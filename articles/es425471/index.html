<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∂Ô∏è üòï üë®üèæ‚ÄçüöÄ Trabajando con im√°genes en Python ü•É üí£ üëí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El tema de la conversaci√≥n de hoy es lo que Python ha aprendido durante todos los a√±os de su existencia al trabajar con im√°genes. De hecho, adem√°s de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabajando con im√°genes en Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/425471/">  El tema de la conversaci√≥n de hoy es lo que Python ha aprendido durante todos los a√±os de su existencia al trabajar con im√°genes.  De hecho, adem√°s de los viejos tiempos de ImageMagick y GraphicsMagick de 1990, existen bibliotecas modernas y efectivas.  Por ejemplo, Pillow y Pillow-SIMD m√°s productivo.  Su desarrollador activo Alexander Karpinsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">homm</a> ) en MoscowPython compar√≥ diferentes bibliotecas para trabajar con im√°genes en Python, present√≥ puntos de referencia y habl√≥ sobre caracter√≠sticas no obvias que siempre son suficientes.  En este art√≠culo, una transcripci√≥n del informe lo ayudar√° a elegir una biblioteca para su aplicaci√≥n y a que funcione de la manera m√°s eficiente posible. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CZ99Q0DQq3Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre el orador:</strong> Alexander Karpinsky trabaja en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uploadcare</a> y se dedica al servicio de modificaci√≥n r√°pida de im√°genes sobre la marcha.  Est√° involucrado en el desarrollo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pillow</a> , una biblioteca popular para trabajar con im√°genes en Python, y est√° desarrollando su propia bifurcaci√≥n de esta biblioteca, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pillow-SIMD</a> , que utiliza instrucciones modernas de procesador para obtener el m√°ximo rendimiento. <br><a name="habracut"></a><br><h2>  Antecedentes <br></h2><br>  El servicio de modificaci√≥n de im√°genes de Uploadcare es un servidor que recibe una solicitud HTTP con un identificador de imagen y algunas operaciones que un cliente debe realizar.  El servidor debe completar las operaciones y responder lo m√°s r√°pido posible.  El cliente m√°s a menudo act√∫a como un navegador. <br><br>  Todo el servicio se puede describir como un contenedor alrededor de la biblioteca de gr√°ficos.  La calidad de todo el proyecto depende de la calidad, el rendimiento y la usabilidad de la biblioteca de gr√°ficos.  Es f√°cil adivinar que Uploadcare usa Pillow como una biblioteca de gr√°ficos. <br><br><h2>  Bibliotecas <br></h2><br>  Revisaremos brevemente qu√© tipo de bibliotecas de gr√°ficos hay en general en Python para comprender mejor lo que se discutir√° m√°s adelante. <br><br><h3>  Almohada <br></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Almohada</a> - tenedor de PIL (Python Imaging Library).  Este es un proyecto muy antiguo, lanzado en 1995 para Python 1.2.  ¬°Puedes imaginar cu√°ntos a√±os tiene!  En alg√∫n momento, la biblioteca de im√°genes de Python fue abandonada y su desarrollo se detuvo.  Se hizo una bifurcaci√≥n de Pillow para instalar y construir la Biblioteca de im√°genes de Python en sistemas modernos.  Gradualmente, la cantidad de cambios que las personas necesitaban en la Biblioteca de im√°genes de Python creci√≥, y sali√≥ Pillow 2.0, que agreg√≥ soporte para Python 3. Esto puede considerarse el comienzo de una vida separada del proyecto Pillow. <br><br>  Pillow es un m√≥dulo nativo para Python, la mitad del c√≥digo est√° escrito en C, la otra mitad en Python.  Se admiten las versiones m√°s diversas de Python: 2.7, 3.3+, PP, . <br><br><h3>  Pillow-SIMD <br></h3><br>  Este es mi tenedor de Pillow, que sale en mayo de 2016.  SIMD son las siglas de Single Instruction, Multiple Data <strong>&nbsp;</strong>  - Un enfoque en el que el procesador puede realizar una mayor cantidad de acciones por ciclo utilizando instrucciones modernas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pillow-SIMD</a> no es una bifurcaci√≥n en el sentido cl√°sico cuando un proyecto comienza a vivir su propia vida.  Este es un reemplazo para Pillow, es decir, instala una biblioteca en lugar de otra, no cambia una l√≠nea en su c√≥digo fuente y obtiene m√°s rendimiento. <br><br>  Pillow-SIMD se puede ensamblar con instrucciones SSE4 (predeterminado).  Este es un conjunto de instrucciones que se encuentra en casi todos los procesadores x86 modernos.  Pillow-SIMD tambi√©n se puede ensamblar con el conjunto de instrucciones AVX2.  Este conjunto de instrucciones es, comenzando con la arquitectura Haswell, es decir, aproximadamente desde 2013. <br><br><h3>  OpenCV <br></h3><br>  Otra biblioteca para trabajar con im√°genes en Python de la que probablemente haya o√≠do hablar es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenCV</a> (Open Computer Vision).  Ha estado trabajando desde 2000.  El enlace de Python est√° incluido.  Esto significa que el enlace es constantemente relevante, no hay sincron√≠a entre la biblioteca en s√≠ y el enlace. <br><br>  Desafortunadamente, esta biblioteca a√∫n no es compatible con PyPy, porque OpenCV se basa en numpy, y numpy solo recientemente comenz√≥ a trabajar en PyPy, y PyC a√∫n no es compatible con OpenCV. <br><br><h3>  VIPS <br></h3><br>  Otra biblioteca a la que vale la pena prestarle atenci√≥n es VIPS.  La idea principal de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VIPS</a> es que no necesita cargar toda la imagen en la memoria para trabajar con la imagen.  La biblioteca puede cargar algunas piezas peque√±as, procesarlas y guardarlas.  Por lo tanto, para procesar im√°genes de gigap√≠xeles, no necesita gastar gigabytes de memoria. <br><br>  Esta es una biblioteca bastante antigua - 1993, pero super√≥ su tiempo.  Durante mucho tiempo se escuch√≥ poco al respecto, pero recientemente comenzaron a aparecer carpetas de VIPS para varios idiomas, incluidos Go, Node.js, Ruby. <br><br>  Durante mucho tiempo quise probar esta biblioteca, sentirla, pero no tuve √©xito por una raz√≥n muy est√∫pida.  No pude averiguar c√≥mo instalar VIPS, porque el enlace era muy complicado.  Pero ahora (en 2017) el autor del VIPS lanz√≥ el enlace pyvips, con el que ya no hay problemas.  Instalar y usar VIPS ahora es muy f√°cil.  Compatible: Python 2.7, 3.3+, RuPu, RuPuZ. <br><br><h3>  ImageMagick &amp; GraphicsMagick <br></h3><br>  Si hablamos de trabajar con gr√°ficos, no podemos dejar de mencionar a las personas mayores: las bibliotecas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ImageMagick</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GraphicsMagick</a> .  Originalmente, este √∫ltimo era una bifurcaci√≥n de ImageMagick con mayor rendimiento, pero ahora su rendimiento parece ser igual.  Que yo sepa, no hay otras diferencias fundamentales entre ellos.  Por lo tanto, puede usar cualquiera, m√°s precisamente, el que prefiera usar. <br><br>  Estas son las bibliotecas m√°s antiguas que mencion√© hoy (1990).  Durante todo este tiempo, hubo varios aglutinantes para Python, y casi todos ya han muerto con seguridad.  De los que se pueden usar, hay: <br><br><ul><li>  Enlace de varita, que se basa en ctypes, pero que ya no se actualiza. </li><li>  El enlace pgmagick usa Boost.Python, por lo que se compila durante mucho tiempo y no funciona en PyPy.  Pero, sin embargo, puedes usarlo, dir√≠a que es preferible a Wand. </li></ul><br><h2>  Rendimiento <br></h2><br>  Cuando hablamos de trabajar con im√°genes, lo primero que nos interesa (al menos para m√≠) es el rendimiento, porque de lo contrario podr√≠amos escribir algo en Python con nuestras manos. <br><br>  El rendimiento no es tan simple.  No puedes decir que una biblioteca es m√°s r√°pida que otra.  Cada biblioteca tiene un conjunto de funciones, y cada funci√≥n funciona a una velocidad diferente. <br><br>  En consecuencia, es correcto decir solo que el rendimiento de una funci√≥n es mayor o menor en una biblioteca particular.  O tiene una aplicaci√≥n que necesita un cierto conjunto de funcionalidades, y hace un punto de referencia espec√≠ficamente para esta funcionalidad, y dice que tal y tal biblioteca funciona m√°s r√°pido (m√°s lento) para su aplicaci√≥n. <br><br><h3>  Es importante verificar el resultado. <br></h3><br>  Cuando hace puntos de referencia, es muy importante observar el resultado obtenido.  Incluso si a primera vista escribi√≥ el mismo c√≥digo, esto no significa que sea el mismo. <br><br>  Recientemente, en un art√≠culo que compara el rendimiento de Pillow y OpenCV, me encontr√© con este c√≥digo: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFilter.BoxBlur im.filter(ImageFilter.BoxBlur(<span class="hljs-number"><span class="hljs-number">3</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 cv2.blur(im, ksize=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) ...</code> </pre> <br>  Parece estar all√≠, y all√≠, BoxBlur, y all√≠, y all√≠, argumento 3, pero de hecho el resultado es diferente.  Porque en Pillow (3) este es el radio de desenfoque, y en OpenCV ksize = (3, 3) es el tama√±o del n√∫cleo, es decir, en t√©rminos generales, el di√°metro.  En este caso, el valor correcto para OpenCV ser√≠a 3 * 2 + 1, es decir (7, 7). <br><br><h3>  Cual es el problema <br></h3><br>  ¬øPor qu√© el rendimiento generalmente es un problema cuando se trabaja con gr√°ficos?  Debido a que la complejidad de cualquier operaci√≥n depende de varios par√°metros, y la mayor√≠a de las veces la complejidad crece linealmente con cada uno de ellos.  Y si, por ejemplo, hay tres de estos factores, y la complejidad depende linealmente de cada uno, entonces se obtiene la complejidad en el cubo. <br><br>  <strong>Ejemplo:</strong> desenfoque gaussiano en OpenCV. <br><br><img src="https://habrastorage.org/webt/q5/ea/ut/q5eaut_epivf3abcoh34rdmjsgg.jpeg"><br><br>  A la izquierda hay un radio de 3, a la derecha 30. Como puede ver, la diferencia de velocidad es m√°s de 10 veces. <br><br>  Cuando me enfrent√© a la tarea de agregar desenfoque gaussiano a mi aplicaci√≥n, no estaba contento de que, hipot√©ticamente, se pudieran gastar 900 ms en una operaci√≥n.  Hay miles de tales operaciones por minuto en la aplicaci√≥n, y pasar tanto tiempo en una no es pr√°ctico.  Por lo tanto, estudi√© el problema e implement√© el desenfoque gaussiano en Pillow, que funciona en tiempo constante en relaci√≥n con el radio.  Es decir, solo el tama√±o de la imagen afecta el rendimiento del desenfoque gaussiano. <br><br>  Pero lo principal aqu√≠ no es que algo funcione m√°s r√°pido o m√°s lento. <br><br><blockquote>  Quiero transmitir que cuando est√° creando alg√∫n tipo de sistema, es importante comprender de qu√© par√°metros depende la complejidad de la salida.  Entonces puede limitar estos par√°metros o de otras maneras para lidiar con esta complejidad. <br></blockquote><br>  Probablemente, la operaci√≥n m√°s com√∫n que hacemos con las im√°genes despu√©s de abrirlas es cambiar el tama√±o. <br><br><img src="https://habrastorage.org/webt/ij/-6/xi/ij-6xiharsev-2a89wlcnvun6b0.jpeg"><br><br>  El gr√°fico muestra el rendimiento (m√°s es mejor) de diferentes bibliotecas para la operaci√≥n de reducir la imagen en 8 y 1,25 veces. <br><br>  Para PIL, un resultado de 17 Mpx / s significa que la foto de un iPhone (12 Mpx) se puede reducir 1.25 veces un poco en menos de un segundo.  Tal rendimiento no es suficiente para una aplicaci√≥n seria que realiza muchas de estas operaciones. <br><br>  Comenc√© a optimizar el rendimiento del cambio de tama√±o, y en Pillow 2.7 logr√© lograr un doble aumento en la productividad, y en Pillow 4.3: tres veces (la versi√≥n de Pillow 5.3 es relevante actualmente, pero el rendimiento de cambio de tama√±o es el mismo). <br><br>  Pero la operaci√≥n de cambio de tama√±o es algo que encaja muy bien en SIMD.  Se acerca a una sola instrucci√≥n, a m√∫ltiples datos y, por lo tanto, en la versi√≥n actual de Pillow-SIMD, logr√© <strong>aumentar la velocidad de cambio de tama√±o en 19 veces en</strong> comparaci√≥n con la Biblioteca de im√°genes Python original con los mismos recursos. <br><br>  Esto es significativamente m√°s alto que el rendimiento de cambio de tama√±o de OpenCV.  Pero la comparaci√≥n no es del todo correcta, porque OpenCV utiliza un m√©todo de cambio de tama√±o ligeramente menos de alta calidad con un filtro de caja, y en Pillow-SIMD, el cambio de tama√±o se implementa mediante convoluciones. <br><br>  Esta es una lista incompleta de aquellas operaciones que se aceleran en Pillow-SIMD en comparaci√≥n con Pillow normal. <br><br><ul><li>  Cambiar el tama√±o: 4 a 7 veces. </li><li>  Desenfoque: 2.8 veces. </li><li>  Aplicaci√≥n del n√∫cleo 3 √ó 3 o 5 √ó 5: 11 veces. </li><li>  Multiplicaci√≥n y divisi√≥n por canal alfa: 4 y 10 veces. </li><li>  Composici√≥n alfa: 5 veces. </li></ul><br>  Ya he dicho que no se puede decir que alguna biblioteca funciona m√°s r√°pido que otra, pero puede inventar un conjunto de operaciones que le interesen.  Eleg√≠ un conjunto de operaciones que son interesantes en mi aplicaci√≥n, hice un punto de referencia y obtuve tales resultados. <br><br><img src="https://habrastorage.org/webt/it/_h/hq/it_hhqosz-vm69bg_o8tt8ajddm.jpeg"><br><br>  Result√≥ que Pillow-SIMD en este conjunto funciona 2 veces m√°s r√°pido que Pillow.  Al final est√° Wand (recuerde que esto es ImageMagick). <br><br>  Pero estaba interesado en otra cosa: ¬øpor qu√© OpenCV y VIPS son tan pobres en resultados, porque estas son bibliotecas que tambi√©n est√°n dise√±adas con vistas al rendimiento?  Result√≥ que en el caso de OpenCV, el ensamblado binario de OpenCV que se instala utilizando pip se ensambl√≥ con un c√≥dec JPEG lento (se notific√≥ al autor del ensamblaje, este problema ya se ha resuelto para 2018).  Est√° construido con libjpeg, mientras que la mayor√≠a de los sistemas, al menos basados ‚Äã‚Äãen Debian, usan libjpeg-turbo, que es varias veces m√°s r√°pido.  Si compila OpenCV desde la fuente usted mismo, entonces el rendimiento ser√° mayor. <br><br>  En el caso de VIPS, la situaci√≥n es diferente.  Me puse en contacto con el autor del VIPS, le mostr√© este punto de referencia y nos mantuvimos en contacto durante mucho tiempo y fruct√≠feramente.  Despu√©s de eso, el autor de VIPS encontr√≥ varios lugares en el propio VIPS, donde la ejecuci√≥n no estaba en la ruta √≥ptima, y ‚Äã‚Äãlos corrigi√≥. <br><br>  Eso es lo que suceder√° con el rendimiento si compila OpenCV desde las fuentes de la versi√≥n actual y VIPS desde el maestro, que ya est√° all√≠. <br><br><img src="https://habrastorage.org/webt/m2/kg/o8/m2kgo8agnblbu9tsc5nw5fonyfk.jpeg"><br><blockquote>  Incluso si encuentra alg√∫n tipo de punto de referencia, no es un hecho que todo funcione con esta velocidad exactamente en su m√°quina. <br></blockquote><br><h3>  Conjunto de puntos de referencia <br></h3><br>  Todos los puntos de referencia de los que habl√© se pueden encontrar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la p√°gina de resultados</a> .  Este es un mini-proyecto separado donde escribo puntos de referencia que yo mismo necesito para desarrollar Pillow-SIMD, ejecutarlos y publicar los resultados. <br><br>  GitHub tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> con marcos de prueba donde todos pueden ofrecer sus propios puntos de referencia o corregir los existentes. <br><br><h2>  Trabajo paralelo <br></h2><br>  Hasta ahora he estado hablando de rendimiento puro, es decir, en un solo n√∫cleo de procesador.  Pero todos hemos tenido acceso a sistemas con m√°s n√∫cleos, y me gustar√≠a deshacerme de ellos.  Aqu√≠ tengo que decir que, de hecho, Pillow es la √∫nica biblioteca de todas que no utiliza la paralelizaci√≥n de tareas.  Tratar√© de explicar por qu√© sucede esto.  Todas las dem√°s bibliotecas de una forma u otra lo usan. <br><br><h3>  M√©tricas de rendimiento <br></h3><br>  En t√©rminos de rendimiento, estamos interesados ‚Äã‚Äãen 2 par√°metros: <br><br><ol><li>  <strong>Tiempo real de ejecuci√≥n de una operaci√≥n.</strong>  Hay una operaci√≥n (o una secuencia de operaciones), y usted se pregunta en qu√© tiempo real (reloj de pared) se ejecutar√° esta secuencia.  Este par√°metro es importante en el escritorio, donde hay un usuario que dio el comando y est√° esperando el resultado. <br></li><li>  <strong>Rendimiento de todo el sistema</strong> (flujo de trabajo).  Cuando tiene un conjunto de operaciones en curso, o muchas operaciones independientes, y la velocidad de procesamiento de estas operaciones en su hardware es importante para usted.  Esta m√©trica es m√°s importante en un servidor donde hay muchos clientes y necesita atenderlos a todos.  El tiempo que lleva servir a un cliente es importante, por supuesto, pero un poco menos que el ancho de banda total. <br></li></ol><br>  En base a estas dos m√©tricas, consideramos diferentes formas de operaci√≥n paralela. <br><br><h3>  M√©todos de trabajo en paralelo <br></h3><br>  1. <strong>A nivel de aplicaci√≥n</strong> , cuando decide a nivel de aplicaci√≥n que las operaciones se procesan en diferentes subprocesos.  Al mismo tiempo, el tiempo de ejecuci√≥n real de una operaci√≥n no cambia, porque como antes, un n√∫cleo est√° ocupado en una secuencia de operaciones.  La capacidad del sistema aumenta en proporci√≥n al n√∫mero de n√∫cleos, es decir, muy bueno. <br><br>  2. <strong>En el nivel de las operaciones gr√°ficas</strong> , eso es exactamente lo que se encuentra en la mayor√≠a de las bibliotecas gr√°ficas.  Cuando una biblioteca gr√°fica recibe alg√∫n tipo de operaci√≥n, crea la cantidad necesaria de subprocesos dentro de s√≠ misma, divide una operaci√≥n en varias m√°s peque√±as y las realiza.  Al mismo tiempo, se reduce el tiempo de ejecuci√≥n real: una operaci√≥n es m√°s r√°pida.  Pero el <strong>rendimiento no crece linealmente</strong> con el n√∫mero de n√∫cleos.  Hay operaciones que no son paralelas, y un ejemplo sorprendente es la decodificaci√≥n de archivos PNG: no se puede paralelizar de ninguna manera.  Adem√°s, hay gastos generales para crear subprocesos, dividir tareas, que tampoco permiten que el ancho de banda crezca linealmente. <br><br>  3. <strong>A nivel de comandos y datos del procesador</strong> .  Preparamos los datos de una manera especial y utilizamos comandos especiales para que el procesador trabaje con ellos m√°s r√°pido.  Este es el enfoque SIMD, que, de hecho, se utiliza en Pillow-SIMD.  El tiempo de ejecuci√≥n en tiempo real est√° disminuyendo, el rendimiento est√° aumentando: <strong>esta</strong> es <strong>una opci√≥n de ganar-ganar</strong> . <br><br><h3>  C√≥mo combinar trabajo paralelo <br></h3><br>  Si queremos combinar de alguna manera el trabajo paralelo, SIMD funciona bien con la paralelizaci√≥n dentro de una operaci√≥n, y SIMD funciona bien con la paralelizaci√≥n dentro de una aplicaci√≥n. <br><img src="https://habrastorage.org/webt/3z/pa/lo/3zpaloqfeh6cczwlz8zlk5s33lc.jpeg"><br>  Pero la paralelizaci√≥n dentro de la aplicaci√≥n y dentro de la operaci√≥n no son compatibles entre s√≠.  Si intentas hacer esto, obtendr√°s desventajas de ambos enfoques.  El tiempo real de la operaci√≥n ser√° el mismo que en un n√∫cleo, y el rendimiento del sistema aumentar√°, pero no linealmente con respecto al n√∫mero de n√∫cleos. <br><br><h3>  Multithreading <br></h3><br>  Si estamos hablando de hilos, todos escribimos en Python y sabemos que tiene un GIL que evita que dos hilos se ejecuten al mismo tiempo.  Python es un lenguaje estrictamente de un solo subproceso. <br><br>  Por supuesto, esto no es cierto, porque el GIL realmente evita que dos hilos se ejecuten en Python, y si el c√≥digo est√° escrito en otro idioma y no usa estructuras internas de Python durante su operaci√≥n, este c√≥digo puede liberar el GIL y as√≠ liberar al int√©rprete para otras tareas <br><br>  Muchas bibliotecas de gr√°ficos lanzan GIL durante su trabajo, incluidas Pillow, OpenCV, pyvips, Wand.  Solo un pgmagick no libera.  Es decir, puede crear hilos de manera segura para realizar algunas operaciones, y esto funcionar√° en paralelo con el resto del c√≥digo. <br><br>  Pero surge la pregunta: <strong>¬øcu√°ntos hilos crear?</strong> <br><br>  Si creamos un n√∫mero infinito de subprocesos para cada tarea que tenemos, entonces simplemente ocupan toda la memoria y todo el procesador; no obtendremos ning√∫n trabajo efectivo.  Formul√© una regla especial. <br><br><blockquote>  <strong>Regla N + 1</strong> <br><br>  Para un trabajo productivo, debe crear no m√°s de N + 1 trabajadores, donde N es el n√∫mero de n√∫cleos o subprocesos del procesador en la m√°quina, y el trabajador es el proceso o subproceso involucrado en el procesamiento. <br></blockquote><br>  Los procesos se utilizan mejor, porque incluso dentro del mismo int√©rprete hay cuellos de botella y gastos generales. <br><br>  Por ejemplo, en nuestra aplicaci√≥n, se utiliza Tornado de instancia N + 1, el equilibrio entre los cuales se lleva a cabo ngnix.  Si se menciona Tornado, entonces hablemos de la operaci√≥n asincr√≥nica. <br><br><h2>  Operaci√≥n asincr√≥nica <br></h2><br>  El tiempo que la biblioteca gr√°fica hace realmente un trabajo √∫til (procesamiento de im√°genes) puede y debe usarse para entrada / salida, si los tiene en la aplicaci√≥n.  Los marcos asincr√≥nicos son muy relevantes aqu√≠. <br><br>  Pero hay un problema: cuando llamamos a alg√∫n tipo de procesamiento, se llama sincr√≥nicamente.  Incluso si la biblioteca libera el GIL en ese momento, el bucle de eventos todav√≠a est√° bloqueado. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.coroutine def get(self, *args, **kwargs): im = process_image(...) ...</span></span></code> </pre><br>  Afortunadamente, este problema es muy f√°cil de resolver creando un ThreadPoolExecutor con un solo hilo en el que comienza el procesamiento de la imagen.  Esta llamada ya est√° ocurriendo de forma asincr√≥nica. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@run_on_executor(executor=ThreadPoolExecutor(1)) def process_image(self, ... @gen.coroutine def get(self, *args, **kwargs): im = yield process_image(...) ...</span></span></code> </pre><br>  En esencia, aqu√≠ se crea una cola con un trabajador que realiza operaciones gr√°ficas, y el bucle de eventos no se bloquea y se ejecuta silenciosamente en paralelo en otro subproceso. <br><br><h2>  Entrada / salida <br></h2><br>  Otro tema que me gustar√≠a abordar en la discusi√≥n de las operaciones gr√°ficas es la entrada / salida.  El hecho es que rara vez creamos ning√∫n tipo de imagen usando una biblioteca de gr√°ficos.  Muy a menudo, abrimos im√°genes que nos han llegado los usuarios en forma de archivos codificados (JPEG, PNG, BMP, TIFF, etc.). <br><br>  En consecuencia, la biblioteca de gr√°ficos para construir una buena aplicaci√≥n deber√≠a tener algunas ventajas para la entrada / salida de los archivos. <br><br><h3>  Carga perezosa <br></h3><br>  El primero de esos bollos es la carga perezosa.  Si, por ejemplo, en Pillow abre una imagen, en este momento no se produce la decodificaci√≥n de la imagen.  Volver√° con un objeto que parece que la imagen ya est√° cargada y funcionando.  Puede ver sus propiedades y decidir sobre la base de las propiedades de esta imagen si est√° listo para trabajar con ella m√°s y si el usuario ha cargado, por ejemplo, una imagen de gigap√≠xeles para interrumpir su servicio. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>))</code> </pre><br>  Si decide qu√© hacer a continuaci√≥n, utilizando la llamada expl√≠cita o impl√≠cita para cargar, esta imagen se decodifica.  Ya en este momento se asigna la cantidad necesaria de memoria. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>)) &gt;&gt;&gt; %time im.load() Wall time: <span class="hljs-number"><span class="hljs-number">73.6</span></span> ms</code> </pre><br><h3>  Modo de imagen rota <br></h3><br>  El segundo bollo que se necesita cuando se trabaja con contenido generado por el usuario es el modo de imagen rota.  Los archivos que recibimos de los usuarios a menudo contienen algunas inconsistencias con el formato en el que est√°n codificados. <br><br>  Estas discrepancias ocurren por varias razones.  A veces, estos son errores de transmisi√≥n a trav√©s de la red, a veces son solo una especie de c√≥decs torcidos que codifican la imagen.  Por defecto, Pillow, cuando ve im√°genes que no se ajustan al formato hasta el final, solo lanza una excepci√≥n. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>) IOError: image file <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> truncated (<span class="hljs-number"><span class="hljs-number">143</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> processed)</code> </pre><br>  Pero el usuario no tiene la culpa del hecho de que su imagen est√° rota, todav√≠a quiere obtener el resultado.  Afortunadamente, Pillow tiene un modo de imagen rota.  Cambiamos una configuraci√≥n, y Pillow intenta ignorar al m√°ximo todos los errores de decodificaci√≥n que est√°n en la imagen.  En consecuencia, el usuario ve al menos algo. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFile ImageFile.LOAD_TRUNCATED_IMAGES = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/cm/jq/ju/cmjqjuopb_ct8wqinkaaeaw0bbc.jpeg"><br><br>  Incluso una imagen recortada es mejor que nada, solo una p√°gina con un error. <br><br><h3>  Tabla resumen <br></h3><br><img src="https://habrastorage.org/webt/zn/p3/yp/znp3ypfris3rbtkmok83gcyvup8.jpeg"><br><br>  En la tabla anterior, he recopilado todo lo relacionado con la entrada / salida en las bibliotecas de las que estoy hablando.  En particular, cont√© la cantidad de c√≥decs de varios formatos que est√°n en las bibliotecas.  Result√≥ que en OpenCV son los menos, en ImageMagick, la mayor√≠a.  Parece que en ImageMagick puedes abrir cualquier imagen que encuentres.  VIPS tiene 12 c√≥decs nativos, pero VIPS puede usar ImageMagick como intermediario.  No he probado c√≥mo funciona esto, espero que sea perfecto. <br><br>  La almohada tiene 17 c√≥decs.  Esta es ahora la √∫nica biblioteca en la que no hay rotaci√≥n autom√°tica EXIF.  Pero ahora este es un peque√±o problema, porque puede leer EXIF ‚Äã‚Äãusted mismo y rotar la imagen de acuerdo con √©l.  Se trata de un peque√±o fragmento, que es f√°cilmente google y toma un m√°ximo de 20 l√≠neas. <br><br><h3>  Caracter√≠sticas de OpenCV <br></h3><br>  Si observa esta tabla con cuidado, puede ver que en OpenCV, de hecho, no todo es tan bueno con la entrada / salida.  Tiene la menor cantidad de c√≥decs, no tiene carga lenta y no puede leer EXIF ‚Äã‚Äãy el perfil de color. <br><br>  Pero eso no es todo.  De hecho, OpenCV tiene m√°s caracter√≠sticas.  Cuando simplemente abrimos una imagen, la <code>cv2.imread(filename)</code> gira los archivos JPEG de acuerdo con EXIF ‚Äã‚Äã(vea la tabla), pero ignora el canal alfa de los archivos PNG, ¬°un comportamiento bastante extra√±o! <br><br>  Afortunadamente, OpenCV tiene una bandera: <code>cv2.imread(filename, flags=cv2.IMREAD_UNCHANGED)</code> . <br><br>  Si especifica el indicador IMREAD_UNCHANGED, OpenCV deja el canal alfa para los archivos PNG, pero deja de convertir los archivos JPEG de acuerdo con EXIF.  Es decir, la misma bandera afecta a dos propiedades completamente diferentes.  Como se puede ver en la tabla, OpenCV no tiene la capacidad de leer EXIF, y resulta que en el caso de este indicador es imposible rotar JPEG en absoluto. <br><br>  ¬øQu√© sucede si no sabe de antemano qu√© formato tiene su imagen y necesita tanto el canal alfa para PNG como la rotaci√≥n autom√°tica para JPEG?  Nada que hacer: OpenCV no funciona as√≠. <br><br>  La raz√≥n por la cual OpenCV tiene tales problemas radica en el nombre de esta biblioteca.  Tiene mucha funcionalidad para la visi√≥n por computadora y el an√°lisis de im√°genes.  De hecho, OpenCV est√° dise√±ado para trabajar con fuentes verificadas.  Esta es, por ejemplo, una c√°mara de vigilancia para exteriores que toma im√°genes una vez por segundo y lo hace durante 5 a√±os en el mismo formato y la misma resoluci√≥n.  No hay necesidad de variabilidad en el problema de E / S. <br><br>  Las personas que necesitan la funcionalidad OpenCV realmente no necesitan la funcionalidad del contenido del usuario. <br><br>  Pero, ¬øqu√© sucede si su aplicaci√≥n a√∫n necesita funcionalidad para trabajar con el contenido del usuario y, al mismo tiempo, necesita toda la potencia de OpenCV para el procesamiento y las estad√≠sticas? <br><br><img src="https://habrastorage.org/webt/2g/2o/mu/2g2omu98a18hv0gzr4387egsj6s.jpeg"><br><br>  La soluci√≥n es combinar bibliotecas.  El hecho es que OpenCV se basa en numpy, y Pillow tiene todos los medios para exportar im√°genes de Pillow a una matriz numpy.  Es decir, exportamos la matriz numpy, y OpenCV puede continuar trabajando con esta imagen, como con la suya.  Esto se hace muy f√°cilmente: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.open(filename) cv_image = numpy.array(pillow_image)</code> </pre><br>  Adem√°s, cuando hacemos magia usando OpenCV (procesamiento), llamamos a otro m√©todo Pillow e importamos la imagen de OpenCV nuevamente al formato Pillow.  En consecuencia, se puede volver a utilizar E / S. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.fromarray(cv_image, <span class="hljs-string"><span class="hljs-string">"RGB"</span></span>) pillow_image.save(filename)</code> </pre><br>  Por lo tanto, resulta que usamos entrada / salida de Pillow, y el procesamiento de OpenCV, es decir, tomamos lo mejor de los dos mundos. <br><br>  Espero que esto te ayude a construir una aplicaci√≥n de gr√°ficos cargada. <br><br><blockquote>  Puede aprender algunos otros secretos de desarrollo en Python, aprender de una experiencia invaluable ya veces inesperada, y lo m√°s importante, puede discutir sus tareas muy pronto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moscow Python Conf ++</a> .  Por ejemplo, preste atenci√≥n a dichos nombres y temas en la programaci√≥n. <br><br><ul><li>  Donald Whyte cuenta una historia sobre c√≥mo hacer que las matem√°ticas sean 10 veces m√°s r√°pidas utilizando bibliotecas populares, trucos y astucia, y el c√≥digo es comprensible y compatible. </li><li>  Andrei Popov se trata de recopilar una gran cantidad de datos y analizarlos en busca de amenazas. </li><li>  Ephraim Matosyan en su informe "Haga que Python vuelva a ser r√°pido" le dir√° c√≥mo aumentar el rendimiento del demonio que procesa los mensajes desde el bus. </li></ul><br>  Una lista completa de lo que se discutir√° para el 22 y 23 de octubre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> , tiene tiempo para unirse. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425471/">https://habr.com/ru/post/es425471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425461/index.html">Devops y seguridad: entrevistas con Seth Wargo y Liz Rice</a></li>
<li><a href="../es425463/index.html">Mapas de Unity Hexagon: Agua, Monumentos y Muros de Fortaleza</a></li>
<li><a href="../es425465/index.html">C√≥mo un dise√±ador puede ganar m√°s, una herramienta ideal para trabajar y buscar ideas</a></li>
<li><a href="../es425467/index.html">Motores Renault D4F> B4D (tambi√©n conocido como SCe). Cambio generacional. Mirada motorista</a></li>
<li><a href="../es425469/index.html">El autor de Python ya no lidera el desarrollo. ¬øMejorar√° o empeorar√° el idioma?</a></li>
<li><a href="../es425473/index.html">Conferencia sobre Python y sobre comunicaci√≥n.</a></li>
<li><a href="../es425475/index.html">Robots colaborativos de Universal Robots en IMTS 2018 en Chicago</a></li>
<li><a href="../es425477/index.html">Seminarios web de Skillbox Friday: desde elegir un lenguaje de programaci√≥n hasta encontrar su empresa</a></li>
<li><a href="../es425479/index.html">Pronto la mitad de las llamadas ser√°n de robots. Consejo: no conteste (?)</a></li>
<li><a href="../es425483/index.html">Lectura de fin de semana: 22 art√≠culos sobre la historia de legendarias compa√±√≠as de audio y c√≥mo "hacen sonido"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>