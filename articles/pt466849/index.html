<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò∏Ô∏è üìò üöµüèª noexcept-ctcheck ou algumas macros simples para ajudar o compilador a escrever c√≥digo noexcept üëáüèº üòº üë®üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao desenvolver em C ++, voc√™ deve escrever c√≥digo periodicamente, no qual exce√ß√µes n√£o devem ocorrer. Por exemplo, quando precisamos escrever uma troc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>noexcept-ctcheck ou algumas macros simples para ajudar o compilador a escrever c√≥digo noexcept</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466849/"><p>  Ao desenvolver em C ++, voc√™ deve escrever c√≥digo periodicamente, no qual exce√ß√µes n√£o devem ocorrer.  Por exemplo, quando precisamos escrever uma troca sem exce√ß√£o para tipos nativos ou definir uma instru√ß√£o move noexcept para nossa classe, ou implementar manualmente um destruidor n√£o trivial. </p><br><p>  No C ++ 11, o modificador noexcept foi adicionado √† linguagem, o que permite ao desenvolvedor entender que as exce√ß√µes da fun√ß√£o (ou m√©todo) marcadas com noexcept n√£o podem ser descartadas.  Portanto, fun√ß√µes com essa marca podem ser usadas com seguran√ßa em contextos onde as exce√ß√µes n√£o devem surgir. </p><br><p>  Por exemplo, se eu tiver esses tipos e fun√ß√µes: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_resource &amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_resource &amp; r)</span></span></span></span>;</code> </pre> <br><p>  e h√° uma certa classe <code>resources_owner</code> que possui objetos como <code>first_resource</code> e <code>second_resource</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources_owner</span></span></span><span class="hljs-class"> {</span></span> first_resource first_resource_; second_resource second_resource_; ... };</code> </pre> <br><p>  ent√£o eu posso escrever o destruidor <code>resources_owner</code> seguinte maneira: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release()   ,    . release(first_resource_); //    close()   ,  //   try-catch. try{ close(second_resource_); } catch(...) {} }</span></span></code> </pre> <br><p>  De certa forma, no exceto em C ++ 11, a vida de um desenvolvedor de C ++ foi mais f√°cil.  Mas a implementa√ß√£o atual, exceto no C ++ moderno, tem um lado desagrad√°vel ... </p><br><h1 id="kompilyator-ne-pomogaet-kontrolirovat-soderzhimoe-noexcept-funkciy-i-metodov">  O compilador n√£o ajuda a controlar o conte√∫do de fun√ß√µes e m√©todos noexcept </h1><a name="habracut"></a><br><p>  Suponha que no exemplo acima eu tenha me enganado: por alguma raz√£o, considerei <code>release()</code> marcado como noexcept, mas, na realidade, n√£o √© e pode gerar exce√ß√µes.  Isso significa que, quando escrevo um destruidor usando uma <code>release()</code> : </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { release(first_resource_); <span class="hljs-comment"><span class="hljs-comment">//  try-catch   ... }</span></span></code> </pre> <br><p>  ent√£o eu imploro por problemas.  Mais cedo ou mais tarde, este <code>release()</code> lan√ßar√° uma exce√ß√£o e todo o meu aplicativo falhar√° devido ao chamado automaticamente <code>std::terminate()</code> .  Ser√° ainda pior se meu aplicativo n√£o travar, mas o de outra pessoa, na qual eles usaram minha biblioteca com um destruidor t√£o problem√°tico para o <code>resources_owner</code> . </p><br><p>  Ou outra varia√ß√£o do mesmo problema.  Suponha que n√£o me enganei que <code>release()</code> fato marcado como sem exce√ß√£o.  Foi sim </p><br><p>  Foi marcado na vers√£o 1.0 de uma biblioteca de terceiros da qual tirei <code>first_resource</code> e <code>release()</code> .  E, depois de v√°rios anos, atualizei para a vers√£o 3.0 desta biblioteca, mas na vers√£o 3.0, <code>release()</code> n√£o possui mais um modificador noexcept. </p><br><p>  Bem o que?  A nova vers√£o principal, eles poderiam facilmente quebrar a API. </p><br><p>  Somente agora, provavelmente, vou me esquecer de corrigir a implementa√ß√£o do destruidor <code>resources_owner</code> .  E se, em vez de mim, algu√©m estiver envolvido no suporte ao <code>resource_owner</code> , que nunca examinou esse destruidor, as altera√ß√µes na assinatura do <code>release()</code> provavelmente passar√£o despercebidas. </p><br><p>  Portanto, eu pessoalmente n√£o gosto do fato de o compilador n√£o avisar o programador de forma alguma que o programador dentro do m√©todo / fun√ß√£o noexcept fa√ßa uma chamada de m√©todo / fun√ß√£o que lan√ßa exce√ß√µes. </p><br><p>  Seria melhor se o compilador emitisse esses avisos. </p><br><h1 id="spasenie-utopayuschih-delo-ruk-samih-utopayuschih">  O resgate do afogamento √© obra dos pr√≥prios afogamentos </h1><br><p>  OK, o compilador n√£o d√° nenhum aviso.  E nada pode ser feito sobre esse desenvolvedor simples.  N√£o lide com modifica√ß√µes do compilador C ++ para suas pr√≥prias necessidades.  Especialmente se voc√™ precisar usar n√£o um compilador, mas vers√µes diferentes de diferentes compiladores C ++. </p><br><p>  √â poss√≠vel obter ajuda do compilador sem entrar em suas miudezas?  I.e.  √â poss√≠vel fazer algum tipo de ferramenta para controlar o conte√∫do de m√©todos / fun√ß√µes sem exce√ß√£o, mesmo que o m√©todo dendro-fecal? </p><br><p>  Voc√™ pode.  Desleixado, mas poss√≠vel. </p><br><h1 id="otkuda-nogi-rastut">  De onde as pernas crescem? </h1><br><p>  A abordagem descrita neste artigo foi testada na pr√°tica ao preparar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√≥xima vers√£o do nosso pequeno servidor HTTP incorporado RESTinio</a> . </p><br><p>  O fato √© que, como o RESTinio est√° cheio de funcionalidades, perdemos de vista os problemas de seguran√ßa de exce√ß√£o em v√°rios locais.  Em particular, com o tempo, ficou claro que, √†s vezes, as exce√ß√µes podem surgir dos retornos de chamada enviados ao Asio (o que n√£o deveria ser), bem como as exce√ß√µes, em princ√≠pio, podem ocorrer durante a limpeza de recursos. </p><br><p>  Felizmente, na pr√°tica, esses problemas nunca foram manifestados, mas a d√≠vida t√©cnica se acumulou e algo teve que ser feito a respeito.  E voc√™ tinha que fazer algo com o c√≥digo que j√° estava escrito.  I.e.  c√≥digo n√£o-exce√ß√£o de trabalho deve ser convertido em c√≥digo n√£o-exce√ß√£o de trabalho. </p><br><p>  Isso foi feito com a ajuda de v√°rias macros, organizadas por c√≥digo nos lugares certos.  Por exemplo, um caso trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Message_Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trigger_error_and_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Message_Builder msg_builder )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// An exception from logger/msg_builder shouldn't prevent // a call to close(). restinio::utils::log_error_noexcept( m_logger, std::move(msg_builder) ); RESTINIO_ENSURE_NOEXCEPT_CALL( close() ); }</span></span></code> </pre> <br><p>  E aqui est√° um fragmento menos trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.empty()); RESTINIO_STATIC_ASSERT_NOEXCEPT( m_context_table.pop_response_context_nonchecked()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front().dequeue_group()); RESTINIO_STATIC_ASSERT_NOEXCEPT(make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; !m_context_table.empty(); m_context_table.pop_response_context_nonchecked() ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; current_ctx = m_context_table.front(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !current_ctx.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wg = current_ctx.dequeue_group(); restinio::utils::suppress_exceptions_quietly( [&amp;] { wg.invoke_after_write_notificator_if_exists( ec ); } ); } } }</code> </pre> <br><p>  O uso dessas macros apertou as m√£os v√°rias vezes, apontando para lugares que eu inadvertidamente havia percebido como n√£o-aceit√°veis, mas que n√£o eram. </p><br><p>  Portanto, a abordagem descrita abaixo, √© claro, √© um auto-fabricado com rodas quadradas, mas continua ... quero dizer que funciona. </p><br><p>  Ainda neste artigo, discutiremos a implementa√ß√£o que foi isolada do c√≥digo RESTinio em um conjunto separado de macros. </p><br><h1 id="sut-podhoda">  A ess√™ncia da abordagem </h1><br><p>  A ess√™ncia da abordagem √© passar a instru√ß√£o / operador (stmt), que precisa ser verificada quanto √† exce√ß√£o, para uma determinada macro.  Essa macro usa <code>static_assert(noexcept(stmt), msg)</code> para verificar se stmt √© realmente noexcept e, em seguida, substitui stmt no c√≥digo. </p><br><p>  Essencialmente, isto √©: </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  ser√° substitu√≠do por algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><h2 id="pochemu-byl-sdelan-vybor-v-polzu-makrosov">  Por que a escolha foi feita em favor das macros? </h2><br><p>  Em princ√≠pio, era poss√≠vel <code>static_assert(noexcept(...))</code> sem macros e escrever <code>static_assert(noexcept(...))</code> no c√≥digo imediatamente antes das a√ß√µes serem verificadas.  Mas as macros t√™m pelo menos algumas virtudes que inclinam a balan√ßa a favor do uso espec√≠fico de macros. </p><br><p>  Primeiro, as macros reduzem a duplica√ß√£o de c√≥digo.  H√° uma compara√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><p>  e </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  √© claro que, com macros, a express√£o principal, ou seja,  <code>release(some_resource)</code> pode ser gravado apenas uma vez.  Isso reduz a probabilidade de o c√≥digo "rastejar" ao longo do tempo, com seu acompanhamento, quando uma corre√ß√£o foi feita em um local e esquecida no segundo. </p><br><p>  Em segundo lugar, as macros e, consequentemente, as verifica√ß√µes ocultas por tr√°s delas podem ser facilmente desabilitadas.  Digamos, se a abund√¢ncia de static_assert-s come√ßar a afetar adversamente a velocidade de compila√ß√£o (embora eu n√£o tenha notado esse efeito).  Ou, mais importante, ao atualizar algumas bibliotecas de terceiros, os erros de compila√ß√£o de static_assert ocultos atr√°s das macros podem polvilhar diretamente com o rio.  Desativar temporariamente as macros pode permitir uma atualiza√ß√£o suave do c√≥digo, incluindo as macros de verifica√ß√£o sequencialmente primeiro em um arquivo, depois no segundo, depois no terceiro, etc. </p><br><p>  Portanto, as macros, embora sejam um recurso desatualizado e altamente controverso em C ++, nesse caso em particular, a vida do desenvolvedor √© simplificada. </p><br><h2 id="osnovnoy-makros-ensure_noexcept_statement">  Macro principal ENSURE_NOEXCEPT_STATEMENT </h2><br><p>  A macro principal ENSURE_NOEXCEPT_STATEMENT √© implementada trivialmente: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_STATEMENT(stmt) \ do { \ static_assert(noexcept(stmt), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this statement is expected to be noexcept: "</span></span></span><span class="hljs-meta"> #stmt); \ stmt; \ } while(false)</span></span></code> </pre> <br><p>  √â usado para verificar se os m√©todos / fun√ß√µes chamados s√£o de fato exceto e que suas chamadas n√£o precisam ser enquadradas por blocos try-catch.  Por exemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_complex_container</span></span></span><span class="hljs-class"> {</span></span> one_container first_data_part_; another_container second_data_part_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some_complex_container &amp; a, some_complex_container &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; <span class="hljs-comment"><span class="hljs-comment">//  swap  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(swap(a.first_data_part_, b.first_data_part_)); ENSURE_NOEXCEPT_STATEMENT(swap(a.second_data_part_, b.second_data_part_)); ... } ... void clean() noexcept { //  clean()  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(first_data_part_.clean()); ENSURE_NOEXCEPT_STATEMENT(second_data_part_.clean()); ... } ... };</span></span></code> </pre> <br><p>  Al√©m disso, tamb√©m h√° a macro ENSURE_NOT_NOEXCEPT_STATEMENT.  √â usado para garantir que um bloco try-catch adicional seja necess√°rio em torno da chamada, para que poss√≠veis exce√ß√µes n√£o sejam exibidas: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_resource_owner</span></span></span><span class="hljs-class"> {</span></span> some_resource resource_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~some_resource_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release   noexcept,  try-catch     //      . ENSURE_NOT_NOEXCEPT_STATEMENT(release(resource_)); } catch(...) {} ... } ... };</span></span></code> </pre> <br><h2 id="vspomogatelnye-makrosy-static_assert_noexcept-i-static_assert_not_noexcept">  Macros auxiliares STATIC_ASSERT_NOEXCEPT e STATIC_ASSERT_NOT_NOEXCEPT </h2><br><p>  Infelizmente, as macros ENSURE_NOEXCEPT_STATEMENT e ENSURE_NOT_NOEXCEPT_STATEMENT podem ser usadas apenas para instru√ß√µes / declara√ß√µes, mas n√£o para express√µes que retornam um valor.  I.e.  voc√™ n√£o pode escrever com ENSURE_NOEXCEPT_STATEMENT assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_STATEMENT(acquire_resource(params));</code> </pre> <br><p>  Portanto, ENSURE_NOEXCEPT_STATEMENT n√£o pode ser usado, por exemplo, em loops em que voc√™ geralmente precisa escrever algo como: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  e voc√™ precisa se certificar de que as chamadas <code>get_first()</code> , <code>get_next()</code> , bem como a atribui√ß√£o de novos valores para eu n√£o lan√ßem uma exce√ß√£o. </p><br><p>  Para combater essas situa√ß√µes, as macros STATIC_ASSERT_NOEXCEPT e STATIC_ASSERT_NOT_NOEXCEPT foram gravadas, atr√°s das quais apenas static_assert s est√£o ocultos e nada mais.  Usando essas macros, posso obter o resultado necess√°rio de alguma maneira (a compila√ß√£o desse fragmento em particular n√£o foi verificada): </p><br><pre> <code class="cpp hljs">STATIC_ASSERT_NOEXCEPT(something.get_first()); STATIC_ASSERT_NOEXCEPT(something.get_first().get_next()); STATIC_ASSERT_NOEXCEPT(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(something.get_first())&gt;() = something.get_first().get_next()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  Obviamente, essa n√£o √© a melhor solu√ß√£o, porque  isso leva √† duplica√ß√£o de c√≥digo e aumenta o risco de sua "flu√™ncia" com manuten√ß√£o adicional.  Mas, como primeiro passo, essas macros simples se mostraram √∫teis. </p><br><h1 id="biblioteka-noexcept-ctcheck">  Biblioteca Noexcept-ctcheck </h1><br><p>  Quando compartilhei essa experi√™ncia no meu blog e no Facebook, recebi uma proposta para organizar os desenvolvimentos acima em uma biblioteca separada.  O que foi feito: o github agora tem uma pequena biblioteca somente de cabe√ßalho <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">noexcept-compile-time-check (ou noexcept-ctcheck, se voc√™ salvar em letras)</a> .  Portanto, todas as op√ß√µes acima voc√™ pode pegar e experimentar.  √â verdade que os nomes das macros s√£o um pouco mais longos do que o usado no artigo.  I.e.  NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT em vez de ENSURE_NOEXCEPT_STATEMENT. </p><br><h2 id="chto-v-noexcept-ctcheck-ne-popalo-poka">  O que n√£o deu no noexcept-ctcheck (ainda?) </h2><br><p>  H√° um desejo de criar a macro ENSURE_NOEXCEPT_EXPRESSION, que pode ser usada assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_EXPRESSION(acquire_resource(params));</code> </pre> <br><p>  Em uma primeira aproxima√ß√£o, ele pode se parecer com isso: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_EXPRESSION(expr) \ ([&amp;]() noexcept -&gt; decltype(auto) { \ static_assert(noexcept(expr), #expr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" is expected to be noexcept"</span></span></span><span class="hljs-meta">); \ return expr; \ }())</span></span></code> </pre> <br><p>  Mas h√° vagas suspeitas de que existem algumas armadilhas nas quais n√£o pensei.  Em geral, as m√£os ainda n√£o chegaram a ENSURE_NOEXCEPT_EXPRESSION :( </p><br><h1 id="a-esli-pomechtat">  E se voc√™ sonhar? </h1><br><p>  Meu antigo sonho √© obter um bloco noexcept em C ++, no qual o pr√≥prio compilador verifica se h√° exce√ß√µes de lan√ßamento e emite avisos se houver exce√ß√µes.  Parece-me que isso tornaria mais f√°cil escrever c√≥digo com exce√ß√£o de seguran√ßa.  E n√£o apenas nos casos √≥bvios mencionados acima (swap, operadores de movimenta√ß√£o, destruidores).  Por exemplo, um bloco noexcept poderia ajudar nessa situa√ß√£o: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify_some_complex_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . one_container_.modify(); // ,   . ,      . //         try. noexcept { current_age_.increment(); } //    ,      . try { another_container_.modify(); ... } catch(...) { noexcept { //  ,     . current_age_.decrement(); one_container_.rollback_modifications(); } throw; } }</span></span></code> </pre> <br><p>  Aqui, para a corre√ß√£o do c√≥digo, √© muito importante que as a√ß√µes executadas nos blocos noexcept n√£o gerem exce√ß√µes.  E se o compilador puder rastrear isso, ser√° uma ajuda s√©ria para o desenvolvedor. </p><br><p>  Mas talvez um bloco de exce√ß√£o seja apenas um caso especial de um problema mais geral.  A saber: verificar as expectativas do programador de que algum bloco de c√≥digo tenha certas propriedades.  Seja a aus√™ncia de exce√ß√µes, a aus√™ncia de efeitos colaterais, a aus√™ncia de recurs√£o, corridas de dados, etc. </p><br><p>  Reflex√µes sobre esse assunto, h√° alguns anos, levaram √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">id√©ia de atributos impl√≠citos e esperados</a> .  Essa id√©ia n√£o foi al√©m da postagem do blog, porque  enquanto ela se afasta dos meus interesses e oportunidades atuais.  Mas, de repente, ser√° interessante para algu√©m e algu√©m pressionar√° para criar algo mais vi√°vel. </p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  Neste artigo, tentei falar sobre minha experi√™ncia na simplifica√ß√£o da grava√ß√£o de c√≥digo com exce√ß√£o de seguran√ßa.  Usar macros, √© claro, n√£o torna o c√≥digo mais bonito e compacto.  Mas funciona.  E mesmo essas macros primitivas aumentam significativamente o coeficiente do meu sono reparador.  Portanto, se algu√©m n√£o pensou em como controlar o conte√∫do de seus pr√≥prios m√©todos / fun√ß√µes, exceto talvez, este artigo talvez o inspire a pensar sobre este t√≥pico. </p><br><p>  E se algu√©m encontrasse uma maneira de simplificar sua vida ao escrever c√≥digo sem exce√ß√£o, seria interessante saber qual √© esse m√©todo, em que ajuda e em que n√£o.  E qu√£o satisfeito voc√™ est√° com o que usa. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466849/">https://habr.com/ru/post/pt466849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466833/index.html">Coisas importantes a saber sobre o Tensorflow 2.0</a></li>
<li><a href="../pt466837/index.html">Fim de semana em uma bicicleta el√©trica com um gerador de g√°s</a></li>
<li><a href="../pt466839/index.html">A hist√≥ria da cria√ß√£o do Norton Commander. Parte 1/3</a></li>
<li><a href="../pt466841/index.html">Por que uma almofada de aquecimento, se houver um laptop: o estudo da resist√™ncia t√©rmica em n√≠vel at√¥mico</a></li>
<li><a href="../pt466845/index.html">Entrevista reversa: que perguntas fazer √† empresa?</a></li>
<li><a href="../pt466851/index.html">Linha Agilex - 10nm Intel FPGA</a></li>
<li><a href="../pt466855/index.html">Criando Tower Defense na Unity: Cen√°rios e Ondas de Inimigos</a></li>
<li><a href="../pt466857/index.html">Execu√ß√£o de aplicativos em segundo plano no iOS 13</a></li>
<li><a href="../pt466859/index.html">Usando o servi√ßo AD Federation para autorizar usu√°rios da AWS com distribui√ß√£o de direitos</a></li>
<li><a href="../pt466861/index.html">Como escapar da realidade usando uma hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>