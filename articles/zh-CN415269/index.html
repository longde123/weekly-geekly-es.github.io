<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏿 👨🏾‍🤝‍👨🏽 📻 JS的工作原理：抽象语法树，解析及其优化 🤞🏼 〰️ ⬛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[建议阅读]周期的其他19个部分  第1部分： 引擎概述，运行时机制，调用堆栈 
 第2部分： 关于V8内部和代码优化 
 第3部分： 管理内存，四种类型的内存泄漏并进行处理 
 第4部分： 事件循环，异步和通过异步/等待改进代码的五种方法 
 第5部分： WebSocket和HTTP / 2 + ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS的工作原理：抽象语法树，解析及其优化</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[建议阅读]周期的其他19个部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引擎概述，运行时机制，调用堆栈</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于V8内部和代码优化</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管理内存，四种类型的内存泄漏并进行处理</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，异步和通过异步/等待改进代码的五种方法</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebSocket和HTTP / 2 + SSE。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择什么？</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebAssembly的功能和范围</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web Workers和五个使用方案</a> <br> 第八部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务人员</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web推送通知</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用MutationObserver跟踪DOM中的更改</a> <br> 第11部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网页呈现引擎和优化其性能的技巧</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第13部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSS和JavaScript动画</a> <br> 第14部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：抽象语法树，解析及其优化</a> <br> 第15部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：类和继承，Babel和TypeScript中的转译</a> <br> 第16部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：存储</a> <br> 第17部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：Shadow DOM技术和Web组件</a> <br> 第18部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：WebRTC和P2P通讯机制</a> <br> 第19部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：自定义元素</a> </div></div><br> 我们都知道，Web项目的JavaScript代码可能会增长到巨大的规模。 并且代码越大，浏览器加载它的时间就越长。 但是，这里的问题不仅在于通过网络传输数据的时间。 程序加载后，仍然需要对其进行解析，编译为字节码并最终执行。 今天，我们提请您注意JavaScript生态系统系列第14部分的译文。 即，我们将讨论JS代码的解析，抽象语法树的构建方式以及程序员如何影响这些过程，从而提高其应用程序速度。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="图片"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">编程语言如何</font> </h2><br> 在讨论抽象语法树之前，让我们先介绍一下编程语言的工作方式。 无论使用哪种语言，都必须始终使用某些带有源代码的程序，并将其转换为包含用于计算机的特定命令的内容。 解释器或编译器均充当此类程序。 无论您使用解释性语言（JavaScript，Python，Ruby）还是编译（C＃，Java，Rust）编写代码，纯文本代码都将始终经过解析阶段，即将纯文本转换为数据结构称为抽象​​语法树（AST）。 <br><br> 抽象语法树不仅提供源代码的结构化表示，而且在语义分析中也起着至关重要的作用，在此期间，编译器将验证软件结构的正确性及其元素的正确使用。 形成AST并执行检查后，此结构用于生成字节码或机器码。 <br><br><h2>  <font color="#3AC1EF">使用抽象语法树</font> </h2><br> 抽象语法树不仅用于解释器和编译器。 在计算机世界中，它们在许多其他领域中很有用。 静态代码分析是最常见的应用程序之一。 静态分析器不执行传递给它们的代码。 但是，尽管如此，他们仍需要了解程序的结构。 <br><br> 假设您想开发一种工具来查找代码中经常发生的结构。 这种工具的报告将有助于重构并减少代码重复。 可以使用通常的字符串比较来完成此操作，但是这种方法非常原始，其功能将受到限制。 实际上，如果要创建类似的工具，则无需编写自己的JavaScript解析器。 此类程序有许多开源实现，它们与ECMAScript规范完全兼容。 例如-Esprima和Acorn。 还有一些工具可以帮助处理解析器生成的内容，即，与抽象语法树一起使用。 <br><br> 另外，抽象语法树还广泛用于编译器的开发中。 假设您决定开发一个将Python代码转换为JavaScript代码的编译器。 一个类似的项目可以基于以下想法：使用编译器基于Python代码创建抽象语法树，然后将其转换为JavaScript代码。 可能在这里您会想知道这怎么可能。 关键是抽象语法树只是在某种编程语言中表示代码的另一种方法。 在将代码转换为AST之前，它看起来像普通的文本，编写时遵循构成语言的某些规则。 解析后，此代码将变成一个树形结构，其中包含与程序源代码相同的信息。 结果，不仅可以执行从源代码到AST的转换，还可以执行逆转换，从而将抽象语法树变成程序代码的文本表示。 <br><br><h2>  <font color="#3AC1EF">解析JavaScript</font> </h2><br> 让我们谈谈抽象语法树是如何构建的。 例如，考虑一个简单的JavaScript函数： <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br> 解析器将创建一个抽象语法树，如下图所示。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">抽象语法树</font></i> <br><br> 请注意，这是解析器结果的简化表示。 真正的抽象语法树看起来要复杂得多。 在这种情况下，我们的主要目标是首先了解源代码在执行之前会变成什么。 如果您有兴趣查看真正的抽象语法树的外观，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AST Explorer</a>网站。 为了为某个JS代码片段生成AST，将其放置在页面上的相应字段中就足够了。 <br><br> 也许在这里您将有一个问题，为什么程序员需要知道JS解析器的工作方式。 最后，解析和执行代码是浏览器任务。 从某种意义上说，你是对的。 下图显示了一些著名的Web项目在执行JS代码的过程中执行各个步骤所需的时间。 <br><br> 仔细看一下这张图，也许您会在这里看到一些有趣的东西。 <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">执行JS代码所花费的时间</font></i> <br><br> 看吗 如果没有，请再次查看。 实际上，我们谈论的是这样一个事实，平均而言，浏览器花费15-20％的时间来解析JS代码。 这不是一些条件数据。 这是有关以某种方式使用JavaScript的实际Web项目的工作的统计信息。 也许15％的数字对您来说似乎并不大，但请相信我，这很多。 典型的一页应用程序加载大约0.4 MB的JavaScript代码，而浏览器需要大约370 ms来解析此代码。 同样，您可以说没有什么可担心的。 是的，仅此而已。 但是，请不要忘记这只是解析代码并将其转换为AST所需的时间。 这不包括执行代码所花费的时间，也不是解决页面加载所伴随的其他任务所花费的时间，例如HTML和CSS处理以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页面渲染</a>任务。 而且，我们仅谈论桌面浏览器。 在移动系统的情况下仍然更糟。 特别是，在移动设备上对相同代码的解析时间可能比在台式机上的解析时间长2-5倍。 看下图。 <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">在各种设备上解析1 MB JS代码的时间</font></i> <br><br> 这是在各种移动和台式设备上解析1 MB JS代码所需的时间。 <br><br> 另外，Web应用程序不断变得越来越复杂，并且越来越多的任务正在转移到客户端。 所有这些旨在改善用户使用网站的体验，以使这些感觉更接近用户与传统应用程序进行交互时所经历的感觉。 很容易弄清楚这对网络项目有多大影响。 为此，只需在浏览器中打开开发人员工具，然后转到一些现代站点，看看在准备工作页面时花了多少时间来解析代码，编译以及浏览器中发生的所有其他事情。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">使用浏览器中的开发人员工具进行网站分析</font></i> <br><br> 不幸的是，移动浏览器没有这样的工具。 但是，这并不意味着无法分析网站的移动版本。 在这里，诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DeviceTiming之类的</a>工具将为我们提供帮助。 使用DeviceTiming，您可以测量在托管环境中解析和执行脚本所花费的时间。 这是由于本地脚本在由辅助代码形成的环境中的放置而导致的，这导致以下事实：每次从各种设备加载页面时，我们就有机会在本地测量解析和代码执行的时间。 <br><br><h2>  <font color="#3AC1EF">解析优化和JS引擎</font> </h2><br>  JS引擎做了很多有用的事情，以避免不必要的工作并优化代码处理过程。 这里有一些例子。 <br><br>  V8引擎支持流脚本和代码缓存。 在这种情况下，流式传输被理解为以下事实：系统参与解析异步加载的脚本，并且脚本的执行被延迟在一个单独的线程中，该脚本从代码开始加载之时就开始这样做。 这导致以下事实：解析几乎与脚本加载完成同时结束，这使准备工作页面所需的时间减少了大约10％。 <br><br> 通常，每次访问页面时，JavaScript代码都会编译为字节码。 但是，该字节码在用户导航到另一页后会丢失。 这是由于以下事实：在编译时，已编译的代码高度依赖于系统的状态和上下文。 为了改善这种情况，Chrome 42引入了对字节码缓存的支持。 由于这项创新，编译后的代码可以存储在本地，因此，当用户返回到已经访问过的页面时，无需下载，解析和编译脚本即可为工作做好准备。 这样，Chrome可以节省大约40％的解析和编译时间。 另外，对于移动设备，这可以节省电池电量。 <br><br> 在Opera浏览器中使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Carakan</a>引擎已经被V8取代了很长时间，它可以重用已经处理过的脚本的编译结果。 不需要将这些脚本连接到同一页面，甚至不需要从同一域中加载它们。 实际上，这种缓存技术非常有效，可以让您完全放弃编译步骤。 她依赖于典型的用户行为方案，以及人们如何使用Web资源。 即，当用户在使用Web应用程序时遵循特定的操作序列时，将加载相同的代码。 <br><br>  FireFox使用的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SpiderMonkey</a>解释器不会连续缓存所有内容。 它支持一个监视系统，该系统计算对特定脚本的调用次数。 根据这些指标，确定需要优化的代码部分，即具有最大负载的部分。 <br><br> 当然，某些浏览器开发人员可能会决定他们的产品根本不需要缓存。 因此，Safari浏览器的领先开发者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Masei Stachovyak</a>表示Safari不参与缓存已编译的字节码。 考虑了缓存的可能性，但尚未实现，因为代码生成花费的时间不到程序总执行时间的2％。 <br><br> 这些优化不会直接影响JS中源代码的解析。 在其应用过程中，在某些情况下，将竭尽所能以完全跳过此步骤。 不管解析速度有多快，它仍然需要一些时间，并且完全没有解析可能就是完美优化的例子。 <br><br><h2>  <font color="#3AC1EF">减少Web应用程序的准备时间</font> </h2><br> 正如我们在上面发现的那样，最大程度地减少对脚本解析的需求是很好的，但是您不能完全摆脱它，所以让我们来谈谈如何减少准备Web应用程序的时间。 实际上，可以做很多事情。 例如，您可以最大程度地减少应用程序中包含的JS代码的数量。 为工作准备页面的小代码可以更快地被解析，并且比大量的代码花费更少的时间来执行。 <br><br> 为了减少代码量，您可以仅将页面上真正需要的内容组织在页面上，而不是一些庞大的代码，其中绝对包括整个Web项目所需的所有内容。 因此，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PRPL</a>模式促进了这种加载代码的方法。 或者，您可以检查依赖项，看看它们中是否有多余的东西，这样只会导致不合理的代码库增长。 实际上，我们在这里谈到了一个值得单独讨论的大话题。 返回解析。 <br><br> 因此，本材料的目的是讨论使Web开发人员能够帮助解析器更快地完成其工作的技术。 存在这样的技术。 现代JS解析器使用启发式算法来确定是否有必要尽快执行某些代码，或者是否需要稍后执行。 基于这些预测，解析器或者使用渴望的解析算法来完全分析代码片段，或者使用惰性解析算法。 通过全面的分析，您将了解需要尽快编译的功能。 在此过程中，解决了三个主要任务：构建AST，创建可见性区域层次结构以及查找语法错误。 另一方面，惰性分析仅用于尚不需要编译的函数。 这不会创建AST，也不会搜索错误。 通过这种方法，仅创建可见区域的层次结构，与需要尽快执行的处理功能相比，节省了大约一半的时间。 <br><br> 实际上，这个概念并不新鲜。 即使像IE9这样的过时浏览器也支持这种优化方法，尽管现代系统当然已经取得了长足的进步。 <br><br> 让我们来看一个说明这些机制操作的示例。 假设我们有以下JS代码： <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br> 与前面的示例一样，代码落入解析器，解析器执行其解析并形成AST。 结果，解析器表示由以下主要部分组成的代码（我们将不关注<code>foo</code>函数）： <br><br><ul><li> 声明一个带有一个参数（ <code>x</code> ）的<code>bar</code>函数。 该函数有一个return命令，它返回<code>x</code>与10相加的结果。 </li><li> 声明一个带有两个参数（ <code>x</code>和<code>y</code> ）的<code>baz</code>函数。 她还有一个return命令，她返回<code>x</code>和<code>y</code>相加的结果。 </li><li> 使用两个参数-100和200调用<code>baz</code>函数。 </li><li> 使用一个参数调用<code>console.log</code>函数，该参数是先前调用的函数返回的值。 </li></ul><br> 这是它的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">在不应用优化的情况下解析示例代码的结果</font></i> <br><br> 让我们谈谈这里发生了什么。 解析器可以看到<code>bar</code>函数的声明， <code>baz</code>函数的声明， <code>baz</code>函数的调用以及<code>console.log</code>函数的调用。 显然，解析这段代码后，解析器将遇到一个任务，该任务的执行不会影响该程序的结果。 这是关于功能<code>bar</code>的分析。 为什么分析此功能不切实际？ 事实是，至少在所提供的代码片段中， <code>bar</code>函数从未被调用过。 这个简单的例子似乎牵强，但许多实际应用程序具有大量从未调用的功能。 <br><br> 在这种情况下，无需解析<code>bar</code>函数，我们只需记录它已声明但未在任何地方使用。 同时，该函数的实际解析在必要时在执行之前完成。 自然地，在执行延迟分析时，您需要检测函数的主体并记录其声明，但这就是工作的终点。 对于这样的功能，由于系统不具有计划执行该功能的信息，因此不必形成抽象语法树。 此外，没有分配堆内存，这通常需要大量的系统资源。 简而言之，拒绝解析不必要的功能会导致代码性能显着提高。 <br><br> 结果，在前面的示例中，真实的解析器将形成类似于以下方案的结构。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">通过优化分析示例代码的结果</font></i> <br><br> 请注意，解析器记下了有关功能<code>bar</code>的声明的注释，但并未对其进行进一步的分析。 系统不分析功能代码。 在这种情况下，函数的主体是返回简单计算结果的命令。 但是，在大多数实际应用中，功能代码可能更长，更复杂，其中包含许多返回命令，条件，循环，变量声明命令和嵌套函数。 如果从不调用此类函数，则解析所有这些都是浪费时间。 <br><br> 上面描述的概念没有什么复杂的，但是其实际实现并非易事。 在这里，我们研究了一个非常简单的示例，实际上，当确定程序中是否需要某些代码时，有必要分析函数，循环，条件运算符和对象。 通常，我们可以说解析器需要处理和分析程序中的所有内容。 <br><br> 例如，这是在JavaScript中实现模块的一种非常常见的模式： <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br> 大多数现代的JS解析器都认可这种模式；对他们而言，这表明需要对位于模块内部的代码进行完全分析。 <br><br> 但是，如果解析器始终使用惰性解析怎么办？ 不幸的是，这不是一个好主意。 事实是，使用这种方法，如果需要尽快执行某些代码，我们将遇到系统运行缓慢的问题。 解析器将执行一次懒惰解析，此后它将立即开始完全分析尽快完成的工作。 与解析器立即开始完全解析最重要的代码时相比，这将导致速度降低约50％。 <br><br><h2>  <font color="#3AC1EF">代码优化，同时考虑其分析功能</font> </h2><br> 既然我们已经了解了解析器内部的情况，现在该考虑可以采取什么措施来帮助他们了。 我们可以编写代码，以便在需要时执行功能解析。 大多数解析器都了解一种模式。 它表示为功能被括在方括号中。 这样的设计几乎总是告诉解析器该功能需要立即拆卸。 如果解析器检测到一个右括号，则紧随其后的是函数声明，它将立即开始解析函数。 当描述需要尽快执行的功能时，我们可以通过应用此技术来帮助解析器。 <br><br> 假设我们有一个函数<code>foo</code> ： <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br> 由于此代码段中没有明确指示该功能计划立即执行，因此浏览器将仅执行其惰性解析。 但是，我们有信心很快就会需要此功能，因此可以诉诸下一个技巧。 <br><br> 首先，将函数保存在变量中： <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br> 请注意，我们将初始函数名称保留在<code>function</code>关键字和左括号之间。 不能说这是绝对必要的，但建议这样做，因为如果在函数运行时抛出异常，则可以在堆栈跟踪数据中看到函数的名称，而不是<code>&lt;anonymous&gt;</code> 。 <br><br> 经过上述更改后，解析器将继续使用延迟解析。 为了改变这一点，一个小细节就足够了。 该功能必须放在方括号中： <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br> 现在，当解析器在<code>function</code>关键字前面找到一个左括号时，它将立即开始解析此函数。 <br><br> 手动执行这种优化可能并不容易，因为为此您需要知道解析器将在哪种情况下执行延迟解析，以及在哪种情况下执行完整解析。 此外，要执行此操作，您需要花费时间来确定某个特定功能是否需要尽快准备就绪才能开始工作。 <br><br> 程序员肯定不会愿意承担所有这些额外的工作。 此外，与已经说过的一切一样重要，以这种方式处理的代码将更难以阅读和理解。 在这种情况下，像Optimize.js这样的特殊软件包已准备就绪，可以为我们提供帮助。 他们的主要目标是优化JS源代码的初始启动时间。 他们执行静态代码分析并对其进行修改，以便将需要尽快执行的功能括在方括号中，从而导致浏览器立即解析它们并为执行做好准备。 <br><br> 因此，假设我们在编程时没有真正考虑任何事情，并且我们有以下代码片段： <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br> 它看起来很正常，可以按预期工作，并且执行迅速，因为解析器在<code>function</code>关键字的前面找到了左括号。 到目前为止一切顺利。 ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   —     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   — ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     —       . ,     —    ,      -,  ,       ,       . <br><br>  <b>亲爱的读者们！</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN415269/">https://habr.com/ru/post/zh-CN415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN415257/index.html">改善数据可视化的8种方法</a></li>
<li><a href="../zh-CN415259/index.html">选择/投票/投票：实际差异</a></li>
<li><a href="../zh-CN415261/index.html">游戏开发中的视觉特效艺术家：功能，职业，发展</a></li>
<li><a href="../zh-CN415263/index.html">我们如何在地图上添加入口并将基地的大小减少10％</a></li>
<li><a href="../zh-CN415265/index.html">寻找KL-7的后继产品：RACE和AROFLEX</a></li>
<li><a href="../zh-CN415271/index.html">甘特图如何简化项目管理</a></li>
<li><a href="../zh-CN415273/index.html">学习编程基础</a></li>
<li><a href="../zh-CN415275/index.html">《 C＃7和.NET Core》一书。 面向专业人员的跨平台开发。 第三版</a></li>
<li><a href="../zh-CN415277/index.html">ARKit 2.0的新功能</a></li>
<li><a href="../zh-CN415279/index.html">如果您使用Alpine Linux，为什么要用显微镜钉钉子？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>