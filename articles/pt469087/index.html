<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèª üë©üèø‚Äçüè´ ‚òπÔ∏è MVCC no PostgreSQL-2. Garfos, arquivos, p√°ginas üâë üßòüèº üëµüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima vez em que conversamos sobre a consist√™ncia dos dados, analisamos a diferen√ßa entre os n√≠veis de isolamento de transa√ß√µes do ponto de vista ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC no PostgreSQL-2. Garfos, arquivos, p√°ginas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/469087/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na √∫ltima vez em</a> que conversamos sobre a consist√™ncia dos dados, analisamos a diferen√ßa entre os n√≠veis de isolamento de transa√ß√µes do ponto de vista do usu√°rio e descobrimos por que isso √© importante.  Agora estamos come√ßando a explorar como o PostgreSQL implementa isolamento de instant√¢neo e simultaneidade de v√°rias vers√µes. <br><br>  Neste artigo, veremos como os dados s√£o fisicamente dispostos em arquivos e p√°ginas.  Isso nos impede de discutir o isolamento, mas essa digress√£o √© necess√°ria para entender o que se segue.  Precisamos descobrir como o armazenamento de dados √© organizado em um n√≠vel baixo. <br><br><h1>  Rela√ß√µes </h1><br>  Se voc√™ olhar dentro de tabelas e √≠ndices, verifica-se que eles est√£o organizados de maneira semelhante.  Ambos s√£o objetos de banco de dados que cont√™m alguns dados que consistem em linhas. <br><br>  N√£o h√° d√∫vida de que uma tabela consiste em linhas, mas isso √© menos √≥bvio para um √≠ndice.  No entanto, imagine uma √°rvore B: consiste em n√≥s que cont√™m valores indexados e refer√™ncias a outros n√≥s ou linhas da tabela.  S√£o esses n√≥s que podem ser considerados linhas de √≠ndice e, de fato, s√£o. <br><br>  Na verdade, mais alguns objetos s√£o organizados de maneira semelhante: sequ√™ncias (essencialmente tabelas de linha √∫nica) e visualiza√ß√µes materializadas (essencialmente, tabelas que lembram a consulta).  E tamb√©m h√° visualiza√ß√µes regulares, que n√£o armazenam dados, mas s√£o, em todos os outros sentidos, semelhantes √†s tabelas. <br><br>  Todos esses objetos no PostgreSQL s√£o chamados de <em>rela√ß√£o de</em> palavras comuns.  Essa palavra √© extremamente impr√≥pria porque √© um termo da teoria relacional.  Voc√™ pode desenhar um paralelo entre uma rela√ß√£o e uma tabela (exibi√ß√£o), mas certamente n√£o entre uma rela√ß√£o e um √≠ndice.  Mas aconteceu: a origem acad√™mica do PostgreSQL se manifesta.  Parece-me que foram as tabelas e vis√µes que foram chamadas primeiro, e o restante aumentou com o tempo. <br><a name="habracut"></a><br>  Para ser mais simples, discutiremos mais tabelas e √≠ndices, mas as outras <em>rela√ß√µes</em> s√£o organizadas exatamente da mesma maneira. <br><br><h1>  Garfos e arquivos </h1><br>  Geralmente v√°rios <em>garfos</em> correspondem a cada rela√ß√£o.  Os garfos podem ter v√°rios tipos e cada um deles cont√©m um certo tipo de dados. <br><br>  Se houver uma bifurca√ß√£o, ela ser√° representada primeiro pelo √∫nico <em>arquivo</em> .  O nome do arquivo √© um identificador num√©rico, que pode ser anexado por uma finaliza√ß√£o que corresponde ao nome do fork. <br><br>  O arquivo aumenta gradualmente e quando seu tamanho atinge 1 GB, um novo arquivo da mesma bifurca√ß√£o √© criado (arquivos como esses √†s vezes s√£o chamados de <em>segmentos</em> ).  O n√∫mero ordinal do segmento √© anexado no final do nome do arquivo. <br><br>  A limita√ß√£o de 1 GB do tamanho do arquivo surgiu historicamente para oferecer suporte a diferentes sistemas de arquivos, alguns dos quais n√£o podem lidar com arquivos de tamanho maior.  Voc√™ pode alterar essa limita√ß√£o ao criar o PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Portanto, v√°rios arquivos no disco podem corresponder a uma rela√ß√£o.  Por exemplo, para uma mesa pequena, haver√° tr√™s delas. <br><br>  Todos os arquivos de objetos que pertencem a um espa√ßo de tabela e um banco de dados ser√£o armazenados em um diret√≥rio.  Voc√™ precisa ter isso em mente, pois os sistemas de arquivos geralmente n√£o funcionam bem com um grande n√∫mero de arquivos em um diret√≥rio. <br><br>  Observe aqui que os arquivos, por sua vez, s√£o divididos em <em>p√°ginas</em> (ou <em>blocos</em> ), geralmente por 8 KB.  Discutiremos um pouco mais a estrutura interna das p√°ginas. <br><br><img src="https://habrastorage.org/webt/10/ze/w6/10zew6_pruaxe8amjtx7_6x70tk.png"><br><br>  Agora vamos ver os tipos de garfos. <br><br>  A <strong>bifurca√ß√£o principal</strong> s√£o os pr√≥prios dados: a pr√≥pria tabela e as linhas de √≠ndice.  A bifurca√ß√£o principal est√° dispon√≠vel para quaisquer rela√ß√µes (exceto exibi√ß√µes que n√£o cont√™m dados). <br><br>  Os nomes dos arquivos da bifurca√ß√£o principal consistem no √∫nico identificador num√©rico.  Por exemplo, este √© o caminho para a tabela que criamos na √∫ltima vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  De onde v√™m esses identificadores?  O diret√≥rio "base" corresponde ao espa√ßo de tabela "pg_default".  O pr√≥ximo subdiret√≥rio, correspondente ao banco de dados, √© onde o arquivo de interesse est√° localizado: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  O caminho √© relativo, √© especificado a partir do diret√≥rio de dados (PGDATA).  Al√©m disso, praticamente todos os caminhos no PostgreSQL s√£o especificados a partir do PGDATA.  Gra√ßas a isso, voc√™ pode mover o PGDATA com seguran√ßa para um local diferente - nada o restringe (exceto pode ser necess√°rio definir o caminho para as bibliotecas em LD_LIBRARY_PATH). <br><br>  Al√©m disso, olhando para o sistema de arquivos: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  A <strong>bifurca√ß√£o de inicializa√ß√£o</strong> est√° dispon√≠vel apenas para tabelas n√£o registradas (criadas com UNLOGGED especificado) e seus √≠ndices.  Objetos como esses n√£o s√£o muito diferentes dos objetos regulares, exceto que as opera√ß√µes com eles n√£o s√£o registradas no log write-ahead (WAL).  Por isso, √© mais r√°pido trabalhar com eles, mas √© imposs√≠vel recuperar os dados no estado consistente em caso de falha.  Portanto, durante uma recupera√ß√£o, o PostgreSQL apenas remove todos os garfos desses objetos e grava o garfo de inicializa√ß√£o no lugar do garfo principal.  Isso resulta em um objeto vazio.  Discutiremos o log em detalhes, mas em outra s√©rie. <br><br>  A tabela "accounts" √© registrada e, portanto, n√£o possui um fork de inicializa√ß√£o.  Mas, para experimentar, podemos desativar o logoff: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  O exemplo esclarece que a possibilidade de ativar e desativar o log on-line est√° associada √† reescrita dos dados em arquivos com nomes diferentes. <br><br>  Um fork de inicializa√ß√£o tem o mesmo nome que o fork principal, mas com o sufixo "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  O <strong>mapa de espa√ßo livre</strong> √© uma bifurca√ß√£o que monitora a disponibilidade de espa√ßo livre dentro das p√°ginas.  Esse espa√ßo est√° mudando constantemente: diminui quando novas vers√µes de linhas s√£o adicionadas e aumenta durante a aspira√ß√£o.  O mapa de espa√ßo livre √© usado durante a inser√ß√£o de novas vers√µes de linha para encontrar rapidamente uma p√°gina adequada, na qual os dados a serem adicionados ser√£o adequados. <br><br>  O nome do mapa de espa√ßo livre possui o sufixo "_fsm".  Mas esse arquivo n√£o aparece imediatamente, mas apenas quando necess√°rio.  A maneira mais f√°cil de conseguir isso √© aspirar uma mesa (explicaremos o porqu√™ quando chegar a hora): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  O <strong>mapa de visibilidade</strong> √© uma bifurca√ß√£o em que as p√°ginas que cont√™m apenas vers√µes de linha atualizadas s√£o marcadas por um bit.  Grosso modo, significa que quando uma transa√ß√£o tenta ler uma linha dessa p√°gina, a linha pode ser mostrada sem verificar sua visibilidade.  Nos pr√≥ximos artigos, discutiremos em detalhes como isso acontece. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  P√°ginas </h1><br>  Como j√° mencionado, os arquivos s√£o logicamente divididos em p√°ginas. <br><br>  Uma p√°gina geralmente tem o tamanho de 8 KB.  O tamanho pode ser alterado dentro de certos limites (16 KB ou 32 KB), mas apenas durante a compila√ß√£o ( <code>./configure --with-blocksize</code> ).  Uma inst√¢ncia criada e executada pode funcionar apenas com p√°ginas do mesmo tamanho. <br><br>  Independentemente da bifurca√ß√£o √† qual os arquivos pertencem, o servidor os utiliza de maneira bastante semelhante.  As p√°ginas s√£o lidas primeiro no cache do buffer, onde os processos podem l√™-los e alter√°-los;  ent√£o, conforme a necessidade, eles s√£o despejados de volta ao disco. <br><br>  Cada p√°gina possui particionamento interno e, em geral, cont√©m as seguintes parti√ß√µes: <br><br><pre>        0 + ----------------------------------- +
           |  cabe√ßalho |
       24 + ----------------------------------- +
           |  matriz de ponteiros para vers√µes de linha |
    menor + ----------------------------------- +
           |  espa√ßo livre |
    superior + ----------------------------------- +
           |  vers√µes de linha |
  especial + ----------------------------------- +
           |  espa√ßo especial |
 tamanho da p√°gina + ----------------------------------- +
</pre><br>  Voc√™ pode conhecer facilmente os tamanhos dessas parti√ß√µes usando a p√°gina de extens√£o "research"; <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Aqui estamos olhando o <strong>cabe√ßalho</strong> da primeira p√°gina (zero) da tabela.  Al√©m dos tamanhos de outras √°reas, o cabe√ßalho possui informa√ß√µes diferentes sobre a p√°gina, das quais ainda n√£o estamos interessados. <br><br>  Na parte inferior da p√°gina, h√° o <strong>espa√ßo especial</strong> , que est√° vazio neste caso.  √â usado apenas para √≠ndices, e mesmo n√£o para todos eles.  "Na parte inferior" aqui reflete o que est√° na foto;  pode ser mais preciso dizer "em endere√ßos altos". <br><br>  Ap√≥s o espa√ßo especial, as <strong>vers√µes das linhas</strong> s√£o localizadas, ou seja, esses mesmos dados que armazenamos na tabela, al√©m de algumas informa√ß√µes internas. <br><br>  No topo de uma p√°gina, logo ap√≥s o cabe√ßalho, h√° o √≠ndice: a <strong>matriz de ponteiros</strong> para vers√µes de linha dispon√≠veis na p√°gina. <br><br>  <strong>√â</strong> poss√≠vel deixar <strong>espa√ßo livre</strong> entre vers√µes de linha e ponteiros (esse espa√ßo livre √© mantido no mapa de espa√ßo livre).  Observe que n√£o h√° fragmenta√ß√£o de mem√≥ria dentro de uma p√°gina - todo o espa√ßo livre √© representado por uma √°rea cont√≠gua. <br><br><h2>  Ponteiros </h2><br>  Por que os ponteiros para as vers√µes de linha s√£o necess√°rios?  O problema √© que as linhas de √≠ndice devem, de alguma forma, fazer refer√™ncia √†s vers√µes de linha na tabela.  √â claro que a refer√™ncia deve conter o n√∫mero do arquivo, o n√∫mero da p√°gina no arquivo e alguma indica√ß√£o da vers√£o da linha.  Poder√≠amos usar o deslocamento desde o in√≠cio da p√°gina como indicador, mas √© inconveniente.  N√£o poder√≠amos mover uma vers√£o de linha dentro da p√°gina, pois isso quebraria as refer√™ncias dispon√≠veis.  E isso resultaria na fragmenta√ß√£o do espa√ßo dentro das p√°ginas e em outras consequ√™ncias problem√°ticas.  Portanto, o √≠ndice faz refer√™ncia ao n√∫mero do ponteiro e o ponteiro faz refer√™ncia ao local atual da vers√£o da linha na p√°gina.  E isso √© endere√ßamento indireto. <br><br>  Cada ponteiro ocupa exatamente quatro bytes e cont√©m: <br><br><ul><li>  uma refer√™ncia para a vers√£o da linha </li><li>  o tamanho desta vers√£o de linha </li><li>  v√°rios bytes para determinar o status da vers√£o da linha </li></ul><br><h2>  Formato de dados </h2><br>  O formato dos dados no disco √© exatamente o mesmo que a representa√ß√£o dos dados na RAM.  A p√°gina √© lida no cache do buffer "como est√°", sem nenhuma convers√£o.  Portanto, os arquivos de dados de uma plataforma se tornam incompat√≠veis com outras plataformas. <br><br>  Por exemplo, na arquitetura X86, a ordena√ß√£o de bytes √© do bytes menos significativo para o mais significativo (little-endian), o z / Architecture usa a ordem inversa (big-endian) e, no ARM, a ordem pode ser trocada. <br><br>  Muitas arquiteturas fornecem alinhamento de dados nos limites das palavras de m√°quina.  Por exemplo, em um sistema x86 de 32 bits, os n√∫meros inteiros (tipo "n√∫mero inteiro", que ocupa 4 bytes) ser√£o alinhados no limite de palavras de 4 bytes, da mesma maneira que os n√∫meros de precis√£o dupla (tipo "precis√£o dupla" , que ocupa 8 bytes).  E em um sistema de 64 bits, os n√∫meros de precis√£o dupla ser√£o alinhados no limite de palavras de 8 bytes.  Este √© mais um motivo de incompatibilidade. <br><br>  Devido ao alinhamento, o tamanho da linha da tabela depende da ordem do campo.  Normalmente, esse efeito n√£o √© muito percept√≠vel, mas √†s vezes pode resultar em um crescimento significativo do tamanho.  Por exemplo, se os campos dos tipos "char (1)" e "inteiro" forem intercalados, geralmente 3 bytes entre eles ser√£o desperdi√ßados.  Para mais detalhes, voc√™ pode ver a apresenta√ß√£o de Nikolay Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tuple internals</a> ". <br><br><h1>  Vers√µes de linha e TOAST </h1><br>  Vamos discutir detalhes da estrutura interna das vers√µes de linha na pr√≥xima vez.  Neste ponto, √© importante apenas sabermos que cada vers√£o deve caber completamente em uma p√°gina: o PostgreSQL n√£o tem como "estender" a linha para a pr√≥xima p√°gina.  A T√©cnica de armazenamento de atributos de grandes dimens√µes (TOAST) √© usada em seu lugar.  O pr√≥prio nome sugere que uma linha pode ser dividida em torradas. <br><br>  Brincadeiras √† parte, o TOAST implica v√°rias estrat√©gias.  Podemos transmitir valores de atributos longos para uma tabela interna separada depois de dividi-los em pequenos peda√ßos de torrada.  Outra op√ß√£o √© compactar um valor para que a vers√£o da linha caiba em uma p√°gina comum.  E podemos fazer as duas coisas: primeiro comprima e depois termine e transmita. <br><br>  Para cada tabela principal, uma tabela TOAST separada pode ser criada, se necess√°rio, uma para todos os atributos (junto com um √≠ndice).  A disponibilidade de atributos potencialmente longos determina essa necessidade.  Por exemplo, se uma tabela tiver uma coluna do tipo "num√©rico" ou "texto", a tabela TOAST ser√° criada imediatamente, mesmo que valores longos n√£o sejam usados. <br><br>  Como uma tabela TOAST √© essencialmente uma tabela regular, ela possui o mesmo conjunto de garfos.  E isso dobra o n√∫mero de arquivos que correspondem a uma tabela. <br><br>  As estrat√©gias iniciais s√£o definidas pelos tipos de dados da coluna.  Voc√™ pode v√™-los usando o comando <code>\d+</code> no psql, mas como ele gera muitas outras informa√ß√µes, consultaremos o cat√°logo do sistema: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Os nomes das estrat√©gias significam: <br><br><ul><li>  O TOAST n√£o √© usado (usado para tipos de dados conhecidos por serem curtos, como "n√∫mero inteiro"). </li><li>  estendido - compress√£o e armazenamento em uma tabela TOAST separada s√£o permitidos </li><li>  valores externos - longos s√£o armazenados na tabela TOAST sem compacta√ß√£o. </li><li>  Os valores main - long s√£o compactados primeiro e s√≥ entram na tabela TOAST se a compacta√ß√£o n√£o ajudar. </li></ul><br>  Em geral, o algoritmo √© o seguinte.  O PostgreSQL pretende ter pelo menos quatro linhas em uma p√°gina.  Portanto, se o tamanho da linha exceder um quarto da p√°gina, levando em considera√ß√£o o cabe√ßalho (2040 bytes para uma p√°gina normal de 8 K), o TOAST deve ser aplicado a uma parte dos valores.  Seguimos a ordem descrita abaixo e paramos assim que a linha n√£o exceder mais o limite: <br><br><ol><li>  Primeiro, analisamos os atributos com as estrat√©gias "externas" e "estendidas", do atributo mais longo ao mais curto.  Os atributos "estendidos" s√£o compactados (se forem efetivos) e, se o valor em si exceder um quarto da p√°gina, ele entra imediatamente na tabela TOAST.  Os atributos "externos" s√£o processados ‚Äã‚Äãda mesma maneira, mas n√£o s√£o compactados. </li><li>  Se ap√≥s a primeira passagem, a vers√£o da linha ainda n√£o se encaixa na p√°gina, transmitimos os atributos restantes com as estrat√©gias "externas" e "estendidas" para a tabela TOAST. </li><li>  Se isso tamb√©m n√£o ajudou, tentamos compactar os atributos com a estrat√©gia "principal", mas os deixamos na p√°gina da tabela. </li><li>  E somente se, depois disso, a linha n√£o for suficientemente curta, os atributos "principais" entrar√£o na tabela TOAST. </li></ol><br>  √Äs vezes, pode ser √∫til alterar a estrat√©gia para determinadas colunas.  Por exemplo, se for sabido antecipadamente que os dados em uma coluna n√£o podem ser compactados, podemos definir a estrat√©gia "externa" para isso, o que nos permite economizar tempo, evitando tentativas in√∫teis de compacta√ß√£o.  Isso √© feito da seguinte maneira: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Re-executando a consulta, obtemos: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  As tabelas e √≠ndices TOAST est√£o localizados no esquema pg_toast separado e, portanto, geralmente n√£o s√£o vis√≠veis.  Para tabelas tempor√°rias, o esquema "pg_toast_temp_ <em>N</em> " √© usado da mesma forma que o usual "pg_temp_ <em>N</em> ". <br><br>  Obviamente, se voc√™ gosta de ningu√©m, isso impedir√° que voc√™ espie a mec√¢nica interna do processo.  Digamos, na tabela "contas", existem tr√™s atributos potencialmente longos e, portanto, deve haver uma tabela TOAST.  Aqui est√°: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  √â razo√°vel que a estrat√©gia "simples" seja aplicada √†s torradas nas quais a linha √© cortada: n√£o h√° um TOAST de segundo n√≠vel. <br><br>  O PostgreSQL oculta melhor o √≠ndice, mas tamb√©m n√£o √© dif√≠cil encontrar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  A coluna "cliente" usa a estrat√©gia "estendida": seus valores ser√£o compactados.  Vamos verificar: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  N√£o h√° nada na tabela TOAST: os caracteres repetidos s√£o compactados com precis√£o e, ap√≥s a compacta√ß√£o, o valor se ajusta a uma p√°gina de tabela usual. <br><br>  E agora deixe o nome do cliente consistir em caracteres aleat√≥rios: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Essa sequ√™ncia n√£o pode ser compactada e entra na tabela TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Podemos ver que os dados s√£o divididos em partes de 2000 bytes. <br><br>  Quando um valor longo √© acessado, o PostgreSQL automaticamente e de forma transparente para o aplicativo restaura o valor original e o retorna ao cliente. <br><br>  Certamente, √© bastante intensivo em recursos para compactar, desmembrar e depois restaurar.  Portanto, armazenar dados massivos no PostgreSQL n√£o √© a melhor id√©ia, especialmente se eles s√£o usados ‚Äã‚Äãcom freq√º√™ncia e o uso n√£o requer l√≥gica transacional (por exemplo: digitaliza√ß√µes de documentos cont√°beis originais).  Uma alternativa mais ben√©fica √© armazenar esses dados em um sistema de arquivos com os nomes de arquivos armazenados no DBMS. <br><br>  A tabela TOAST √© usada apenas para acessar um valor longo.  Al√©m disso, sua pr√≥pria simultaneidade de mutivers√£o √© suportada para uma tabela TOAST: a menos que uma atualiza√ß√£o de dados toque em um valor longo, uma nova vers√£o de linha far√° refer√™ncia ao mesmo valor na tabela TOAST, e isso economizar√° espa√ßo. <br><br>  Observe que o TOAST funciona apenas para tabelas, mas n√£o para √≠ndices.  Isso imp√µe uma limita√ß√£o no tamanho das chaves a serem indexadas. <br><blockquote>  Para mais detalhes da estrutura de dados interna, voc√™ pode ler a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469087/">https://habr.com/ru/post/pt469087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469073/index.html">Derivada discreta ou resumo de como somar s√©ries</a></li>
<li><a href="../pt469075/index.html">Grokay DLR</a></li>
<li><a href="../pt469077/index.html">Novo curso de Python da Microsoft [em ingl√™s]</a></li>
<li><a href="../pt469079/index.html">Python no c√≥digo do Visual Studio: atualiza√ß√£o de extens√£o de setembro</a></li>
<li><a href="../pt469085/index.html">Retiramos o software do microcontrolador protegido por senha Renesas M16C</a></li>
<li><a href="../pt469093/index.html">Compara√ß√£o de bibliotecas menos populares e n√£o muito CLI: cliff, plac, plumbum e outras (parte 2)</a></li>
<li><a href="../pt469095/index.html">Lan√ßadas atualiza√ß√µes do ML.NET e do Model Builder: O que h√° de novo</a></li>
<li><a href="../pt469097/index.html">Servidor web CentOS 8 com php7, node.js e redis</a></li>
<li><a href="../pt469099/index.html">Tarefas de teste na entrevista do desenvolvedor - isso faz sentido?</a></li>
<li><a href="../pt469101/index.html">Aprendendo ingl√™s: como aprender a falar como falante nativo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>