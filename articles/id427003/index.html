<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛔️ 👨🏿‍🔬 🔍 Hexagon maps in Unity: kabut perang, riset peta, pembuatan prosedural 🧗🏽 ⬇️ ✔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1-3: jala, warna, dan tinggi sel 

 Bagian 4-7: gundukan, sungai, dan jalan 

 Bagian 8-11: air, bentang alam, dan benteng 

 Bagian 12-15: men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hexagon maps in Unity: kabut perang, riset peta, pembuatan prosedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427003/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1-3: jala, warna, dan tinggi sel</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4-7: gundukan, sungai, dan jalan</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8-11: air, bentang alam, dan benteng</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 12-15: menyimpan dan memuat, tekstur, jarak</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 16-19: menemukan jalan, regu pemain, animasi</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 20-23: Kabut Perang, Penelitian Peta, Generasi Prosedural</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 24-27: siklus air, erosi, bioma, peta silindris</a> <br><br><h1>  Bagian 20: kabut perang </h1><br><ul><li>  Simpan data sel dalam tekstur. </li><li>  Ubah jenis bantuan tanpa triangulasi. </li><li>  Kami melacak visibilitas. </li><li>  Menggelapkan segalanya yang tak terlihat. </li></ul><br>  Di bagian ini, kita akan menambahkan efek kabut perang ke peta. <br><br>  Sekarang seri akan dibuat pada Unity 2017.1.0. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg"></div><br>  <i>Sekarang kita melihat bahwa kita dapat dan tidak dapat melihat.</i> <br><a name="habracut"></a><br><h2>  Data Sel di Shader </h2><br>  Banyak game strategi menggunakan konsep kabut perang.  Ini berarti bahwa visi pemain terbatas.  Dia hanya bisa melihat apa yang dekat dengan unitnya atau area yang dikendalikannya.  Meskipun kami bisa melihat kelegaan, kami tidak tahu apa yang terjadi di sana.  Biasanya medan yang tak terlihat menjadi lebih gelap.  Untuk mewujudkan ini, kita perlu melacak visibilitas sel dan membuatnya sesuai. <br><br>  Cara paling sederhana untuk mengubah tampilan sel tersembunyi adalah menambahkan metrik visibilitas ke data mesh.  Namun, pada saat yang sama, kami harus meluncurkan triangulasi bantuan baru ketika visibilitas berubah.  Ini adalah keputusan yang buruk karena visibilitas terus berubah selama pertandingan. <br><br>  Teknik render di atas topografi permukaan yang tembus sering digunakan, yang sebagian menutupi sel yang tidak terlihat oleh pemain.  Metode ini cocok untuk medan yang relatif datar dalam kombinasi dengan sudut pandang terbatas.  Tetapi karena medan kami dapat berisi ketinggian dan objek yang sangat bervariasi yang dapat dilihat dari sudut yang berbeda, untuk ini kami membutuhkan jaring yang sangat detail yang cocok dengan bentuk medan.  Metode ini akan lebih mahal daripada pendekatan paling sederhana yang disebutkan di atas. <br><br>  Pendekatan lain adalah untuk mentransfer data sel ke shader ketika merender secara terpisah dari relief mesh.  Ini akan memungkinkan kita untuk melakukan triangulasi hanya sekali.  Data sel dapat ditransfer menggunakan tekstur.  Mengubah tekstur adalah proses yang jauh lebih sederhana daripada melakukan triangulasi medan.  Selain itu, mengeksekusi beberapa sampel tekstur tambahan lebih cepat daripada merender lapisan tembus tunggal. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana dengan menggunakan array shader?</b> <div class="spoiler_text">  Anda juga dapat mentransfer data sel ke shader menggunakan array vektor.  Namun, array shader memiliki batas ukuran, diukur dalam ribuan byte, dan tekstur dapat mengandung jutaan piksel.  Untuk mendukung peta besar, kami akan menggunakan tekstur. </div></div><br><h3>  Manajemen Data Sel </h3><br>  Kami membutuhkan cara untuk mengontrol tekstur yang berisi data sel.  Mari kita membuat komponen <code>HexCellShaderData</code> baru yang akan melakukan ini. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; }</code> </pre> <br>  Saat membuat atau memuat peta baru, kita perlu membuat tekstur baru dengan ukuran yang benar.  Oleh karena itu, kami menambahkan metode inisialisasi yang menciptakan tekstur padanya.  Kami menggunakan tekstur RGBA tanpa tekstur mip dan ruang warna linier.  Kami tidak perlu mencampur data sel, jadi kami menggunakan pemfilteran titik.  Selain itu, data tidak boleh diciutkan.  Setiap piksel dalam tekstur akan berisi data dari satu sel. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Haruskah ukuran tekstur cocok dengan ukuran peta?</b> <div class="spoiler_text">  Tidak, itu hanya perlu memiliki piksel yang cukup untuk menampung semua sel.  Dengan kecocokan persis dengan ukuran peta, tekstur dengan ukuran yang bukan kekuatan dua (non-kekuatan-dua, NPOT) kemungkinan besar akan dibuat, dan format tekstur ini bukan yang paling efektif.  Meskipun kita dapat mengonfigurasi kode untuk bekerja dengan tekstur ukuran kekuatan dua, ini adalah optimasi kecil, yang mempersulit akses ke data sel. </div></div><br>  Faktanya, kita tidak perlu membuat tekstur baru setiap kali kita membuat peta baru.  Cukup untuk mengubah ukuran tekstur jika sudah ada.  Kami bahkan tidak perlu memeriksa apakah kami sudah memiliki ukuran yang tepat, karena <code>Texture2D.Resize</code> cukup pintar untuk melakukan ini untuk kami. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTexture) { cellTexture.Resize(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( cellCountX, cellCountZ, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; } }</code> </pre> <br>  Alih-alih menerapkan data sel satu piksel pada satu waktu, kami menggunakan buffer warna dan menerapkan data semua sel sekaligus.  Untuk melakukan ini, kita akan menggunakan larik <code>Color32</code> .  Jika perlu, kami akan membuat instance array baru di akhir <code>Initialize</code> .  Jika kita sudah memiliki array dengan ukuran yang benar.  lalu kita bersihkan isinya. <br><br><pre> <code class="cs hljs"> Texture2D cellTexture; Color32[] cellTextureData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || cellTextureData.Length != x * z) { cellTextureData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32[x * z]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellTextureData.Length; i++) { cellTextureData[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Apa itu color32?</b> <div class="spoiler_text">  Tekstur RGBA tanpa kompresi standar mengandung piksel empat-byte.  Masing-masing dari empat saluran warna menerima byte, yaitu, mereka memiliki 256 nilai yang mungkin.  Saat menggunakan struktur <code>Color</code> Persatuan, komponen titik apung dalam interval 0–1 dikonversi menjadi byte dalam interval 0–255.  Saat pengambilan sampel, GPU melakukan transformasi terbalik. <br><br>  Struktur <code>Color32</code> bekerja secara langsung dengan byte, sehingga mereka mengambil lebih sedikit ruang dan tidak memerlukan konversi, yang meningkatkan efisiensi penggunaannya.  Karena kami menyimpan data sel alih-alih warna, akan lebih logis untuk bekerja secara langsung dengan data tekstur mentah, dan bukan dengan <code>Color</code> . </div></div><br>  <code>HexGrid</code> harus berurusan dengan pembuatan dan inisialisasi sel-sel ini di shader.  Oleh karena itu, kami akan menambahkan bidang <code>cellShaderData</code> ke <code>cellShaderData</code> dan membuat komponen di dalam <code>Awake</code> . <br><br><pre> <code class="cs hljs"> HexCellShaderData cellShaderData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); CreateMap(cellCountX, cellCountZ); }</code> </pre> <br>  Saat membuat peta baru, <code>cellShaderData</code> juga harus <code>cellShaderData</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; cellShaderData.Initialize(cellCountX, cellCountZ); CreateChunks(); CreateCells(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Mengedit Data Sel </h3><br>  Sampai sekarang, ketika mengubah properti sel, perlu memperbarui satu atau beberapa fragmen, tetapi sekarang mungkin perlu memperbarui data sel.  Ini berarti bahwa sel harus memiliki tautan ke data sel di shader.  Untuk melakukan ini, tambahkan properti ke <code>HexCell</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCellShaderData ShaderData { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Di <code>HexGrid.CreateCell</code> kami <code>HexGrid.CreateCell</code> menetapkan komponen data shader ke properti ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.ShaderData = cellShaderData; … }</code> </pre> <br>  Sekarang kita bisa mendapatkan sel untuk memperbarui data shader mereka.  Meskipun kami tidak melacak visibilitas, kami dapat menggunakan data shader untuk hal lain.  Jenis relief sel menentukan tekstur yang digunakan untuk membuatnya.  Itu tidak mempengaruhi geometri sel, jadi kita bisa menyimpan indeks tipe elevasi dalam data sel, dan tidak dalam data mesh.  Ini akan memungkinkan kita untuk menyingkirkan kebutuhan akan triangulasi ketika mengubah jenis relief sel. <br><br>  Tambahkan metode <code>HexCellShaderData</code> ke <code>RefreshTerrain</code> untuk menyederhanakan tugas ini untuk sel tertentu.  Biarkan metode ini kosong untuk saat ini. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Ubah <code>HexCell.TerrainTypeIndex</code> sehingga <code>HexCell.TerrainTypeIndex</code> metode ini, dan tidak memesan untuk memperbarui fragmen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Refresh(); ShaderData.RefreshTerrain(this); } } }</span></span></code> </pre> <br>  Kami juga akan memanggilnya di <code>HexCell.Load</code> setelah menerima jenis topografi sel. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); RefreshPosition(); … }</code> </pre> <br><h3>  Indeks sel </h3><br>  Untuk mengubah sel-sel ini, kita perlu mengetahui indeks sel.  Cara termudah untuk melakukan ini adalah dengan menambahkan properti <code>Index</code> ke <code>HexCell</code> .  Ini akan menunjukkan indeks sel dalam daftar sel di peta, yang sesuai dengan indeksnya dalam sel yang diberikan dalam shader. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  Indeks ini sudah ada di <code>HexGrid.CreateCell</code> , jadi tetapkan saja ke sel yang dibuat. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; … }</code> </pre> <br>  Sekarang <code>HexCellShaderData.RefreshTerrain</code> dapat menggunakan indeks ini untuk menentukan data sel.  Mari kita simpan indeks tipe elevasi dalam komponen alfa pikselnya dengan hanya mengonversi tipe menjadi byte.  Ini akan mendukung hingga 256 jenis medan, yang akan cukup bagi kami. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; }</code> </pre> <br>  Untuk menerapkan data ke tekstur dan meneruskannya ke GPU, kita perlu memanggil <code>Texture2D.SetPixels32</code> , dan kemudian <code>Texture2D.Apply</code> .  Seperti dalam kasus fragmen, kami akan menunda operasi ini di <code>LateUpdate</code> sehingga mereka dapat dilakukan tidak lebih dari sekali per frame, terlepas dari jumlah sel yang diubah. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].a = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)cell.TerrainTypeIndex; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Untuk memastikan bahwa data akan diperbarui setelah membuat peta baru, aktifkan komponen setelah inisialisasi. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3>  Triangulasi indeks sel </h3><br>  Karena kami sekarang menyimpan indeks tipe elevasi dalam sel-sel ini, kami tidak perlu lagi memasukkannya dalam proses triangulasi.  Tetapi untuk menggunakan data sel, shader harus tahu indeks mana yang harus digunakan.  Oleh karena itu, Anda perlu menyimpan indeks sel dalam data mesh, menggantikan indeks tipe ketinggian.  Selain itu, kita masih membutuhkan saluran warna mesh untuk mencampur sel saat menggunakan sel-sel ini. <br><br>  Kami <code>HexMesh</code> bidang umum usang <code>useColors</code> dan <code>useTerrainTypes</code> .  Ganti dengan satu bidang <code>useCellData</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public bool useCollider, useColors, useUVCoordinates, useUV2Coordinates; // public bool useTerrainTypes; public bool useCollider, useCellData, useUVCoordinates, useUV2Coordinates;</span></span></code> </pre><br>  Kami mengubah nama dari daftar <code>cellIndices</code> menjadi <code>cellIndices</code> .  Mari juga refactor-rename <code>colors</code> ke <code>cellWeights</code> - nama ini akan lebih baik. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes; // [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;Vector3&gt; vertices, cellIndices; [NonSerialized] List&lt;Color&gt; cellWeights; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; [NonSerialized] List&lt;int&gt; triangles;</span></span></code> </pre><br>  Ubah <code>Clear</code> sehingga saat menggunakan sel-sel ini, ia mengumpulkan dua daftar, dan tidak secara terpisah. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { cellWeights = ListPool&lt;Color&gt;.Get(); cellIndices = ListPool&lt;Vector3&gt;.Get(); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // colors = ListPool&lt;Color&gt;.Get(); // } if (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } if (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } // if (useTerrainTypes) { // terrainTypes = ListPool&lt;Vector3&gt;.Get(); // } triangles = ListPool&lt;int&gt;.Get(); }</span></span></code> </pre> <br>  Lakukan pengelompokan yang sama di <code>Apply</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCellData) { hexMesh.SetColors(cellWeights); ListPool&lt;Color&gt;.Add(cellWeights); hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, cellIndices); ListPool&lt;Vector3&gt;.Add(cellIndices); } <span class="hljs-comment"><span class="hljs-comment">// if (useColors) { // hexMesh.SetColors(colors); // ListPool&lt;Color&gt;.Add(colors); // } if (useUVCoordinates) { hexMesh.SetUVs(0, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } if (useUV2Coordinates) { hexMesh.SetUVs(1, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } // if (useTerrainTypes) { // hexMesh.SetUVs(2, terrainTypes); // ListPool&lt;Vector3&gt;.Add(terrainTypes); // } hexMesh.SetTriangles(triangles, 0); ListPool&lt;int&gt;.Add(triangles); hexMesh.RecalculateNormals(); if (useCollider) { meshCollider.sharedMesh = hexMesh; } }</span></span></code> </pre> <br>  Mari kita hapus semua <code>AddTriangleTerrainTypes</code> dan <code>AddTriangleTerrainTypes</code> .  Ganti mereka dengan metode <code>AddTriangleCellData</code> sesuai, yang menambahkan indeks dan bobot sekaligus. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddTriangleCellData(indices, weights, weights, weights); }</code> </pre> <br>  Lakukan hal yang sama dalam metode <code>AddQuad</code> sesuai. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2, Color weights3, Color weights4 </span></span></span><span class="hljs-function">)</span></span> { cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellIndices.Add(indices); cellWeights.Add(weights1); cellWeights.Add(weights2); cellWeights.Add(weights3); cellWeights.Add(weights4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 indices, Color weights1, Color weights2 </span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights1, weights1, weights2, weights2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 indices, Color weights</span></span></span><span class="hljs-function">)</span></span> { AddQuadCellData(indices, weights, weights, weights, weights); }</code> </pre> <br><h3>  HexGridChunk Refactoring </h3><br>  Pada tahap ini, kami mendapatkan banyak kesalahan kompiler di <code>HexGridChunk</code> yang perlu <code>HexGridChunk</code> .  Tapi pertama-tama, demi konsistensi, kami mengubah nama-warna statis menjadi bobot. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color weights3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br>  Mari kita mulai dengan memperbaiki <code>TriangulateEdgeFan</code> .  Dia dulu butuh tipe, tapi sekarang dia butuh indeks sel.  <code>AddTriangleColor</code> dan <code>AddTriangleTerrainTypes</code> dengan kode <code>AddTriangleTerrainTypes</code> yang sesuai. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); terrain.AddTriangle(center, edge.v2, edge.v3); terrain.AddTriangle(center, edge.v3, edge.v4); terrain.AddTriangle(center, edge.v4, edge.v5); Vector3 indices; indices.x = indices.y = indices.z = index; terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = type; // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Metode ini disebut di beberapa tempat.  Mari kita telaah mereka dan pastikan bahwa indeks sel ditransfer di sana, dan bukan jenis medan. <br><br><pre> <code class="cs hljs"> TriangulateEdgeFan(center, e, cell.Index);</code> </pre> <br>  Berikutnya adalah <code>TriangulateEdgeStrip</code> .  Semuanya sedikit lebih rumit di sini, tetapi kami menggunakan pendekatan yang sama.  Juga refactor-rename nama parameter <code>c1</code> dan <code>c2</code> ke <code>w1</code> dan <code>w2</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color w1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index1, EdgeVertices e2, Color w2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); Vector3 indices; indices.x = indices.z = index1; indices.y = index2; terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); terrain.AddQuadCellData(indices, w1, w2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // terrain.AddQuadColor(c1, c2); // Vector3 types; // types.x = types.z = type1; // types.y = type2; // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); if (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</span></span></code> </pre> <br>  Ubah panggilan ke metode ini sehingga indeks sel diteruskan ke mereka.  Kami juga menjaga agar nama variabel tetap konsisten. <br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip( m, weights1, cell.Index, e, weights1, cell.Index ); … TriangulateEdgeStrip( e1, weights1, cell.Index, e2, weights2, neighbor.Index, hasRoad ); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w2 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i1 = beginCell.Index; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> i2 = endCell.Index; TriangulateEdgeStrip(begin, weights1, i1, e2, w2, i2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color w1 = w2; e2 = EdgeVertices.TerraceLerp(begin, end, i); w2 = HexMetrics.TerraceLerp(weights1, weights2, i); TriangulateEdgeStrip(e1, w1, i1, e2, w2, i2, hasRoad); } TriangulateEdgeStrip(e2, w2, i1, end, weights2, i2, hasRoad); }</code> </pre> <br>  Sekarang kita beralih ke metode sudut.  Perubahan ini sederhana, tetapi harus dibuat dalam jumlah besar kode.  Pertama di <code>TriangulateCorner</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); Vector3 indices; indices.x = bottomCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangleCellData(indices, weights1, weights2, weights3); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, weights2, weights3); // Vector3 types; // types.x = bottomCell.TerrainTypeIndex; // types.y = leftCell.TerrainTypeIndex; // types.z = rightCell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</span></span></code> </pre> <br>  Datang ke <code>TriangulateCornerTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w3 = HexMetrics.TerraceLerp(weights1, weights2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color w4 = HexMetrics.TerraceLerp(weights1, weights3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleCellData(indices, weights1, w3, w4); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1, w3, w4); // terrain.AddTriangleTerrainTypes(indices); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color w1 = w3; Color w2 = w4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); w3 = HexMetrics.TerraceLerp(weights1, weights2, i); w4 = HexMetrics.TerraceLerp(weights1, weights3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadCellData(indices, w1, w2, w3, w4); // terrain.AddQuadColor(w1, w2, w3, w4); // terrain.AddQuadTerrainTypes(indices); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadCellData(indices, w3, w4, weights2, weights3); // terrain.AddQuadColor(w3, w4, weights2, weights3); // terrain.AddQuadTerrainTypes(indices); }</span></span></code> </pre> <br>  Kemudian di <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryWeights = Color.Lerp(weights1, weights3, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( begin, weights1, left, weights2, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryColor); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Dan sedikit berbeda di <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryWeights = Color.Lerp(weights1, weights2, b); Vector3 indices; indices.x = beginCell.Index; indices.y = leftCell.Index; indices.z = rightCell.Index; TriangulateBoundaryTriangle( right, weights3, begin, weights1, boundary, boundaryWeights, indices ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, weights2, right, weights3, boundary, boundaryWeights, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleCellData( indices, weights2, weights3, boundaryWeights ); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights2, weights3, boundaryWeights); // terrain.AddTriangleTerrainTypes(indices); } }</span></span></code> </pre> <br>  Dua metode sebelumnya menggunakan <code>TriangulateBoundaryTriangle</code> , yang juga membutuhkan pembaruan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginWeights, Vector3 left, Color leftWeights, Vector3 boundary, Color boundaryWeights, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleCellData(indices, beginWeights, w2, boundaryWeights); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(beginColor, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); for (int i = 2; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color w1 = w2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); w2 = HexMetrics.TerraceLerp(beginWeights, leftWeights, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleCellData(indices, w1, w2, boundaryWeights); // terrain.AddTriangleColor(c1, c2, boundaryColor); // terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleCellData(indices, w2, leftWeights, boundaryWeights); // terrain.AddTriangleColor(c2, leftColor, boundaryColor); // terrain.AddTriangleTerrainTypes(types); }</span></span></code> </pre> <br>  Metode terakhir yang perlu diubah adalah <code>TriangulateWithRiver</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangle(centerL, m.v1, m.v2); terrain.AddQuad(centerL, center, m.v2, m.v3); terrain.AddQuad(center, centerR, m.v3, m.v4); terrain.AddTriangle(centerR, m.v4, m.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; terrain.AddTriangleCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddQuadCellData(indices, weights1); terrain.AddTriangleCellData(indices, weights1); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddQuadColor(weights1); // terrain.AddTriangleColor(weights1); // Vector3 types; // types.x = types.y = types.z = cell.TerrainTypeIndex; // terrain.AddTriangleTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddQuadTerrainTypes(types); // terrain.AddTriangleTerrainTypes(types); … }</span></span></code> </pre> <br>  Agar semuanya berfungsi, kita perlu menunjukkan bahwa kita akan menggunakan data sel untuk elemen anak dari relief fragmen cetakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/b8c/731/919b8c7317b2aa3c06f1077eef27fe96.png"></div><br>  <i>Relief menggunakan data sel.</i> <br><br>  Pada tahap ini, mesh berisi indeks sel, bukan indeks tipe elevasi.  Karena shader elevasi masih menafsirkannya sebagai indeks elevasi, kita akan melihat bahwa sel pertama dirender dengan tekstur pertama dan seterusnya hingga tekstur relief terakhir tercapai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/a23/ce8/8a5a23ce850af789e759dde6879f93eb.png"></div><br>  <i>Menggunakan indeks sel sebagai indeks tekstur ketinggian.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Saya tidak dapat mengaktifkan kode refactored.</b>  <b class="spoiler_title">Apa yang saya lakukan salah?</b> <div class="spoiler_text">  Pada suatu waktu kami mengubah sejumlah besar kode triangulasi, sehingga ada kemungkinan kesalahan atau kelalaian yang tinggi.  Jika Anda tidak dapat menemukan kesalahan, coba unduh paket dari bagian ini dan ekstrak file yang sesuai.  Anda dapat mengimpornya ke proyek terpisah dan membandingkannya dengan kode Anda sendiri. </div></div><br><h3>  Transfer data sel ke shader </h3><br>  Untuk menggunakan sel-sel ini, shader medan harus memiliki akses ke mereka.  Ini dapat diimplementasikan melalui properti shader.  Ini akan membutuhkan <code>HexCellShaderData</code> mengatur properti material lega.  Atau kita dapat membuat tekstur sel-sel ini terlihat secara global oleh semua shader.  Ini nyaman karena kami membutuhkannya dalam beberapa shader, jadi kami akan menggunakan pendekatan ini. <br><br>  Setelah membuat tekstur sel, panggil metode <code>Shader.SetGlobalTexture</code> statis untuk membuatnya terlihat secara global sebagai <em>_HexCellData</em> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } … }</code> </pre> <br>  Saat menggunakan properti shader, Unity membuat ukuran tekstur tersedia untuk shader melalui variabel <em>teksturName_TexelSize</em> .  Ini adalah vektorizer empat komponen yang berisi nilai yang terbalik dengan lebar dan tinggi, serta lebar dan tinggi itu sendiri.  Tetapi ketika mengatur tekstur global, ini tidak dilakukan.  Oleh karena itu, kami akan melakukannya sendiri menggunakan <code>Shader.SetGlobalVector</code> setelah membuat atau mengubah ukuran tekstur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cellTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D( x, z, TextureFormat.RGBA32, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); cellTexture.filterMode = FilterMode.Point; cellTexture.wrapMode = TextureWrapMode.Clamp; Shader.SetGlobalTexture(<span class="hljs-string"><span class="hljs-string">"_HexCellData"</span></span>, cellTexture); } Shader.SetGlobalVector( <span class="hljs-string"><span class="hljs-string">"_HexCellData_TexelSize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector4(<span class="hljs-number"><span class="hljs-number">1f</span></span> / x, <span class="hljs-number"><span class="hljs-number">1f</span></span> / z, x, z) );</code> </pre> <br><h3>  Akses Data Shader </h3><br>  Buat shader baru sertakan file dalam folder bahan yang disebut <em>HexCellData</em> .  Di dalamnya, kami mendefinisikan variabel untuk informasi tentang tekstur dan ukuran sel-sel ini.  Kami juga membuat fungsi untuk mendapatkan data sel untuk data mesh vertex yang diberikan. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _HexCellData; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> _HexCellData_TexelSize; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> GetCellData (appdata_full v) { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/604/dbc/a64604dbc7d3ad5ff1e1578bd0c84eec.png"></div><br>  <i>Sertakan file baru.</i> <br><br>  Indeks sel disimpan dalam <code>v.texcoord2</code> , seperti halnya dengan jenis medan.  Mari kita mulai dengan indeks pertama - <code>v.texcoord2.x</code> .  Sayangnya, kami tidak dapat langsung menggunakan indeks untuk sampel tekstur sel-sel ini.  Kami harus mengubahnya menjadi koordinat UV. <br><br>  Langkah pertama dalam membuat koordinat U adalah membagi indeks sel dengan lebar tekstur.  Kita dapat melakukan ini dengan mengalikannya dengan <code>_HexCellData_TexelSize.x</code> . <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">appdata_full v</span></span></span><span class="hljs-function">)</span></span> { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasilnya akan berupa angka dalam bentuk ZU, di mana Z adalah indeks baris dan U adalah koordinat dari sel U. </font><font style="vertical-align: inherit;">Kita dapat mengekstraksi string dengan membulatkan angka ke bawah dan kemudian mengurangkannya dari angka untuk mendapatkan koordinat U.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinat V membagi garis dengan ketinggian tekstur. </font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = v.texcoord2.x * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita mengambil sampel tekstur, kita perlu menggunakan koordinat di pusat piksel, bukan di tepinya. </font><font style="vertical-align: inherit;">Dengan cara ini kami menjamin bahwa piksel yang benar disampel. </font><font style="vertical-align: inherit;">Karena itu, setelah membaginya dengan ukuran tekstur, tambahkan ½.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v) { float2 uv; uv.x = (v.texcoord2.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini memberi kita koordinat UV yang benar untuk indeks sel pertama yang disimpan dalam data titik. </font><font style="vertical-align: inherit;">Tetapi di atas kita dapat memiliki hingga tiga indeks berbeda. </font><font style="vertical-align: inherit;">Karenanya, kami akan membuatnya </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berfungsi untuk indeks apa pun. </font><font style="vertical-align: inherit;">Tambahkan parameter integer ke dalamnya </font></font><code>index</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang akan kita gunakan untuk mengakses komponen vektor dengan indeks sel.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki semua koordinat yang diperlukan untuk sel-sel ini, kita dapat mencicipi </font></font><code>_HexCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena kita mengambil sampel tekstur dalam program vertex, kita perlu secara eksplisit memberi tahu shader yang menggunakan tekstur mip. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menggunakan fungsi </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang membutuhkan koordinat empat tekstur. </font><font style="vertical-align: inherit;">Karena sel-sel ini tidak memiliki tekstur-mip, kami menetapkan nilai nol ke koordinat tambahan.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float2 uv; uv.x = (v.texcoord2[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.x; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> = floor(uv.x); uv.x -= <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>; uv.y = (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * _HexCellData_TexelSize.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> data = tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen data keempat berisi indeks tipe elevasi, yang kami simpan langsung sebagai byte. </font><font style="vertical-align: inherit;">Namun, GPU secara otomatis mengubahnya menjadi nilai floating point di kisaran 0-1. </font><font style="vertical-align: inherit;">Untuk mengubahnya kembali ke nilai yang benar, kalikan dengan 255. Setelah itu, Anda dapat mengembalikan data.</font></font><br><br><pre> <code class="hljs kotlin"> float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = tex2Dlod(_HexCellData, float4(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.w *= <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menggunakan fungsi ini, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktifkan HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena saya menempatkan shader ini di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material / Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , saya perlu menggunakan path relatif </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">../HexCellData.cginc</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs lisp"> #include <span class="hljs-string"><span class="hljs-string">"../HexCellData.cginc"</span></span> UNITY_DECLARE_TEX2DARRAY(<span class="hljs-name"><span class="hljs-name">_MainTex</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam program titik, kami memperoleh data sel untuk ketiga indeks sel yang disimpan dalam data titik. </font><font style="vertical-align: inherit;">Kemudian tetapkan </font></font><code>data.terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indeks ketinggian mereka.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); // data.terrain = v.texcoord2.xyz; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.terrain.x = cell0.w; data.terrain.y = cell1.w; data.terrain.z = cell2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, peta kembali mulai menampilkan medan yang benar. </font><font style="vertical-align: inherit;">Perbedaan besar adalah bahwa pengeditan hanya tipe medan tidak lagi mengarah ke triangulasi baru. </font><font style="vertical-align: inherit;">Jika selama mengedit data sel lainnya diubah, maka triangulasi akan dilakukan seperti biasa. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilitas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menciptakan dasar sel-sel ini, kita dapat melanjutkan untuk mendukung visibilitas. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami menggunakan shader, sel itu sendiri, dan objek yang menentukan visibilitas. </font><font style="vertical-align: inherit;">Perhatikan bahwa proses triangulasi sama sekali tidak mengetahui tentang ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan memberi tahu shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tentang visibilitas. </font><font style="vertical-align: inherit;">Ini akan menerima data visibilitas dari program vertex dan meneruskannya ke program fragmen menggunakan struktur </font></font><code>Input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena kami melewati tiga indeks ketinggian yang terpisah, kami akan melewati tiga nilai visibilitas juga.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float4 color : <span class="hljs-type"><span class="hljs-type">COLOR</span></span>; float3 worldPos; float3 terrain; float3 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menyimpan visibilitas, kami menggunakan komponen pertama sel-sel ini. </font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { UNITY_INITIALIZE_OUTPUT(Input, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); float4 cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); float4 cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); float4 cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.x = cell0.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.y = cell1.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.terrain.z = cell2.w; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilitas 0 berarti sel saat ini tidak terlihat. </font><font style="vertical-align: inherit;">Jika itu terlihat, itu akan memiliki nilai visibilitas 1. Oleh karena itu, kita dapat menggelapkan medan dengan mengalikan hasilnya </font></font><code>GetTerrainColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan vektor visibilitas yang sesuai. </font><font style="vertical-align: inherit;">Jadi, kami secara individual memodulasi warna relief dari setiap sel campuran.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/183/e69/1bf183e695a42f4691f63cec72255993.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sel-sel menjadi hitam.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak bisakah kita menggabungkan visibilitas dalam program vertex?</font></font></b> <div class="spoiler_text">   ,           .              .           .        ,      .   ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gelap total adalah penghalang bagi sel-sel yang tidak terlihat sementara. </font><font style="vertical-align: inherit;">Agar kita masih bisa melihat kelegaan, kita perlu meningkatkan indikator yang digunakan untuk sel-sel tersembunyi. </font><font style="vertical-align: inherit;">Mari kita beralih dari 0-1 ke ¼ - 1, yang dapat dilakukan dengan menggunakan fungsi </font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di akhir program vertex.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell1.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.z = cell2.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a20/090/3e2/a200903e2f31f3bdcd0c996d42f91a02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sel teduh.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelacakan visibilitas sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar visibilitas berfungsi, sel harus melacak visibilitasnya. Tetapi bagaimana sebuah sel menentukan apakah itu terlihat? Kita dapat melakukan ini dengan melacak jumlah entitas yang melihatnya. Ketika seseorang mulai melihat sel, ia harus melaporkan sel ini. Dan ketika seseorang berhenti melihat sel, dia juga harus memberi tahu dia tentang hal itu. Sel hanya melacak jumlah pengamat, apa pun entitas itu. Jika sel memiliki nilai visibilitas minimal 1, maka itu terlihat, jika tidak maka tidak terlihat. Untuk menerapkan perilaku ini, kami menambahkan </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua metode dan properti </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">variabel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visibility; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, tambahkan ke </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang melakukan hal yang sama </font></font><code>RefreshTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hanya demi visibilitas. </font><font style="vertical-align: inherit;">Menyimpan data dalam komponen R dari sel data. </font><font style="vertical-align: inherit;">Karena kami bekerja dengan byte yang dikonversi ke nilai 0-1, kami menggunakan untuk menunjukkan visibilitas </font></font><code>(byte)255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cellTextureData[cell.Index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami akan memanggil metode ini dengan meningkatkan dan menurunkan visibilitas, mengubah nilai antara 0 dan 1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menciptakan visibilitas pasukan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita membuatnya sehingga unit dapat melihat sel yang mereka tempati. </font><font style="vertical-align: inherit;">Ini dilakukan dengan menggunakan panggilan </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke lokasi baru unit selama tugas </font></font><code>HexUnit.Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami juga memanggil lokasi lama (jika ada) </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } location = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Unit = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.IncreaseVisibility(); transform.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Position; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/f95/a07/7bcf95a07fdf4c10ed1d53055dddf6a4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit dapat melihat di mana mereka berada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya kami menggunakan visibilitas! </font><font style="vertical-align: inherit;">Saat ditambahkan ke peta, unit membuat sel mereka terlihat. </font><font style="vertical-align: inherit;">Selain itu, ruang lingkup mereka diteleportasi ketika pindah ke lokasi baru mereka. </font><font style="vertical-align: inherit;">Tetapi ruang lingkup mereka tetap aktif saat mengeluarkan unit dari peta. </font><font style="vertical-align: inherit;">Untuk memperbaiki ini, kami akan mengurangi visibilitas lokasi mereka saat menghancurkan unit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { location.DecreaseVisibility(); } location.Unit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(gameObject); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rentang visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kita hanya melihat sel tempat detasemen itu berada, dan ini membatasi kemungkinan. Setidaknya kita perlu melihat sel tetangga. Dalam kasus umum, unit dapat melihat semua sel dalam jarak tertentu, yang tergantung pada unit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita tambahkan ke </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode untuk menemukan semua sel terlihat dari satu sel dengan mempertimbangkan rentang. Kita dapat membuat metode ini dengan menduplikasi dan mengubah </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ubah parameternya dan buat kembali daftar sel tempat Anda bisa menggunakan kumpulan daftar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada setiap iterasi, sel saat ini ditambahkan ke daftar. Tidak ada lagi sel akhir, jadi pencarian tidak akan pernah berakhir ketika mencapai titik ini. Kami juga menyingkirkan logika bergerak dan biaya bergerak. Buat properti</font></font><code>PathFrom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mereka tidak lagi ditanya karena kita tidak membutuhkannya, dan kita tidak ingin mengganggu jalan di sepanjang grid. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada setiap langkah, jarak hanya meningkat dengan 1. Jika melebihi kisaran, maka sel ini dilewati. </font><font style="vertical-align: inherit;">Dan kami tidak memerlukan pencarian heuristik, jadi kami menginisialisasi dengan nilai 0. Artinya, pada dasarnya, kami kembali ke algoritma Dijkstra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; visibleCells = ListPool&lt;HexCell&gt;.Get(); searchFrontierPhase += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchFrontier.Clear(); } fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.SearchPhase += <span class="hljs-number"><span class="hljs-number">1</span></span>; visibleCells.Add(current); <span class="hljs-comment"><span class="hljs-comment">// if (current == toCell) { // return true; // } // int currentTurn = (current.Distance - 1) / speed; for (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); if ( neighbor == null || neighbor.SearchPhase &gt; searchFrontierPhase ) { continue; } // … // int moveCost; // … int distance = current.Distance + 1; if (distance &gt; range) { continue; } // int turn = (distance - 1) / speed; // if (turn &gt; currentTurn) { // distance = turn * speed + moveCost; // } if (neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = distance; // neighbor.PathFrom = current; neighbor.SearchHeuristic = 0; searchFrontier.Enqueue(neighbor); } else if (distance &lt; neighbor.Distance) { int oldPriority = neighbor.SearchPriority; neighbor.Distance = distance; // neighbor.PathFrom = current; searchFrontier.Change(neighbor, oldPriority); } } } return visibleCells; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak bisakah kita menggunakan algoritma yang lebih sederhana untuk menemukan semua sel dalam jangkauan?</font></font></b> <div class="spoiler_text"> ,          ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga tambahkan </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mereka mendapatkan sel dan rentang, mengambil daftar sel yang sesuai dan meningkatkan / menurunkan visibilitas mereka. </font><font style="vertical-align: inherit;">Setelah selesai, mereka harus mengembalikan daftar itu ke kumpulannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].IncreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { List&lt;HexCell&gt; cells = GetVisibleCells(fromCell, range); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Count; i++) { cells[i].DecreaseVisibility(); } ListPool&lt;HexCell&gt;.Add(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menggunakan metode ini </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memerlukan akses ke kisi, jadi tambahkan properti ke dalamnya </font></font><code>Grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat Anda menambahkan skuad ke kisi, ia akan menetapkan kisi ke properti ini </font></font><code>HexGrid.AddUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddUnit</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexUnit unit, HexCell location, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation</span></span></span><span class="hljs-function">)</span></span> { units.Add(unit); unit.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; unit.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); unit.Location = location; unit.Orientation = orientation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mulai dengan, kisaran visibilitas tiga sel akan cukup. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita tambahkan ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konstanta, yang di masa depan selalu dapat berubah menjadi variabel. </font><font style="vertical-align: inherit;">Kemudian kita akan membuat metode memanggil regu untuk grid </font></font><code>IncreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>DecreaseVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mentransmisikan juga jangkauan visibilitasnya, dan tidak hanya pergi ke tempat ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visionRange = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell Location { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> location; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { <span class="hljs-comment"><span class="hljs-comment">// location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); location.Unit = null; } location = value; value.Unit = this; // value.IncreaseVisibility(); Grid.IncreaseVisibility(value, visionRange); transform.localPosition = value.Position; } } … public void Die () { if (location) { // location.DecreaseVisibility(); Grid.DecreaseVisibility(location, visionRange); } location.Unit = null; Destroy(gameObject); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/c45/ccb/8cdc45ccb01449b3c7d50a7bef9b249c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unit dengan rentang visibilitas yang dapat tumpang tindih.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilitas saat bergerak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, area visibilitas skuad setelah perintah bergerak segera dipindahkan ke titik akhir. </font><font style="vertical-align: inherit;">Akan terlihat lebih baik jika unit dan bidang visibilitasnya bergerak bersama. </font><font style="vertical-align: inherit;">Langkah pertama untuk ini adalah bahwa kami tidak akan lagi menetapkan properti </font></font><code>Location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>HexUnit.Travel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebagai gantinya, kami akan langsung mengubah bidang </font></font><code>location</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menghindari kode properti. </font><font style="vertical-align: inherit;">Karenanya, kami akan menghapus lokasi lama secara manual dan mengonfigurasi lokasi baru. </font><font style="vertical-align: inherit;">Visibilitas akan tetap tidak berubah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Travel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;HexCell&gt; path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Location = path[path.Count - 1]; location.Unit = null; location = path[path.Count - 1]; location.Unit = this; pathToTravel = path; StopAllCoroutines(); StartCoroutine(TravelPath()); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di dalam coroutine, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita akan mengurangi visibilitas sel pertama hanya setelah selesai </font></font><code>LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setelah itu, sebelum pindah ke sel baru, kami akan meningkatkan visibilitas dari sel ini. </font><font style="vertical-align: inherit;">Setelah selesai dengan ini, kami kembali mengurangi visibilitas darinya. </font><font style="vertical-align: inherit;">Akhirnya, tingkatkan visibilitas dari sel terakhir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-comment"><span class="hljs-comment">// transform.localPosition = c; yield return LookAt(pathToTravel[1].Position); Grid.DecreaseVisibility(pathToTravel[0], visionRange); float t = Time.deltaTime * travelSpeed; for (int i = 1; i &lt; pathToTravel.Count; i++) { a = c; b = pathToTravel[i - 1].Position; c = (b + pathToTravel[i].Position) * 0.5f; Grid.IncreaseVisibility(pathToTravel[i], visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= 1f; } a = c; b = location.Position; // We can simply use the destination here. c = b; Grid.IncreaseVisibility(location, visionRange); for (; t &lt; 1f; t += Time.deltaTime * travelSpeed) { … } … }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilitas saat bepergian. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua ini berfungsi, kecuali ketika pesanan baru dikeluarkan pada saat detasemen bergerak. </font><font style="vertical-align: inherit;">Ini mengarah pada teleportasi, yang juga harus berlaku untuk visibilitas. </font><font style="vertical-align: inherit;">Untuk mewujudkan ini, kita perlu melacak lokasi skuad saat ini saat bergerak.</font></font><br><br><pre> <code class="cs hljs"> HexCell location, currentTravelLocation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan memperbarui lokasi ini setiap kali kami menekan sel baru saat bergerak, hingga skuad mencapai sel terakhir. </font><font style="vertical-align: inherit;">Maka harus diatur ulang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; pathToTravel.Count; i++) { currentTravelLocation = pathToTravel[i]; a = c; b = pathToTravel[i - <span class="hljs-number"><span class="hljs-number">1</span></span>].Position; c = (b + currentTravelLocation.Position) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Grid.IncreaseVisibility(pathToTravel[i], visionRange); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; t &lt; <span class="hljs-number"><span class="hljs-number">1f</span></span>; t += Time.deltaTime * travelSpeed) { transform.localPosition = Bezier.GetPoint(a, b, c, t); Vector3 d = Bezier.GetDerivative(a, b, c, t); dy = <span class="hljs-number"><span class="hljs-number">0f</span></span>; transform.localRotation = Quaternion.LookRotation(d); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } Grid.DecreaseVisibility(pathToTravel[i], visionRange); t -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang setelah menyelesaikan pergantian, </font></font><code>TravelPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita dapat memeriksa apakah lokasi perantara yang lama diketahui. </font><font style="vertical-align: inherit;">Jika ya, maka Anda perlu mengurangi visibilitas dalam sel ini, dan tidak di awal jalan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TravelPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a, b, c = pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pathToTravel[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">].Position</span></span></span><span class="hljs-function">)</span></span>; Grid.DecreaseVisibility( currentTravelLocation ? currentTravelLocation : pathToTravel[<span class="hljs-number"><span class="hljs-number">0</span></span>], visionRange ); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita juga perlu memperbaiki visibilitas setelah kompilasi yang terjadi selama pergerakan pasukan. </font><font style="vertical-align: inherit;">Jika lokasi perantara masih diketahui, maka kurangi visibilitas di dalamnya dan tingkatkan visibilitas di titik akhir, lalu atur ulang lokasi perantara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location) { transform.localPosition = location.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTravelLocation) { Grid.IncreaseVisibility(location, visionRange); Grid.DecreaseVisibility(currentTravelLocation, visionRange); currentTravelLocation = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilitas jalan dan air </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun perubahan warna bantuan didasarkan pada visibilitas, ini tidak mempengaruhi jalan dan air. </font><font style="vertical-align: inherit;">Mereka terlihat terlalu cerah untuk sel yang tidak terlihat. </font><font style="vertical-align: inherit;">Untuk menerapkan visibilitas ke jalan dan air, kita perlu menambahkan indeks sel dan mencampur bobot ke data mesh mereka. </font><font style="vertical-align: inherit;">Oleh karena itu, kami akan memeriksa anak-anak dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Sel Penggunaan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perairan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muara</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fragmen cetakan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jalan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan mulai dari jalan. </font><font style="vertical-align: inherit;">Metode ini </font></font><code>HexGridChunk.TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan untuk membuat sebagian kecil jalan di tengah sel, sehingga perlu satu indeks sel. </font><font style="vertical-align: inherit;">Tambahkan parameter ke sana dan buat data sel untuk segitiga.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); Vector3 indices; indices.x = indices.y = indices.z = index; roads.AddTriangleCellData(indices, weights1); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara mudah lain untuk membuat jalan adalah </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini digunakan baik di dalam maupun di antara sel, sehingga harus bekerja dengan dua indeks yang berbeda. </font><font style="vertical-align: inherit;">Untuk ini, nyaman untuk menggunakan parameter indeks vektor. </font><font style="vertical-align: inherit;">Karena ruas jalan dapat menjadi bagian dari tepian, bobot juga harus melewati parameter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6, Color w1, Color w2, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadCellData(indices, w1, w2); roads.AddQuadCellData(indices, w1, w2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita beralih ke </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang menciptakan jalan di dalam sel. </font><font style="vertical-align: inherit;">Itu juga membutuhkan parameter indeks. </font><font style="vertical-align: inherit;">Dia melewati data ini ke metode jalan yang dia panggil, dan menambahkannya ke segitiga yang dia buat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 indices; indices.x = indices.y = indices.z = index; Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment( mL, mC, mR, e.v2, e.v3, e.v4, weights1, weights1, indices ); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleCellData(indices, weights1); roads.AddTriangleCellData(indices, weights1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR, index); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap menambahkan argumen metode yang diperlukan untuk </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateRoadEdge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk memperbaiki semua kesalahan kompiler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction), cell.Index ); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge, cell.Index); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL, cell.Index); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center, cell.Index); } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> … </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment( e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4, w1, w2, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang data mesh sudah benar, dan kita akan beralih ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Perlu program vertex dan harus mengandung </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">decal</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:blend</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">HexCellData</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.cginc</span></span>"</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena kami tidak mencampurkan beberapa bahan, cukup bagi kami untuk memasukkan satu indikator visibilitas ke dalam program fragmen. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> {</span></span> float2 uv_MainTex; float3 worldPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cukup untuk program vertex baru untuk menerima data dari dua sel. </font><font style="vertical-align: inherit;">Kami segera mencampur visibilitas mereka, menyesuaikannya dan menambah output.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam program fragmen, kita hanya perlu menambahkan visibilitas ke warna. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/92f/46e/af892f46e364906cc547aaecb4e50e3a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan dengan jarak pandang.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Air terbuka </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin terlihat bahwa visibilitas telah mempengaruhi air, tetapi ini hanya permukaan medan yang terbenam dalam air. </font><font style="vertical-align: inherit;">Mari kita mulai dengan menerapkan visibilitas ke perairan terbuka. </font><font style="vertical-align: inherit;">Untuk ini kita perlu berubah </font></font><code>HexGridChunk.TriangulateOpenWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, c1, c2); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … water.AddQuad(c1, c2, e1, e2); indices.y = neighbor.Index; water.AddQuadCellData(indices, weights1, weights2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); indices.z = nextNeighbor.Index; water.AddTriangleCellData( indices, weights1, weights2, weights3 ); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kita juga perlu menambahkan data sel ke penggemar segitiga di dekat pantai. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); Vector3 indices; indices.x = indices.y = indices.z = cell.Index; water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); water.AddTriangleCellData(indices, weights1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perlu diubah dengan cara yang sama dengan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">, tetapi perlu menggabungkan visibilitas tidak hanya dua, tetapi tiga sel.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a4/c52/36c/6a4c5236c52eaae78cbde54fb2fdeeac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air terbuka dengan visibilitas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pantai dan muara </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendukung pantai, kita perlu berubah lagi </font></font><code>HexGridChunk.TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami sudah membuat vektor indeks, tetapi kami hanya menggunakan satu indeks sel untuk perairan terbuka. </font><font style="vertical-align: inherit;">Pantai juga membutuhkan indeks tetangga, jadi ubah kodenya.</font></font><br><br><pre> <code class="cs hljs"> Vector3 indices; <span class="hljs-comment"><span class="hljs-comment">// indices.x = indices.y = indices.z = cell.Index; indices.x = indices.z = cell.Index; indices.y = neighbor.Index;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan data sel ke paha depan dan segitiga pantai. </font><font style="vertical-align: inherit;">Kami juga menyampaikan indeks panggilan </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary( e1, e2, cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); waterShore.AddQuadCellData(indices, weights1, weights2); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … waterShore.AddTriangleUV( … ); indices.z = nextNeighbor.Index; waterShore.AddTriangleCellData( indices, weights1, weights2, weights3 ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan parameter yang diperlukan ke </font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan rawat sel-sel ini untuk pantai dan mulut. </font><font style="vertical-align: inherit;">Jangan lupa bahwa mulutnya terbuat dari trapesium dengan dua segitiga pantai di sisinya. </font><font style="vertical-align: inherit;">Kami memastikan bahwa bobot ditransfer dalam urutan yang benar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); waterShore.AddTriangleCellData(indices, weights2, weights1, weights1); estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadCellData( indices, weights2, weights1, weights2, weights1 ); estuaries.AddTriangleCellData(indices, weights1, weights2, weights2); estuaries.AddQuadCellData(indices, weights1, weights2); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waterShore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader, </font><em><font style="vertical-align: inherit;">Anda</font></em><font style="vertical-align: inherit;"> perlu membuat perubahan yang sama seperti di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">, mencampurkan visibilitas tiga sel.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell2 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">2</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y + cell2.x * v.color.z; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheider </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muara</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> campuran visibilitas dari dua sel, serta shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan Umum Deskripsi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dia sudah memiliki program vertex, karena kita membutuhkannya untuk mengirimkan koordinat UV sungai.</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.visibility = cell0.x * v.color.x + cell1.x * v.color.y; o.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, o.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88f/829/254/88f829254235a293040ac755d8318bc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pantai dan muara dengan visibilitas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daerah air terakhir yang bekerja adalah sungai. </font><font style="vertical-align: inherit;">Tambahkan </font></font><code>HexGridChunk.TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektor indeks </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">parameter dan menambahkannya ke jala sehingga dapat mempertahankan visibilitas dua sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed, indices); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br> <code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menciptakan titik akhir sungai dengan quad dan segitiga di tengah sel. </font><font style="vertical-align: inherit;">Tambahkan data sel yang diperlukan untuk ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; Vector3 indices; indices.x = indices.y = indices.z = cell.Index; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); … rivers.AddTriangleCellData(indices, weights1); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sudah memiliki indeks sel ini </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi kami hanya meneruskannya saat menelepon </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed, indices ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed, indices ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami juga menambahkan dukungan indeks ke air terjun yang mengalir ke air yang dalam. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY, Vector3 indices </span></span></span><span class="hljs-function">)</span></span> { … rivers.AddQuadCellData(indices, weights1, weights2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, ubahlah </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga melewati indeks yang diperlukan untuk metode sungai dan air terjun.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { e2.v3.y = neighbor.StreamBedY; Vector3 indices; indices.x = indices.z = cell.Index; indices.y = neighbor.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction, indices ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY, indices ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY, indices ); } } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perlu membuat perubahan yang sama dengan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "HexCellData.cginc" sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell0 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> cell1 = GetCellData(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); data.visibility = cell0.x * v.color.x + cell1.x * v.color.y; data.visibility = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ef/db6/76a/1efdb676afe28b61b73f317d25158505.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai dengan visibilitas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objek dan Visibilitas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang visibilitas berfungsi untuk seluruh medan yang dihasilkan secara prosedural, tetapi sejauh ini tidak memengaruhi fitur medan. Bangunan, pertanian, dan pohon dibuat dari prefab, dan bukan dari geometri prosedural, jadi kami tidak dapat menambahkan indeks sel dan mencampur bobot dengan simpulnya. Karena masing-masing objek ini hanya dimiliki oleh satu sel, kita perlu menentukan di mana sel mereka berada. Jika kita bisa melakukan ini, maka kita akan mendapatkan akses ke data sel yang sesuai dan menerapkan visibilitas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita sudah bisa mengubah posisi XZ dunia menjadi indeks sel. Transformasi ini digunakan untuk mengedit medan dan mengelola regu. Namun, kode yang sesuai adalah nontrivial. Ia menggunakan operasi integer dan membutuhkan logika untuk bekerja dengan edge. Ini tidak praktis untuk shader, jadi kita dapat memanggang sebagian besar logika dalam tekstur dan menggunakannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sudah menggunakan tekstur dengan pola heksagonal untuk memproyeksikan kisi di atas topografi. Tekstur ini mendefinisikan area sel 2 × 2. Karena itu, kita dapat dengan mudah menghitung di area mana kita berada. Setelah itu, Anda bisa menerapkan tekstur yang mengandung offset X dan Z untuk sel di area ini dan menggunakan data ini untuk menghitung sel tempat kami berada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah tekstur yang serupa. X offset disimpan di saluran merahnya, dan offset Z disimpan di saluran hijau. Karena mencakup area sel 2 × 2, kita perlu offset dari 0 dan 2. Data tersebut tidak dapat disimpan dalam saluran warna, sehingga offset dikurangi setengahnya. Kita tidak membutuhkan tepi sel yang jelas, jadi tekstur kecil sudah cukup.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/63c/d3c/79563cd3c22e7aa2ca66e40b5ffe3f7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur kisi koordinat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan tekstur ke proyek. </font><font style="vertical-align: inherit;">Atur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wrap Mode-nya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repeat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sama seperti tekstur mesh lainnya. </font><font style="vertical-align: inherit;">Kami tidak membutuhkan pencampuran, jadi untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blend Mode</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami akan memilih </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Point</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Matikan juga </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompresi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agar data tidak terdistorsi. </font><font style="vertical-align: inherit;">Matikan mode </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sRGB</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga ketika merender dalam mode linear, tidak ada konversi ruang warna yang dilakukan. </font><font style="vertical-align: inherit;">Dan akhirnya, kita tidak perlu tekstur mip.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/866/aa9/de3/866aa9de36f6953f54d4fb8197fb75ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi impor tekstur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obyek Shader dengan Visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> baru </font><font style="vertical-align: inherit;">untuk menambahkan dukungan visibilitas ke objek. </font><font style="vertical-align: inherit;">Ini adalah shader permukaan sederhana dengan program titik. </font><font style="vertical-align: inherit;">Tambahkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> padanya </font><font style="vertical-align: inherit;">dan berikan indikator visibilitas ke program fragmen, dan seperti biasa, pertimbangkan dalam warna. </font><font style="vertical-align: inherit;">Perbedaannya di sini adalah bahwa kita tidak dapat menggunakannya </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena data mesh yang diperlukan tidak ada. </font><font style="vertical-align: inherit;">Sebaliknya, kita memiliki posisi di dunia. </font><font style="vertical-align: inherit;">Tetapi untuk sekarang, biarkan visibilitas sama dengan 1.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Feature" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> [NoTilingOffset] _GridCoordinates ("Grid Coordinates", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "../HexCellData.cginc" sampler2D _MainTex, _GridCoordinates; half _Glossiness; half _Metallic; fixed4 _Color; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float</span></span> visibility; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubah semua bahan objek sehingga mereka menggunakan shader baru dan berikan mereka tekstur koordinat grid. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e35/fad/546/e35fad5469e6c9e5c6a31626ba182ec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkotaan dengan tekstur jala.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akses data sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk sampel tekstur koordinat grid dalam program vertex, kita lagi membutuhkan </font></font><code>tex2Dlod</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vektor koordinat tekstur empat komponen. </font><font style="vertical-align: inherit;">Dua koordinat pertama adalah posisi dunia XZ. </font><font style="vertical-align: inherit;">Dua lainnya sama dengan nol seperti sebelumnya.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); float3 pos = mul(unity_ObjectToWorld, v.vertex); <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); data.visibility = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti pada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">, kami meregangkan koordinat UV sehingga tekstur memiliki rasio aspek yang benar sesuai dengan kisi segi enam.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengetahui di bagian mana sel 2 × 2 kita berada dengan mengambil nilai koordinat UV dibulatkan ke bawah. </font><font style="vertical-align: inherit;">Ini membentuk dasar untuk koordinat sel.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> gridUV = <span class="hljs-type"><span class="hljs-type">float4</span></span>(pos.xz, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); float2 cellDataCoordinates = floor(gridUV.xy);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk menemukan koordinat sel tempat kami berada, kami menambahkan perpindahan yang disimpan dalam tekstur. </font></font><br><br><pre> <code class="hljs pgsql"> float2 cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena bagian dari kisi berukuran 2 × 2, dan offset dibagi dua, kita perlu menggandakan hasilnya untuk mendapatkan koordinat akhir. </font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">float2</span></span> cellDataCoordinates = floor(gridUV.xy) + tex2Dlod(_GridCoordinates, gridUV).rg; <span class="hljs-attribute"><span class="hljs-attribute">cellDataCoordinates</span></span> *= <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki koordinat XZ dari kisi sel yang perlu kita konversi menjadi koordinat UV sel-sel ini. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan hanya berpindah ke pusat piksel dan kemudian membaginya menjadi ukuran tekstur. </font><font style="vertical-align: inherit;">Jadi mari kita tambahkan </font><font style="vertical-align: inherit;">fungsi untuk ini ke file </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> termasuk </font><font style="vertical-align: inherit;">yang juga akan menangani pengambilan sampel.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { float2 uv = cellDataCoordinates + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; uv.x *= _HexCellData_TexelSize.x; uv.y *= _HexCellData_TexelSize.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menggunakan ini dalam program vertex shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur yang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs haskell"> cellDataCoordinates *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GetCellData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cellDataCoordinates</span></span></span><span class="hljs-class">).x; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/9c9/7ed/1ed9c97ed37aa88aaee6c0efd9d075d7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek dengan visibilitas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akhirnya, visibilitas mempengaruhi seluruh peta, dengan pengecualian unit yang selalu terlihat. Karena kita menentukan visibilitas objek untuk setiap verteks, maka untuk objek yang melintasi batas sel, visibilitas sel yang ditutup akan bercampur. Tetapi objek sangat kecil sehingga mereka terus-menerus tetap di dalam sel mereka, bahkan dengan mempertimbangkan distorsi posisi. Namun, beberapa mungkin merupakan bagian dari simpul di sel lain. Karena itu, pendekatan kami murah, tetapi tidak sempurna. Ini paling terlihat dalam kasus dinding, visibilitasnya bervariasi antara visibilitas dari sel tetangga.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/1c7/f7d/4211c7f7dea80bbbd13664586074c43a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding dengan perubahan visibilitas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena segmen dinding dihasilkan secara prosedural, kita dapat menambahkan data sel ke mesh mereka dan menggunakan pendekatan yang kita gunakan untuk bantuan. </font><font style="vertical-align: inherit;">Sayangnya, menara adalah cetakan, jadi kami masih akan memiliki inkonsistensi. </font><font style="vertical-align: inherit;">Secara umum, pendekatan yang ada terlihat cukup baik untuk geometri sederhana yang kami gunakan. </font><font style="vertical-align: inherit;">Di masa depan, kami akan mempertimbangkan model dan dinding yang lebih rinci, oleh karena itu, kami akan meningkatkan metode pencampuran visibilitas mereka. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 21: penelitian peta </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menampilkan semuanya selama mengedit. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami melacak sel yang diselidiki. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menyembunyikan apa yang masih belum diketahui. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memaksa unit untuk menghindari area yang belum dijelajahi. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada bagian sebelumnya, kami menambahkan kabut perang, yang sekarang akan kami sempurnakan untuk mengimplementasikan penelitian peta. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81d/40e/bff/81d40ebff615fc7c4e39a15d88da016d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami siap menjelajah dunia.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilkan seluruh peta dalam mode edit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arti dari penelitian ini adalah bahwa sampai sel-sel tidak terlihat dianggap tidak diketahui, dan karena itu tidak terlihat. </font><font style="vertical-align: inherit;">Mereka seharusnya tidak dikaburkan, tetapi tidak ditampilkan sama sekali. </font><font style="vertical-align: inherit;">Karena itu, sebelum menambahkan dukungan penelitian, kami akan mengaktifkan visibilitas dalam mode edit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengalihan Visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat mengontrol apakah shader menggunakan visibilitas menggunakan kata kunci, seperti yang dilakukan pada hamparan di grid. </font><font style="vertical-align: inherit;">Mari kita gunakan kata kunci </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font><font style="vertical-align: inherit;">menunjukkan status mode pengeditan. </font><font style="vertical-align: inherit;">Karena beberapa shader harus tahu tentang kata kunci ini, kami akan mendefinisikannya secara global menggunakan metode statis </font></font><code>Shader.EnableKeyWord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Shader.DisableKeyword</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan memanggil metode yang sesuai </font></font><code>HexGameUI.SetEditMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika mengubah mode pengeditan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { enabled = !toggle; grid.ShowUI(!toggle); grid.ClearPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (toggle) { Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Shader.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edit mode shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> didefinisikan, shader akan mengabaikan visibilitas. </font><font style="vertical-align: inherit;">Ini bermuara pada kenyataan bahwa visibilitas sel akan selalu dianggap sama dengan 1. Mari kita tambahkan </font><font style="vertical-align: inherit;">fungsi untuk memfilter data sel tergantung pada kata kunci </font><font style="vertical-align: inherit;">di awal file-file </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HexCellData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs kotlin">sampler2D _HexCellData; float4 _HexCellData_TexelSize; float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melewati fungsi ini hasil dari kedua fungsi </font></font><code>GetCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum mengembalikannya.</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (appdata_full v, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(data); } <span class="hljs-type"><span class="hljs-type">float4</span></span> GetCellData (float2 cellDataCoordinates) { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FilterCellData(tex2Dlod(_HexCellData, <span class="hljs-type"><span class="hljs-type">float4</span></span>(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar semuanya berfungsi, semua shader yang relevan harus menerima arahan multi_compile untuk membuat opsi seandainya kata kunci </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HEX_MAP_EDIT_MODE</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditentukan. </font><font style="vertical-align: inherit;">Tambahkan garis yang sesuai ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shaders </font><font style="vertical-align: inherit;">, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feature</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Road</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , antara arahan target dan yang pertama termasuk arahan.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> multi_compile _ HEX_MAP_EDIT_MODE</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika beralih ke mode edit peta, kabut perang akan hilang. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penelitian sel </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara default, sel harus dianggap belum dijelajahi. </font><font style="vertical-align: inherit;">Mereka menjadi dieksplorasi ketika sebuah regu melihat mereka. </font><font style="vertical-align: inherit;">Setelah itu, mereka terus tetap diselidiki jika detasemen dapat melihat mereka.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Melacak Status Studi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menambahkan dukungan untuk memantau status studi, kami menambah </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti umum </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keadaan penelitian ditentukan oleh sel itu sendiri. </font><font style="vertical-align: inherit;">Karena itu, properti ini hanya boleh disetel </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk menambahkan batasan ini, kami akan menetapkan setter pribadi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama kali visibilitas sel menjadi lebih besar dari nol, sel mulai dianggap diselidiki, dan karenanya </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai harus ditetapkan </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bahkan, cukup bagi kita untuk hanya menandai sel saat diperiksa ketika visibilitas meningkat menjadi 1. Ini harus dilakukan sebelum panggilan </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncreaseVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { visibility += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility == <span class="hljs-number"><span class="hljs-number">1</span></span>) { IsExplored = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mentransfer status penelitian ke shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti dalam kasus dengan visibilitas sel, kami mentransfer status penelitian mereka ke shader melalui data shader. </font><font style="vertical-align: inherit;">Pada akhirnya, itu hanyalah jenis visibilitas lainnya. </font></font><code>HexCellShaderData.RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan status visibilitas dalam saluran data R. </font><font style="vertical-align: inherit;">Mari kita jaga keadaan penelitian di saluran G data.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relief hitam yang belum dijelajahi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menggunakan shader untuk memvisualisasikan keadaan penelitian sel. </font><font style="vertical-align: inherit;">Untuk memastikan semuanya berjalan sebagaimana mestinya, kami hanya membuat medan yang tidak dijelajahi menjadi hitam. </font><font style="vertical-align: inherit;">Tetapi pertama-tama, untuk membuat mode pengeditan berfungsi, ubahlah </font></font><code>FilterCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga memfilter data penelitian.</font></font><br><br><pre> <code class="hljs kotlin">float4 FilterCellData (float4 <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(HEX_MAP_EDIT_MODE) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.xy = <span class="hljs-number"><span class="hljs-number">1</span></span>; #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">meneruskan data visibilitas ketiga sel yang mungkin ke program fragmen. </font><font style="vertical-align: inherit;">Dalam kasus keadaan penelitian, kami menggabungkan mereka dalam program vertex dan mentransfer satu-satunya nilai ke program fragmen. </font><font style="vertical-align: inherit;">Tambahkan </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komponen keempat ke </font><font style="vertical-align: inherit;">input </font><font style="vertical-align: inherit;">sehingga kita punya tempat untuk ini.</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; <span class="hljs-type"><span class="hljs-type">float4</span></span> visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, dalam program vertex, ketika kita mengubah indeks visibilitas, kita harus secara eksplisit mengakses </font></font><code>data.visibility.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { … data.visibility.xyz = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.xyz); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah itu, kami menggabungkan keadaan penelitian dan menulis hasilnya </font></font><code>data.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini mirip dengan menggabungkan visibilitas dalam shader lain, tetapi menggunakan komponen Y dari sel-sel ini.</font></font><br><br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.xyz = lerp(0.25, 1, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xyz</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">.visibility.w = cell0.y * v.color.x + cell1.y * v.color.y + cell2.y * v.color.z;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status penelitian sekarang tersedia dalam program fragmen melalui </font></font><code>IN.visibility.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertimbangkan itu dalam perhitungan albedo.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2d/de4/c18/b2dde4c1831a9ecc637550b2b8e2e134.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topografi yang belum dijelajahi sekarang berwarna hitam. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief sel yang belum dijelajahi sekarang memiliki warna hitam. </font><font style="vertical-align: inherit;">Tapi ini belum mempengaruhi benda, jalan, dan air. </font><font style="vertical-align: inherit;">Namun, ini cukup untuk memastikan bahwa penelitian ini berhasil.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyimpan dan memuat status penelitian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami telah menambahkan dukungan penelitian, kami perlu memastikan bahwa status penelitian diperhitungkan saat menyimpan dan memuat peta. </font><font style="vertical-align: inherit;">Karena itu, kita perlu meningkatkan versi file peta menjadi 3. Untuk membuat perubahan ini lebih nyaman, mari kita tambahkan </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konstanta </font><font style="vertical-align: inherit;">untuk ini </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menggunakan konstanta ini ketika menulis versi file ke </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan ketika memeriksa dukungan file di </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(mapFileVersion); hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= mapFileVersion) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai langkah terakhir, </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami mencatat status penelitian.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { … writer.Write(IsExplored); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kita akan membacanya di bagian akhir </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setelah itu, kami akan memanggil </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika keadaan penelitian berbeda dari yang sebelumnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = reader.ReadBoolean(); ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menjaga kompatibilitas ke belakang dengan file penyimpanan lama, kita harus melewati membaca status penyimpanan jika versi file kurang dari 3. Dalam kasus ini, secara default, sel-sel akan memiliki status "belum dijelajahi". </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu menambahkan </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data header </font><font style="vertical-align: inherit;">sebagai parameter </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … IsExplored = header &gt;= <span class="hljs-number"><span class="hljs-number">3</span></span> ? reader.ReadBoolean() : <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus melewati </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data header.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, saat menyimpan dan memuat peta, keadaan eksplorasi sel akan diperhitungkan. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan sel yang tidak dikenal </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap saat ini, sel-sel yang belum dijelajahi secara visual diindikasikan oleh relief hitam. </font><font style="vertical-align: inherit;">Namun pada kenyataannya, kami ingin sel-sel ini tidak terlihat karena tidak diketahui. </font><font style="vertical-align: inherit;">Kita dapat membuat geometri buram transparan sehingga tidak terlihat. </font><font style="vertical-align: inherit;">Namun, kerangka shader permukaan Unity dikembangkan tanpa mempertimbangkan kemungkinan ini. </font><font style="vertical-align: inherit;">Alih-alih menggunakan transparansi sejati, kami akan mengubah shader agar sesuai dengan latar belakang, yang juga akan membuatnya tidak terlihat.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat lega benar-benar hitam </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun relief yang dipelajari berwarna hitam, kita masih bisa mengenalinya karena masih memiliki pencahayaan specular. Untuk menghilangkan pencahayaan, kita harus membuatnya hitam sempurna. Agar tidak mempengaruhi sifat permukaan lainnya, paling mudah untuk mengubah warna specular menjadi hitam. Ini dimungkinkan jika Anda menggunakan permukaan shader yang bekerja dengan specular, tapi sekarang kami menggunakan logam standar. Jadi mari kita mulai dengan mengganti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shader </font><font style="vertical-align: inherit;">ke specular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ganti properti warna </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Metallic</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada properti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_Specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Secara default, nilai warnanya harus sama dengan (0,2, 0,2, 0,2). Jadi kami menjamin bahwa itu akan cocok dengan penampilan versi logam.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga ubah variabel shader yang sesuai. </font><font style="vertical-align: inherit;">Warna permukaan specular shader didefinisikan sebagai </font></font><code>fixed3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi mari kita gunakan.</font></font><br><br><pre> <code class="hljs objectivec"> half _Glossiness; <span class="hljs-comment"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah permukaan pragma surf dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StandardSpecular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini akan memaksa Unity untuk menghasilkan shader menggunakan specular.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang fungsi tersebut </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan parameter kedua bertipe </font></font><code>SurfaceOutputStandardSpecular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selain itu, sekarang Anda harus menetapkan nilai bukan </font></font><code>o.Metallic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi </font></font><code>o.Specular</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; // o.Metallic = _Metallic; o.Specular = _Specular; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengaburkan highlight dengan mempertimbangkan </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">warna specular.</font></font><br><br><pre> <code class="hljs"> o.Specular = _Specular * explored;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/d05/128/289d0512816a7d6f692b0e7639e882eb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medan yang belum dijelajahi tanpa pencahayaan yang dipantulkan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang dapat Anda lihat dalam gambar, sekarang relief yang belum dijelajahi tampak hitam pudar. </font><font style="vertical-align: inherit;">Namun, ketika dilihat pada sudut singgung, permukaan berubah menjadi cermin, karena itu relief mulai mencerminkan lingkungan, yaitu skybox.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa permukaan menjadi cermin?</font></font></b> <div class="spoiler_text">    .  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering</a> . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/255/d63/627/255d636278eb947c27117d6c596a9489.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Area yang belum dijelajahi masih mencerminkan lingkungan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghilangkan refleksi ini, kami akan mempertimbangkan bantuan yang belum dijelajahi sepenuhnya teduh. </font><font style="vertical-align: inherit;">Ini dilakukan dengan menetapkan nilai ke </font></font><code>explored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter oklusi, yang kami gunakan sebagai topeng refleksi.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.w; o.Albedo = c.rgb * grid * _Color * explored; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/118/ab6/a5a/118ab6a5a91711eda2165433a7b99513.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belum dijelajahi tanpa refleksi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Latar Belakang Pencocokan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang karena medan yang belum dijelajahi mengabaikan semua pencahayaan, Anda harus menyesuaikannya dengan latar belakang. </font><font style="vertical-align: inherit;">Karena kamera kami selalu terlihat dari atas, latar belakang selalu abu-abu. </font><font style="vertical-align: inherit;">Untuk memberi tahu shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> warna yang akan digunakan, tambahkan properti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_BackgroundColor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang defaultnya menjadi hitam.</font></font><br><br><pre> <code class="hljs dos"> Properties { … _BackgroundColor ("Background <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>", <span class="hljs-built_in"><span class="hljs-built_in">Color</span></span>) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) } … half _Glossiness; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menggunakan warna ini, kami akan menambahkannya sebagai cahaya memancarkan. </font><font style="vertical-align: inherit;">Ini </font></font><code>o.Emission</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dilakukan dengan menetapkan nilai warna latar belakang dikalikan dengan satu dikurangi dieksplorasi.</font></font><br><br><pre> <code class="hljs"> o.Occlusion = explored; o.Emission = _BackgroundColor * (1 - explored);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami menggunakan skybox default, warna latar belakang yang terlihat sebenarnya tidak sama. </font><font style="vertical-align: inherit;">Secara umum, abu-abu yang sedikit kemerahan akan menjadi warna terbaik. </font><font style="vertical-align: inherit;">Saat menyiapkan bahan bantuan, Anda dapat menggunakan </font><font style="vertical-align: inherit;">kode 68615BFF </font><font style="vertical-align: inherit;">untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/307/7dd/eeb3077dd097a7649575a371cbb361f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan bantuan dengan warna latar belakang abu-abu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, ini berhasil, meskipun jika Anda tahu ke mana harus mencari, Anda akan melihat siluet yang sangat lemah. </font><font style="vertical-align: inherit;">Agar pemain tidak dapat melihatnya, Anda dapat menetapkan warna latar belakang seragam 68615BFF ke kamera alih-alih skybox.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b9/8cc/ec9/7b98ccec9228ac333cc23ec19cc6f28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kamera dengan warna latar yang seragam.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa tidak menghapus skybox?</font></font></b> <div class="spoiler_text">   ,   ,     environmental lighting .     ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita tidak dapat menemukan perbedaan antara latar belakang dan sel yang belum dijelajahi. </font><font style="vertical-align: inherit;">Topografi tinggi yang belum dijelajahi masih dapat mengaburkan topografi yang dieksplorasi rendah pada sudut kamera rendah. </font><font style="vertical-align: inherit;">Selain itu, bagian yang belum dijelajahi masih memberikan bayangan pada yang dieksplorasi. </font><font style="vertical-align: inherit;">Tapi petunjuk minimal ini bisa diabaikan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f88/764/d67/f88764d67aec0bf90267d273e1a248d5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sel yang belum dijelajahi tidak lagi terlihat.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana jika Anda tidak menggunakan warna latar belakang yang seragam?</font></font></b> <div class="spoiler_text">    ,        ,      .        .      ,          .       ,     ,  ,  UV-           . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan benda bantuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami hanya memiliki lubang bantuan yang tersembunyi. </font><font style="vertical-align: inherit;">Sisa keadaan penelitian belum terpengaruh.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/282/c0c/a0f/282c0ca0fb55bf26ee0bb1d43cadd42f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, hanya bantuan yang disembunyikan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mengubah shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan shader buram seperti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ubah itu menjadi shader specular dan tambahkan warna latar belakang ke dalamnya. </font><font style="vertical-align: inherit;">Mari kita mulai dengan propertinya.</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Albedo (RGB)"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> // _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> _Specular (<span class="hljs-string"><span class="hljs-string">"Specular"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>) _BackgroundColor (<span class="hljs-string"><span class="hljs-string">"Background Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) [NoScaleOffset] _GridCoordinates (<span class="hljs-string"><span class="hljs-string">"Grid Coordinates"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lebih lanjut permukaan dan variabel pragma, seperti sebelumnya. </font></font><br><br><pre> <code class="hljs cpp"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf StandardSpecular fullforwardshadows vertex:vert … half _Glossiness; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// half _Metallic; fixed3 _Specular; fixed4 _Color; half3 _BackgroundColor;</span></span></span></span></code> </pre> <br> <code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu komponen lagi juga diperlukan. </font><font style="vertical-align: inherit;">Karena </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menggabungkan visibilitas untuk setiap titik, itu hanya membutuhkan satu nilai float. </font><font style="vertical-align: inherit;">Sekarang kita butuh dua.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float2 visibility; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga digunakan secara eksplisit untuk data visibilitas </font></font><code>data.visibility.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian tetapkan </font></font><code>data.visibility.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai data penelitian.</font></font><br><br><pre> <code class="hljs kotlin"> void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … float4 cellData = GetCellData(cellDataCoordinates); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cellData.x; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cellData.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menggunakan data baru, seperti </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x * explored); // o.Metallic = _Metallic; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Emission = _BackgroundColor * (<span class="hljs-number"><span class="hljs-number">1</span></span> - explored); o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/863/dc6/d13863dc60bbb92750cd5c8f8b69d82b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benda bantuan tersembunyi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan air </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water Shore</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shaders </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita mulai dengan mengubahnya menjadi specular shaders. </font><font style="vertical-align: inherit;">Namun, mereka tidak membutuhkan warna latar belakang karena mereka adalah shader transparan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah konversi, tambahkan </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satu komponen lagi dan ubah sesuai </font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kedua shader menggabungkan data dari tiga sel.</font></font><br><br><pre> <code class="hljs dos"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, out Input data) { … data.visibility.x = cell0.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.x * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; data.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, data.visibility.x); data.visibility.y = cell0.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.x + cell1.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.y + cell2.y * v.<span class="hljs-built_in"><span class="hljs-built_in">color</span></span>.z; }</code> </pre> <br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pesisir Air</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melakukan </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operasi yang berbeda, tetapi mengatur sifat permukaannya dengan cara yang sama. </font><font style="vertical-align: inherit;">Karena transparan, kami akan mempertimbangkan </font></font><code>explore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saluran alpha, dan kami tidak akan menetapkan emisi.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/e39/390/15ae39390ccbe91f3d12f068992a7c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Air yang tersembunyi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menyembunyikan muara, sungai, dan jalan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami masih memiliki shader untuk </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muara</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ketiganya transparan dan menggabungkan data dua sel. </font><font style="vertical-align: inherit;">Alihkan semuanya ke specular, dan kemudian tambahkan ke </font></font><code>visibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data penelitian.</font></font><br><br><pre> <code class="hljs kotlin"> struct Input { … float2 visibility; }; … void vert (inout appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> Input <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = cell0.x * v.color.x + cell1.x * v.color.y; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x = lerp(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.x); <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.visibility.y = cell0.y * v.color.x + cell1.y * v.color.y; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah fungsi </font><em><font style="vertical-align: inherit;">Estuary</font></em><font style="vertical-align: inherit;"> dan </font><em><font style="vertical-align: inherit;">River</font></em></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shaders </font><font style="vertical-align: inherit;">sehingga menggunakan data baru. </font><font style="vertical-align: inherit;">Keduanya perlu melakukan perubahan yang sama.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; fixed4 c = saturate(_Color + water); o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = ca * explored; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sedikit berbeda karena menggunakan indikator tambahan pencampuran.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandardSpecular o) { <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color * ((noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.x); <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend *= noise.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend); <span class="hljs-type"><span class="hljs-type">float</span></span> explored = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.visibility.y; o.Albedo = c.rgb; o.Specular = _Specular * explored; o.Smoothness = _Glossiness; o.Occlusion = explored; o.Alpha = blend * explored; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c6/1d2/c65/1c61d2c652b436385b42188c39476c14.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya tersembunyi. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghindari Sel yang Belum Dieksplorasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun segala sesuatu yang tidak diketahui secara visual disembunyikan, sedangkan keadaan penelitian tidak diperhitungkan saat mencari jalan. </font><font style="vertical-align: inherit;">Akibatnya, unit dapat dipesan untuk bergerak melalui dan melalui sel yang belum dijelajahi, secara ajaib menentukan cara untuk bergerak. </font><font style="vertical-align: inherit;">Kita perlu memaksa unit untuk menghindari sel yang belum dijelajahi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca9/eb9/f22/ca9eb9f22cd36b917bd5f0c38028bce7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menavigasi sel yang belum dijelajahi.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pasukan menentukan biaya bergerak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum menangani sel yang belum dijelajahi, mari kita ulangi kode untuk mentransfer biaya pindah dari </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan menyederhanakan dukungan untuk unit dengan aturan pergerakan yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode umum </font></font><code>GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menentukan biaya pemindahan. </font><font style="vertical-align: inherit;">Dia perlu tahu sel mana yang bergerak di antara mereka, serta arahnya. </font><font style="vertical-align: inherit;">Kami menyalin kode yang sesuai untuk biaya pindah dari </font></font><code>HexGrid.Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke metode ini dan mengubah nama variabel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode harus mengembalikan biaya pemindahan. </font><font style="vertical-align: inherit;">Saya menggunakan kode lama untuk melewati gerakan yang tidak valid </font></font><code>continue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi pendekatan ini tidak akan berfungsi di sini. </font><font style="vertical-align: inherit;">Jika pergerakan tidak memungkinkan, maka kami akan mengembalikan biaya bergerak negatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMoveCost</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexCell fromCell, HexCell toCell, HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { HexEdgeType edgeType = fromCell.GetEdgeType(toCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> moveCost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.HasRoadThroughEdge(direction)) { moveCost = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromCell.Walled != toCell.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveCost = edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; moveCost += toCell.UrbanLevel + toCell.FarmLevel + toCell.PlantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moveCost; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu tahu kapan menemukan jalan, tidak hanya kecepatan, tetapi juga unit yang dipilih. </font><font style="vertical-align: inherit;">Ubah sesuai </font></font><code>HexGameUI.DoPathFinding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoPathfinding</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UpdateCurrentCell()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentCell &amp;&amp; selectedUnit.IsValidDestination(currentCell)) { grid.FindPath(selectedUnit.Location, currentCell, selectedUnit); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { grid.ClearPath(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami masih membutuhkan akses ke kecepatan regu, kami akan menambah ke </font></font><code>HexUnit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti </font></font><code>Speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sementara itu akan mengembalikan nilai konstan 24.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Speed { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perubahan, </font></font><code>FindPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agar mereka dapat bekerja dengan pendekatan baru kami.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { ClearPath(); currentPathFrom = fromCell; currentPathTo = toCell; currentPathExists = Search(fromCell, toCell, unit); ShowPath(unit.Speed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, HexCell toCell, HexUnit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> speed = unit.Speed; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita akan menghapus dari </font></font><code>Search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode lama yang menentukan apakah mungkin untuk pindah ke sel berikutnya dan berapa biaya untuk pindah. </font><font style="vertical-align: inherit;">Sebaliknya, kami akan menelepon </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>HexUnit.GetMoveCost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan melewati sel jika biaya bergerak negatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (neighbor.IsUnderwater || neighbor.Unit) { // continue; // } // HexEdgeType edgeType = current.GetEdgeType(neighbor); // if (edgeType == HexEdgeType.Cliff) { // continue; // } // int moveCost; // if (current.HasRoadThroughEdge(d)) { // moveCost = 1; // } // else if (current.Walled != neighbor.Walled) { // continue; // } // else { // moveCost = edgeType == HexEdgeType.Flat ? 5 : 10; // moveCost += neighbor.UrbanLevel + neighbor.FarmLevel + // neighbor.PlantLevel; // } if (!unit.IsValidDestination(neighbor)) { continue; } int moveCost = unit.GetMoveCost(current, neighbor, d); if (moveCost &lt; 0) { continue; } int distance = current.Distance + moveCost; int turn = (distance - 1) / speed; if (turn &gt; currentTurn) { distance = turn * speed + moveCost; } … }</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lewati area yang belum dijelajahi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghindari sel yang belum dijelajahi, cukup bagi kami untuk memastikan bahwa kami </font></font><code>HexUnit.IsValidDestination</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memeriksa apakah sel tersebut diperiksa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.IsExplored &amp;&amp; !cell.IsUnderwater &amp;&amp; !cell.Unit; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a84/831/2c6/a848312c6231a168a966e4cdafc2df38.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih banyak unit tidak akan dapat membuka sel yang belum dijelajahi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sel yang belum dijelajahi tidak lagi merupakan titik akhir yang valid, regu akan menghindarinya ketika pindah ke titik akhir. </font><font style="vertical-align: inherit;">Artinya, area yang belum dijelajahi bertindak sebagai penghalang yang memperpanjang jalan atau bahkan membuatnya tidak mungkin. </font><font style="vertical-align: inherit;">Kami harus membawa unit lebih dekat ke medan yang tidak diketahui untuk menjelajahi area terlebih dahulu.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana jika jalur yang lebih pendek muncul selama perpindahan?</font></font></b> <div class="spoiler_text">                .           ,        .       . <br><br>   ,        ,            .            ,    . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 22: Peningkatan Visibilitas </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubah visibilitas dengan lancar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gunakan ketinggian sel untuk menentukan ruang lingkup. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan tepi peta. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan menambahkan dukungan untuk eksplorasi peta, kami akan meningkatkan perhitungan dan transisi dari ruang lingkup. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/c4a/793/2d2c4a7939e75fe09298f96ff6125478.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melihat lebih jauh, naik lebih tinggi.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transisi Visibilitas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sel itu terlihat atau tidak terlihat, karena ia berada dalam ruang lingkup detasemen atau tidak. </font><font style="vertical-align: inherit;">Sekalipun unit itu membutuhkan waktu untuk bergerak di antara sel, bidang pandangnya melompat dari sel ke sel secara instan. </font><font style="vertical-align: inherit;">Akibatnya, visibilitas sel-sel di sekitarnya berubah secara dramatis. </font><font style="vertical-align: inherit;">Pergerakan pasukan tampak halus, tetapi perubahan visibilitas tiba-tiba. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealnya, visibilitas juga harus berubah dengan lancar. </font><font style="vertical-align: inherit;">Begitu berada di bidang visibilitas, sel-sel harus diterangi secara bertahap, dan meninggalkannya, secara bertahap menjadi gelap. </font><font style="vertical-align: inherit;">Atau mungkin Anda lebih suka transisi instan? </font><font style="vertical-align: inherit;">Mari kita tambahkan ke </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti yang beralih transisi instan. </font><font style="vertical-align: inherit;">Secara default, transisi akan mulus.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelacakan Sel Transisi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan ketika menampilkan transisi yang halus, data visibilitas sebenarnya masih tetap biner, yaitu, efeknya hanya visual. </font><font style="vertical-align: inherit;">Ini berarti bahwa transisi visibilitas harus ditangani </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan memberikan daftar sel di mana transisi dilakukan. </font><font style="vertical-align: inherit;">Pastikan bahwa pada setiap inisialisasi itu kosong.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCellShaderData</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Texture2D cellTexture; Color32[] cellTextureData; List&lt;HexCell&gt; transitioningCells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ImmediateMode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … transitioningCells.Clear(); enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, kami sedang mengatur data sel </font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secara langsung. </font><font style="vertical-align: inherit;">Ini masih benar untuk mode transisi instan, tetapi ketika dinonaktifkan, kita harus menambahkan sel ke daftar sel transisi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilitas tampaknya tidak berfungsi lagi, karena untuk saat ini, kami tidak melakukan apa pun dengan sel dalam daftar. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loop melalui sel dalam satu lingkaran </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih langsung mengatur nilai yang sesuai ke 255 atau 0, kami akan menambah / mengurangi nilai-nilai ini secara bertahap. </font><font style="vertical-align: inherit;">Kelancaran transisi tergantung pada tingkat perubahan. </font><font style="vertical-align: inherit;">Seharusnya tidak terlalu cepat dan tidak terlalu lambat. </font><font style="vertical-align: inherit;">Kompromi yang baik antara transisi yang indah dan kenyamanan gim adalah berubah dalam satu detik. </font><font style="vertical-align: inherit;">Mari kita tetapkan konstanta untuk ini agar lebih mudah diubah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transitionSpeed = <span class="hljs-number"><span class="hljs-number">255f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita dapat mendefinisikan delta yang diterapkan pada nilai-nilai. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kalikan delta waktu dengan kecepatan. </font><font style="vertical-align: inherit;">Itu harus bilangan bulat karena kita tidak tahu seberapa besar itu. </font><font style="vertical-align: inherit;">Penurunan tajam dalam frame rate dapat membuat delta lebih dari 255. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, kami perlu memperbarui sementara ada sel transisi. </font><font style="vertical-align: inherit;">Karena itu, kode harus dimasukkan ketika ada sesuatu dalam daftar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); cellTexture.SetPixels32(cellTextureData); cellTexture.Apply(); enabled = transitioningCells.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara teori, kemungkinan frame rate sangat tinggi. </font><font style="vertical-align: inherit;">Dalam kombinasi dengan kecepatan transisi yang rendah, ini dapat memberi kita delta 0. Agar perubahan terjadi, kami memaksakan delta minimum menjadi 1.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima delta, kita dapat memutar semua sel transisi dan memperbarui datanya. </font><font style="vertical-align: inherit;">Misalkan kita memiliki metode untuk ini </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, parameternya adalah sel dan delta yang sesuai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(Time.deltaTime * transitionSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">0</span></span>) { delta = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { UpdateCellData(transitioningCells[i], delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik tertentu, transisi sel harus selesai. </font><font style="vertical-align: inherit;">Asumsikan bahwa metode ini mengembalikan informasi tentang apakah transisi masih berlangsung. </font><font style="vertical-align: inherit;">Ketika berhenti, kita dapat menghapus sel dari daftar. </font><font style="vertical-align: inherit;">Setelah itu, kita harus mengurangi iterator agar tidak melewatkan sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; transitioningCells.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells.RemoveAt(i--); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan di mana sel transisi diproses tidak penting. </font><font style="vertical-align: inherit;">Karenanya, kita tidak perlu menghapus sel pada indeks saat ini, yang akan memaksa </font></font><code>RemoveAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semua sel </font><font style="vertical-align: inherit;">untuk </font><font style="vertical-align: inherit;">bergerak setelahnya. </font><font style="vertical-align: inherit;">Alih-alih, kami memindahkan sel terakhir ke indeks saat ini, lalu menghapus yang terakhir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!UpdateCellData(transitioningCells[i], delta)) { transitioningCells[i--] = transitioningCells[transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; transitioningCells.RemoveAt(transitioningCells.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita harus membuat metode </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk melakukan pekerjaannya, dia akan membutuhkan data indeks dan sel, jadi mari kita mulai dengan mendapatkannya. </font><font style="vertical-align: inherit;">Itu juga harus menentukan apakah akan terus memperbarui sel. </font><font style="vertical-align: inherit;">Secara default, kami akan menganggap bahwa itu tidak perlu. </font><font style="vertical-align: inherit;">Setelah menyelesaikan pekerjaan, perlu untuk menerapkan data yang diubah dan mengembalikan status "pembaruan sedang berlangsung".</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; Color32 data = cellTextureData[index]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memperbarui Data Sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, kita memiliki sel yang sedang dalam proses transisi atau telah menyelesaikannya. </font><font style="vertical-align: inherit;">Pertama, mari kita periksa status probe sel. </font><font style="vertical-align: inherit;">Jika sel diperiksa, tetapi nilai G-nya belum sama dengan 255, maka ia sedang dalam proses transisi, jadi kami akan memantau ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stillUpdating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } cellTextureData[index] = data;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan transisi, kami akan menambahkan delta ke nilai G sel. </font><font style="vertical-align: inherit;">Operasi aritmatika tidak bekerja dengan byte, mereka pertama kali dikonversi ke integer. </font><font style="vertical-align: inherit;">Oleh karena itu, penjumlahan akan memiliki format integer, yang harus dikonversi ke byte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetapi sebelum konversi, Anda harus memastikan bahwa nilainya tidak melebihi 255. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.g + delta; data.g = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selanjutnya, kita perlu melakukan hal yang sama untuk visibilitas, yang menggunakan nilai R. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsExplored &amp;&amp; data.g &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible &amp;&amp; data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karena sel dapat menjadi tidak terlihat lagi, kita perlu memeriksa apakah perlu untuk mengurangi nilai R. Ini terjadi ketika sel tidak terlihat, tetapi R lebih besar dari nol. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsVisible) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &lt; <span class="hljs-number"><span class="hljs-number">255</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r + delta; data.r = t &gt;= <span class="hljs-number"><span class="hljs-number">255</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.r &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { stillUpdating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = data.r - delta; data.r = t &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)t; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang sudah </font></font><code>UpdateCellData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siap dan transisi visibilitas dilakukan dengan benar.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transisi Visibilitas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perlindungan terhadap elemen transisi duplikat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transisi berfungsi, tetapi item duplikat mungkin muncul dalam daftar. </font><font style="vertical-align: inherit;">Ini terjadi jika keadaan visibilitas sel berubah saat masih dalam transisi. </font><font style="vertical-align: inherit;">Misalnya, ketika sel terlihat selama pergerakan skuad hanya untuk waktu yang singkat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasil dari penampilan elemen yang digandakan, transisi sel diperbarui beberapa kali per frame, yang mengarah pada transisi yang lebih cepat dan kerja ekstra. </font><font style="vertical-align: inherit;">Kami dapat mencegah ini dengan memeriksa sebelum menambahkan sel apakah sudah ada dalam daftar. </font><font style="vertical-align: inherit;">Namun, pencarian daftar pada setiap panggilan</font></font><code>RefreshVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mahal, terutama ketika beberapa transisi sel dilakukan. </font><font style="vertical-align: inherit;">Sebagai gantinya, mari kita gunakan saluran lain yang belum digunakan untuk menunjukkan apakah sel sedang dalam proses transisi, misalnya nilai B. Saat menambahkan sel ke daftar, kami akan menetapkan nilai 255, dan menambahkan hanya sel-sel yang nilainya tidak sama dengan 255.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = cell.Index; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ImmediateMode) { cellTextureData[index].r = cell.IsVisible ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; cellTextureData[index].g = cell.IsExplored ? (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cellTextureData[index].b != <span class="hljs-number"><span class="hljs-number">255</span></span>) { cellTextureData[index].b = <span class="hljs-number"><span class="hljs-number">255</span></span>; transitioningCells.Add(cell); } enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agar ini berfungsi, kita perlu mengatur ulang nilai B setelah sel transisi selesai. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateCellData</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!stillUpdating) { data.b = <span class="hljs-number"><span class="hljs-number">0</span></span>; } cellTextureData[index] = data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stillUpdating; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transisi tanpa duplikat.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seketika memuat visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perubahan visibilitas sekarang selalu bertahap, bahkan saat memuat peta. </font><font style="vertical-align: inherit;">Ini tidak logis, karena peta menggambarkan keadaan di mana sel-sel sudah terlihat, sehingga transisi tidak sesuai di sini. </font><font style="vertical-align: inherit;">Selain itu, melakukan transisi untuk banyak sel yang terlihat dari peta besar dapat memperlambat permainan setelah memuat. </font><font style="vertical-align: inherit;">Karena itu, sebelum memuat sel dan regu, mari kita beralih </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke mode transisi instan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader, header); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami mendefinisikan kembali pengaturan awal mode transisi instan, apa pun itu. </font><font style="vertical-align: inherit;">Mungkin itu sudah dimatikan, atau membuat opsi konfigurasi, jadi kita akan mengingat mode awal dan akan beralih ke sana setelah selesai bekerja.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> originalImmediateMode = cellShaderData.ImmediateMode; cellShaderData.ImmediateMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; … cellShaderData.ImmediateMode = originalImmediateMode; }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lingkup tergantung tinggi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini kami telah menggunakan ruang lingkup tiga untuk semua unit, tetapi pada kenyataannya itu lebih rumit. Dalam kasus umum, kita tidak dapat melihat objek karena dua alasan: beberapa hambatan menghalangi kita untuk melihatnya, atau objek itu terlalu kecil atau jauh. Dalam permainan kami, kami hanya menerapkan batasan ruang lingkup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tidak dapat melihat apa yang ada di sisi berlawanan dari Bumi, karena planet ini mengaburkan kita. Kami hanya bisa melihat ke cakrawala. Karena planet ini dapat dianggap sebagai bola, semakin tinggi sudut pandangnya, semakin banyak permukaan yang bisa kita lihat, yaitu cakrawala tergantung pada ketinggian.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/788/208/0717882082a42e92b14e158876c6e28b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cakrawala tergantung pada ketinggian sudut pandang. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibilitas terbatas dari unit kami meniru efek cakrawala yang diciptakan oleh kelengkungan Bumi. </font><font style="vertical-align: inherit;">Kisaran ulasan mereka tergantung pada ukuran planet dan skala peta. </font><font style="vertical-align: inherit;">Setidaknya itulah penjelasan logisnya. </font><font style="vertical-align: inherit;">Tapi alasan utama untuk mengurangi ruang lingkup adalah gameplay, ini adalah batasan yang disebut kabut perang. </font><font style="vertical-align: inherit;">Namun, memahami fisika yang mendasari bidang pandang, kita dapat menyimpulkan bahwa sudut pandang yang tinggi harus memiliki nilai strategis, karena itu menjauhkan cakrawala dan memungkinkan Anda untuk melihat hambatan yang lebih rendah. </font><font style="vertical-align: inherit;">Namun sejauh ini kami belum mengimplementasikannya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tinggi untuk ditinjau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memperhitungkan ketinggian saat menentukan ruang lingkup, kita perlu mengetahui ketinggiannya. </font><font style="vertical-align: inherit;">Ini akan menjadi ketinggian atau tingkat air yang biasa, tergantung pada apakah sel tanah atau air. </font><font style="vertical-align: inherit;">Mari kita tambahkan ini ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ViewElevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation &gt;= waterLevel ? elevation : waterLevel; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi jika tinggi mempengaruhi ruang lingkup, maka dengan perubahan ketinggian tampilan sel, situasi visibilitas juga dapat berubah. </font><font style="vertical-align: inherit;">Karena sel telah diblokir atau sekarang memblokir ruang lingkup beberapa unit, tidaklah mudah untuk menentukan apa yang perlu diubah. </font><font style="vertical-align: inherit;">Sel itu sendiri tidak akan dapat menyelesaikan masalah ini, jadi biarkan ia melaporkan perubahan dalam situasi ini </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Misalkan Anda </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki metode untuk ini </font></font><code>ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan menyebutnya atas penugasan </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jika perlu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang sama berlaku untuk </font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalViewElevation = ViewElevation; waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ViewElevation != originalViewElevation) { ShaderData.ViewElevationChanged(); } ValidateRivers(); Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atur ulang visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu membuat metode </font></font><code>HexCellShaderData.ViewElevationChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menentukan bagaimana perubahan situasi visibilitas umum adalah tugas yang kompleks, terutama ketika mengubah banyak sel secara bersamaan. </font><font style="vertical-align: inherit;">Karena itu, kami tidak akan menemukan trik apa pun, tetapi cukup merencanakan untuk mengatur ulang visibilitas semua sel. </font><font style="vertical-align: inherit;">Tambahkan bidang boolean untuk melacak apakah akan melakukan ini. </font><font style="vertical-align: inherit;">Di dalam metode, kita hanya akan mengaturnya menjadi true dan memasukkan komponen. </font><font style="vertical-align: inherit;">Terlepas dari jumlah sel yang telah berubah secara bersamaan, ini akan mengarah ke pengaturan ulang tunggal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> needsVisibilityReset; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewElevationChanged</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatur ulang nilai visibilitas semua sel, Anda harus memiliki akses ke sana, yang </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak Anda miliki. </font><font style="vertical-align: inherit;">Jadi mari kita mendelegasikan tanggung jawab ini </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda perlu menambahkan ke </font></font><code>HexCellShaderData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti, yang akan memungkinkan Anda untuk merujuk ke kisi. </font><font style="vertical-align: inherit;">Kemudian kita bisa menggunakannya </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk meminta reset.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid Grid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsVisibilityReset) { needsVisibilityReset = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Grid.ResetVisibility(); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita beralih ke </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: mengatur tautan ke kisi </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah membuat data shader.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexUnit.unitPrefab = unitPrefab; cellShaderData = gameObject.AddComponent&lt;HexCellShaderData&gt;(); cellShaderData.Grid = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; CreateMap(cellCountX, cellCountZ); }</code> </pre> <br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga harus mendapatkan metode </font></font><code>ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuang semua sel. </font><font style="vertical-align: inherit;">Hanya membuatnya berkeliling semua sel dalam loop dan mendelegasikan reset ke dirinya sendiri.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu menambahkan </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>ResetVisibilty</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini hanya akan nol visibilitas dan memicu pembaruan visibilitas. </font><font style="vertical-align: inherit;">Ini harus dilakukan ketika visibilitas sel lebih besar dari nol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { visibility = <span class="hljs-number"><span class="hljs-number">0</span></span>; ShaderData.RefreshVisibility(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mengatur ulang semua data visibilitas, </font></font><code>HexGrid.ResetVisibility</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ia harus kembali menerapkan visibilitas ke semua regu, untuk itu ia perlu mengetahui ruang lingkup masing-masing regu. </font><font style="vertical-align: inherit;">Misalkan dapat diperoleh menggunakan properti </font></font><code>VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResetVisibility</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].ResetVisibility(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; units.Count; i++) { HexUnit unit = units[i]; IncreaseVisibility(unit.Location, unit.VisionRange); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk ini untuk bekerja, mengubah nama refactor- </font></font><code>HexUnit.visionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di </font></font><code>HexUnit.VisionRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengubahnya menjadi fitur. </font><font style="vertical-align: inherit;">Meskipun akan menerima nilai konstan 3, tetapi di masa depan itu akan berubah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VisionRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena ini, data visibilitas akan diatur ulang dan tetap benar setelah mengubah ketinggian tampilan sel. </font><font style="vertical-align: inherit;">Tetapi kemungkinan kami akan mengubah aturan untuk menentukan ruang lingkup dan menjalankan kompilasi dalam mode Putar. </font><font style="vertical-align: inherit;">Agar cakupan berubah secara independen, mari jalankan reset </font></font><code>HexGrid.OnEnable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketika kompilasi terdeteksi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { … ResetVisibility(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang Anda dapat mengubah kode lingkup dan melihat hasilnya, sambil tetap dalam mode Putar. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memperluas cakrawala </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhitungan ruang lingkup ditentukan </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agar ketinggian memengaruhi ruang lingkup, kita cukup menggunakan ketinggian tampilan dengan </font></font><code>fromCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendefinisikan kembali sementara area yang ditransmisikan. </font><font style="vertical-align: inherit;">Jadi kita dapat dengan mudah memeriksa apakah ini berhasil.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">List&lt;HexCell&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell fromCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range</span></span></span><span class="hljs-function">)</span></span> { … range = fromCell.ViewElevation; fromCell.SearchPhase = searchFrontierPhase; fromCell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(fromCell); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/727/032/6d3/7270326d379796f2b4f2f3c3ca65512c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gunakan ketinggian sebagai ruang lingkup.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hambatan untuk Visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menerapkan ketinggian tampilan sebagai ruang lingkup hanya berfungsi dengan benar ketika semua sel lain berada pada ketinggian nol. </font><font style="vertical-align: inherit;">Tetapi jika semua sel memiliki ketinggian yang sama dengan sudut pandang, maka bidang pandang harus nol. </font><font style="vertical-align: inherit;">Selain itu, sel dengan ketinggian tinggi harus memblokir visibilitas sel-sel rendah di belakangnya. </font><font style="vertical-align: inherit;">Sejauh ini, belum ada yang diterapkan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/7be/a6f/de87bea6f4b88cd61765450a63f738f9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lingkup tidak mengganggu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara yang paling benar untuk menentukan ruang lingkup adalah dengan mengecek dengan emisi sinar, tetapi dengan cepat akan menjadi mahal dan masih menghasilkan hasil yang aneh. </font><font style="vertical-align: inherit;">Kami membutuhkan solusi cepat yang menciptakan hasil yang cukup baik yang tidak harus sempurna. </font><font style="vertical-align: inherit;">Selain itu, penting bahwa aturan untuk menentukan ruang lingkup sederhana, intuitif, dan dapat diprediksi untuk pemain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi kami adalah sebagai berikut - saat menentukan visibilitas sel, kami akan menambahkan ketinggian tampilan sel tetangga ke jarak yang dicakup. </font><font style="vertical-align: inherit;">Bahkan, ini mengurangi ruang lingkup ketika kita melihat sel-sel ini, dan jika mereka dilewati, ini tidak akan memungkinkan kita untuk mencapai sel-sel di belakangnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/774/44c/efe/77444cefe82d428ee32e094213e82a1a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sel-sel tinggi memblokir tampilan.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidakkah seharusnya kita melihat sel-sel tinggi di kejauhan?</font></font></b> <div class="spoiler_text">      ,     ,   ,   .       ,       . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jangan melihat-lihat sudut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tampaknya sel-sel tinggi menghalangi pandangan ke rendah, tetapi kadang-kadang ruang lingkup menerobosnya, meskipun tampaknya tidak seharusnya demikian. </font><font style="vertical-align: inherit;">Ini terjadi karena algoritma pencarian masih menemukan jalur ke sel-sel ini, melewati sel yang menghalangi. </font><font style="vertical-align: inherit;">Alhasil, area visibilitas kami seolah bisa melewati rintangan. </font><font style="vertical-align: inherit;">Untuk menghindari hal ini, kita perlu memastikan bahwa hanya jalur terpendek yang diperhitungkan saat menentukan visibilitas sel. </font><font style="vertical-align: inherit;">Ini bisa dilakukan dengan menjatuhkan jalur yang menjadi lebih panjang dari yang diperlukan.</font></font><br><br><pre> <code class="cs hljs"> HexCoordinates fromCoordinates = fromCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance + neighbor.ViewElevation &gt; range || distance &gt; fromCoordinates.DistanceTo(neighbor.coordinates) ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/bfa/1c2/30dbfa1c2df2fb6119249f00cdc3d8d8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami hanya menggunakan jalur terpendek.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi kami memperbaiki sebagian besar kasus yang keliru. Untuk sel di dekatnya, ini bekerja dengan baik, karena hanya ada jalur terpendek ke sana. Sel yang lebih jauh memiliki lebih banyak opsi untuk jalur, oleh karena itu, jarak yang jauh, sebuah amplop visibilitas masih dapat terjadi. Ini tidak akan menjadi masalah jika area visibilitas tetap kecil dan perbedaan ketinggian yang berdekatan tidak terlalu besar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, alih-alih mengganti bidang tampilan yang ditransmisikan, kami menambahkan ketinggian tampilan. Bidang pandang regu sendiri menunjukkan kemampuan ketinggian, ketinggian penerbangan, atau pengintaian.</font></font><br><br><pre> <code class="cs hljs"> range += fromCell.ViewElevation;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ff/1ce/a2b/3ff1cea2b833bda69990576fa8323aec.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat dengan bidang pandang penuh pada titik pandang rendah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, aturan final visibilitas berlaku untuk penglihatan ketika bergerak di sepanjang jalur terpendek ke bidang pandang, dengan mempertimbangkan perbedaan ketinggian sel relatif terhadap sudut pandang. </font><font style="vertical-align: inherit;">Ketika sel di luar ruang lingkup, itu memblokir semua jalur melaluinya. </font><font style="vertical-align: inherit;">Akibatnya, titik pengamatan tinggi, yang tidak menghalangi pandangan, menjadi bernilai strategis.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan menghalangi visibilitas objek?</font></font></b> <div class="spoiler_text">  ,        ,  . ,  ,        .          . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sel yang tidak bisa dieksplorasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah terakhir dengan visibilitas menyangkut tepi peta. </font><font style="vertical-align: inherit;">Kelegaan tiba-tiba dan tanpa transisi berakhir, karena sel-sel di tepi tidak memiliki tetangga.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/217/fbb/587217fbb248ae8a13759a33e22e25ff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepi peta yang ditandai.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealnya, tampilan visual area dan tepi peta yang belum dijelajahi harus sama. Kita dapat mencapai ini dengan menambahkan case khusus ketika melakukan triangulasi edge, ketika mereka tidak memiliki tetangga, tetapi ini akan membutuhkan logika tambahan, dan kita harus bekerja dengan sel yang hilang. Oleh karena itu, solusi semacam itu tidak trivial. Pendekatan alternatif adalah memaksa sel-sel batas peta untuk tidak dieksplorasi, bahkan jika mereka berada dalam lingkup skuad. Pendekatan ini jauh lebih sederhana, jadi mari kita gunakan. Ini juga memungkinkan Anda untuk menandai sebagai sel yang belum dijelajahi dan lainnya, membuatnya lebih mudah untuk mencapai penciptaan tepi peta yang tidak rata. Selain itu, sel-sel tersembunyi di tepi memungkinkan Anda untuk membuat jalan dan sungai yang masuk dan meninggalkan peta sungai dan jalan, karena titik akhir mereka akan berada di luar ruang lingkup.Juga, dengan bantuan solusi ini, Anda dapat menambahkan unit yang masuk dan keluar peta.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menandai sel yang diselidiki </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menunjukkan bahwa sel dapat diperiksa, tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti </font></font><code>Explorable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Explorable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang sel dapat terlihat jika itu adalah sel yang diselidiki, jadi </font></font><code>IsVisible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami akan </font><font style="vertical-align: inherit;">mengubah properti </font><font style="vertical-align: inherit;">untuk mempertimbangkan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsVisible { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visibility &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; Explorable; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang sama berlaku untuk </font></font><code>IsExplored</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Namun, untuk ini kami menyelidiki properti standar. </font><font style="vertical-align: inherit;">Kita perlu mengubahnya menjadi properti eksplisit agar dapat mengubah logika pengambilnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsExplored { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> explored &amp;&amp; Explorable; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { explored = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> explored;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sembunyikan tepi peta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa menyembunyikan tepi peta persegi panjang dalam metode ini </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sel-sel yang tidak ada di tepi diselidiki, semua sisanya belum diselidiki.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.Index = i; cell.ShaderData = cellShaderData; cell.Explorable = x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; x &lt; cellCountX - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; z &lt; cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kartu-kartu itu digelapkan di sekitar tepinya, bersembunyi di belakangnya ruang-ruang besar yang belum dijelajahi. </font><font style="vertical-align: inherit;">Akibatnya, ukuran area peta yang dipelajari berkurang di setiap dimensi oleh dua dimensi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/19f/353/59419f35345fa4eac3380c4e16461baf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepi peta yang belum dijelajahi.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mungkin untuk membuat status penelitian dapat diedit?</font></font></b> <div class="spoiler_text"> ,  ,     .          . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sel yang belum dijelajahi menghalangi visibilitas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, jika sel tidak dapat diperiksa, maka itu harus mengganggu visibilitas. </font><font style="vertical-align: inherit;">Ubah </font></font><code>HexGrid.GetVisibleCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mempertimbangkan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.SearchPhase &gt; searchFrontierPhase || !neighbor.Explorable ) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 23: menghasilkan tanah </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isi peta baru dengan lanskap yang dihasilkan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mengangkat tanah di atas air, kami membanjiri sebagian. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mengontrol jumlah tanah yang dibuat, ketinggian dan ketidakrataannya. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menambahkan dukungan untuk berbagai opsi konfigurasi untuk membuat peta variabel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membuatnya sehingga peta yang sama dapat dihasilkan lagi. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian tutorial ini akan menjadi awal dari rangkaian pembuatan peta prosedural. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian ini dibuat di Unity 2017.1.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/798/7bb/99e7987bbcb46f1f961b72ba76a78aa0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu dari banyak peta yang dihasilkan.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembuatan kartu </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kita dapat membuat peta apa pun, butuh banyak waktu. Akan lebih mudah jika aplikasi tersebut dapat membantu perancang dengan membuat kartu untuknya, yang kemudian dapat dimodifikasi sesuai selera. Anda dapat mengambil langkah lain dan sepenuhnya menghilangkan membuat desain secara manual, sepenuhnya mentransfer tanggung jawab untuk menghasilkan peta yang sudah selesai ke aplikasi. Karena ini, permainan dapat dimainkan setiap kali dengan kartu baru dan setiap sesi permainan akan berbeda. Agar semua ini memungkinkan, kita harus membuat algoritma pembuatan peta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis algoritma pembangkitan yang Anda butuhkan tergantung pada jenis kartu yang Anda butuhkan. Tidak ada pendekatan yang benar, Anda selalu harus mencari kompromi antara kredibilitas dan kemampuan bermain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar sebuah kartu dapat dipercaya, itu harus tampak sangat mungkin dan nyata bagi pemain. Ini tidak berarti bahwa peta harus terlihat seperti bagian dari planet kita. Ini mungkin planet yang berbeda atau realitas yang sama sekali berbeda. Tetapi jika itu harus menunjukkan relief Bumi, maka setidaknya harus sebagian menyerupai itu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemutaran terkait dengan bagaimana kartu sesuai dengan gameplay. Terkadang bertentangan dengan kepercayaan. Misalnya, meskipun pegunungan dapat terlihat indah, pada saat yang sama mereka sangat membatasi pergerakan dan tampilan unit. Jika ini tidak diinginkan, maka Anda harus melakukannya tanpa gunung, yang akan mengurangi kredibilitas dan membatasi ekspresif permainan. Atau kita bisa menyelamatkan pegunungan, tetapi mengurangi dampaknya pada gameplay, yang juga dapat mengurangi kredibilitas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, kelayakan harus dipertimbangkan. Misalnya, Anda dapat membuat planet mirip bumi yang sangat realistis dengan mensimulasikan lempeng tektonik, erosi, hujan, letusan gunung berapi, efek meteorit dan bulan, dan sebagainya. Tetapi pengembangan sistem seperti itu akan membutuhkan banyak waktu. Selain itu, dibutuhkan waktu lama untuk menghasilkan planet seperti itu, dan para pemain tidak akan mau menunggu beberapa menit sebelum memulai permainan baru. Artinya, simulasi adalah alat yang ampuh, tetapi memiliki harga.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game sering menggunakan pertukaran antara kredibilitas, kemampuan bermain, dan kelayakan. Terkadang kompromi semacam itu tidak terlihat dan tampak sepenuhnya normal, dan terkadang kompromi itu terlihat acak, tidak konsisten, atau kacau, tergantung pada keputusan yang diambil selama proses pengembangan. Ini tidak hanya berlaku untuk pembuatan kartu, tetapi ketika mengembangkan generator kartu prosedural, Anda perlu memberikan perhatian khusus pada ini. Anda dapat menghabiskan banyak waktu membuat algoritme yang menghasilkan kartu-kartu indah yang ternyata tidak berguna untuk gim yang Anda buat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam seri tutorial ini, kami akan membuat relief mirip tanah. </font><font style="vertical-align: inherit;">Seharusnya terlihat menarik, dengan variabilitas besar dan tidak adanya area homogen yang besar. </font><font style="vertical-align: inherit;">Skala bantuan akan besar, peta akan mencakup satu atau lebih benua, wilayah lautan, atau bahkan seluruh planet. </font><font style="vertical-align: inherit;">Kita memerlukan kendali atas geografi, termasuk massa tanah, iklim, jumlah daerah, dan benjolan di daratan. </font><font style="vertical-align: inherit;">Pada bagian ini kita akan meletakkan dasar untuk pembuatan sushi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memulai dalam mode edit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan fokus pada peta, bukan pada gameplay, sehingga akan lebih mudah untuk meluncurkan aplikasi dalam mode edit. </font><font style="vertical-align: inherit;">Berkat ini, kita dapat langsung melihat kartunya. </font><font style="vertical-align: inherit;">Oleh karena itu, kami akan mengubah dengan </font></font><code>HexMapEditor.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengatur mode pengeditan ke true dan mengaktifkan kata kunci shader dari mode ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); Shader.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"HEX_MAP_EDIT_MODE"</span></span>); SetEditMode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generator kartu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena cukup banyak kode diperlukan untuk menghasilkan peta prosedural, kami tidak akan menambahkannya langsung ke </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebaliknya, kami akan membuat komponen baru </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan mengetahuinya. </font><font style="vertical-align: inherit;">Ini akan menyederhanakan transisi ke algoritma lain jika kita membutuhkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generator membutuhkan tautan ke grid, jadi kami akan menambahkan bidang umum ke situ. </font><font style="vertical-align: inherit;">Selain itu, kami menambahkan metode umum </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang akan menangani pekerjaan algoritma. </font><font style="vertical-align: inherit;">Kami akan memberikannya dimensi peta sebagai parameter, dan kemudian memaksanya untuk digunakan untuk membuat peta kosong baru.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapGenerator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan objek dengan komponen ke adegan </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan hubungkan ke grid.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/b6e/fd2/932b6efd2dd1809893af27ec7a91c620.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta objek generator.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubah menu peta baru </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan mengubahnya </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga dapat menghasilkan kartu, bukan hanya membuat yang kosong. </font><font style="vertical-align: inherit;">Kami akan mengontrol fungsinya melalui bidang Boolean </font></font><code>generateMaps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang secara default memiliki nilai </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita buat metode umum untuk mengatur bidang ini, seperti yang kita lakukan untuk beralih opsi </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambahkan saklar yang sesuai ke menu dan hubungkan ke metode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> generateMaps = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleMapGeneration</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { generateMaps = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc9/9c7/0c9/fc99c70c99095b3565104ef42254859d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu kartu baru dengan sakelar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikan menu tautan ke generator peta. </font><font style="vertical-align: inherit;">Kemudian kita akan memaksanya untuk memanggil metode </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generator </font><font style="vertical-align: inherit;">jika perlu </font><font style="vertical-align: inherit;">, dan tidak hanya menjalankan </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grid.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMapGenerator mapGenerator; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (generateMaps) { mapGenerator.GenerateMap(x, z); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.CreateMap(x, z); } HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d1/e98/3d9/7d1e983d927d912b75d9b245219659f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koneksi ke generator.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akses sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar generator berfungsi, ia membutuhkan akses ke sel. </font><font style="vertical-align: inherit;">Kami </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah memiliki metode umum </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memerlukan atau vektor posisi, atau koordinat segi enam. </font><font style="vertical-align: inherit;">Generator tidak perlu bekerja dengan satu atau yang lain, jadi kami menambahkan dua metode </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang </font><font style="vertical-align: inherit;">nyaman </font><font style="vertical-align: inherit;">yang akan bekerja dengan koordinat offset atau indeks sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xOffset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zOffset</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[xOffset + zOffset * cellCountX]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cellIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[cellIndex]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat menerima sel secara langsung. </font><font style="vertical-align: inherit;">Misalnya, setelah membuat peta baru, ia dapat menggunakan koordinat rumput untuk mengatur rumput sebagai relief kolom tengah sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; z; i++) { grid.GetCell(x / <span class="hljs-number"><span class="hljs-number">2</span></span>, i).TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/aee/119/860aee119f0e000ef290f6c87e61ad05.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kolom rumput di peta kecil. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat sushi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat membuat peta, kami memulai sepenuhnya tanpa tanah. </font><font style="vertical-align: inherit;">Orang dapat membayangkan bahwa seluruh dunia dibanjiri oleh satu samudera luas. </font><font style="vertical-align: inherit;">Sebuah daratan tercipta ketika bagian dasar samudera terdorong begitu tinggi hingga naik di atas air. </font><font style="vertical-align: inherit;">Kita perlu memutuskan berapa banyak tanah yang harus dibuat dengan cara ini, di mana akan muncul dan apa bentuknya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naikkan kelegaan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dari yang kecil - angkat satu bidang tanah di atas air. </font><font style="vertical-align: inherit;">Kami membuat metode ini </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan parameter untuk mengontrol ukuran plot. </font><font style="vertical-align: inherit;">Panggil metode ini </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ganti kode tes sebelumnya. </font><font style="vertical-align: inherit;">Mari kita mulai dengan sebidang tanah kecil yang terdiri dari tujuh sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { grid.CreateMap(x, z); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; z; i++) { // grid.GetCell(x / 2, i).TerrainTypeIndex = 1; // } RaiseTerrain(7); } void RaiseTerrain (int chunkSize) {}</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kami menggunakan jenis bantuan “rumput” untuk menunjukkan tanah yang ditinggikan, dan bantuan “pasir” asli mengacu pada lautan. </font><font style="vertical-align: inherit;">Buat kami </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengambil sel acak dan mengubah jenis bantuannya sampai kami mendapatkan jumlah lahan yang tepat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan sel acak, kami menambahkan metode </font></font><code>GetRandomCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menentukan indeks sel acak dan memperoleh sel yang sesuai dari kisi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunkSize; i++) { GetRandomCell().TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, grid.cellCountX * grid.cellCountZ)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/fb8/ce6/396fb8ce67de74961b31562e275bd81a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tujuh sel sushi acak. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena pada akhirnya kita mungkin membutuhkan banyak sel acak atau loop melalui semua sel beberapa kali, mari kita melacak jumlah sel dalam sel itu sendiri </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cellCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; … } … <span class="hljs-function"><span class="hljs-function">HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRandomCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grid.GetCell(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellCount)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembuatan satu situs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini, kami mengubah tujuh sel acak menjadi daratan, dan mereka dapat berada di mana saja. </font><font style="vertical-align: inherit;">Kemungkinan besar mereka tidak membentuk satu wilayah lahan tunggal. </font><font style="vertical-align: inherit;">Selain itu, kami dapat memilih sel yang sama beberapa kali, jadi kami mendapat lebih sedikit lahan. </font><font style="vertical-align: inherit;">Untuk mengatasi kedua masalah, tanpa batasan, kami hanya akan memilih sel pertama. </font><font style="vertical-align: inherit;">Setelah itu, kita harus memilih hanya sel-sel yang berada di sebelah yang dipilih sebelumnya. </font><font style="vertical-align: inherit;">Pembatasan ini mirip dengan pembatasan pencarian jalur, jadi kami menggunakan pendekatan yang sama di sini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menambahkan </font></font><code>HexMapGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti kami sendiri dan penghitung dari fase batas pencarian, seperti di </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> HexCellPriorityQueue searchFrontier; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> searchFrontierPhase;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pastikan antrian prioritas ada sebelum kita membutuhkannya. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah membuat peta baru, batas pencarian untuk semua sel adalah nol. Tetapi jika kita akan mencari sel dalam proses pembuatan peta, kita akan meningkatkan batas pencarian mereka dalam proses ini. Jika kami melakukan banyak operasi pencarian, mereka mungkin berada di depan fase batas pencarian yang direkam </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini dapat mengganggu pencarian jalur unit. Untuk menghindari hal ini, pada akhir proses pembuatan peta, kami akan mengatur ulang fase pencarian semua sel menjadi nol.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang saya </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus mencari sel yang sesuai, dan tidak memilihnya secara acak. Proses ini sangat mirip dengan metode pencarian di </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun, kami tidak akan mengunjungi sel lebih dari satu kali, sehingga cukup bagi kami untuk meningkatkan fase batas pencarian sebanyak 1 alih-alih 2. Kemudian kami menginisialisasi perbatasan dengan sel pertama, yang dipilih secara acak. Seperti biasa, selain mengatur fase pencariannya, kami menetapkan jarak dan heuristik ke nol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; chunkSize; i++) { // GetRandomCell().TerrainTypeIndex = 1; // } searchFrontierPhase += 1; HexCell firstCell = GetRandomCell(); firstCell.SearchPhase = searchFrontierPhase; firstCell.Distance = 0; firstCell.SearchHeuristic = 0; searchFrontier.Enqueue(firstCell); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah itu, loop pencarian sebagian besar akan akrab bagi kita. </font><font style="vertical-align: inherit;">Selain itu, untuk melanjutkan pencarian sampai perbatasan kosong, kita perlu berhenti ketika fragmen mencapai ukuran yang diinginkan, jadi kita akan melacaknya. </font><font style="vertical-align: inherit;">Pada setiap iterasi, kita akan mengekstrak sel berikutnya dari antrian, mengatur jenis reliefnya, menambah ukurannya, dan kemudian memotong tetangga sel ini. </font><font style="vertical-align: inherit;">Semua tetangga ditambahkan ke perbatasan jika mereka belum ditambahkan di sana. </font><font style="vertical-align: inherit;">Kami tidak perlu melakukan perubahan atau perbandingan apa pun. </font><font style="vertical-align: inherit;">Setelah selesai, Anda harus menghapus batas.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } } searchFrontier.Clear();</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97a/f44/023/97af440236cb6909130d6a8bfaab3f5a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garis sel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapat satu plot dengan ukuran yang tepat. </font><font style="vertical-align: inherit;">Ini akan lebih kecil hanya jika tidak ada jumlah sel yang cukup. </font><font style="vertical-align: inherit;">Karena cara perbatasan diisi, plot selalu terdiri dari garis yang membentang ke barat laut. </font><font style="vertical-align: inherit;">Itu mengubah arah hanya ketika mencapai tepi peta.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menghubungkan sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Area tanah jarang menyerupai garis, dan jika mereka lakukan, mereka tidak selalu berorientasi dengan cara yang sama. </font><font style="vertical-align: inherit;">Untuk mengubah bentuk situs, kita perlu mengubah prioritas sel. </font><font style="vertical-align: inherit;">Sel acak pertama dapat digunakan sebagai pusat plot. </font><font style="vertical-align: inherit;">Maka jarak ke semua sel lain akan relatif ke titik ini. </font><font style="vertical-align: inherit;">Jadi kami akan memberikan prioritas lebih tinggi ke sel yang lebih dekat ke pusat, sehingga situs tidak akan tumbuh sebagai garis, tetapi di sekitar pusat.</font></font><br><br><pre> <code class="cs hljs"> searchFrontier.Enqueue(firstCell); HexCoordinates center = firstCell.coordinates; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; size += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor &amp;&amp; neighbor.SearchPhase &lt; searchFrontierPhase) { neighbor.SearchPhase = searchFrontierPhase; neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/117/149/84111714960a293415b1d24edf92f56b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akumulasi sel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan faktanya, sekarang tujuh sel kita dikemas dengan indah di area heksagonal yang kompak jika sel pusat tidak muncul di tepi peta. </font><font style="vertical-align: inherit;">Mari kita coba sekarang untuk menggunakan ukuran plot 30.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/893/c36/13e/893c3613edfe02b457cc4ee6d191072c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sushi massa dalam 30 sel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami kembali mendapatkan bentuk yang sama, meskipun tidak ada cukup sel untuk mendapatkan segi enam yang tepat. </font><font style="vertical-align: inherit;">Karena jari-jari plot lebih besar, lebih cenderung dekat dengan tepi peta, yang akan memaksanya mengambil bentuk yang berbeda.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengacakan sushi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak ingin semua area terlihat sama, jadi kami akan sedikit mengubah prioritas sel. </font><font style="vertical-align: inherit;">Setiap kali kita menambahkan sel tetangga ke perbatasan, jika angka berikutnya </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kurang dari nilai ambang tertentu, maka heuristik sel ini menjadi bukan 0, tetapi 1. Mari kita gunakan nilai 0,5 sebagai ambang, artinya, kemungkinan besar akan mempengaruhi setengah sel.</font></font><br><br><pre> <code class="cs hljs"> neighbor.Distance = neighbor.coordinates.DistanceTo(center); neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5f</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; searchFrontier.Enqueue(neighbor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/aec/793/43eaec79315f68e0618fe71c0f93c3f3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Area terdistorsi.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan meningkatkan heuristik pencarian sel, kami membuatnya mengunjungi lebih lambat dari yang diharapkan. Pada saat yang sama, sel-sel lain yang terletak satu langkah lebih jauh dari pusat akan dikunjungi lebih awal, kecuali jika mereka juga meningkatkan heuristik. Ini berarti bahwa jika kita meningkatkan heuristik semua sel dengan satu nilai, maka ini tidak akan mempengaruhi peta. Artinya, ambang 1 tidak akan berpengaruh, seperti ambang 0. Dan ambang 0.8 akan setara dengan 0.2. Artinya, probabilitas 0,5 membuat proses pencarian paling "gemetar." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah osilasi yang tepat tergantung pada jenis medan yang diinginkan, jadi mari kita ubahsuaikan. Tambahkan bidang float generik </font></font><code>jitterProbability</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan atribut </font><font style="vertical-align: inherit;">ke generator</font></font><code>Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terbatas pada kisaran 0-0,5. </font><font style="vertical-align: inherit;">Mari kita beri nilai default yang sama dengan rata-rata interval ini, mis. 0,25. </font><font style="vertical-align: inherit;">Ini akan memungkinkan kita untuk mengonfigurasi generator di jendela inspektur Unity.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> jitterProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/795/b50/381/795b50381d8c9cda219ff092cf64cee5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemungkinan fluktuasi. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah Anda membuatnya dapat disesuaikan di game UI?</font></font></b> <div class="spoiler_text">  ,       .           UI,       .          ,      UI.  ,     .         ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang, untuk membuat keputusan tentang kapan heuristik harus sama dengan 1, kita menggunakan probabilitas daripada nilai konstan. </font></font><br><br><pre> <code class="cs hljs"> neighbor.SearchHeuristic = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; jitterProbability ? <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menggunakan nilai heuristik 0 dan 1. Meskipun nilai yang lebih besar dapat digunakan, ini akan sangat memperburuk deformasi bagian, kemungkinan besar mengubahnya menjadi banyak garis. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naikkan beberapa tanah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak akan terbatas pada pembuatan satu bidang tanah saja. </font><font style="vertical-align: inherit;">Misalnya, kami melakukan panggilan </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di dalam satu lingkaran untuk mendapatkan lima bagian.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { RaiseTerrain(<span class="hljs-number"><span class="hljs-number">30</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d42/83f/acd/d4283facd88705107d705290c3d8e78b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lima bidang tanah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun sekarang kami menghasilkan lima plot masing-masing 30 sel, tetapi belum tentu mendapatkan 150 sel tanah. </font><font style="vertical-align: inherit;">Karena setiap situs dibuat secara terpisah, mereka tidak saling mengenal, sehingga mereka dapat bersinggungan. </font><font style="vertical-align: inherit;">Ini normal karena dapat menciptakan lanskap yang lebih menarik daripada hanya seperangkat bagian yang terisolasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meningkatkan variabilitas lahan, kami juga dapat mengubah ukuran setiap plot. </font><font style="vertical-align: inherit;">Tambahkan dua bidang bilangan bulat untuk mengontrol ukuran minimum dan maksimum plot. </font><font style="vertical-align: inherit;">Tetapkan mereka interval yang cukup besar, misalnya, 20-200. </font><font style="vertical-align: inherit;">Saya akan membuat standar minimum sama dengan 30, dan standar maksimum - 100.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(20, 200)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMin = <span class="hljs-number"><span class="hljs-number">30</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeMax = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/026/e43/9ea026e43e949f571be0358332447de5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interval ukuran. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan bidang ini untuk secara acak menentukan ukuran area saat dipanggil </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0df/124/dab/0df124dab1f706825f75304d2862aea3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lima bagian berukuran acak di peta tengah.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat cukup sushi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami tidak dapat secara khusus mengontrol jumlah lahan yang dihasilkan. </font><font style="vertical-align: inherit;">Meskipun kita dapat menambahkan opsi konfigurasi untuk jumlah plot, plot itu sendiri berukuran acak dan mungkin tumpang tindih sedikit atau kuat. </font><font style="vertical-align: inherit;">Oleh karena itu, jumlah situs tidak menjamin tanda terima pada peta dari jumlah lahan yang diperlukan. </font><font style="vertical-align: inherit;">Mari tambahkan opsi untuk secara langsung mengontrol persentase lahan yang dinyatakan sebagai bilangan bulat. </font><font style="vertical-align: inherit;">Karena 100% tanah atau air tidak terlalu menarik, kami membatasinya pada interval 5–95, dengan nilai 50 secara default.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(5, 95)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landPercentage = <span class="hljs-number"><span class="hljs-number">50</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/281/912/21e281912ad5a4a5378c5e55514c639c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persentase sushi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menjamin terciptanya jumlah lahan yang tepat, kita hanya perlu terus meningkatkan area dataran sampai kita mendapatkan jumlah yang cukup. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu mengendalikan prosesnya, yang akan menyulitkan pembuatan tanah. </font><font style="vertical-align: inherit;">Karena itu, mari kita ganti siklus yang ada untuk meningkatkan situs dengan memanggil metode baru </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hal pertama yang dilakukan metode ini adalah menghitung jumlah sel yang seharusnya menjadi daratan. </font><font style="vertical-align: inherit;">Jumlah ini akan menjadi jumlah total sel sushi kami.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; 5; i++) { // RaiseTerrain(Random.Range(chunkSizeMin, chunkSizeMax + 1)); // } CreateLand(); for (int i = 0; i &lt; cellCount; i++) { grid.GetCell(i).SearchPhase = 0; } } void CreateLand () { int landBudget = Mathf.RoundToInt(cellCount * landPercentage * 0.01f); }</span></span></code> </pre> <br> <code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menyebabkan </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sampai kita menghabiskan seluruh jumlah sel. </font><font style="vertical-align: inherit;">Agar tidak melebihi jumlah, kami mengubah </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menerima jumlah sebagai parameter tambahan. </font><font style="vertical-align: inherit;">Setelah selesai bekerja, ia harus mengembalikan jumlah yang tersisa.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void RaiseTerrain (int chunkSize) { int RaiseTerrain (int chunkSize, int budget) { … return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlahnya harus berkurang setiap kali sel dikeluarkan dari perbatasan dan dikonversi menjadi daratan. </font><font style="vertical-align: inherit;">Jika setelah ini seluruh jumlah dihabiskan, maka kita harus menghentikan pencarian dan menyelesaikan situs. </font><font style="vertical-align: inherit;">Selain itu, ini harus dilakukan hanya ketika sel saat ini belum mendarat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { current.TerrainTypeIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat meningkatkan lahan sampai menghabiskan seluruh sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { landBudget = RaiseTerrain( Random.Range(chunkSizeMin, chunkSizeMax + <span class="hljs-number"><span class="hljs-number">1</span></span>), landBudget ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d15/34e/7f4/d1534e7f47ba4cf87f3dbeed60aa7d00.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setengah peta menjadi tanah. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mempertimbangkan ketinggian </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanah bukan hanya pelat datar, dibatasi oleh garis pantai. </font><font style="vertical-align: inherit;">Dia memiliki ketinggian yang berubah, mengandung bukit, gunung, lembah, danau, dan sebagainya. </font><font style="vertical-align: inherit;">Perbedaan besar dalam ketinggian ada karena interaksi lempeng tektonik yang bergerak lambat. </font><font style="vertical-align: inherit;">Meskipun kami tidak akan mensimulasikannya, area tanah kami harus menyerupai pelat tersebut. </font><font style="vertical-align: inherit;">Situs tidak bergerak, tetapi dapat berpotongan. </font><font style="vertical-align: inherit;">Dan kita bisa memanfaatkan ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dorong tanah ke atas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap plot mewakili bagian tanah yang didorong keluar dari dasar lautan. </font><font style="vertical-align: inherit;">Karena itu, mari kita terus-menerus meningkatkan ketinggian sel saat ini </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melihat apa yang terjadi.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.TerrainTypeIndex == <span class="hljs-number"><span class="hljs-number">0</span></span>) { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3c/f6e/d3e/b3cf6ed3e71eb737ea7246c92bdd5624.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mendarat dengan ketinggian. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami punya ketinggian, tapi sulit dilihat. </font><font style="vertical-align: inherit;">Anda dapat membuatnya lebih mudah dibaca jika menggunakan jenis medan Anda sendiri untuk setiap tingkat ketinggian, seperti pelapisan geografis. </font><font style="vertical-align: inherit;">Kami hanya akan melakukan ini agar ketinggian lebih terlihat, sehingga Anda cukup menggunakan level ketinggian sebagai indeks ketinggian.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang terjadi jika ketinggian melebihi jumlah jenis medan?</font></font></b> <div class="spoiler_text">        .        ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih memperbarui jenis medan sel dengan setiap perubahan ketinggian, mari kita buat metode terpisah </font></font><code>SetTerrainType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mengatur semua jenis medan hanya sekali.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); cell.TerrainTypeIndex = cell.Elevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami akan memanggil metode ini setelah membuat sushi. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … CreateLand(); SetTerrainType(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang dia </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak bisa menangani jenis bantuan, dan fokus pada ketinggian. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda perlu mengubah logikanya. </font><font style="vertical-align: inherit;">Jika tinggi baru sel saat ini adalah 1, maka itu baru saja menjadi kering, sehingga jumlah sel telah menurun, yang dapat menyebabkan selesainya pertumbuhan situs.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// if (current.TerrainTypeIndex == 0) { // current.TerrainTypeIndex = 1; // if (--budget == 0) { // break; // } // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/eec/b9e/ee0eecb9e59f527bd27f0275e230de0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stratifikasi lapisan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan air </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita secara eksplisit menunjukkan sel mana yang air atau tanah, mengatur level air untuk semua sel menjadi 1. Mari kita lakukan ini </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum membuat tanah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { cellCount = x * z; grid.CreateMap(x, z); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (searchFrontier == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { searchFrontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCellPriorityQueue(); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = <span class="hljs-number"><span class="hljs-number">1</span></span>; } CreateLand(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang untuk penunjukan lapisan tanah kita bisa menggunakan semua jenis medan. </font><font style="vertical-align: inherit;">Semua sel kapal selam akan tetap berpasir, demikian pula sel-sel daratan terendah. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan mengurangi ketinggian air dari ketinggian dan menggunakan nilai sebagai indeks dari jenis bantuan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { HexCell cell = grid.GetCell(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { cell.TerrainTypeIndex = cell.Elevation - cell.WaterLevel; } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b5/449/bc3/1b5449bc37b1c677d908484c7bcd0286.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanah dan air.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Naikkan level air </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak terbatas pada satu permukaan air saja. </font><font style="vertical-align: inherit;">Mari kita membuatnya dapat disesuaikan menggunakan bidang umum dengan interval 1–5 dan nilai default 3. </font><font style="vertical-align: inherit;">Gunakan level ini saat menginisialisasi sel.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(1, 5)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel = <span class="hljs-number"><span class="hljs-number">3</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cellCount; i++) { grid.GetCell(i).WaterLevel = waterLevel; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/9cf/82f/c329cf82f9a847ac01f2754cc3252500.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/c9d/fe4/850c9dfe4694834486bf4be64ac1783a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketinggian air 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika ketinggian airnya 3, kita mendapatkan tanah yang kurang dari yang kita harapkan. </font><font style="vertical-align: inherit;">Ini karena </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masih percaya bahwa ketinggian air adalah 1. Mari kita perbaiki.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); current.Elevation += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Elevation == waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan level air yang lebih tinggi mengarah ke sana. </font><font style="vertical-align: inherit;">bahwa sel tidak segera menjadi daratan. </font><font style="vertical-align: inherit;">Ketika level air 2, bagian pertama akan tetap berada di bawah air. </font><font style="vertical-align: inherit;">Dasar laut telah naik, tetapi masih tetap di bawah air. </font><font style="vertical-align: inherit;">Sebuah tanah hanya terbentuk di persimpangan setidaknya dua bagian. </font><font style="vertical-align: inherit;">Semakin tinggi permukaan air, semakin banyak situs yang harus dilintasi untuk menciptakan tanah. </font><font style="vertical-align: inherit;">Karena itu, dengan naiknya permukaan air, tanah menjadi lebih kacau. </font><font style="vertical-align: inherit;">Selain itu, ketika lebih banyak plot diperlukan, lebih mungkin mereka akan berpotongan di lahan yang sudah ada, itulah sebabnya gunung akan lebih umum dan tanah datar lebih jarang, seperti dalam kasus menggunakan plot yang lebih kecil.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/f02/abf/c39f02abf2bfa93f01395208da92ae9a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/01f/4e2/5a901f4e2785456e0784f33508be4ede.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/816/cc1/863816cc19c0fd7cbf172905962970d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/412/190/fd041219043df072443b00d6799f3946.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat airnya 2-5, sushi selalu 50%. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gerakan vertikal </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sejauh ini kami telah menaikkan plot satu tingkat pada satu waktu, tetapi kami tidak harus membatasi diri untuk ini. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Situs tinggi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun setiap bagian meningkatkan tinggi selnya satu level, kliping dapat terjadi. </font><font style="vertical-align: inherit;">Ini terjadi ketika tepi dua bagian bersentuhan. </font><font style="vertical-align: inherit;">Ini dapat membuat tebing yang terisolasi, tetapi garis tebing yang panjang akan jarang. </font><font style="vertical-align: inherit;">Kita dapat meningkatkan frekuensi penampilan mereka dengan meningkatkan ketinggian plot lebih dari satu langkah. </font><font style="vertical-align: inherit;">Tetapi ini perlu dilakukan hanya untuk sebagian situs saja. </font><font style="vertical-align: inherit;">Jika semua daerah naik tinggi, akan sangat sulit untuk bergerak di sepanjang medan. </font><font style="vertical-align: inherit;">Jadi mari kita buat parameter ini dapat dikustomisasi menggunakan bidang probabilitas dengan nilai default 0,25.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 1f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> highRiseProbability = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/485/8d7/cb64858d7531bb31842aebdd49b68304.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan kenaikan kuat dalam sel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kita dapat menggunakan peningkatan ketinggian apa pun untuk area tinggi, ini dengan cepat menjadi tidak terkendali. </font><font style="vertical-align: inherit;">Perbedaan ketinggian 2 sudah membuat tebing, jadi ini sudah cukup. </font><font style="vertical-align: inherit;">Karena Anda dapat melewati ketinggian yang sama dengan ketinggian air, kami perlu mengubah cara kami menentukan apakah sebuah sel telah menjadi daratan. </font><font style="vertical-align: inherit;">Jika berada di bawah permukaan air, dan sekarang berada pada tingkat yang sama atau lebih tinggi, maka kami membuat sel tanah baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rise = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; current.Elevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b31/8c1/ea5/b318c1ea557ced17d2cb0d9a951bcfc3.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ba/353/78b/4ba35378bc60e74b624e136b90a4a7eb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea3/8ac/b0a/ea38acb0a5cf12835c2ba177e41d6178.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/018/0df/bd9/0180dfbd9869a0d0e0d5a1712af34fb3.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probabilitas peningkatan tinggi yang kuat adalah 0,25, 0,50, 0,75 dan 1.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Turunkan tanah </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanah tidak selalu naik, kadang jatuh. </font><font style="vertical-align: inherit;">Ketika tanah jatuh cukup rendah, air mengisinya dan hilang. </font><font style="vertical-align: inherit;">Sejauh ini kami tidak melakukan ini. </font><font style="vertical-align: inherit;">Karena kami hanya mendorong area ke atas, tanah biasanya terlihat seperti satu set area yang agak bulat bercampur menjadi satu. </font><font style="vertical-align: inherit;">Jika kita terkadang menurunkan area ke bawah, kita mendapatkan bentuk yang lebih bervariasi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/95e/d81/9e495ed818dfffc39e5a238f273c8c5b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta besar tanpa sushi cekung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat mengontrol frekuensi penurunan tanah menggunakan bidang probabilitas lain. </font><font style="vertical-align: inherit;">Karena penurunan dapat menghancurkan tanah, probabilitas penurunan harus selalu lebih rendah daripada probabilitas peningkatan. </font><font style="vertical-align: inherit;">Kalau tidak, mungkin butuh waktu yang sangat lama untuk mendapatkan persentase lahan yang tepat. </font><font style="vertical-align: inherit;">Oleh karena itu, mari kita gunakan probabilitas penurunan maksimum 0,4 dengan nilai default 0,2.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(0f, 0.4f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sinkProbability = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a11/997/e82/a11997e824700a045e9faaedaafeb121.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan menurunkan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menurunkan situs mirip dengan menaikkan, dengan beberapa perbedaan. </font><font style="vertical-align: inherit;">Karenanya, kami menduplikasi metode </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengubah namanya menjadi </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Alih-alih menentukan besarnya kenaikan, kita membutuhkan nilai yang lebih rendah yang dapat menggunakan logika yang sama. </font><font style="vertical-align: inherit;">Pada saat yang sama, perbandingan untuk memeriksa apakah kita telah melewati permukaan air perlu dibalik. </font><font style="vertical-align: inherit;">Selain itu, ketika menurunkan relief, kita tidak terbatas pada jumlah sel. </font><font style="vertical-align: inherit;">Sebaliknya, setiap sel sushi yang hilang mengembalikan jumlah yang dihabiskan untuknya, jadi kami meningkatkannya dan terus bekerja.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SinkTerrain</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunkSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sink = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; highRiseProbability ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (size &lt; chunkSize &amp;&amp; searchFrontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; current.Elevation = originalElevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; current.Elevation &lt; waterLevel <span class="hljs-comment"><span class="hljs-comment">// &amp;&amp; --budget == 0 ) { // break; budget += 1; } size += 1; … } searchFrontier.Clear(); return budget; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, pada setiap iterasi di dalam, </font></font><code>CreateLand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita harus menurunkan atau menaikkan lahan, tergantung pada probabilitas penurunan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLand</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> landBudget = Mathf.RoundToInt(cellCount * landPercentage * <span class="hljs-number"><span class="hljs-number">0.01f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (landBudget &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSize = Random.Range(chunkSizeMin, chunkSizeMax - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; sinkProbability) { landBudget = SinkTerrain(chunkSize, landBudget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { landBudget = RaiseTerrain(chunkSize, landBudget); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/c5e/762/d6bc5e76274e4aa9c8a692f90fde3646.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/8ae/3e3/c2f8ae3e3a4b814b6ae954d40225149e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/f5d/461/1e3f5d461421feddbb145d4e1d56c000.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33b/39d/462/33b39d462682688fc2a8094556e4fc91.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peluang jatuh adalah 0,1, 0,2, 0,3, dan 0,4.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Batasi ketinggian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap saat ini, kita bisa berpotensi tumpang tindih banyak bagian, kadang-kadang dengan beberapa peningkatan ketinggian, beberapa di antaranya bisa turun dan kemudian naik lagi. </font><font style="vertical-align: inherit;">Pada saat yang sama, kita dapat menciptakan ketinggian yang sangat tinggi, dan kadang-kadang sangat rendah, terutama ketika dibutuhkan persentase tanah yang tinggi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/c2e/359/f3fc2e359db04b4411f2bcd06b81888b.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketinggian besar di tanah 90%. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membatasi ketinggian, mari tambahkan kustom minimum dan maksimum. </font><font style="vertical-align: inherit;">Minimum yang wajar akan berada di suatu tempat antara −4 dan 0, dan maksimum yang dapat diterima mungkin dalam kisaran 6-10. </font><font style="vertical-align: inherit;">Biarkan nilai default menjadi −2 dan 8. Saat mengedit peta secara manual, mereka akan berada di luar batas yang dapat diterima, sehingga Anda dapat mengubah bilah geser UI editor, atau membiarkannya apa adanya.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Range(-4, 0)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMinimum = <span class="hljs-number"><span class="hljs-number">-2</span></span>; [Range(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevationMaximum = <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/20b/efc/bcb20befc496cd2c5bffbc94b0a9d267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinggi minimum dan maksimum. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang </font></font><code>RaiseTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita harus memastikan bahwa ketinggiannya tidak melebihi batas maksimum yang diizinkan. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan memeriksa apakah sel saat ini terlalu tinggi. </font><font style="vertical-align: inherit;">Jika demikian, maka kami melewati mereka tanpa mengubah ketinggian dan menambahkan tetangga mereka. </font><font style="vertical-align: inherit;">Ini akan mengarah pada fakta bahwa area daratan akan menghindari area yang telah mencapai ketinggian maksimum, dan tumbuh di sekitarnya.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = originalElevation + rise; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &gt; elevationMaximum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &lt; waterLevel &amp;&amp; newElevation &gt;= waterLevel &amp;&amp; --budget == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lakukan hal yang sama </font></font><code>SinkTerrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi untuk ketinggian minimum.</font></font><br><br><pre> <code class="cs hljs"> HexCell current = searchFrontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalElevation = current.Elevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newElevation = current.Elevation - sink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newElevation &lt; elevationMinimum) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } current.Elevation = newElevation; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( originalElevation &gt;= waterLevel &amp;&amp; newElevation &lt; waterLevel ) { budget += <span class="hljs-number"><span class="hljs-number">1</span></span>; } size += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/cbe/339/4afcbe339d0d697779ff0649f6c2c125.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketinggian terbatas dengan tanah 90%.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pelestarian Ketinggian Negatif </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, kode simpan dan muat tidak dapat menangani ketinggian negatif karena kami menyimpan ketinggian sebagai byte. </font><font style="vertical-align: inherit;">Angka negatif dikonversi ketika disimpan ke positif besar. </font><font style="vertical-align: inherit;">Karena itu, ketika menyimpan dan memuat peta yang dihasilkan, yang sangat tinggi mungkin muncul sebagai pengganti sel bawah air asli. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat menambahkan dukungan untuk ketinggian negatif dengan menyimpannya sebagai integer, bukan byte. </font><font style="vertical-align: inherit;">Namun, kita masih tidak perlu mendukung berbagai level ketinggian. </font><font style="vertical-align: inherit;">Selain itu, kami dapat mengimbangi nilai yang disimpan dengan menambahkan 127. Ini akan memungkinkan kami untuk menyimpan ketinggian dengan benar di kisaran −127–128 dalam satu byte. </font><font style="vertical-align: inherit;">Ubah </font></font><code>HexCell.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sesuai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(elevation + <span class="hljs-number"><span class="hljs-number">127</span></span>)); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami mengubah cara kami menyimpan data peta, kami menambahnya </font></font><code>SaveLoadMenu.mapFileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mapFileVersion = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan akhirnya, ubah </font></font><code>HexCell.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga mengurangi 127 dari ketinggian yang dimuat dari file versi 4.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadByte(); ShaderData.RefreshTerrain(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); elevation = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { elevation -= <span class="hljs-number"><span class="hljs-number">127</span></span>; } … }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menciptakan peta yang sama </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat membuat berbagai macam peta. </font><font style="vertical-align: inherit;">Saat menghasilkan setiap hasil baru akan acak. </font><font style="vertical-align: inherit;">Kami dapat mengontrol menggunakan opsi konfigurasi hanya karakteristik kartu, tetapi bukan bentuk yang paling akurat. </font><font style="vertical-align: inherit;">Tetapi kadang-kadang kita perlu membuat kembali peta yang sama persis lagi. </font><font style="vertical-align: inherit;">Misalnya, untuk berbagi peta yang indah dengan teman, atau mulai lagi setelah mengeditnya secara manual. </font><font style="vertical-align: inherit;">Ini juga berguna dalam proses pengembangan game, jadi mari kita tambahkan fitur ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan Benih </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat proses pembuatan peta tidak dapat diprediksi, kami menggunakan </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk mendapatkan urutan angka pseudo-acak yang sama lagi, Anda perlu menggunakan nilai seed yang sama. </font><font style="vertical-align: inherit;">Kami telah mengambil pendekatan serupa sebelumnya, di </font></font><code>HexMetrics.InitializeHashGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertama-tama ia menyimpan keadaan saat ini dari generator nomor yang diinisialisasi dengan nilai benih tertentu, dan kemudian mengembalikan keadaan aslinya. </font><font style="vertical-align: inherit;">Kita dapat menggunakan pendekatan yang sama untuk </font></font><code>HexMapGenerator.GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kita dapat mengingat kembali kondisi lama dan mengembalikannya setelah selesai, agar tidak mengganggu apa pun yang menggunakan </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; … Random.state = originalRandomState; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita perlu menyediakan seed yang digunakan untuk menghasilkan kartu terakhir. </font><font style="vertical-align: inherit;">Ini dilakukan dengan menggunakan bidang bilangan bulat umum.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/3b5/538/41d3b553898698698636b6bada081aa6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benih tampilan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita membutuhkan nilai seed untuk diinisialisasi </font></font><code>Random</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk membuat kartu acak, Anda perlu menggunakan seed acak. </font><font style="vertical-align: inherit;">Pendekatan paling sederhana adalah dengan menggunakan nilai seed arbitrary untuk menghasilkan </font></font><code>Random.Range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agar tidak mempengaruhi keadaan acak awal, kita perlu melakukan ini setelah menyimpannya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Random.State originalRandomState = Random.state; seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); Random.InitState(seed); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena setelah selesai kami mengembalikan keadaan acak, jika kami segera menghasilkan kartu lain, sebagai hasilnya kami mendapatkan nilai seed yang sama. </font><font style="vertical-align: inherit;">Selain itu, kita tidak tahu bagaimana keadaan acak awal diinisialisasi. </font><font style="vertical-align: inherit;">Oleh karena itu, meskipun dapat berfungsi sebagai titik awal yang sewenang-wenang, kami membutuhkan sesuatu yang lebih untuk mengacaknya dengan setiap panggilan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada berbagai cara untuk menginisialisasi generator angka acak. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda dapat dengan mudah menggabungkan beberapa nilai arbitrer yang bervariasi pada rentang yang luas, yaitu kemungkinan menghasilkan kembali kartu yang sama akan rendah. </font><font style="vertical-align: inherit;">Sebagai contoh, kami menggunakan 32 bit yang lebih rendah dari waktu sistem, dinyatakan dalam siklus, ditambah runtime aplikasi saat ini. </font><font style="vertical-align: inherit;">Gabungkan nilai-nilai ini menggunakan operasi ATAU bitwise eksklusif sehingga hasilnya tidak terlalu besar.</font></font><br><br><pre> <code class="cs hljs"> seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angka yang dihasilkan mungkin negatif, yang untuk nilai benih publik tidak terlihat bagus. </font><font style="vertical-align: inherit;">Kita bisa membuatnya benar-benar positif dengan menggunakan masking bitwise dengan nilai integer maksimum yang akan mereset bit sign.</font></font><br><br><pre> <code class="cs hljs"> seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.unscaledTime; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; Random.InitState(seed);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benih yang dapat digunakan kembali </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami masih menghasilkan kartu acak, tetapi sekarang kami bisa melihat nilai seed apa yang digunakan untuk masing-masing kartu. </font><font style="vertical-align: inherit;">Untuk membuat kembali peta yang sama lagi, kita harus memesan generator untuk menggunakan nilai seed yang sama lagi, daripada membuat yang baru. </font><font style="vertical-align: inherit;">Kami akan melakukan ini dengan menambahkan saklar menggunakan bidang Boolean.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useFixedSeed;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/200/4c6/eed/2004c6eed8c2244bdfe660bf477d2fa3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi untuk menggunakan seed konstan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika sebuah seed konstan dipilih, maka kami hanya melewatkan menghasilkan seed baru di </font></font><code>GenerateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika kami tidak mengubah bidang benih secara manual, hasilnya akan menjadi peta yang sama lagi.</font></font><br><br><pre> <code class="cs hljs"> Random.State originalRandomState = Random.state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!useFixedSeed) { seed = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue); seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)System.DateTime.Now.Ticks; seed ^= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Time.time; seed &amp;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } Random.InitState(seed);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menyalin nilai seed dari peta yang kita sukai dan menyimpannya di suatu tempat, untuk menghasilkannya lagi di masa depan. </font><font style="vertical-align: inherit;">Jangan lupa bahwa kita akan mendapatkan kartu yang sama hanya jika kita menggunakan parameter generator yang sama persis, yaitu, ukuran kartu yang sama, serta semua opsi konfigurasi lainnya. </font><font style="vertical-align: inherit;">Bahkan perubahan kecil dalam probabilitas ini dapat membuat peta yang sama sekali berbeda. </font><font style="vertical-align: inherit;">Karena itu, selain seed, kita perlu mengingat semua pengaturan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ff/cd2/279/7ffcd2279b4dd882db924d8e1fc61d0e.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/6db/156/4866db15628d75936b7e19fa4841f2f5.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kartu besar dengan nilai seed 0 dan 929396788, parameter standar. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427003/">https://habr.com/ru/post/id427003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426991/index.html">Startup Digest: 10 acara IT mendatang di Moskow</a></li>
<li><a href="../id426993/index.html">Apakah saya perlu belajar C untuk memahami cara kerja komputer?</a></li>
<li><a href="../id426995/index.html">Daur ulang membahayakan produk dan karyawan</a></li>
<li><a href="../id426997/index.html">Cara membuat bentuk khusus menggunakan MaterialShapeDrawable</a></li>
<li><a href="../id426999/index.html">Mengikuti tren, atau bergerak menuju RxJava dan LiveData</a></li>
<li><a href="../id427005/index.html">Pengembang AI - profesi jutawan?</a></li>
<li><a href="../id427009/index.html">"Berjalan" dari elektron: manipulasi dengan muatan di dalam struktur ikatan tak jenuh</a></li>
<li><a href="../id427011/index.html">"Hello World!" pada FPGA atau versi UART berikutnya</a></li>
<li><a href="../id427013/index.html">Tatap muka NeoQUEST-2018: ingat bagaimana itu</a></li>
<li><a href="../id427015/index.html">Mengapa pusat data cerdas komersial membutuhkan PDU pintar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>