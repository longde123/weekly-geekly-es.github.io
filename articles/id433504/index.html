<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏻 🍥 🌹 Bagaimana cara berhenti menulis firmware untuk mikrokontroler dan mulai hidup 💭 🤑 🥡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, nama saya Eugene, dan saya bosan menulis firmware untuk mikrokontroler. Bagaimana ini terjadi dan apa yang harus dilakukan dengan itu, mari kita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara berhenti menulis firmware untuk mikrokontroler dan mulai hidup</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433504/"><img src="https://habrastorage.org/webt/nd/sn/hu/ndsnhuqdxwhktmaafqwsluk-iia.png"><br><p>  Halo, nama saya Eugene, dan saya bosan menulis firmware untuk mikrokontroler.  Bagaimana ini terjadi dan apa yang harus dilakukan dengan itu, mari kita cari tahu. </p><a name="habracut"></a><br><p>  Setelah Anda bekerja dalam pemrograman besar C ++, Java, Python, dll., Anda tidak ingin kembali ke mikrokontroler yang kecil dan buncit.  Untuk sedikit alat dan perpustakaan mereka.  Namun terkadang tidak ada yang bisa dilakukan, tugas real-time dan otonomi tidak meninggalkan pilihan.  Tetapi ada beberapa jenis tugas yang menjadi liar di daerah ini untuk dipecahkan. </p><br><p>  Misalnya, peralatan pengujian, sesuatu yang lebih membosankan dan pelajaran membosankan dalam pemrograman tertanam, sulit dibayangkan.  Secara umum, serta alat yang nyaman untuk ini.  Anda menulis ... Anda berkedip ... Anda berkedip ... LED (kadang-kadang masuk di UART).  Semua pena, tanpa alat pengujian khusus. </p><br><p>  Ini juga menyedihkan bahwa tidak ada tes instrumental untuk mikrokontroler kecil kami.  Semuanya hanya melalui firmware dan melalui debugger untuk menguji. </p><br><p> Dan studi bekerja dengan perangkat dan periferal baru membutuhkan banyak usaha dan waktu.  Satu kesalahan dan program harus dikompilasi ulang dan dijalankan kembali setiap kali. </p><br><p>  Untuk eksperimen semacam itu, sesuatu seperti REPL lebih cocok, sehingga Anda dapat dengan mudah dan tanpa rasa sakit melakukan hal-hal ini, setidaknya sepele, hal-hal: </p><br><p><img src="https://habrastorage.org/webt/cl/rb/oh/clrbohl9g4mkgs_l2z-mf4wmjde.gif">  \ </p><br><p>  Bagaimana caranya, seri artikel ini dikhususkan. </p><br><p>  Dan kali ini saya menemukan sebuah proyek di mana perlu untuk menguji perangkat yang agak rumit, dengan banyak semua jenis sensor dan chip lain yang tidak saya kenal sebelumnya, yang menggunakan banyak perangkat MK dan banyak antarmuka yang berbeda.  Kegembiraan khusus adalah bahwa saya tidak memiliki kode sumber firmware untuk papan tulis, sehingga semua tes harus ditulis dari awal, tanpa menggunakan waktu pengoperasian dari kode sumber. </p><br><p>  Proyek menjanjikan juru roti yang baik dan kontes menarik selama dua bulan atau lebih (dan kemungkinan besar lebih). </p><br><p>  Oke, kita tidak akan menangis.  Seseorang harus terjun ke belantara C dan firmware tak berujung lagi, atau menolak atau datang dengan sesuatu untuk memfasilitasi pelajaran ini.  Pada akhirnya, kemalasan dan keingintahuan adalah mesin kemajuan. </p><br><p>  Terakhir kali, ketika saya mengerti OpenOCD, saya menemukan titik yang menarik dalam dokumentasi </p><br><pre><code class="plaintext hljs">http://openocd.org/doc/html/General-Commands.html 15.4 Memory access commands mdw, mdh, mdb —         mww, mwh, mwb —       </code> </pre> <br><p>  Menarik ...  Dan apakah mungkin untuk membaca dan menulis register periferal dengan mereka? .. ternyata memungkinkan, dan di samping itu, perintah-perintah ini dapat dijalankan dari jarak jauh melalui server TCL, yang dimulai ketika openOCD dimulai. </p><br><p>  Berikut adalah contoh LED yang berkedip untuk stm32f103C8T6 </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step 1: Enable the clock to PORT B RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPCEN; // Step 2: Change PB0's mode to 0x3 (output) and cfg to 0x0 (push-pull) GPIOC-&gt;CRH = GPIO_CRH_MODE13_0 | GPIO_CRH_MODE13_1; // Step 3: Set PB0 high GPIOC-&gt;BSRR = GPIO_BSRR_BS13; // Step 4: Reset PB0 low GPIOC-&gt;BSRR = GPIO_BSRR_BR13;</span></span></code> </pre> <br><p>  dan urutan serupa dari perintah openOCD </p><br><pre> <code class="plaintext hljs">mww 0x40021018 0x10 mww 0x40011004 0x300000 mww 0x40011010 0x2000 mww 0x40011010 0x20000000</code> </pre> <br><p>  Dan sekarang, jika Anda berpikir tentang yang abadi dan mempertimbangkan firmware untuk MK ... maka tujuan utama dari program ini adalah untuk menulis ke register chip;  Firmware yang hanya akan melakukan sesuatu dan bekerja hanya dengan inti prosesor tidak memiliki penggunaan praktis! </p><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text"><p>  Meskipun tentu saja Anda dapat mempertimbangkan crypt (= </p></div></div><br><p>  Banyak yang akan lebih ingat tentang bekerja dengan interupsi.  Tetapi mereka tidak selalu diperlukan, dan dalam kasus saya, Anda dapat melakukannya tanpa mereka. </p><br><p>  Jadi, hidup menjadi lebih baik.  Di sumber openOCD Anda bahkan dapat menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> menarik menggunakan antarmuka ini. </p><br><p>  Sangat bagus kosong di python. </p><br><p>  Sangat mungkin untuk mengkonversi alamat register dari file header, dan mulai menulis dalam bahasa scripting halal.  Anda sudah dapat menyiapkan sampanye, tetapi bagi saya rasanya tidak cukup, karena saya ingin menggunakan Perpustakaan Periferal Standar atau HAL baru untuk bekerja dengan periferal alih-alih sibuk dengan register. </p><br><p>  Memindahkan pustaka ke python ... dalam mimpi buruk kita akan melakukannya.  Jadi, Anda perlu menggunakan perpustakaan ini di C atau ... C ++.  Dan di pro, Anda dapat mengganti hampir semua operator ... untuk kelas mereka. </p><br><p>  Dan alamat dasar dalam file header, ganti dengan objek dari kelas mereka. </p><br><p>  Misalnya, dalam file stm32f10x.h </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE ((uint32_t)0x42000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Ganti dengan </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterceptAddr</span></span></span><span class="hljs-class">;</span></span> InterceptAddr addr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BB_BASE (addr) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span></span></code> </pre> <br><p>  Tapi game dengan pointer di perpustakaan memotong ide ini sejak awal ... </p><br><p>  Berikut adalah contoh file stm32f10x_i2c.c: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FlagStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C_GetFlagStatus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I2C_TypeDef* I2Cx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I2C_FLAG)</span></span></span><span class="hljs-function"> </span></span>{ __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i2creg = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2cxbase = <span class="hljs-number"><span class="hljs-number">0</span></span>; …. <span class="hljs-comment"><span class="hljs-comment">/* Get the I2Cx peripheral base address */</span></span> i2cxbase = (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)I2Cx; ….</code> </pre> <br><p>  Jadi, perlu untuk mencegat alamat ke alamat entah bagaimana berbeda.  Cara melakukan ini mungkin patut dilihat di Valgrind, bukan tanpa alasan bahwa ia memiliki seorang memchecker.  Yah, dia benar-benar harus tahu cara mencegat alamat. </p><br><p>  Ke depan, saya akan mengatakan bahwa lebih baik tidak melihat ke sana ... Saya hampir berhasil mencegat panggilan ke alamat.  Untuk hampir semua kasus kecuali ini </p><br><pre> <code class="cpp hljs">Int * p = ... *p = <span class="hljs-number"><span class="hljs-number">0x123</span></span>;</code> </pre> <br><p>  Dimungkinkan untuk mencegat alamat, tetapi tidak mungkin lagi untuk mencegat data yang direkam.  Hanya nama register internal tempat nilai ini berada, tetapi yang tidak dapat dijangkau dari memcheck. </p><br><p>  Bahkan, Valgrind mengejutkan saya, di dalam monster libVEX kuno digunakan, tentang yang saya tidak menemukan informasi di Internet.  Bagus bahwa sedikit dokumentasi ditemukan di file header. </p><br><p>  Lalu ada alat DBI lainnya. </p><br><p>  Frida, Dynamic RIO, beberapa lagi, dan akhirnya mendapat Pintool. </p><br><p>  PinTool memiliki beberapa dokumentasi dan contoh yang cukup bagus.  Meskipun saya masih belum cukup, saya harus melakukan eksperimen dengan beberapa hal.  Alat ini ternyata sangat kuat, hanya mengganggu kode yang ditutup dan pembatasan hanya untuk platform intel (meskipun di masa depan ini dapat dielakkan) </p><br><p>  Jadi, kita perlu mencegat menulis dan membaca di alamat tertentu.  Mari kita lihat instruksi apa yang bertanggung jawab untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://godbolt.org/z/nJS9ci</a> ini. </p><br><p>  Untuk x64, ini akan menjadi MOV untuk kedua operasi. </p><br><p>  Dan untuk x86 itu adalah MOV untuk menulis dan MOVZ untuk membaca. </p><br><p>  Catatan: yang terbaik adalah tidak mengaktifkan optimasi, jika tidak instruksi lain mungkin muncul. </p><br><div class="spoiler">  <b class="spoiler_title">Judul spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs">INS_AddInstrumentFunction(EmulateLoad, <span class="hljs-number"><span class="hljs-number">0</span></span>); INS_AddInstrumentFunction(EmulateStore, <span class="hljs-number"><span class="hljs-number">0</span></span>); ..... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmulateLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(INS ins, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Find the instructions that move a value from memory to a register if ((INS_Opcode(ins) == XED_ICLASS_MOV || INS_Opcode(ins) == XED_ICLASS_MOVZX) &amp;&amp; INS_IsMemoryRead(ins) &amp;&amp; INS_OperandIsReg(ins, 0) &amp;&amp; INS_OperandIsMemory(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(loadAddr2Reg), IARG_MEMORYREAD_EA, IARG_MEMORYREAD_SIZE, IARG_RETURN_REGS, INS_OperandReg(ins, 0), IARG_END); // Delete the instruction INS_Delete(ins); } } static VOID EmulateStore(INS ins, VOID *v) { if (INS_Opcode(ins) == XED_ICLASS_MOV &amp;&amp; INS_IsMemoryWrite(ins) &amp;&amp; INS_OperandIsMemory(ins, 0)) { if (INS_hasKnownMemorySize(ins)) { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(multiMemAccessStore), IARG_MULTI_MEMORYACCESS_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)multiMemAccessStore, IARG_MULTI_MEMORYACCESS_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_END); } } else { if (INS_OperandIsReg(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_REG_VALUE, INS_OperandReg(ins, 1), IARG_MEMORYWRITE_SIZE, IARG_END); } else if (INS_OperandIsImmediate(ins, 1)) { INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(storeReg2Addr), IARG_MEMORYWRITE_EA, IARG_UINT64, INS_OperandImmediate(ins, 1), IARG_UINT32, IARG_MEMORYWRITE_SIZE, IARG_END); } } } }</span></span></code> </pre> </div></div><br><p>  Dalam hal membaca dari alamat, kami memanggil fungsi loadAddr2Reg dan menghapus instruksi asli.  Berdasarkan ini, loadAddr2Reg harus mengembalikan nilai yang diperlukan kepada kami. </p><br><p>  Dengan catatan, semakin sulit ... argumennya bisa dari berbagai jenis dan juga dapat dikirim dengan cara yang berbeda, jadi Anda harus memanggil fungsi yang berbeda sebelum perintah.  Pada platform 32-bit, multiMemAccessStore, dan pada 64 storeReg2Addr akan dipanggil.  Dan di sini kita tidak menghapus instruksi dari jalur perakitan.  Tidak ada masalah untuk menghapusnya, tetapi dalam beberapa kasus tidak mungkin untuk meniru tindakannya.  Program untuk beberapa alasan terkadang menabrak sigfault.  Ini tidak penting bagi kami, biarlah itu ditulis untuk dirinya sendiri, hal utama adalah bahwa ada kemungkinan mencegat argumen. </p><br><p>  Selanjutnya kita perlu melihat alamat apa yang perlu kita intersep, lihat Memory Map untuk chip stm32f103C8T6 kami: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f59/014/f32/f59014f32867a45837c7609bc74a89b3.png" alt="gambar"><br>  Kami tertarik pada alamat dengan SRAM dan PERIPH_BASE, mis. Dari 0x20000000 hingga 0x20000000 + 128 * 1024 dan dari 0x40000000 hingga 0x40030000.  Yah, atau lebih tepatnya, tidak cukup, saat kita mengingat instruksi rekaman, kita tidak bisa menghapus.  Oleh karena itu, catatan di alamat ini akan jatuh di sigfault.  Selain itu, ada kemungkinan yang tidak mungkin bahwa alamat ini akan memiliki data dari program kami, bukan chip ini memiliki yang lain.  Karena itu, kita pasti perlu memperbaikinya di suatu tempat.  Katakanlah pada semacam array. </p><br><p>  Kami membuat array ukuran yang diperlukan, dan kemudian mengganti pointer mereka di alamat basis yang ditentukan. </p><br><p>  Dalam program kami, sebagai gantinya di berita utama </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((uint32_t)0x20000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; SRAM base address in the alias region */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((uint32_t)0x40000000) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*!&lt; Peripheral base address in the alias region */</span></span></span></span></code> </pre> <br><p>  Lakukan </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SRAM_BASE ((AddrType)pAddrSRAM) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PERIPH_BASE ((AddrType)pAddrPERIPH)</span></span></code> </pre> <br><p>  dan di mana pAddrSRAM dan pAddrPERIPH adalah pointer ke array yang dialokasikan sebelumnya. </p><br><p>  Sekarang, klien PinTool kami perlu menyampaikan bagaimana kami memperbaiki alamat yang diperlukan. <br>  Hal paling sederhana yang menurut saya bagaimana melakukannya adalah mencegat fungsi yang mengembalikan struktur array dari format ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span> start_addr; <span class="hljs-comment"><span class="hljs-comment">//      addr_t end_addr; //   addr_t reference_addr; //   } memoryTranslate;</span></span></code> </pre> <br><p>  Sebagai contoh, untuk chip kami akan sangat terisi </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;start_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)pAddrSRAM; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;end_addr = <span class="hljs-number"><span class="hljs-number">96</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-&gt;reference_addr = (<span class="hljs-keyword"><span class="hljs-keyword">addr_t</span></span>)<span class="hljs-number"><span class="hljs-number">0x20000000</span></span>U;</code> </pre> <br><p>  Tidaklah sulit untuk mencegat fungsi dan mengambil nilai yang diperlukan darinya: </p><br><pre> <code class="cpp hljs">IMG_AddInstrumentFunction(ImageReplace, <span class="hljs-number"><span class="hljs-number">0</span></span>); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> memoryTranslate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceMemoryMapFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CONTEXT *context, AFUNPTR orgFuncptr, sizeMemoryTranslate_t *size)</span></span></span><span class="hljs-function"> </span></span>{ PIN_CallApplicationFunction(context, PIN_ThreadId(), CALLINGSTD_DEFAULT, orgFuncptr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PIN_PARG(memoryTranslate *), &amp;addrMap, PIN_PARG(sizeMemoryTranslate_t *), size, PIN_PARG_END()); sizeMap = *size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addrMap; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImageReplace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IMG img, VOID *v)</span></span></span><span class="hljs-function"> </span></span>{ RTN freeRtn = RTN_FindByName(img, NAME_MEMORY_MAP_FUNCTION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RTN_Valid(freeRtn)) { PROTO proto_free = PROTO_Allocate(PIN_PARG(memoryTranslate *), CALLINGSTD_DEFAULT, NAME_MEMORY_MAP_FUNCTION, PIN_PARG(sizeMemoryTranslate_t *), PIN_PARG_END()); RTN_ReplaceSignature(freeRtn, AFUNPTR(replaceMemoryMapFun), IARG_PROTOTYPE, proto_free, IARG_CONTEXT, IARG_ORIG_FUNCPTR, IARG_FUNCARG_ENTRYPOINT_VALUE, <span class="hljs-number"><span class="hljs-number">0</span></span>, IARG_END); } }</code> </pre> <br><p>  Dan buat fungsi yang dicegat kami terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">memoryTranslate * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMemoryMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sizeMemoryTranslate_t * size)</span></span></span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoryMap; }</code> </pre> <br><p>  Apa pekerjaan paling sepele yang dilakukan, masih membuat klien untuk OpenOCD, di klien PinTool saya tidak ingin mengimplementasikannya, jadi saya membuat aplikasi terpisah yang berkomunikasi dengan klien PinTool kami melalui nama fifo. </p><br><p>  Dengan demikian, skema antarmuka dan komunikasi adalah sebagai berikut: <br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/a54/e2b/a0ea54e2b4e3b849ed205cb0879b4e23.png" alt="gambar"><br>  Alur kerja yang disederhanakan pada contoh mencegat alamat 0x123: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/65d/4d3/00a65d4d32607e0510e8abddf86382fb.png" alt="gambar"><br>  Mari kita lihat apa yang terjadi di sini: </p><br><p>  klien PinTool diluncurkan, ini menginisialisasi pencegat kami, memulai program <br>  Program dimulai, perlu alamat alamat register pada beberapa larik thread, fungsi getMemoryMap disebut, yang disadap PinTool kami.  Sebagai contoh, salah satu register telah beralih ke alamat 0x123, kami akan melacaknya <br>  Klien PinTool menyimpan nilai-nilai alamat yang dipisahkan <br>  Transfer kendali kembali ke program kami <br>  Lebih jauh, di suatu tempat ada rekaman di alamat terlacak kami 0x123.  Fungsi StoreReg2Addr melacak hal ini <br>  Dan mengirimkan permintaan tulis ke klien OpenOCD <br>  Klien mengembalikan jawaban, yang diuraikan.  Jika semuanya baik-baik saja, maka kontrol program kembali <br>  Lebih jauh, di suatu tempat dalam program, pembacaan terjadi pada alamat yang dilacak 0x123. <br>  loadAddr2Reg melacak ini dan mengirimkan permintaan OpenOCD ke klien. <br>  Klien OpenOCD memprosesnya dan mengembalikan respons <br>  Jika semuanya baik-baik saja, tetapi nilai dari register MK dikembalikan ke program <br>  Program berlanjut. <br>  Itu saja untuk saat ini, kode sumber dan contoh lengkap akan ada di bagian berikut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433504/">https://habr.com/ru/post/id433504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433494/index.html">10 idiom bahasa Inggris yang tidak akan Anda ketahui</a></li>
<li><a href="../id433496/index.html">Perusahaan milik negara wajib untuk beralih ke perangkat lunak dalam negeri pada tahun 2022</a></li>
<li><a href="../id433498/index.html">Sberbank - Anda memiliki "paket" untuk saya, tetapi saya tidak akan menerimanya ...</a></li>
<li><a href="../id433500/index.html">Robot kurir Berkeley terbakar karena kurangnya status sistem pemantauan</a></li>
<li><a href="../id433502/index.html">Teknologi audio nirkabel Bluetooth: mana yang lebih baik?</a></li>
<li><a href="../id433506/index.html">UE mencari hak untuk memperbaiki peralatan rumah tangga besar</a></li>
<li><a href="../id433508/index.html">Pemilik arsitektur MIPS bermaksud untuk membuka set instruksi (ISA) pada tahun 2019</a></li>
<li><a href="../id433510/index.html">Perbedaan lintas budaya dalam permainan</a></li>
<li><a href="../id433512/index.html">Teori kebahagiaan. Sandwich sandwich dengan mentega</a></li>
<li><a href="../id433514/index.html">Do-it-yourself sih</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>