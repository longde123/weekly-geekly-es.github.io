<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👺 🔟 🔖 Indicador de calidad del canal para el servidor WebRTC sobre TCP 📆 💇🏽 🍹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publica y juega 


 Existen dos funciones principales de la operación WebRTC en el lado del servidor en el campo de la transmisión de video: publicaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indicador de calidad del canal para el servidor WebRTC sobre TCP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flashphoner/blog/480006/"><p><img src="https://habrastorage.org/webt/pv/ay/09/pvay09ig__cufhrusi92uh55yd4.jpeg"></p><br><h2 id="publish-and-play">  Publica y juega </h2><br><p> Existen dos funciones principales de la operación WebRTC en el lado del servidor en el campo de la transmisión de video: publicación y reproducción.  En el caso de la publicación, la transmisión de video se captura desde la cámara web y se mueve desde el navegador al servidor.  En el caso de reproducción, la transmisión se mueve en la dirección opuesta, desde el servidor al navegador, se decodifica y reproduce en el elemento HTML5 <code>&lt;video&gt;</code> del navegador en la pantalla del dispositivo. </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/zn/59/bs/zn59bsyyymrdcllr6eco4ftss3o.png"></p><br><h2 id="udp-and-tcp">  UDP y TCP </h2><br><p>  El video puede moverse a través de dos protocolos de transporte: TCP o UDP.  En el caso de UDP, las retroalimentaciones NACK RTCP funcionan activamente, llevando la información sobre los paquetes perdidos, debido a lo cual es una tarea bastante simple detectar el deterioro del canal UDP, se reduce a contar el NACK (ACK negativo) para determinar La calidad.  Cuantas más retroalimentaciones NACK y PLI (Indicador de pérdida de imagen) haya, más pérdidas reales habrá y menor será la calidad del canal. </p><br><p><img src="https://habrastorage.org/webt/tl/ba/q1/tlbaq1d159jew-qmqd4q38oaehu.png"></p><br><h2 id="tcp-without-nack">  TCP sin NACK </h2><br><p>  En este artículo, nos centraremos más en el protocolo TCP.  Cuando WebRTC se utiliza a través de TCP, las retroalimentaciones <a href="https://flashphoner.com/what-is-webrtc-nack/">NACK</a> RTCP no se envían, e incluso si se envían, no reflejan la imagen real de las pérdidas, y no parece posible determinar la calidad del canal por las retroalimentaciones.  Como se conoce comúnmente, TCP es un protocolo de transporte con entrega garantizada.  Por esta razón, en caso de que la calidad del canal se deteriore, el resto de los paquetes que hay en la red se enviarán al nivel del protocolo de transporte.  Tarde o temprano se entregarán, pero no se generará un NACK para esas pérdidas porque, de hecho, no hubo pérdidas.  Como resultado, los paquetes llegarán a su destino con retraso.  Los paquetes retrasados ​​simplemente no se agruparán en cuadros de video y serán desechados por el desempaquetador, como resultado de lo cual el usuario verá una imagen como esta, llena de artefactos: </p><br><p><img src="https://habrastorage.org/webt/cn/8h/wl/cn8hwlk-msj9tjq6shwgya_wgqi.png"></p><br><p>  Los comentarios mostrarán que todo está bien, pero la imagen contendrá artefactos.  A continuación puede ver capturas de pantalla del tráfico de Wireshark que ilustran el comportamiento de la transmisión que se publica en canales TCP y UDP comprimidos, así como capturas de pantalla de las estadísticas de Google Chrome.  En las capturas de pantalla, puede ver que en el caso de TCP, la métrica NACK no crece a diferencia del UDP, a pesar de que el estado del canal es muy malo. </p><br><p>  TCP <br><img src="https://habrastorage.org/webt/ny/0w/gp/ny0wgpbc62mfx3yw7vli0inrnjg.png"></p><br><p>  UDP </p><br><p><img src="https://habrastorage.org/webt/db/na/ow/dbnaowmxhccemnwslj9j85vmc6c.png"><br><img src="https://habrastorage.org/webt/ae/xs/wg/aexswgs7isxyt05_nivxqog8fyo.png"></p><br><h2 id="why-stream-over-tcp-at-all-if-there-is-udp">  ¿Por qué transmitir a través de TCP si hay UDP? </h2><br><p>  Esta es una pregunta razonable para hacer.  La respuesta es, para empujar grandes resoluciones a través del canal.  Por ejemplo, en el caso de la transmisión de realidad virtual (VR), las resoluciones pueden comenzar desde 4k.  No parece posible empujar un flujo con tal resolución y con una tasa de bits de aproximadamente 10 Mbps en un canal regular sin pérdidas, el servidor escupe los paquetes UDP y comienzan a perderse en la red en grupos, luego el resto de ellos comienza a ser enviado, y así sucesivamente.  Grandes cantidades de paquetes de video descartados corrompen el video, y el resultado neto es que la calidad se vuelve muy pobre.  Esta es la razón por la cual WebRTC sobre TCP se utiliza para entregar el video en redes de propósito general y con altas resoluciones, como Full HD y 4k, para descartar pérdidas de paquetes de red a expensas de un ligero aumento en la latencia de la comunicación. </p><br><h2 id="rtt-for-determining-the-channel-quality">  RTT para determinar la calidad del canal </h2><br><p>  Por lo tanto, no hay una métrica que le diga con certeza que el canal está en muy mal estado.  Algunos desarrolladores intentan confiar en la métrica RTT, pero está lejos de ser capaz de funcionar en todos los navegadores, y no proporciona resultados precisos. </p><br><p>  A continuación puede encontrar una ilustración de la dependencia de la calidad del canal en RTT de acuerdo con el proyecto callstat </p><br><p><img src="https://habrastorage.org/webt/ux/am/pf/uxampfookpvevnacbv0fg2j8kj0.jpeg"></p><br><h2 id="remb-based-solution">  Solución basada en REMB </h2><br><p>  Hemos decidido adoptar un enfoque ligeramente diferente a este problema.  Existe el <a href="https://flashphoner.com/what-is-remb/">REMB</a> trabajando en el lado del <a href="http://flashphoner.com/">servidor</a> , que calcula la tasa de bits entrante para todas las secuencias entrantes, calcula su desviación de la media y sugiere que el navegador reduzca la tasa de bits en el caso de una dispersión significativa, enviando comandos REMB especializados a través del RTCP protocolo  El navegador recibe dicho mensaje y reduce la tasa de bits del codificador de video para los valores recomendados: así es como funciona la protección contra la sobrecarga del canal y la degradación del flujo entrante.  De esta manera, el mecanismo de cálculo de velocidad de bits ya se ha implementado en el lado del servidor.  El promedio y la determinación de la dispersión se han realizado a través del filtro Kalman.  Esto permite obtener la tasa de bits actual en cualquier momento con gran precisión y filtrar cualquier desviación significativa. </p><br><p><img src="https://habrastorage.org/webt/c3/yd/ga/c3ydgaktjtjo6luxkfmub6j58cq.png"></p><br><p>  El lector seguramente tendrá esta pregunta: "¿Cómo me ayudará a saber la tasa de bits que el servidor puede ver para la transmisión que ingresa?" Esto solo le permitirá comprender que hay video entrando en el servidor con una tasa de bits del valor de los cuales fue posible determinar.  Para evaluar la calidad del canal, se requerirá un componente más. </p><br><h2 id="the-outcoming-bitrate-and-why-it-is-important">  La tasa de bits próxima y por qué es importante </h2><br><p>  Las estadísticas para la transmisión del flujo de WebRTC muestran con qué tasa de bits sale el flujo de video del navegador.  Como dice una vieja broma, un administrador del sitio dice que al revisar su rifle de asalto, “De mi lado, las balas han salido volando.  Los problemas están de su lado ... ”La idea de verificar la calidad del canal implica comparar dos tasas de bits: 1) la tasa de bits enviada por el navegador, 2) la tasa de bits realmente recibida por el servidor. </p><br><p>  El administrador del sitio dispara las balas y calcula la velocidad a la que vuelan a su lado.  El servidor calcula la velocidad a la que se reciben en su lado.  Hay un participante más de este evento, TCP, este es un superhéroe que se encuentra en el medio entre el administrador y el servidor y puede detener las balas al azar.  Por ejemplo, puede detener 10 balas aleatorias de 100 durante 2 segundos y luego dejarlas volar nuevamente.  Esa es la matriz que vemos aquí. </p><br><p><img src="https://habrastorage.org/webt/e0/oo/j-/e0ooj-egdyzecr3bpmwndre0kxq.png"></p><br><p>  En el lado del navegador, tomamos la tasa de bits actual de las estadísticas de WebRTC, luego suavizamos el gráfico con el filtro de Kalman en la implementación de JavaScript y obtenemos una versión suavizada de la tasa de bits del navegador del cliente al final del proceso.  Ahora tenemos prácticamente todo lo que necesitamos: la tasa de bits del cliente nos dice cómo sale el tráfico del navegador, y la tasa de bits del servidor nos dice cómo el servidor ve ese tráfico y con qué tasa de bits se recibe.  Es obvio que si la tasa de bits del cliente sigue siendo alta y la tasa de bits del servidor comienza a reducirse en relación con la tasa de bits del cliente, significa que no todas las viñetas han "alcanzado el objetivo", y el servidor en realidad no puede ver una parte del tráfico que le fue enviado  Sobre esta base, podemos concluir que algo está mal con el canal y es hora de cambiar el color del indicador a rojo. </p><br><h2 id="and-theres-more">  Y hay mas </h2><br><p>  Los gráficos se correlacionan pero están ligeramente desplazados en el tiempo en relación entre sí.  Para una correlación completa, es necesario hacer coincidir los gráficos en el tiempo para comparar la tasa de bits del cliente y el servidor en el mismo punto de tiempo con los datos históricos.  La desincronización se ve aproximadamente así: </p><br><p><img src="https://habrastorage.org/webt/vk/fi/em/vkfiem1ddasv5rsag30hco5zkrw.png"></p><br><p>  Y así es como se ve un gráfico sincronizado en el tiempo. </p><br><p><img src="https://habrastorage.org/webt/8b/zj/a0/8bzja0l9fn3kxbrz_ueihmrh_k4.png"></p><br><h2 id="lets-test-it">  Probémoslo </h2><br><p>  Nos queda un poco por hacer, solo tenemos que probarlo.  Publiquemos una secuencia de video, ábrala y mire el gráfico de las tasas de bits publicadas: en el lado del navegador y en el lado del servidor.  Los gráficos demuestran prácticamente una combinación perfecta.  Y este es el nombre del indicador, PERFECTO. </p><br><p><img src="https://habrastorage.org/webt/mr/pn/ru/mrpnruxxsbuescnpgfxmscgmapa.png"></p><br><p>  Entonces, comencemos a corromper el canal.  Para hacerlo, podemos utilizar las siguientes herramientas gratuitas: <a href="https://github.com/WPO-Foundation/win-shaper">winShaper</a> para Windows o <a href="https://nshipster.com/network-link-conditioner/">Network Link Conditioner</a> para MacOS.  Permiten comprimir el canal al valor preestablecido.  Por ejemplo, si sabemos que un flujo de 640x480 puede alcanzar una velocidad de 1 Mbps, comprimámoslo a 300 kbs.  Al hacerlo, no debemos olvidar que estamos trabajando con TCP.  Verifiquemos el resultado de nuestra prueba: hay una correlación inversa en los gráficos y el indicador se desliza a MALO.  De hecho, el navegador continúa enviando datos e incluso está aumentando la tasa de bits al intentar empujar una nueva porción de tráfico en la red.  Estos datos se acumulan en la red en forma de retransmisiones y no llegan al servidor, como resultado, el servidor muestra una imagen inversa y dice que la tasa de bits que puede ver se ha reducido.  De hecho, es malo. </p><br><p><img src="https://habrastorage.org/webt/4b/ds/xd/4bdsxdc1w7oupjx_eivkx-yb2gy.png"></p><br><p>  Hemos realizado bastantes pruebas que muestran el correcto funcionamiento del <a href="https://docs.flashphoner.com/display/WCS52EN/Publisher%2Band%2Bplayer%2Bchannel%2Bquality%2Bcontrol">indicador</a> .  Como resultado de eso, tenemos una función que permite informar de manera confiable y rápida al usuario sobre cualquier problema con el canal, tanto para la publicación como para la reproducción de transmisiones (trabajando según el mismo principio).  Sí, todo este alboroto fue por esta lámpara verde y roja, PERFECT-BAD.  Pero la práctica muestra que este indicador es muy importante y su ausencia, junto con la falta de comprensión del estado actual, puede crear grandes problemas para un usuario común de un servicio de transmisión de video WebRTC. </p><br><h2 id="links">  Enlaces </h2><br><p>  <a href="http://flashphoner.com/">WCS 5.2</a> es un servidor de transmisión de medios para el desarrollo de aplicaciones web y móviles </p><br><p>  <a href="https://docs.flashphoner.com/display/WCS52EN/Publisher%2Band%2Bplayer%2Bchannel%2Bquality%2Bcontrol">Control de calidad del canal de editor y reproductor</a> </p><br><p>  <a href="https://flashphoner.com/what-is-remb/">REMB</a> : <a href="https://flashphoner.com/what-is-remb/">tasa de</a> bits máxima estimada del receptor utilizada para el control del ancho de banda <br>  <a href="https://flashphoner.com/what-is-webrtc-nack/">NACK</a> : acuse de recibo negativo utilizado para el control de pérdida de paquetes y retransmisiones </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480006/">https://habr.com/ru/post/480006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479992/index.html">Cómo enseñar a UITextView a destacarse maravillosamente</a></li>
<li><a href="../479996/index.html">Transistores de 2 nm: ¿corta o corta?</a></li>
<li><a href="../479998/index.html">Trucos turcos con gusanos, ratas ... y un profesional independiente</a></li>
<li><a href="../480000/index.html">Indicador de calidad del canal del servidor WebRTC sobre TCP</a></li>
<li><a href="../480002/index.html">Revise DevOpsDays Moscú: ideas de 6 informes</a></li>
<li><a href="../480008/index.html">Yuri Rogachev: "Vine a hacer el M-1, sin conocer la tecnología informática"</a></li>
<li><a href="../480010/index.html">Los 3 principales elementos HTML que olvidamos</a></li>
<li><a href="../480012/index.html">El formato Clang ralentiza el programa</a></li>
<li><a href="../480016/index.html">El 39% de las pymes rusas se enfrentan a ciberataques selectivos</a></li>
<li><a href="../480018/index.html">Desarrollo de aplicaciones móviles en Python. Biblioteca KivyMD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>