<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üåßÔ∏è üè† Eigener Mapper oder ein wenig √ºber ExpressionTrees üöµ üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üì≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir dar√ºber sprechen, wie Sie Ihren AutoMapper schreiben. Ja, ich w√ºrde Ihnen gerne davon erz√§hlen, aber ich kann nicht. Tatsache ist, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eigener Mapper oder ein wenig √ºber ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="Bild"><br><br>  Heute werden wir dar√ºber sprechen, wie Sie Ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoMapper</a> schreiben.  Ja, ich w√ºrde Ihnen gerne davon erz√§hlen, aber ich kann nicht.  Tatsache ist, dass solche L√∂sungen sehr umfangreich sind, eine lange Geschichte von Versuch und Irrtum haben und auch einen langen Weg zur Anwendung zur√ºckgelegt haben.  Ich kann nur ein Verst√§ndnis daf√ºr geben, wie dies funktioniert, und einen Ausgangspunkt f√ºr diejenigen geben, die den Arbeitsmechanismus der ‚ÄûMapper‚Äú verstehen m√∂chten.  Man k√∂nnte sogar sagen, dass wir unser Fahrrad schreiben werden. <br><a name="habracut"></a><br><h3>  Haftungsausschluss </h3><br>  Ich erinnere Sie noch einmal daran: Wir werden einen primitiven Mapper schreiben.  Wenn Sie sich pl√∂tzlich dazu entschlie√üen, es zu √§ndern und im Produkt zu verwenden, tun Sie dies nicht.  Nehmen Sie eine vorgefertigte L√∂sung, die den Stapel von Problemen in diesem Themenbereich <i>kennt</i> und <i>bereits wei√ü, wie</i> man sie l√∂st.  Es gibt mehrere mehr oder weniger wichtige Gr√ºnde, Ihren Bike Mapper zu schreiben und zu verwenden: <br><br><ul><li>  Ben√∂tigen Sie eine spezielle Anpassung. </li><li> Sie ben√∂tigen maximale Leistung unter Ihren Bedingungen und sind bereit, Kegel zu f√ºllen. </li><li>  Sie m√∂chten verstehen, wie Mapper funktioniert. </li><li>  Du radelst einfach gern. </li></ul><br><h3>  Wie hei√üt das Wort "Mapper"? </h3><br>  Dies ist das Subsystem, das daf√ºr verantwortlich ist, ein Objekt zu nehmen und es in ein anderes zu konvertieren (zu kopieren).  Eine typische Aufgabe besteht darin, ein DTO in ein Business-Layer-Objekt zu konvertieren.  Der primitivste Mapper "durchl√§uft" die Eigenschaften der Datenquelle und vergleicht sie mit den Eigenschaften des Datentyps, der ausgegeben wird.  Nach dem Abgleich werden die Werte aus der Quelle extrahiert und in das Objekt geschrieben, was das Ergebnis der Konvertierung ist.  Irgendwo auf dem Weg wird es h√∂chstwahrscheinlich noch notwendig sein, genau dieses ‚ÄûErgebnis‚Äú zu erzielen. <br><br>  F√ºr den Verbraucher ist Mapper ein Dienst, der die folgende Schnittstelle bietet: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Ich betone: Dies ist die primitivste Schnittstelle, die aus meiner Sicht zur Erkl√§rung geeignet ist.  In der Realit√§t handelt es sich h√∂chstwahrscheinlich um einen spezifischeren Mapper (IMapper &lt;TIn, TOut&gt;) oder um eine allgemeinere Fassade (IMapper), die selbst einen bestimmten Mapper f√ºr die angegebenen Arten von Eingabe-Ausgabe-Objekten ausw√§hlt. <br><br><h3>  Naive Umsetzung </h3><br>  Hinweis: Selbst die naive Implementierung von Mapper erfordert Grundkenntnisse in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflection</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressionTrees</a> .  Wenn Sie den Links nicht gefolgt sind oder nichts √ºber diese Technologien geh√∂rt haben, lesen Sie sie.  Ich verspreche, dass die Welt niemals dieselbe sein wird. <br><br>  Wir schreiben jedoch Ihren eigenen Mapper.  Lassen Sie uns zun√§chst alle Eigenschaften ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo</a> ) des Datentyps abrufen, der <b>ausgegeben</b> werden soll (ich werde ihn <b>sp√§ter TOut</b> nennen).  Dies ist ganz einfach: Wir kennen den Typ, da wir die Implementierung einer generischen Klasse schreiben, die mit dem TOut-Typ parametrisiert ist.  Als N√§chstes erhalten wir mithilfe einer Instanz der Type-Klasse alle ihre Eigenschaften. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Beim Abrufen von Eigenschaften lasse ich die Funktionen weg.  Zum Beispiel k√∂nnen einige von ihnen ohne Setter-Funktion sein, einige k√∂nnen als vom Attribut ignoriert markiert sein, einige k√∂nnen mit speziellem Zugriff sein.  Wir erw√§gen die einfachste Option. <br><br>  Wir gehen weiter.  Es w√§re sch√∂n, eine Instanz vom Typ TOut erstellen zu k√∂nnen, dh genau das Objekt, in das wir das eingehende Objekt "abbilden".  In C # gibt es verschiedene M√∂glichkeiten, dies zu tun.  Zum Beispiel k√∂nnen wir dies tun: System.Activator.CreateInstance ().  Oder auch nur neues TOut (), aber daf√ºr m√ºssen Sie eine Einschr√§nkung f√ºr TOut erstellen, die Sie in der verallgemeinerten Oberfl√§che nicht tun m√∂chten.  Wir wissen beide etwas √ºber ExpressionTrees, was bedeutet, dass wir es so machen k√∂nnen: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Warum so?  Da wir wissen, dass eine Instanz der Type-Klasse Informationen dar√ºber liefern kann, √ºber welche Konstruktoren sie verf√ºgt, ist dies sehr praktisch f√ºr F√§lle, in denen wir unseren Mapper so entwickeln, dass alle Daten an den Konstruktor √ºbergeben werden.  Au√üerdem haben wir etwas mehr √ºber ExpressionTrees gelernt, n√§mlich, dass Plaque Code erstellen und kompilieren kann, der dann wiederverwendet werden kann.  In diesem Fall handelt es sich um eine Funktion, die tats√§chlich wie () =&gt; new TOut () aussieht. <br><br>  Jetzt m√ºssen Sie die Haupt-Mapper-Methode schreiben, die die Werte kopiert.  Wir gehen den einfachsten Weg: Wir gehen die Eigenschaften des Objekts durch, das am Eingang zu uns gekommen ist, und suchen unter den Eigenschaften des ausgehenden Objekts nach den gleichnamigen Eigenschaften.  Wenn gefunden - kopieren, wenn nicht - weitermachen. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Damit haben wir die <a href="">BasicMapper-</a> Klasse vollst√§ndig gebildet.  Hier k√∂nnen Sie sich mit seinen Tests vertraut machen.  Bitte beachten Sie, dass die Quelle entweder ein Objekt eines bestimmten Typs oder ein anonymes Objekt sein kann. <br><br><h3>  Leistung und Boxen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Reflexion ist</a> gro√üartig, aber langsam.  Dar√ºber hinaus erh√∂ht seine h√§ufige Verwendung den Speicherverkehr, was bedeutet, dass der GC geladen wird, was bedeutet, dass die Anwendung noch mehr verlangsamt wird.  Zum Beispiel haben wir nur die Methoden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo.SetValue</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo.GetValue</a> verwendet.  Die GetValue-Methode gibt ein Objekt zur√ºck, in das ein bestimmter Wert eingeschlossen ist (Boxing).  Dies bedeutet, dass wir eine Zuteilung von Grund auf erhalten haben. <br><br>  Mapper befinden sich normalerweise dort, wo Sie ein Objekt in ein anderes verwandeln m√ºssen ... Nein, nicht eines, sondern viele Objekte.  Zum Beispiel, wenn wir etwas aus der Datenbank nehmen.  An dieser Stelle m√∂chte ich eine normale Leistung sehen und bei einer elementaren Operation nicht das Ged√§chtnis verlieren. <br><br>  Was k√∂nnen wir tun?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressionTrees</a> wird uns wieder helfen.  Tatsache ist, dass Sie mit .NET Code "on the fly" erstellen und kompilieren k√∂nnen: Wir beschreiben ihn in der Objektdarstellung, sagen, was und wo wir ihn verwenden werden ... und kompilieren ihn.  Fast keine Magie. <br><br><h3>  Kompilierter Mapper </h3><br>  Tats√§chlich ist alles relativ einfach: Wir haben Expression.New (ConstructorInfo) bereits neu gemacht.  Sie haben wahrscheinlich bemerkt, dass die statische New-Methode genauso aufgerufen wird wie der Operator.  Tatsache ist, dass fast die gesamte C # -Syntax in Form statischer Methoden der Expression-Klasse wiedergegeben wird.  Wenn etwas fehlt, bedeutet dies, dass Sie nach dem sogenannten suchen  "Syntaktischer Zucker." <br><br>  Hier sind einige Operationen, die wir in unserem Mapper verwenden werden: <br><br><ul><li>  Variablendeklaration - Expression.Variable (Typ, Zeichenfolge).  Das Type-Argument gibt an, welcher Variablentyp erstellt wird, und string ist der Name der Variablen. </li><li>  Zuweisung - Expression.Assign (Ausdruck, Ausdruck).  Das erste Argument ist das, was wir zuweisen, und das zweite Argument ist das, was wir zuweisen. </li><li>  Der Zugriff auf die Eigenschaft eines Objekts erfolgt √ºber Expression.Property (Expression, PropertyInfo).  Expression ist der Eigent√ºmer der Eigenschaft, und PropertyInfo ist die Objektdarstellung der durch Reflection erhaltenen Eigenschaft. </li></ul><br>  Mit diesem Wissen k√∂nnen wir Variablen erstellen, auf Eigenschaften von Objekten zugreifen und Eigenschaften von Objekten Werte zuweisen.  H√∂chstwahrscheinlich verstehen wir auch, dass ExpressionTree in einen Delegaten der Form <b>Func &lt;Objekt, TOut&gt; kompiliert werden muss</b> .  Der Plan lautet wie folgt: Wir erhalten eine Variable, die die Eingabedaten enth√§lt, erstellen eine Instanz vom Typ TOut und erstellen Ausdr√ºcke, die eine Eigenschaft einer anderen zuweisen. <br><br>  Leider ist der Code nicht sehr kompakt, daher schlage ich vor, dass Sie sich sofort die Implementierung von <a href="">CompiledMapper</a> ansehen.  Ich habe hier nur wichtige Punkte gebracht. <br><br>  Zun√§chst erstellen wir eine Objektdarstellung des Parameters unserer Funktion.  Da ein Objekt als Eingabe verwendet wird, ist das Objekt ein Parameter. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  Als N√§chstes erstellen wir zwei Variablen und eine Ausdrucksliste, in die wir nacheinander Zuweisungsausdr√ºcke einf√ºgen.  Die Reihenfolge ist wichtig, da die Befehle so ausgef√ºhrt werden, wenn wir die kompilierte Methode aufrufen.  Beispielsweise k√∂nnen wir einer Variablen, die noch nicht deklariert wurde, keinen Wert zuweisen. <br><br>  Ebenso wie bei einer naiven Implementierung gehen wir die Liste der Typeneigenschaften durch und versuchen, sie nach Namen abzugleichen.  Anstatt jedoch sofort Werte zuzuweisen, erstellen wir Ausdr√ºcke zum Extrahieren von Werten und zum Zuweisen von Werten f√ºr jede zugeordnete Eigenschaft. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Ein wichtiger Punkt: Nachdem wir alle Zuweisungsoperationen erstellt haben, m√ºssen wir das Ergebnis von der Funktion zur√ºckgeben.  Zu diesem Zweck sollte der letzte Ausdruck in der Liste Ausdruck sein, der die Instanz der von uns erstellten Klasse enth√§lt.  Ich habe einen Kommentar neben dieser Zeile hinterlassen.  Warum sieht das Verhalten, das dem Schl√ºsselwort return in ExpressionTree entspricht, so aus?  Ich f√ºrchte, dies ist ein separates Thema.  Jetzt schlage ich vor, es ist leicht zu merken. <br><br>  Nun, ganz am Ende m√ºssen wir alle Ausdr√ºcke kompilieren, die wir erstellt haben.  Was interessiert uns hier?  Die Body-Variable enth√§lt den "Body" der Funktion.  "Normale Funktionen" haben einen K√∂rper, oder?  Nun, die wir in geschweiften Klammern einschlie√üen.  Expression.Block ist genau das.  Da geschweifte Klammern ebenfalls ein Bereich sind, m√ºssen wir dort die Variablen √ºbergeben, die dort verwendet werden - in unserem Fall sourceInstance und outInstance. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  Am Ausgang erhalten wir Func &lt;Objekt, TOut&gt;, d.h.  Eine Funktion, die Daten von einem Objekt in ein anderes konvertieren kann.  Warum solche Schwierigkeiten, fragst du?  Ich erinnere Sie daran, dass wir erstens beim Kopieren von ValueType-Werten das Boxen vermeiden wollten und zweitens die Methoden PropertyInfo.GetValue und PropertyInfo.SetValue aufgeben wollten, da sie etwas langsam sind. <br><br>  Warum nicht boxen?  Da der kompilierte ExpressionTree eine echte IL ist und zur Laufzeit wie (fast) wie Ihr Code aussieht.  Warum ist der "kompilierte Mapper" schneller?  Nochmals: weil es einfach nur IL ist.  √úbrigens k√∂nnen wir die Geschwindigkeit mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet-</a> Bibliothek leicht best√§tigen, und der Benchmark selbst kann hier angezeigt <a href="">werden</a> . <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  AutoMapper </td><td>  1.291,6 uns </td><td>  3.3173 uns </td><td>  3.1030 uns </td><td>  1,00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11.987,0 uns </td><td>  33.8389 uns </td><td>  28.2570 uns </td><td>  9.28 </td><td>  3437,5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341,3 uns </td><td>  2.8230 uns </td><td>  2.6407 uns </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  In der Ratio-Spalte zeigte "CompiledMapper" (CompiledMapper) ein sehr gutes Ergebnis, selbst im Vergleich zu AutoMapper (es ist die Basislinie, d. H. 1).  Freuen wir uns jedoch nicht: AutoMapper verf√ºgt im Vergleich zu unserem Fahrrad √ºber deutlich gr√∂√üere Funktionen.  Mit dieser Platte wollte ich nur zeigen, dass ExpressionTrees viel schneller ist als der ‚Äûklassische Reflection-Ansatz‚Äú. <br><br><h3>  Zusammenfassung </h3><br>  Ich hoffe, ich konnte zeigen, dass das Schreiben Ihres Mappers recht einfach ist.  Reflection und ExpressionTrees sind sehr leistungsstarke Tools, mit denen Entwickler viele verschiedene Aufgaben l√∂sen k√∂nnen.  Abh√§ngigkeitsinjektion, Serialisierung / Deserialisierung, CRUD-Repositorys, Erstellen von SQL-Abfragen, Verwenden anderer Sprachen als Skripts f√ºr .NET-Anwendungen - all dies erfolgt mithilfe von Reflection, Reflection.Emit und ExpressionTrees. <br><br>  Was ist mit Mapper?  Mapper ist ein gro√üartiges Beispiel, wo Sie all dies lernen k√∂nnen. <br><br>  PS: Wenn Sie weitere ExpressionTrees m√∂chten, empfehlen wir Ihnen zu lesen, wie Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihren JSON-Konverter</a> mithilfe dieser Technologie erstellen k√∂nnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463961/">https://habr.com/ru/post/de463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463943/index.html">Die Missgeschicke des schwarzen Einhorns</a></li>
<li><a href="../de463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../de463953/index.html">Implementieren des Befehlsentwurfsmusters in Unity</a></li>
<li><a href="../de463955/index.html">Wie entwickelt man ein Konzept zur √Ñnderung der IP-Plattform? Gebrauchsanweisung</a></li>
<li><a href="../de463957/index.html">So stellen Sie eine einfach verkn√ºpfte Interviewliste bereit</a></li>
<li><a href="../de463963/index.html">Gesichtserkennung auf einer Baustelle</a></li>
<li><a href="../de463965/index.html">Gesetzte Anwendung in LaTeX</a></li>
<li><a href="../de463969/index.html">Telegramm Familienbudget</a></li>
<li><a href="../de463971/index.html">Pentester Notes: Jagdf√§lle</a></li>
<li><a href="../de463975/index.html">Moderne Umgebung f√ºr reaktive native Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>