<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏾 🌧️ 🏠 Eigener Mapper oder ein wenig über ExpressionTrees 🚵 🏴󠁧󠁢󠁳󠁣󠁴󠁿 📭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir darüber sprechen, wie Sie Ihren AutoMapper schreiben. Ja, ich würde Ihnen gerne davon erzählen, aber ich kann nicht. Tatsache ist, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eigener Mapper oder ein wenig über ExpressionTrees</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463961/"><img src="https://habrastorage.org/webt/ry/x_/sj/ryx_sj0phsfsrlfz1tcxy2_8izs.jpeg" alt="Bild"><br><br>  Heute werden wir darüber sprechen, wie Sie Ihren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AutoMapper</a> schreiben.  Ja, ich würde Ihnen gerne davon erzählen, aber ich kann nicht.  Tatsache ist, dass solche Lösungen sehr umfangreich sind, eine lange Geschichte von Versuch und Irrtum haben und auch einen langen Weg zur Anwendung zurückgelegt haben.  Ich kann nur ein Verständnis dafür geben, wie dies funktioniert, und einen Ausgangspunkt für diejenigen geben, die den Arbeitsmechanismus der „Mapper“ verstehen möchten.  Man könnte sogar sagen, dass wir unser Fahrrad schreiben werden. <br><a name="habracut"></a><br><h3>  Haftungsausschluss </h3><br>  Ich erinnere Sie noch einmal daran: Wir werden einen primitiven Mapper schreiben.  Wenn Sie sich plötzlich dazu entschließen, es zu ändern und im Produkt zu verwenden, tun Sie dies nicht.  Nehmen Sie eine vorgefertigte Lösung, die den Stapel von Problemen in diesem Themenbereich <i>kennt</i> und <i>bereits weiß, wie</i> man sie löst.  Es gibt mehrere mehr oder weniger wichtige Gründe, Ihren Bike Mapper zu schreiben und zu verwenden: <br><br><ul><li>  Benötigen Sie eine spezielle Anpassung. </li><li> Sie benötigen maximale Leistung unter Ihren Bedingungen und sind bereit, Kegel zu füllen. </li><li>  Sie möchten verstehen, wie Mapper funktioniert. </li><li>  Du radelst einfach gern. </li></ul><br><h3>  Wie heißt das Wort "Mapper"? </h3><br>  Dies ist das Subsystem, das dafür verantwortlich ist, ein Objekt zu nehmen und es in ein anderes zu konvertieren (zu kopieren).  Eine typische Aufgabe besteht darin, ein DTO in ein Business-Layer-Objekt zu konvertieren.  Der primitivste Mapper "durchläuft" die Eigenschaften der Datenquelle und vergleicht sie mit den Eigenschaften des Datentyps, der ausgegeben wird.  Nach dem Abgleich werden die Werte aus der Quelle extrahiert und in das Objekt geschrieben, was das Ergebnis der Konvertierung ist.  Irgendwo auf dem Weg wird es höchstwahrscheinlich noch notwendig sein, genau dieses „Ergebnis“ zu erzielen. <br><br>  Für den Verbraucher ist Mapper ein Dienst, der die folgende Schnittstelle bietet: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IMapper</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">TOut</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TOut </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> source</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Ich betone: Dies ist die primitivste Schnittstelle, die aus meiner Sicht zur Erklärung geeignet ist.  In der Realität handelt es sich höchstwahrscheinlich um einen spezifischeren Mapper (IMapper &lt;TIn, TOut&gt;) oder um eine allgemeinere Fassade (IMapper), die selbst einen bestimmten Mapper für die angegebenen Arten von Eingabe-Ausgabe-Objekten auswählt. <br><br><h3>  Naive Umsetzung </h3><br>  Hinweis: Selbst die naive Implementierung von Mapper erfordert Grundkenntnisse in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reflection</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressionTrees</a> .  Wenn Sie den Links nicht gefolgt sind oder nichts über diese Technologien gehört haben, lesen Sie sie.  Ich verspreche, dass die Welt niemals dieselbe sein wird. <br><br>  Wir schreiben jedoch Ihren eigenen Mapper.  Lassen Sie uns zunächst alle Eigenschaften ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo</a> ) des Datentyps abrufen, der <b>ausgegeben</b> werden soll (ich werde ihn <b>später TOut</b> nennen).  Dies ist ganz einfach: Wir kennen den Typ, da wir die Implementierung einer generischen Klasse schreiben, die mit dem TOut-Typ parametrisiert ist.  Als Nächstes erhalten wir mithilfe einer Instanz der Type-Klasse alle ihre Eigenschaften. <br><br><pre> <code class="cs hljs">Type outType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TOut); PropertyInfo[] outProperties = outType.GetProperties();</code> </pre><br>  Beim Abrufen von Eigenschaften lasse ich die Funktionen weg.  Zum Beispiel können einige von ihnen ohne Setter-Funktion sein, einige können als vom Attribut ignoriert markiert sein, einige können mit speziellem Zugriff sein.  Wir erwägen die einfachste Option. <br><br>  Wir gehen weiter.  Es wäre schön, eine Instanz vom Typ TOut erstellen zu können, dh genau das Objekt, in das wir das eingehende Objekt "abbilden".  In C # gibt es verschiedene Möglichkeiten, dies zu tun.  Zum Beispiel können wir dies tun: System.Activator.CreateInstance ().  Oder auch nur neues TOut (), aber dafür müssen Sie eine Einschränkung für TOut erstellen, die Sie in der verallgemeinerten Oberfläche nicht tun möchten.  Wir wissen beide etwas über ExpressionTrees, was bedeutet, dass wir es so machen können: <br><br><pre> <code class="cs hljs">ConstructorInfo outConstructor = outType.GetConstructor(Array.Empty&lt;Type&gt;()); Func&lt;TOut&gt; activator = outConstructor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"Default constructor for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{outType.Name}</span></span></span><span class="hljs-string"> not found"</span></span>) : Expression.Lambda&lt;Func&lt;TOut&gt;&gt;(Expression.New(outConstructor)).Compile();</code> </pre><br>  Warum so?  Da wir wissen, dass eine Instanz der Type-Klasse Informationen darüber liefern kann, über welche Konstruktoren sie verfügt, ist dies sehr praktisch für Fälle, in denen wir unseren Mapper so entwickeln, dass alle Daten an den Konstruktor übergeben werden.  Außerdem haben wir etwas mehr über ExpressionTrees gelernt, nämlich, dass Plaque Code erstellen und kompilieren kann, der dann wiederverwendet werden kann.  In diesem Fall handelt es sich um eine Funktion, die tatsächlich wie () =&gt; new TOut () aussieht. <br><br>  Jetzt müssen Sie die Haupt-Mapper-Methode schreiben, die die Werte kopiert.  Wir gehen den einfachsten Weg: Wir gehen die Eigenschaften des Objekts durch, das am Eingang zu uns gekommen ist, und suchen unter den Eigenschaften des ausgehenden Objekts nach den gleichnamigen Eigenschaften.  Wenn gefunden - kopieren, wenn nicht - weitermachen. <br><br><pre> <code class="cs hljs">TOut outInstance = _activator(); PropertyInfo[] sourceProperties = source.GetType().GetProperties(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sourceProperties.Length; i++) { PropertyInfo sourceProperty = sourceProperties[i]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName = sourceProperty.Name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_outProperties.TryGetValue(propertyName, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> PropertyInfo outProperty)) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sourceValue = sourceProperty.GetValue(source); outProperty.SetValue(outInstance, sourceValue); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outInstance;</code> </pre><br>  Damit haben wir die <a href="">BasicMapper-</a> Klasse vollständig gebildet.  Hier können Sie sich mit seinen Tests vertraut machen.  Bitte beachten Sie, dass die Quelle entweder ein Objekt eines bestimmten Typs oder ein anonymes Objekt sein kann. <br><br><h3>  Leistung und Boxen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Reflexion ist</a> großartig, aber langsam.  Darüber hinaus erhöht seine häufige Verwendung den Speicherverkehr, was bedeutet, dass der GC geladen wird, was bedeutet, dass die Anwendung noch mehr verlangsamt wird.  Zum Beispiel haben wir nur die Methoden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo.SetValue</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PropertyInfo.GetValue</a> verwendet.  Die GetValue-Methode gibt ein Objekt zurück, in das ein bestimmter Wert eingeschlossen ist (Boxing).  Dies bedeutet, dass wir eine Zuteilung von Grund auf erhalten haben. <br><br>  Mapper befinden sich normalerweise dort, wo Sie ein Objekt in ein anderes verwandeln müssen ... Nein, nicht eines, sondern viele Objekte.  Zum Beispiel, wenn wir etwas aus der Datenbank nehmen.  An dieser Stelle möchte ich eine normale Leistung sehen und bei einer elementaren Operation nicht das Gedächtnis verlieren. <br><br>  Was können wir tun?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ExpressionTrees</a> wird uns wieder helfen.  Tatsache ist, dass Sie mit .NET Code "on the fly" erstellen und kompilieren können: Wir beschreiben ihn in der Objektdarstellung, sagen, was und wo wir ihn verwenden werden ... und kompilieren ihn.  Fast keine Magie. <br><br><h3>  Kompilierter Mapper </h3><br>  Tatsächlich ist alles relativ einfach: Wir haben Expression.New (ConstructorInfo) bereits neu gemacht.  Sie haben wahrscheinlich bemerkt, dass die statische New-Methode genauso aufgerufen wird wie der Operator.  Tatsache ist, dass fast die gesamte C # -Syntax in Form statischer Methoden der Expression-Klasse wiedergegeben wird.  Wenn etwas fehlt, bedeutet dies, dass Sie nach dem sogenannten suchen  "Syntaktischer Zucker." <br><br>  Hier sind einige Operationen, die wir in unserem Mapper verwenden werden: <br><br><ul><li>  Variablendeklaration - Expression.Variable (Typ, Zeichenfolge).  Das Type-Argument gibt an, welcher Variablentyp erstellt wird, und string ist der Name der Variablen. </li><li>  Zuweisung - Expression.Assign (Ausdruck, Ausdruck).  Das erste Argument ist das, was wir zuweisen, und das zweite Argument ist das, was wir zuweisen. </li><li>  Der Zugriff auf die Eigenschaft eines Objekts erfolgt über Expression.Property (Expression, PropertyInfo).  Expression ist der Eigentümer der Eigenschaft, und PropertyInfo ist die Objektdarstellung der durch Reflection erhaltenen Eigenschaft. </li></ul><br>  Mit diesem Wissen können wir Variablen erstellen, auf Eigenschaften von Objekten zugreifen und Eigenschaften von Objekten Werte zuweisen.  Höchstwahrscheinlich verstehen wir auch, dass ExpressionTree in einen Delegaten der Form <b>Func &lt;Objekt, TOut&gt; kompiliert werden muss</b> .  Der Plan lautet wie folgt: Wir erhalten eine Variable, die die Eingabedaten enthält, erstellen eine Instanz vom Typ TOut und erstellen Ausdrücke, die eine Eigenschaft einer anderen zuweisen. <br><br>  Leider ist der Code nicht sehr kompakt, daher schlage ich vor, dass Sie sich sofort die Implementierung von <a href="">CompiledMapper</a> ansehen.  Ich habe hier nur wichtige Punkte gebracht. <br><br>  Zunächst erstellen wir eine Objektdarstellung des Parameters unserer Funktion.  Da ein Objekt als Eingabe verwendet wird, ist das Objekt ein Parameter. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameter = Expression.Parameter(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>), <span class="hljs-string"><span class="hljs-string">"source"</span></span>);</code> </pre><br>  Als Nächstes erstellen wir zwei Variablen und eine Ausdrucksliste, in die wir nacheinander Zuweisungsausdrücke einfügen.  Die Reihenfolge ist wichtig, da die Befehle so ausgeführt werden, wenn wir die kompilierte Methode aufrufen.  Beispielsweise können wir einer Variablen, die noch nicht deklariert wurde, keinen Wert zuweisen. <br><br>  Ebenso wie bei einer naiven Implementierung gehen wir die Liste der Typeneigenschaften durch und versuchen, sie nach Namen abzugleichen.  Anstatt jedoch sofort Werte zuzuweisen, erstellen wir Ausdrücke zum Extrahieren von Werten und zum Zuweisen von Werten für jede zugeordnete Eigenschaft. <br><br><pre> <code class="cs hljs">Expression sourceValue = Expression.Property(sourceInstance, sourceProperty); Expression outValue = Expression.Property(outInstance, outProperty); expressions.Add(Expression.Assign(outValue, sourceValue));</code> </pre><br>  Ein wichtiger Punkt: Nachdem wir alle Zuweisungsoperationen erstellt haben, müssen wir das Ergebnis von der Funktion zurückgeben.  Zu diesem Zweck sollte der letzte Ausdruck in der Liste Ausdruck sein, der die Instanz der von uns erstellten Klasse enthält.  Ich habe einen Kommentar neben dieser Zeile hinterlassen.  Warum sieht das Verhalten, das dem Schlüsselwort return in ExpressionTree entspricht, so aus?  Ich fürchte, dies ist ein separates Thema.  Jetzt schlage ich vor, es ist leicht zu merken. <br><br>  Nun, ganz am Ende müssen wir alle Ausdrücke kompilieren, die wir erstellt haben.  Was interessiert uns hier?  Die Body-Variable enthält den "Body" der Funktion.  "Normale Funktionen" haben einen Körper, oder?  Nun, die wir in geschweiften Klammern einschließen.  Expression.Block ist genau das.  Da geschweifte Klammern ebenfalls ein Bereich sind, müssen wir dort die Variablen übergeben, die dort verwendet werden - in unserem Fall sourceInstance und outInstance. <br><br><pre> <code class="cpp hljs">var body = Expression.Block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {sourceInstance, outInstance}, expressions); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Expression.Lambda&lt;Func&lt;object, TOut&gt;&gt;(body, parameter).Compile();</code> </pre><br>  Am Ausgang erhalten wir Func &lt;Objekt, TOut&gt;, d.h.  Eine Funktion, die Daten von einem Objekt in ein anderes konvertieren kann.  Warum solche Schwierigkeiten, fragst du?  Ich erinnere Sie daran, dass wir erstens beim Kopieren von ValueType-Werten das Boxen vermeiden wollten und zweitens die Methoden PropertyInfo.GetValue und PropertyInfo.SetValue aufgeben wollten, da sie etwas langsam sind. <br><br>  Warum nicht boxen?  Da der kompilierte ExpressionTree eine echte IL ist und zur Laufzeit wie (fast) wie Ihr Code aussieht.  Warum ist der "kompilierte Mapper" schneller?  Nochmals: weil es einfach nur IL ist.  Übrigens können wir die Geschwindigkeit mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BenchmarkDotNet-</a> Bibliothek leicht bestätigen, und der Benchmark selbst kann hier angezeigt <a href="">werden</a> . <br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verhältnis </th><th>  Zugewiesen </th></tr></thead><tbody><tr><td>  AutoMapper </td><td>  1.291,6 uns </td><td>  3.3173 uns </td><td>  3.1030 uns </td><td>  1,00 </td><td>  312,5 KB </td></tr><tr><td>  Velo_BasicMapper </td><td>  11.987,0 uns </td><td>  33.8389 uns </td><td>  28.2570 uns </td><td>  9.28 </td><td>  3437,5 KB </td></tr><tr><td>  Velo_CompiledMapper </td><td>  341,3 uns </td><td>  2.8230 uns </td><td>  2.6407 uns </td><td>  0,26 </td><td>  312,5 KB </td></tr></tbody></table></div><br>  In der Ratio-Spalte zeigte "CompiledMapper" (CompiledMapper) ein sehr gutes Ergebnis, selbst im Vergleich zu AutoMapper (es ist die Basislinie, d. H. 1).  Freuen wir uns jedoch nicht: AutoMapper verfügt im Vergleich zu unserem Fahrrad über deutlich größere Funktionen.  Mit dieser Platte wollte ich nur zeigen, dass ExpressionTrees viel schneller ist als der „klassische Reflection-Ansatz“. <br><br><h3>  Zusammenfassung </h3><br>  Ich hoffe, ich konnte zeigen, dass das Schreiben Ihres Mappers recht einfach ist.  Reflection und ExpressionTrees sind sehr leistungsstarke Tools, mit denen Entwickler viele verschiedene Aufgaben lösen können.  Abhängigkeitsinjektion, Serialisierung / Deserialisierung, CRUD-Repositorys, Erstellen von SQL-Abfragen, Verwenden anderer Sprachen als Skripts für .NET-Anwendungen - all dies erfolgt mithilfe von Reflection, Reflection.Emit und ExpressionTrees. <br><br>  Was ist mit Mapper?  Mapper ist ein großartiges Beispiel, wo Sie all dies lernen können. <br><br>  PS: Wenn Sie weitere ExpressionTrees möchten, empfehlen wir Ihnen zu lesen, wie Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ihren JSON-Konverter</a> mithilfe dieser Technologie erstellen können. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463961/">https://habr.com/ru/post/de463961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463943/index.html">Die Missgeschicke des schwarzen Einhorns</a></li>
<li><a href="../de463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../de463953/index.html">Implementieren des Befehlsentwurfsmusters in Unity</a></li>
<li><a href="../de463955/index.html">Wie entwickelt man ein Konzept zur Änderung der IP-Plattform? Gebrauchsanweisung</a></li>
<li><a href="../de463957/index.html">So stellen Sie eine einfach verknüpfte Interviewliste bereit</a></li>
<li><a href="../de463963/index.html">Gesichtserkennung auf einer Baustelle</a></li>
<li><a href="../de463965/index.html">Gesetzte Anwendung in LaTeX</a></li>
<li><a href="../de463969/index.html">Telegramm Familienbudget</a></li>
<li><a href="../de463971/index.html">Pentester Notes: Jagdfälle</a></li>
<li><a href="../de463975/index.html">Moderne Umgebung für reaktive native Anwendungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>