<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêÄ üöß üëáüèº WBOIT di OpenGL: transparansi tanpa pengurutan üìß üôãüèº üë©üèª‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kita akan berbicara tentang "Transparansi tertimbang urutan-independen-independen" (selanjutnya disebut WBOIT) - teknik yang dijelaskan dalam JCGT pad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WBOIT di OpenGL: transparansi tanpa pengurutan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457284/">  Kita akan berbicara tentang "Transparansi tertimbang urutan-independen-independen" (selanjutnya disebut WBOIT) - teknik yang dijelaskan dalam JCGT pada 2013 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ). <br><a name="habracut"></a><br>  Ketika beberapa objek transparan muncul di layar, warna pixel tergantung pada mana yang lebih dekat dengan pengamat.  Berikut ini adalah formula pencampuran warna yang terkenal untuk kasus ini: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br>  Urutan pengaturan fragmen penting untuknya: warna fragmen dekat dan opacitynya dilambangkan sebagai C <sub>dekat</sub> dan <i>Œ±</i> , dan warna yang dihasilkan dari semua fragmen yang terletak di belakangnya dilambangkan sebagai C <sub>jauh</sub> .  Opacity adalah properti yang mengambil nilai dari 0 hingga 1, di mana 0 berarti objek sangat transparan sehingga tidak terlihat, dan 1 - sangat buram sehingga tidak ada yang terlihat di <i>belakangnya</i> . <br><br>  Untuk menggunakan rumus ini, Anda harus terlebih dahulu mengurutkan fragmen berdasarkan kedalaman.  Bayangkan betapa sakit kepala ini melibatkan!  Secara umum, penyortiran harus dilakukan di setiap frame.  Jika Anda menyortir objek, maka beberapa objek dengan bentuk kompleks harus dipotong-potong dan disortir berdasarkan kedalaman bagian yang dipotong (khususnya, untuk permukaan berpotongan, ini pasti perlu dilakukan).  Jika Anda menyortir fragmen, maka penyortiran akan terjadi di shader.  Pendekatan ini disebut "Transparansi bebas pesanan" (OIT), dan menggunakan daftar tertaut yang disimpan dalam memori kartu video.  Untuk memperkirakan berapa banyak memori yang harus dialokasikan untuk daftar ini hampir tidak realistis.  Dan jika tidak ada cukup memori, artefak akan muncul di layar. <br><br>  Beruntung bagi mereka yang dapat mengontrol berapa banyak objek tembus ditempatkan di atas panggung, dan di mana mereka relatif satu sama lain.  Tetapi jika Anda melakukan CAD, maka Anda akan memiliki objek transparan sebanyak yang diinginkan pengguna, dan mereka akan ditempatkan secara acak. <br><br>  Sekarang Anda memahami keinginan beberapa orang untuk menyederhanakan hidup mereka dan menghasilkan formula untuk memadukan warna yang tidak memerlukan penyortiran.  Formula seperti itu ada di artikel yang saya sebutkan di awal.  Bahkan ada beberapa formula di sana, tetapi yang terbaik menurut penulis (dan menurut saya juga) adalah ini: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  Dalam tangkapan layar adalah kelompok segitiga tembus pandang yang terletak di empat lapisan secara mendalam.  Di sebelah kiri, mereka dirender menggunakan teknik WBOIT.  Di sebelah kanan adalah gambar yang diperoleh dengan menggunakan rumus (1), campuran warna klasik, dengan mempertimbangkan urutan susunan fragmen.  Selanjutnya saya akan menyebutnya CODB (pencampuran tergantung pesanan Klasik). <br><br>  Sebelum kita mulai membuat objek transparan, kita harus membuat semua yang buram.  Setelah itu, objek transparan dirender dengan uji kedalaman, tetapi tanpa menulis ke buffer kedalaman (ini dilakukan seperti ini: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ).  Artinya, inilah yang terjadi pada suatu titik dengan beberapa koordinat layar (x, y): fragmen transparan yang lebih dekat daripada buram lulus uji kedalaman, terlepas dari bagaimana mereka berada di kedalaman relatif terhadap fragmen transparan yang sudah ditarik, dan fragmen transparan yang muncul lebih jauh buram, jangan lulus uji kedalaman, dan, karenanya, dibuang. <br><br>  C <sub>0</sub> dalam rumus (2) adalah warna dari sebuah fragmen yang buram, yang di atasnya fragmen transparan digambar, di mana kita memiliki n buah, yang ditunjukkan oleh indeks 1 sampai n.  C <sub>i</sub> adalah warna dari fragmen transparan ke-i, <i>Œ± <sub>i</sub></i> adalah opacity-nya. <br><br>  Jika Anda perhatikan lebih teliti, maka rumus (2) sedikit mirip rumus (1).  Jika Anda bayangkan itu <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  Apakah C <sub>dekat</sub> , C <sub>0</sub> adalah C <sub>jauh</sub> , dan <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  - ini <i>Œ±</i> , maka ini akan menjadi formula 1, 1-1.  Dan sungguh <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  - ini adalah rata-rata tertimbang warna dari fragmen transparan (pusat massa ditentukan dalam mekanika dengan rumus yang sama), itu akan menjadi warna fragmen terdekat C di <sub>dekat</sub> .  C <sub>0</sub> adalah warna fragmen buram yang terletak di belakang semua fragmen, yang kami hitung rata-rata tertimbang ini, dan itu akan berlaku untuk C <sub>jauh</sub> .  Artinya, kami mengganti semua fragmen transparan dengan satu fragmen ‚Äúrata-rata‚Äù dan menerapkan formula standar untuk pencampuran warna - formula (1).  Apa rumus licik untuk <i>Œ±</i> yang ditawarkan oleh penulis artikel asli? <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/457284/&amp;usg=ALkJrhgh1X1LV11y_rOJAJMhI15wsoxM1g#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  Ini adalah fungsi skalar dalam ruang n-dimensi, jadi mari kita ingat analisis diferensial fungsi beberapa variabel.  Mengingat bahwa semua <i>Œ± <sub>i</sub></i> termasuk dalam rentang dari 0 hingga 1, turunan parsial sehubungan dengan salah satu variabel akan selalu menjadi konstanta non-negatif.  Ini berarti bahwa opacity dari fragmen "rata-rata" meningkat dengan meningkatnya opacity dari fragmen transparan, dan inilah yang kita butuhkan.  Selain itu, meningkat secara linear. <br><br>  Jika opacity dari sebuah fragmen adalah 0, maka itu tidak terlihat sama sekali, itu tidak mempengaruhi warna yang dihasilkan. <br><br>  Jika opacity dari setidaknya satu fragmen adalah 1, maka <i>Œ±</i> adalah 1. Artinya, fragmen opak menjadi tidak terlihat, yang umumnya baik.  Hanya fragmen transparan yang terletak di belakang fragmen dengan opacity = 1 masih bersinar dan memengaruhi warna yang dihasilkan: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  Di sini, sebuah segitiga oranye terletak di atas, hijau di bawahnya, dan abu-abu dan cyan di bawah hijau, dan semua ini dengan latar belakang hitam.  Opacity biru = 1, semua lainnya - 0,5.  Gambar di sebelah kanan adalah apa yang seharusnya.  Seperti yang Anda lihat, WBOIT terlihat menjijikkan.  Satu-satunya tempat di mana warna oranye normal muncul adalah tepi segitiga hijau, dikelilingi oleh garis putih buram.  Seperti yang baru saja saya katakan, sebuah fragmen buram tidak terlihat jika opacity dari fragmen transparan adalah 1. <br><br>  Ini bahkan lebih baik dilihat di sini: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  Segitiga oranye memiliki opacity 1, yang hijau dengan transparansi dimatikan hanya ditarik dengan objek buram.  Sepertinya segitiga HIJAU bersinar melalui ORANGE melalui segitiga oranye. <br><br>  Untuk membuat gambar terlihat layak, cara termudah adalah tidak menetapkan objek dengan opacity tinggi.  Dalam proyek kerja saya, saya tidak mengizinkan pengaturan opacity lebih besar dari 0,5.  Ini adalah CAD 3D, di mana objek digambar secara skematis, dan realisme khusus tidak diperlukan, jadi pembatasan seperti itu diperbolehkan di sana. <br><br>  Dengan nilai opacity rendah, gambar di sebelah kiri dan kanan terlihat hampir sama: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  Dan dengan tinggi mereka sangat berbeda: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  Seperti inilah bentuk polyhedron transparan: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  Polyhedron memiliki wajah horizontal oranye dan hijau oranye.  Sayangnya, Anda tidak akan memahami ini pada pandangan pertama, yaitu  gambar tidak terlihat meyakinkan.  Di mana ada dinding oranye di depan, Anda membutuhkan lebih dari oranye, dan di mana hijau lebih dari hijau.  Akan jauh lebih baik untuk menggambar wajah dalam satu warna: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  WBOIT berbasis kedalaman </h3><br>  Untuk mengkompensasi kurangnya penyortiran berdasarkan kedalaman, penulis artikel ini memberikan beberapa opsi untuk menambahkan kedalaman pada formula (2).  Ini membuat implementasi lebih sulit, dan hasilnya kurang dapat diprediksi dan tergantung pada karakteristik adegan tiga dimensi tertentu.  Saya tidak mempelajari topik ini, jadi siapa yang peduli - saya mengusulkan untuk membaca artikel. <br><br>  Dikatakan bahwa WBOIT kadang-kadang mampu melakukan sesuatu yang tidak bisa diurutkan oleh transparansi klasik.  Misalnya, Anda menggambar asap sebagai sistem partikel yang hanya menggunakan dua partikel - dengan asap gelap dan terang.  Ketika satu partikel melewati yang lain, pencampuran warna klasik dengan penyortiran memberikan hasil yang buruk - warna asap dari cahaya dengan tajam menjadi gelap.  Artikel tersebut mengatakan bahwa WBOIT yang sensitif terhadap kedalaman memungkinkan transisi yang mulus dan terlihat lebih dapat dipercaya.  Hal yang sama dapat dikatakan tentang pemodelan bulu dan rambut dalam bentuk tabung tipis. <br><br><h3>  Kode </h3><br>  Sekarang tentang bagaimana menerapkan formula (2) pada OpenGL.  Contoh kode ada di Github ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ), dan sebagian besar gambar dalam artikel berasal dari sana.  Anda dapat mengumpulkan dan bermain dengan segitiga saya.  Kerangka kerja Qt digunakan. <br><br>  Bagi mereka yang baru mulai mempelajari rendering objek transparan, saya merekomendasikan dua artikel ini: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelajari OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelajaran 4.3 - Mencampur Warna</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritme Transparansi Independen Pesanan menggunakan daftar tertaut pada Direct3D 11 dan OpenGL 4</a> <br><br>  Namun, yang kedua tidak begitu penting untuk memahami materi ini, tetapi yang pertama harus dibaca. <br><br>  Untuk menghitung rumus (2), kita membutuhkan 2 framebuffer tambahan, 3 tekstur multisampel dan buffer render, di mana kita akan menulis kedalamannya.  Dalam tekstur pertama - colorTextureNT (NT berarti non-transparan) - kita akan membuat objek buram.  Itu memiliki tipe GL_RGB10_A2.  Tekstur kedua (colorTexture) akan bertipe GL_RGBA16F;  dalam 3 komponen pertama dari tekstur ini, kita akan menulis rumus ini (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  di keempat - <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  .  Tekstur lain dari tipe GL_R16 (alphaTexture) akan berisi <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  Pertama, Anda perlu membuat objek-objek ini untuk mendapatkan pengidentifikasi dari OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  Seperti yang saya katakan, kerangka kerja Qt digunakan di sini, dan semua panggilan OpenGL melalui objek bertipe QOpenGLFunctions_4_5_Core, yang selalu disebut sebagai f untuk saya. <br><br>  Sekarang Anda harus mengalokasikan memori: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  Dan konfigurasikan framebuffers: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  Pada pass rendering kedua, output dari shader fragmen akan menuju ke dua tekstur sekaligus, dan ini harus ditentukan secara eksplisit menggunakan glDrawBuffers. <br><br>  Sebagian besar kode ini dieksekusi satu kali, pada saat startup program.  Kode yang mengalokasikan memori untuk tekstur dan membuat buffer dipanggil setiap kali jendela diubah ukurannya.  Selanjutnya muncul kode rendering, yang dipanggil setiap kali jendela digambar ulang. <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br>  Kami hanya menggambar semua objek buram pada tekstur colorTextureNT, dan menulis kedalaman ke buffer render.  Sebelum menggunakan renderbuffer yang sama pada tahap gambar berikutnya, Anda perlu memastikan bahwa semua kedalaman objek buram sudah ditulis di sana.  Untuk ini, GL_FRAMEBUFFER_BARRIER_BIT digunakan.  Setelah merender objek transparan, kita memanggil fungsi ApplyTextures (), yang akan meluncurkan tahap akhir rendering, di mana shader fragmen akan membaca data dari colorTextureNT tekstur, colorTexture dan alphaTexture untuk menerapkan rumus (2).  Tekstur seharusnya sudah sepenuhnya ditulis saat itu, jadi sebelum memanggil ApplyTextures () kami menggunakan GL_TEXTURE_FETCH_BARRIER_BIT. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO adalah framebuffer tempat kita menampilkan gambar.  Dalam kebanyakan kasus itu adalah 0, tetapi dalam Qt adalah QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Setiap kali shader fragmen dipanggil, kami akan memiliki informasi tentang warna dan opacity dari fragmen saat ini.  Tetapi pada output dalam tekstur colorTexture kami ingin mendapatkan jumlah (dan dalam produk alphaTexture tekstur) dari beberapa fungsi dari jumlah ini.  Blending digunakan untuk ini.  Selain itu, karena untuk tekstur pertama kami menghitung jumlah, dan untuk yang kedua - produk, pengaturan blending (glBlendFunc dan glBlendEquation) untuk setiap lampiran harus diatur secara terpisah. <br><br>  Berikut adalah isi dari fungsi SiapkanToTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br>  Dan isi dari fungsi CleanupAfterTransparentRendering (): <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  Dalam shader fragmen saya, opacity ditunjukkan oleh huruf w.  Produk warna oleh w dan w itu sendiri kita output ke satu parameter output, dan 1 - w ke yang lain.  Untuk setiap parameter output, kualifikasi tata letak diatur dalam bentuk ‚Äúlocation = X‚Äù, di mana X adalah indeks elemen dalam array lampiran, yang kami sampaikan ke glDrawBuffers di daftar ke-3 (khususnya, parameter output dengan lokasi = 0 dikirim ke tekstur terikat ke GL_COLOR_ATTACHMENT0 , dan parameter dengan lokasi = 1 - dalam tekstur yang dilampirkan ke GL_COLOR_ATTACHMENT1).  Angka yang sama digunakan dalam fungsi glBlendFunci dan glBlendEquationi untuk menunjukkan nomor lampiran yang kita atur parameter blending. <br><br>  Shader fragmen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  Dalam fungsi ApplyTextures (), kita cukup menggambar kotak di atas seluruh jendela.  Shader fragmen meminta data dari semua tekstur yang kami buat, menggunakan koordinat layar saat ini sebagai koordinat tekstur dan nomor sampel saat ini (gl_SampleID) sebagai nomor sampel dalam tekstur multisampel.  Menggunakan variabel gl_SampleID dalam shader secara otomatis mengaktifkan mode ketika shader fragmen dipanggil satu kali untuk setiap sampel (dalam kondisi normal, itu disebut sekali untuk seluruh piksel, dan hasilnya ditulis untuk semua sampel yang ada di dalam primitif). <br><br>  Tidak ada yang luar biasa di vertex shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br>  Shader fragmen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Dan akhirnya, isi fungsi ApplyTextures (): <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Yah, alangkah baiknya untuk membebaskan sumber daya OpenGL setelah selesai.  Saya memiliki kode ini yang disebut sebagai penghancur widget OpenGL saya: <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457284/">https://habr.com/ru/post/id457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457262/index.html">Analisis kualifikasi kejuaraan pemrograman antara pengembang backend</a></li>
<li><a href="../id457266/index.html">Krisis yang gesit. Apa yang harus dilakukan</a></li>
<li><a href="../id457270/index.html">Prisma-CMS sebagai mesin untuk membuat MVP dengan cepat</a></li>
<li><a href="../id457276/index.html">Tujuh ancaman bot ke situs Anda</a></li>
<li><a href="../id457282/index.html">"Kematian Tuhan" atau runtuhnya undang-undang yang berlaku umum untuk membangun tim TI dan menciptakan sistem TI di abad ke-21</a></li>
<li><a href="../id457286/index.html">Solusi tugas WorldSkills dari modul Network dalam kompetensi "CCA". Bagian 1 - Pengaturan Dasar</a></li>
<li><a href="../id457288/index.html">Stasiun kerja kriptografis berdasarkan token PKCS # 11. Tanda tangan elektronik. Bagian 2</a></li>
<li><a href="../id457290/index.html">Konferensi DEFCON 25. Garry Kasparov. "Pertempuran terakhir otak." Bagian 2</a></li>
<li><a href="../id457292/index.html">WBOIT di OpenGL: transparansi tanpa pengurutan</a></li>
<li><a href="../id457294/index.html">"Live high" atau kisah saya dari penundaan hingga pengembangan diri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>