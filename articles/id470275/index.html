<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ù üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üôÉ F # 8: Serikat yang Didiskriminasi üêò üôÖ üßëüèæ‚Äçü§ù‚Äçüßëüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi perjalanan F # kami berlanjut. Kami melihat beberapa tipe dasar blok bangunan, seperti catatan / tupel, sekarang saatnya untuk melihat pada asosi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>F # 8: Serikat yang Didiskriminasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470275/">  Jadi perjalanan F # kami berlanjut.  Kami melihat beberapa tipe dasar blok bangunan, seperti catatan / tupel, sekarang saatnya untuk melihat pada asosiasi yang ditandai. <br><a name="habracut"></a><br>  Serikat pekerja berlabel memberikan dukungan untuk nilai, yang dapat menjadi salah satu dari beberapa nilai yang mungkin.  Nilai yang mungkin dikenal sebagai "kasus gabungan", dan mengambil formulir yang ditunjukkan di bawah ini: <br><br><pre><code class="plaintext hljs">case-identifier1 [of [ fieldname1 : ] type1 [ * [ fieldname2 : ] type2 ‚Ä¶]</code> </pre> <br>  Jangan khawatir jika sintaks ini terlihat mengintimidasi, maka sebenarnya apa yang muncul adalah adanya label sehingga setiap case dapat dikenali (dibedakan) dari yang lain, dan tipe untuk case combining.  Nama memiliki aturan tertentu, seperti <br><br><ul><li>  Harus dimulai dengan huruf kapital </li><li>  Ini bisa menjadi pengidentifikasi, termasuk nama jenis serikat itu sendiri.  Ini mungkin sedikit membingungkan, tetapi berguna untuk menggambarkan kasus penggabungan. </li></ul><br>  Berikut adalah contoh id yang buruk <br><br><img src="https://habrastorage.org/getpro/habr/post_images/832/c8a/fe0/832c8afe07d8b70c609873c18652b27e.png" alt="gambar"><br><br>  Dan di sini adalah bagaimana sesuatu seperti ini terlihat ketika menggunakan pengenal tag yang cocok dengan register serikat, yang, sebagaimana disebutkan sebelumnya, sangat valid <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LabelUnionType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> of int | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> of string</span></span></code> </pre> <br><h4>  Membangun asosiasi yang ditandai </h4><br>  Lantas bagaimana membangun kasus unifikasi?  Nah, ada berbagai cara, Anda bisa menggunakan salah satu pendekatan berikut: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> currentLabelUnionType1 = <span class="hljs-number"><span class="hljs-number">13</span></span> printfn <span class="hljs-string"><span class="hljs-string">"let currentLabelUnionType1 = 13"</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%O"</span></span> currentLabelUnionType1 <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentLabelUnionType2 = <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-number"><span class="hljs-number">23</span></span> printfn <span class="hljs-string"><span class="hljs-string">"let currentLabelUnionType2 = Int 23"</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%O"</span></span> currentLabelUnionType2 printfn <span class="hljs-string"><span class="hljs-string">"%A"</span></span> currentLabelUnionType2 <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentLabelUnionType3 = <span class="hljs-string"><span class="hljs-string">"Cat"</span></span> printfn <span class="hljs-string"><span class="hljs-string">"let currentLabelUnionType3 = \"Cat\""</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%O"</span></span> currentLabelUnionType3 printfn <span class="hljs-string"><span class="hljs-string">"%A"</span></span> currentLabelUnionType3 <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentLabelUnionType4 = <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-string"><span class="hljs-string">"Cat"</span></span> printfn <span class="hljs-string"><span class="hljs-string">"let currentLabelUnionType4 = String \"Cat\""</span></span> printfn <span class="hljs-string"><span class="hljs-string">"%O"</span></span> currentLabelUnionType4 printfn <span class="hljs-string"><span class="hljs-string">"%A"</span></span> currentLabelUnionType4</code> </pre> <br>  Yang saat startup dapat memberikan hasil berikut ketika diluncurkan melalui fungsi printfn (Saya menggunakan formatter% A atau% O printfn di bawah): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf0/376/0be/cf03760be0b27e0621fb455e9e747871.png" alt="gambar"><br><br>  Anda dapat menggunakan hampir semua jenis dalam menggabungkan kasus seperti <br><br><ul><li>  Tuple </li><li>  dokumentasi </li><li>  Jenis lainnya </li></ul><br>  Satu-satunya aturan adalah bahwa jenisnya harus ditentukan sebelum kasing serikat Anda dapat menggunakannya. <br><br>  Berikut adalah contoh yang menggunakan jenis tuple dalam kasus penyatuan: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> unionUsingTuples = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CCY</span></span></span><span class="hljs-class"> of (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rates</span></span></span><span class="hljs-class"> of (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">decimal</span></span></span><span class="hljs-class">) ..... ..... let tupledUnion = (12, "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GBP</span></span></span><span class="hljs-class">")</span></span></code> </pre> <br><h4>  Serikat Kosong </h4><br>  Anda juga dapat menggunakan serikat kosong.  Yang mana Anda tidak menentukan tipe.  Ini membuat mereka jauh lebih mirip dengan nilai enumerasi .NET standar.  Berikut ini sebuah contoh: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Player</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cross</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nought</span></span></span><span class="hljs-class"> .... .... let emptyUnion = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cross</span></span></span></span></code> </pre> <br><h4>  Bagaimana dengan kasus serupa berdasarkan jenis </h4><br>  Mata elang, seperti Anda, dapat melihat masalahnya.  Apa yang akan terjadi jika kita memiliki sesuatu seperti ini: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PurchaseOrders</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Orders</span></span></span><span class="hljs-class"> of (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ClientOrders</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Orders</span></span></span><span class="hljs-class"> of (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span></span></code> </pre> <br>  Ini menyebabkan masalah bagi kita, bukan?  Bagaimana kita membedakan jenis aliansi yang dibatasi ini?  Untungnya, kita dapat mengambil pendekatan yang sepenuhnya memenuhi syarat untuk ini, jadi kita bisa melakukannya, dan semuanya akan bekerja seperti yang diharapkan.  Perlu dicatat bahwa Anda dapat mengambil satu langkah lebih jauh dan memasukkan nama modul jika modul terlibat (kita akan mempelajari lebih lanjut tentang ini nanti di artikel berikutnya): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> purchaseOrders = <span class="hljs-type"><span class="hljs-type">PurchaseOrders</span></span>.<span class="hljs-type"><span class="hljs-type">Orders</span></span> (<span class="hljs-string"><span class="hljs-string">"box of 100 scrubbing brushes"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> clientOrders = <span class="hljs-type"><span class="hljs-type">ClientOrders</span></span>.<span class="hljs-type"><span class="hljs-type">Orders</span></span> (<span class="hljs-string"><span class="hljs-string">"scrubbing brush"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br><h4>  Perbandingan </h4><br>  Seperti banyak jenis F #, gabungan terbatas dianggap sama jika <br><br><ul><li>  Panjang kotak gabungannya sama. </li><li>  Jenis kasus serikat mereka cocok. </li><li>  Nilai kasus asosiasi mereka sama. </li></ul><br><h4>  Tidak sama </h4><br>  Berikut adalah contoh di mana kesetaraan tidak dihormati: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> purchaseOrders1 = <span class="hljs-type"><span class="hljs-type">PurchaseOrders</span></span>.<span class="hljs-type"><span class="hljs-type">Orders</span></span> (<span class="hljs-string"><span class="hljs-string">"box of 100 scrubbing brushes"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> purchaseOrders2 = <span class="hljs-type"><span class="hljs-type">PurchaseOrders</span></span>.<span class="hljs-type"><span class="hljs-type">Orders</span></span> (<span class="hljs-string"><span class="hljs-string">"10 pack of disks"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"purchaseOrders1 = purchaseOrders2 %A"</span></span> (purchaseOrders1 = purchaseOrders2)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/16a/355/6f716a3554105e739c50e42de2846287.png" alt="gambar"><br><br><h4>  Sama </h4><br>  Ini adalah contoh kesetaraan.  Ini adalah sesuatu seperti kode .NET biasa, Anda tahu, jika para anggotanya sama, mereka memiliki nilai yang sama dan nomor yang benar, maka ini hampir sama (jika kita mengabaikan kode hash yang ada): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">let</span></span> purchaseOrders1 = <span class="hljs-type"><span class="hljs-type">PurchaseOrders</span></span>.<span class="hljs-type"><span class="hljs-type">Orders</span></span> (<span class="hljs-string"><span class="hljs-string">"box of 100 scrubbing brushes"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> purchaseOrders2 = <span class="hljs-type"><span class="hljs-type">PurchaseOrders</span></span>.<span class="hljs-type"><span class="hljs-type">Orders</span></span> (<span class="hljs-string"><span class="hljs-string">"box of 100 scrubbing brushes"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) printfn <span class="hljs-string"><span class="hljs-string">"purchaseOrders1 = purchaseOrders2 %A"</span></span> (purchaseOrders1 = purchaseOrders2)</code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/f3a/df3/12d/f3adf312dd3da82030e5d77b694ba8ae.png" alt="gambar"><br><br>  Perlu dicatat bahwa kita tidak dapat menggunakan kesetaraan ketika kita harus sepenuhnya memenuhi syarat jenis serikat, karena mereka adalah jenis yang berbeda, jadi ini tidak akan berfungsi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ac/f7b/b25/6acf7bb25aba5d1778c173fd73c5efae.png" alt="gambar"><br><br><h4>  Pola Perbandingan </h4><br>  Di bawah ini adalah fungsi kecil yang mengambil Kartu union dan menampilkan kasus-kasus serikat itu dipanggil, dan hanya mengembalikan Unit (batal, jika Anda ingat ini dari artikel sebelumnya dalam seri ini): <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValueCard</span></span></span><span class="hljs-class"> of int | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jack</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Queen</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">King</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ace</span></span></span><span class="hljs-class"> .... .... let cardFunction card = match card with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValueCard</span></span></span><span class="hljs-class"> i -&gt; printfn "its a value card of %</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">" i | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jack</span></span></span><span class="hljs-class"> -&gt; printfn "its a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jack</span></span></span><span class="hljs-class">" | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Queen</span></span></span><span class="hljs-class"> -&gt; printfn "its a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jack</span></span></span><span class="hljs-class">" | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">King</span></span></span><span class="hljs-class"> -&gt; printfn "its a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jack</span></span></span><span class="hljs-class">" | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ace</span></span></span><span class="hljs-class"> -&gt; printfn "its a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ace</span></span></span><span class="hljs-class">" () //return unit //shows you how to pass it in without a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Let</span></span></span><span class="hljs-class"> binding do cardFunction (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValueCard</span></span></span><span class="hljs-class"> 8) //or you could use explicit </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Let</span></span></span><span class="hljs-class"> binding if you do desire let aceCard = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ace</span></span></span><span class="hljs-class"> do cardFunction aceCard</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/ab7/a11/21e/ab7a1121eb25190c883400d09e939646.png" alt="gambar"><br><br><h4>  Jadi persis apa yang terjadi di balik layar </h4><br>  Jadi sekarang kita telah melihat beberapa contoh cara kerja asosiasi berlabel.  Jadi, apa yang menurut Anda dapat terjadi jika kami memiliki pustaka F # yang menggunakan asosiasi markup, dan kami memutuskan untuk menggunakannya dari C # / VB.NET.  Apakah Anda pikir ini akan berhasil?  Jawab: Saya yakin itu akan terjadi.  Saya akan melakukan seluruh posting tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interop</a> di suatu tempat di masa depan, tapi saya pikir mungkin menarik untuk mempertimbangkan beberapa hal ini sekarang untuk bergabung dengan label, karena mereka sangat berbeda dari semua yang kita lihat dalam pemrograman standar .NET. <br><br>  Jadi, mari kita ambil Kartu di atas, yang merupakan kode ini: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Card</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValueCard</span></span></span><span class="hljs-class"> of int | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jack</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Queen</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">King</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ace</span></span></span></span></code> </pre> <br>  Dan jalankan melalui decompiler seperti Reflector / DotPeek (semua yang Anda miliki).  Saya menggunakan DotPeek dan mendapatkan kode C # ini untuk baris F # ini.  Jadi, seperti yang Anda lihat, kompiler F # melakukan pekerjaan yang bagus untuk memastikan bahwa tipe F # akan bekerja dengan baik dengan .NET, seperti C # / VB.NET. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Microsoft</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FSharp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Core</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Collections</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Diagnostics</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Runtime</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CompilerServices</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Runtime</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InteropServices</span></span>; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.Module)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span> { [EntryPoint] public static int main(string[] argv) { return 0; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerDisplay("{__DebugDisplay(),nq}")]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.SumType)]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Serializable]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Card</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">IEquatable</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">IStructuralEquatable</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">IComparable</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span>&gt;, <span class="hljs-selector-tag"><span class="hljs-selector-tag">IComparable</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">IStructuralComparable</span></span> { [CompilerGenerated] [DebuggerNonUserCode] [DebuggerBrowsable(DebuggerBrowsableState.Never)] public int Tag { [DebuggerNonUserCode] get { return this._tag; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IsValueCard</span></span> { [DebuggerNonUserCode] get { return this.get_Tag() == 0; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Jack</span></span> { [CompilationMapping(SourceConstructFlags.UnionCase, 1)] get { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_Jack; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IsJack</span></span> { [DebuggerNonUserCode] get { return this.get_Tag() == 1; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Queen</span></span> { [CompilationMapping(SourceConstructFlags.UnionCase, 2)] get { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_Queen; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IsQueen</span></span> { [DebuggerNonUserCode] get { return this.get_Tag() == 2; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">King</span></span> { [CompilationMapping(SourceConstructFlags.UnionCase, 3)] get { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_King; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IsKing</span></span> { [DebuggerNonUserCode] get { return this.get_Tag() == 3; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ace</span></span> { [CompilationMapping(SourceConstructFlags.UnionCase, 4)] get { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_Ace; } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilerGenerated]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerNonUserCode]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerBrowsable(DebuggerBrowsableState.Never)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">bool</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IsAce</span></span> { [DebuggerNonUserCode] get { return this.get_Tag() == 4; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Card</span></span>() { } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.UnionCase, 0)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">NewValueCard</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span>) { return (Program.Card) new Program.Card.ValueCard(item); } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.UnionCase, 1)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_Jack</span></span>() { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_Jack; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.UnionCase, 2)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_Queen</span></span>() { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_Queen; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.UnionCase, 3)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_King</span></span>() { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_King; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[CompilationMapping(SourceConstructFlags.UnionCase, 4)]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_Ace</span></span>() { // <span class="hljs-attribute"><span class="hljs-attribute">ISSUE</span></span>: reference to a compiler-generated field return Program.Card._unique_Ace; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tags</span></span> { public const int ValueCard = 0; public const int Jack = 1; public const int Queen = 2; public const int King = 3; public const int Ace = 4; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerTypeProxy(typeof (Program.Card.ValueCard\u0040DebugTypeProxy))]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[DebuggerDisplay("{__DebugDisplay(),nq}")]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[Serializable]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[SpecialName]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">public</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValueCard</span></span> : <span class="hljs-selector-tag"><span class="hljs-selector-tag">Program</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Card</span></span> { [CompilationMapping(SourceConstructFlags.Field, 0, 0)] [CompilerGenerated] [DebuggerNonUserCode] public int Item { [DebuggerNonUserCode] get { return this.item; } } } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[SpecialName]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">internal</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValueCard</span></span>\<span class="hljs-selector-tag"><span class="hljs-selector-tag">u0040DebugTypeProxy</span></span> { [CompilationMapping(SourceConstructFlags.Field, 0, 0)] [CompilerGenerated] [DebuggerNonUserCode] public int Item { [DebuggerNonUserCode] get { return this._obj.item; } } } } }</code> </pre> <br><h4>  Kasing rekursif (struktur pohon) </h4><br>  Gabungan berlabel juga dapat digunakan dengan cara rekursif, di mana serikat itu sendiri dapat digunakan sebagai salah satu jenis dalam satu atau lebih kasus.  Ini membuat sambungan yang ditandai sangat cocok untuk memodelkan struktur pohon, seperti: <br><br><ul><li>  Ekspresi matematika </li><li>  Pohon sintaksis abstrak </li><li>  Xml </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bahkan, MSDN memiliki beberapa contoh bagus.</a> <br><br>  Dalam kode berikut, serikat berlabel rekursif digunakan untuk membuat struktur data pohon biner.  Serikat terdiri dari dua kasus: Node, yang merupakan simpul dengan nilai integer dan sub pohon kiri dan kanan, dan Tip, yang melengkapi pohon. <br><br>  Struktur pohon untuk myTree dalam contoh di bawah ini ditunjukkan pada gambar di bawah ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3dd/d4f/1f9/3ddd4f1f98668aa64a5d4b8577ca8ede.png" alt="gambar"><br><br>  Dan ini adalah bagaimana kita bisa memodelkan myTree menggunakan gabungan yang ditandai.  Perhatikan bagaimana kami mengklasifikasikan bergabung yang ditandai sebagai salah satu kasus bergabung.  Dalam hal ini, kasus-kasus menggabungkan keduanya <br><br><ul><li>  Kiat (serikat kosong, bertindak sebagai enumerasi standar dalam .NET) </li><li>  Atau 3 digit tuple dari angka, Tree, Tree </li></ul><br>  Juga harus dicatat bahwa fungsi sumTree ditandai dengan kata kunci rec.  Apa yang dilakukan mantra sihir ini dengan fungsi kita?  Nah, ini menandai fungsi sumTree sebagai fungsi yang akan dipanggil secara rekursif.  Tanpa kata kunci "rec" dalam fungsi sumTree, kompiler F # akan mengeluh.  Dalam hal ini, kompiler akan melempar kesalahan berikut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea2/97f/878/ea297f878ef1675a089775fb38392d56.png" alt="gambar"><br><br>  Tetapi kami adalah orang baik, dan kami akan menggunakan kata kunci yang tepat untuk mendukung kasus penggunaan kami, jadi kami melanjutkan <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class"> of int * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tree</span></span></span><span class="hljs-class"> .... .... .... .... let rec sumTree tree = match tree with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class"> -&gt; 0 | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">left</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">right</span></span></span><span class="hljs-class">) -&gt; value + sumTree(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">left</span></span></span><span class="hljs-class">) + sumTree(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">right</span></span></span><span class="hljs-class">) let myTree = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class">(0, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class">(1, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class">(2, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class">), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class">(3, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class">)), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Node</span></span></span><span class="hljs-class">(4, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Tip</span></span></span><span class="hljs-class">)) let resultSumTree = sumTree myTree printfn "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Value</span></span></span><span class="hljs-class"> of sumTree is %</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">" resultSumTree</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/edd/bd4/a6d/eddbd4a6d557bd13c7b6d21ee11b73ba.png" alt="gambar"><br><br>  MSDN juga memiliki contoh bagus lainnya yang menurut saya layak untuk dicuri (ya, saya berbicara terus terang tentang hal itu sekarang. Saya pikir sementara kalian mengambil sesuatu dari contoh pinjaman ini, seperti Saya jelas mengatakan, saya meminjam, saya tidak dalam bisnis).  Mari kita lihat contoh ini di sini: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> = | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Number</span></span></span><span class="hljs-class"> of int | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Multiply</span></span></span><span class="hljs-class"> of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expression</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Variable</span></span></span><span class="hljs-class"> of string .... .... .... let rec </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">env</span></span></span><span class="hljs-class">:</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">&gt;) exp = match exp with | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Number</span></span></span><span class="hljs-class"> n -&gt; n | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> env x + </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> env y | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Multiply</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> env x * </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> env y | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Variable</span></span></span><span class="hljs-class"> id -&gt; env.[id] let environment = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Map</span></span></span><span class="hljs-class">.ofList [ "a", 1 ; "b", 2 ; "c", 3 ] // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Create</span></span></span><span class="hljs-class"> an expression tree that represents // the expression: a + 2 * b. let expressionTree1 = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Variable</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">", </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Multiply</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Number</span></span></span><span class="hljs-class"> 2, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Variable</span></span></span><span class="hljs-class"> "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">")) // </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> the expression a + 2 * b, given the // table of values for the variables. let result = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Evaluate</span></span></span><span class="hljs-class"> environment expressionTree1 printfn "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Value</span></span></span><span class="hljs-class"> of sumTree is %</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">" result</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/4f3/5cb/5ea/4f35cb5ea06ed795a8aa6a565ac72a37.png" alt="gambar"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470275/">https://habr.com/ru/post/id470275/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470257/index.html">Cloak Around ImmutableList di Jawa</a></li>
<li><a href="../id470267/index.html">Pemantauan Suhu Bersertifikat</a></li>
<li><a href="../id470269/index.html">ReactOS 0.4.12: Âçé‰∏∫ Ôºå ‰Ω† ËÆ§‰∏∫ Ëøô‰∏™ ÊÄé‰πà Ê†∑Ôºü</a></li>
<li><a href="../id470271/index.html">F # 6: Tuples</a></li>
<li><a href="../id470273/index.html">F # 7: Catatan</a></li>
<li><a href="../id470277/index.html">Bagaimana jaringan global di Federasi Rusia terorganisir dan terorganisir?</a></li>
<li><a href="../id470279/index.html">AI, Pembelajaran Mesin, Big Data, Pengenalan Bicara dan kata-kata lain yang TIDAK akan membantu Anda belajar bahasa Inggris</a></li>
<li><a href="../id470281/index.html">Wajah perangkat lunak Rusia. Atau beberapa statistik dari Unified Register program komputer dan basis data Rusia</a></li>
<li><a href="../id470283/index.html">Mesin pencari adalah seorang Wanita</a></li>
<li><a href="../id470285/index.html">Seekor harimau yang meringkuk bersembunyi di SQLAlchemy. Dasar-dasarnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>