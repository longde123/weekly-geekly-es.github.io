<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÑ üîª ‚õìÔ∏è El libro "Tareas de inform√°tica cl√°sica en Python" üèÇüèΩ üë©üèΩ‚Äçüöí ü§πüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchas tareas en el campo de la inform√°tica, que a primera vista parecen nuevas o √∫nicas, se basan en algoritmos cl√°sicos, m√©todos de codificaci√≥n y p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro "Tareas de inform√°tica cl√°sica en Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="imagen"></a>  Muchas tareas en el campo de la inform√°tica, que a primera vista parecen nuevas o √∫nicas, se basan en algoritmos cl√°sicos, m√©todos de codificaci√≥n y principios de desarrollo.  ¬°Y las t√©cnicas establecidas siguen siendo la mejor manera de resolver tales problemas! <br><br>  El libro le dar√° la oportunidad de dominar mejor el lenguaje Python, ponerse a prueba en tareas, ejercicios y algoritmos probados por el tiempo.  Tiene que resolver docenas de tareas de programaci√≥n: desde las m√°s simples (por ejemplo, encontrar elementos de la lista usando la ordenaci√≥n binaria) hasta las complejas (agrupar datos usando el m√©todo k-means).  Al trabajar con ejemplos de b√∫squeda, agrupaci√≥n, gr√°ficos, etc., recordar√° lo que ha olvidado y dominar√° las t√©cnicas cl√°sicas para resolver problemas cotidianos. <br><a name="habracut"></a><br><h3>  ¬øPara qui√©n es este libro? </h3><br>  Este libro est√° destinado a programadores de nivel medio y alto.  Los profesionales experimentados que desean profundizar su conocimiento de Python encontrar√°n aqu√≠ tareas que les son familiares desde el momento en que ense√±aron inform√°tica o programaci√≥n.  Los programadores de nivel medio se familiarizar√°n con estas tareas cl√°sicas en su lenguaje elegido: Python.  Para los desarrolladores que se est√°n preparando para una entrevista de programaci√≥n, es probable que la publicaci√≥n se convierta en un valioso material preparatorio. <br><br>  Adem√°s de los programadores profesionales, este libro puede ser considerado √∫til por los estudiantes que estudian para programas de pregrado en inform√°tica y est√°n interesados ‚Äã‚Äãen Python.  No pretende ser una introducci√≥n rigurosa a las estructuras de datos y algoritmos.  Este no es un tutorial sobre estructuras de datos y algoritmos.  No encontrar√° pruebas de teoremas o el uso abundante de O grandes anotaciones en sus p√°ginas.  Por el contrario, este libro se posiciona como una gu√≠a pr√°ctica accesible de m√©todos para resolver problemas que deber√≠an convertirse en el producto final del estudio de la estructura de datos, algoritmos y clases de inteligencia artificial. <br><br>  Lo enfatizo nuevamente: se supone que los lectores est√°n familiarizados con la sintaxis y la sem√°ntica de Python.  Es poco probable que un lector con experiencia en programaci√≥n cero se beneficie de este libro, y un programador con experiencia cero en Python probablemente ser√° dif√≠cil.  En otras palabras, "Tareas de inform√°tica cl√°sica en Python" es un libro para programadores de Python y estudiantes de inform√°tica. <br><br><h3>  Extracto  1.5.  Torres de hanoi </h3><br>  Hay tres columnas verticales altas (en adelante, torres).  Los designaremos A, B y C. Los discos con agujeros en el centro est√°n encadenados en la torre A. El disco m√°s ancho, lo llamaremos disco 1, se encuentra debajo.  Los discos restantes ubicados encima est√°n indicados por n√∫meros crecientes y se van reduciendo gradualmente.  Por ejemplo, si tuvi√©ramos tres discos, el m√°s ancho de ellos, el de abajo, tendr√≠a el n√∫mero 1. El siguiente disco m√°s ancho, en el n√∫mero 2, se ubicar√≠a sobre el disco 1. Finalmente, el disco m√°s estrecho, en el n√∫mero 3 estar√≠a en el disco 2. <br><br>  Nuestro objetivo es mover todas las unidades desde la torre A a la torre C, teniendo en cuenta las siguientes restricciones. <br><br><ul><li>  Los discos solo se pueden mover de uno en uno. </li><li>  La √∫nica unidad disponible para moverse es la que se encuentra en la parte superior de cualquier torre. </li><li>  Una unidad m√°s ancha nunca se puede colocar encima de una m√°s estrecha. <br>  Esquem√°ticamente, la tarea se muestra en la Fig.  1.7. </li></ul><br><h3>  1.5.1.  Modelado de torres </h3><br>  Una pila es una estructura de datos modelada seg√∫n el principio de √∫ltimo en entrar, primero en salir (LIFO).  Lo √∫ltimo que se pone en la pila se convierte en el primero que se obtiene de all√≠.  Las dos operaciones principales de la pila son push (put) y pop (extract).  La operaci√≥n de inserci√≥n empuja un nuevo elemento a la pila, y pop lo elimina de la pila y devuelve el √∫ltimo elemento insertado.  Puede modelar f√°cilmente la pila en Python usando la lista como almacenamiento de respaldo (Listado 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="imagen"></div><br>  Listado 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  La clase Stack presentada implementa el m√©todo __repr __ (), que facilita el examen del contenido de la torre.  __repr __ () es lo que se generar√° cuando la funci√≥n print () se aplique a la pila. </blockquote><br><blockquote>  Como se indic√≥ en la introducci√≥n, las anotaciones de tipo se utilizan en el libro.  La importaci√≥n de gen√©ricos desde un m√≥dulo de entrada permite que Stack sea una clase param√©trica para un tipo espec√≠fico en anotaciones de tipo.  Un tipo arbitrario T se define en T = TypeVar ('T').  T puede ser de cualquier tipo.  Cuando la anotaci√≥n de tipo se usa posteriormente para Stack para resolver el problema de la torre de Hanoi, la solicitud ser√° Stack [int], es decir, se usar√° el tipo int en lugar de T.  En otras palabras, aqu√≠ la pila es una pila de enteros.  Si tiene dificultades con las anotaciones de tipo, consulte el Ap√©ndice B. </blockquote><br>  Las pilas son perfectas para el desaf√≠o de la torre de Hanoi.  Para mover el disco a la torre, podemos usar la operaci√≥n de empuje.  Para mover el disco de una torre a otra, podemos empujarlo desde la primera (pop) y colocarlo en la segunda (push). <br><br>  Defina las torres como objetos de Pila y llene la primera con discos (Listado 1.21). <br><br>  Listado 1.21.  hanoi.py (continuaci√≥n) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2.  Resolviendo el problema de las Torres de Hanoi </h3><br>  ¬øC√≥mo puedo resolver el problema de las torres de Hanoi?  Supongamos que estamos tratando de mover solo una unidad.  Entonces sabr√≠amos c√≥mo hacer esto, ¬øverdad?  De hecho, mover un disco es un caso b√°sico para una soluci√≥n recursiva a este problema.  Mover varias unidades es un caso recursivo.  El punto clave es que, de hecho, tenemos dos escenarios que necesitan ser codificados: mover un disco (caso base) y mover varios discos (caso recursivo). <br><br>  Para entender el caso recursivo, considere un ejemplo espec√≠fico.  Supongamos que tenemos tres discos: el superior, el medio y el inferior, ubicados en la torre A, y queremos moverlos a la torre C. (Posteriormente, esto ayudar√° a describir esquem√°ticamente el problema). Primero podr√≠amos mover el disco superior a la torre C. Luego, - mueva el disco del medio a la torre B, y luego el disco superior de la torre C a la torre B. Ahora tenemos el disco inferior todav√≠a ubicado en la torre A y los dos discos superiores en la torre B. Esencialmente, ya hemos movido con √©xito dos conducir de una torre (A) a otra (B).  Mover el disco inferior de A a C es el caso b√°sico (mover un disco).  Ahora podemos mover los dos discos superiores de B a C usando el mismo procedimiento que de A a B. Movimos el disco superior a A, el disco del medio a C y finalmente el disco superior de A a C. <br><br><blockquote>  En las clases de ciencias de la computaci√≥n, a menudo se encuentran modelos peque√±os de estas torres, construidas con alfileres y discos de pl√°stico.  Puedes hacer tu propio modelo con tres l√°pices y tres hojas de papel.  Quiz√°s esto lo ayude a visualizar la soluci√≥n. </blockquote><br>  En el ejemplo con tres discos, hubo un caso b√°sico simple de mover un disco y un caso recursivo de mover los discos restantes (en este caso dos) usando una tercera torre temporal.  Podemos dividir el caso recursivo en los siguientes pasos. <br><br><ol><li>  Mueva las unidades n - 1 superiores de la torre A a la torre B (temporal), utilizando C como torre intermedia. </li><li>  Mueva la unidad inferior de A a C. </li><li>  Mueva n - 1 discos de la torre B a la torre C, la torre A es intermedia. </li></ol><br>  Sorprendentemente, este algoritmo recursivo funciona no solo para tres, sino para cualquier cantidad de discos.  Codif√≠quelo como una funci√≥n hanoi (), que es responsable de mover discos de una torre a otra utilizando una tercera torre temporal (Listado 1.22). <br><br>  Listado 1.22.  hanoi.py (continuaci√≥n) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Despu√©s de llamar a hanoi (), debe verificar las torres A, B y C para asegurarse de que los discos se hayan movido correctamente (Listado 1.23). <br><br>  Listado 1.23.  hanoi.py (continuaci√≥n) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Ver√° que las unidades se han movido.  Al codificar la soluci√≥n al problema de la torre de Hanoi, no es necesario comprender todos los pasos necesarios para mover varios discos de la torre A a la torre C. Llegamos a comprender el algoritmo recursivo general para mover cualquier n√∫mero de discos y lo sistematizamos, permitiendo que la computadora haga el resto.  Este es el poder de formular soluciones recursivas a los problemas: a menudo podemos imaginar soluciones en abstracto, sin desperdiciar energ√≠a en la representaci√≥n mental de cada acci√≥n individual. <br><br>  Por cierto, la funci√≥n hanoi () se ejecutar√° exponencialmente dependiendo del n√∫mero de discos, lo que hace que la soluci√≥n del problema incluso para 64 discos no sea adecuada.  Puede intentar ejecutarlo con un n√∫mero diferente de discos cambiando la variable num_discs.  A medida que aumenta el n√∫mero de discos, el n√∫mero de pasos para completar la tarea de la torre de Hanoi crece exponencialmente; se pueden encontrar m√°s detalles en muchas fuentes.  Si est√° interesado en aprender m√°s sobre las matem√°ticas detr√°s de la soluci√≥n recursiva de este problema, vea la explicaci√≥n de Karl Birch en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Sobre las Torres de Hanoi"</a> . <br><br><h3>  1.6.  Aplicaciones reales </h3><br>  Los diversos m√©todos presentados en este cap√≠tulo (recursi√≥n, memorizaci√≥n, compresi√≥n y manipulaci√≥n a nivel de bits) est√°n tan extendidos en el desarrollo de software moderno que sin ellos es imposible imaginar el mundo de la inform√°tica.  A pesar de que las tareas pueden resolverse sin ellas, a menudo es m√°s l√≥gico o conveniente resolverlas utilizando estos m√©todos. <br><br>  En particular, la recursi√≥n subyace no solo en muchos algoritmos, sino incluso en lenguajes de programaci√≥n completos.  En algunos lenguajes de programaci√≥n funcionales, como Scheme y Haskell, la recursi√≥n reemplaza los bucles utilizados en los lenguajes imperativos.  Sin embargo, debe recordarse que todo lo que se puede lograr utilizando el m√©todo recursivo tambi√©n se puede realizar de forma iterativa. <br><br>  La memorizaci√≥n se ha utilizado con √©xito para acelerar el trabajo de los analizadores sint√°cticos, programas que interpretan idiomas.  Esto es √∫til en todas las tareas donde es probable que se solicite nuevamente el resultado de un c√°lculo reciente.  Otra √°rea de acci√≥n para la memorizaci√≥n es el tiempo de ejecuci√≥n del lenguaje de programaci√≥n.  Algunos de estos tiempos de ejecuci√≥n, por ejemplo, para la versi√≥n Prolog, guardan autom√°ticamente los resultados de las llamadas a funciones (auto-mash), por lo que la funci√≥n no tiene que ejecutarse la pr√≥xima vez con la misma llamada.  Esto es similar al decorador @lru_cache () en fib6 (). <br><br>  La compresi√≥n ha hecho que el mundo de Internet, con su ancho de banda limitado, sea m√°s soportable.  El m√©todo de cadena de bits discutido en la Secci√≥n 1.2 es aplicable a tipos de datos simples en el mundo real que tienen un n√∫mero limitado de valores posibles, para los cuales incluso 1 byte es redundante.  Sin embargo, la mayor√≠a de los algoritmos de compresi√≥n funcionan buscando patrones o estructuras en un conjunto de datos que eliminan la informaci√≥n duplicada.  Son mucho m√°s complicados que los descritos en la secci√≥n 1.2. <br><br>  Los cifrados desechables no son adecuados para casos generales de cifrado.  Requieren que tanto el codificador como el decodificador tengan una de las claves (datos ficticios en nuestro ejemplo) para restaurar los datos originales, lo cual es demasiado engorroso y en la mayor√≠a de los esquemas de cifrado no permite alcanzar el objetivo de mantener las claves en secreto.  Pero puede interesarle saber que el nombre de "cifrado desechable" fue inventado por esp√≠as que durante la Guerra Fr√≠a utilizaron cuadernos de papel reales con datos ficticios grabados en ellos para crear mensajes cifrados. <br><br>  Estos m√©todos son los componentes b√°sicos de los programas; otros algoritmos se basan en ellos.  En los siguientes cap√≠tulos ver√° cu√°n ampliamente se aplican. <br><br><h3>  Sobre el autor </h3><br>  <b>David Kopec</b> es profesor titular de inform√°tica e innovaci√≥n en el Champlain College en Burlington, Vermont.  Es un desarrollador de software experimentado y autor de Classic Computer Science Problems in Swift (Manning, 2018) y Dart for Absolute Beginners (Apress, 2014).  David obtuvo una licenciatura en econom√≠a y una maestr√≠a en inform√°tica del Dartmouth College.  Puede contactarlo en Twitter por @davekopec. <br><br>  ¬ªSe puede encontrar m√°s informaci√≥n sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br>  Cup√≥n de 25% de descuento para vendedores ambulantes - <b>Python</b> <br><br>  Tras el pago de la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/471520/">https://habr.com/ru/post/471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../471508/index.html">¬øAdministrador sin brazos = hiperconvergencia?</a></li>
<li><a href="../471512/index.html">28 de octubre, Ekaterimburgo - Comunicaci√≥n de calidad</a></li>
<li><a href="../471514/index.html">El t√≠tulo "Leer art√≠culos para usted". Enero - junio 2019</a></li>
<li><a href="../471516/index.html">Intel 665p: SSD con QLC NAND de 96 capas</a></li>
<li><a href="../471518/index.html">Apple en 2019 es Linux en 2000</a></li>
<li><a href="../471522/index.html">Askozia C√≥mo funciona Autoprovisioning Plug & Play</a></li>
<li><a href="../471524/index.html">Traducci√≥n completa de instrucciones para evaluadores Google</a></li>
<li><a href="../471528/index.html">Implemente aplicaciones con Docker Swarm</a></li>
<li><a href="../471530/index.html">GitLab recorri√≥ un camino inusual hacia CI / CD y Kubernetes</a></li>
<li><a href="../471532/index.html">Adi√≥s PCB; hola interconexi√≥n de silicio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>