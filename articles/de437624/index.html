<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèº ‚úãüèΩ üëß OpenSceneGraph: Texturgrundlagen üë®üèΩ‚Äçüî¨ üö£ üéΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Wir haben bereits ein Beispiel untersucht, in dem ein Quadrat in allen Farben des Regenbogens gemalt wurde. Dennoch gibt es eine andere T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Texturgrundlagen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437624/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><br><h1>  Einf√ºhrung </h1><br>  Wir haben bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> untersucht, in dem ein Quadrat in allen Farben des Regenbogens gemalt wurde.  Dennoch gibt es eine andere Technologie, n√§mlich die Anwendung auf die dreidimensionale Geometrie der sogenannten <em>Texturkarte</em> oder einfach nur Textur - ein zweidimensionales Rasterbild.  In diesem Fall wirkt sich der Effekt nicht auf die Scheitelpunkte der Geometrie aus, sondern die Daten aller Pixel, die w√§hrend der Rasterung der Szene erhalten werden, √§ndern sich.  Diese Technik kann den Realismus und die Details des endg√ºltigen Bildes erheblich verbessern. <br><br>  OSG unterst√ºtzt verschiedene Texturattribute und Texturierungsmodi.  Bevor wir jedoch √ºber Texturen sprechen, lassen Sie uns dar√ºber sprechen, wie OSG mit Bitmap-Bildern umgeht.  F√ºr die Arbeit mit Rasterbildern wird eine spezielle Klasse bereitgestellt - osg :: Image, in der Bilddaten gespeichert werden, die letztendlich zur Texturierung des Objekts bestimmt sind. <br><a name="habracut"></a><br><h1>  1. Pr√§sentation von Rasterbilddaten.  Osg class :: Image </h1><br>  Der beste Weg, ein Image von der Festplatte zu laden, ist die Verwendung des Aufrufs osgDB :: readImageFile ().  Es ist dem Aufruf von osg :: readNodeFile () sehr √§hnlich, der uns bereits gelangweilt hat.  Wenn wir eine Bitmap mit dem Namen picture.bmp haben, sieht das Laden folgenderma√üen aus <br><br><pre><code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>);</code> </pre> <br>  Wenn das Bild korrekt geladen ist, ist der Zeiger g√ºltig, andernfalls gibt die Funktion NULL zur√ºck.  Nach dem Herunterladen k√∂nnen wir Bildinformationen mit den folgenden √∂ffentlichen Methoden erhalten <br><br><ol><li>  t (), s () und r () - geben die Breite, H√∂he und Tiefe des Bildes zur√ºck. <br></li><li>  data () - gibt einen Zeiger vom Typ unsigned char * auf die "rohen" Bilddaten zur√ºck.  √úber diesen Zeiger kann der Entwickler direkt auf die Bilddaten reagieren.  Mit den Methoden getPixalFormat () und getDataType () k√∂nnen Sie sich ein Bild vom Bilddatenformat machen.  Die von ihnen zur√ºckgegebenen Werte entsprechen den Parametern des Formats und des Typs der OpenGL-Funktionen glTexImage * ().  Wenn das Bild beispielsweise das Pixelformat GL_RGB hat und der Typ GL_UNSIGNED_BYTE ist, werden drei unabh√§ngige Elemente (vorzeichenlose Bytes) verwendet, um die RGB-Farbkomponente darzustellen <br></li></ol><br><img src="https://habrastorage.org/webt/6g/mo/or/6gmoorwfvryg44pq7sdi0cb4l9s.png"><br><br>  Sie k√∂nnen ein neues Bildobjekt erstellen und Speicher daf√ºr zuweisen. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage(s, t, r, GL_RGB, GL_UNSIGNED_BYTE); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = image-&gt;data(); <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre><br>  Hier sind s, t, r Bildgr√∂√üen;  GL_RGB legt das Pixelformat fest und GL_UNSIGNED_BYTE legt den Datentyp fest, um eine einzelne Farbkomponente zu beschreiben.  Ein interner Datenpuffer der erforderlichen Gr√∂√üe wird im Speicher zugewiesen und automatisch zerst√∂rt, wenn keine einzige Verkn√ºpfung zu diesem Bild besteht. <br><br>  Das OSG-Plug-In-System unterst√ºtzt das Herunterladen fast aller g√§ngigen Bildformate: * .jpg, * .bmp, * .png, * .tif usw.  Diese Liste kann leicht erweitert werden, indem Sie Ihr eigenes Plugin schreiben. Dies ist jedoch ein Thema f√ºr eine andere Diskussion. <br><br><h1>  2. Die Grundlagen der Texturierung </h1><br>  Um eine Textur auf ein dreidimensionales Modell anzuwenden, m√ºssen Sie eine Reihe von Schritten ausf√ºhren: <br><br><ol><li>  Definieren Sie die Texturkoordinaten der Scheitelpunkte f√ºr das geometrische Objekt (in der Umgebung von 3D-Designern wird dies als UV-Scan bezeichnet). <br></li><li>  Erstellen Sie ein Texturattributobjekt f√ºr 1D-, 2D-, 3D- oder kubische Textur. <br></li><li>  Legen Sie ein oder mehrere Bilder f√ºr ein Texturattribut fest. <br></li><li>  F√ºgen Sie der Gruppe von Zust√§nden, die auf das zu zeichnende Objekt angewendet werden, ein Texturattribut und einen Modus hinzu. <br></li></ol><br>  OSG definiert die Klasse osg :: Texture, die alle Arten von Texturen kapselt.  Von diesen werden die Unterklassen osg :: Texture1D, osg :: Texture2D, osg :: Texture3D und osg :: TextureCubeMap geerbt, die verschiedene in OpenGL verwendete Texturierungstechniken darstellen. <br><br>  Die gebr√§uchlichste osg :: Texture-Klassenmethode ist setImage (), mit der beispielsweise das in der Textur verwendete Bild festgelegt wird <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setImage(image.get());</code> </pre><br>  Sie k√∂nnen das Bildobjekt auch direkt an den Konstruktor der Texturklasse √ºbergeben <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"picture.bmp"</span></span>); osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D(image.get());</code> </pre><br>  Das Bild kann durch Aufrufen der Methode getImage () aus dem Texturobjekt abgerufen werden. <br><br>  Ein weiterer wichtiger Punkt ist das Festlegen der Texturkoordinaten f√ºr jeden Scheitelpunkt im osg :: Geometry-Objekt.  Die √úbertragung dieser Koordinaten erfolgt √ºber das Array osg :: Vec2Array und osg :: Vec3Array durch Aufrufen der Methode setTexCoordArray (). <br><br>  Nach dem Festlegen der Texturkoordinaten m√ºssen wir die Texturschlitznummer (Einheit) festlegen, da OSG das √úberlagern mehrerer Texturen mit derselben Geometrie unterst√ºtzt.  Bei Verwendung einer einzelnen Textur ist die Einheitennummer immer 0. Der folgende Code veranschaulicht beispielsweise das Festlegen der Texturkoordinaten f√ºr die Einheit 0 der Geometrie <br><br><pre> <code class="cpp hljs">osf::ref_ptr&lt;osg::Vec2Array&gt; texcoord = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoord-&gt;push_back( osg::Vec2(...) ); ... geom-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoord.get());</code> </pre><br>  Danach k√∂nnen wir das Texturattribut zu der Gruppe von Zust√§nden hinzuf√ºgen, den entsprechenden Texturierungsmodus automatisch aktivieren (in unserem Beispiel GL_TEXTURE_2D) und das Attribut auf die Geometrie oder den Knoten anwenden, der diese Geometrie enth√§lt <br><br><pre> <code class="cpp hljs">geom-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(texture.get());</code> </pre><br>  Bitte beachten Sie, dass OpenGL die Bilddaten im Grafikspeicher der Grafikkarte verwaltet, sich jedoch das osg :: Image-Objekt zusammen mit denselben Daten im Systemspeicher befindet.  Infolgedessen werden wir feststellen, dass wir zwei Kopien derselben Daten gespeichert haben, die den Prozessspeicher belegen.  Wenn dieses Image nicht von mehreren Texturattributen gemeinsam genutzt wird, kann es sofort nach der √úbertragung durch OpenGL in den Videoadapterspeicher aus dem Systemspeicher gel√∂scht werden.  Die Klasse osg :: Texture bietet die entsprechende Methode, um diese Funktion zu aktivieren. <br><br><pre> <code class="cpp hljs">texture-&gt;setUnRefImageDataAfterApply( <span class="hljs-literal"><span class="hljs-literal">true</span></span> );</code> </pre> <br><h1>  3. Laden Sie eine 2D-Textur und wenden Sie sie an </h1><br>  Die am h√§ufigsten verwendete Technik ist die 2D-Texturierung - √úberlagern eines zweidimensionalen Bildes (oder von zweidimensionalen Bildern) am Rand einer dreidimensionalen Oberfl√§che.  Betrachten Sie das einfachste Beispiel f√ºr das Anwenden einer einzelnen Textur auf ein viereckiges Polygon <br><br><div class="spoiler">  <b class="spoiler_title">Texturbeispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet( new osg::DrawArrays(GL_QUADS, 0, 4) ); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad.get()); root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Erstellen Sie ein Array von Eckpunkten und Normalen zum Gesicht <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3( <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  Erstellen Sie ein Array von Texturkoordinaten <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) );</code> </pre><br>  Der Punkt ist, dass jeder Scheitelpunkt des dreidimensionalen Modells einem Punkt auf der zweidimensionalen Textur entspricht und die Koordinaten der Punkte auf der Textur relativ sind - sie werden auf die tats√§chliche Breite und H√∂he des Bildes normalisiert.  Wir wollen das gesamte geladene Bild auf ein Quadrat strecken, wobei die Ecken des Quadrats den Texturpunkten (0, 0), (0, 1), (1, 1) und (1, 0) entsprechen.  Die Reihenfolge der Scheitelpunkte im Scheitelpunktarray muss mit der Reihenfolge der Texturscheitelpunkte √ºbereinstimmen. <br><br>  Erstellen Sie als N√§chstes ein Quadrat und weisen Sie der Geometrie ein Array von Eckpunkten und ein Array von Normalen zu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) );</code> </pre><br>  Erstellen Sie ein Texturobjekt und laden Sie das daf√ºr verwendete Bild. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile(<span class="hljs-string"><span class="hljs-string">"../data/Images/lz.rgb"</span></span>); texture-&gt;setImage(image.get());</code> </pre><br>  Erstellen Sie den Wurzelknoten der Szene und f√ºgen Sie die dort erstellte Geometrie ein <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; root-&gt;addDrawable(quad.get());</code> </pre><br>  und schlie√ülich das Texturattribut auf den Knoten anwenden, in dem die Geometrie platziert ist <br><br><pre> <code class="cpp hljs">root-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br><img src="https://habrastorage.org/webt/wm/2a/fy/wm2afywfx6dnkhwaagvceqkycd8.png"><br><br>  Die Klasse osg :: Texture2D bestimmt mithilfe der OpenGL-Funktion gluScaleImage (), ob Texturbildgr√∂√üen ein Vielfaches der Zweierpotenz sind (z. B. 64 x 64 oder 256 x 512), und skaliert automatisch Bilder, die f√ºr die Gr√∂√üe ungeeignet sind.  Es gibt eine setResizeNonPowerOfTwoHint () -Methode, die bestimmt, ob die Bildgr√∂√üe ge√§ndert werden soll oder nicht.  Einige Grafikkarten erfordern ein Vielfaches der Gr√∂√üe eines Bildes mit der Potenz von zwei, w√§hrend die Klasse osg :: Texture2D das Arbeiten mit beliebigen Texturgr√∂√üen unterst√ºtzt. <br><br><h1>  Etwas √ºber das Mischen von Texturen </h1><br>  Wie bereits erw√§hnt, werden die Texturkoordinaten von 0 auf 1 normalisiert. Punkt (0, 0) entspricht der oberen linken Ecke des Bildes und Punkt (1, 1) entspricht der unteren rechten Ecke.  Was passiert, wenn Sie Texturkoordinaten gr√∂√üer als eins festlegen? <br><br>  Standardm√§√üig wird in OpenGL wie in OSG die Textur in Richtung der Achse wiederholt, der Wert der Texturkoordinate √ºberschreitet eins.  Diese Technik wird oft verwendet, um beispielsweise ein Modell einer langen Mauer zu erstellen. Ich verwende eine kleine Textur, die ihre √úberlagerung sowohl in der Breite als auch in der H√∂he viele Male wiederholt. <br><br>  Dieses Verhalten kann √ºber die setWrap () -Methode der Klasse osg :: Texture gesteuert werden.  Als ersten Parameter verwendet die Methode den Bezeichner der Achse, auf die der Mischmodus angewendet werden soll, beispielsweise als zweiten Parameter <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     s texture-&gt;setWrap( osg::Texture::WRAP_S, osg::Texture::REPEAT ); //     r texture-&gt;setWrap( osg::Texture::WRAP_R, osg::Texture::REPEAT );</span></span></code> </pre><br>  Dieser Code weist die Engine ausdr√ºcklich an, die Textur entlang der s- und r-Achse zu wiederholen, wenn die Texturkoordinatenwerte 1 √ºberschreiten. Eine vollst√§ndige Liste der Texturabbildungsmodi: <br><br><ol><li>  WIEDERHOLEN - Wiederholen Sie die Textur. <br></li><li>  SPIEGEL - Wiederholen Sie die Textur und spiegeln Sie sie. <br></li><li>  CLAMP_TO_EDGE - Koordinaten, die √ºber 0 bis 1 hinausgehen, werden an der entsprechenden Kante der Textur gefangen. <br></li><li>  CLAMP_TO_BORDER - Koordinaten, die √ºber 0 bis 1 hinausgehen, geben die vom Benutzer festgelegte Rahmenfarbe an. <br></li></ol><br><h1>  4. Rendern zur Textur </h1><br>  Die Textur-Rendering-Technik erm√∂glicht es dem Entwickler, eine Textur basierend auf einer dreidimensionalen Unterszene oder einem dreidimensionalen Modell zu erstellen und auf die Oberfl√§che in der Hauptszene anzuwenden.  Eine √§hnliche Technologie wird oft als Texturbacken bezeichnet. <br><br>  Um eine Textur dynamisch zu backen, m√ºssen Sie drei Schritte ausf√ºhren: <br><br><ol><li>  Erstellen Sie ein Texturobjekt, um es zu rendern. <br></li><li>  Rendern Sie die Szene in eine Textur. <br></li><li>  Verwenden Sie die resultierende Textur wie vorgesehen. <br></li></ol><br>  Wir m√ºssen ein leeres Texturobjekt erstellen.  Mit OSG k√∂nnen Sie eine leere Textur einer bestimmten Gr√∂√üe erstellen.  Mit der Methode setTextureSize () k√∂nnen Sie die Breite und H√∂he der Textur sowie die Tiefe als zus√§tzlichen Parameter festlegen (f√ºr 3D-Texturen). <br><br>  Um eine Textur zu rendern, sollten Sie sie an das Kameraobjekt anh√§ngen, indem Sie die Methode attach () aufrufen, die ein Texturobjekt als Argument verwendet.  Dar√ºber hinaus akzeptiert diese Methode ein Argument, das angibt, welcher Teil des Bildpuffers in diese Textur gerendert werden soll.  Um beispielsweise einen Farbpuffer in eine Textur zu √ºbertragen, sollten Sie den folgenden Code ausf√ºhren <br><br><pre> <code class="cpp hljs">camera-&gt;attach( osg::Camera::COLOR_BUFFER, texture.get() );</code> </pre><br>  Weitere Teile des f√ºr das Rendern verf√ºgbaren Bildpuffers sind der Tiefenpuffer DEPTH_BUFFER, der Schablonenpuffer STENCIL_BUFFER und zus√§tzliche Farbpuffer von COLOR_BUFFER0 bis COLOR_BUFFER15.  Das Vorhandensein zus√§tzlicher Farbpuffer und deren Anzahl wird durch das Modell der Grafikkarte bestimmt. <br><br>  Dar√ºber hinaus m√ºssen Sie f√ºr eine Kamera, die in eine Textur gerendert wird, die Parameter der Projektionsmatrix und des Ansichtsfensters festlegen, deren Gr√∂√üe der Gr√∂√üe der Textur entspricht.  Die Textur wird aktualisiert, wenn jeder Frame gezeichnet wird.  Beachten Sie, dass die Hauptkamera nicht zum Rendern in eine Textur verwendet werden sollte, da sie das Rendern der Hauptszene erm√∂glicht und Sie nur einen schwarzen Bildschirm erhalten.  Diese Anforderung wird m√∂glicherweise nicht nur erf√ºllt, wenn Sie ein Rendern au√üerhalb des Bildschirms durchf√ºhren. <br><br><h1>  5. Ein Beispiel f√ºr die Implementierung des Renderns in Textur </h1><br>  Um die Rendering-Technik in einer Textur zu demonstrieren, implementieren wir die folgende Aufgabe: Erstellen Sie ein Quadrat, zeichnen Sie eine quadratische Textur darauf und rendern Sie eine animierte Szene in die Textur, nat√ºrlich mit der Cessna, die wir lieben.  Das Programm, das das Beispiel implementiert, ist ziemlich umfangreich.  Ich werde jedoch trotzdem den vollst√§ndigen Quellcode angeben. <br><br><div class="spoiler">  <b class="spoiler_title">Texrender Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Camera&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad(const osg::Vec3 &amp;pos, float w, float h) { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, -h / 2) ); vertices-&gt;push_back( pos + osg::Vec3( w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, h / 2) ); vertices-&gt;push_back( pos + osg::Vec3(-w / 2, 0.0f, -h / 2) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back(osg::Vec3(0.0f, -1.0f, 0.0f)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = new osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(0.0, osg::Vec3(0.0f, 0.0f, 1.0f))); transform1-&gt;addChild(sub_model.get()); osg::ref_ptr&lt;osg::Geode&gt; model = new osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(0.0f, 0.0f, 0.0f), 2.0f, 2.0f)); int tex_widht = 1024; int tex_height = 1024; osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR); model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(0, texture.get()); osg::ref_ptr&lt;osg::Camera&gt; camera = new osg::Camera; camera-&gt;setViewport(0, 0, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get()); camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get()); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(0); camera-&gt;setProjectionMatrixAsPerspective(30.0, static_cast&lt;double&gt;(tex_widht) / static_cast&lt;double&gt;(tex_height), 0.1, 1000.0); float dist = 100.0f; float alpha = 10.0f * 3.14f / 180.0f; osg::Vec3 eye(0.0f, -dist * cosf(alpha), dist * sinf(alpha)); osg::Vec3 center(0.0f, 0.0f, 0.0f); osg::Vec3 up(0.0f, 0.0f, -1.0f); camera-&gt;setViewMatrixAsLookAt(eye, center, up); float phi = 0.0f; float delta = -0.01f; while (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(static_cast&lt;double&gt;(phi), osg::Vec3(0.0f, 0.0f, 1.0f))); viewer.frame(); phi += delta; } return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Um ein Quadrat zu erstellen, schreiben Sie eine separate freie Funktion <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> w, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> h)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3( w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); vertices-&gt;push_back( pos + osg::Vec3(-w / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, -h / <span class="hljs-number"><span class="hljs-number">2</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); texcoords-&gt;push_back( osg::Vec2(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(<span class="hljs-number"><span class="hljs-number">0</span></span>, texcoords.get()); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  Die Funktion akzeptiert die Position der Mitte des Quadrats und seine geometrischen Abmessungen als Eingabe.  Als n√§chstes wird ein Array von Eckpunkten, ein Array von Normalen und Texturkoordinaten erstellt, wonach die erstellte Geometrie von der Funktion zur√ºckgegeben wird. <br><br>  Laden Sie im Hauptteil des Hauptprogramms das Modell der Cessna <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; sub_model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg"</span></span>);</code> </pre><br>  Um dieses Modell zu animieren, erstellen und initialisieren Sie die Rotationstransformation um die Z-Achse <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; transform1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); transform1-&gt;addChild(sub_model.get());</code> </pre><br>  Erstellen Sie nun ein Modell f√ºr die Hauptszene - ein Quadrat, auf dem wir rendern werden <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Geode&gt; model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; model-&gt;addChild(createQuad(osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>));</code> </pre><br>  Erstellen Sie eine leere Textur f√ºr ein 1024 x 1024 Pixel gro√ües Quadrat mit einem RGBA-Pixelformat (32-Bit-Dreikomponentenfarbe mit Alphakanal). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_widht = <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tex_height = <span class="hljs-number"><span class="hljs-number">1024</span></span>; osg::ref_ptr&lt;osg::Texture2D&gt; texture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Texture2D; texture-&gt;setTextureSize(tex_widht, tex_height); texture-&gt;setInternalFormat(GL_RGBA); texture-&gt;setFilter(osg::Texture2D::MIN_FILTER, osg::Texture2D::LINEAR); texture-&gt;setFilter(osg::Texture2D::MAG_FILTER, osg::Texture2D::LINEAR);</code> </pre><br>  Wenden Sie diese Textur auf das quadratische Modell an. <br><br><pre> <code class="cpp hljs">model-&gt;getOrCreateStateSet()-&gt;setTextureAttributeAndModes(<span class="hljs-number"><span class="hljs-number">0</span></span>, texture.get());</code> </pre><br>  Erstellen Sie dann eine Kamera, die die Textur backt <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Camera&gt; camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Camera; camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, tex_widht, tex_height); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setClearMask(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</code> </pre><br>  Das Kamera-Ansichtsfenster hat dieselbe Gr√∂√üe wie die Textur.  Vergessen Sie au√üerdem nicht, die Hintergrundfarbe beim Reinigen des Bildschirms und der Reinigungsmaske festzulegen, um sowohl den Farbpuffer als auch den Tiefenpuffer zu l√∂schen.  Konfigurieren Sie als N√§chstes die Kamera so, dass sie in Textur gerendert wird <br><br><pre> <code class="cpp hljs">camera-&gt;setRenderOrder(osg::Camera::PRE_RENDER); camera-&gt;setRenderTargetImplementation(osg::Camera::FRAME_BUFFER_OBJECT); camera-&gt;attach(osg::Camera::COLOR_BUFFER, texture.get());</code> </pre><br>  Die Renderreihenfolge von PRE_RENDER gibt an, dass diese Kamera vor dem Rendern in der Hauptszene gerendert wird.  Geben Sie den FBO als Rendering-Ziel an und h√§ngen Sie unsere Textur an die Kamera an.  Jetzt richten wir die Kamera so ein, dass sie in einem absoluten Koordinatensystem arbeitet, und als Szene setzen wir unseren Teilbaum, den wir in eine Textur rendern m√∂chten: eine Rotationstransformation mit einem daran angeh√§ngten Cessna-Modell <br><br><pre> <code class="cpp hljs">camera-&gt;setReferenceFrame(osg::Camera::ABSOLUTE_RF); camera-&gt;addChild(transform1.get());</code> </pre><br>  Erstellen Sie einen Stammgruppenknoten, indem Sie das Hauptmodell (Quadrat) und eine Kamera-Verarbeitungstextur hinzuf√ºgen <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(model.get()); root-&gt;addChild(camera.get());</code> </pre><br>  Erstellen Sie einen Viewer und passen Sie ihn an <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setUpViewOnSingleScreen(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Richten Sie die Projektionsmatrix f√ºr die Kamera ein - eine perspektivische Projektion durch die Parameter der Schnittpyramide <br><br><pre> <code class="cpp hljs">camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_widht) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(tex_height), <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>);</code> </pre><br>  Wir haben eine Ansichtsmatrix erstellt, die die Position der Kamera im Raum in Bezug auf den Ursprung der Sub-Cessna festlegt <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = <span class="hljs-number"><span class="hljs-number">100.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">10.0f</span></span> * <span class="hljs-number"><span class="hljs-number">3.14f</span></span> / <span class="hljs-number"><span class="hljs-number">180.0f</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eye</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, -dist * cosf(alpha), dist * sinf(alpha))</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">center</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1.0f</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; camera-&gt;setViewMatrixAsLookAt(eye, center, up);</code> </pre><br>  Zum Schluss animieren und zeigen Sie die Szene an, indem Sie den Drehwinkel des Flugzeugs um die Z-Achse in jedem Bild √§ndern <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> phi = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> delta = <span class="hljs-number"><span class="hljs-number">-0.01f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!viewer.done()) { transform1-&gt;setMatrix(osg::Matrix::rotate(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(phi), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>))); viewer.frame(); phi += delta; }</code> </pre><br>  Als Ergebnis erhalten wir ein ziemlich interessantes Bild <br><br><img src="https://habrastorage.org/webt/se/g1/jr/seg1jrflbtmzfkb5cbtwys1hleg.gif"><br><br>  In diesem Beispiel haben wir einige Szenenanimationen implementiert. Beachten Sie jedoch, dass das Erweitern der run () - Schleife und das √Ñndern der Renderparameter vor oder nach dem Rendern des Frames eine unsichere Aktivit√§t ist, um den Zugriff auf Daten aus verschiedenen Streams zu organisieren.  Da OSG Multithread-Rendering verwendet, gibt es auch regelm√§√üige Mechanismen zum Einbetten eigener Aktionen in den Rendering-Prozess, die einen thread-sicheren Zugriff auf Daten erm√∂glichen. <br><br><h1>  6. Speichern Sie das Rendering-Ergebnis in einer Datei </h1><br>  OSG unterst√ºtzt die M√∂glichkeit, ein osg :: Image-Objekt an die Kamera anzuh√§ngen und den Inhalt des Bildpuffers im Bilddatenpuffer zu speichern.  Danach k√∂nnen diese Daten mit der Funktion osg :: writeImageFile () auf der Festplatte gespeichert werden <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Image&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Image; image-&gt;allocateImage( width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE ); camera-&gt;attach( osg::Camera::COLOR_BUFFER, image.get() ); ... osgDB::writeImageFile( *image, <span class="hljs-string"><span class="hljs-string">"saved_image.bmp"</span></span> );</code> </pre><br><h1>  Fazit </h1><br>  Vielleicht scheint das im Artikel vorgestellte Material trivial zu sein.  Es werden jedoch die Grundlagen der Arbeit mit Texturen in OpenSceneGraph beschrieben, auf denen komplexere Techniken f√ºr die Arbeit mit dieser Engine basieren, √ºber die wir in Zukunft definitiv sprechen werden. <br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437624/">https://habr.com/ru/post/de437624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437614/index.html">Das Iterator-Architekturmuster im schnellen Universum</a></li>
<li><a href="../de437616/index.html">Sechs Monate ohne Umsatzr√ºckgang von CEO und iPhone: Warum Intel-Aktien fallen</a></li>
<li><a href="../de437618/index.html">42 Google Advanced Search Operators (vollst√§ndige Liste)</a></li>
<li><a href="../de437620/index.html">Wie die Cloud-Technologie unsere Behandlung ver√§ndert</a></li>
<li><a href="../de437622/index.html">Erste Schritte mit dem Azure Machine Learning-Dienst</a></li>
<li><a href="../de437626/index.html">Handelsplattformleistung anhand eines einfachen Beispiels</a></li>
<li><a href="../de437630/index.html">Die wichtigsten Ank√ºndigungen von Microsoft von der BETT-Konferenz</a></li>
<li><a href="../de437632/index.html">Mash, die Grundlagen der Sprache</a></li>
<li><a href="../de437634/index.html">DIY Wireless Router</a></li>
<li><a href="../de437636/index.html">Ver√∂ffentlichung der App im Microsoft Store: einige √Ñnderungen f√ºr das Jahr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>