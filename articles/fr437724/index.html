<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé§ üßùüèº üë≥ OpenSceneGraph: Animation proc√©durale des attributs de g√©om√©trie et d'√©tat üéä ü§õüèæ üë©‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Parlant des techniques de programmation sp√©cifiques √† OSG , la derni√®re fois nous avons parl√© du m√©canisme de rappel et de son impl√©men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Animation proc√©durale des attributs de g√©om√©trie et d'√©tat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437724/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="image"><br><h1>  Pr√©sentation </h1><br>  Parlant des techniques de programmation sp√©cifiques √† OSG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, la derni√®re fois</a> nous avons parl√© du m√©canisme de rappel et de son impl√©mentation dans le moteur.  Il est temps d'examiner les possibilit√©s que ce m√©canisme offre pour g√©rer le contenu d'une sc√®ne en trois dimensions. <br><br>  Si nous parlons d'animation d'objet, OSG offre au d√©veloppeur deux options pour sa mise en ≈ìuvre: <br><br><ol><li>  Animation proc√©durale impl√©ment√©e par programmation gr√¢ce √† la transformation des objets et de leurs attributs </li><li>  Exporter l'animation √† partir d'un √©diteur 3D et la g√©rer √† partir du code d'application </li></ol><br>  Pour commencer, consid√©rez la premi√®re possibilit√©, comme la plus √©vidente.  Nous parlerons certainement de la seconde un peu plus tard. <br><a name="habracut"></a><br><h1>  1. Animation de morphing proc√©dural </h1><br>  Lors de la travers√©e du graphique de la sc√®ne, OSG transf√®re les donn√©es vers le pipeline OpenGL, qui s'ex√©cute dans un thread s√©par√©.  Ce thread doit √™tre synchronis√© avec d'autres threads de traitement dans chaque trame.  Sinon, la m√©thode frame () peut se terminer avant le traitement des donn√©es de g√©om√©trie.  Cela entra√Ænera un comportement impr√©visible du programme et des plantages.  OSG propose une solution √† ce probl√®me sous la forme de la m√©thode setDataVariance () de la classe osg :: Object, qui est la base de tous les objets jalons de la sc√®ne.  Vous pouvez d√©finir trois modes de traitement pour les objets <br><br><ol><li>  NON SP√âCIFI√â (par d√©faut) - OSG d√©termine ind√©pendamment l'ordre de traitement de l'objet. <br></li><li>  STATIQUE - l'objet est immuable et l'ordre de son traitement n'est pas important.  Acc√©l√®re consid√©rablement le rendu. <br></li><li>  DYNAMIQUE - l'objet doit √™tre trait√© avant le d√©but du rendu. <br></li></ol><br>  Ce param√®tre peut √™tre d√©fini √† tout moment en appelant <br><br><pre><code class="cpp hljs">node-&gt;setDataVariance( osg::Object::DYNAMIC );</code> </pre> <br>  La pratique g√©n√©ralement accept√©e consiste √† modifier la g√©om√©trie "√† la vol√©e", c'est-√†-dire √† modifier dynamiquement les coordonn√©es des sommets, des normales de couleur et des textures dans chaque image, pour obtenir une g√©om√©trie mutable.  Cette technique est appel√©e animation de morphing.  Dans ce cas, l'ordre de traitement de la g√©om√©trie est d√©terminant - toutes ses modifications doivent √™tre recalcul√©es avant le d√©but du dessin.  Pour illustrer cette astuce, nous modifions l√©g√®rement l'exemple carr√© color√©, for√ßant l'un de ses sommets √† tourner autour de l'axe X. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple Animquad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad() { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class DynamicQuadCallback : public osg::Drawable::UpdateCallback { public: virtual void update(osg::NodeVisitor *, osg::Drawable *drawable); }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = static_cast&lt;osg::Geometry *&gt;(drawable); if (!quad) return; osg::Vec3Array *vertices = static_cast&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); if (!vertices) return; osg::Quat quat(osg::PI * 0.01, osg::X_AXIS); vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(new DynamicQuadCallback); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Nous allons cr√©er un carr√© dans une fonction s√©par√©e <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  une description dont, en principe, n'est pas n√©cessaire, car nous avons fait de telles actions √† plusieurs reprises.  Pour modifier les sommets de ce carr√©, nous √©crivons la classe DynamicQuadCallback, l'h√©ritant de osg :: Drawable :: UpdateCallback <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicQuadCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Drawable::UpdateCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor *, osg::Drawable *drawable)</span></span></span></span>; };</code> </pre><br>  remplacer la m√©thode update () <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!quad) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!vertices) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>; vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); }</code> </pre><br>  Ici, nous obtenons un pointeur sur un objet g√©om√©trique <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable);</code> </pre><br>  on lit dans la g√©om√©trie une liste de sommets (ou plut√¥t un pointeur sur celle-ci) <br><br><pre> <code class="cpp hljs">osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray());</code> </pre><br>  Pour obtenir le dernier √©l√©ment (dernier sommet) du tableau, la classe osg :: Array fournit la m√©thode back ().  Pour effectuer la rotation du sommet par rapport √† l'axe X, nous introduisons le quaternion <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>;</code> </pre><br>  c'est-√†-dire que nous avons d√©fini un quaternion qui impl√©mente une rotation autour de l'axe X d'un angle de 0,01 * Pi.  Faire pivoter le sommet en multipliant le quaternion par un vecteur d√©finissant les coordonn√©es du sommet <br><br><pre> <code class="cpp hljs">vertices-&gt;back() = quat * vertices-&gt;back();</code> </pre><br>  Les deux derniers appels racontent la liste d'affichage et le parall√©l√©pip√®de dimensionnel pour la g√©om√©trie modifi√©e <br><br><pre> <code class="cpp hljs">quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound();</code> </pre><br>  Dans le corps de la fonction main (), nous cr√©ons un carr√©, d√©finissons le mode de dessin dynamique et ajoutons un rappel modifiant la g√©om√©trie <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicQuadCallback);</code> </pre><br>  Je vais quitter sans discernement la cr√©ation du n≈ìud racine et le lancement de la visionneuse, comme nous l'avons d√©j√† fait au moins vingt fois de diff√©rentes mani√®res.  En cons√©quence, nous avons l'animation de morphing la plus simple <br><br><img src="https://habrastorage.org/webt/rk/oy/rf/rkoyrfpjkx_kan0puqvyj1ocxps.gif"><br><br>  Essayez maintenant de supprimer (commenter) l'appel setDataVariance ().  Peut-√™tre que nous ne verrons rien de criminel dans ce cas - par d√©faut, OSG essaie de d√©terminer automatiquement quand mettre √† jour les donn√©es de g√©om√©trie, en essayant de se synchroniser avec le rendu.  Ensuite, essayez de changer le mode de DYNAMIQUE en STATIQUE et vous verrez que l'image ne s'affiche pas en douceur, avec des secousses, des erreurs et des avertissements notables comme celui-ci <br><br><pre> <code class="plaintext hljs">Warning: detected OpenGL error 'invalid value' at after RenderBin::draw(..)</code> </pre><br>  Si vous n'ex√©cutez pas la m√©thode dirtyDisplayList (), OpenGL ignorera toutes les modifications de la g√©om√©trie et utilisera la liste d'affichage cr√©√©e au tout d√©but pour cr√©er le carr√© pour le rendu.  Supprimez cet appel et vous verrez qu'il n'y a pas d'animation. <br><br>  Sans appeler la m√©thode dirtyBound (), la bo√Æte englobante ne sera pas recalcul√©e et OSG coupera incorrectement les faces invisibles. <br><br><h1>  2. Le concept d'interpolation de mouvement </h1><br>  Supposons qu'un train allant de la gare A √† la gare B prenne 15 minutes pour voyager.  Comment simuler cette situation en modifiant la position du train lors du rappel?  Le moyen le plus simple est de corr√©ler la position de la gare A avec l'heure 0 et de la gare B avec 15 minutes et de d√©placer le train de mani√®re √©gale entre ces heures.  Cette approche la plus simple est appel√©e interpolation lin√©aire.  En interpolation lin√©aire, un vecteur sp√©cifiant la position d'un point interm√©diaire est d√©crit par la formule <br><br><pre> <code class="plaintext hljs">p = (1 - t) * p0 + t * p1</code> </pre><br>  o√π p0 est le point de d√©part;  p1 est le point final;  t est un param√®tre qui varie uniform√©ment de 0 √† 1. Cependant, le mouvement du train est beaucoup plus compliqu√©: il quitte la gare A, acc√©l√®re, puis se d√©place √† vitesse constante, puis ralentit, s'arr√™te √† la gare B.Un tel processus ne peut plus d√©crire l'interpolation lin√©aire et √áa n'a pas l'air naturel. <br><br>  OSG fournit au d√©veloppeur la biblioth√®que osgAnimation, qui contient un certain nombre d'algorithmes d'interpolation standard utilis√©s pour animer en douceur le mouvement des objets de sc√®ne.  Chacune de ces fonctions a g√©n√©ralement deux arguments: la valeur initiale du param√®tre (g√©n√©ralement 0) et la valeur finale du param√®tre (g√©n√©ralement 1).  Ces fonctions peuvent √™tre appliqu√©es au d√©but du mouvement (InMotion), √† la fin du mouvement (OutMotion) ou au d√©but et √† la fin du mouvement (InOutMotion) <br><br><table><thead><tr><th>  Type de mouvement </th><th>  en classe </th><th>  en classe </th><th>  classe entr√©e / sortie </th></tr></thead><tbody><tr><td>  Interpolation lin√©aire </td><td>  LinearMotion </td><td>  - </td><td>  - </td></tr><tr><td>  Interpolation quadratique </td><td>  InQuadMotion </td><td>  OutQuadMotion </td><td>  InOutQuadMotion </td></tr><tr><td>  Interpolation cubique </td><td>  InCubicMotion </td><td>  Outcubicmotion </td><td>  InOutCubicMotion </td></tr><tr><td>  Interpolation √† 4 ordres </td><td>  InQuartMotion </td><td>  OutQuartMotion </td><td>  InOutQuartMotion </td></tr><tr><td>  Interpolation d'effet de rebond </td><td>  InBounceMotion </td><td>  OutBounceMotion </td><td>  InOutBounceMotion </td></tr><tr><td>  Interpolation de rebond √©lastique </td><td>  InElasticMotion </td><td>  OutElasticMotion </td><td>  InOutElasticMotion </td></tr><tr><td>  Interpolation sinuso√Ødale </td><td>  InSineMotion </td><td>  Outsinemotion </td><td>  InOutSineMotion </td></tr><tr><td>  Interpolation inverse </td><td>  Inbackmotion </td><td>  Outbackmotion </td><td>  InOutBackMotion </td></tr><tr><td>  Interpolation circulaire </td><td>  InCircMotion </td><td>  Outcircmotion </td><td>  InOutCircMotion </td></tr><tr><td>  Interpolation exponentielle </td><td>  InExpoMotion </td><td>  Outexpomotion </td><td>  InOutExpoMotion </td></tr></tbody></table><br>  Pour cr√©er une interpolation lin√©aire du mouvement d'un objet, nous √©crivons un tel code <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgAnimation::LinearMotion&gt; motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::LinearMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br><h1>  3. Animation des n≈ìuds de transformation </h1><br>  L'animation de trajectoire est le type d'animation le plus courant dans les applications graphiques.  Cette technique peut √™tre utilis√©e pour animer le mouvement d‚Äôune voiture, le vol d‚Äôun avion ou le mouvement d‚Äôune cam√©ra.  La trajectoire est pr√©d√©finie, avec toutes les positions, rotations et changements d'√©chelle √† des moments cl√©s.  Lorsque le cycle de simulation d√©marre, l'√©tat de l'objet est recalcul√© dans chaque image, en utilisant une interpolation lin√©aire pour la position et la mise √† l'√©chelle et une interpolation lin√©aire sph√©rique pour les quaternions de rotation.  Pour ce faire, utilisez la m√©thode interne slerp () de la classe osg :: Quat. <br><br>  OSG fournit la classe osg :: AnimationPath pour d√©crire un chemin variant dans le temps.  La m√©thode de cette classe insert () est utilis√©e pour ajouter √† la trajectoire des points de contr√¥le correspondant √† certains points dans le temps.  Le point de contr√¥le est d√©crit par la classe osg :: AnimationPath :: ControlPoint, dont le constructeur prend la position comme param√®tres et, √©ventuellement, les param√®tres de rotation et de mise √† l'√©chelle de l'objet.  Par exemple <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;insert(t1, osg::AnimationPath::ControlPoint(pos1, rot1, scale1)); path-&gt;insert(t2, ...);</code> </pre><br>  Ici t1, t2 sont des instants de temps en secondes;  rot1 est le param√®tre de rotation √† l'instant t1, d√©crit par le quaternion osg :: Quat. <br><br>  Il est possible de contr√¥ler les boucles d'animation via la m√©thode setLoopMode ().  Par d√©faut, le mode LOOP est activ√© - l'animation sera r√©p√©t√©e en continu.  Autres valeurs possibles: NO_LOOPING - joue l'animation une fois et SWING - boucle le mouvement dans les directions avant et arri√®re. <br><br>  Une fois l'initialisation termin√©e, nous attachons l'objet osg :: AnimationPath √† l'objet int√©gr√© osg :: AnimationPathCallback, qui est d√©riv√© de la classe osg :: NodeCallback. <br><br><h1>  4. Un exemple d'animation de mouvement le long d'un chemin </h1><br>  Nous allons maintenant faire bouger notre cessna dans un cercle avec le centre au point (0,0,0).  La position de l'avion sur la trajectoire sera calcul√©e en interpolant lin√©airement la position et l'orientation entre les images cl√©s. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple Animcessna</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/AnimationPath&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::AnimationPath *createAnimationPath(double radius, double time) { osg::ref_ptr&lt;osg::AnimationPath&gt; path = new osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); unsigned int numSamples = 32; double delta_yaw = 2.0 * osg::PI / (static_cast&lt;double&gt;(numSamples) - 1.0); double delta_time = time / static_cast&lt;double&gt;(numSamples); for (unsigned int i = 0; i &lt; numSamples; ++i) { double yaw = delta_yaw * i; osg::Vec3d pos(radius * sin(yaw), radius * cos(yaw), 0.0); osg::Quat rot(-yaw, osg::Z_AXIS); path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } return path.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg.0,0,90.rot"); osg::ref_ptr&lt;osg::MatrixTransform&gt; root = new osg::MatrixTransform; root-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = new osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(50.0, 6.0)); root-&gt;setUpdateCallback(apcb.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Nous commen√ßons par cr√©er la trajectoire de l'avion, en prenant ce code dans une fonction distincte <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">AnimationPath *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAnimationPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.release(); }</code> </pre><br>  Comme param√®tres, la fonction prend le rayon du cercle le long duquel l'avion se d√©place et le temps pendant lequel il fera un tour.  √Ä l'int√©rieur de la fonction, cr√©ez un objet trajectoire et activez le mode de boucle d'animation <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP);</code> </pre><br>  Code suivant <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples);</code> </pre><br>  calcule les param√®tres d'approximation de la trajectoire.  Nous divisons la trajectoire enti√®re en numSamples de sections droites et calculons le changement de l'angle de rotation du plan autour de l'axe vertical (lacet) delta_yaw et le changement de temps delta_time lors du passage d'une section √† l'autre.  Cr√©ez maintenant les points de contr√¥le n√©cessaires <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); }</code> </pre><br>  Dans le cycle, toutes les sections de la trajectoire de la premi√®re √† la derni√®re sont tri√©es.  Chaque point de contr√¥le est caract√©ris√© par un angle de lacet <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i;</code> </pre><br>  la position du centre de masse de l'a√©ronef dans l'espace <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  La rotation de l'avion √† l'angle de lacet souhait√© (par rapport √† l'axe vertical) est r√©gl√©e par le quaternion <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>;</code> </pre><br>  puis ajoutez les param√®tres calcul√©s √† la liste des points de contr√¥le du chemin <br><br><pre> <code class="cpp hljs">path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot));</code> </pre><br>  Dans le programme principal, nous pr√™tons attention √† la nuance en indiquant le nom du fichier de mod√®le d'avion au d√©marrage <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  - un suffixe ".0,0,90.rot" a √©t√© ajout√© au nom du fichier.  Le m√©canisme de chargement de la g√©om√©trie √† partir d'un fichier utilis√© dans OSG vous permet de sp√©cifier la position et l'orientation initiales du mod√®le apr√®s le chargement.  Dans ce cas, nous voulons que le mod√®le pivote de 90 degr√©s autour de l'axe Z apr√®s le chargement. <br><br>  Ensuite, le n≈ìud racine est cr√©√©, qui est le n≈ìud de transformation, et l'objet mod√®le lui est ajout√© en tant que n≈ìud enfant <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; root-&gt;addChild(model.get());</code> </pre><br>  Cr√©ez maintenant un rappel d'animation de trajectoire, en y ajoutant le chemin cr√©√© par la fonction createAnimationPath () <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(<span class="hljs-number"><span class="hljs-number">50.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>));</code> </pre><br>  Attachez ce rappel au n≈ìud de transformation <br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback(apcb.get());</code> </pre><br>  Le visualiseur est initialis√© et lanc√© comme d'habitude. <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Obtenez une animation de mouvement d'avion <br><br><img src="https://habrastorage.org/webt/ax/01/rl/ax01rlkfna5cfkvzqk3qfao_lmq.gif"><br><br>  Vous pensez que vous n'avez rien trouv√© d'√©trange dans cet exemple?  Auparavant, par exemple, dans un programme lors du rendu en texture, vous avez explicitement modifi√© la matrice de transformation pour obtenir un changement de position du mod√®le dans l'espace.  Ici, nous cr√©ons simplement un n≈ìud de transformation et dans le code, il n'y a aucune affectation de matrice explicite nulle part. <br><br>  Le secret est que la classe sp√©ciale osg :: AnimationPathCallback fait ce travail.  Conform√©ment √† la position actuelle de l'objet sur le chemin, il calcule la matrice de transformation et l'applique automatiquement au noeud de transformation auquel il est attach√©, ce qui √©vite au d√©veloppeur un tas d'op√©rations de routine. <br><br>  Il convient de noter que la connexion d'osg :: AnimationPathCallback √† d'autres types de n≈ìuds n'aura pas seulement aucun effet, mais peut √©galement conduire √† un comportement de programme non d√©fini.  Il est important de se rappeler que ce rappel n'affecte que les n≈ìuds de transformation. <br><br><h1>  5. Animation du contr√¥le logiciel </h1><br>  La classe osg :: AnimationPathCallback fournit des m√©thodes pour contr√¥ler l'animation pendant l'ex√©cution du programme. <br><br><ol><li>  reset () - r√©initialise l'animation et la joue d'abord. <br></li><li>  setPause () - interrompt l'animation.  Prend une valeur bool√©enne comme param√®tre <br></li><li>  setTimeOffset () - d√©finit le d√©calage temporel avant le d√©but de l'animation. <br></li><li>  setTimeMultiplier () - d√©finit le facteur de temps pour l'acc√©l√©ration / d√©c√©l√©ration de l'animation. <br></li></ol><br>  Par exemple, pour supprimer l'animation de la pause et de la r√©initialisation, nous ex√©cutons ce code <br><br><pre> <code class="cpp hljs">apcb-&gt;setPause(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); apcb-&gt;reset();</code> </pre><br>  et pour d√©marrer l'animation √† partir de la quatri√®me seconde apr√®s avoir d√©marr√© le programme avec une double acc√©l√©ration, un tel code <br><br><pre> <code class="cpp hljs">apcb-&gt;setTimeOffset(<span class="hljs-number"><span class="hljs-number">4.0f</span></span>); apcb-&gt;setTimeMultiplier(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>);</code> </pre><br><h1>  6. L'ordre de rendu des primitives dans OpenGL </h1><br>  OpenGL stocke les sommets et les donn√©es primitives dans divers tampons, tels qu'un tampon de couleur, un tampon de profondeur, un tampon de gabarit, etc.  De plus, il n'√©crase pas les sommets et faces triangulaires d√©j√† envoy√©s √† son pipeline.  Cela signifie qu'OpenGL cr√©e une nouvelle g√©om√©trie, quelle que soit la fa√ßon dont la g√©om√©trie existante a √©t√© cr√©√©e.  Cela signifie que l'ordre dans lequel les primitives sont envoy√©es au pipeline de rendu affecte de mani√®re significative le r√©sultat final que nous voyons √† l'√©cran. <br><br>  Sur la base des donn√©es du tampon de profondeur, OpenGL dessine correctement les objets opaques, triant les pixels en fonction de leur distance par rapport √† l'observateur.  Cependant, lors de l'utilisation de la technique de m√©lange de couleurs, par exemple, lors de la mise en ≈ìuvre d'objets transparents et translucides, une op√©ration sp√©ciale sera effectu√©e pour mettre √† jour le tampon de couleurs.  Les nouveaux et anciens pixels de l'image sont m√©lang√©s, en tenant compte de la valeur du canal alpha (quatri√®me composante de couleur).  Cela conduit au fait que l'ordre de rendu des bords translucides et opaques affecte le r√©sultat final <br><br><img src="https://habrastorage.org/webt/tz/3w/o4/tz3wo4dfy14oscogqvrb1akmh5m.png"><br><br>  Sur la figure, dans la situation de gauche, des objets d'abord opaques puis transparents ont √©t√© envoy√©s au pipeline, ce qui a conduit au d√©calage correct du tampon de couleurs et √† l'affichage correct des visages.  Dans la bonne situation, les premiers objets transparents ont √©t√© dessin√©s, puis opaques, ce qui a conduit √† un affichage incorrect. <br><br>  La m√©thode setRenderingHint () de la classe osg :: StateSet indique √† OSG l'ordre de rendu requis des n≈ìuds et des objets g√©om√©triques, si cela doit √™tre fait explicitement.  Cette m√©thode indique simplement si les visages translucides doivent ou non √™tre pris en compte lors du rendu, garantissant ainsi que s'il y a des visages translucides dans la sc√®ne, les visages opaques puis transparents seront dessin√©s en premier, en tenant compte de la distance de l'observateur.  Pour informer le moteur que ce n≈ìud est opaque, nous utilisons ce code <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::OPAQUE_BIN);</code> </pre><br>  ou contient des bords transparents <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br><h1>  7. Un exemple de mise en ≈ìuvre d'objets translucides </h1><br>  Essayons d'illustrer toute l'introduction th√©orique ci-dessus avec un exemple concret de mise en ≈ìuvre d'un objet translucide. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de transparence</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/BlendFunc&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 0.5f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = new osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); osg::StateSet *stateset = geode-&gt;getOrCreateStateSet(); stateset-&gt;setTextureAttributeAndModes(0, texture.get()); stateset-&gt;setAttributeAndModes(blendFunc); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Pour la plupart, le code pr√©sent√© ici ne contient rien de nouveau: deux objets g√©om√©triques sont cr√©√©s - un carr√© textur√© et un deltaplane, dont le mod√®le est charg√© √† partir d'un fichier.  Cependant, nous appliquons une couleur blanche translucide √† tous les sommets du carr√© <br><br><pre> <code class="cpp hljs">colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre><br>  - la valeur du canal alpha est de 0,5, ce qui, lorsqu'il est m√©lang√© avec des couleurs de texture, devrait donner l'effet d'un objet translucide.  En outre, la fonction de fusion des couleurs doit √™tre d√©finie pour le traitement de la transparence. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre><br>  le passer √† la machine d'√©tat OpenGL <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(blendFunc);</code> </pre><br>  Lors de la compilation et de l'ex√©cution de ce programme, nous obtenons le r√©sultat suivant <br><br><img src="https://habrastorage.org/webt/_m/mz/kz/_mmzkzrmxvmfll-qi0xli6wq_5g.png"><br><br>  Arr√™te √ßa!  Et o√π est la transparence?  Le fait est que nous avons oubli√© de dire au moteur que les bords transparents doivent √™tre trait√©s, ce qui est facilement r√©solu en appelant <br><br><pre> <code class="cpp hljs">stateset-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br>  apr√®s quoi nous obtenons le r√©sultat dont nous avons besoin - l'aile de deltaplane brille √† travers un carr√© textur√© translucide <br><br><img src="https://habrastorage.org/webt/py/bl/ta/pybltaqa6xkligouodxgunwoyvs.png"><br><br>  Les param√®tres des fonctions de m√©lange GL_SRC_ALPHA et GL_ONE_MINUS_SRC_ALPHA signifient que le pixel d'√©cran r√©sultant lors du dessin d'une face translucide aura des composantes de couleur calcul√©es par la formule <br><br><pre> <code class="plaintext hljs">R = srcR * srcA + dstR * (1 - srcA) G = srcG * srcA + dstG * (1 - srcA) B = srcB * srcA + dstB * (1 - srcA)</code> </pre><br>  o√π [srcR, srcG, srcB] sont les composantes de couleur de la texture carr√©e; [dstR, dstG, dstB] ‚Äî           ,    ,            .  srcA  -  . <br><br>  seRenderingHint()    ,      ,             .         ,        . <br><br><h1> 8.    </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'aide de l'animation, vous pouvez √©galement contr√¥ler les attributs d'√©tat. </font><font style="vertical-align: inherit;">Une multitude d'effets visuels peuvent √™tre g√©n√©r√©s en modifiant les propri√©t√©s d'un ou plusieurs attributs de rendu. </font><font style="vertical-align: inherit;">Ce type d'animation qui modifie l'√©tat des attributs de rendu est facile √† impl√©menter via le m√©canisme de rappel lors de la mise √† jour de la sc√®ne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des classes d'interpolations standard peuvent √©galement √™tre utilis√©es pour sp√©cifier la fonction de modification des param√®tres d'attribut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons d√©j√† de l'exp√©rience dans la cr√©ation d'objets translucides. </font><font style="vertical-align: inherit;">Nous savons que si la composante alpha de la couleur est nulle, nous obtenons un objet compl√®tement transparent, avec une valeur de 1 - compl√®tement opaque. </font><font style="vertical-align: inherit;">Il est clair qu'en faisant varier ce param√®tre de 0 √† 1 dans le temps, l'effet de l'apparition ou de la disparition progressive d'un objet peut √™tre obtenu. </font><font style="vertical-align: inherit;">Nous illustrons cela avec un exemple concret.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple de fondu</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/BlendFunc&gt; #include &lt;osg/Material&gt; #include &lt;osgAnimation/EaseMotion&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AlphaFadingCallback : public osg::StateAttributeCallback { public: AlphaFadingCallback() { _motion = new osgAnimation::InOutCubicMotion(0.0f, 1.0f); } virtual void operator() (osg::StateAttribute* , osg::NodeVisitor*); protected: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void AlphaFadingCallback::operator()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (void) nv; osg::Material *material = static_cast&lt;osg::Material *&gt;(sa); if (material) { _motion-&gt;update(0.0005f); float alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, alpha)); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(-0.5f, 0.0f, -0.5f), osg::Vec3(1.0f, 0.0f, 0.0f), osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Material&gt; material = new osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, 0.5f)); material-&gt;setUpdateCallback(new AlphaFadingCallback); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get()); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(new osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>     -   -   <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlphaFadingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::StateAttributeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::StateAttribute* , osg::NodeVisitor*)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; };</code> </pre><br>   _motion    ,        .       ,    ,    <br><br><pre> <code class="cpp hljs">AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre><br>         <br><br><img src="https://habrastorage.org/webt/ej/gd/cr/ejgdcr97gkb0lru6evved46sk6q.png"><br><br>    InOutCubicMotion       0  1.   operator()      <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AlphaFadingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) nv; osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (material) { _motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha)); } }</code> </pre><br>     <br><br><pre> <code class="cpp hljs">osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa);</code> </pre><br>  callback    ,       ,      ,          .         ‚Äî   ,           <br><br><pre> <code class="cpp hljs">_motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>);</code> </pre><br>     <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue();</code> </pre><br>        <br><br><pre> <code class="cpp hljs">material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha));</code> </pre><br>      main().           ,    ‚Äî      OSG <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier param√®tre est le point √† partir duquel le coin inf√©rieur gauche du carr√© sera construit, les deux autres param√®tres sp√©cifient les coordonn√©es des diagonales. </font><font style="vertical-align: inherit;">Apr√®s avoir compris le carr√©, nous cr√©ons du mat√©riel pour lui</font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Material&gt; material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous indiquons les options de couleur du mat√©riau. </font><font style="vertical-align: inherit;">La couleur ambiante est un param√®tre qui caract√©rise la couleur du mat√©riau dans la zone ombr√©e, inaccessible aux sources de couleur. </font><font style="vertical-align: inherit;">La couleur diffuse est la couleur propre du mat√©riau, qui caract√©rise la capacit√© d'une surface √† dissiper la couleur qui y tombe, c'est-√†-dire ce que nous appelons la couleur dans la vie quotidienne. </font><font style="vertical-align: inherit;">Le param√®tre FRONT_AND_BACK indique que cet attribut de couleur est affect√© aux c√¥t√©s avant et arri√®re des faces de la g√©om√©trie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez un mat√©riau au gestionnaire pr√©c√©demment cr√©√©.</font></font><br><br><pre> <code class="cpp hljs">material-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AlphaFadingCallback);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attribuer le mat√©riau cr√©√© au carr√© </font></font><br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get());</code> </pre><br>     ‚Äî     ,       <br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br>       <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/glider.osg"</span></span>)); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>          <br><br><img src="https://habrastorage.org/webt/s5/jv/1h/s5jv1h_ebaecadz6owo60nnrdvg.gif"><br><br><h1>  :     </h1><br>     ,     .    ‚Äì        main.h <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgAnimation/EaseMotion&gt;</span></span></span></span></code> </pre><br>   OSG,     ,     ,       ,   .    osgAnimation/      ,           ,   (       ) <br><br><pre> <code class="cmake hljs">LIBS += -losgAnimation</code> </pre><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437724/">https://habr.com/ru/post/fr437724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437712/index.html">Station spatiale Roskomnadzor</a></li>
<li><a href="../fr437714/index.html">Nous dessinons une explosion de dessin anim√© pour 180 lignes de C ++ nu</a></li>
<li><a href="../fr437716/index.html">Trois fa√ßons relativement honn√™tes de cr√©er un projet Flutter</a></li>
<li><a href="../fr437720/index.html">La lutte pour des solutions de qualit√© √† Erlang / Elixir</a></li>
<li><a href="../fr437722/index.html">Cons√©quences cosmiques du d√©mant√®lement am√©ricain</a></li>
<li><a href="../fr437726/index.html">S√©rialisation de Kotlin avec Kotlinx.</a></li>
<li><a href="../fr437730/index.html">Comment nous avons r√©solu le probl√®me de m√©moire dans PostgreSQL sans ajouter d'octet</a></li>
<li><a href="../fr437732/index.html">Pr√©sentation de l'imprimante MakeX M-One Pro 70 DLP</a></li>
<li><a href="../fr437734/index.html">Configuration de l'IPTV depuis Rostelecom sur les routeurs MikroTik</a></li>
<li><a href="../fr437736/index.html">Comment nous avons automatis√© le lancement des tests Selenium via Moon et OpenShift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>