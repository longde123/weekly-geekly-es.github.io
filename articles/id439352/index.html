<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👩‍👦‍👦 👨🏼‍✈️ 🤹🏻 Membuat bot prototipe untuk pertempuran di Clash Royale 👴🏽 #⃣ 💪🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah itu terjadi pada Anda bahwa Anda tetap berpegang pada semacam permainan sederhana, berpikir bahwa kecerdasan buatan dapat mengatasinya? Saya du...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat bot prototipe untuk pertempuran di Clash Royale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/binarydistrict/blog/439352/">  Apakah itu terjadi pada Anda bahwa Anda tetap berpegang pada semacam permainan sederhana, berpikir bahwa kecerdasan buatan dapat mengatasinya?  Saya dulu, dan saya memutuskan untuk mencoba membuat pemain bot seperti itu.  Selain itu, sekarang ada banyak alat untuk visi komputer dan pembelajaran mesin yang memungkinkan Anda untuk membangun model tanpa pemahaman mendalam tentang detail implementasi.  Manusia biasa dapat membuat prototipe tanpa membangun jaringan saraf selama berbulan-bulan dari awal. <br><br><img src="https://habrastorage.org/webt/fs/7g/yb/fs7gyb9v-o6bessxnliwetns8u0.png"><br><br>  Di bawah potongan Anda akan menemukan proses menciptakan bot proof-of-concept untuk game Clash Royale, di mana saya menggunakan perpustakaan Scala, Python dan CV.  Menggunakan visi komputer dan pembelajaran mesin, saya mencoba membuat bot untuk permainan yang berinteraksi seperti pemain hidup. <br><a name="habracut"></a><br>  Nama saya Sergey Tolmachev, saya Pimpinan Pengembang Scala di Waves Platform dan mengajar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus Scala</a> di Distrik Biner, dan di waktu senggang saya mempelajari teknologi lain, seperti AI.  Dan saya ingin memperkuat keterampilan yang diperoleh dengan beberapa pengalaman praktis.  Tidak seperti kompetisi AI, di mana bot Anda bermain melawan bot pengguna lain, Clash Royale dapat bermain melawan orang-orang, yang terdengar lucu.  Bot Anda bisa belajar mengalahkan pemain sungguhan! <br><br><h2>  Mekanik game di Clash Royale </h2><br>  Mekanik gim ini cukup sederhana.  Anda dan lawan Anda memiliki tiga bangunan: benteng dan dua menara.  Para pemain sebelum permainan mengumpulkan deck - 8 unit yang tersedia, yang kemudian digunakan dalam pertempuran.  Mereka memiliki level yang berbeda, dan mereka dapat dipompa, mengumpulkan lebih banyak kartu dari unit-unit ini dan membeli pembaruan. <br>  Setelah dimulainya permainan, Anda dapat menempatkan unit yang tersedia pada jarak yang aman dari menara musuh, sambil menghabiskan unit mana, yang perlahan-lahan dipulihkan selama permainan.  Unit dikirim ke bangunan musuh dan terganggu oleh musuh yang ditemui di sepanjang jalan.  Pemain hanya dapat mengontrol posisi awal unit - ia dapat mempengaruhi pergerakan lebih lanjut dan kerusakan hanya dengan mengatur unit lainnya. <br><br>  Masih ada mantra yang dapat dimainkan di mana saja di lapangan, mereka biasanya menyebabkan kerusakan pada unit dengan cara yang berbeda.  Mantra dapat mengkloning, membekukan, atau mempercepat unit di suatu daerah. <br><br><img src="https://habrastorage.org/webt/bk/xs/s2/bkxss2pfmjmvheqvnex86yy2wdk.png"><br><br>  Tujuan permainan ini adalah untuk menghancurkan bangunan musuh.  Untuk kemenangan penuh, Anda harus menghancurkan benteng atau setelah dua menit permainan menghancurkan lebih banyak bangunan (aturannya tergantung pada mode permainan, tetapi secara umum mereka terdengar seperti ini). <br><br>  Selama permainan, Anda harus memperhitungkan pergerakan unit, jumlah mana yang mungkin dan kartu musuh saat ini.  Anda juga perlu mempertimbangkan bagaimana pemasangan unit memengaruhi lapangan bermain. <br><br><h2>  Membangun solusi </h2><br>  Clash Royale adalah game mobile, jadi saya memutuskan untuk menjalankannya di Android dan berinteraksi dengannya melalui ADB.  Ini akan mendukung pekerjaan dengan simulator atau dengan perangkat nyata. <br><br>  Saya memutuskan bahwa bot, seperti banyak AI game lainnya, harus bekerja pada algoritma Persepsi-Analisis-Tindakan.  Seluruh lingkungan dalam permainan ditampilkan di layar, dan interaksi dengannya terjadi dengan mengeklik layar.  Oleh karena itu, bot harus berupa program, input yang menggambarkan kondisi permainan saat ini: lokasi dan karakteristik unit dan bangunan, kemungkinan kartu saat ini, dan jumlah mana.  Pada output, bot harus memberikan array koordinat di mana unit harus direkam. <br><br>  Tetapi sebelum membuat bot itu sendiri, perlu untuk menyelesaikan masalah mengekstraksi informasi tentang kondisi saat ini permainan dari tangkapan layar.  Pada umumnya, isi artikel selanjutnya dikhususkan untuk tugas ini. <br><br>  Untuk mengatasi masalah ini, saya memutuskan untuk menggunakan Computer Vision.  Mungkin ini bukan solusi terbaik: CV tanpa banyak pengalaman dan sumber daya jelas memiliki keterbatasan dan tidak dapat mengenali semuanya di tingkat manusia. <br><br>  Akan lebih akurat untuk mengambil data dari memori, tetapi saya tidak memiliki pengalaman seperti itu.  Root diperlukan dan secara keseluruhan solusi ini terlihat lebih rumit.  Juga tidak jelas apakah kecepatan sekitar waktu nyata dapat dicapai di sini jika Anda mencari objek dengan tumpukan JVM di dalam perangkat.  Selain itu, saya ingin menyelesaikan masalah CV lebih dari ini. <br>  Secara teori, seseorang dapat membuat server proxy dan mengambil informasi dari sana.  Tetapi protokol jaringan permainan sering berubah, proksi di Internet datang, tetapi dengan cepat menjadi usang dan tidak didukung. <br><br><h2>  Sumber Daya Game yang tersedia </h2><br>  Untuk mulai dengan, saya memutuskan untuk berkenalan dengan materi yang tersedia dari permainan.  Saya menemukan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klub pengrajin</a> menarik keluar sumber daya permainan dikemas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> .  Pertama-tama, saya tertarik pada gambar unit, tetapi dalam paket game yang tidak dibungkus, mereka disajikan dalam bentuk peta petak (bagian-bagiannya terdiri dari unit). <br><br>  Saya juga menemukan skrip frame animasi unit terpaku (meskipun tidak sempurna) - mereka berguna untuk melatih model pengenalan. <br><br><img src="https://habrastorage.org/webt/b_/bp/zm/b_bpzm14pv9snavxmruq0k5q0cm.png"><br><br>  Selain itu, dalam sumber daya Anda dapat menemukan csv dengan berbagai data permainan - jumlah HP, kerusakan unit dari berbagai tingkat, dll. Ini berguna saat membuat logika bot.  Misalnya, dari data menjadi jelas bahwa bidang itu dibagi menjadi 18 x 29 sel, dan unit hanya dapat ditempatkan pada mereka.  Ada juga semua gambar peta unit, yang akan berguna bagi kita nanti. <br><br><h2>  Visi Komputer untuk Malas </h2><br>  Setelah mencari solusi-CV yang tersedia, menjadi jelas bahwa dalam kasus apa pun, mereka harus dilatih tentang dataset berlabel.  Saya mengambil tangkapan layar dan sudah siap untuk menandai sejumlah tangkapan layar dengan tangan saya.  Ini ternyata menjadi tantangan. <br><br>  Menemukan program pengenalan yang tersedia membutuhkan waktu.  Saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">labelImg</a> .  Semua aplikasi anotasi yang saya temukan cukup primitif: banyak yang tidak mendukung pintasan keyboard, pemilihan objek dan tipenya dibuat jauh lebih tidak nyaman daripada di labelImg. <br><br>  Saat markup, ternyata bermanfaat untuk memiliki kode sumber aplikasi.  Saya mengambil screenshot setiap beberapa detik dari pertandingan.  Ada banyak objek di tangkapan layar (misalnya, sepasukan kerangka), dan saya membuat modifikasi pada labelImg - secara default, saat menandai gambar berikutnya, label dari yang sebelumnya diambil.  Seringkali, mereka hanya harus dipindahkan ke posisi baru unit, menghapus unit yang mati dan menambahkan beberapa muncul, dan tidak menandai dari awal. <br><br><img src="https://habrastorage.org/webt/cx/dh/rf/cxdhrf-uctqed-l84x2mg_9j4u8.png"><br><br>  Prosesnya ternyata memakan banyak sumber daya - dalam dua hari dalam mode senyap, saya memposting sekitar 200 tangkapan layar.  Sampel terlihat sangat kecil, tetapi saya memutuskan untuk mulai bereksperimen.  Anda selalu dapat menambahkan lebih banyak contoh dan meningkatkan kualitas model. <br><br>  Pada saat markup, saya tidak tahu alat pelatihan apa yang akan saya gunakan, jadi saya memutuskan untuk menyimpan hasil markup dalam format VOC - salah satu yang konservatif dan tampaknya universal. <br><br>  Pertanyaannya mungkin timbul: mengapa tidak mencari gambar unit demi piksel secara kebetulan saja?  Masalahnya adalah bahwa untuk yang satu ini harus mencari sejumlah besar frame animasi yang berbeda dari unit yang berbeda.  Itu tidak akan berhasil.  Saya ingin membuat solusi universal yang mendukung berbagai izin.  Selain itu, unit dapat memiliki warna yang berbeda tergantung pada efek yang diterapkan padanya - pembekuan, akselerasi. <br><br><h2>  Mengapa saya memilih YOLO </h2><br>  Saya mulai mengeksplorasi kemungkinan solusi pengenalan gambar.  Saya melihat penerapan berbagai algoritma: OpenCV, TensorFlow, Torch.  Saya ingin membuat pengakuan secepat mungkin, bahkan mengorbankan akurasi, dan mendapatkan POC sesegera mungkin. <br><br>  Setelah membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> , saya menyadari bahwa tugas saya tidak sesuai dengan pengklasifikasi HOG / LBP / SVM / HAAR / ....  Meskipun mereka cepat, mereka harus diterapkan berkali-kali - sesuai dengan pengklasifikasi untuk setiap unit - dan kemudian satu per satu untuk menerapkannya pada gambar untuk pencarian.  Selain itu, prinsip operasi mereka dalam teori akan memberikan hasil yang buruk: unit dapat memiliki bentuk yang berbeda, misalnya, ketika bergerak ke kiri dan ke atas. <br><br>  Secara teoritis, menggunakan jaringan saraf, Anda dapat menerapkannya sekali untuk gambar dan mendapatkan semua unit dari jenis yang berbeda dengan posisi mereka, jadi saya mulai menggali ke arah jaringan saraf.  TensorFlow telah menemukan dukungan untuk Convolutional Neural Networks (CNN).  Ternyata tidak perlu melatih jaringan saraf dari awal - Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melatih kembali jaringan kuat yang ada</a> . <br><br>  Kemudian saya menemukan algoritma YOLO yang lebih praktis, yang menjanjikan kompleksitas lebih sedikit dan, oleh karena itu, harus menyediakan algoritma pencarian berkecepatan tinggi tanpa mengorbankan banyak akurasi (dan dalam beberapa kasus, melampaui model lain). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Situs web YOLO</a> menjanjikan perbedaan kecepatan yang sangat besar dengan menggunakan model mungil dan jaringan yang lebih kecil dan dioptimalkan.  YOLO juga memungkinkan Anda untuk melatih ulang jaringan saraf yang telah selesai untuk tugas Anda, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">darknet</a> - kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open</a> source untuk menggunakan berbagai neuron yang pembuatnya dikembangkan YOLO - adalah aplikasi C asli yang sederhana, dan semua pekerjaan dengannya terjadi melalui pemanggilan parameternya. <br><br>  TensorFlow, yang ditulis dengan Python, sebenarnya adalah sebuah pustaka Python dan digunakan dengan menggunakan skrip yang ditulis sendiri yang harus Anda pahami atau sempurnakan sesuai kebutuhan Anda.  Mungkin, bagi sebagian orang, fleksibilitas TensorFlow merupakan nilai tambah, tetapi tanpa merinci, hampir tidak mungkin untuk dengan cepat mengambil dan menggunakannya.  Karena itu, dalam proyek saya, pilihan jatuh pada YOLO. <br><br><h2>  Bangunan model </h2><br>  Untuk mengerjakan pelatihan model, saya menginstal Ubuntu 18.10, mengirimkan paket perakitan, paket OpenCL NVIDIA dan dependensi lainnya, dan membangun darknet. <br><br>  Github memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian dengan langkah-langkah sederhana untuk melatih ulang model YOLO</a> : Anda perlu mengunduh model dan mengonfigurasi, mengubahnya dan mulai melatih kembali. <br><br>  Pertama saya ingin mencoba melatih kembali model YOLO sederhana, lalu Tiny dan membandingkannya.  Namun, ternyata untuk melatih model-model sederhana, Anda memerlukan 4 GB memori kartu video, dan saya hanya punya kartu grafis NVIDIA GeForce GTX 1060 3 GB yang dibeli untuk permainan.  Karena itu, saya hanya bisa segera melatih model Tiny. <br><br>  Markup unit pada gambar yang saya miliki adalah dalam format VOC, dan YOLO bekerja dengan formatnya sendiri, jadi saya menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">convert2Yolo</a> untuk mengonversi file anotasi. <br><br>  Setelah satu malam pelatihan di 200 tangkapan layar saya, saya mendapatkan hasil pertama, dan mereka mengejutkan saya - model itu benar-benar mampu mengenali sesuatu dengan benar!  Saya menyadari bahwa saya bergerak ke arah yang benar, dan memutuskan untuk melakukan lebih banyak contoh pengajaran. <br><br><img src="https://habrastorage.org/webt/ek/rh/ik/ekrhikfcntuxljeawh09ikegnp0.png"><br><br>  Saya tidak ingin terus meletakkan tangkapan layar, dan saya ingat tentang bingkai dari animasi unit.  Saya menandai semua gambar kecil dengan kelas mereka dan mencoba untuk melatih jaringan pada set ini.  Hasilnya sangat buruk.  Saya berasumsi bahwa model tidak dapat memilih pola yang benar dari gambar kecil untuk digunakan dalam gambar besar. <br><br>  Setelah itu, saya memutuskan untuk menempatkan mereka di latar belakang arena pertempuran yang sudah jadi dan secara terprogram membuat file markup VOC.  Ternyata screenshot sintetis seperti itu dengan tata letak otomatis 100% akurat. <br><br>  Saya menulis sebuah skrip di Scala yang membagi tangkapan layar menjadi 16 kotak 4x4 dan mengatur unit di tengah mereka sehingga mereka tidak saling berpotongan.  Skrip juga memungkinkan saya untuk menyesuaikan pembuatan contoh pelatihan - saat menerima kerusakan, unit dicat dengan warna tim mereka (merah / biru), dan selama klasifikasi saya secara terpisah mengenali unit warna yang berbeda.  Selain pewarnaan, unit tim yang berbeda yang menerima kerusakan memiliki sedikit perbedaan dalam pakaian.  Juga, saya secara acak menambah dan mengurangi unit sedikit, sehingga model belajar untuk tidak terlalu bergantung pada ukuran unit.  Hasilnya, saya belajar cara membuat puluhan ribu contoh pelatihan yang kira-kira mirip dengan tangkapan layar nyata. <br><br><img src="https://habrastorage.org/webt/uv/zi/_u/uvzi_uwhmohzcx0a7ylmpbyjady.png"><br><br>  Generasi itu tidak sempurna.  Seringkali unit ditempatkan di atas bangunan, meskipun dalam permainan mereka akan berada di belakang mereka;  tidak ada contoh tumpang tindih bagian unit, meskipun ini bukan situasi yang jarang terjadi dalam permainan.  Tapi sejauh ini saya memutuskan untuk mengabaikannya. <br><br><img src="https://habrastorage.org/webt/zo/wk/uq/zowkuqkijfqocemk7_qflhhgavg.png"><br><br>  Model yang diperoleh setelah beberapa malam pelatihan tentang campuran 200 tangkapan layar nyata dan 5000 gambar yang dihasilkan yang diciptakan kembali selama proses pelatihan sekali sehari, ketika diuji pada tangkapan layar ini, memberikan hasil yang buruk.  Tidak mengherankan, karena gambar yang dihasilkan memiliki banyak perbedaan dari yang asli. <br><br>  Oleh karena itu, saya meletakkan model yang dihasilkan untuk melatih ulang pada sampel rata-rata, di mana hanya ada 200 tangkapan layar saya.  Setelah itu, dia mulai bekerja jauh lebih baik. <br><br><div class="spoiler">  <b class="spoiler_title">Sayang sekali</b> <div class="spoiler_text">  Saya minta maaf karena menangani tindakan tidak ilmiah seperti itu "jauh lebih baik", tetapi saya tidak tahu cara cepat memvalidasi gambar, jadi saya mencoba beberapa tangkapan layar dari perangkat non-pelatihan dan mencari apakah hasilnya memuaskan saya.  Ini adalah hal yang paling penting.  Kami malas dan kami membuat prototipe, kan? <br><br>  Langkah-langkah selanjutnya untuk meningkatkan model dapat dipahami - tandai dengan tangan Anda tangkapan layar yang lebih nyata dan latihlah pada model tersebut, pra-latih pada tangkapan layar yang dihasilkan. <br></div></div><br><h2>  Mari kita turun ke bot </h2><br>  Saya memutuskan untuk menulis bot dengan Python - ia memiliki banyak alat yang tersedia untuk ML.  Saya memutuskan untuk menggunakan model saya dengan OpenCV, yang dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3,5 belajar menggunakan model jaringan saraf</a> , dan saya bahkan menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh sederhana</a> .  Setelah mencoba beberapa perpustakaan untuk bekerja dengan ADB, saya memilih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pure-python-adb</a> - semua yang saya butuhkan hanya diterapkan di sana: fungsi tangkapan layar dan operasi pada perangkat shell;  Saya ketuk menggunakan 'input ketuk'. <br><br>  Jadi, setelah menerima tangkapan layar dari gim tersebut, mengenali unit-unit di dalamnya dan menyodoknya di layar, saya terus berupaya mengenali keadaan gim.  Selain unit, saya perlu membuat pengakuan tingkat mana saat ini dan kartu yang tersedia untuk pemain. <br><br>  Level mana dalam game ditampilkan sebagai bilah kemajuan dan angka.  Tanpa berpikir dua kali, saya mulai memotong nomornya, membalikkan dan mengenali menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pytesseract</a> . <br><br>  Untuk menentukan kartu yang tersedia dan posisinya, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detektor keypoint KAZE dari OpenCV</a> .  Sejauh ini saya tidak ingin kembali mempelajari jaringan saraf lagi, dan saya memilih metode yang lebih cepat dan lebih mudah, meskipun pada akhirnya ternyata memiliki akurasi minimum yang cukup dalam kasus ketika Anda perlu mencari banyak objek. <br><br>  Saat memulai bot, saya menghitung titik kunci untuk semua gambar kartu (totalnya ada beberapa lusin), dan selama permainan saya mencari kecocokan semua kartu dengan area kartu pemain untuk mengurangi jumlah kesalahan dan meningkatkan kecepatan.  Mereka disortir berdasarkan akurasi dan koordinat <i>x</i> untuk mendapatkan urutan peta - informasi tentang bagaimana mereka berada di layar. <br><br>  Setelah bermain sedikit dengan parameter, dalam praktiknya saya mendapatkan banyak kesalahan, meskipun beberapa gambar kartu yang kompleks, yang kadang-kadang keliru untuk orang lain oleh algoritma, diakui dengan sangat akurat.  Saya harus menambahkan buffer tiga elemen: jika tiga pengenalan berturut-turut kita mendapatkan nilai yang sama, maka kita secara kondisional percaya bahwa kita dapat mempercayai mereka. <br><br><img src="https://habrastorage.org/webt/vr/8a/mj/vr8amjw6_mpuh8kzethfk0zbkya.png"><br><br>  Setelah menerima semua informasi yang diperlukan (unit dan perkiraan posisi mereka, mana dan kartu yang tersedia), Anda dapat membuat beberapa keputusan. <br><br>  Sebagai permulaan, saya memutuskan untuk mengambil sesuatu yang sederhana: misalnya, jika ada cukup mana pada kartu yang dapat diakses, mainkan di lapangan.  Tetapi bot masih tidak tahu bagaimana cara "bermain" kartu - ia tahu kartu apa yang kita miliki, di mana lapangan, Anda perlu mengklik kartu yang diinginkan, dan kemudian pada sel yang diinginkan di lapangan. <br><br>  Mengetahui resolusi tangkapan layar, Anda dapat memahami koordinat peta dan sel bidang yang diinginkan.  Sekarang saya sudah terikat dengan resolusi layar yang tepat, tetapi jika perlu, saya bisa mengabaikan ini.  Fungsi keputusan akan mengembalikan array keran yang perlu dilakukan dalam waktu dekat.  Secara umum, bot kami akan menjadi loop tak terbatas (disederhanakan): <br><br><pre><code class="plaintext hljs">:     =        :         ( )               :         =  ()         =  ()         =  ()         += (, , , )</code> </pre> <br><br>  Sejauh ini, bot hanya dapat menempatkan unit pada satu titik, tetapi sudah memiliki informasi yang cukup untuk membangun strategi yang lebih kompleks. <br><br><h3>  Masalah pertama </h3><br>  Pada kenyataannya, saya mengalami masalah yang tidak terduga dan sangat tidak menyenangkan.  Membuat tangkapan layar melalui ADB membutuhkan waktu sekitar 100 ms, yang memperkenalkan penundaan yang signifikan - Saya mengandalkan penundaan yang sedemikian besar, dengan mempertimbangkan semua perhitungan dan pilihan tindakan, tetapi tidak pada satu langkah membuat tangkapan layar.  Solusi sederhana dan cepat tidak dapat ditemukan.  Secara teori, menggunakan emulator Android, Anda dapat mengambil tangkapan layar langsung dari jendela aplikasi, atau Anda dapat membuat utilitas untuk streaming gambar dari ponsel dengan kompresi melalui UDP dan menghubungkan bot ke sana, tetapi saya juga tidak menemukan solusi cepat di sini. <br><br><h2>  Jadi </h2><br>  Setelah dengan tenang menilai keadaan proyek saya, saya memutuskan untuk berhenti pada model ini untuk saat ini.  Saya menghabiskan beberapa minggu waktu luang saya melakukan ini, dan pengenalan unit hanya bagian dari gameplay. <br><br>  Saya memutuskan untuk mengembangkan bagian-bagian bot secara bertahap - untuk membuat logika dasar persepsi, kemudian logika sederhana dari permainan dan interaksi dengan permainan, dan kemudian akan mungkin untuk meningkatkan bagian-bagian bot yang mereda secara individu.  Ketika tingkat model pengenalan unit menjadi cukup, menambahkan informasi tentang HP dan tingkat unit dapat membawa pengembangan bot game ke tahap yang sama sekali baru.  Mungkin ini akan menjadi tujuan berikutnya, tetapi saat ini jelas tidak layak untuk fokus pada tugas ini. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori proyek Github</a> <br><br>  Saya menghabiskan banyak waktu di proyek dan, terus terang, saya bosan, tapi saya tidak menyesal sedikit - saya mendapat pengalaman baru di ML / CV. <br><br>  Mungkin saya akan kembali kepadanya nanti - saya akan senang jika seseorang bergabung dengan saya.  Jika Anda tertarik, bergabunglah dengan grup di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Telegram</a> , dan datang juga ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus Scala</a> saya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439352/">https://habr.com/ru/post/id439352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439342/index.html">Pertemuan Musim Dingin DIYorDIE 17 Februari</a></li>
<li><a href="../id439344/index.html">Seperti troll: bagaimana perusahaan monopoli memerintah paten</a></li>
<li><a href="../id439346/index.html">Laravel + Docker: pengalaman sukses kami</a></li>
<li><a href="../id439348/index.html">Visi turun setelah koreksi penglihatan laser - apa yang harus dilakukan? Atau, dokter, bantu aku</a></li>
<li><a href="../id439350/index.html">Kecerdasan Buatan sebagai Mesin Penemuan</a></li>
<li><a href="../id439354/index.html">Rust News # 5 (Januari 2019)</a></li>
<li><a href="../id439356/index.html">Metrik non-sepele dari efektivitas kampanye iklan</a></li>
<li><a href="../id439358/index.html">Metadata file Excel</a></li>
<li><a href="../id439360/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Hari 3. Subnet</a></li>
<li><a href="../id439362/index.html">Bagaimana kita mengajar Rekayasa Perangkat Lunak di St. Petersburg HSE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>