<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèº üêÆ üß§ Likbez lan√ßa Istio ‚ÜóÔ∏è üõ≥Ô∏è üßúüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Malha de servi√ßo Isstio 


 Na Namely, estamos usando o Istio h√° um ano. Ele ent√£o acabou de sair. Tivemos uma grande queda no desempenho no cluster K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Likbez lan√ßa Istio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/441616/"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Malha de servi√ßo Isstio</em> </p><br><p>  Na Namely, estamos usando o Istio h√° um ano.  Ele ent√£o acabou de sair.  Tivemos uma grande queda no desempenho no cluster Kubernetes, quer√≠amos um rastreamento distribu√≠do e levamos o Istio para executar o Jaeger e descobrir isso.  A malha de servi√ßo se encaixa t√£o bem em nossa infraestrutura que decidimos investir nessa ferramenta. </p><br><p>  Eu tive que sofrer, mas n√≥s estudamos isso amplamente.  Este √© o primeiro post de uma s√©rie em que descreverei como o Istio se integra ao Kubernetes e o que aprendemos sobre seu trabalho.  √Äs vezes, vagamos pelas √°reas t√©cnicas, mas n√£o muito longe.  Al√©m disso, haver√° mais posts. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  O que √© o Istio? </h3><br><p>  Istio √© uma ferramenta de configura√ß√£o de malha de servi√ßo.  Ele l√™ o estado do cluster Kubernetes e atualiza para proxies L7 (HTTP e gRPC), que s√£o implementados como side-car nos pods do Kubernetes.  Esses carros laterais s√£o cont√™ineres Envoy que l√™em a configura√ß√£o da API do Istio Pilot (e o servi√ßo gRPC) e direcionam o tr√°fego atrav√©s dela.  Com o poderoso proxy L7, podemos usar m√©tricas, tra√ßos, l√≥gica de repeti√ß√£o, disjuntor, balanceamento de carga e implanta√ß√µes de can√°rias. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Vamos come√ßar do come√ßo: Kubernetes </h3><br><p> No Kubernetes, criamos usando um deploy ou StatefulSet.  Ou pode ser apenas "baunilha" sem um controlador de alto n√≠vel.  Em seguida, o Kubernetes faz o poss√≠vel para manter o estado desejado - ele cria pods no cluster no n√≥, garante que eles sejam iniciados e reiniciados.  Quando um under √© criado, o Kubernetes passa pelo ciclo de vida da API, garante que cada etapa seja bem-sucedida e s√≥ ent√£o finalmente cria o under no cluster. </p><br><p>  Est√°gios do ciclo de vida da API: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Obrigado ao Banzai Cloud pela imagem bacana.</em> </p><br><p>  Uma das etapas √© modificar os webhooks de admiss√£o.  Esta √© uma parte separada do ciclo de vida no Kubernetes, onde os recursos s√£o personalizados antes de serem confirmados no reposit√≥rio etcd, a fonte da verdade para a configura√ß√£o do Kubernetes.  E aqui Istio faz sua m√°gica. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Modificando webhooks de admiss√£o </h3><br><p> Quando um sub √© criado (via <code>kubectl</code> ou <code>Deployment</code> ), ele passa por esse ciclo de vida e os webhooks modificadores de acesso o alteram antes de liber√°-lo para o grande mundo. </p><br><p>  Durante a instala√ß√£o do Istio, o istio-sidecar-injector √© adicionado como um recurso de configura√ß√£o para modificar webhooks: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  E a configura√ß√£o: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  Ele diz aqui que o Kubernetes deve enviar todos os eventos de cria√ß√£o de lareira para o servi√ßo <code>istio-sidecar-injector</code> no espa√ßo de nome <code>istio-system</code> se o espa√ßo de nome tiver <code>istio-injection=enabled</code> .  O injetor inclui mais dois cont√™ineres no PodSpec: um tempor√°rio para definir regras de proxy e outro para proxy em si.  O injetor de carro lateral insere esses recipientes de acordo com o modelo do mapa de configura√ß√£o <code>istio-sidecar-injector</code> .  Esse processo tamb√©m √© chamado de side-car. </p><br><h3 id="sidecar-pody">  Pods de sidecar </h3><br><p>  Sidecar s√£o os truques do nosso m√°gico Istio.  O Istio aciona tudo de maneira t√£o inteligente que, do lado de fora, √© apenas m√°gica, se voc√™ n√£o conhece os detalhes.  E √© √∫til conhec√™-los se voc√™ precisar depurar repentinamente solicita√ß√µes de rede. </p><br><h3 id="init--i-proksi-konteynery">  Cont√™ineres de inicializa√ß√£o e proxy </h3><br><p>  O Kubernetes possui cont√™ineres de inicializa√ß√£o √∫nicos tempor√°rios que podem ser executados antes dos principais.  Eles agrupam recursos, migram bancos de dados ou, como √© o caso do Istio, configuram regras de rede. </p><br><p>  O Istio usa o Envoy para fazer proxy de todas as solicita√ß√µes de envio pelas rotas desejadas.  Para fazer isso, o Istio cria regras para o <code>iptables</code> e envia o tr√°fego de entrada e sa√≠da diretamente para o Envoy, al√©m de proxies do tr√°fego para seu destino.  O tr√°fego faz um pequeno desvio, mas voc√™ distribuiu o rastreamento, as m√©tricas de consulta e a aplica√ß√£o de pol√≠ticas.  Neste arquivo, no reposit√≥rio do Istio, voc√™ <a href="">pode ver</a> como o Istio cria regras para o iptables. </p><br><p>  <a href="">O @jimmysongio</a> desenhou um excelente diagrama de conex√£o entre as regras do iptables e o proxy Envoy: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Enviado - Tr√°fego enviado</em> </p><br><p>  O Envoy recebe todo o tr√°fego de entrada e sa√≠da; portanto, todo o tr√°fego geralmente se move dentro do Envoy, como no diagrama.  O proxy Istio √© outro cont√™iner que √© adicionado a todos os pods modificados pelo injetor lateral do Istio.  Nesse cont√™iner, o processo do Envoy √© iniciado, que recebe todo o tr√°fego da lareira (com algumas exce√ß√µes, como o tr√°fego do cluster Kubernetes). </p><br><p>  O processo do Envoy descobre todas as rotas por meio da API do Envoy v2, que implementa o Istio. </p><br><h3 id="envoy-i-pilot">  Enviado e Piloto </h3><br><p>  O pr√≥prio enviado n√£o tem l√≥gica para detectar pods e servi√ßos em um cluster.  √â um plano de dados e precisa de um plano de controle para gui√°-lo.  O par√¢metro de configura√ß√£o do Envoy solicita que a porta do host ou servi√ßo receba essa configura√ß√£o por meio da API do gRPC.  O Istio, por meio do servi√ßo Pilot, atende aos requisitos da API do gRPC.  O Enviado se conecta a essa API com base em uma configura√ß√£o de side-car implementada por meio de um webhook de modifica√ß√£o.  A API possui todas as regras de tr√°fego que o Envoy precisa descobrir e rotear para o cluster.  Esta √© a malha de servi√ßo. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>Troca de dados "sob o &lt;-&gt; piloto"</em> </p><br><p>  O piloto se conecta ao cluster Kubernetes, l√™ o status do cluster e aguarda atualiza√ß√µes.  Ele monitora os pods, servi√ßos e pontos finais no cluster Kubernetes, para fornecer a configura√ß√£o correta a todos os carros laterais Envoy conectados ao Pilot.  Esta √© a ponte entre Kubernetes e Enviado. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>De Piloto a Kubernetes</em> </p><br><p>  Quando pods, servi√ßos ou pontos de extremidade s√£o criados ou atualizados no Kubernetes, o Pilot aprende sobre ele e envia a configura√ß√£o necess√°ria para todas as inst√¢ncias do Envoy conectadas. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  Que configura√ß√£o est√° sendo enviada? </h3><br><p>  Que configura√ß√£o o Enviado obt√©m do Istio Pilot? </p><br><p>  Por padr√£o, o Kubernetes resolve seus problemas de rede com um servi√ßo (servi√ßo) que gerencia <code>endpoint</code> .  A lista de terminais pode ser aberta com o comando: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  Esta √© uma lista de todos os IP e portas do cluster e seus endere√ßos (geralmente s√£o pods criados a partir de uma implanta√ß√£o).  √â importante saber o Istio para configurar e enviar dados de rota para o Envoy. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Servi√ßos, ouvintes e rotas </h3><br><p>  Ao criar um servi√ßo em um cluster Kubernetes, voc√™ inclui atalhos pelos quais todos os pods adequados ser√£o selecionados.  Quando voc√™ envia tr√°fego para o IP do servi√ßo, o Kubernetes seleciona o tr√°fego para esse tr√°fego.  Por exemplo, o comando </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  Primeiro, ele encontrar√° o IP virtual atribu√≠do ao <code>my-service</code> no espa√ßo para nome <code>default</code> e esse IP encaminhar√° o tr√°fego para uma sub que corresponda √† etiqueta de servi√ßo. </p><br><p>  Istio e Envoy mudam ligeiramente essa l√≥gica.  O Istio configura o Envoy com base nos servi√ßos e pontos de extremidade no cluster Kubernetes e usa os recursos de roteamento inteligente e balanceamento de carga da Envoy para ignorar o servi√ßo Kubernetes.  Em vez de proxy de um IP de cada vez, o Envoy se conecta diretamente √† lareira do IP.  <strong>Para fazer isso, o Istio mapeia a configura√ß√£o do Kubernetes para a configura√ß√£o do Envoy</strong> . </p><br><p>  Os termos Kubernetes, Istio e Enviado s√£o um pouco diferentes, e n√£o est√° claro o que eles comem imediatamente. </p><br><h3 id="servisy">  Servi√ßos </h3><br><p>  Um servi√ßo no Kubernetes √© mapeado para um <strong>cluster</strong> no Envoy.  O cluster Envoy cont√©m uma lista de <strong>pontos</strong> de <strong>extremidade</strong> , ou seja, o IP (ou nomes de host) das inst√¢ncias para o processamento de solicita√ß√µes.  Para ver a lista de clusters configurados no Istio sidecar-pod, execute o <code>istioctl proxy-config cluster &lt; &gt;</code> .  Este comando mostra o estado atual das coisas em termos da lareira.  Aqui est√° um exemplo de um de nossos ambientes: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  Todos os mesmos servi√ßos est√£o neste espa√ßo para nome: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  Como o Istio sabe qual protocolo usa o servi√ßo?  Configura protocolos para manifestos de servi√ßo pelo campo de <code>name</code> na entrada da porta. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  Se houver <code>grpc</code> ou o prefixo grpc, o Istio configurar√° o protocolo HTTP2 para o servi√ßo.  Aprendemos por experi√™ncia amarga como o Istio usa o nome da porta quando as configura√ß√µes de proxy est√£o corrompidas porque n√£o especificaram prefixos http ou grpc ... </p><br><p>  Se voc√™ usar o kubectl e a p√°gina de encaminhamento da porta administrativa no Envoy, poder√° ver que os pontos de extremidade account-grpc-public s√£o implementados pelo Pilot como um cluster no Envoy com o protocolo HTTP2.  Isso confirma nossas suposi√ß√µes: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  A porta 15000 √© a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina de administra√ß√£o</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Envoy</a> , dispon√≠vel em todos os carros laterais. </p><br><h3 id="proslushivateli">  Ouvintes </h3><br><p>  Os ouvintes reconhecem os pontos de extremidade do Kubernetes para passar o tr√°fego para as lareiras.  O servi√ßo de verifica√ß√£o de endere√ßo possui um terminal aqui: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Portanto, a lareira de verifica√ß√£o de endere√ßo tem um ouvinte na porta 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Rotas </h3><br><p>  No Istio, em vez do objeto padr√£o do Kubernetes Ingress, um recurso personalizado mais abstrato e eficiente √© <code>VirtualService</code> - <code>VirtualService</code> .  O VirtualService mapeia rotas para clusters upstream, vinculando-os ao gateway.  √â assim que se usa o Kubernetes Ingress com um controlador do Ingress. </p><br><p>  Na Namely, usamos o Istio Ingress-Gateway para todo o tr√°fego GRPC interno: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  √Ä primeira vista, voc√™ n√£o entender√° nada no exemplo.  N√£o √© vis√≠vel aqui, mas a implanta√ß√£o do Istio-IngressGateway registra quais pontos de extremidade s√£o necess√°rios com base no <code>istio: ingressgateway</code> .  Neste exemplo, o IngressGateway roteia o tr√°fego para todos os dom√≠nios pela porta 80 pelo HTTP2.  O VirtualService implementa rotas para esse gateway, corresponde ao prefixo <code>/namely.address_validator.AddressValidator</code> e passa o <code>addressvalidator</code> pela porta 50051 para o servi√ßo upstream <code>addressvalidator</code> uma regra de repeti√ß√£o em dois segundos. </p><br><p>  Se redirecionarmos a porta de pod do Istio-IngressGateway e vermos a configura√ß√£o do Envoy, veremos o que o VirtualService faz: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  O que pesquisamos no Google enquanto procur√°vamos no Istio </h3><br><p>  <strong>Ocorre o erro 503 ou 404</strong> </p><br><p>  Os motivos s√£o diferentes, mas geralmente s√£o: </p><br><ul><li>  Os aplicativos do side-car n√£o podem entrar em contato com o Pilot (verifique se o Pilot est√° em execu√ß√£o). </li><li>  O manifesto do servi√ßo Kubernetes tem um protocolo inv√°lido. </li><li>  A configura√ß√£o do VirtualService / Envoy grava a rota no cluster upstream errado.  Comece com o servi√ßo de borda, onde voc√™ espera tr√°fego de entrada, e examine os logs do Envoy.  Ou use algo como Jaeger para encontrar erros. </li></ul><br><p>  <strong>O que significa NR / UH / UF nos logs de proxy do Istio?</strong> </p><br><ul><li>  NR - Sem rota. </li><li>  UH - Upstream Insalubre (upstream inoper√°vel). </li><li>  UF - Falha a montante (falha a montante). </li></ul><br><p>  Leia mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site da Envoy</a> . </p><br><p>  <strong>Em rela√ß√£o √† alta disponibilidade com o Istio</strong> </p><br><ul><li>  Adicione NodeAffinity aos componentes do Istio para distribuir uniformemente lares em diferentes zonas de disponibilidade e aumentar o n√∫mero m√≠nimo de r√©plicas. </li><li>  Inicie a nova vers√£o do Kubernetes com o recurso de escalonamento horizontal do pod horizontal.  As lareiras mais importantes ser√£o dimensionadas com base na carga. </li></ul><br><p>  <strong>Por que o cronjob n√£o termina?</strong> </p><br><p>  Quando a carga de trabalho principal estiver conclu√≠da, o cont√™iner lateral continuar√° funcionando.  Para contornar o problema, desative o sidecar nos cronjobs adicionando a anota√ß√£o <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> ao PodSpec. </p><br><p>  <strong>Como instalar o Istio?</strong> </p><br><p>  Usamos o Spinnaker para implanta√ß√µes, mas geralmente pegamos os gr√°ficos Helm mais recentes, conjuramos, usamos o <code>helm template -f values.yml</code> e confirmamos os arquivos no Github para ver as altera√ß√µes antes de aplic√°-las via <code>kubectl apply -f -</code> .  Isso ocorre para n√£o alterar acidentalmente o CRD ou a API em vers√µes diferentes. </p><br><p>  Agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bobby Tables</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Michael Hamrah</a> por ajudarem a escrever este post. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441616/">https://habr.com/ru/post/pt441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441600/index.html">Interface do usu√°rio fraca, programador fraco</a></li>
<li><a href="../pt441602/index.html">Por que um carro autom√°tico cl√°ssico √© imposs√≠vel e n√£o tem perspectivas comerciais</a></li>
<li><a href="../pt441604/index.html">Sistemas de vigil√¢ncia nacional da China: uma fonte n√£o apenas de dados, mas tamb√©m de uma renda est√°vel</a></li>
<li><a href="../pt441608/index.html">Dualidade - um mecanismo f√°cil e r√°pido para o igrostroy no Windows (Ext.)</a></li>
<li><a href="../pt441610/index.html">Mentiras LED de propor√ß√µes sem precedentes</a></li>
<li><a href="../pt441618/index.html">Cria√ß√£o da barra de navega√ß√£o inferior no Kotlin usando Anko</a></li>
<li><a href="../pt441620/index.html">O Projeto Prometheus: Procurando fogo usando IA</a></li>
<li><a href="../pt441626/index.html">Workshop sobre impress√£o 3D industrial: 1¬∫ de mar√ßo no Caliber Technopark</a></li>
<li><a href="../pt441628/index.html">Classifica√ß√£o de empregadores de TI em S√£o Petersburgo e Moscou 2018: resultados de uma pesquisa com desenvolvedores</a></li>
<li><a href="../pt441632/index.html">1 de mar√ßo - Teamlead Meetup: avalia√ß√£o e motiva√ß√£o dos funcion√°rios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>