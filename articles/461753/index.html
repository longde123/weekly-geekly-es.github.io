<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ üö≤ üéüÔ∏è Transacciones globales de InterSystems IRIS üë®‚Äçüéì üëºüèª üë¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="InterSystems IRIS DBMS admite estructuras curiosas de almacenamiento de datos: globales. De hecho, se trata de claves de varios niveles con varias ven...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transacciones globales de InterSystems IRIS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461753/"><img src="https://habrastorage.org/webt/fh/h6/kb/fhh6kbibffqggpvpjk1bpabnj1w.png" alt="InterSystems IRIS y transacci√≥n" align="left">  InterSystems IRIS DBMS admite estructuras curiosas de almacenamiento de datos: globales.  De hecho, se trata de claves de varios niveles con varias ventajas adicionales en forma de transacciones, funciones r√°pidas para atravesar √°rboles de datos, bloqueos y su propio lenguaje ObjectScript. <br><br>  M√°s informaci√≥n sobre los globales en la serie de art√≠culos "Globales - Espadas-Masones para el almacenamiento de datos": <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los arboles.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los arboles.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matrices dispersas.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br><br>  Me result√≥ interesante c√≥mo se implementan las transacciones en el mundo, qu√© caracter√≠sticas hay.  Despu√©s de todo, esta es una estructura completamente diferente para almacenar datos que las tablas habituales.  Nivel mucho m√°s bajo. <br><a name="habracut"></a><br>  Como sabe por la teor√≠a de la base de datos relacional, una buena implementaci√≥n de transacci√≥n debe satisfacer los requisitos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ACID</a> : <br><br>  <b>A - At√≥mico (atomicidad).</b>  Se registran todos los cambios realizados en la transacci√≥n o ninguno. <br><br>  <b>C - Consistencia.</b>  Una vez completada la transacci√≥n, el estado l√≥gico de la base de datos debe ser internamente coherente.  En muchos sentidos, este requisito se aplica al programador, pero en el caso de las bases de datos SQL, tambi√©n se aplica a las claves externas. <br><br>  <b>I - Aislar (aislamiento).</b>  Las transacciones paralelas no deber√≠an afectarse entre s√≠. <br><br>  <b>D - Durable.</b>  Despu√©s de que la transacci√≥n se complete con √©xito, los problemas en los niveles inferiores (falla de energ√≠a, por ejemplo) no deber√≠an afectar los datos modificados por la transacci√≥n. <br><br>  Los globales son estructuras de datos no relacionales.  Fueron creados para un trabajo ultrarr√°pido en hardware muy limitado.  Comprendamos la implementaci√≥n de transacciones en globales utilizando la imagen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">oficial del acoplador IRIS</a> . <br><br>  Para admitir transacciones en IRIS, se utilizan los siguientes comandos: <a href="">TSTART</a> , <a href="">TCOMMIT</a> , <a href="">TROLLBACK</a> . <br><br><h2>  1. Atomicidad </h2><br>  La forma m√°s f√°cil de verificar la atomicidad.  Comprobaci√≥n desde la consola de la base de datos. <br><br><pre><code class="bash hljs">Kill ^a TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TCOMMIT</code> </pre> <br>  Entonces concluimos: <br><br><pre> <code class="bash hljs">Write ^a(1), ‚Äú ‚Äù, ^a(2), ‚Äú ‚Äù, ^a(3)</code> </pre> <br>  Obtenemos: <br><br><pre> <code class="bash hljs">1 2 3</code> </pre> <br>  Todo esta bien.  Atomicidad observada: se registran todos los cambios. <br><br>  Complicamos la tarea, introducimos un error y vemos c√≥mo se guarda la transacci√≥n, parcialmente o en absoluto. <br><br>  Verifiquemos la atomicidad una vez m√°s: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3</code> </pre> <br>  Luego, detenga el contenedor por la fuerza, comience y vea. <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  Este comando es casi equivalente a apagar la alimentaci√≥n por la fuerza, ya que env√≠a una se√±al para detener inmediatamente el proceso SIGKILL. <br><br>  ¬øQuiz√°s la transacci√≥n se guard√≥ parcialmente? <br><br><pre> <code class="bash hljs">WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  - No, no conservado. <br><br>  Pruebe el comando de reversi√≥n: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TROLLBACK WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  Nada fue preservado tampoco. <br><br><h2>  2. Consistencia </h2><br>  Dado que en las bases de datos en globales, las claves tambi√©n se hacen en globales (recuerdo que un global es una estructura de nivel inferior para almacenar datos que una tabla relacional), para cumplir con el requisito de coherencia, debe incluir el cambio de clave en la misma transacci√≥n que el cambio global. <br><br>  Por ejemplo, tenemos una persona ^ global en la que almacenamos personalidades y usamos el TIN como clave. <br><br><pre> <code class="bash hljs">^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ...</span></span></code> </pre> <br>  Para tener una b√∫squeda r√°pida por apellido y nombre, creamos la clave ^ index. <br><br><pre> <code class="bash hljs">^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) = 1</code> </pre> <br>  Para que se acuerde la base, debemos agregar personalidades como esta: <br><br><pre> <code class="bash hljs">TSTART ^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ^index('</span></span>Kamenev<span class="hljs-string"><span class="hljs-string">', '</span></span>Sergey<span class="hljs-string"><span class="hljs-string">', 1234567) = 1 TCOMMIT</span></span></code> </pre> <br>  En consecuencia, al eliminar, tambi√©n debemos usar la transacci√≥n: <br><br><pre> <code class="bash hljs">TSTART Kill ^person(1234567) ZKill ^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) TCOMMIT</code> </pre> <br>  En otras palabras, el cumplimiento del requisito de coherencia recae completamente en el programador.  Pero cuando se trata de globales, esto es normal, debido a su naturaleza de bajo nivel. <br><br><h2>  3. Aislamiento </h2><br>  Aqu√≠ es donde comienzan las selvas.  Muchos usuarios trabajan simult√°neamente en la misma base de datos, modifican los mismos datos. <br><br>  La situaci√≥n es comparable a la situaci√≥n en la que muchos usuarios trabajan simult√°neamente con el mismo repositorio con el c√≥digo e intentan realizar cambios en muchos archivos a la vez. <br><br>  La base de datos debe resolver esto en tiempo real.  Dado que en las empresas serias hay incluso una persona especial responsable del control de versiones (para fusionar sucursales, resolver conflictos, etc.), y la base de datos debe hacer todo esto en tiempo real, se hace evidente la complejidad de la tarea y el dise√±o correcto de la base de datos y El c√≥digo que lo sirve. <br><br>  La base de datos no puede entender el significado de las acciones realizadas por los usuarios para evitar conflictos si trabajan con los mismos datos.  Solo puede cancelar una transacci√≥n contraria a otra o ejecutarlas secuencialmente. <br><br>  Otro problema es que durante la ejecuci√≥n de la transacci√≥n (antes de la confirmaci√≥n), el estado de la base de datos puede ser inconsistente, por lo que es deseable que otras transacciones no tengan acceso al estado inconsistente de la base de datos, que se logra en las bases de datos relacionales de muchas maneras: creando instant√°neas, filas de varias versiones y etc. <br><br>  En la ejecuci√≥n paralela de transacciones, es importante para nosotros que no interfieran entre s√≠.  Esta es la propiedad del aislamiento. <br><br>  SQL define 4 niveles de aislamiento: <br><br><ul><li>  LEER SIN COMPROMISO </li><li>  LEER COMPROMETIDO </li><li>  LECTURA REPETIBLE </li><li>  SERIALIZABLE </li></ul><br>  Consideremos cada nivel por separado.  Los costos de implementar cada nivel est√°n creciendo casi exponencialmente. <br><br>  <b>LEER NO COMPROMETIDO</b> es el nivel m√°s bajo de aislamiento, pero el m√°s r√°pido.  Las transacciones pueden leer los cambios realizados entre s√≠. <br><br>  <b>LEER COMPROMETIDO</b> es el siguiente nivel de aislamiento, que es un compromiso.  Las transacciones no pueden leer los cambios realizados entre s√≠ antes de una confirmaci√≥n, pero pueden leer cualquier cambio realizado despu√©s de una confirmaci√≥n. <br><br>  Si tenemos una transacci√≥n larga T1, durante la cual hubo confirmaciones en las transacciones T2, T3 ... Tn que funcionaron con los mismos datos que T1, entonces cuando solicitamos datos en T1, obtendremos resultados diferentes cada vez.  Este fen√≥meno se llama lectura no repetible. <br><br>  <b>LECTURA REPETIBLE</b> : en este nivel de aislamiento, no tenemos el fen√≥meno de la lectura no repetible, debido al hecho de que para cada solicitud de lectura de datos, se crea una instant√°nea de los datos del resultado y cuando se reutiliza en la misma transacci√≥n, se utilizan los datos de la instant√°nea.  Sin embargo, a este nivel de aislamiento, se pueden leer datos fantasma.  Esto se refiere a la lectura de nuevas l√≠neas que fueron agregadas por transacciones confirmadas concurrentes. <br><br>  <b>SERIALIZABLE</b> es el nivel m√°s alto de aislamiento.  Se caracteriza por el hecho de que los datos utilizados de cualquier manera en la transacci√≥n (lectura o cambio) est√°n disponibles para otras transacciones solo despu√©s de la finalizaci√≥n de la primera transacci√≥n. <br><br>  Primero, averig√ºemos si hay un aislamiento de operaciones en una transacci√≥n del hilo principal.  Abramos 2 ventanas de terminal. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs">Kill ^t Write ^t(1) 2</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=2</code> </pre> </td></tr></tbody></table></div><br>  No hay aislamiento  Un hilo ve lo que hace el segundo que abri√≥ la transacci√≥n. <br><br>  Veamos si las transacciones de diferentes flujos ven lo que sucede dentro de ellos. <br><br>  Abrimos 2 ventanas de terminal y abrimos 2 transacciones en paralelo. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> ^t TSTART Write ^t(1) 3</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=3</code> </pre></td></tr></tbody></table></div><br>  Las transacciones concurrentes ven los datos del otro.  Entonces, obtuvimos el nivel de aislamiento m√°s simple, pero tambi√©n el m√°s r√°pido LEER SIN COMPROMISO. <br><br>  En principio, esto podr√≠a esperarse para los globales, para quienes la velocidad siempre ha sido primordial. <br><br>  Pero, ¬øqu√© pasa si necesitamos un mayor nivel de aislamiento en las operaciones globales? <br><br>  Aqu√≠ debe pensar por qu√© se necesitan niveles de aislamiento y c√≥mo funcionan. <br><br>  El nivel de aislamiento m√°s alto de SERIALIZE significa que el resultado de las transacciones ejecutadas simult√°neamente es equivalente a su ejecuci√≥n secuencial, lo que garantiza la ausencia de colisiones. <br><br>  Podemos hacer esto con la ayuda de bloqueos competentes en ObjectScript, que tienen muchas formas diferentes de aplicaci√≥n: puede hacer bloqueos m√∫ltiples, incrementales y regulares con el comando <a href="">LOCK</a> . <br><br>  Los niveles de aislamiento m√°s bajos son compensaciones dise√±adas para aumentar la velocidad de la base de datos. <br><br>  Veamos c√≥mo podemos lograr diferentes niveles de aislamiento usando bloqueos. <br><br>  Este operador le permite tomar no solo los bloqueos exclusivos necesarios para cambiar los datos, sino tambi√©n los llamados compartidos, que pueden tomar varios hilos a la vez, cuando necesitan leer datos que otros procesos no deber√≠an cambiar durante la lectura. <br><br>  M√°s informaci√≥n sobre el m√©todo de bloqueo de dos fases en ruso e ingl√©s: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cerradura de dos fases</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloqueo bif√°sico</a> <br><br>  La dificultad es que durante la transacci√≥n el estado de la base de datos puede ser inconsistente, sin embargo, estos datos inconsistentes son visibles para otros procesos.  ¬øC√≥mo evitar esto? <br><br>  Usando bloqueos, crearemos ventanas de visibilidad en las que se acordar√° el estado de la base de datos.  Y todas las llamadas a tales ventanas de visibilidad del estado acordado ser√°n controladas por cerraduras. <br><br>  Los bloqueos compartidos de los mismos datos son reutilizables: varios procesos pueden tomarlos.  Estos bloqueos evitan que otros procesos cambien datos, es decir  Se utilizan para formar las ventanas del estado coordinado de la base de datos. <br><br>  Los bloqueos exclusivos se utilizan para modificar datos: solo un proceso puede tomar dicho bloqueo.  El bloqueo exclusivo puede tomar: <br><br><ol><li>  Cualquier proceso si los datos son libres </li><li>  Solo el proceso que tiene un bloqueo compartido en estos datos y el primero solicit√≥ un bloqueo exclusivo. </li></ol><br><img src="https://habrastorage.org/webt/ba/pu/mx/bapumxoivygurvclagw-mkw9p8w.png"><br><br>  Cuanto m√°s estrecha sea la ventana de visibilidad, m√°s tardar√°n otros procesos en esperar, pero m√°s coherente puede ser el estado de la base de datos. <br><br>  <b>READ_COMMITED</b> : la esencia de este nivel es que solo vemos datos de otras transmisiones que est√°n bloqueados.  Si los datos en otra transacci√≥n a√∫n no se han confirmado, entonces vemos su versi√≥n anterior. <br><br>  Esto nos permite paralelizar el trabajo en lugar de esperar a que se libere el bloqueo. <br><br>  Sin trucos especiales, no podremos ver la versi√≥n anterior de los datos en IRIS, por lo que tenemos que ver con bloqueos. <br><br>  En consecuencia, tendremos que usar bloqueos compartidos para permitir la lectura de datos solo en momentos de consistencia. <br><br>  Supongamos que tenemos una base de usuarios ^ persona que transfiere dinero entre s√≠. <br><br>  El momento de la transferencia de la persona 123 a la persona 242: <br><br><pre> <code class="bash hljs">LOCK +^person(123), +^person(242) Set ^person(123, amount) = ^person(123, amount) - amount Set ^person(242, amount) = ^person(242, amount) + amount LOCK -^person(123), -^person(242)</code> </pre> <br>  El momento de solicitar la cantidad de dinero de la persona 123 antes del d√©bito debe ir acompa√±ado de un bloqueo exclusivo (por defecto): <br><br><pre> <code class="bash hljs">LOCK +^person(123) Write ^person(123)</code> </pre> <br>  Y si necesita mostrar el estado de la cuenta en su cuenta, puede usar el bloqueo compartido o no usarlo en absoluto: <br><br><pre> <code class="bash hljs">LOCK +^person(123)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù Write ^person(123)</span></span></code> </pre> <br>  Sin embargo, si suponemos que las operaciones de la base de datos se realizan casi instant√°neamente (recuerdo que los globales son una estructura de nivel mucho m√°s baja que una tabla relacional), entonces la necesidad de este nivel disminuye. <br><br>  <b>LECTURA REPETIBLE</b> : en este nivel de aislamiento, se <b>supone</b> que puede haber m√∫ltiples lecturas de datos que pueden modificarse mediante transacciones concurrentes. <br><br>  En consecuencia, tendremos que poner un bloqueo compartido en la lectura de los datos que estamos cambiando y bloqueos exclusivos en los datos que estamos cambiando. <br><br>  Afortunadamente, el operador LOCK le permite a un operador enumerar en detalle todos los bloqueos necesarios, que pueden ser muchos. <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù  ^person(123, amount)</span></span></code> </pre> <br>  otras operaciones (en este momento, los hilos paralelos intentan cambiar ^ persona (123, cantidad), pero no pueden) <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù</span></span></code> </pre> <br>  Cuando se enumeran los bloqueos separados por comas, se toman secuencialmente, y si lo hace: <br><br><pre> <code class="bash hljs">LOCK +(^person(123),^person(242))</code> </pre> <br>  entonces se toman at√≥micamente de una vez. <br><br>  <b>SERIALIZAR</b> : tendremos que establecer los bloqueos para que, en √∫ltima instancia, todas las transacciones que tienen datos comunes se ejecuten secuencialmente.  Para este enfoque, la mayor√≠a de las cerraduras deben ser exclusivas y llevadas a las √°reas m√°s peque√±as del mundo para el rendimiento. <br><br>  Si hablamos de cancelaciones en la persona global ^, entonces solo el nivel de aislamiento SERIALIZE es aceptable para √©l, ya que el dinero debe gastarse estrictamente secuencialmente, de lo contrario es posible gastar la misma cantidad varias veces. <br><br><h2>  4. Durabilidad </h2><br>  Realic√© pruebas con un corte duro del contenedor a trav√©s de <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  La base los toler√≥ bien.  No se identificaron problemas. <br><br><h2>  Conclusi√≥n </h2><br>  Para los globales, InterSystems IRIS tiene soporte para transacciones.  Son verdaderamente at√≥micos, confiables.  Para garantizar la coherencia de la base de datos en los globales, los esfuerzos del programador y el uso de transacciones son necesarios, ya que no existen construcciones integradas complejas, como las claves externas. <br><br>  El nivel de aislamiento de los globales sin el uso de cerraduras se LEE SIN COMPROMISO, y cuando se usan cerraduras, se puede asegurar hasta el nivel de SERIALIZAR. <br><br>  La exactitud y la velocidad de las transacciones en los globales depende en gran medida de la habilidad del programador: cuanto m√°s se utilicen los bloqueos compartidos al leer, cuanto mayor sea el nivel de aislamiento y m√°s bloqueos exclusivos se realicen, mayor ser√° la velocidad. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461753/">https://habr.com/ru/post/461753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461743/index.html">Semana de la seguridad 31: vulnerabilidad VLC y tel√©fono roto</a></li>
<li><a href="../461745/index.html">DeviceLock DLP: precios del mercado negro ruso por romper datos personales (m√°s una respuesta a la respuesta de Tinkoff Bank)</a></li>
<li><a href="../461747/index.html">C√≥mo implementamos ML en una aplicaci√≥n con casi 50 millones de usuarios. Experiencia Sberbank</a></li>
<li><a href="../461749/index.html">Belleza en el ojo del espectador</a></li>
<li><a href="../461751/index.html">Contribuci√≥n del dise√±ador al desarrollo de aplicaciones m√≥viles</a></li>
<li><a href="../461755/index.html">La psicolog√≠a de la visi√≥n sana. Svetlana Lebedeva cont√≥ c√≥mo se les ense√±a a las personas una nueva forma de percibir</a></li>
<li><a href="../461759/index.html">Escuchando comunicaciones VoIP cifradas</a></li>
<li><a href="../461761/index.html">DPKI: abordando las desventajas de la PKI centralizada con blockchain</a></li>
<li><a href="../461763/index.html">¬øPueden las agencias de publicidad matar negocios al comienzo del viaje?</a></li>
<li><a href="../461765/index.html">Cruzamos k8s con Kafka, protegemos contenedores, escapamos de la basura en Ansible: los 10 mejores informes de DevOops 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>