<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèª üçù üöµ Ein kleiner √úberblick √ºber SIMD in .NET / C # ‚úçüèæ üôÖüèº üçá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ihre Aufmerksamkeit wird auf einen kleinen √úberblick √ºber die M√∂glichkeiten der Vektorisierung von Algorithmen in .NET Framework und .NETCORE gelenkt....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein kleiner √úberblick √ºber SIMD in .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435840/"><p> Ihre Aufmerksamkeit wird auf einen kleinen √úberblick √ºber die M√∂glichkeiten der Vektorisierung von Algorithmen in .NET Framework und .NETCORE gelenkt.  Der Zweck des Artikels ist es, diese Techniken denjenigen vorzustellen, die sie √ºberhaupt nicht kannten, und zu zeigen, dass .NET nicht weit hinter den "echten, kompilierten" Sprachen f√ºr den Muttersprachler zur√ºckbleibt <br>  Entwicklung. </p><a name="habracut"></a><br><p>  Ich fange gerade erst an, Vektorisierungstechniken zu lernen. Wenn mich also jemand aus der Community auf eine explizite Neigung hinweist oder verbesserte Versionen der unten beschriebenen Algorithmen vorschl√§gt, bin ich sehr gl√ºcklich. </p><br><h2 id="nemnogo-istorii">  Ein bisschen Geschichte </h2><br><p>  In .NET erschien SIMD erstmals 2015 mit der Ver√∂ffentlichung von .NET Framework 4.6.  Dann wurden die Typen Matrix3x2, Matrix4x4, Ebene, Quaternion, Vektor2, Vektor3 und Vektor4 hinzugef√ºgt, die die Erstellung vektorisierter Berechnungen erm√∂glichten.  Sp√§ter wurde der Typ Vector &lt;T&gt; hinzugef√ºgt, der mehr M√∂glichkeiten zur Vektorisierung von Algorithmen bot.  Aber viele Programmierer waren immer noch ungl√ºcklich, weil  Die oben genannten Typen schr√§nkten den Gedankenfluss des Programmierers ein und erlaubten nicht die volle Leistung der SIMD-Anweisungen moderner Prozessoren.  Bereits heute wurde in der .NET Core 3.0-Vorschau der System.Runtime.Intrinsics-Namespace angezeigt, der viel mehr Freiheit bei der Auswahl von Anweisungen bietet.  Um die besten Geschwindigkeitsergebnisse zu erzielen, m√ºssen Sie RyuJit verwenden und entweder unter x64 erstellen oder Prefer 32-bit deaktivieren und unter AnyCPU erstellen.  Alle Benchmarks, die ich auf einem Computer mit einem Intel Core i7-6700-Prozessor mit 3,40 GHz (Skylake) ausgef√ºhrt habe. </p><br><h2 id="summiruem-elementy-massiva">  Fassen Sie die Elemente des Arrays zusammen </h2><br><p>  Ich habe mich entschlossen, mit dem klassischen Problem zu beginnen, das bei der Vektorisierung oft zuerst geschrieben wird.  Dies ist die Aufgabe, die Summe der Elemente des Arrays zu ermitteln.  Wir werden vier Implementierungen dieser Aufgabe schreiben und die Elemente des Array-Arrays zusammenfassen: </p><br><p>  Am offensichtlichsten </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Verwenden von LINQ </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Verwenden von Vektoren aus System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Verwenden von Code aus dem System.Runtime.Intrinsics-Bereich: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Ich habe einen Benchmark f√ºr diese 4 Methoden auf meinem Computer gestartet und folgendes Ergebnis erhalten: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10 </td><td>  75,12 ns </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  1 186,85 ns </td></tr><tr><td>  Vektoren </td><td>  10 </td><td>  60,09 ns </td></tr><tr><td>  Intrinsics </td><td>  10 </td><td>  255,40 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  100 </td><td>  360,56 ns </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  2 719,24 ns </td></tr><tr><td>  Vektoren </td><td>  100 </td><td>  60,09 ns </td></tr><tr><td>  Intrinsics </td><td>  100 </td><td>  345,54 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  1000 </td><td>  1 847,88 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 033,78 ns </td></tr><tr><td>  Vektoren </td><td>  1000 </td><td>  240,38 ns </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  630,98 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  10.000 </td><td>  18 403,72 ns </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  102 489,96 ns </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  7 316,42 ns </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  3 365,25 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  176 630,67 ns </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  975 998,24 ns </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  78 828,03 ns </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  41 269,41 ns </td></tr></tbody></table></div><br><p>  Es ist ersichtlich, dass die L√∂sungen mit Vektoren und Intrinsics sehr viel schneller sind als die offensichtliche L√∂sung und mit LINQ.  Jetzt m√ºssen wir herausfinden, was bei diesen beiden Methoden passiert. </p><br><p>  Betrachten Sie die Vektoren-Methode genauer: </p><br><div class="spoiler">  <b class="spoiler_title">Vektoren</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vector &lt;int&gt; .Count;  - So viele 4-Byte-Zahlen k√∂nnen wir in einen Vektor einf√ºgen.  Wenn die Hardwarebeschleunigung verwendet wird, zeigt dieser Wert an, wie viele 4-Byte-Nummern in einem SIMD-Register abgelegt werden k√∂nnen.  Tats√§chlich wird angezeigt, wie viele Elemente dieses Typs Sie parallel ausf√ºhren k√∂nnen. </li><li>  accVector - ein Vektor, in dem sich das Ergebnis der Funktion ansammelt; <br>  var v = neuer Vektor &lt;int&gt; (Array, i);  - Daten werden ausgehend vom Index i aus dem Array in einen neuen Vektor v geladen.  Es werden genau vectorSize-Daten geladen. </li><li>  accVector = Vector.Add (accVector, v);  - Es werden zwei Vektoren hinzugef√ºgt. <br>  Zum Beispiel werden 8 Zahlen in Array gespeichert: {0, 1, 2, 3, 4, 5, 6, 7} und vectorSize == 4, dann: <br>  In der ersten Iteration der Schleife accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3} ist es nach der Addition in accVector: {0, 0, 0, 0} + {0, 1, 2 , 3} = {0, 1, 2, 3}. <br>  In der zweiten Iteration ist v = {4, 5, 6, 7} und nach Addition accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Es bleibt nur irgendwie die Summe aller Elemente des Vektors zu erhalten, daf√ºr k√∂nnen wir die Skalarmultiplikation mit einem mit Einheiten gef√ºllten Vektor anwenden: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Dann stellt sich heraus: {4, 6, 8, 10} <em>{1, 1, 1, 1} = 4</em> 1 + 6 <em>1 + 8</em> 1 + 10 * 1 = 28. </li><li>  Am Ende werden bei Bedarf Zahlen addiert, die nicht in den letzten Vektor passen. </li></ul><br><p>  Wenn Sie sich den Intrinsics-Methodencode ansehen: </p><br><div class="spoiler">  <b class="spoiler_title">Intrinsics</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Sie k√∂nnen sehen, dass es Vektoren mit wenigen Ausnahmen sehr √§hnlich ist: </p><br><ul><li>  vectorSize ist durch Konstante gegeben.  Dies liegt daran, dass Avx2-Befehle, die mit 256-Bit-Registern arbeiten, in dieser Methode explizit verwendet werden.  In einer realen Anwendung sollte √ºberpr√ºft werden, ob der aktuelle Avx2-Prozessor Anweisungen unterst√ºtzt, und wenn nicht, einen anderen Code aufrufen.  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector wird als 256-Bit-Vektor deklariert, der mit Nullen gef√ºllt ist. </li><li>  fest (int * ptr = Array) - In ptr wird ein Zeiger auf ein Array eingegeben. </li><li>  Dann die gleichen Operationen wie in Vektoren: Laden von Daten in einen Vektor und Hinzuf√ºgen von zwei Vektoren. </li><li>  Um die Elemente des Vektors zusammenzufassen, wurde die folgende Methode angewendet: <br><ul><li>  Auf dem Stapel wird ein Array erstellt: var temp = stackalloc int [vectorSize]; </li><li>  Der Vektor wird in dieses Array geladen: Avx2.Store (temp, accVector); </li><li>  In einer Schleife werden die Elemente des Arrays summiert. </li></ul></li><li>  Dann werden die Elemente des Arrays addiert, die nicht im letzten Vektor platziert sind </li></ul><br><h2 id="sravnivaem-dva-massiva">  Vergleichen Sie zwei Arrays </h2><br><p>  Es ist notwendig, zwei Arrays von Bytes zu vergleichen.  Eigentlich ist dies das Problem, aufgrund dessen ich angefangen habe, SIMD in .NET zu lernen.  Wieder werden wir verschiedene Methoden f√ºr den Benchmark schreiben, wir werden zwei Arrays vergleichen: ArrayA und ArrayB: </p><br><p>  Die naheliegendste L√∂sung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  L√∂sung √ºber LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  L√∂sung √ºber MemCmp-Funktion: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Verwenden von Vektoren aus System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Verwenden von Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Das Ergebnis des Benchmarks auf meinem Computer: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10.000 </td><td>  66 719,1 ns </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  71 211,1 ns </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  3 695,8 ns </td></tr><tr><td>  Memcmp </td><td>  10.000 </td><td>  600,9 ns </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  1 607,5 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  588 633,7 ns </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  651 191,3 ns </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  34 659,1 ns </td></tr><tr><td>  Memcmp </td><td>  100.000 </td><td>  5 513,6 ns </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  12.078,9 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  1.000.000 </td><td>  5 637 293,1 ns </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6 622 666,0 ns </td></tr><tr><td>  Vektoren </td><td>  1.000.000 </td><td>  777 974,2 ns </td></tr><tr><td>  Memcmp </td><td>  1.000.000 </td><td>  361 704,5 ns </td></tr><tr><td>  Intrinsics </td><td>  1.000.000 </td><td>  434 252,7 ns </td></tr></tbody></table></div><br><p>  Der gesamte Code f√ºr diese Methoden ist meines Erachtens verst√§ndlich, mit Ausnahme von zwei Zeilen in Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Im ersten Schritt werden zwei Vektoren auf Gleichheit verglichen und das Ergebnis in dem Vektor areEqual gespeichert, in dem alle Bits in einem Element an einer bestimmten Position auf 1 gesetzt werden, wenn die entsprechenden Elemente in va und vb gleich sind.  Es stellt sich heraus, dass, wenn die Vektoren aus den Bytes va und vb vollst√§ndig gleich sind, in areEquals alle Elemente gleich 255 (11111111b) sein sollten.  Weil  Avx2.CompareEqual ist ein Wrapper √ºber _mm256_cmpeq_epi8. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf der Intel-Website</a> k√∂nnen Sie den Pseudocode dieser Operation sehen: <br>  Die MoveMask-Methode aus einem Vektor erstellt eine 32-Bit-Zahl.  Die Bitwerte sind die hohen Bits jedes der 32 Einzelbyte-Elemente des Vektors.  Pseudocode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Wenn also einige Bytes in va und vb nicht √ºbereinstimmen, sind in areEqual die entsprechenden Bytes 0, daher sind die h√∂chstwertigen Bits dieser Bytes ebenfalls 0, was bedeutet, dass die entsprechenden Bits in der Avx2.MoveMask-Antwort ebenfalls 0 und der Vergleich sind mit equalsMask funktioniert nicht. </p><br><p>  Analysieren wir ein kleines Beispiel unter der Annahme, dass die L√§nge des Vektors 8 Bytes betr√§gt (zum Schreiben war es weniger): </p><br><ul><li>  Sei va = {100, 10, 20, 30, 100, 40, 50, 100} und vb = {100, 20, 10, 30, 100, 40, 80, 90}; </li><li>  Dann ist areEqual gleich {255, 0, 0, 255, 255, 255, 0, 0}; </li><li>  Die MoveMask-Methode gibt 10011100b zur√ºck, was mit der Maske 11111111b verglichen werden muss, weil  Da diese Masken ungleich sind, stellt sich heraus, dass die Vektoren va und vb nicht gleich sind. </li></ul><br><h2 id="podschityvaem-skolko-raz-element-vstrechaetsya-v-kollekcii">  Z√§hlen Sie, wie oft ein Element in der Sammlung vorkommt </h2><br><p>  Manchmal muss berechnet werden, wie oft ein bestimmtes Element in einer Sammlung gefunden wird, z. B. Ints. Dieser Algorithmus kann auch beschleunigt werden.  Lassen Sie uns einige Methoden zum Vergleich schreiben. Wir werden nach dem Item-Element im Array-Array suchen. </p><br><p>  Das offensichtlichste: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  mit LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  Verwenden von Vektoren aus System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Verwenden von Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//var mask = Avx2.SetAllVector256(Item); //var mask = Avx2.SetVector256(Item, Item, Item, Item, Item, Item, Item, Item); var temp = stackalloc int[vectorSize]; for (int j = 0; j &lt; vectorSize; j++) { temp[j] = Item; } var mask = Avx2.LoadVector256(temp); var accVector = Vector256&lt;int&gt;.Zero; int i; var array = Array; fixed (int* ptr = array) { for (i = 0; i &lt; array.Length - vectorSize; i += vectorSize) { var v = Avx2.LoadVector256(ptr + i); var areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } int result = 0; Avx2.Store(temp, accVector); for(int j = 0; j &lt; vectorSize; j++) { result += temp[j]; } for(; i &lt; array.Length; i++) { if (array[i] == Item) { result++; } } return result; }</span></span></code> </pre> <br><p>  Das Ergebnis des Benchmarks auf meinem Computer: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Median </th></tr></thead><tbody><tr><td>  Naiv </td><td>  1000 </td><td>  2 824,41 ns </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  12 138,95 ns </td></tr><tr><td>  Vektoren </td><td>  1000 </td><td>  961,50 ns </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  691,08 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  10.000 </td><td>  27 072,25 ns </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  113 967,87 ns </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  7 571,82 ns </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  4,296,71 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  361 028,46 ns </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  1.091.994,28 ns </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  82 839,29 ns </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  40 307,91 ns </td></tr><tr><td></td><td></td></tr><tr><td>  Naiv </td><td>  1.000.000 </td><td>  1 634 175,46 ns </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6 194 257,38 ns </td></tr><tr><td>  Vektoren </td><td>  1.000.000 </td><td>  583 901,29 ns </td></tr><tr><td>  Intrinsics </td><td>  1.000.000 </td><td>  413 520,38 ns </td></tr></tbody></table></div><br><p>  Die Methoden Vectors und Intrinsics sind in der Logik v√∂llig identisch, die Unterschiede bestehen nur in der Implementierung spezifischer Operationen.  Die Idee als Ganzes ist: </p><br><ul><li>  Es wird ein Maskenvektor erstellt, in dem die erforderliche Anzahl in jedem Element gespeichert ist. </li><li>  Der Teil des Arrays wird in den Vektor v geladen und mit der Maske verglichen, dann werden alle Bits in areEqual in gleiche Elemente gesetzt, weil  areEqual ist ein Vektor aus Ints. Wenn Sie also alle Bits eines Elements setzen, erhalten wir -1 in diesem Element ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  Der Vektor areEqual wird von accVector subtrahiert, und dann ist der accVector die Summe, wie oft das Elementelement in allen Vektoren v f√ºr jede Position aufgetreten ist (minus min ergibt ein Plus). </li></ul><br><p>  Der gesamte Code aus dem Artikel ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> zu finden </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Ich habe nur einen sehr kleinen Teil der M√∂glichkeiten untersucht, die .NET f√ºr die Vektorisierung von Berechnungen bietet.  Eine vollst√§ndige und aktuelle Liste der in .NETCORE unter x86 verf√ºgbaren Intrinsics finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> .  Es ist praktisch, dass in den C # -Dateien in der Zusammenfassung jedes Intrinsics ein eigener Name aus der Welt von C enthalten ist, was das Verst√§ndnis des Zwecks dieses Intrinsics und die √úbersetzung vorhandener C ++ / C-Algorithmen in .NET vereinfacht.  Die Dokumentation zu System.Numerics.Vector finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">msdn</a> . </p><br><p>  Meiner Meinung nach hat .NET einen gro√üen Vorteil gegen√ºber C ++, weil  Die JIT-Kompilierung findet bereits auf dem Client-Computer statt. Der Compiler kann den Code f√ºr einen bestimmten Client-Prozessor optimieren und bietet so maximale Leistung.  Gleichzeitig kann ein Programmierer zum Schreiben von schnellem Code im Rahmen einer Sprache und Technologie bleiben. </p><br><p>  UPD (15.09.2019): </p><br><div class="spoiler">  <b class="spoiler_title">Es gab einen Pfosten in Benchmarks</b> <div class="spoiler_text"><p>  In Benchmarks habe ich IterationSetup verwendet, was, wie sich herausstellte, die Leistung von Benchmarks, die in weniger als 100 ms funktionieren, stark beeintr√§chtigen kann.  Wenn Sie es in GlobalSetup wiederholen, sehen die Ergebnisse folgenderma√üen aus. </p><br><p>  Summe der Array-Elemente: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10 </td><td>  3,531 ns </td><td>  0,0336 ns </td><td>  0,0314 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76,925 ns </td><td>  0,4166 ns </td><td>  0,3897 ns </td><td>  21.79 </td></tr><tr><td>  Vektoren </td><td>  10 </td><td>  2,750 ns </td><td>  0,0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intrinsics </td><td>  10 </td><td>  6,513 ns </td><td>  0,0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100 </td><td>  47,982 ns </td><td>  0,3975 ns </td><td>  0,3524 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590,414 ns </td><td>  3,8808 ns </td><td>  3,4402 ns </td><td>  12.31 </td></tr><tr><td>  Vektoren </td><td>  100 </td><td>  10,122 ns </td><td>  0,0747 ns </td><td>  0,0699 ns </td><td>  0,21 </td></tr><tr><td>  Intrinsics </td><td>  100 </td><td>  14.277 ns </td><td>  0,0566 ns </td><td>  0,0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1000 </td><td>  569.910 ns </td><td>  2,8297 ns </td><td>  2,6469 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5.658,570 ns </td><td>  31,7465 ns </td><td>  29.6957 ns </td><td>  9.93 </td></tr><tr><td>  Vektoren </td><td>  1000 </td><td>  79,598 ns </td><td>  0,3498 ns </td><td>  0,3272 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  66,970 ns </td><td>  0,3937 ns </td><td>  0,3682 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  10.000 </td><td>  5.637,571 ns </td><td>  37,5050 ns </td><td>  29,2814 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  56.498.987 ns </td><td>  294.8776 ns </td><td>  275,8287 ns </td><td>  10.02 </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  772.900 ns </td><td>  2,6802 ns </td><td>  2,5070 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  579,152 ns </td><td>  2,8371 ns </td><td>  2,6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  56.352,865 ns </td><td>  230,7916 ns </td><td>  215,8826 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  562,610,571 ns </td><td>  3,775.7631 ns </td><td>  3,152.9332 ns </td><td>  9.98 </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  8,389.647 ns </td><td>  165,9590 ns </td><td>  227,1666 ns </td><td>  0,15 </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  7,261.334 ns </td><td>  89,6468 ns </td><td>  69.9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Vergleich zweier Arrays: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10.000 </td><td>  7.033,8 ns </td><td>  50,636 ns </td><td>  47,365 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  64.841,4 ns </td><td>  289,157 ns </td><td>  270,478 ns </td><td>  9.22 </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  504,0 ns </td><td>  2,406 ns </td><td>  2,251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10.000 </td><td>  368,1 ns </td><td>  2,637 ns </td><td>  2,466 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  283,6 ns </td><td>  1,135 ns </td><td>  1,061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  85.214,4 ns </td><td>  903,868 ns </td><td>  845,478 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  702.279,4 ns </td><td>  2,846.609 ns </td><td>  2,662.720 ns </td><td>  8.24 </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  5,179,2 ns </td><td>  45,337 ns </td><td>  42,409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100.000 </td><td>  4,510,5 ns </td><td>  24,292 ns </td><td>  22.723 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  2.957,0 ns </td><td>  11.452 ns </td><td>  10,712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1.000.000 </td><td>  844.006,1 ns </td><td>  3,552.478 ns </td><td>  3,322.990 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6.483.079,3 ns </td><td>  42.641,040 ns </td><td>  39.886,455 ns </td><td>  7.68 </td></tr><tr><td>  Vektoren </td><td>  1.000.000 </td><td>  54.180,1 ns </td><td>  357,258 ns </td><td>  334.180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1.000.000 </td><td>  49.480,1 ns </td><td>  515,675 ns </td><td>  457,133 ns </td><td>  0,06 </td></tr><tr><td>  Intrinsics </td><td>  1.000.000 </td><td>  36.633,9 ns </td><td>  680,525 ns </td><td>  636,564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  Die Anzahl der Vorkommen eines Elements in einem Array: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10 </td><td>  8,844 ns </td><td>  0,0772 ns </td><td>  0,0603 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87,456 ns </td><td>  0,9496 ns </td><td>  0,8883 ns </td><td>  9,89 </td></tr><tr><td>  Vektoren </td><td>  10 </td><td>  3,140 ns </td><td>  0,0406 ns </td><td>  0,0380 ns </td><td>  0,36 </td></tr><tr><td>  Intrinsics </td><td>  10 </td><td>  13.813 ns </td><td>  0,0825 ns </td><td>  0,0772 ns </td><td>  1,56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100 </td><td>  107,310 ns </td><td>  0,6975 ns </td><td>  0,6183 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626,285 ns </td><td>  5,7677 ns </td><td>  5,3951 ns </td><td>  5.83 </td></tr><tr><td>  Vektoren </td><td>  100 </td><td>  11.844 ns </td><td>  0,2113 ns </td><td>  0,1873 ns </td><td>  0,11 </td></tr><tr><td>  Intrinsics </td><td>  100 </td><td>  19.616 ns </td><td>  0,1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1000 </td><td>  1.032,466 ns </td><td>  6,3799 ns </td><td>  5,6556 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6,266.605 ns </td><td>  42,6585 ns </td><td>  39,9028 ns </td><td>  6.07 </td></tr><tr><td>  Vektoren </td><td>  1000 </td><td>  83,417 ns </td><td>  0,5393 ns </td><td>  0,4780 ns </td><td>  0,08 </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  88,358 ns </td><td>  0,4921 ns </td><td>  0,4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  10.000 </td><td>  9.942,503 ns </td><td>  47,9732 ns </td><td>  40.0598 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  62.305.598 ns </td><td>  643,8775 ns </td><td>  502,6972 ns </td><td>  6.27 </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  914,967 ns </td><td>  7,2959 ns </td><td>  6,8246 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  931.698 ns </td><td>  6,3444 ns </td><td>  5,9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  94.834,804 ns </td><td>  793,8585 ns </td><td>  703,7349 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  626.620.968 ns </td><td>  4,696.9221 ns </td><td>  4.393,5038 ns </td><td>  6.61 </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  9.000,827 ns </td><td>  179,5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  8,690,771 ns </td><td>  101,7078 ns </td><td>  95,1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1.000.000 </td><td>  959,302,249 ns </td><td>  4,268.2488 ns </td><td>  3,783.6914 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6,218,681.888 ns </td><td>  31.321,9277 ns </td><td>  29.298.5506 ns </td><td>  6.48 </td></tr><tr><td>  Vektoren </td><td>  1.000.000 </td><td>  99.778,488 ns </td><td>  1,975.6001 ns </td><td>  4,252.6877 ns </td><td>  0,10 </td></tr><tr><td>  Intrinsics </td><td>  1.000.000 </td><td>  96.449,350 ns </td><td>  1,171.8067 ns </td><td>  978,5116 ns </td><td>  0,10 </td></tr></tbody></table></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435840/">https://habr.com/ru/post/de435840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435828/index.html">Mathe in Gamedev ist einfach. Einheitskurven und Wellen f√ºr Regeneffekt</a></li>
<li><a href="../de435830/index.html">OMEGA - Automatisierung des Timings von Sportveranstaltungen</a></li>
<li><a href="../de435834/index.html">EXAM - Modernste Textklassifizierungsmethode</a></li>
<li><a href="../de435836/index.html">Die gr√∂√üten Unternehmen der Wall Street vereinbaren, eine neue B√∂rse zu er√∂ffnen, um mit Nasdaq und NYSE zu konkurrieren</a></li>
<li><a href="../de435838/index.html">Lazy-Funktionen von JavaScript</a></li>
<li><a href="../de435842/index.html">Erstellen von 3D-Spielemodellen f√ºr die Armen: Indie Way</a></li>
<li><a href="../de435846/index.html">Konferenzen und Hackathons f√ºr Sch√ºler und Studenten: 11 thematische Veranstaltungen</a></li>
<li><a href="../de435848/index.html">Neue Ger√§te und Technologien mit CES 2019 von Microsoft und Partnern</a></li>
<li><a href="../de435854/index.html">Notizen eines Phytochemikers. Bananenradio</a></li>
<li><a href="../de435856/index.html">Welche Antivirenprogramme werden in modernen Firewalls verwendet?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>