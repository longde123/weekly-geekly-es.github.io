<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìà üë®‚Äçüëß‚Äçüëß ‚ôèÔ∏è Berhenti menggunakan Ngrx / efek untuk ini üíë üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® ü§üüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terkadang implementasi fungsionalitas yang paling sederhana pada akhirnya menciptakan lebih banyak masalah daripada yang baik, hanya meningkatkan komp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berhenti menggunakan Ngrx / efek untuk ini</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448858/"><img src="https://habrastorage.org/webt/73/82/fl/7382flctc9zmk_xd-mox_6ahrru.jpeg" alt="bust dengan efek"><br><br>  Terkadang implementasi fungsionalitas yang paling sederhana pada akhirnya menciptakan lebih banyak masalah daripada yang baik, hanya meningkatkan kompleksitas di tempat lain.  Hasil akhirnya adalah arsitektur zag yang tidak ingin disentuh oleh siapa pun. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Catatan Penerjemah</b> <div class="spoiler_text"><p>  Artikel ini ditulis pada tahun 2017, tetapi relevan untuk hari ini.  Ini ditujukan untuk orang yang berpengalaman dalam RxJS dan Ngrx, atau yang ingin mencoba Redux di Angular. </p><br>  Cuplikan kode diperbarui berdasarkan sintaks RxJS saat ini dan sedikit dimodifikasi untuk meningkatkan keterbacaan dan kemudahan pemahaman. <br></div></div><br><p> Ngrx / store adalah perpustakaan Angular yang membantu mengandung kompleksitas fungsi individu.  Salah satu alasannya adalah bahwa ngrx / store mencakup pemrograman fungsional, yang membatasi apa yang dapat dilakukan di dalam suatu fungsi untuk mencapai lebih banyak kewajaran di luarnya.  Di ngrx / store, hal-hal seperti reduksi (selanjutnya disebut reduksi), penyeleksi (selanjutnya disebut sebagai penyeleksi) dan operator RxJS adalah fungsi murni. </p><br><p>  Fungsi murni lebih mudah untuk menguji, men-debug, menganalisis, memparalelkan, dan menggabungkan.  Suatu fungsi bersih jika: </p><br><ul><li>  dengan input yang sama, selalu mengembalikan output yang sama; </li><li>  tidak ada efek samping. </li></ul><br><p>  Efek samping tidak dapat dihindari, tetapi mereka terisolasi di ngrx / store, sehingga sisa aplikasi dapat terdiri dari fungsi murni. </p><br><h3>  Efek samping </h3><br><p>  Saat pengguna mengirimkan formulir, kami perlu membuat perubahan di server.  Mengubah server dan merespons klien adalah efek samping.  Ini dapat ditangani dalam komponen: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data) <span class="hljs-comment"><span class="hljs-comment">// POST    .pipe(map(res =&gt; this.store.dispatch({ type: 'DATA_SAVED' }))) .subscribe();</span></span></code> </pre> <br><p>  Alangkah baiknya jika kita bisa mengirimkan tindakan (selanjutnya tindakan) di dalam komponen ketika pengguna mengirimkan formulir dan menangani efek samping di tempat lain. </p><br><p>  Ngrx / effects adalah middleware untuk menangani efek samping di ngrx / store.  Ia mendengarkan tindakan yang disampaikan dalam utas yang dapat diamati, melakukan efek samping, dan mengembalikan tindakan baru segera atau tidak sinkron.  Tindakan yang dikembalikan diteruskan ke peredam. </p><br><p>  Kemampuan untuk menangani efek samping dengan cara RxJS membuat kode lebih bersih.  Setelah mengirim tindakan awal <code>SAVE_DATA</code> dari komponen, Anda membuat kelas efek untuk menangani sisanya: </p><br><pre> <code class="javascript hljs">@Effect() saveData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>), pluck(<span class="hljs-string"><span class="hljs-string">'payload'</span></span>), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DATA_SAVED'</span></span> })), );</code> </pre><br><p>  Ini menyederhanakan operasi komponen hanya sebelum mengirim tindakan dan berlangganan dapat diamati. </p><br><h2>  Mudah disalahgunakan Ngrx / efek </h2><br><p>  Ngrx / efek adalah solusi yang sangat kuat, sehingga mudah disalahgunakan.  Berikut adalah beberapa pola anti-pola ngrx / store umum yang disederhanakan oleh Ngrx / efek: </p><br><h3>  1. Status rangkap </h3><br><p>  Misalkan Anda sedang mengerjakan beberapa jenis aplikasi multimedia, dan Anda memiliki properti berikut di pohon negara: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">mediaPlaying</span></span>: boolean; audioPlaying: boolean; videoPlaying: boolean; }</code> </pre><br><p>  Karena audio adalah jenis media, setiap kali pemutaran audio benar, <code>mediaPlaying</code> juga harus benar.  Jadi, inilah pertanyaannya: "Bagaimana cara memastikan mediaPlaying diperbarui ketika audioPlaying diperbarui?" </p><br><p>  <b>Jawaban tidak valid</b> : gunakan Ngrx / efek! </p><br><pre> <code class="javascript hljs">@Effect() playMediaWithAudio$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'PLAY_AUDIO'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'PLAY_MEDIA'</span></span> })), );</code> </pre><br><p>  <b>Jawaban yang benar adalah</b> : jika keadaan <code>mediaPlaying</code> sepenuhnya diprediksi oleh bagian lain dari pohon negara, maka ini bukan keadaan yang benar.  Ini adalah kondisi turunan.  Itu milik pemilih, bukan toko. </p><br><pre> <code class="javascript hljs">audioPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'audioPlaying'</span></span>); videoPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'videoPlaying'</span></span>); mediaPlaying$ = combineLatest(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioPlaying$, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.videoPlaying$).pipe( map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[audioPlaying, videoPlaying]</span></span></span><span class="hljs-function">) =&gt;</span></span> audioPlaying || videoPlaying), );</code> </pre><br><p>  Sekarang kondisi kami dapat tetap bersih dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">normal</a> , dan kami tidak menggunakan Ngrx / efek untuk sesuatu yang bukan efek samping. </p><br><h3>  2. Tindakan rantai dengan peredam </h3><br><p>  Bayangkan Anda memiliki properti ini di pohon negara Anda: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">items</span></span>: { [index: number]: Item }; favoriteItems: number[]; }</code> </pre><br><p>  Kemudian pengguna menghapus item.  Ketika permintaan penghapusan dikembalikan, tindakan <code>DELETE_ITEM_SUCCESS</code> dikirim untuk memperbarui status aplikasi kami.  Dalam peredam <code>items</code> , <code>Item</code> individual dihapus dari objek <code>items</code> .  Tetapi jika pengidentifikasi elemen ini ada dalam array <code>favoriteItems</code> , elemen yang dirujuknya akan tidak ada.  Jadi pertanyaannya adalah, bagaimana saya bisa memastikan pengidentifikasi dihapus dari <code>favoriteItems</code> saat mengirim tindakan <code>DELETE_ITEM_SUCCESS</code> ? </p><br><p>  <b>Jawaban tidak valid</b> : gunakan Ngrx / efek! </p><br><pre> <code class="javascript hljs">@Effect() removeFavoriteItemId$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM_ID'</span></span> })), );</code> </pre><br><p>  Jadi, sekarang kita akan memiliki dua tindakan yang dikirim satu demi satu, dan dua reducers mengembalikan negara baru satu demi satu. </p><br><p>  <b>Jawaban yang benar</b> : <code>DELETE_ITEM_SUCCESS</code> dapat diproses oleh peredam <code>items</code> dan peredam <code>items</code> <code>favoriteItems</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">favoriteItemsReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action: Action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemId = action.payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> id !== itemId); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre><br><p>  Tujuan dari tindakan ini adalah untuk memisahkan apa yang terjadi dari bagaimana negara harus berubah.  Apa yang terjadi adalah <code>DELETE_ITEM_SUCCESS</code> .  Tugas reduksi adalah menyebabkan perubahan yang sesuai di negara. </p><br><p>  Menghapus pengidentifikasi dari <code>favoriteItems</code> bukan efek samping dari menghapus <code>Item</code> .  Seluruh proses sepenuhnya disinkronkan dan dapat diproses oleh reduksi.  Ngrx / efek tidak diperlukan. </p><br><h3>  3. Minta data untuk komponen </h3><br><p>  Komponen Anda membutuhkan data dari toko, tetapi pertama-tama Anda harus mendapatkannya dari server.  Pertanyaannya adalah, bagaimana kita bisa meletakkan data di toko sehingga komponen dapat menerimanya? </p><br><p>  <b>Cara menyakitkan</b> : gunakan Ngrx / efek! </p><br><p>  Dalam komponen, kami memulai permintaan dengan mengirimkan tindakan: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> }); }</code> </pre><br><p>  Di kelas efek, kami mendengarkan <code>GET_USERS</code> : </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), );</code> </pre><br><p>  Sekarang anggaplah pengguna memutuskan bahwa rute tertentu membutuhkan waktu terlalu lama untuk dimuat, sehingga ia akan beralih dari satu rute ke rute lainnya.  Agar efisien dan tidak memuat data yang tidak perlu, kami ingin membatalkan permintaan ini.  Ketika komponen dihancurkan, kami akan berhenti berlangganan dari permintaan dengan mengirimkan tindakan: </p><br><pre> <code class="javascript hljs">ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> }); }</code> </pre><br><p>  Sekarang di kelas efek kita mendengarkan kedua tindakan: </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>, <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> action), switchMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> action.type === <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().pipe(map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users }))), ), );</code> </pre><br><p>  Bagus  Sekarang pengembang lain menambahkan komponen yang memerlukan permintaan HTTP yang sama (kami tidak akan membuat asumsi tentang komponen lain).  Komponen mengirimkan tindakan yang sama di tempat yang sama.  Jika kedua komponen aktif pada saat yang sama, komponen pertama memulai permintaan HTTP untuk menginisialisasi.  Ketika komponen kedua diinisialisasi, tidak ada tambahan yang akan terjadi, karena <code>needUsers</code> akan <code>false</code> .  Hebat! </p><br><p>  Kemudian, ketika komponen pertama dihancurkan, itu akan mengirim <code>CANCEL_GET_USERS</code> .  Tetapi komponen kedua masih membutuhkan data ini.  Bagaimana kita bisa mencegah permintaan agar tidak dibatalkan?  Mungkin kita akan memulai penghitung semua pelanggan?  Saya tidak akan mengimplementasikan ini, tapi saya kira Anda mengerti intinya.  Kami mulai curiga bahwa ada cara yang lebih baik untuk mengelola dependensi data ini. </p><br><p>  Sekarang anggaplah komponen lain muncul, dan itu tergantung pada data yang tidak dapat diambil sampai data <code>users</code> muncul di toko.  Ini mungkin koneksi ke soket web untuk mengobrol, informasi tambahan tentang beberapa pengguna, atau sesuatu yang lain.  Kami tidak tahu apakah komponen ini akan diinisialisasi sebelum atau setelah berlangganan dua komponen lain kepada <code>users</code> . </p><br><p>  Bantuan terbaik yang saya temukan untuk skenario khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos yang luar biasa ini</a> .  Dalam contohnya, <code>callApiY</code> mengharuskan <code>callApiX</code> sudah selesai.  Saya menghapus komentar agar tidak terlalu mengintimidasi, tetapi jangan ragu untuk membaca posting asli untuk mengetahui lebih lanjut: </p><br><pre> <code class="javascript hljs">@Effect() actionX$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>), map(toPayload), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiX(payload).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err })), ), ), ); @Effect() actionY$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_Y'</span></span>), map(toPayload), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> state.someBoolean)), switchMap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[payload, someBoolean]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callHttpY = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiY(v).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err, }), ), ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someBoolean) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>, payload }).merge( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>), first(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'Because ACTION_X failed.'</span></span>, }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); }), ), ); }), );</code> </pre><br><p>  Sekarang tambahkan persyaratan bahwa permintaan HTTP harus dibatalkan ketika komponen tidak lagi membutuhkannya, dan ini akan menjadi lebih kompleks. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  Jadi, mengapa ada begitu banyak masalah dengan manajemen ketergantungan data ketika RxJS harus membuatnya sangat mudah? </p><br><p>  Meskipun data yang berasal dari server secara teknis adalah efek samping, menurut saya Ngrx / efek adalah cara terbaik untuk menangani ini. </p><br><p>  Komponen adalah antarmuka input / output pengguna.  Mereka menunjukkan data dan mengirim tindakan yang dilakukan olehnya.  Ketika komponen dimuat, itu tidak mengirim tindakan apa pun yang dilakukan oleh pengguna ini.  Dia ingin menunjukkan data.  Ini lebih seperti langganan daripada efek samping. </p><br><p>  Sangat sering Anda dapat melihat aplikasi yang menggunakan tindakan untuk memulai permintaan data.  Aplikasi ini menerapkan antarmuka khusus untuk dapat diamati melalui efek samping.  Dan, seperti yang kita lihat, antarmuka ini bisa menjadi sangat merepotkan dan tidak praktis.  Berlangganan, berhenti berlangganan, dan menghubungkan diri yang diamati itu jauh lebih mudah. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  <b>Cara yang tidak menyakitkan</b> : komponen akan mendaftarkan minatnya pada data dengan berlangganan kepada mereka melalui diamati. </p><br><p>  Kami akan membuat observable yang berisi permintaan HTTP yang diperlukan.  Kita akan melihat betapa lebih mudahnya mengelola beberapa langganan dan rantai kueri yang saling bergantung menggunakan RxJS murni, daripada melakukan ini melalui efek. </p><br><p>  Buat ini dapat diamati di layanan: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), finalize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), );</code> </pre><br><p>  Berlangganan ke <code>users$</code> akan dikirimkan baik untuk <code>requireUsers$</code> dan <code>this.store.pipe(select(selectUsers))</code> , tetapi data hanya akan diterima dari <code>this.store.pipe(select(selectUsers))</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>muteFirst</code></a> implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>muteFirst</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>muteFirst</code></a> implementasi tetap dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ujiannya</a> .) </p><br><p>  Dalam komponen: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.users$; }</code> </pre><br><p>  Karena ketergantungan data ini sekarang mudah diamati, kami dapat berlangganan dan berhenti berlangganan di templat menggunakan pipa <code>async</code> , dan kami tidak perlu lagi mengirim tindakan.  Jika aplikasi meninggalkan rute komponen terakhir yang ditandatangani untuk data, permintaan HTTP dibatalkan atau soket web ditutup. </p><br><p>  Rantai ketergantungan data dapat diproses seperti ini: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), ); requireUsersExtraData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$.pipe( withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectNeedUsersExtraData))), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[users, needData]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(users.length) &amp;&amp; needData), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS_EXTRA_DATA'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS_EXTRA_DATA'</span></span>, users, }), ), share(), ); public usersExtraData$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsersExtraData$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsersExtraData)), );</code> </pre><br><p>  Berikut ini adalah perbandingan paralel dari metode di atas dengan metode ini: </p><br><img src="https://habrastorage.org/webt/xd/cb/ho/xdcbhozsjus5vu64eqp9x8nsnuy.png" alt="perbandingan paralel"><br><br><p>  Menggunakan murni yang dapat diamati membutuhkan lebih sedikit baris kode dan secara otomatis berhenti berlangganan dari ketergantungan data di seluruh rantai.  (Saya melewatkan pernyataan <code>finalize</code> yang awalnya termasuk untuk membuat perbandingan lebih dimengerti, tetapi bahkan tanpa mereka, permintaan masih akan dibatalkan.) </p><br><img src="https://habrastorage.org/webt/mj/2m/pc/mj2mpclzeric84dwrap4c5fpkqm.jpeg" alt="efek seperti ceri dalam koktail"><br><br><h2>  Kesimpulan </h2><br><p>  Ngrx / efek adalah alat yang hebat!  Tetapi pertimbangkan pertanyaan-pertanyaan ini sebelum menggunakannya: </p><br><ul><li>  Apakah ini benar-benar efek samping? </li><li>  Apakah Ngrx / efek cara terbaik untuk melakukan ini? </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448858/">https://habr.com/ru/post/id448858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448840/index.html">Acara digital di Moskow dari 22 hingga 28 April</a></li>
<li><a href="../id448842/index.html">Monitor Kualitas Udara Honeywell HAQ</a></li>
<li><a href="../id448846/index.html">Yang penting jangan dilupakan saat menerapkan Agile di perusahaan besar</a></li>
<li><a href="../id448854/index.html">Dragon Crew meledak</a></li>
<li><a href="../id448856/index.html">Torfon - aplikasi mobile untuk telepon anonim</a></li>
<li><a href="../id448860/index.html">Catatan Rilis Android Studio 3.4 (April 2019)</a></li>
<li><a href="../id448866/index.html">Detail transisi dari nilai tukar berpasangan (relatif) ke absolut. Menangani kesalahan</a></li>
<li><a href="../id448868/index.html">Intisari materi menarik untuk pengembang ponsel # 295 (pada 15 - 21 April)</a></li>
<li><a href="../id448870/index.html">Optlib Implementasi algoritma optimasi genetik di Rust</a></li>
<li><a href="../id448872/index.html">Terjemahan buku interkom tentang manajemen produk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>