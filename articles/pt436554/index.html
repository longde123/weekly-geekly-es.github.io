<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè© ü§∑üèΩ üë®üèº‚Äçüî¨ Transfira 30.000 linhas de c√≥digo do Flow para o TypeScript ‚ôæ üçÑ ‚ô®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, transferimos 30.000 linhas de c√≥digo JavaScript do nosso sistema MemSQL Studio do Flow para o TypeScript. Neste artigo, explicarei por q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transfira 30.000 linhas de c√≥digo do Flow para o TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436554/">  Recentemente, transferimos 30.000 linhas de c√≥digo JavaScript do nosso sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemSQL Studio</a> do Flow para o TypeScript.  Neste artigo, explicarei por que portamos a base de c√≥digo, como aconteceu e o que aconteceu. <br><br>  <i>Isen√ß√£o de responsabilidade: meu objetivo n√£o √© criticar a Flow.</i>  <i>Admiro o projeto e acho que h√° espa√ßo suficiente na comunidade JavaScript para as duas op√ß√µes de verifica√ß√£o de tipo.</i>  <i>No final, todos escolher√£o o que melhor lhe convier.</i>  <i>Espero sinceramente que o artigo ajude nessa escolha.</i> <br><br>  Primeiro, vou atualiz√°-lo.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemSQL, somos</a> grandes f√£s da digita√ß√£o est√°tica e forte do JavaScript para evitar problemas comuns com a digita√ß√£o din√¢mica e fraca. <br><a name="habracut"></a><br>  Discurso sobre problemas comuns: <br><br><ol><li>  Digite erros no tempo de execu√ß√£o devido ao fato de que diferentes partes do c√≥digo n√£o s√£o correspondidas por tipos impl√≠citos. </li><li>  √â gasto muito tempo escrevendo testes para coisas triviais, como a verifica√ß√£o de par√¢metros de tipo (a verifica√ß√£o no tempo de execu√ß√£o tamb√©m aumenta o tamanho do pacote). </li><li> H√° uma falta de integra√ß√£o editor / IDE, porque sem a digita√ß√£o est√°tica, √© muito mais dif√≠cil implementar a fun√ß√£o Ir para a defini√ß√£o, refatora√ß√£o mec√¢nica e outras fun√ß√µes. </li><li>  N√£o h√° como escrever c√≥digo em torno de modelos de dados, ou seja, primeiro projetar tipos de dados e, em seguida, o c√≥digo basicamente "se escreve". </li></ol><br>  Esses s√£o apenas alguns dos benef√≠cios da digita√ß√£o est√°tica, listados em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo recente sobre o Flow</a> . <br><br>  No in√≠cio de 2016, implementamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tcomb</a> para implementar algum tipo de seguran√ßa no tempo de execu√ß√£o de um de nossos projetos JavaScript internos (aviso de isen√ß√£o de responsabilidade: n√£o lidei com esse projeto).  Embora a verifica√ß√£o em tempo de execu√ß√£o √†s vezes seja √∫til, ela nem fornece todos os benef√≠cios da digita√ß√£o est√°tica (a combina√ß√£o de digita√ß√£o est√°tica e verifica√ß√£o de tipo em tempo de execu√ß√£o pode ser adequada para certos casos, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">io-ts</a> permite fazer isso com tcomb e TypeScript, embora eu nunca tenha tentado )  Entendendo isso, decidimos implementar o Flow para outro projeto que iniciamos em 2016.  Naquela √©poca, o Flow parecia uma √≥tima op√ß√£o: <br><br><ul><li>  Suporte do Facebook, que fez um trabalho incr√≠vel no desenvolvimento do React e no crescimento da comunidade (eles tamb√©m desenvolveram o React <i>with</i> Flow). </li><li>  Aproximadamente o mesmo ecossistema de desenvolvimento JavaScript.  Foi assustador abandonar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Babel</a> for tsc (compilador TypeScript) porque perdemos a flexibilidade de mudar para outra verifica√ß√£o de tipo (obviamente, a situa√ß√£o mudou desde ent√£o). </li><li>  N√£o h√° necessidade de digitar toda a base de c√≥digo (quer√≠amos ter uma id√©ia do JavaScript digitado estaticamente antes de entrar no programa), mas apenas parte dos arquivos.  Observe que agora o Flow e o TypeScript permitem isso. </li><li>  O TypeScript (na √©poca) carecia de algumas das fun√ß√µes b√°sicas que est√£o dispon√≠veis agora, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√£o tipos de pesquisa</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">par√¢metros padr√£o para tipos gen√©ricos</a> etc. </li></ul><br>  Quando come√ßamos a trabalhar no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MemSQL Studio,</a> no final de 2017, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cobrir√≠amos</a> tipos de todo o aplicativo (ele √© inteiramente escrito em JavaScript: o frontend e o backend s√£o executados no navegador).  Tomamos o Flow como uma ferramenta que usamos com sucesso no passado. <br><br>  Mas minha aten√ß√£o foi atra√≠da para o <a href="">Babel 7 com suporte ao TypeScript</a> .  Esta vers√£o significava que a mudan√ßa para o TypeScript n√£o exigia mais uma transi√ß√£o para todo o ecossistema do TypeScript, e voc√™ poderia continuar usando o Babel para JavaScript.  Mais importante, poder√≠amos <b>usar o TypeScript apenas para verifica√ß√£o de tipo</b> , e n√£o como uma "linguagem" completa. <br><br>  Pessoalmente, acredito que separar a verifica√ß√£o de tipo do gerador de c√≥digo √© uma maneira mais elegante de digitar est√°tica (e forte) em JavaScript, porque: <br><br><ol><li>  Compartilhamos os problemas de c√≥digo e digita√ß√£o.  Isso reduz as paradas de verifica√ß√£o e acelera o desenvolvimento: se por algum motivo a verifica√ß√£o de tipo for lenta, o c√≥digo ainda ser√° gerado corretamente (se voc√™ usar tsc com Babel, poder√° configur√°-lo para fazer o mesmo). </li><li>  Babel possui √≥timos plugins e recursos que o gerador TypeScript n√£o possui.  Por exemplo, o Babel permite que voc√™ especifique os navegadores suportados e emite automaticamente o c√≥digo para eles.  Essa √© uma fun√ß√£o muito complexa e n√£o faz sentido apoi√°-la em dois projetos diferentes ao mesmo tempo. </li><li>  Eu gosto do JavaScript como uma linguagem de programa√ß√£o (exceto pela falta de digita√ß√£o est√°tica) e n√£o tenho id√©ia do quanto o TypeScript existir√°, enquanto acredito em muitos anos de ECMAScript.  Portanto, prefiro escrever e "pensar" em JavaScript (observe que digo "use Flow" ou "use TypeScript" em vez de "write in Flow" ou "TypeScript", porque eu sempre os represento com ferramentas, n√£o com linguagens de programa√ß√£o). </li></ol><br>  Obviamente, essa abordagem tem algumas desvantagens: <br><br><ol><li>  O compilador TypeScript pode teoricamente executar otimiza√ß√µes baseadas em tipo, mas aqui perdemos essa oportunidade. </li><li>  A configura√ß√£o do projeto √© um pouco mais complicada com um aumento no n√∫mero de ferramentas e depend√™ncias.  Penso que este √© um argumento relativamente fraco: um monte de Babel e Flow nunca nos decepcionaram. </li></ol><br><h1>  TypeScript como uma alternativa ao Flow </h1><br>  Percebi um crescente interesse no TypeScript na comunidade JavaScript: online e entre os desenvolvedores.  Portanto, assim que descobri que o Babel 7 suporta TypeScript, comecei imediatamente a estudar poss√≠veis op√ß√µes de transi√ß√£o.  Al√©m disso, encontramos algumas das desvantagens do Flow: <br><br><ol><li>  Menor qualidade da integra√ß√£o editor / IDE (em compara√ß√£o com o TypeScript).  O Nuclide, o IDE do Facebook com a melhor integra√ß√£o, j√° est√° desatualizado. </li><li>  Uma comunidade menor, que significa menos defini√ß√µes de tipo para bibliotecas diferentes, e elas s√£o de qualidade inferior (atualmente o reposit√≥rio DefinitelyTyped possui 19 682 estrelas do GitHub e o reposit√≥rio com tipo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fluxo</a> possui apenas 3070). </li><li>  Falta de um plano de desenvolvimento p√∫blico e pouca intera√ß√£o entre a equipe do Flow no Facebook e a comunidade.  Voc√™ pode ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este coment√°rio</a> de um funcion√°rio do Facebook para entender a situa√ß√£o. </li><li>  Alto consumo de mem√≥ria e vazamentos frequentes - para alguns de nossos desenvolvedores, o Flow √†s vezes ocupava quase 10 GB de RAM. </li></ol><br>  Obviamente, voc√™ deve estudar como o TypeScript nos conv√©m.  Essa √© uma pergunta muito complexa: o estudo do t√≥pico incluiu uma leitura completa da documenta√ß√£o, o que ajudou a entender que para todas as fun√ß√µes do Flow existe um TypeScript equivalente.  Depois, explorei o plano de desenvolvimento p√∫blico do TypeScript e gostei muito dos recursos planejados para o futuro (por exemplo, deriva√ß√£o parcial dos argumentos de tipo que usamos no Flow). <br><br><h1>  Transfira mais de 30 mil linhas de c√≥digo do Flow para o TypeScript </h1><br>  Para iniciantes, voc√™ deve atualizar o Babel de 6 para 7. Essa tarefa simples levou 16 horas-homem, pois decidimos atualizar o Webpack 3 para 4. Ao mesmo tempo, algumas depend√™ncias obsoletas em nosso c√≥digo complicaram a tarefa.  A grande maioria dos projetos JavaScript n√£o ter√° esses problemas. <br><br>  Depois disso, substitu√≠mos a predefini√ß√£o Babel Flow pela nova predefini√ß√£o TypeScript e, pela primeira vez, executamos o compilador TypeScript em todas as nossas fontes escritas com Flow.  O resultado s√£o <b>erros de sintaxe 8245</b> (o tsc CLI n√£o mostra erros reais para o projeto at√© que todos os erros de sintaxe tenham sido corrigidos). <br><br>  A princ√≠pio, esse n√∫mero nos assustou (muito), mas rapidamente percebemos que a maioria dos erros se devia ao TypeScript n√£o suportar arquivos .js.  Tendo estudado o t√≥pico, aprendi que os arquivos TypeScript devem terminar com .ts ou .tsx (se eles tiverem JSX).  Isso me parece um claro inconveniente.  Para n√£o pensar na presen√ßa / aus√™ncia do JSX, simplesmente renomeei todos os arquivos para .tsx. <br><br>  Cerca de 4.000 erros de sintaxe permanecem.  A maioria deles est√° relacionada ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo de importa√ß√£o</a> , que com o TypeScript pode ser substitu√≠do simplesmente pela importa√ß√£o, bem como √† diferen√ßa na designa√ß√£o de objetos ( <code>{||}</code> vez de <code>{}</code> ).  Aplicando rapidamente algumas express√µes regulares, deixamos 414 erros de sintaxe.  Tudo o resto tinha que ser corrigido manualmente: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O tipo existencial</a> , que usamos para derivar parcialmente argumentos de um tipo gen√©rico, deve ser substitu√≠do por argumentos expl√≠citos ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desconhecidos</a> para informar ao TypeScript que alguns argumentos n√£o s√£o importantes. </li><li>  Digite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">$ Keys</a> e outros tipos avan√ßados de fluxo t√™m uma sintaxe diferente no TypeScript (por exemplo, <code>$Shape‚Äú‚Äù</code> corresponde a <code>Partial‚Äú‚Äù</code> no TypeScript). </li></ul><br>  Depois de corrigir todos os erros de sintaxe, o tsc finalmente disse quantos erros de tipo real em nossa base de c√≥digo s√£o apenas 1300. Agora tivemos que sentar e decidir se continuaria ou n√£o.  Afinal, se a migra√ß√£o demorar semanas, √© melhor permanecer no Flow.  No entanto, decidimos que a portabilidade de c√≥digo exigiria menos de uma semana de trabalho por um engenheiro, o que √© bastante aceit√°vel. <br><br>  Observe que, durante a migra√ß√£o, tive que interromper todo o trabalho nessa base de c√≥digo.  No entanto, em paralelo, voc√™ pode iniciar novos projetos - mas voc√™ deve ter em mente centenas de erros de tipo no c√≥digo existente, o que n√£o √© f√°cil. <br><br><h1>  Que tipo de erros? </h1><br>  O TypeScript e o Flow processam o c√≥digo JavaScript de v√°rias maneiras.  Portanto, o Flow √© mais rigoroso em rela√ß√£o a algumas coisas e o TypeScript - em rela√ß√£o a outras.  Uma compara√ß√£o profunda dos dois sistemas ser√° muito longa, ent√£o veja alguns exemplos. <br><br>  Nota: todos os links para a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sandbox TypeScript</a> assumem par√¢metros "estritos".  Infelizmente, quando voc√™ compartilha um link, essas op√ß√µes n√£o s√£o armazenadas no URL.  Portanto, eles devem ser definidos manualmente ap√≥s abrir qualquer link para a sandbox deste artigo. <br><br><h3>  invariant.js </h3><br>  A fun√ß√£o <code>invariant</code> acabou sendo muito comum em nosso c√≥digo fonte.  Apenas para citar a documenta√ß√£o: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> invariant = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'invariant'</span></span>); invariant(someTruthyVal, <span class="hljs-string"><span class="hljs-string">'This will not throw'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// No errors invariant(someFalseyVal, 'This will throw an error with this message'); // Error raised: Invariant Violation: This will throw an error with this message</span></span></code> </pre> <br>  A ideia √© clara: uma fun√ß√£o simples que gera um erro em alguma condi√ß√£o.  Vamos ver como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implement√°-lo e us√°-lo</a> no Flow: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invariant</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">condition: boolean, message: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!condition) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(message); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { invariant(x !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  Agora <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregue o mesmo trecho no TypeScript</a> .  Como voc√™ pode ver no link, o TypeScript comete um erro, porque n√£o √© poss√≠vel entender que <code>x</code> garantido para n√£o permanecer <code>undefined</code> ap√≥s a √∫ltima linha.  Na verdade, esse √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema bem conhecido</a> - o TypeScript (por enquanto) n√£o sabe como fazer essa infer√™ncia por meio de uma fun√ß√£o.  No entanto, este √© um modelo muito comum em nossa base de c√≥digo, ent√£o tive que substituir manualmente cada inst√¢ncia invari√°vel (mais de 150 partes) por outro c√≥digo que imediatamente emitisse um erro: <br><br><pre> <code class="javascript hljs">type Maybe&lt;T&gt; = T | <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x: Maybe&lt;number&gt;, c: number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"When c is positive, x should never be undefined"</span></span>); } (x + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// works because x has been refined to "number" } }</span></span></code> </pre> <br>  N√£o √© realmente comparado a <code>invariant</code> , mas n√£o √© uma quest√£o t√£o importante. <br><br><h3>  $ ExpectError vs @ ts-ignore </h3><br>  O fluxo tem uma fun√ß√£o muito interessante, semelhante a <code>@ts-ignore</code> , exceto que gera um erro se a pr√≥xima linha <b>n√£o</b> for um erro.  Isso √© muito √∫til para escrever "testes de tipo" que garantem que a verifica√ß√£o de tipo (seja TypeScript ou Flow) encontre certos erros de tipo. <br><br>  Infelizmente, o TypeScript n√£o possui essa fun√ß√£o, portanto nossos testes perderam algum valor.  Estou ansioso para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implementar esta fun√ß√£o no TypeScript</a> . <br><br><h3>  Erros de tipo gen√©rico e infer√™ncia de tipo </h3><br>  Geralmente, o TypeScript permite um c√≥digo mais expl√≠cito que o Flow, como neste exemplo: <br><br><pre> <code class="javascript hljs">type Leaf = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"LEAF"</span></span>; }; type Aggregator = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: string; port: number; type: <span class="hljs-string"><span class="hljs-string">"AGGREGATOR"</span></span>; } type MemsqlNode = Leaf | Aggregator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leaves: Array&lt;Leaf&gt;, aggregators: Array&lt;Aggregator&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemsqlNode</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// The next line errors because you cannot concat aggregators to leaves. return leaves.concat(aggregators); }</span></span></code> </pre> <br>  O fluxo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deduz o tipo leaves.concat (agregadores) como Matriz &lt;Folha |</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agregador&gt;</a> , que pode ser <code>Array&lt;MemsqlNode&gt;</code> na <code>Array&lt;MemsqlNode&gt;</code> .  Acho que este √© um bom exemplo em que o Flow pode ser um pouco mais inteligente e o TypeScript precisa de uma pequena ajuda: nesse caso, podemos aplicar uma asser√ß√£o de tipo, mas isso √© perigoso e deve ser feito com muito cuidado. <br><br>  Embora eu n√£o tenha nenhuma evid√™ncia formal, acredito que o Flow seja muito superior ao TypeScript na infer√™ncia de tipo.  Eu realmente espero que o TypeScript atinja o n√≠vel Flow, pois a linguagem est√° se desenvolvendo muito ativamente e muitas melhorias recentes foram feitas nessa √°rea.  Em muitos lugares do nosso c√≥digo, o TypeScript teve que ajudar um pouco nas anota√ß√µes ou nas afirma√ß√µes de tipo, embora tenhamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">evitado o</a> m√°ximo poss√≠vel.  Vamos considerar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais um exemplo</a> (tivemos mais de 200 desses erros): <br><br><pre> <code class="javascript hljs">type Player = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string; age: number; position: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span> | <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }; type F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;Player&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> f1: F = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"David Gomes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"GOALKEEPER"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Cristiano Ronaldo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-attr"><span class="hljs-attr">position</span></span>: <span class="hljs-string"><span class="hljs-string">"STRIKER"</span></span>, } ]); };</code> </pre> <br>  O TypeScript n√£o permitir√° que voc√™ escreva isso porque n√£o permitir√° que voc√™ declare <code>{ name: "David Gomes", age: 23, type: "GOALKEEPER" }</code> como um objeto do tipo <code>Player</code> (consulte o sandbox para obter o erro exato).  Este √© outro caso em que considero que o TypeScript n√£o √© inteligente o suficiente (pelo menos em compara√ß√£o com o Flow, que entende esse c√≥digo). <br><br>  Existem v√°rias op√ß√µes para corrigir isso: <br><br><ul><li>  Declare <code>"STRIKER"</code> como <code>"STRIKER"</code> para que TypeScript entenda que a string √© uma enumera√ß√£o v√°lida do tipo <code>"STRIKER" | "GOALKEEPER"</code>  <code>"STRIKER" | "GOALKEEPER"</code> . </li><li>  Declare todos os objetos como <code>Player</code> . </li><li>  Ou o que considero ser a melhor solu√ß√£o: ajude o TypeScript sem usar nenhuma instru√ß√£o de tipo escrevendo <code>Promise.all&lt;Player&gt;(...)</code> . </li></ul><br>  Aqui est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro exemplo</a> (TypeScript) em que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flow √© novamente melhor na infer√™ncia de tipo</a> : <br><br><pre> <code class="javascript hljs">type Connection = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: number }; declare <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connection</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveConnection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolve(getConnection()); }) } resolveConnection().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">conn</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TypeScript errors in the next line because it does not understand // that conn is of type Connection. We have to manually annotate // resolveConnection as Promise&lt;Connection&gt;. (conn.id); });</span></span></code> </pre> <br>  Um exemplo muito pequeno, mas interessante: o fluxo considera a <code>Array&lt;T&gt;.pop()</code> tipo <code>T</code> e o TypeScript considera como <code>T | void</code>  <code>T | void</code>  Um ponto a favor do TypeScript, porque obriga a verificar duas vezes a exist√™ncia de um elemento (se a matriz estiver vazia, ent√£o <code>Array.pop</code> retornar√° <code>undefined</code> ).  Existem v√°rios outros pequenos exemplos como este, em que o TypeScript √© superior ao Flow. <br><br><h3>  Defini√ß√µes TypeScript para depend√™ncias de terceiros </h3><br>  Obviamente, ao escrever qualquer aplicativo JavaScript, voc√™ ter√° pelo menos algumas depend√™ncias.  Eles devem ser digitados, caso contr√°rio, voc√™ perder√° a maioria das possibilidades de an√°lise de tipo est√°tico (conforme descrito no in√≠cio do artigo). <br><br>  As bibliotecas do npm podem vir com defini√ß√µes de tipo Flow ou TypeScript, com ou sem ambas.  Freq√ºentemente (pequenas) bibliotecas n√£o s√£o fornecidas com uma ou outra, portanto, voc√™ deve escrever suas pr√≥prias defini√ß√µes de tipo ou emprest√°-las da comunidade.  O Flow e o TypeScript suportam reposit√≥rios de defini√ß√£o padr√£o para pacotes JavaScript de terceiros: s√£o do tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">flow</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DefinitelyTyped</a> . <br><br>  Devo dizer que DefinitelyTyped gostamos muito mais.  Com o tipo de fluxo, tive que usar a ferramenta CLI para introduzir defini√ß√µes de tipo para v√°rias depend√™ncias no projeto.  DefinitelyTyped combina essa fun√ß√£o com a ferramenta CLI npm enviando <code>@types/package-name</code> packages para o reposit√≥rio de pacotes npm.  Isso √© muito legal e simplificou bastante a entrada de defini√ß√µes de tipo para nossas depend√™ncias (brincadeira, rea√ß√£o, lodash, rea√ß√£o-redux, essas s√£o apenas algumas). <br><br>  Al√©m disso, eu me diverti bastante preenchendo o banco de dados DefinitelyTyped (n√£o pense que as defini√ß√µes de tipo sejam equivalentes ao transportar c√≥digo do Flow para o TypeScript).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">J√°</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enviei</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algumas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solicita√ß√µes pull</a> e n√£o houve problemas em nenhum lugar.  Apenas clone o reposit√≥rio, edite as defini√ß√µes de tipo, adicione testes - e envie uma solicita√ß√£o pull.  O bot do GitHub DefinitelyTyped marca os autores das defini√ß√µes que voc√™ editou.  Se nenhum deles fornecer feedback dentro de sete dias, a solicita√ß√£o de recebimento ser√° enviada para considera√ß√£o do mantenedor.  Ap√≥s mesclar com a ramifica√ß√£o principal, uma nova vers√£o do pacote de depend√™ncia √© enviada para o npm.  Por exemplo, quando atualizei o pacote @ types / redux-form pela primeira vez, a vers√£o 7.4.14 foi enviada automaticamente para o npm.  portanto, basta atualizar o arquivo package.json para obter novas defini√ß√µes de tipo.  Se voc√™ n√£o puder esperar a ado√ß√£o da solicita√ß√£o de recebimento, sempre poder√° alterar as defini√ß√µes dos tipos usados ‚Äã‚Äãno seu projeto, conforme descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em um dos artigos anteriores</a> . <br><br>  Em geral, a qualidade das defini√ß√µes de tipo no DefinitelyTyped √© muito melhor devido √† comunidade TypeScript maior e mais pr√≥spera.  De fato, ap√≥s a transfer√™ncia do projeto para o TypeScript <b>, nossa cobertura de tipo aumentou de 88% para 96%</b> , principalmente devido a melhores defini√ß√µes de tipos de depend√™ncia de terceiros, com menos tipos. <br><br><h1>  Fiapos e testes </h1><br><ol><li>  Mudamos de eslint para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tslint</a> (com eslint para TypeScript, parecia mais dif√≠cil come√ßar). </li><li>  Os testes TypeScript usam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ts-jest</a> .  Alguns dos testes s√£o digitados, enquanto outros n√£o (se digitados por muito tempo, os salvamos como arquivos .js). </li></ol><br><h1>  O que aconteceu depois de corrigir todos os erros de digita√ß√£o? </h1><br>  Ap√≥s 40 horas de trabalho, alcan√ßamos o √∫ltimo erro de digita√ß√£o, adiando-o por um tempo usando <code>@ts-ignore</code> . <br><br>  Depois de revisar os coment√°rios de revis√£o de c√≥digo e corrigir alguns bugs (infelizmente, tive que alterar um pouco o c√≥digo de tempo de execu√ß√£o para corrigir a l√≥gica que o TypeScript n√£o conseguia entender), a solicita√ß√£o pull desapareceu e, desde ent√£o, usamos o TypeScript.  (E sim, corrigimos o √∫ltimo <code>@ts-ignore</code> na pr√≥xima solicita√ß√£o de recebimento). <br><br>  Al√©m da integra√ß√£o com o editor, o trabalho com o TypeScript √© muito semelhante ao trabalho com o Flow.  O desempenho do servidor de fluxo √© um pouco maior, mas esse n√£o √© um grande problema, porque eles geram erros para o arquivo atual de maneira igualmente r√°pida.  A √∫nica diferen√ßa de desempenho √© que o TypeScript relata um novo erro ap√≥s salvar o arquivo um pouco mais tarde (de 0,5 a 1 s).  O tempo de inicializa√ß√£o do servidor √© aproximadamente o mesmo (cerca de 2 minutos), mas n√£o √© t√£o importante.  At√© agora, n√£o tivemos problemas com o consumo de mem√≥ria.  Parece que o tsc usa constantemente cerca de 600 MB. <br><br>  Pode parecer que a fun√ß√£o de infer√™ncia de tipo d√™ ao Flow uma grande vantagem, mas h√° duas raz√µes pelas quais isso realmente n√£o importa: <br><br><ol><li>  Convertemos a base de c√≥digo do Flow em TypeScript.  Obviamente, encontramos apenas o c√≥digo que o Flow pode expressar, mas o TypeScript n√£o.  Se a migra√ß√£o tivesse acontecido na dire√ß√£o oposta, tenho certeza de que haveria coisas que o TypeScript melhor exibe / expressa. </li><li>  A infer√™ncia de tipo √© importante para ajudar a escrever um c√≥digo mais conciso.  Mas, ainda assim, outras coisas s√£o mais importantes, como uma comunidade forte e a disponibilidade de defini√ß√µes de tipo, porque a infer√™ncia de tipo fraca pode ser corrigida gastando um pouco mais de tempo na digita√ß√£o. </li></ol><br><h3>  Estat√≠sticas de c√≥digo </h3><br><pre> <code class="bash hljs">$ npm run <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-coverage <span class="hljs-comment"><span class="hljs-comment"># https://github.com/plantain-00/type-coverage 43330 / 45047 96.19% $ cloc # ignoring tests and dependencies -------------------------------------------------------------------------------- Language files blank comment code -------------------------------------------------------------------------------- TypeScript 330 5179 1405 31463</span></span></code> </pre> <br><h1>  O que vem a seguir? </h1><br>  N√£o terminamos de melhorar a an√°lise de tipo est√°tico.  O MemSQL tem outros projetos que eventualmente mudar√£o do Flow para o TypeScript (e alguns projetos JavaScript que come√ßar√£o a usar o TypeScript), e queremos tornar nossa configura√ß√£o do TypeScript mais rigorosa.  Atualmente, temos a op√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strictNullChecks ativada</a> , mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">noImplicitAny</a> ainda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√°</a> desativado.  Tamb√©m removeremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algumas instru√ß√µes de tipo perigoso</a> do c√≥digo. <br><br>  √â um prazer compartilhar com voc√™s tudo o que aprendi durante minhas aventuras com a digita√ß√£o de JavaScript.  Se voc√™ estiver interessado em um t√≥pico espec√≠fico, entre em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contato</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436554/">https://habr.com/ru/post/pt436554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436544/index.html">O Marketplace responder√° por tudo</a></li>
<li><a href="../pt436546/index.html">Desenvolvimento de uma equipe para consultar dados do banco de dados - parte 3</a></li>
<li><a href="../pt436548/index.html">Programa de Educa√ß√£o em Realidade Virtual</a></li>
<li><a href="../pt436550/index.html">Gra√ßas ao rob√¥, os cientistas aprenderam como um dos primeiros habitantes de sushi andava</a></li>
<li><a href="../pt436552/index.html">Obitu√°rio √† morte do Chromecast Audio ou por que o Google matou discos pretos</a></li>
<li><a href="../pt436556/index.html">Empregos em uma empresa alem√£ - como se inscrever e n√£o obter uma recusa?</a></li>
<li><a href="../pt436558/index.html">Feliz anivers√°rio de 18 anos, Wikipedia; comemorando a maioridade de um bom projeto</a></li>
<li><a href="../pt436560/index.html">Protocolos criptogr√°ficos para vota√ß√£o eletr√¥nica</a></li>
<li><a href="../pt436564/index.html">Como o ProGuard funciona</a></li>
<li><a href="../pt436568/index.html">Plataforma de v√≠deo pr√≥pria ou como usar muitos recursos de computa√ß√£o. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>