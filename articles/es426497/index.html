<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª ‚õπÔ∏è üèØ N√∫cleos de CPU o qu√© es SMP y qu√© come ‚úåüèΩ üë©üèø‚Äçüé® üëä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Buen d√≠a, hoy me gustar√≠a tocar un tema bastante simple que es casi desconocido para los programadores comunes, pero que es muy probabl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√∫cleos de CPU o qu√© es SMP y qu√© come</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426497/"><h2>  Introduccion </h2><br>  Buen d√≠a, hoy me gustar√≠a tocar un tema bastante simple que es casi desconocido para los programadores comunes, pero que es muy probable que cada uno de ustedes lo haya usado. <br>  Estamos hablando del multiprocesamiento sim√©trico (popularmente - SMP), la arquitectura que se encuentra en todos los sistemas operativos multitarea y, por supuesto, es una parte integral de ellos.  Todo el mundo sabe que cuantos m√°s n√∫cleos tenga un procesador, m√°s potente ser√° el procesador, s√≠, pero ¬øc√≥mo puede un sistema operativo usar varios n√∫cleos al mismo tiempo?  Algunos programadores no bajan a este nivel de abstracci√≥n, simplemente no lo necesitan, pero creo que todos estar√°n interesados ‚Äã‚Äãen c√≥mo funciona SMP. <br><a name="habracut"></a><br><h2>  Multitarea y su implementaci√≥n </h2><br>  Aquellos que alguna vez han estudiado arquitectura de computadoras saben que el procesador en s√≠ no puede realizar varias tareas a la vez, la multitarea nos da solo el sistema operativo, que cambia estas tareas.  Existen varios tipos de multitarea, pero la m√°s adecuada, conveniente y ampliamente utilizada es desplazar la multitarea (puede leer sus aspectos principales en Wikipedia).  Se basa en el hecho de que cada proceso (tarea) tiene su propia prioridad, lo que afecta la cantidad de tiempo de procesador que se le asignar√°.  Cada tarea tiene un intervalo de tiempo durante el cual el proceso hace algo; una vez que expira el intervalo de tiempo, el sistema operativo transfiere el control a otra tarea.  Surge la pregunta: c√≥mo distribuir los recursos inform√°ticos, como la memoria, los dispositivos, etc.  entre procesos?  Todo es muy simple: Windows lo hace por s√≠ mismo, Linux usa un sistema de sem√°foro.  Pero un n√∫cleo no es serio, seguimos adelante. <br><br><h3>  Interrupciones y PIC </h3><br>  Quiz√°s para algunos esto resulte ser una novedad, para otros no, pero la arquitectura i386 (hablar√© sobre la arquitectura x86, ARM no cuenta, porque no estudi√© esta arquitectura y nunca la encontr√© (incluso al nivel de escribir alg√∫n servicio o programa residente)) usa interrupciones (solo hablaremos de interrupciones de hardware, IRQ) para notificar al SO o al programa sobre un evento.  Por ejemplo, hay una interrupci√≥n 0x8 (para modos protegidos y largos, por ejemplo, 0x20, dependiendo de c√≥mo configurar el PIC, m√°s sobre eso m√°s adelante), que es llamado por PIT, que, por ejemplo, puede generar interrupciones con cualquier frecuencia necesaria.  Luego, el trabajo del sistema operativo para la distribuci√≥n de segmentos de tiempo se reduce a 0, cuando se llama a una interrupci√≥n, el programa se detiene y se le da control, por ejemplo, al n√∫cleo, que a su vez guarda los datos actuales del programa (registros, banderas, etc.) y le da control al siguiente proceso. . <br><br>  Como probablemente haya entendido, las interrupciones son funciones (o procedimientos) que el equipo o el programa en s√≠ llaman en alg√∫n momento.  En total, el procesador admite 16 interrupciones en dos PIC.  El procesador tiene banderas, y una de ellas es la bandera "I" - Control de interrupci√≥n.  Al establecer este indicador en 0, el procesador no causar√° interrupciones de hardware.  Pero tambi√©n quiero se√±alar que existen los llamados NMI (interrupciones no enmascarables): los datos de interrupci√≥n se seguir√°n llamando, incluso si el bit I se establece en 0. Usando la programaci√≥n PIC, puede desactivar los datos de interrupci√≥n, pero despu√©s de regresar de cualquier interrupci√≥n con IRET - nuevamente no ser√°n prohibidos.  Observo que desde un programa regular no puede rastrear la llamada de interrupci√≥n: su programa se detiene y solo se reanuda despu√©s de un tiempo, su programa ni siquiera se da cuenta (s√≠, puede verificar que se llam√≥ a la interrupci√≥n, pero ¬øpor qu√©? <br><br><h5>  PIC - Controlador de interrupci√≥n programable </h5><br>  De Wiki: <br><blockquote>  Como regla general, es un dispositivo electr√≥nico, a veces hecho como parte del propio procesador o chips complejos de su marco, cuyas entradas est√°n conectadas el√©ctricamente a las salidas correspondientes de varios dispositivos.  El n√∫mero de entrada del controlador de interrupci√≥n se denomina "IRQ".  Este n√∫mero debe distinguirse de la prioridad de interrupci√≥n, as√≠ como del n√∫mero de entrada en la tabla de vectores de interrupci√≥n (INT).  Entonces, por ejemplo, en una PC IBM en modo real (MS-DOS se est√° ejecutando en este modo) del procesador, la interrupci√≥n del teclado est√°ndar usa IRQ 1 e INT 9. <br><br>  La plataforma original de PC de IBM utiliza un esquema de interrupci√≥n muy simple.  El controlador de interrupci√≥n es un contador simple que itera secuencialmente sobre las se√±ales de diferentes dispositivos o se reinicia al principio cuando se encuentra una nueva interrupci√≥n.  En el primer caso, los dispositivos tienen la misma prioridad; en el segundo, los dispositivos con un n√∫mero de serie m√°s bajo (o m√°s alto en el recuento) tienen una prioridad m√°s alta. </blockquote><br>  Como comprender√°, este es un circuito electr√≥nico que permite que los dispositivos env√≠en solicitudes de interrupci√≥n, por lo general, hay exactamente 2 de ellos. <br><br>  Ahora, pasemos al tema del art√≠culo. <br><br><h2>  SMP </h2><br>  Para implementar este est√°ndar, se comenzaron a colocar nuevos esquemas en las placas base: APIC y ACPI.  Hablemos del primero. <br><br>  APIC - Controlador de interrupci√≥n programable avanzado, una versi√≥n mejorada de PIC.  Se utiliza en sistemas multiprocesador y es una parte integral de todos los √∫ltimos procesadores Intel (y compatibles).  APIC se utiliza para el reenv√≠o de interrupciones complejas y para enviar interrupciones entre procesadores.  Estas cosas no fueron posibles utilizando la especificaci√≥n PIC anterior. <br><br><h3>  APIC local y IO APIC </h3><br>  En un sistema basado en APIC, cada procesador consta de un "n√∫cleo" y un "APIC local".  El APIC local es responsable de manejar la configuraci√≥n de interrupci√≥n espec√≠fica del procesador.  Entre otras cosas, contiene una tabla de vectores local (LVT), que traduce eventos, como el "reloj interno" y otras fuentes de interrupci√≥n "locales", en un vector de interrupci√≥n (por ejemplo, el contacto LocalINT1 puede generar una excepci√≥n NMI mientras mantiene " 2 "a la entrada LVT correspondiente). <br><br>  Puede encontrar m√°s informaci√≥n sobre el APIC local en la "Gu√≠a de programaci√≥n del sistema" de los procesadores Intel modernos. <br><br>  Adem√°s, hay un APIC IO (por ejemplo, Intel 82093AA), que forma parte del conjunto de chips y proporciona control de interrupciones multiprocesador, incluida la distribuci√≥n sim√©trica est√°tica y din√°mica de interrupciones para todos los procesadores.  En sistemas con m√∫ltiples subsistemas de E / S, cada subsistema puede tener su propio conjunto de interrupciones. <br><br>  Cada pin de interrupci√≥n se programa individualmente como disparo de borde o nivel.  El vector de interrupci√≥n y la informaci√≥n de control de interrupci√≥n se pueden especificar para cada interrupci√≥n.  El esquema de acceso indirecto a registros optimiza el espacio de memoria necesario para acceder a los registros internos de E / S APIC.  Para aumentar la flexibilidad del sistema al asignar espacio de memoria, los dos registros de E / S APIC son reubicables, pero el valor predeterminado es 0xFEC00000. <br><br><h3>  Inicializando un APIC "local" </h3><br>  El APIC local se activa en el momento del arranque y se puede deshabilitar restableciendo el bit 11 IA32_APIC_BASE (MSR) (esto solo funciona con procesadores con una familia&gt; 5, ya que Pentium no tiene dicho MSR), luego el procesador recibe sus interrupciones directamente del PIC 8259 compatible .  Sin embargo, la gu√≠a de desarrollo de software de Intel establece que despu√©s de deshabilitar el APIC local a trav√©s de IA32_APIC_BASE, no podr√° encenderlo hasta que se restablezca por completo.  El APO IO tambi√©n se puede configurar para funcionar en modo heredado para que emule un dispositivo 8259. <br><br>  Los APIC locales se asignan a la p√°gina f√≠sica FEE00xxx (consulte la Tabla 8-1 Intel P4 SPG).  Esta direcci√≥n es la misma para cada APIC local que existe en la configuraci√≥n, lo que significa que puede acceder directamente a los registros del n√∫cleo APIC local en el que se est√° ejecutando actualmente su c√≥digo.  Tenga en cuenta que hay un MSR que define la base APIC real (disponible solo para procesadores con una familia&gt; 5).  MADT contiene una base APIC local, y en sistemas de 64 bits tambi√©n puede contener un campo que especifica una redefinici√≥n de 64 bits de la direcci√≥n base, que debe usar en su lugar.  Puede dejar la base APIC local solo donde la encuentre, o moverla a donde quiera.  Nota: No creo que pueda moverlo m√°s all√° del cuarto GB de RAM. <br><br>  Para permitir que el APIC local reciba interrupciones, debe configurar el Registro de vectores de interrupciones espurias.  El valor correcto para este campo es el n√∫mero IRQ que desea asignar a las falsas interrupciones con los 8 bits inferiores, y el octavo bit establecido en 1 para habilitar APIC (consulte la especificaci√≥n para m√°s detalles).  Debe seleccionar un n√∫mero de interrupci√≥n que tenga los 4 bits inferiores establecidos;  La forma m√°s f√°cil es usar 0xFF.  Esto es importante para algunos procesadores m√°s antiguos, porque para estos valores, los 4 bits inferiores deben establecerse en 1. <br><br>  Deshabilite el 8259 PIC correctamente.  Esto es casi tan importante como configurar APIC.  Lo haces en dos pasos: enmascarar todas las interrupciones y reasignar la IRQ.  Disfrazar todas las interrupciones las desactiva en el PIC.  Reasignar interrupciones es lo que probablemente ya hizo cuando us√≥ PIC: desea que las solicitudes de interrupci√≥n comiencen en 32 en lugar de 0 para evitar conflictos con las excepciones (en los modos de procesador protegido y largo (Largo), porque Las primeras 32 interrupciones son excepciones).  Entonces debe evitar usar estos vectores de interrupci√≥n para otros fines.  Esto es necesario porque, a pesar del hecho de que enmascaraste todas las interrupciones de PIC, a√∫n podr√≠a lanzar falsas interrupciones, que luego se procesar√≠an incorrectamente como excepciones en tu n√∫cleo. <br>  Pasemos a SMP. <br><br><h3>  Multitarea sim√©trica: inicializaci√≥n </h3><br>  La secuencia de inicio es diferente para diferentes CPU.  La Gu√≠a del programador Intel (Secci√≥n 7.5.4) contiene un protocolo de inicializaci√≥n para procesadores Intel Xeon y no cubre procesadores m√°s antiguos.  Para un algoritmo general de "todo tipo de procesador", consulte la Especificaci√≥n de multiprocesador Intel. <br><br>  Para 80486 (con APIC 8249DX externo) debe usar IPIT INIT seguido de IPI "INIT level de-afirmar" sin ning√∫n SIPI.  Esto significa que no puede decirles d√≥nde comenzar a ejecutar su c√≥digo (la parte vectorial de SIPI), y siempre comienzan a ejecutar c√≥digo de BIOS.  En este caso, configura el valor de restablecimiento del BIOS CMOS en "arranque en caliente con salto lejano" (es decir, configura CMOS 0x0F a 10) para que el BIOS realice jmp far ~ [0: 0x0469], y luego establece el segmento y el desplazamiento Puntos de entrada AP en 0x0469. <br><br>  El IPI de "desprestigio de nivel INIT" no es compatible con los nuevos procesadores (Pentium 4 e Intel Xeon), y AFAIK es completamente ignorado en estos procesadores. <br><br>  Para los procesadores m√°s nuevos (P6, Pentium 4) un SIPI es suficiente, pero no estoy seguro de que los procesadores Intel (Pentium) m√°s antiguos o los procesadores de otros fabricantes necesiten un segundo SIPI.  Tambi√©n es posible que exista un segundo SIPI en caso de una falla de entrega para el primer SIPI (ruido del bus, etc.). <br><br>  Por lo general, env√≠o el primer SIPI y luego espero para ver si el AP aumenta la cantidad de procesadores en ejecuci√≥n.  Si no aumenta este contador en unos pocos milisegundos, enviar√© un segundo SIPI.  Esto es diferente del algoritmo general de Intel (que tiene un retraso de 200 microsegundos entre SIPI), pero tratar de encontrar una fuente de tiempo que pueda medir con precisi√≥n el retraso de 200 microsegundos durante un inicio temprano no es tan simple.  Tambi√©n descubr√≠ que en el hardware real, si el retraso entre SIPI es demasiado largo (y no est√° utilizando mi m√©todo), el AP principal puede ejecutar el c√≥digo de inicio de AP temprano para el sistema operativo dos veces (lo que en mi caso har√° que el sistema operativo piense que tenemos el doble de procesadores de lo que realmente somos). <br><br>  Puede transmitir estas se√±ales en el bus para iniciar cada dispositivo presente.  Sin embargo, tambi√©n puede encender los procesadores que estaban especialmente deshabilitados (porque estaban "defectuosos"). <br><br><h3>  Buscando informaci√≥n usando la tabla MT </h3><br>  Parte de la informaci√≥n (que puede no estar disponible en m√°quinas m√°s nuevas) destinada al multiprocesamiento.  Primero necesita encontrar la estructura de puntero flotante MP.  Est√° alineado en un l√≠mite de 16 bytes y contiene una firma al comienzo de "_MP_" o 0x5F504D5F.  El sistema operativo debe buscar en EBDA, el espacio ROM del BIOS y en el √∫ltimo kilobyte de "memoria base";  El tama√±o de la memoria base se especifica en un valor de 2 bytes de 0x413 en kilobytes, menos 1 KB.  As√≠ es como se ve la estructura: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_floating_pointer_structure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> configuration_table; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; <span class="hljs-comment"><span class="hljs-comment">// In 16 bytes (eg 1 = 16 bytes, 2 = 32 bytes) uint8_t mp_specification_revision; uint8_t checksum; // This value should make all bytes in the table equal 0 when added together uint8_t default_configuration; // If this is not zero then configuration_table should be // ignored and a default configuration should be loaded instead uint32_t features; // If bit 7 is then the IMCR is present and PIC mode is being used, otherwise // virtual wire mode is; all other bits are reserved }</span></span></code> </pre> <br>  As√≠ es como se ve la tabla de configuraci√≥n a la que apunta la estructura flotante del puntero: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_configuration_table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "PCMP" uint16_t length; uint8_t mp_specification_revision; uint8_t checksum; // Again, the byte should be all bytes in the table add up to 0 char oem_id[8]; char product_id[12]; uint32_t oem_table; uint16_t oem_table_size; uint16_t entry_count; // This value represents how many entries are following this table uint32_t lapic_address; // This is the memory mapped address of the local APICs uint16_t extended_table_length; uint8_t extended_table_checksum; uint8_t reserved; }</span></span></code> </pre><br>  Despu√©s de la tabla de configuraci√≥n hay entradas entry_count, que contienen m√°s informaci√≥n sobre el sistema, seguido de una tabla extendida.  Las entradas tienen 20 bytes para representar el procesador u 8 bytes para otra cosa.  As√≠ es como se ven el procesador APIC y los registros de E / S. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 0 uint8_t local_apic_id; uint8_t local_apic_version; uint8_t flags; // If bit 0 is clear then the processor must be ignored // If bit 1 is set then the processor is the bootstrap processor uint32_t signature; uint32_t feature_flags; uint64_t reserved; }</span></span></code> </pre><br>  Aqu√≠ est√° la entrada IO APIC. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_io_apic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 2 uint8_t id; uint8_t version; uint8_t flags; // If bit 0 is set then the entry should be ignored uint32_t address; // The memory mapped address of the IO APIC is memory }</span></span></code> </pre><br><h3>  Buscando informaci√≥n con APIC </h3><br>  Puede encontrar la tabla MADT (APIC) en ACPI.  La tabla enumera los APIC locales, cuyo n√∫mero debe corresponder al n√∫mero de n√∫cleos en su procesador.  Los detalles de esta tabla no est√°n aqu√≠, pero puede encontrarlos en Internet. <br><br><h3>  Lanzar AP </h3><br>  Despu√©s de haber recopilado la informaci√≥n, debe deshabilitar el PIC y prepararse para la E / S APIC.  Tambi√©n necesita configurar el BSP del APIC local.  Luego, inicie el AP utilizando SIPI. <br><br>  <b>C√≥digo para lanzar n√∫cleos:</b> <br><br>  Observo que el vector que especifique al inicio indica la direcci√≥n de inicio: vector 0x8 - direcci√≥n 0x8000, vector 0x9 - direcci√≥n 0x9000, etc. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static u32 LocalApicIn(uint reg) { return MmioRead32(*g_localApicAddr + reg); } // ------------------------------------------------------------------------------------------------ static void LocalApicOut(uint reg, u32 data) { MmioWrite32(*g_localApicAddr + reg, data); } // ------------------------------------------------------------------------------------------------ void LocalApicInit() { // Clear task priority to enable all interrupts LocalApicOut(LAPIC_TPR, 0); // Logical Destination Mode LocalApicOut(LAPIC_DFR, 0xffffffff); // Flat mode LocalApicOut(LAPIC_LDR, 0x01000000); // All cpus use logical id 1 // Configure Spurious Interrupt Vector Register LocalApicOut(LAPIC_SVR, 0x100 | 0xff); } // ------------------------------------------------------------------------------------------------ uint LocalApicGetId() { return LocalApicIn(LAPIC_ID) &gt;&gt; 24; } // ------------------------------------------------------------------------------------------------ void LocalApicSendInit(uint apic_id) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, ICR_INIT | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } // ------------------------------------------------------------------------------------------------ void LocalApicSendStartup(uint apic_id, uint vector) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, vector | ICR_STARTUP | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } void SmpInit() { kprintf("Waking up all CPUs\n"); *g_activeCpuCount = 1; uint localId = LocalApicGetId(); // Send Init to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) { LocalApicSendInit(apicId); } } // wait PitWait(200); // Send Startup to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) LocalApicSendStartup(apicId, 0x8); } // Wait for all cpus to be active PitWait(10); while (*g_activeCpuCount != g_acpiCpuCount) { kprintf("Waiting... %d\n", *g_activeCpuCount); PitWait(10); } kprintf("All CPUs activated\n"); }</span></span></code> </pre><br><pre> <code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">org</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>] AP: jmp short bsp ;     -   BSP xor ax,ax mov ss,ax mov sp, <span class="hljs-number"><span class="hljs-number">0</span></span>x7c00 xor ax,ax mov ds,ax ; Mark CPU as active lock inc byte [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>] ;   ,   jmp zop bsp: xor ax,ax mov ds,ax mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov dword[<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-type"><span class="hljs-type">g_activeCpuCount</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span> mov word [<span class="hljs-type"><span class="hljs-type">ds</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x8000</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>x9090 ;  JMP   <span class="hljs-number"><span class="hljs-number">2</span></span> NOP<span class="hljs-string"><span class="hljs-string">' ;   ,  </span></span></code> </pre><br>  Ahora, como comprender√°, para que el sistema operativo use muchos n√∫cleos, debe configurar la pila para cada n√∫cleo, cada n√∫cleo, sus interrupciones, etc., pero lo m√°s importante es que cuando se usa el multiprocesamiento sim√©trico, todos los recursos de los n√∫cleos son los mismos: una memoria, un PCI, etc., y el sistema operativo solo puede paralelizar tareas entre los n√∫cleos. <br><br>  Espero que el art√≠culo no sea lo suficientemente aburrido y bastante informativo.  La pr√≥xima vez, creo, podemos hablar sobre c√≥mo sol√≠an dibujar en la pantalla (y ahora dibujan), sin usar sombreadores y tarjetas de video geniales. <br><br>  Buena suerte </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426497/">https://habr.com/ru/post/es426497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426487/index.html">Prueba de automatizaci√≥n desde cero. Parte 1</a></li>
<li><a href="../es426489/index.html">Sobre la relaci√≥n de n√∫meros primos e irracionales</a></li>
<li><a href="../es426491/index.html">Semana de la seguridad 39: a la muerte de Google+</a></li>
<li><a href="../es426493/index.html">Descuentos constantes de los anfitriones para VPS y VPS. Hoy Buscar visitantes</a></li>
<li><a href="../es426495/index.html">Dise√±ador en solitario. C√≥mo construir una carrera cuando trabajas solo</a></li>
<li><a href="../es426499/index.html">Programa educativo para trabajar con tarjetas perforadas (o la historia de c√≥mo se procesaron los "grandes datos" desde 1890 hasta 1970)</a></li>
<li><a href="../es426501/index.html">Lamoda desde adentro: por qu√© la tienda en l√≠nea de 300 ingenieros</a></li>
<li><a href="../es426503/index.html">Funcionalidad SAP HANA como base de datos para SAP HANA Data Management Suite</a></li>
<li><a href="../es426505/index.html">Eventos digitales en Mosc√∫ del 15 al 21 de octubre.</a></li>
<li><a href="../es426507/index.html">Crear una arquitectura: trabajar con el patr√≥n Coordinador de iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>