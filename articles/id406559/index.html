<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçº üì≠ ‚òÑÔ∏è Pemrograman dan pertukaran data dengan ARDUINO via WIFI via ESP8266 Bagian Satu üßïüèº üöù üë©‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti banyak produk buatan rumah lainnya, saya secara teratur menggunakan mikrokontroler AVR untuk semua jenis kerajinan amatir. Dan berkat konsep A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman dan pertukaran data dengan ARDUINO via WIFI via ESP8266 Bagian Satu</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/406559/">  Seperti banyak produk buatan rumah lainnya, saya secara teratur menggunakan mikrokontroler AVR untuk semua jenis kerajinan amatir.  Dan berkat konsep Arduino, kerajinan tangan ini sekarang memiliki tampilan yang elegan juga.  Memang, untuk sekitar 300-400 rubel, kami mendapatkan papan multi-layer miniatur dengan topeng, layar silks dan dengan periferal untuk mikrokontroler yang benar-benar dibesarkan di atasnya (apalagi, dalam versi SMD!).  Saya tidak berbicara tentang semua jenis plug-in dari seri "Arduino" yang sama: sensor, pengontrol, display dan seluruh rangkaian, periferal tambahan yang sangat kami butuhkan.  Dan lagi, semuanya juga murah dan dalam kinerja yang sangat baik.  Sebenarnya tidak perlu lagi mengembangbiakkan sesuatu dan menyolder pada "lutut". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/dcc/5a0/51d/dcc5a051d0554a7a86eaf37d51702ce6.jpg"></div><br>  Tetapi semua berbagai kerajinan amatir ini, tentu saja memerlukan <b>pemrograman pendahuluan.</b>  Dan kemudian, dengan berbagai perbaikan, saya terus menerus harus merombak kerajinan ini.  Jelas bahwa lebih mudah untuk melakukan ini dari jarak jauh daripada terus-menerus menyeret mereka ke programmer biasa.  Secara umum, berkat platform Arduino yang sama, ada banyak opsi di sini: Bluetooth, ZigBee, saluran radio dengan protokol pribadi Anda, IR, dan bahkan Wi-Fi.  Semuanya memungkinkan Anda membuat kontak nirkabel dengan mikrokontroler Anda.  Tetapi kita akan berhenti pada opsi terakhir.  Ada empat alasan utama: <br><br>  1: modern, Internet hal! <br><br>  2: ada router nirkabel di setiap apartemen, daftarkan perangkat Anda di jaringan rumah dan voila! <br><br>  3: kerajinan Anda membuat lompatan revolusioner dalam perkembangannya;  mereka tidak hanya dapat diprogram dari jarak jauh, mereka sekarang juga dapat berkomunikasi dengan dunia di sekitar mereka: jam elektronik secara mandiri mengambil waktu yang tepat dari jam server NTP, perangkat eksekutif dikendalikan dari ujung kota atau negara, perangkat pendaftaran menyimpan data yang terakumulasi dalam cloud dll.  dll. <br><br>  4: ada serangkaian chip ESP8266 yang luar biasa yang <s>tidak</s> mudah untuk mengimplementasikan semua ini. <br><a name="habracut"></a><br>  Selanjutnya, dalam artikel ini, menggunakan contoh lengan mekanik pada servos, pemrograman jarak jauh dan pertukaran data dengan PC (atau apa pun) dengan perangkat berbasis mikrokontroler AVR akan dibongkar dan diperagakan.  Saya ingin segera mencatat bahwa semua program yang tercantum di sini adalah murni demonstrasi dan tidak memiliki nilai komersial.  Oleh karena itu, klaim, seperti mengapa programmer begitu dikebiri dan fungsionalnya buruk atau mengapa tidak ada layanan tambahan di mana-mana, tidak diterima.  Karena kode terbuka, siapa pun dapat menyelesaikannya atas kebijakan mereka sendiri, tetapi saya masih memiliki cukup untuk bekerja. <br><br>  Diasumsikan bahwa pembaca sudah terbiasa dengan kedua modul Arduino (perisai) dan koneksi dan firmware dari ESP8266.  Bahkan, sejumlah besar materi telah diposting di Web menjelaskan dasar-dasar bekerja dengan perangkat ini dan saya tidak ingin mengulanginya di sini.  Untuk pemula, di akhir artikel ada daftar tautan bermanfaat tentang masalah ini, di mana Anda dapat menemukan banyak informasi <s>, mengapa semuanya tidak bekerja untuk Anda</s> .  Dari pengalaman saya sebagai mantan insinyur elektronik, saya secara bertanggung jawab dapat menyatakan bahwa 99% masalah adalah sebagai berikut: <br><br>  1. Kontak yang buruk.  Karena "Arduino" perisai menyiratkan beralih satu sama lain melalui kabel dari jenis "ayah-ibu", dan bukan melalui penyolderan, sangat sering sesuatu, di suatu tempat, hilang.  Lihat itu.  Dan memang, seperti kata mereka, elektronik adalah ilmu kontak. <br><br>  2. Masalah daya.  Jangan memasok daya 5 volt di tempat 3.3 diperlukan.  Terkadang asap berasal dari ESP8266.  Meskipun, di sisi lain, itu mencerna sinyal logis dari perangkat lima volt tanpa masalah. <br><br>  3. Masalah dengan daya yang cukup.  ESP8266 memiliki sifat keji dan kadang-kadang dapat mengkonsumsi hampir tiga ratus milliamps, meskipun sebelum itu dapat dipenuhi dengan tiga puluh.  Dengan demikian, papan 3.3 volt lemah stabilizer "Arduino", yang Anda dapat menambahkan hingga tidak ada, itu terhubung, segera tenggelam ke nilai-nilai mikroskopis.  Dan Anda tidak bisa mengerti mengapa itu bekerja, maka tidak. <br><br>  4. Kebingungan dengan kesimpulan.  Selalu periksa sinyal mana yang pergi ke mana.  Penerima RXD harus terhubung ke pemancar TXD, serta TXD ke RXD, tetapi MOSI harus terhubung ke MOSI, dan MISO ke MISO, dan seterusnya. <br><br>  5. Jangan mengandalkan resistor pull-up dalam sirkuit di ESP8266, selalu tarik kabel ke nol atau daya, melalui resistor eksternal 5-10 kilo-ohm, dan bukan hanya pelompat.  Kalau tidak, Anda bisa, paling-paling, mendapatkan konsumsi saat ini yang belum pernah terjadi sebelumnya, dan kemudian mencium bau tidak enak dari plastik yang terbakar. <br><br>  6. Shoals perangkat lunak.  Karena perangkat lunak untuk pengguna individu ditulis oleh penggemar yang sama, gangguan dari firmware itu sendiri dan bug muncul secara berkala ketika memperbarui versi dari firmware yang sama.  Itu diperlakukan dengan merangkak di forum yang relevan, kadang-kadang bahkan dalam bahasa Inggris.  Beberapa kawan bahkan mengklaim bahwa chip ESP itu sendiri lembab seperti cuaca di St. Petersburg, tetapi di sisi lain ada juga pendapat bahwa sejak 2014 (tahun pertama kali dirilis), situasi dengan ini telah meningkat secara dramatis (tidak seperti cuaca). <br><br>  7. Gangguan misterius.  Ini adalah fenomena yang jarang terjadi, namun menguras tenaga.  Misalnya, saya tidak punya perangkat "Arduino" jarak jauh.  Sebaliknya, itu terjadi tetapi dengan kesalahan.  Tapi itu berjalan tanpa kesalahan jika kabel dari programmer tergantung padanya (tetapi tanpa programmer itu sendiri).  "AHA," kataku pada diri sendiri, dan menyolder kapasitor 15 pF antara pin transfer data dan pin sinkronisasi.  Semuanya berhasil.  Tapi hari itu terbunuh. <br><br>  Jadi, mari kita mulai dengan yang paling sederhana.  Kami memiliki mekanis ekstremitas MechArm (tapi bukan apa yang dirakit Howard Volovits) di Cina dan komputer pribadi dengan Windows.  Tugasnya adalah mem-flash program secara jarak jauh dan mengelolanya dari komputer. <br><img src="https://habrastorage.org/web/296/4e6/530/2964e653055742f1a6641f06f2d767b1.jpg"><br>  Untuk pengontrol kontrol, kami mengambil syal Arduino Nano miniatur yang lucu dengan batu ATmega328P.  Papan ini dengan sempurna didorong ke lengan mekanik. <br><img src="https://habrastorage.org/web/45f/320/2e5/45f3202e545d485faa6d1b5fb71bc574.jpg"><br>  Sekarang kami memutuskan bagaimana kami akan memprogramnya.  Ada tiga metode utama yang paling cocok untuk firmware jarak jauh: melalui antarmuka SPI, melalui bootloader bawaan, melalui port JTAG. <br><br>  Opsi termudah tentu saja adalah bootloader bawaan (bootloader).  Ini adalah memori pra-terdaftar di FLASH, sebuah program yang menerima kode sesuai dengan protokol tertentu (misalnya, menggunakan UART paling sederhana) dan menulisnya ke lokasi program yang dimuat dengan perintah khusus.  Ini berfungsi, misalnya, bootloader ARDUINO IDE.  Setelah reset atau mulai, bootloader menunggu beberapa saat untuk menerima data dan jika tidak menunggu, ia memulai eksekusi program dari alamat nol.  Jika datanya tiba, dia menulisnya di bagian program.  Setelah reset berikutnya, program yang diunduh mulai berjalan.  Secara detail, mungkin saya jelaskan secara tidak akurat, tetapi intinya hanya itu.  Akibatnya, kita hanya membutuhkan tiga output untuk pemrograman: penerima RTD, reset RESET, dan GND ground.  Secara umum, pemancar TRD juga digunakan untuk memverifikasi program yang direkam, tetapi untuk aplikasi demonstrasi sederhana (bukan untuk pembangkit listrik tenaga nuklir), verifikasi dapat dihilangkan. <br><br>  Loader itu sendiri ditulis dalam bahasa assembly, ada contoh loader sederhana di lembar data pada AVR.  Anda dapat menggali bootloader yang ada jika berada di domain publik dan cukup menggunakannya dalam bentuk siap pakai jika protokol yang digunakan diketahui.  Satu-satunya peringatan adalah bahwa Anda perlu mengkonfigurasi AVR dalam mode khusus dengan mem-flash bit sekering khusus, yang dilakukan oleh programmer normal, dan kemudian Anda juga dapat menjahit bootloader ke dalam memori mikrokontroler (yaitu, Anda tidak dapat melakukannya tanpa programmer sekali). <br><br>  Opsi kedua adalah pemrograman melalui antarmuka SPI serial.  Tidak ada bootloader internal di sini, tetapi kami memprogram dengan mengirimkan perintah khusus dan kemudian data melalui antarmuka yang disebutkan di atas.  Di sini kita memiliki bootloader eksternal, tetapi Anda masih perlu menulisnya.  Selain RESET dan GND, empat output MOSI tambahan digunakan untuk transmisi, MISO - data, sinkronisasi SLK, pemilihan chip CS.  Namun secara umum, Anda juga dapat menghapus MISO dan CS.  Data hanya akan diterima (maka tidak akan ada verifikasi program), dan kami hanya memiliki satu kristal. <br><br>  Setiap pendekatan memiliki pro dan kontra (dan saya tidak mempertimbangkan JTAG sama sekali, karena kehidupan manusia pendek).  Tetapi pada akhirnya, saya condong ke SPI karena saya terlalu malas untuk menulis di assembler, tetapi saya tidak menemukan bootloader siap pakai terbuka (saya hanya tidak terlihat baik-baik saja). <br><br>  Untuk membangun saluran nirkabel, saya, seperti yang telah disebutkan, memilih chip ESP8266 yang saat ini dikenal luas - mikrokontroler, atau lebih tepatnya, seluruh SoC (System-on-Chip) dari pabrikan Espressif Cina dengan antarmuka Wi-Fi.  Selain Wi-Fi, itu dibedakan oleh kemampuan untuk menjalankan program dari memori flash eksternal.  Dan khusus untuk proyek saya, saya mengambil ESP8266-07 dengan memori 512 KB. <br><br><img src="https://habrastorage.org/web/e50/03b/ab1/e5003bab173c4deca207971fd82261f0.jpg"><br>  Secara umum, ESP8266 apa pun cocok di mana ada kaki tambahan untuk menerapkan SPI.  Oleh karena itu, ESP8266-01 yang paling sederhana tidak cocok untuk kita, karena ESP8266 sangat sedikit untuk port input / output.  Tetapi di sisi lain, perbedaan harga kurang dari seratus rubel, dan mereka tersedia sama.  Nah, papan debug besar dengan ESP, di mana banyak periferal untuk kenyamanan, juga tidak cocok untuk kita, karena mereka tidak masuk ke tempat kita ingin mendorong mereka ke lengan mekanik kita. <br><br>  Esensi global dari gagasan itu secara umum adalah sebagai berikut.  Tubuh program yang dimuat ke dalam mikrokontroler ditransfer dari komputer ke ESP secara nirkabel melalui WI-FI (dalam jaringan rumah Anda).  Dan ESP sudah menggunakan kabel menggunakan antarmuka SPI menulis program ini langsung ke memori FLASH mikrokontroler.  Kemudian secara alami me-reset dan memungkinkan program yang dimuat untuk dieksekusi.  Selain itu, ESP harus memiliki unit independen, yang juga mengelola pertukaran data dengan mikrokontroler, karena kami ingin tidak hanya program, tetapi juga bertukar data dengan itu.  Khususnya, untuk proyek dengan MechArm, setelah merekam program, kami masih mengirimkan sinyal kontrol servo untuk mengatur gerakan ini.  Oleh karena itu, pada ESP itu sendiri, disarankan bagi kita untuk meningkatkan server TCP untuk transfer program dan server UDP untuk mengendalikan MechArm.  Karenanya, server ini bergabung dengan jaringan rumah dan mendengarkan dengan cermat apakah ada orang yang ingin mengunggah kode baru ke MechaArm atau melambaikannya kepada seseorang. <br><br>  Jadi, saya temukan di Web bahwa firmware sudah memungkinkan Anda untuk memprogram AVR melalui udara, tetapi ada masalah utama adalah untuk apa lagi firmware ini tidak lagi dapat digunakan.  Setelah pemrograman, kami ingin berkomunikasi dengan AVR juga dari jarak jauh. <br><br>  Perangkat lunak apa yang akan kita gunakan: <br><br>  Untuk PC, saya menulis semuanya di JAVA, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IntelliJ IDEA</a> .  Tetapi pada dasarnya, Anda dapat melakukan apa saja, hal utama bagi kami adalah menulis klien yang akan mengirim program untuk menginstal AVR ke ESP8266. <br><br>  Saya sendiri menulis program untuk AVR di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ATMEL STUDIO</a> , dalam bahasa C, jarang dalam assembler.  Saya tidak menggunakan sketsa Arduino pada prinsipnya, hampir semua perpustakaan yang diperlukan ditulis dalam satu atau dua jam, dengan pemahaman penuh tentang pekerjaannya.  Saya sudah mencoba sketsa, tetapi selama Anda tidak memiliki sistem operasi pada AVR, sketsa akan mengambil periferal dari teman dan secara teratur gagal.  Ya, IDE Arduino sendiri, dibandingkan dengan ATMEL STUDIO, tentu saja merupakan hal yang sangat primitif.  Tapi di sini pertanyaannya, tentu saja, kontroversial, untuk humaniora dan anak sekolah akan lebih menyenangkan dan lebih mudah, mungkin, dengan sketsa. <br><br>  Untuk pemrograman ESP8266, saya menggunakan firmware NodeMCU, dan saya menulis program di Lua.  Tidak, saya ingin sekali menulis dalam Java dan C, tetapi tidak ada dalam ESP.  Bahasa Lu sebagaimana diterapkan pada tugas kita tidak sulit, untuk menguasai beberapa hal sepele.  Dan sebenarnya, untuk mengunduh program dan men-debug-nya di ESP, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IDE ESPlorer</a> .  Produk domestik gratis (tetapi Anda dapat menyumbangkannya kepada penulis), yang tentu saja tidak dapat dibandingkan dengan lingkungan yang disebutkan di atas, tetapi seperti kata kuda hadiah ... Tetapi untuk menggunakan ESPlorer dan menulis di LUA, pertama-tama kita perlu mengganti firmware dasar (dipasok dari pabrikan) dalam chip ESP8266 ke yang baru.  Program NODE MCU PyFlasher akan membantu kami dalam usaha ini.  Maksud saya, itu akan membantu untuk merombaknya.  Dan kami akan membuat sendiri firmware dan mendapatkannya di tangan situs pembuat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NodeMCU</a> . Dan Anda dapat membaca lebih lanjut tentang proses ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini:</a> <br><br>  Semuanya sangat mudah diakses dan dimengerti.  Kami menambahkan dukungan SPI dan operasi bit ke pustaka dasar (dalam LUA, dalam kasus kami, operasi bit kelebihan beban dan tidak berguna dari mereka).  Banyak perpustakaan tidak boleh dimasukkan ke dalam firmware perpustakaan, karena karena adanya berbagai perangkat lunak pada ESP8266, hanya ada sedikit memori yang tersisa, beberapa jenis 20 kB yang menyedihkan. <br><br>  Tentu saja, Anda bisa mengambil firmware yang sudah jadi, yang banyak di antaranya sudah nongkrong di Internet, tapi saya tidak merekomendasikannya.  Setidaknya karena beberapa dari mereka tidak memiliki dukungan untuk operasi bit (dan kami membutuhkannya) dan tidak ada peraturan laju transfer data melalui SPI. <br>  Dengan demikian, mereka ditransmisikan secara default pada kecepatan 40 MHz dibagi dengan beberapa koefisien kecil dan karena itu AVR tidak punya waktu untuk mencernanya. <br><br>  Siapa yang terlalu malas untuk membuat firmware, Anda dapat mengunduh milik saya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud</a> . <br><br>  Sekarang kita memiliki firmware dan kita perlu memuatnya ke dalam ESP8266, bukan basis.  Untuk melakukan ini, kita memerlukan adaptor USB sederhana - UART. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/48a/a27/8c7/48aa278c709446c38f3c89dd7b063bb6.jpg"></div><br>  Kami menghubungkan kaki-kaki TXD ke RXD, dan RXD ke TXD, kami membuat landasan bersama, tetapi sepertinya tidak menggunakan output daya 3,3 V yang nyaman pada adaptor.  Dalam kebanyakan kasus, ESP8266 akan mengeringkannya sepenuhnya.  Karena itu, kami memberinya makan secara terpisah.  Kemudian kita menempatkan ESP ke mode pemrograman (GP0 ke tanah, kalau ada yang lupa) dan menjalankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pyodeslas NODE MCU</a> . <br><br><img src="https://habrastorage.org/web/437/bd0/676/437bd067628f4a9db96466bb8d0d793b.png"><br><br>  Yang penting, jangan lupa untuk menghapus memori flash (ya, menghapus semua data), jika tidak, tergantung pada versi firmware, setelah pemrograman, sampah yang tidak perlu mungkin tetap ada dalam memori, yang pada gilirannya akan membuang sampah ke konsol selama pekerjaan lebih lanjut.  Sebelum itu, saya menggunakan perangkat lunak, di mana tidak ada pilihan untuk menghapus memori sebelumnya, saya sangat tersiksa, karena tidak ada yang berhasil.  Dan peti mati baru saja dibuka, hanya kebenaran di forum bahasa Inggris dari pencipta NODE MCU. <br><br>  Setelah memperoleh firmware yang diperlukan, kami sekarang dapat menulis dan men-debug program LUA (ada juga MicroPython, tetapi saya tidak menggunakannya) menggunakan API yang sangat nyaman dari NODE MCU.  Kami meluncurkan ESPlorer yang telah disebutkan. <br><br><img src="https://habrastorage.org/web/8c0/a47/d1f/8c0a47d1fbfa41c8a1413852852a1513.png"><br><br>  Kami juga mengkonfigurasinya untuk bekerja dengan ESP8266, mengatur parameter koneksi serial.  Semuanya cukup sederhana dan berulang kali dinyatakan di Internet. <br><br>  Sekarang kami menulis program di LUA, yang kemudian kami unggah ke ESP8266: <br><br><div class="spoiler">  <b class="spoiler_title">Lua bootloader untuk AVR ditulis ke ESP8266</b> <div class="spoiler_text"><pre><code class="lua hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming"&lt;/b&gt; p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then print("connection established") p=33 if(p==31) then print("no connection") end end end end &lt;b&gt;function ProgrammingDisable ()&lt;/b&gt; pin=2--END OF ESET FOR MK gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) pin=5--CLK MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI gpio.mode(pin, gpio.INPUT) end &lt;b&gt;function ProgrammingEnable ()&lt;/b&gt; pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end &lt;b&gt;function InstrFlashErase() &lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) print( "FLASH is erased") InstrProgrammingEnable () end &lt;b&gt;function InstrStorePAGE(H, address, data)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end &lt;b&gt;function InstrWriteFLASH(page_address_low,page_address_high)&lt;/b&gt; pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end &lt;b&gt;function Programming (payload)&lt;/b&gt; pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end &lt;b&gt;--MAIN BLOCK&lt;/b&gt; wifi.setmode(wifi.STATION) --wifi.sta.config(" ","") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid=" " tmr.delay(30000) station_cfg.pwd="" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) print(wifi.sta.status()) print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end sv=net.createServer(net.TCP,30) tmr.delay(100) print("SERVER READY") sv:listen(4000,function(c) c:on("receive", function(c, payload) print(payload) if (payload =="program\r\n") then c:send("ready\r\n") print("ready for program\r\n") spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,320,spi.FULLDUPLEX) ProgrammingEnable () tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--    st=net.createServer(net.TCP,30) st:listen(4001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then c:send("ready\r\n") print("ready for data\r\n") srv=net.createServer(net.UDP) tmr.delay(1000) pin=10 gpio.write(pin, gpio.HIGH) uart.setup(0,9600,8,0,1,0) srv:listen(5000) srv:on("receive", function(srv, pl) pl=pl*1 --print(pl) uart.write(0,pl) tmr.wdclr() end) end if (payload =="stop\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () print("stop program") end if(srv~=nil) then srv:close() print("stop data") end end end) end) end)</span></span></code> </pre> <br><br></div></div><br>  Di mana fungsi yang relevan melakukan tindakan berikut: <br><br>  <b>function InstrProgrammingEnable ()</b> - menempatkan mikrokontroler dalam mode pemrograman dengan perintah khusus yang dikirim melalui SPI. <br><br>  <b>function ProgrammingEnable ()</b> - cukup reset AVR selama 25 ms sebelum memulai pemrograman <br><br>  <b>function ProgrammingDisable ()</b> - setelah akhir pemrograman, kami menerjemahkan output SPI di ESP8266 ke keadaan tidak aktif sehingga mereka tidak mengganggu kami ketika mengeksekusi kode pada mikrokontroler (tiba-tiba mereka digunakan di sana) <br><br>  <b>function InstrFlashErase ()</b> - kami menghapus memori flash pada mikrokontroler sebelum pemrograman.  Mengapa ini perlu dijelaskan tidak perlu. <br><br>  <b>function InstrStorePAGE (H, address, data)</b> - perintah ini menulis byte program ke buffer internal mikrokontroler.  Tetapi ini bukan catatan flash itu sendiri, karena flash ditulis di sini halaman demi halaman pada 128 byte. <br><br>  <b>function InstrWriteFLASH (page_address_low, page_address_high)</b> - tetapi ini adalah catatan kilat dan itu membutuhkan waktu, perhatikan waktu tunda 5.000 Œºs. <br><br>  <b>function Programming (payload)</b> - fungsi terbesar dan paling penting menggunakan fungsi-fungsi di atas.  Dibutuhkan program yang ditransmisikan dalam potongan 1024 byte, membaginya menjadi byte dan membentuk alamat untuk mereka, kemudian mengirimkannya ke mikrokontroler di buffer internal dan menginisialisasi catatan flash setiap 128 byte.  Lalu ia mengambil kode kilobyte berikutnya dan mengulangi operasi, secara alami dengan offset di alamat, sehingga untuk menulis lebih jauh dan tidak menimpa yang direkam.  Pada awalnya, saya mencoba meneruskan seluruh program, tetapi ketika saya melebihi 6 kilobyte di ESP8266, memori yang tersedia berakhir dan macet.  Satu kilobyte ternyata menjadi unit yang paling nyaman, karena itu dibagi dengan rapi menjadi beberapa bagian dan mudah ditransmisikan melalui TCP (kita masih perlu mendapatkannya dari komputer).  Ukuran yang lebih besar juga tidak diperlukan, TCP, Anda tahu, dalam versi saat ini membatasi paket yang ditransmisikan ke 1500 atau byte (tetapi untuk beberapa alasan 1440 ditransmisikan kepada saya, semacam). <br><br>  Seolah tidak ada yang rumit, tetapi beberapa jebakan harus diatasi. <br><br>  Berikutnya adalah MAIN BLOCK.  Di dalamnya kita: <br><br>  Kami terdaftar di jaringan nirkabel. <br><br>  Pertama kita membuat server TCP yang mendengarkan tiga perintah: <br><br>  1. "program" (kami akan memprogram) <br><br>  2. "data" (kami akan mengubah data), <br><br>  3. "berhenti" (kami menghentikan semuanya). <br><br>  Jika kami memprogram, pertama-tama kami menginisialisasi SPI dan membuat server TCP lain yang mengambil data (kode firmware) per kilobyte dan memanggil fungsi pemrograman mikrokontroler untuknya.  Saya mengerti bahwa kelihatannya konyol untuk membuat server kedua, tetapi ini adalah keharusan, karena API lokal mendukung pembuatan hanya satu soket, dan kita perlu memisahkan perintah "program" dan "data" dengan data yang dikirimkan, karena menurut pandangan mereka tidak berbeda, ada byte dan ini adalah byte. <br><br>  Jika kita tidak ingin memprogram, tetapi untuk bertukar data, mengirimkannya dalam kasing kita ke mikrokontroler, maka kita pertama-tama mengirim string ‚Äúdata‚Äù melalui TCP.  Menanggapi hal ini, server UDP akan dibuat (saya ingatkan Anda bahwa kami tidak mengelola secara dinamis dengan tangan mekanis dan bahwa kami tidak perlu menunda dengan pembentukan paket TCP, dan memang mengirim satu byte sebagai keseluruhan frame TCP ke atas meja).  Dan datagram UDP akan kecil dan akan terbentuk dengan cepat. <br><br>  Setelah UART diinisialisasi, dan setiap byte yang diterima secara nirkabel sudah dikirim melalui kabel TXD ke mikrokontroler, yang wajib menerimanya jika program terkait diperbarui di sana.  Pertukaran data ke arah lain juga tidak sulit untuk diatur, tetapi saya belum mengimplementasikannya. <br><br>  Nah, dengan perintah "stop", server yang disebutkan di atas (kecuali yang pertama) menutup koneksi dan server utama kembali masuk ke keadaan siaga dari perintah "program" dan "data". <br><br>  Karena antarmuka SPI ditiru secara pemrograman dalam ESP8266, port I / O untuk sinyal CS, CLK, MISO, MOSI, RESET (untuk AVR), Anda dapat menggunakan yang tersedia, dan bukan yang ditunjukkan dalam bootloader saya.  Selain itu, ternyata CS dan MISO, pada prinsipnya, juga dapat terganggu dalam hal ini, itu akan berfungsi tanpa mereka.  Nah, satu pin digunakan pada LED yang terpasang pada papan ESP8266 sehingga terkadang berkedip dan menunjukkan bahwa program tersebut masih hidup. <br><br>  Pemeriksaan untuk kesalahan perekaman tidak dilakukan (dengan pengecualian permintaan pertama ke AVR, tetapi informasi ini hanya ditampilkan pada konsol), EEPROM tidak diprogram, lebih dari 32 KB tidak dijahit - singkatnya, masih ada pekerjaan yang harus dilakukan.  Kecepatan pertukaran SPI sekitar 115 Kbit, dalam beberapa detik semuanya terlintas, kira-kira, seperti dengan programmer serial biasa seperti ISP500). <br><br>  Ambil kodenya, masukkan jaringan dan kata sandi Anda, kompilasi pada ESplorer, sebut "init" (sehingga dimulai saat restart) dan kirimkan ke ESP8266.  Itu harus bekerja.  Dalam artian bekerja sebagai programmer nirkabel, setidaknya. <br><br>  Sekarang kita akan berurusan dengan pihak pengelola - komputer pribadi. <br><br>  Bahkan, kita perlu mengambil file HEX ke mana program Anda ditulis dalam lingkungan ATMEL STUDIO berubah dan mengirimkannya melalui WI-FI ke port soket yang kita tahu (dalam hal ini 4000).  Tangkapan kecilnya adalah bahwa kita memerlukan file BIN biner untuk transfer, dan ATMEL STUDIO menyenangkan kita hanya dengan HEX.  Ada dua jalan keluar;  atau mengubahnya menjadi format BIN dengan konverter program khusus, seperti WinHex, atau lakukan sendiri di program Anda.  Saya belum melakukannya, tetapi tampaknya tidak sulit, di sana Anda perlu memotong judul dan melakukan sesuatu yang lain. <br><br>  Akibatnya, saya menulis program bootloader di JAVA (terutama karena saya tidak tahu bagaimana melakukan hal lain), bekerja di lingkungan IntelliJ IDEA yang sangat indah dan gratis.  Ini menciptakan klien TCP yang mencari server yang berjalan pada ESP8266.  Jika ditemukan, maka kontaknya dan mengiriminya file yang terletak di alamat tersebut.  Kode di bawah. <br><br><div class="spoiler">  <b class="spoiler_title">Pengunduh file JAVA berbasis PC</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Net</span></span></span><span class="hljs-class"> </span></span>{ &lt;b&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Http_client(<span class="hljs-number"><span class="hljs-number">4000</span></span>); }&lt;/b&gt; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Http_client</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port; String s; String Greetings_from_S; Http_client(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.port = port; start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//192.168.1.113 -  ESP8266   .  ,      //    ,    try (Socket socket = new Socket("192.168.1.113", port)) { PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()),true); pw.println("program");// Greetings with SERVER System.out.println("program"); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); Greetings_from_S = br.readLine(); System.out.println(Greetings_from_S); if(Greetings_from_S.equals("ready")) { try { File file = new File("d:BlinkOUT.bin");//    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); byte [] data = new byte[bis.available()]; bis.read(data); byte [] data_buffer = new byte[1024]; int frames = data.length/1024; System.out.println(frames); int residy = data.length%1024; for (int i = 0; i &lt; frames;i++) { for (int k = 0; k&lt; (1024); k++) { data_buffer[k] = data[k+1024*(i)]; } sendingChunk(data_buffer); } byte [] data_buffer2= new byte[residy]; for (int i = 0; i &lt; residy;i++) { data_buffer2[i] = data[i+1024*(frames)]; } sendingChunk(data_buffer2); pw.println("stop");// System.out.println("stop program"); } catch (Exception e) { System.out.println(e); } } } catch (Exception e) { System.out.println(e); } } public void sendingChunk (byte [] data_buffer){ try (Socket socket = new Socket("192.168.1.113", 4001)){ BufferedOutputStream bos = new BufferedOutputStream((socket.getOutputStream())); bos.write(data_buffer); bos.flush(); System.out.println(data_buffer.length); } catch (Exception e) { System.out.println(e); } } }</span></span></code> </pre><br><br></div></div><br>  Di sini, tentu saja, terlalu banyak luka, semua jenis siap, pada prinsipnya, tidak diperlukan.  Jika koneksi TCP terjalin, maka terjalin.  Satu-satunya masalah adalah bahwa file tidak ingin dikirim dalam potongan 1024 byte dengan cara apa pun, seperti yang saya benar-benar butuhkan, meskipun saya secara eksplisit menunjukkan ukurannya.  Rupanya ada beberapa jenis buffer akhir yang tidak dapat diakses dari JAVA, dan mengirimkan paket ukuran yang dia inginkan, yang sama sekali tidak dapat diterima oleh pihak penerima.  Pada awalnya saya mencoba menunda sehingga penyangga akan bosan menunggu kepingan berikutnya dan mengirimkannya apa adanya.  Tetapi penundaan mulai bekerja ketika mencapai 10 detik, yang entah bagaimana sepertinya terlalu banyak untuk satu kilobyte yang ditransfer. <br><br>  Tetapi kemudian saya perhatikan bahwa karena suatu alasan bagian pertama selalu berjalan mulus, mana yang dipesan, dan sudah sejak detik dimulai bacchanalia yang tidak dapat diprediksi.  Oleh karena itu, saya membuat klien membuka koneksi, mengirim sebagian kode dalam 1024 byte dan menutup koneksi.  Demikian seterusnya hingga seluruh file terkirim.  Semuanya bekerja dengan baik. <br><br>  Satu-satunya hal untuk memulai adalah menginstal runtime JAVA di komputer.  Tapi saya biasanya memulai segera dari IntelliJ IDEA karena di sana Anda selalu dapat melihat apa yang terjadi di konsol (tetapi di sini Anda memerlukan lingkungan JAVA).  Meskipun, tentu saja, dengan cara yang cerdas Anda perlu membuat GUI.  Yaitu, jendela tempat path ke file jatuh, kemampuan untuk mengubah nomor port di jendela dan, yah, hal-hal lain yang diperlukan.  Dan untuk mengumpulkan semua ini dalam bentuk file yang dapat dieksekusi. <br><br>  Dan tapericha, seperti yang biasa dikatakan Koroviev, mari kita kembali ke warga, pada kenyataannya, ke mekanik MechArm, yang disebutkan di awal.  Kami sekarang memiliki kesempatan untuk memprogram dari jarak jauh, dan kemudian mengelolanya.  Mari kita beralih ke program kontrol di samping mikrokontroler. <br><br>  Dalam hal ini, kita perlu mengendalikan empat servos.  Ini mereka. <br><div style="text-align:center;"><img src="https://habrastorage.org/web/d29/b6c/8ee/d29b6c8ee960405b9070649d8dc0b2a2.jpg"></div><br>  Drive tersebut dikendalikan oleh pulsa persegi panjang periode 20 ms (50 Hz) dengan faktor tugas 2 hingga 4 persen.  Yaitu, 2% adalah giliran lengkap di satu arah, 4% di yang lain.  Tugas ini hanya untuk PWM terintegrasi dalam AVR. <br><br><img src="https://habrastorage.org/web/9a8/385/2f6/9a83852f6093435abf70b5a8f8d5f29c.png"><br><br>  Satu servo drive digunakan untuk bergerak ke kiri dan ke kanan;  yang kedua pada diri sendiri - dari diri sendiri;  ketiga atas dan ke bawah;  yang keempat adalah cakar itu sendiri, yang harus dikompresi dan diperluas.  Semuanya ditulis dalam C dan dikompilasi ke file HEX di ATMEL STUDIO.  Jenis program yang agak aneh adalah karena pada awalnya tangan dikendalikan dari keyboard yang diikat dengan kabel ke mikrokontroler.  Tapi kabel kemarin, kita harus berevolusi lebih lanjut. <br><br>  Anda tentu saja dapat menggunakan sketsa untuk servos dari "ARDUINO", tetapi saya tidak menyukainya.  Lebih menarik untuk menulis sendiri.  Selain itu, keempat servo harus bekerja secara bersamaan, dan tidak dalam mode multiplex, ketika PWM beralih ke setiap servo secara bergantian.  Karena tidak ada yang membatalkan gravitasi, dan anggota tubuh yang terangkat akan segera turun jika kendali impuls berhenti tiba di servo drive yang sesuai.  Saya tidak yakin bahwa sketsa ‚ÄúARDUINO‚Äù menyediakan operasi simultan untuk empat servos.  Tapi kami sendiri bisa menulis program yang memenuhi persyaratan yang diperlukan.  Secara umum, dengan tidak adanya sistem operasi yang memisahkan domba dari kambing, penggunaan sketsa yang bersaing untuk perangkat periferal mikrokontroler (dan kami bahkan tidak tahu yang mana di muka) terlalu buggy. <br><br>  Berikut adalah kode itu sendiri yang kami tulis ke Arduino Nano menggunakan ESP8266-07. <br><br><div class="spoiler">  <b class="spoiler_title">Program untuk mengendalikan MechArm untuk mikrokontroler AVRmega328P</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 16000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;stdint.h&gt;//    #include &lt;avr/interrupt.h&gt; #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; //  #define UART_BAUD_RATE 115200 //  1    20 #define COUNTER1_OFF TCCR1B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER1_ON TCCR1B=0b00000011 //  0       0  1 #define COUNTER0_OFF TCCR0B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER0_ON TCCR0B=0b00000100 //  2       B2(PD6)  3(PD7) #define COUNTER2_OFF TCCR2B=0b00000000 // CS02 CS01 CS00 - 000 - ; 001  ; 010 c  8; 011 -64; 100 -256; 101 -1024 #define COUNTER2_ON TCCR2B=0b00000110 volatile uint16_t period_20ms; volatile uint8_t State_of_keyboard; volatile uint8_t start_position [6]; volatile int8_t number_servo; ISR(USART_RX_vect)//   UART { State_of_keyboard=UDR0; return; } ISR(TIMER0_COMPA_vect)//  0    { PORTB &amp;=~(1&lt;&lt;0); TIMSK0&amp;=~(1&lt;&lt;OCIE0A); TIFR0 |=(1&lt;&lt;OCF0A); return; } ISR(TIMER0_COMPB_vect) //  1    { PORTB &amp;=~(1&lt;&lt;1); TIFR0 |=(1&lt;&lt;OCF0B); TIMSK0 &amp;=~(1&lt;&lt;OCIE0B); return; } ISR(TIMER2_COMPA_vect)//  2(PD6)    { PORTD &amp;=~(1&lt;&lt;6); TIFR2 |=(1&lt;&lt;OCF2A); TIMSK2 &amp;=~(1&lt;&lt;OCIE2A); return; } ISR(TIMER2_COMPB_vect)//  3(PD7)    { PORTD &amp;=~(1&lt;&lt;7); TIFR2 |=(1&lt;&lt;OCF2B); TIMSK2 &amp;=~(1&lt;&lt;OCIE2B); return; } ISR(TIMER1_OVF_vect){//   20      COUNTER1_OFF; COUNTER0_OFF; COUNTER2_OFF; TIFR0 |=(1&lt;&lt;OCF0A); TIFR0 |=(1&lt;&lt;OCF0B); TIFR2 |=(1&lt;&lt;OCF2A); TIFR2 |=(1&lt;&lt;OCF2B); TIFR1 |=(1&lt;&lt;TOV1); PORTB |=(1&lt;&lt;0)|(1&lt;&lt;1); PORTD |=(1&lt;&lt;6)|(1&lt;&lt;7); TCNT1 = period_20ms; //  20  TCNT0 = 0; TCNT2 = 0; TIMSK0|=(1&lt;&lt;OCIE0A)|(1&lt;&lt;OCIE0B); TIMSK2|=(1&lt;&lt;OCIE2A)|(1&lt;&lt;OCIE2B); OCR0A=start_position[1];//  0  0 OCR0B=start_position[2];//  0  1 OCR2A=start_position[3];//  0  2 OCR2B=start_position[4];//  0  3 COUNTER1_ON; COUNTER2_ON; COUNTER0_ON; return; } void time_delay(long i) { cli();sei(); long k; i*=2000; for(k=0;k&lt;i;k++){;;}; } void timer_counter0_1_2_INIT()//   0,1,2 { // 1 TCCR1A &amp;=~(1&lt;&lt;COM1A0)|~(1&lt;&lt;COM1A1)|~(1&lt;&lt;COM1B0)|~(1&lt;&lt;COM1B1);//   TCCR1A &amp;=~(1&lt;&lt;WGM10)|~(1&lt;&lt;WGM11); TCCR1B &amp;=~(1&lt;&lt;WGM12)|~(1&lt;&lt;WGM13);//    period_20ms=60575; TCNT1 = period_20ms; TIMSK1|=(1&lt;&lt;TOIE1);//|    //TIFR0   TOV0 // 0 TCCR0A &amp;=~(1&lt;&lt;COM0A0)|~(1&lt;&lt;COM0A1)|~(1&lt;&lt;COM0B0)|~(1&lt;&lt;COM0B1);//   TCCR0A &amp;=~(1&lt;&lt;WGM00)|~(1&lt;&lt;WGM01); TCCR0B &amp;=~(1&lt;&lt;WGM02);//    // 2 TCCR2A &amp;=~(1&lt;&lt;COM2A0)|~(1&lt;&lt;COM2A1)|~(1&lt;&lt;COM2B0)|~(1&lt;&lt;COM2B1);//   TCCR2A &amp;=~(1&lt;&lt;WGM20)|~(1&lt;&lt;WGM21); TCCR2B &amp;=~(1&lt;&lt;WGM22);//    COUNTER1_ON; } void servo_reset() { start_position[1]=97;//  0  0 start_position[2]=70;//  0  1 start_position[3]=92;//  0  2 start_position[4]=124; // 0  3 COUNTER1_ON; time_delay(100); } void servo_go( int8_t moven, uint8_t servo_position_max, uint8_t servo_position_min)// { switch (moven){ case 1: start_position[number_servo]++; if(start_position[number_servo]==servo_position_max){start_position[number_servo]--;};//  +90  break; case 2: start_position[number_servo]--; if(start_position[number_servo]==servo_position_min){start_position[number_servo]++;};//6  -90  break; }; time_delay(20); return; } //PORTB-0,1, PORTD - 6,7 -  , 8-  COUNTER 0 int main(void) { uint8_t servo_positionmin=0, servo_positionmax=0; int8_t const servo_position1max = 122, servo_position1min=58; //  int8_t const servo_position2max = 120, servo_position2min=36;// int8_t const servo_position3max = 125, servo_position3min=68;// int8_t const servo_position4max = 129, servo_position4min=108;// 128 108 sei(); DDRD = 0B11000010; //   D2-D5  , D0  RX, D1  TX, D6 D7   3  4 PORTD = 0B00111110; //     DDRB |=(1&lt;&lt;0)|(1&lt;&lt;1);//         PORTB &amp;=(~1&lt;&lt;0)|(~1&lt;&lt;1); UCSR0A=0;// UART UCSR0B=0b10010000; UCSR0C=0b00000110; UBRR0L=103;//  115200 UBRR0H=0; timer_counter0_1_2_INIT(); servo_reset(); PORTB |=(1&lt;&lt;5); while (1) { switch (State_of_keyboard) { case 1://   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 2: //   1 PD0(PB0) number_servo=1; servo_positionmin=servo_position1min; servo_positionmax=servo_position1max; break; case 5: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 6: number_servo=2; //   2 PD1(PB1) servo_positionmin=servo_position2min; servo_positionmax=servo_position2max; break; case 7: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 8: number_servo=3;//   3 PD6 servo_positionmin=servo_position3min; servo_positionmax=servo_position3max; break; case 3: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  case 4: number_servo=4; //   4 PD7 servo_positionmin=servo_position4min; servo_positionmax=servo_position4max; break;//  // c    - ,       4-  //        ,         } if(State_of_keyboard==1||State_of_keyboard==3||State_of_keyboard==5||State_of_keyboard==7) { servo_go(1,servo_positionmax,servo_positionmin);// } if(State_of_keyboard==2||State_of_keyboard==4||State_of_keyboard==6||State_of_keyboard==8) //     { servo_go(2,servo_positionmax,servo_positionmin);// } time_delay(20); } }</span></span></span></span></code> </pre><br><br></div></div><br>  Inti dari program ini jelas dari teks dan komentar.  Kami menggunakan penghitung T1 untuk periode contoh 20 ms dan T0, penghitung T2 untuk mengeluarkan sinyal PWM ke empat baris port I / O, karena masing-masing dari dua penghitung ini dapat bekerja pada dua perangkat. <br>  Program ini mengatur posisi awal servos dengan memuat register penghitung OCR0A, OCR0B, OCR2A, OCR2B.  Konstanta kendala juga diperkenalkan, karena kita tidak selalu membutuhkan rentang 180 derajat.  Baik dan selanjutnya, dengan interupsi dari UART, program menangkap nomor yang dikirim oleh ESP8266 (dari 1 hingga 8) dan menerjemahkannya menjadi perintah untuk servo yang sesuai.  Ada empat drive, masing-masing bekerja dalam dua arah, jadi bilangan bulat dari satu hingga delapan sudah cukup.  Setelah nomor dipilih, isi register penghitung di atas bertambah atau berkurang, masing-masing mengubah siklus tugas dari pulsa kontrol dan sudut rotasi dari drive servo yang dipilih.  Drive yang tidak kami pilih mempertahankan nilai lama sudut rotasi (karena isi register yang sesuai, meskipun diperbarui, tidak berubah) dan terus menahan lengan mekanik pada posisi yang sama. <br><br>  Sekarang kita hanya perlu menulis program kontrol, maaf untuk tautalogy, untuk mengontrol tangan mekanik langsung dari komputer melalui WI-FI. <br>  Kode ini juga ditulis dalam bahasa JAWA, tetapi sedikit dimuliakan.  GUI dan kemampuan untuk mengedit nomor port dan alamat jaringan ESP8266 muncul. <br><br><img src="https://habrastorage.org/web/d48/d3e/27a/d48d3e27af904919b00d0873de532d3d.png"><br><br>  Apa yang terjadi di sana jelas dari jendela.  Saya tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyediakan</a> teks program di sini (tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> ), karena alasan berikut: sekitar 95% volumenya adalah pembuatan jendela dan pemrosesan sinyal dari keyboard.  Tetapi intinya sama dengan program sebelumnya di JAVA.  Klien dibuat, hanya UDP, yang, tergantung pada tombol yang ditekan, mengirimkan angka dari 1 hingga 8, pada alamat yang ditentukan pada port yang ditentukan. <br>  Atau Anda bisa langsung mendapatkan executable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> .  Untuk mesin 64 bit dengan Windows.  Bahkan lingkungan JAVA yang diinstal tidak diperlukan.  Semuanya sudah dimasukkan ke 178 MB. <br><br>  Jadi, pena mekanis dirakit, di-debug, dan disajikan kepada saudaranya untuk ulang tahunnya.  Dapat mengambil tumpukan plastik dengan vodka, di Skype dari kota lain.  Meskipun untuk lengan mekanik Howard Volovitsa dari seri "The Big Bang Theory", dia masih jauh. <br><br>  Tetapi kemudian dalam artikel berikut (jika ada yang tertarik) kita akan dapat mengelolanya dari ponsel, melakukan hal yang sama dengan kereta roda empat robot dan memperbarui waktu dalam jam tangan elektronik dari server jam di Internet.  Kemudian kami meletakkan smartphone lama di troli dan mendorong video dari itu ke jaringan saraf dengan pengenalan pola, dan kembali sinyal kontrol ke motor, <s>oh sesuatu sudah membawa saya ...</s> <br><br>  Dan semua ini dengan ESP8266 yang indah. <br>  Saya akan senang jika ada yang menemukan artikel yang menarik. <br><br>  [1] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pinout dan spesifikasi ESP8266</a> <br>  [2] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghubungkan ESP8266.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mulai cepat.</a> <br>  [3] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembaruan firmware NodeMCU melalui cloud</a> <br>  [4] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NODE MCU PyFlasher</a> <br>  [5] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESPlorer - IDE untuk ESP8266</a> <br>  [6] <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">C Pemrograman untuk AVR</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tinjauan artikel - ‚ÄúMemprogram mikrokontroler dalam bahasa C‚Äù</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [8] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi NodeMCU API</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [9] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [10] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skrip dan modul Lua</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [11] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntelliJ IDEA</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [12] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduh Java ke komputer desktop Anda sekarang! </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atmel Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id406559/">https://habr.com/ru/post/id406559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id406547/index.html">Ulasan papan di SoC ARM + FPGA. Bagian Satu Dunia Xilinx</a></li>
<li><a href="../id406549/index.html">Panduan untuk material listrik untuk semua orang. Bagian 9</a></li>
<li><a href="../id406551/index.html">Monowheel: dua musim pengalaman</a></li>
<li><a href="../id406553/index.html">10 mesin desktop CNC terbaik untuk rumah 2017</a></li>
<li><a href="../id406555/index.html">Anda, saya dan Kecerdasan Buatan saya</a></li>
<li><a href="../id406561/index.html">Micromachines dalam pengobatan penyakit perut</a></li>
<li><a href="../id406563/index.html">Mengapa otak Anda perlu lebih banyak istirahat</a></li>
<li><a href="../id406567/index.html">Di bawah hantaman unsur-unsur: Kennedy Space Center sedang mempersiapkan badai "Irma"</a></li>
<li><a href="../id406569/index.html">XRONOS - agregator</a></li>
<li><a href="../id406571/index.html">Bagaimana cara mengalahkan penuaan - rencana tindakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>