<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤜🏿 ♋️ 🧖🏼 Docker: como implantar um aplicativo de pilha completa e não ficar cinza 📗 🧜🏼 💀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Precisamos de DevOps!" 
 (a frase mais popular no final de qualquer hackathon) 

 Primeiro, algumas letras. 

 Quando um desenvolvedor é um excelente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: como implantar um aplicativo de pilha completa e não ficar cinza</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448094/">  <i>"Precisamos de DevOps!"</i> <br>  <i>(a frase mais popular no final de qualquer hackathon)</i> <br><img src="https://habrastorage.org/webt/yy/k1/0q/yyk10qsi8ayqzxsnwqua1nwyzrk.jpeg"><br>  Primeiro, algumas letras. <br><br>  Quando um desenvolvedor é um excelente desenvolvedor que pode implantar sua ideia em qualquer máquina sob qualquer OC, isso é uma vantagem.  No entanto, se ele não entende nada além de seu IDE, isso não é um sinal de menos - no final, ele é pago pelo código, não pela capacidade de implementá-lo.  Um especialista estreito e profundo no mercado é avaliado acima da habilidade média de "valete de todos os negócios".  Para pessoas como nós, “usuários de IDE”, pessoas boas criaram o Docker. <br><br>  O princípio do Docker é o seguinte: "funciona para mim - funciona em todos os lugares".  O único programa necessário para implantar uma cópia do seu aplicativo em qualquer lugar é o Docker.  Se você executar seu aplicativo na janela de encaixe na sua máquina, é garantido que ele será executado com o mesmo sucesso em qualquer outra janela de encaixe.  E nada além de uma janela de encaixe precisa ser instalado.  Por exemplo, eu nem tenho Java no servidor virtual. <a name="habracut"></a><br><br><h2>  Como o docker funciona? </h2><br>  O Docker cria uma imagem de uma máquina virtual com aplicativos instalados nela.  Além disso, essa imagem se desdobra como uma máquina virtual completamente autônoma.  Uma cópia em execução da imagem é chamada de "contêiner".  Você pode executar qualquer número de imagens no servidor e cada uma delas será uma máquina virtual separada com seu próprio ambiente. <br><br>  O que é uma máquina virtual?  Este é o local encapsulado no servidor com o sistema operacional no qual os aplicativos estão instalados.  Em qualquer sistema operacional, um grande número de aplicativos geralmente está girando, no nosso existe um. <br><br>  O esquema de implantação de contêiner pode ser representado da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/9p/vq/ya/9pvqyam6ckaxqvihopwdoynhf4y.jpeg"><br><br>  Para cada aplicativo, criamos nossa própria imagem e implantamos cada contêiner separadamente.  Além disso, você pode colocar todos os aplicativos em uma imagem e implantar como um contêiner.  Além disso, para não implantar cada contêiner separadamente, podemos usar um utilitário docker-compose separado que configura os contêineres e o relacionamento entre eles por meio de um arquivo separado.  Em seguida, a estrutura de todo o aplicativo pode ficar assim: <br><br><img src="https://habrastorage.org/webt/ga/ft/fm/gaftfmbyumgesqldxv1pphh6ati.jpeg"><br><br>  Intencionalmente, não contribuí com o banco de dados para a assembléia geral do Docker, por vários motivos.  Primeiro, o banco de dados é completamente independente dos aplicativos que trabalham com ele.  Pode estar longe de um aplicativo, pode ser solicitações manuais do console.  Pessoalmente, não vejo razão para tornar o banco de dados dependente do assembly do Docker no qual está localizado.  Portanto, eu aguentei.  No entanto, muitas vezes é praticada uma abordagem na qual o banco de dados é colocado em uma imagem separada e iniciado em um contêiner separado.  Em segundo lugar, quero mostrar como o contêiner do Docker interage com os sistemas externos ao contêiner. <br><br>  No entanto, bem as letras, vamos escrever o código.  Escreveremos o aplicativo mais simples na primavera e reagiremos, que gravará nossas chamadas para a frente no banco de dados e elevaremos tudo isso através do Docker.  A estrutura do nosso aplicativo ficará assim: <br><br><img src="https://habrastorage.org/webt/k4/pp/lg/k4pplgvwba46vygymrasjctmrkm.jpeg"><br><br>  Existem muitas maneiras de implementar essa estrutura.  Estamos implementando um deles.  Criaremos duas imagens, lançaremos dois contêineres a partir deles, além disso, o back-end se conectará ao banco de dados, instalado em um servidor específico em algum lugar da Internet (sim, essas solicitações ao banco de dados não serão rápidas, mas não somos motivados pela necessidade de otimização, mas interesse científico). <br><br>  A postagem será dividida em partes: <br><br>  0. Instale o Docker. <br>  1. Nós escrevemos aplicativos. <br>  2. Coletamos imagens e lançamos contêineres. <br>  3. Colete imagens e inicie contêineres em um servidor remoto. <br>  4. Resolva os problemas de rede. <br><br><h2>  0. Instale o Docker </h2><br>  Para instalar o Docker, você precisa ir ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site</a> e seguir o que está escrito lá.  Ao instalar o Docker em um servidor remoto, esteja preparado para o fato de o Docker não funcionar com servidores no OpenVZ.  Além disso, pode haver problemas se você não tiver o iptables ativado.  É aconselhável iniciar o servidor no KVM com o iptables.  Mas estas são minhas recomendações.  Se tudo funcionar para você, e assim, ficarei feliz que você não gastou muito tempo descobrindo por que não funciona, como eu tive que fazê-lo. <br><br><h2>  1. Nós escrevemos aplicativos </h2><br>  Vamos escrever um aplicativo simples com o backend mais primitivo no Spring Boot, um frontend muito simples no ReactJS e um banco de dados MySQL.  O aplicativo terá uma página única com um único botão que registrará a hora em que foi clicada no banco de dados. <br><br>  Confio no fato de que você já sabe escrever aplicativos na inicialização, mas, se não, pode clonar o projeto finalizado.  Todos os links no final do artigo. <br><br><h3>  Back-end na Inicialização Spring </h3><br>  build.gradle: <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.4.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.2'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'mysql:mysql-connector-java'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Entidade de log: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.annotation.JsonFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Serializable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.LocalDateTime; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Objects; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 21:20 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"request_logs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Log</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime created; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-meta"><span class="hljs-meta">@JsonFormat</span></span>(shape = JsonFormat.Shape.STRING, pattern = <span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> created; } <span class="hljs-meta"><span class="hljs-meta">@PrePersist</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prePersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.created = LocalDateTime.now(); } <span class="hljs-comment"><span class="hljs-comment">//setters, toString, equals, hashcode, constructors</span></span></code> </pre> <br>  LogController, que funcionará na lógica simplificada e gravará imediatamente no banco de dados.  Nós omitimos o serviço. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.controller; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.core.JsonProcessingException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.databind.ObjectMapper; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.beans.factory.annotation.Autowired; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.http.ResponseEntity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RequestMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.entity.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.repository.LogRepository; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.logging.Logger; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 22:24 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/log"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOG = Logger.getLogger(LogController.class.getName()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LogRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LogRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ResponseEntity&lt;Log&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log log = repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Log()); LOG.info(<span class="hljs-string"><span class="hljs-string">"saved new log: "</span></span> + log.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResponseEntity.ok(log); } }</code> </pre><br>  Tudo, como vemos, é muito simples.  Por uma solicitação GET, escrevemos no banco de dados e retornamos o resultado. <br><br>  Discutiremos o arquivo de configurações do aplicativo separadamente.  Existem dois deles. <br><br>  application.yml: <br><br><pre> <code class="java hljs">spring: profiles: active: remote</code> </pre> <br>  application-remote.yml: <br><br><pre> <code class="java hljs">spring: datasource: driver-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cj</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">database</span></span></span><span class="hljs-class">:3306/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebounder_database</span></span></span><span class="hljs-class">?</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useUnicode</span></span></span></span>=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useJDBCCompliantTimezoneShift=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useLegacyDatetimeCode=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>&amp;serverTimezone=UTC username: admin password: <span class="hljs-number"><span class="hljs-number">12345</span></span> jpa: hibernate: ddl-auto: update show-sql: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> properties: hibernate.dialect: org.hibernate.dialect.MySQL5Dialect server: port: <span class="hljs-number"><span class="hljs-number">8099</span></span></code> </pre> <br>  Como isso funciona, você provavelmente sabe que o Spring verifica primeiro o arquivo application.properties ou application.yml - qual ele encontra.  Nele, indicamos uma única configuração - qual perfil usaremos.  Normalmente, durante o desenvolvimento, acumulo vários perfis, e é muito conveniente alterná-los usando o perfil padrão.  Em seguida, o Spring localiza application.yml com o sufixo desejado e o utiliza. <br><br>  Especificamos a fonte de dados, as configurações JPA e, principalmente, a porta externa do nosso back-end. <br><br><h3>  ReactJS Frontend </h3><br>  Você também pode ver o frontend em um projeto no git, ou até não pode assistir, mas cloná-lo e executá-lo. <br><br>  Você pode verificar o trabalho individual do front-end fazendo o download do projeto, acessando a pasta raiz do projeto no terminal (onde o arquivo package.json está localizado) e executando dois comandos em sequência: <br><br><pre> <code class="bash hljs">npm install //      ,  maven npm start //  </code> </pre> <br>  Obviamente, para isso, você precisa do Node Package Manager (npm) instalado, e é a maneira mais difícil de evitar o uso do Docker.  Se você ainda iniciou o projeto, verá a seguinte janela: <br><br><img src="https://habrastorage.org/webt/aq/m7/t4/aqm7t4txa2g_rqbuswo3uiibjpq.png"><br><br>  Oh, bem, é hora de olhar para o código.  Vou indicar apenas a parte que se refere ao back-end. <br><br><pre> <code class="java hljs">export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ _apiPath = <span class="hljs-string"><span class="hljs-string">'http://localhost:8099'</span></span>; _logUrl = <span class="hljs-string"><span class="hljs-string">'/log'</span></span>; getResource = async () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(`${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._apiPath}${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._logUrl}`)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res.ok) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(`Could not fetch ${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._logUrl}` + `, received ${res.status}`) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await res.json(); }; };</code> </pre> <br>  O frontend funciona previsivelmente.  Seguimos o link, aguardamos a resposta e a exibimos na tela. <br><br><img src="https://habrastorage.org/webt/xz/vy/qd/xzvyqdrh7akd1c1flu-gnjhcxok.png"><br><br>  Vale a pena focar nos seguintes pontos: <br><br><ol><li>  A frente está aberta para o mundo exterior pela porta 3000. Essa é a porta padrão para o React. </li><li>  A parte traseira é aberta na porta 8099. Definimos nas configurações do aplicativo. </li><li>  A parte de trás está batendo no banco de dados através da Internet externa. </li></ol><br>  O aplicativo está pronto. <br><br><h2>  2. Colete imagens e lance contêineres </h2><br>  A estrutura da nossa montagem será a seguinte.  Criaremos duas imagens - front-end e back-end, que se comunicarão através de portas externas.  Para a base, não criaremos uma imagem, instalaremos separadamente.  Porque  Por que não criamos uma imagem para a base?  Temos dois aplicativos que mudam constantemente e não armazenam dados em nós mesmos.  O banco de dados armazena dados em si mesmo, e isso pode ser o resultado de vários meses de operação do aplicativo.  Além disso, esse banco de dados pode ser acessado não apenas pelo nosso aplicativo de back-end, mas também por muitos outros - pois também é um banco de dados, e não o iremos remontar constantemente.  Novamente, esta é uma oportunidade de trabalhar com uma API externa, que, é claro, é conectar-se ao nosso banco de dados. <br><br><h4>  Montagem frontal </h4><br>  Para executar cada aplicativo (seja na frente ou atrás), você precisa de uma certa sequência de ações.  Para executar o aplicativo no React, precisamos fazer o seguinte (desde que já tenhamos Linux): <br><br><ol><li>  Instale o NodeJS. </li><li>  Copie o aplicativo para uma pasta específica. </li><li>  Instale os pacotes necessários (comando npm install). </li><li>  Inicie o aplicativo com o comando npm start. </li></ol><br>  É essa sequência de ações que precisamos executar na janela de encaixe.  Para fazer isso, na raiz do projeto (no mesmo local que package.json está localizado), devemos colocar o Dockerfile com o seguinte conteúdo: <br><br><pre> <code class="javascript hljs">FROM node:alpine WORKDIR /usr/app/front EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span> COPY ./ ./ RUN npm install CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Vamos ver o que cada linha significa. <br><br><pre> <code class="javascript hljs">FROM node:alpine</code> </pre> <br>  Com essa linha, deixamos claro para a janela de encaixe que quando você inicia o contêiner, a primeira coisa que você precisa fazer é baixar o Docker do repositório e instalar o NodeJS e a mais leve (todas as versões mais leves de estruturas e bibliotecas populares na janela de encaixe são geralmente chamadas de alpinas). <br><br><pre> <code class="javascript hljs">WORKDIR /usr/app/front</code> </pre> <br>  No contêiner do Linux, as mesmas pastas padrão serão criadas como em outras pastas do Linux - / opt, / home, / etc, / usr e assim por diante.  Definimos o diretório de trabalho com o qual iremos trabalhar - / usr / app / front. <br><br><pre> <code class="javascript hljs">EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span></code> </pre> <br>  Abrimos a porta 3000. Uma comunicação adicional com o aplicativo em execução no contêiner ocorrerá através dessa porta. <br><br><pre> <code class="javascript hljs">COPY ./ ./</code> </pre> <br>  Copie o conteúdo do projeto de origem para a pasta de trabalho do contêiner. <br><br><pre> <code class="javascript hljs">RUN npm install</code> </pre> <br>  Instale todos os pacotes necessários para executar o aplicativo. <br><br><pre> <code class="javascript hljs">CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Iniciamos o aplicativo com o comando npm start. <br><br>  Este cenário será executado em nosso aplicativo quando o contêiner iniciar. <br><br>  Vamos direto na frente.  Para fazer isso, no terminal, estando na pasta raiz do projeto (onde o Dockerfile está localizado), execute o comando: <br><br><pre> <code class="java hljs">docker build -t rebounder-chain-frontend .</code> </pre> <br>  Valores de comando: <br><br>  docker é uma chamada para o aplicativo docker, bem, você sabe disso. <br>  construir - crie uma imagem a partir dos materiais de destino. <br>  -t &lt;name&gt; - no futuro, o aplicativo estará disponível pela tag especificada aqui.  Você pode omitir isso, o Docker gerará sua própria tag, mas será impossível diferenciá-lo dos outros. <br>  .  - indica que você precisa coletar o projeto da pasta atual. <br><br><img src="https://habrastorage.org/webt/ro/fc/nz/rofcnzucfn0207jnqulzpjrgxw4.jpeg"><br><br>  Como resultado, a montagem deve terminar com o texto: <br><br><pre> <code class="java hljs">Step <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span> : CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>] ---&gt; Running in ee0e8a9066dc Removing intermediate container ee0e8a9066dc ---&gt; b208c4184766 Successfully built b208c4184766 Successfully tagged rebounder-chain-frontend:latest</code> </pre> <br>  Se percebermos que a última etapa foi concluída e tudo foi bem-sucedido, temos uma imagem.  Podemos verificar isso executando-o: <br><br><pre> <code class="java hljs">docker run -p <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> rebounder-chain-frontend</code> </pre> <br>  Acho que o significado desse comando é geralmente entendido, com exceção da entrada -p 8080: 3000. <br>  docker run rebounder-chain-frontend - significa que estamos lançando uma imagem do docker, que chamamos de rebounder-chain-frontend.  Mas esse contêiner não terá uma saída para o exterior, ele precisa definir uma porta.  É a equipe abaixo que define isso.  Lembramos que nosso aplicativo React é executado na porta 3000. O comando -p 8080: 3000 diz ao docker para pegar a porta 3000 e encaminhá-la para a porta 8080 (que será aberta).  Portanto, um aplicativo executado na porta 3000 será aberto na porta 8080 e estará disponível na máquina local nessa porta. <br><br><pre> <code class="bash hljs">,       : Mac-mini-Vaceslav:rebounder-chain-frontend xpendence$ docker run -p 8080:3000 rebounder-chain-frontend &gt; rebounder-chain-frontend@0.1.0 start /usr/app/front &gt; react-scripts start Starting the development server... Compiled successfully! You can now view rebounder-chain-frontend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the browser. Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/ Note that the development build is not optimized. To create a production build, use npm run build.</code> </pre> <br>  Não deixe o registro incomodá-lo <br><br><pre> <code class="bash hljs"> Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/</code> </pre> <br>  Reagir pensa assim.  Ele está realmente disponível no contêiner na porta 3000, mas encaminhamos essa porta para a porta 8080 e, a partir do contêiner, o aplicativo é executado na porta 8080. Você pode executar o aplicativo localmente e verificar isso. <br><br>  Portanto, temos um contêiner pronto com um aplicativo front-end, agora vamos coletar o back-end. <br><br><h4>  Crie back-end. </h4><br>  O script para iniciar um aplicativo em Java é significativamente diferente do assembly anterior.  Consiste nos seguintes itens: <br><br><ol><li>  Instale a JVM. </li><li>  Nós coletamos o arquivo jar. </li><li>  Nós o lançamos. </li></ol><br>  No Dockerfile, esse processo se parece com o seguinte: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># back #     JVM FROM openjdk:8-jdk-alpine #  . ,    .  . LABEL maintainer="2262288@gmail.com" #         (  ,  ) VOLUME /tmp #  ,        EXPOSE 8099 # ,       ARG JAR_FILE=build/libs/rebounder-chain-backend-0.0.2.jar #       rebounder-chain-backend.jar ADD ${JAR_FILE} rebounder-chain-backend.jar #    ENTRYPOINT ["java","-jar","/rebounder-chain-backend.jar"]</span></span></code> </pre> <br>  O processo de montagem de uma imagem com a inclusão de um dzharnik em alguns pontos se assemelha ao de nossa frente. <br><br>  O processo de montagem e lançamento da segunda imagem é essencialmente o mesmo que montagem e lançamento da primeira imagem. <br><br><pre> <code class="bash hljs">docker build -t rebounder-chain-backend . docker run -p 8099:8099 rebounder-chain-backend</code> </pre> <br>  Agora, se você tiver os dois contêineres em execução e o back-end estiver conectado ao banco de dados, tudo funcionará.  Lembro que você deve registrar a conexão com o banco de dados a partir do back-end e deve trabalhar através de uma rede externa. <br><br><h2>  3. Colete imagens e execute contêineres em um servidor remoto </h2><br>  Para que tudo funcione em um servidor remoto, precisamos do Docker já instalado nele, após o qual, basta executar as imagens.  Seguiremos o caminho certo e enviaremos nossas imagens para nossa conta na nuvem do Docker, após o que elas estarão disponíveis em qualquer lugar do mundo.  Obviamente, existem muitas alternativas para essa abordagem, bem como tudo o que é descrito no post, mas vamos avançar um pouco mais e fazer nosso trabalho bem.  Ruim, como Andrei Mironov disse, sempre temos tempo para fazê-lo. <br><br><h4>  Criando uma conta no hub do Docker </h4><br>  A primeira coisa que você precisa fazer é obter uma conta no hub do Docker.  Para fazer isso, vá para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hub</a> e registre-se.  Não é difícil. <br><br>  Em seguida, precisamos ir ao terminal e fazer login no Docker. <br><br><pre> <code class="bash hljs">docker login</code> </pre> <br>  Você será solicitado a inserir um nome de usuário e senha.  Se tudo estiver ok, uma notificação aparecerá no terminal que o Login foi bem-sucedido. <br><br><h4>  Confirmando imagens no Docker Hub </h4><br>  Em seguida, precisamos marcar nossas imagens e enviá-las para o hub.  Isso é feito pela equipe de acordo com o seguinte esquema: <br><br><pre> <code class="bash hljs">docker tag   /_:</code> </pre> <br>  Portanto, precisamos especificar o nome da nossa imagem, login / repositório e a marca sob a qual nossa imagem será confirmada no hub. <br><br>  No meu caso, ficou assim: <br><br><img src="https://habrastorage.org/webt/wu/pv/fh/wupvfhs3za_nws2wwsicgfgm2z4.jpeg"><br><br>  Podemos verificar a presença desta imagem no repositório local usando o comando: <br><br><pre> <code class="bash hljs">Mac-mini-Vaceslav:rebounder-chain-backend xpendence$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE xpendence/rebounder-chain-backend 0.0.2 c8f5b99e15a1 About an hour ago 141MB</code> </pre> <br>  Nossa imagem está pronta para ser confirmada.  Confirmar: <br><br><pre> <code class="bash hljs">docker push xpendence/rebounder-chain-backend:0.0.2</code> </pre> <br>  Um registro de confirmação bem-sucedido deve aparecer. <br>  Faça o mesmo com o frontend: <br><br><pre> <code class="bash hljs">docker tag rebounder-chain-frontend xpendence/rebounder-chain-frontend:0.0.1 docker push xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Agora, se formos para hub.docker.com, veremos duas imagens bloqueadas.  Que estão disponíveis em qualquer lugar. <br><br><img src="https://habrastorage.org/webt/ur/zs/hk/urzshkc3j1ivikyhu4cxvcm43yk.png"><br><br><img src="https://habrastorage.org/webt/cr/if/rb/crifrbda12uxdq6habx6nfeablm.png"><br><br>  Parabéns  Nós apenas temos que passar para a parte final do nosso trabalho - para lançar imagens em um servidor remoto. <br><br><h4>  Executar imagens em um servidor remoto </h4><br>  Agora podemos executar nossa imagem em qualquer máquina com o Docker, preenchendo apenas uma linha no terminal (no nosso caso, precisamos executar sequencialmente duas linhas em terminais diferentes - uma para cada imagem). <br><br><pre> <code class="bash hljs">docker run -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Este lançamento tem, no entanto, um sinal de menos.  Quando o terminal estiver fechado, o processo será encerrado e o aplicativo deixará de funcionar.  Para evitar isso, podemos executar o aplicativo no modo "desanexado": <br><br><pre> <code class="bash hljs">docker run -d -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -d -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Agora, o aplicativo não emitirá um log para o terminal (isso pode ser configurado novamente), mas mesmo quando o terminal estiver fechado, ele não parará de funcionar. <br><br><h2>  4. Resolvendo problemas de rede </h2><br>  Se você fez tudo certo, pode esperar a maior decepção no caminho para seguir este post - pode acontecer que nada funcione.  Por exemplo, tudo funcionou perfeitamente para você e funcionou na máquina local (como, por exemplo, no meu Mac), mas quando implantados em um servidor remoto, os contêineres pararam de se ver (como, por exemplo, no meu servidor remoto no Linux).  Qual é o problema?  Mas o problema é esse, e no começo eu sugeri isso.  Como mencionado anteriormente, quando o contêiner é iniciado, o Docker cria uma máquina virtual separada, rola o Linux para lá e instala o aplicativo nesse Linux.  Isso significa que o host local condicional para o contêiner em execução é limitado ao próprio contêiner e o aplicativo não está ciente da existência de outras redes.  Mas precisamos: <br><br>  a) os contêineres se viam. <br>  b) o back-end viu o banco de dados. <br><br>  Existem duas soluções para o problema. <br><br>  1. Criando uma rede interna. <br>  2. Trazendo contêineres para o nível do host. <br><br>  1. No nível do Docker, você pode criar redes, além disso, três delas por padrão - <i>bridge</i> , <i>none</i> e <i>host</i> . <br><br>  <i>Bridge</i> é uma rede interna do Docker isolada da rede host.  Você pode acessar contêineres apenas pelas portas que você abre quando o contêiner inicia com o comando <i>-p</i> .  Você pode criar qualquer número de redes, como <i>ponte</i> . <br><br><img src="https://habrastorage.org/webt/ld/sp/pf/ldsppf06sqnpf6cumhqodzsiiga.jpeg"><br><br>  <i>Nenhuma</i> é uma rede separada para um contêiner específico. <br><br>  <i>Host</i> é a rede host.  Ao escolher essa rede, seu contêiner é totalmente acessível por meio do host - o comando <i>-p</i> simplesmente não funciona aqui e, se você implantou o contêiner nessa rede, não precisa especificar uma porta externa - o contêiner pode ser acessado por sua porta interna.  Por exemplo, se o Dockerfile EXPOSE estiver definido como 8090, é por essa porta que o aplicativo estará disponível. <br><br><img src="https://habrastorage.org/webt/ve/6r/rw/ve6rrwnis25uarwrfudc_xlps4o.jpeg"><br><br>  Como precisamos ter acesso ao banco de dados do servidor, usaremos o último método e colocaremos os contêineres na rede do servidor remoto. <br><br>  Isso é feito com muita simplicidade, removemos a menção de portas do comando de inicialização do contêiner e especificamos a rede host: <br><br><pre> <code class="bash hljs">docker run --net=host xpendence/rebounder-chain-frontend:0.0.8</code> </pre> <br>  Conexão à base que eu indiquei <br><br><pre> <code class="bash hljs">localhost:3306</code> </pre> <br>  A conexão da frente à parte traseira tinha que ser especificada inteiramente, externa: <br><br><pre> <code class="bash hljs">http://&lt;__:__&gt;</code> </pre> <br>  Se você encaminhar a porta interna para a porta externa, que geralmente é o caso de servidores remotos, será necessário especificar a porta interna para o banco de dados e a porta externa para o contêiner. <br><br>  Se você quiser experimentar conexões, poderá fazer o download e criar um projeto que escrevi especialmente para testar a conexão entre contêineres.  Basta digitar o endereço desejado, pressionar Enviar e, no modo de depuração, ver o que voou de volta. <br><br>  O projeto está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h2>  Conclusão </h2><br>  Existem várias maneiras de criar e executar uma imagem do Docker.  Para os interessados, aconselho você a aprender docker-compor.  Aqui examinamos apenas uma das maneiras de trabalhar com o docker.  Obviamente, essa abordagem a princípio não parece tão simples.  Mas aqui está um exemplo - durante a escrita de uma postagem, eu tinha conexões de saída em um servidor remoto.  E durante o processo de depuração, tive que alterar as configurações de conexão com o banco de dados várias vezes.  Todo o conjunto e implantação se encaixam no meu conjunto de 4 linhas, depois de entrar, onde vi o resultado em um servidor remoto.  No modo de programação extremo, o Docker é indispensável. <br><br>  Como prometido, eu posto as fontes do aplicativo: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">back-end</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">frontend</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448094/">https://habr.com/ru/post/pt448094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448080/index.html">Robo jogador de futebol de iniciantes. Competições no MIPT. Android, Arduino e Bluetooth</a></li>
<li><a href="../pt448082/index.html">[Antes de segunda-feira] Síndrome do olho seco</a></li>
<li><a href="../pt448084/index.html">Foto de um buraco negro - será útil?</a></li>
<li><a href="../pt448088/index.html">Produção de motores a plasma na Rússia</a></li>
<li><a href="../pt448090/index.html">Frontend Weekly Digest (8-14 abr 2019)</a></li>
<li><a href="../pt448096/index.html">Julia em látex</a></li>
<li><a href="../pt448098/index.html">GHIDRA, executáveis ​​do Playstation 1, assinaturas FLIRT e PsyQ</a></li>
<li><a href="../pt448100/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 360 (7 a 14 de abril de 2019)</a></li>
<li><a href="../pt448102/index.html">Equipe dos sonhos do nada: contratação de profissionais de TI</a></li>
<li><a href="../pt448106/index.html">Treinamento de desenvolvedores 1C-Bitrix: compartilhe nossa abordagem para o "crescimento" de pessoal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>