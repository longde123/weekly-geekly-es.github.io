<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏾 👐🏼 🤾🏾 Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil zwei 🔳 👴🏽 🤾🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil des Artikels, der benutzerdefinierte Funktionen für die Arbeit mit Systemverzeichnissen beschreibt: pg_class, pg_attribute, p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil zwei</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415897/">  Dies ist der zweite Teil des Artikels, der benutzerdefinierte Funktionen für die Arbeit mit Systemverzeichnissen beschreibt: pg_class, pg_attribute, pg_constraints usw. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zc/rx/ta/zcrxta08dnfat5cqpgid4lyq7by.png"></div><br>  In diesem Teil des Artikels werden Funktionen erläutert, <b>die die Eigenschaften von Einschränkungen und Indizes zurückgeben</b> . <br><a name="habracut"></a><br>  Die erste Hälfte des Artikels enthält Kommentare zur Implementierung von Funktionen.  Der zweite ist der Quellcode der Funktionen.  Für diejenigen Leser, die nur an den Ausgangstexten interessiert sind, empfehlen wir, sofort mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang fortzufahren</a> . <br><p>  <b>Siehe auch</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil eins</a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil drei</a> .</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Ende (Teil vier)</a> .</b> <br><br></p><h3>  admtf_Table_Constraintes Liste der Einschränkungen der Datenbanktabelle und ihrer Eigenschaften </h3><br><a name="tfTableC_def"></a><br><p>  Die Funktion admtf_Table_Constraintes gibt eine Liste der Einschränkungen (CONSTRAINT) der Datenbanktabelle und ihrer Merkmale zurück.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode kann hier angezeigt und heruntergeladen werden</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist eine Version einer Funktion, die keinen Cursor verwendet</a> . </p><br><br>  Als Parameter verwendet die Funktion den Namen der <b>Quelltabelle</b> ( <b>a_TableName</b> ) und den Namen des Schemas, in dem die Tabelle erstellt wird ( <b>a_SchemaName</b> ). <br><br><p>  Die Beschreibung einer bestimmten Einschränkung ist eine Kombination aus dem Datensatz in <b>pg_class</b> , der sie als physikalische Beziehung beschreibt, und dem Datensatz in <b>pg_constraint</b> , der Daten zu den spezifischen Merkmalen der Einschränkung enthält. </p><br><br><img src="https://habrastorage.org/webt/q8/xc/ll/q8xcllhdjgtvndtzraq2ofsssti.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tbl.OID,con.conname,con.contype,con.conkey,reftbl.OID, reftbl.relname,con.confkey,con.consrc <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint con <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.connamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.conrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class reftbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.confrelid=reftbl.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.contype <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>,con.conname;</code> </pre> <br></div></div><br><p>  Die Hauptdaten (Name und Art der Einschränkung) werden aus dem Verzeichniseintrag <b>pg_constraint</b> abgerufen.  Die Merkmale jeder Einschränkung werden aus demselben Katalog extrahiert, der in Form von OID-Tabellen ( <b>conrelid</b> , <b>confrelid</b> ) oder Arrays von Attribut-Seriennummern ( <b>conkey</b> , <b>confkey</b> ) dargestellt wird, die an der Einschränkung teilnehmen. </p><br><br><p>  Die Funktion gibt Einschränkungsmerkmale in Form von Tabellennamen und Attributen zurück.  In diesem Fall werden die Tabellennamen aus dem Katalogeintrag <b>pg_class</b> nach Kennung (OID) und die Attributnamen aus den Katalogeinträgen <b>pg_attribute</b> nach Tabellenkennung und Attributseriennummer <b>extrahiert</b> .  Weil  Da Seriennummern in Form eines Arrays (einer Liste) im Hauptverzeichnis gespeichert sind, werden Listen von Attributnamen innerhalb der Funktion mithilfe einer Schleife erstellt. </p><br><p>  Die Funktion gibt ein spezielles Merkmal zurück - die Regel zum Überprüfen der Werte von Feldern in Tabelleneinträgen (Einschränkung CHECK).  Dieses Merkmal wird als <b>Textwert im</b> Feld <b>consrc des</b> Verzeichnisses <b>pg_constraint gespeichert</b> . </p><br>  <strong>Tabelle 7. Das Ergebnis der Ausführung der Funktion admtf_Table_Constraintes ('public', 'Street').</strong> <br><img src="https://habrastorage.org/webt/gd/x6/ny/gdx6ny5rnukyvjntf4bjirkwlye.png"><br><div class="spoiler">  <b class="spoiler_title">Die Textversion der Tabelle in der Abbildung</b> <div class="spoiler_text"><table width="80" border="1"><tbody><tr><th width="15">  Titel </th><th width="5">  Typ </th><th width="20">  Quellentabellenattribute </th><th width="10">  Der Name der externen Tabelle </th><th width="15">  Attribute einer externen Tabelle </th><th width="15">  Validierungsregel </th></tr><tr><td width="15">  xpkstreet </td><td width="5">  p </td><td width="20">  wcrccode, localityid, streetid </td><td width="10"></td><td width="15"></td><td width="15"></td></tr><tr><td width="15">  fk_street_locality </td><td width="5">  f </td><td width="20">  wcrccode, localityid </td><td width="10">  Lokalität </td><td width="15">  wcrccode, localityid </td><td width="15"></td></tr><tr><td width="15">  fk_street_streettype </td><td width="5">  f </td><td width="20">  Streettypeacrm </td><td width="10">  Streettyp </td><td width="15">  Streettypeacrm </td><td width="15"></td></tr><tr><td width="15">  ck_street_streetname </td><td width="5">  c </td><td width="20">  Straßenname </td><td width="10"></td><td width="15"></td><td width="15">  ((Straßenname) :: text! ~ * '[az]' :: text) </td></tr><tr><td width="15">  ck_street_streettypeacrm </td><td width="5">  c </td><td width="20">  Streettypeacrm </td><td width="10"></td><td width="15"></td><td width="15">  ((streettypeacrm) :: bpchar! ~ * '[az]' :: text) </td></tr></tbody></table><br></div></div><br><a name="tfTableC_woc_def"></a><br><h4>  Version ohne Cursor </h4><br><p>  Ich sehe Fragen und Kommentare zur Verwendung des Cursors in der Hauptversion der Funktion voraus. </p><br><p>  Ich werde nicht antworten - es gibt keine Kameraden für den Geschmack und die Farbe.  Aber ich werde eine Version der Funktion ohne Cursor geben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Version der Funktionsimplementierung ohne Verwendung des Cursors kann hier angezeigt und heruntergeladen werden</a> . </p><br><p>  Die Hauptschwierigkeit besteht darin, den Join (JOIN) der Tabellen gemäß den Werten zu organisieren, die sich im Attributtyp des Arrays eines dieser Tabellen befinden.  Solche Arrays sind in diesem Fall <b>conkey</b> und <b>confkey</b> . </p><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.conname,c.contype,c.conkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[], GENERATE_SUBSCRIPTS(c.conkey, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.conname=<span class="hljs-string"><span class="hljs-string">'fk_street_locality'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span>;</code> </pre><br><p>  Um ein solches Problem zu lösen, enthält PostgrSQL Funktionen, die eine Wertetabelle von Zeigern auf Array-Elemente zurückgeben.  In unserem Fall wird die Funktion <b>generate_subscripts</b> verwendet.  Es werden nicht nur viele Zeiger auf die Position des Arrays generiert, das als Parameter an das Array übergeben wird, sondern es wird auch ein Datensatz, der das Array enthält, durch die Anzahl der Elemente im Array in mehrere umgewandelt.  Jeder Datensatz einer solchen Tabelle enthält einen eindeutigen Wert - die Position des Arrays. </p><br><br>  <strong>Tabelle 8. Weitergabe der ursprünglichen Zeichenfolge mithilfe von <b>generate_subscripts</b> .</strong> <br><br><table width="95" border="1"><tbody><tr><th width="15">  Restriktionsname </th><th width="5">  Typ </th><th width="10">  Array von Attributnummern </th><th width="10">  Zeiger auf eine Array-Position </th></tr><tr><td width="15">  fk_street_locality </td><td width="5">  f </td><td width="10">  {1,2} </td><td width="10">  1 </td></tr><tr><td width="15">  fk_street_locality </td><td width="5">  f </td><td width="10">  {1,2} </td><td width="10">  2 </td></tr></tbody></table><br><br><img src="https://habrastorage.org/webt/0t/yn/9_/0tyn9__z3p-g8knkavap0aluta8.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> con.conname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ConstraintName,con.contype::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ConstraintType, STRING_AGG(attr.attname, <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.No) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_ConstraintKeyNames, reftbl.relname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> RefTableName, STRING_AGG(rattr.attname,<span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.No) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_RefTableKeyNames, con.consrc <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ConstraintSource <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.oid, c.conrelid,c.confrelid,c.conname,c.contype, c.conkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],c.consrc, c.confkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[], generate_subscripts(c.conkey, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint c) con <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.conrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.attrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum=con.conkey[con.No] <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class reftbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.confrelid=reftbl.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute rattr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rattr.attrelid=reftbl.oid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rattr.attnum=con.confkey[con.No] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.conname,con.contype,reftbl.relname,con.consrc <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.contype <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>,con.conname;</code> </pre><br></div></div><br><p>  Eine solche Tabelle kann mit dem Attributkatalog <b>pg_attribute</b> verbunden werden, <b>indem</b> Attributnamen unter der Bedingung <b>attr.attrelid = tbl.oid AND attr.attnum = con.conkey [con.No] daraus extrahiert werden</b> . <br>  Jetzt müssen Sie nicht mehr unnötige Datensätze entfernen, indem Sie Datensätze gruppieren und aus den Namen der Attribute eine Zeichenfolge erstellen. </p><br><p>  Das Erstellen einer Zeile erfolgt mit der Aggregationsfunktion <b>STRING_AGG</b> , in der Sie die <b>Sortieroption</b> (ORDER BY) angeben müssen. <b>Andernfalls stimmt</b> die Reihenfolge der Attribute möglicherweise nicht mit der Reihenfolge der Deklaration der Attribute im Index überein. </p><br><br><p>  Die Ausführungszeit beider Versionen der Funktionen stimmte überein.  Die Ausgabe der Daten in der Ergebnistabelle dauerte 20 ms. </p><br><h3>  Admtf_Table_Indexes Funktionsliste der Datenbanktabellenindizes und ihrer Eigenschaften </h3><br><a name="tfTableI_def"></a><br><p>  Die Funktion admtf_Table_Indexes gibt eine Liste der Indizes (INDEX) der Datenbanktabelle und ihrer Merkmale zurück.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode kann hier angezeigt und heruntergeladen werden</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist eine Version einer Funktion, die keinen Cursor verwendet</a> . </p><br>  Als Parameter verwendet die Funktion den Namen der <b>Quelltabelle</b> ( <b>a_TableName</b> ) und den Namen des Schemas, in dem die Tabelle erstellt wird ( <b>a_SchemaName</b> ). <br><img src="https://habrastorage.org/webt/fb/wv/jm/fbwvjmsipergemhoi8u1dyf8z3m.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tbl.oid,inxcls.relname,inxam.amname,inx.indisunique,inx.indisprimary, inx.indkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],inx.indoption::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],inxam.amcanorder <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index inx <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class inxcls <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indexrelid=inxcls.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace inxnsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inxcls.relnamespace=inxnsp.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_am inxam <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inxcls.relam=inxam.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inxam.amname, inxcls.relname;</code> </pre><br></div></div><br><p>  Die Beschreibung eines einzelnen Index ist eine Kombination aus einem Datensatz in <b>pg_class</b> , der ihn als physikalische Beziehung beschreibt, und einem Datensatz in <b>pg_index</b> , der Daten zu den spezifischen Merkmalen des Index enthält.  Darüber hinaus werden Informationen zu Indexzugriffsmethoden im Systemverzeichnis pg_am gespeichert. </p><br><pre> <code class="sql hljs">CASE inxam.amcanorder WHEN true THEN CASE inx.indoption[inx.No] &amp; 1 WHEN 1 THEN ' DESC' ELSE ' ASC' <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre><br><p>  <b>Ein</b> Attribut der Index-Eindeutigkeit ( <b>indisunique</b> ), ein Zeichen dafür, dass der Index gemäß der Beschreibung des Primärschlüssels ( <b>indisprimary</b> ) erstellt wurde, sowie Arrays von Seriennummern der Tabellenattribute, basierend auf den Werten, deren Index ( <b>indkey</b> ) und Zeichen der Reihenfolge der Sortierattributwerte aus dem Katalogeintrag <b>pg_index</b> extrahiert werden <b>,</b> werden extrahiert im Index ( <b>indoption</b> ). </p><br><p>  Aus dem Katalogeintrag, der die Zugriffsmethode des <b>pg_am-</b> Index beschreibt, werden das Attribut der Eignung der im Index enthaltenen Daten für die Sortierung ( <b>amcanorder</b> ) und der Name oder Typ der Zugriffsmethode des Index ( <b>amname</b> ) <b>extrahiert</b> . </p><p></p><p>  Mit anderen Worten, das amcanorder-Attribut gibt an, ob es möglich ist, eine Sortierreihenfolge für die Werte der im Index enthaltenen Attribute festzulegen.  Wenn <b>amcanorder = true ist</b> , kann die Sortierreihenfolge angegeben werden, andernfalls nicht.  Aus derselben Abbildung ist die Bedeutung der Werte des <b>Indoptionsarrays ersichtlich.</b> Wenn das rechte Bit der Binärform des Werts 1B enthält, wird der Wert des entsprechenden Attributs in absteigender Reihenfolge sortiert, andernfalls in aufsteigender Reihenfolge. </p><br><p>  Innerhalb der Funktion werden mithilfe eines Zyklus Listen mit Namen von Attributen erstellt, die im Index enthalten sind, sowie Zeichen für die Reihenfolge der Attributwerte. </p><br><br>  <strong>Tabelle 9. Das Ergebnis der Ausführung der Funktion admtf_Table_Indexes ('public', 'Street').</strong> <strong><br></strong> <br><img src="https://habrastorage.org/webt/u0/ft/uz/u0ftuzwae5ew1anmkqwjgvqlrbg.png"><br><div class="spoiler">  <b class="spoiler_title">Die Textversion der Tabelle in der Abbildung</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="15">  Indexname </th><th width="5">  Methode </th><th width="5">  ?  Einzigartig </th><th width="5">  ?  Primärschlüssel </th><th width="20">  Attribute im Index </th></tr><tr><td width="15">  xie1street </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  wcrccode ASC, localityid ASC, streettypeacrm ASC, Straßenname ASC </td></tr><tr><td width="15">  xie2stree </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  wcrccode ASC, localityid ASC, Straßenname ASC </td></tr><tr><td width="15">  xie3street </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  Straßenname ASC </td></tr><tr><td width="15">  xie9street </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  wcrccode ASC, localityid ASC, Straßenname DESC </td></tr><tr><td width="15">  xpkstreet </td><td width="5">  btree </td><td width="5">  t </td><td width="5">  t </td><td width="20">  wcrccode ASC, localityid ASC, streetid ASC </td></tr><tr><td width="15">  xts1street </td><td width="5">  Gin </td><td width="5">  f </td><td width="5">  f </td><td width="20">  streettsvector </td></tr><tr><td width="15">  xts2street </td><td width="5">  Gin </td><td width="5">  f </td><td width="5">  f </td><td width="5">  streettsvector </td></tr></tbody></table><br></div></div><br><h4>  Version ohne Cursor </h4><br><p>  Der Ansatz zum Erstellen einer Version einer Funktion ohne Cursor ist genau der gleiche wie im vorherigen Abschnitt beschrieben: </p><br><ul><li>  Reproduktion von Datensätzen mit generate_subscripts; </li><li>  nachfolgende Gruppierung von Datensätzen; </li><li>  Erstellen einer Liste von Indexattributen mit der Funktion STRING_AGG mit der Option ORDER BY. </li></ul><br><img src="https://habrastorage.org/webt/7f/3y/bm/7f3ybmq5e8bd7auydle70utg8-k.png"><br><div class="spoiler">  <b class="spoiler_title">der Quellcode des Operators in der Abbildung</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> inxcls.relname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_IndexName ,inxam.amname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_IndexType, inx.indisunique <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_isUnique,inx.indisprimary <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_isPrimary, STRING_AGG(attr.attname|| <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> inxam.amcanorder <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> inx.indoption[inx.No] &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">' DESC'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">' ASC'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, c_Delimiter <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inx.No) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i.indrelid, i.indexrelid,i.indisunique,i.indisprimary, i.indkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],i.indoption::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[], generate_subscripts(i.indkey, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index i) inx <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class inxcls <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indexrelid=inxcls.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_am inxam <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inxcls.relam=inxam.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.attrelid=tbl.OID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum=inx.indkey[inx.No] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inxcls.relname,inxam.amname,inx.indisunique,inx.indisprimary <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inxcls.relname;</code> </pre><br></div></div><br><br><p>  Die Ausführungszeit beider Versionen der Funktionen stimmte überein. Ich brauchte 20 ms, um die Daten in der Ergebnistabelle auszugeben. </p><br><p>  Daher werde ich keine Funktionsversionen mehr produzieren, wie  Wer möchte, kann sie nach seinen Wünschen neu gestalten oder <b>mich kontaktieren. Ich werde eine modifizierte Version kostenlos senden</b> . </p><p>  <b>Siehe auch den</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vierten</a> Teil des Artikels. </p><br><a name="Script2"></a><br><h2>  ANHANG 1. Skripte </h2><br><a name="tfTableC"></a><br><h3>  Erstellen der Funktion admtf_Table_Constraintes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare zum Funktionsquellcode finden Sie hier.</a> <br><div class="spoiler">  <b class="spoiler_title">Funktionsquellcode</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_ConstraintName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_RefTableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_RefTableKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_ConstraintSource <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_Scale <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintRec RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_ConstraintName name; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintType name; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_isUnique BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_isPrimary BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*      Primary KEY */</span></span> v_AttributeNum INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_AttributeName name; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_ConstraintKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_RefTableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID ,     */</span></span> v_RefTableName name;<span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> v_RefTableKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_RefTableKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     ,    */</span></span> v_ConstraintSource TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     CHECK*/</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN FOR v_ConstraintRec IN SELECT con.oid AS ConstraintOID ,tbl.OID AS TableOID, con.conname AS ConstraintName, con.contype AS ConstraintType, con.conkey AS ConstraintKeyNos, reftbl.OID AS RefTableOID, reftbl.relname AS RefTableName, con.confkey AS RefTableKeyNos, con.consrc AS ConstraintSource FROM pg_constraint con INNER JOIN pg_class tbl ON con.conrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid LEFT OUTER JOIN pg_class reftbl ON con.confrelid=reftbl.oid WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) ORDER BY con.contype DESC,con.conname LOOP v_ConstraintOID:=v_ConstraintRec.ConstraintOID; v_TableOID:=v_ConstraintRec.TableOID; v_ConstraintName:=v_ConstraintRec.ConstraintName; v_ConstraintType:=v_ConstraintRec.ConstraintType; v_ConstraintKeyNos:=v_ConstraintRec.ConstraintKeyNos; v_RefTableOID:=v_ConstraintRec.RefTableOID; v_RefTableName:=v_ConstraintRec.RefTableName; v_RefTableKeyNos:=v_ConstraintRec.RefTableKeyNos; v_ConstraintSource:=v_ConstraintRec.ConstraintSource; v_ConstraintKeyNames:=''; FOREACH v_AttributeNum IN ARRAY v_ConstraintKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_TableOID AND attr.attnum=v_AttributeNum; v_ConstraintKeyNames:=v_ConstraintKeyNames|| CASE WHEN v_ConstraintKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; v_RefTableKeyNames:=''; IF v_RefTableKeyNos IS NOT NULL THEN FOREACH v_AttributeNum IN ARRAY v_RefTableKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_RefTableOID AND attr.attnum=v_AttributeNum; v_RefTableKeyNames:=v_RefTableKeyNames|| CASE WHEN v_RefTableKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; END IF; RETURN QUERY SELECT v_ConstraintName,v_ConstraintType,v_ConstraintKeyNames, v_RefTableName,v_RefTableKeyNames, v_ConstraintSource; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Constraintes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Constraintes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_ConstraintName VARCHAR(256),r_ConstraintType VARCHAR(256),r_ConstraintKeyNames Text,r_RefTableName VARCHAR(256),r_RefTableKeyNames Text,r_ConstraintSource Text) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT tc.r_ConstraintName::VARCHAR(256), tc.r_ConstraintType::VARCHAR(256),tc.r_ConstraintKeyNames::TEXT, tc.r_RefTableName::VARCHAR(256),tc.r_RefTableKeyNames::TEXT, tc.r_ConstraintSource::TEXT FROM admtf_Table_Constraintes(a_SchemaName::NAME,a_TableName::NAME) tc; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Constraintes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Constraintes('public'::name,'Street'::name);</span></span></code> </pre><br></div></div><br><a name="tfTableC_woc"></a><br><h3>  Erstellen einer Version von admtf_Table_Constraintes ohne Cursor </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare zum Funktionsquellcode finden Sie hier.</a> <br><div class="spoiler">  <b class="spoiler_title">Funktionsquellcode</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_ConstraintName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_RefTableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_RefTableKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_ConstraintSource <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_Scale <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintRec RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_ConstraintName name; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintType name; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_isUnique BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_isPrimary BOOLEAN;<span class="hljs-comment"><span class="hljs-comment">/*      Primary KEY */</span></span> v_AttributeNum INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_AttributeName name; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_ConstraintKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_RefTableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID ,     */</span></span> v_RefTableName name;<span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> v_RefTableKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_RefTableKeyNames TEXT;<span class="hljs-comment"><span class="hljs-comment">/*     ,    */</span></span> v_ConstraintSource TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     CHECK*/</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN FOR v_ConstraintRec IN SELECT con.oid AS ConstraintOID , tbl.OID AS TableOID, con.conname AS ConstraintName, con.contype AS ConstraintType, con.conkey AS ConstraintKeyNos, reftbl.OID AS RefTableOID, reftbl.relname AS RefTableName, con.confkey AS RefTableKeyNos, con.consrc AS ConstraintSource FROM pg_constraint con INNER JOIN pg_class tbl ON con.conrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid LEFT OUTER JOIN pg_class reftbl ON con.confrelid=reftbl.oid WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) ORDER BY con.contype DESC,con.conname LOOP v_ConstraintOID:=v_ConstraintRec.ConstraintOID; v_TableOID:=v_ConstraintRec.TableOID; v_ConstraintName:=v_ConstraintRec.ConstraintName; v_ConstraintType:=v_ConstraintRec.ConstraintType; v_ConstraintKeyNos:=v_ConstraintRec.ConstraintKeyNos; v_RefTableOID:=v_ConstraintRec.RefTableOID; v_RefTableName:=v_ConstraintRec.RefTableName; v_RefTableKeyNos:=v_ConstraintRec.RefTableKeyNos; v_ConstraintSource:=v_ConstraintRec.ConstraintSource; v_ConstraintKeyNames:=''; FOREACH v_AttributeNum IN ARRAY v_ConstraintKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_TableOID AND attr.attnum=v_AttributeNum; v_ConstraintKeyNames:=v_ConstraintKeyNames|| CASE WHEN v_ConstraintKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; v_RefTableKeyNames:=''; IF v_RefTableKeyNos IS NOT NULL THEN FOREACH v_AttributeNum IN ARRAY v_RefTableKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_RefTableOID AND attr.attnum=v_AttributeNum; v_RefTableKeyNames:=v_RefTableKeyNames|| CASE WHEN v_RefTableKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; END IF; RETURN QUERY SELECT v_ConstraintName,v_ConstraintType,v_ConstraintKeyNames, v_RefTableName,v_RefTableKeyNames, v_ConstraintSource; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Constraintes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Constraintes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_ConstraintName VARCHAR(256),r_ConstraintType VARCHAR(256),r_ConstraintKeyNames Text,r_RefTableName VARCHAR(256),r_RefTableKeyNames Text,r_ConstraintSource Text) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT tc.r_ConstraintName::VARCHAR(256), tc.r_ConstraintType::VARCHAR(256), tc.r_ConstraintKeyNames::TEXT, tc.r_RefTableName::VARCHAR(256), tc.r_RefTableKeyNames::TEXT, tc.r_ConstraintSource::TEXT FROM admtf_Table_Constraintes(a_SchemaName::NAME,a_TableName::NAME) tc; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Constraintes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Constraintes('public'::name,'Street'::name);</span></span></code> </pre><br></div></div><br><a name="tfTableI"></a><br><h3>  Erstellen der Funktion admtf_Table_Indexes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare zum Funktionsquellcode finden Sie hier.</a> <br><div class="spoiler">  <b class="spoiler_title">Funktionsquellcode</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_IndexName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_IndexType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isUnique <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,r_isPrimary <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_IndexKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_IndexKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'i'</span></span>; v_IndexRec RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_Scale INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_IndexOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_IndexKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_IndexName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_IndexAMName NAME; <span class="hljs-comment"><span class="hljs-comment">/*    ( ) */</span></span> v_isUnique BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_isPrimary BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*      Primary KEY */</span></span> v_AttributeNum INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_AttributeName NAME; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_IndexKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN FOR v_IndexRec IN SELECT inxcls.oid AS IndexOID,tbl.oid AS TableOID, inxcls.relname AS IndexName,inxam.amname AS IndexAMName, inx.indisunique AS isUnique,inx.indisprimary isPrimary, inx.indkey::SMALLINT[] AS IndexKeyNos FROM pg_index inx INNER JOIN pg_class inxcls ON inx.indexrelid=inxcls.oid INNER JOIN pg_am inxam ON inxcls.relam=inxam.oid INNER JOIN pg_class tbl ON inx.indrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND inxcls.relkind=c_IndexKind AND tbl.relname=LOWER(a_TableName) ORDER BY inxam.amname, inxcls.relname LOOP v_IndexOID:=v_IndexRec.IndexOID; v_TableOID:=v_IndexRec.TableOID; v_IndexName:=v_IndexRec.IndexName; v_IndexAMName:=v_IndexRec.IndexAMName; v_isUnique:=v_IndexRec.isUnique; v_isPrimary:=v_IndexRec.isPrimary; v_IndexKeyNos:=v_IndexRec.IndexKeyNos; v_IndexKeyNames:=''; FOREACH v_AttributeNum IN ARRAY v_IndexKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_TableOID AND attr.attnum=v_AttributeNum; v_IndexKeyNames:=v_IndexKeyNames|| CASE WHEN v_IndexKeyNames='' THEN '' ELSE c_Delimiter||' ' END || v_AttributeName; END LOOP; RETURN QUERY SELECT v_IndexName,v_IndexAMName,v_isUnique, v_isPrimary,v_IndexKeyNames; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Indexes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Indexes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_IndexName VARCHAR(256),r_IndexType VARCHAR(256),r_isUnique BOOLEAN,r_isPrimary BOOLEAN, r_IndexKeyNames TEXT) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT ti.r_IndexName::VARCHAR(256), ti.r_IndexType::VARCHAR(256), ti.r_isUnique::BOOLEAN, ti.r_isPrimary::BOOLEAN, ti.r_IndexKeyNames::TEXT FROM admtf_Table_Indexes(a_SchemaName::NAME,a_TableName::NAME) ti; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Indexes('public'::NAME,'Street'::NAME); SELECT * FROM admtf_Table_Indexes('public'::VARCHAR(256),'Street'::VARCHAR(256));</span></span></code> </pre><br></div></div><br><a name="tfTableI_woc"></a><br><h3>  Erstellen einer Version von admtf_Table_Indexes ohne Cursor </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_IndexName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_IndexType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isUnique <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,r_isPrimary <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_IndexKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_IndexKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'i'</span></span>; c_Delimiter CONSTANT VARCHAR(2):=', '; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN RETURN QUERY SELECT inxcls.relname AS r_IndexName, inxam.amname AS r_IndexType, inx.indisunique AS r_isUnique, inx.indisprimary r_isPrimary, STRING_AGG(attr.attname||CASE inxam.amcanorder WHEN true THEN CASE inx.indoption[inx.No] &amp; 1 WHEN 1 THEN ' DESC' ELSE ' ASC' END ELSE '' END, c_Delimiter ORDER BY inx.No) FROM (SELECT i.indrelid, i.indexrelid,i.indisunique, i.indisprimary,i.indkey::SMALLINT[], i.indoption::SMALLINT[], generate_subscripts(i.indkey, 1) as No FROM pg_index i) inx INNER JOIN pg_class inxcls ON inx.indexrelid=inxcls.oid INNER JOIN pg_am inxam ON inxcls.relam=inxam.oid INNER JOIN pg_class tbl ON inx.indrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid INNER JOIN pg_attribute attr ON attr.attrelid=tbl.OID AND attr.attnum=inx.indkey[inx.No] WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND inxcls.relkind=c_IndexKind AND tbl.relname=LOWER(a_TableName) GROUP BY inxcls.relname,inxam.amname,inx.indisunique,inx.indisprimary ORDER BY inxcls.relname; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Indexes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Indexes (a_SchemaName VARCHAR(256) default 'public', /*    */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_IndexName VARCHAR(256),r_IndexType VARCHAR(256),r_isUnique BOOLEAN,r_isPrimary BOOLEAN, r_IndexKeyNames TEXT) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT ti.r_IndexName::VARCHAR(256), ti.r_IndexType::VARCHAR(256), ti.r_isUnique::BOOLEAN, ti.r_isPrimary::BOOLEAN, ti.r_IndexKeyNames::TEXT FROM admtf_Table_Indexes(a_SchemaName::NAME,a_TableName::NAME) ti; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Indexes('public'::NAME,'Street'::NAME); SELECT * FROM admtf_Table_Indexes('public'::VARCHAR(256),'Street'::VARCHAR(256));</span></span></code> </pre><br></div></div><br><h3>  Siehe auch </h3><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     PostgreSQL.  </a> ;</b> <br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     PostgreSQL.  </a> .</b> <br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     PostgreSQL. ( )</a> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415897/">https://habr.com/ru/post/de415897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415881/index.html">Funktionsweise von JS: Shadow DOM-Technologie und Webkomponenten</a></li>
<li><a href="../de415887/index.html">Welche Art von Spinnenrobotern fliegen über Stadien und schießen Fußball. Interview mit dem Schöpfer von Robycam</a></li>
<li><a href="../de415891/index.html">Was sind die coolen Fortsetzungsspiele?</a></li>
<li><a href="../de415893/index.html">So machen Sie Java-Prozesse unter Linux / Docker einfach und unkompliziert</a></li>
<li><a href="../de415895/index.html">Das wichtigste Muster in der Programmierung</a></li>
<li><a href="../de415899/index.html">Office 365 Outlook hat undokumentierte APIs mit detaillierten Benutzeraktivitätsprotokollen gefunden</a></li>
<li><a href="../de415901/index.html">Die Kommission des Föderationsrates unterstützte die Idee, eine IMEI-Basis für alle weißen Telefone zu schaffen</a></li>
<li><a href="../de415903/index.html">Willkommen zum Sommer-DIYorDIE-Meetup am 7. Juli</a></li>
<li><a href="../de415905/index.html">Wie man ein gesundes Produkt anbaut (Juno-Beispiel)</a></li>
<li><a href="../de415907/index.html">Wie man Mitarbeiter entlässt, ohne das Image des Unternehmens zu gefährden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>