<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¢ üè£ üêÜ Optimizaci√≥n del trabajo con prototipos en motores JavaScript. üìï üëä üòü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya traducci√≥n publicamos hoy, fue preparado por Matthias Binens y Benedict Meirer. Est√°n trabajando en el motor V8 JS en Google. Este a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimizaci√≥n del trabajo con prototipos en motores JavaScript.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  El material, cuya traducci√≥n publicamos hoy, fue preparado por Matthias Binens y Benedict Meirer.  Est√°n trabajando en el motor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V8</a> JS en Google.  Este art√≠culo est√° dedicado a algunos mecanismos b√°sicos que son caracter√≠sticos no solo para V8, sino tambi√©n para otros motores.  La familiaridad con la estructura interna de dichos mecanismos permite a los involucrados en el desarrollo de JavaScript navegar mejor por los problemas de rendimiento del c√≥digo.  En particular, aqu√≠ hablaremos sobre las caracter√≠sticas de las tuber√≠as de optimizaci√≥n del motor y c√≥mo acelerar el acceso a las propiedades de los prototipos de objetos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Niveles de optimizaci√≥n de c√≥digo y compensaciones</font> </h2><br>  El proceso de convertir los textos de programas escritos en JavaScript en c√≥digo adecuado para la ejecuci√≥n se ve aproximadamente igual en diferentes motores. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">El proceso de convertir el c√≥digo fuente JS en c√≥digo ejecutable</font></i> <br><br>  Los detalles se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  Adem√°s, debe tenerse en cuenta que aunque, en un nivel alto, las canalizaciones para convertir el c√≥digo fuente en ejecutable son muy similares para diferentes motores, sus sistemas de optimizaci√≥n de c√≥digo a menudo difieren.  ¬øPor qu√© es esto as√≠?  ¬øPor qu√© algunos motores tienen m√°s niveles de optimizaci√≥n que otros?  Resulta que los motores tienen que comprometerse de una forma u otra, lo que consiste en el hecho de que pueden generar r√°pidamente c√≥digo que no es el m√°s eficiente pero adecuado para la ejecuci√≥n, o pasar m√°s tiempo creando dicho c√≥digo, pero debido a esto, lograr un rendimiento √≥ptimo <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Preparaci√≥n r√°pida de c√≥digo para ejecuci√≥n y c√≥digo optimizado que lleva m√°s tiempo pero se ejecuta m√°s r√°pido</font></i> <br><br>  El int√©rprete puede generar r√°pidamente un c√≥digo de bytes, pero dicho c√≥digo generalmente no es muy eficiente.  El compilador de optimizaci√≥n, por otro lado, necesita m√°s tiempo para generar el c√≥digo, pero al final se optimiza, el c√≥digo de m√°quina m√°s r√°pido. <br><br>  Es este modelo de preparaci√≥n de c√≥digo para ejecuci√≥n que se utiliza en V8.  El int√©rprete V8 se llama Ignition, es el m√°s r√°pido de los int√©rpretes existentes (en t√©rminos de ejecuci√≥n del c√≥digo de bytes de origen).  El compilador de optimizaci√≥n V8 se llama TurboFan, que es responsable de crear un c√≥digo de m√°quina altamente optimizado. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Int√©rprete de encendido y compilador de optimizaci√≥n TurboFan</font></i> <br><br>  La compensaci√≥n entre el retraso en el inicio del programa y la velocidad de ejecuci√≥n es la raz√≥n por la que algunos motores JS tienen niveles adicionales de optimizaci√≥n.  Por ejemplo, en SpiderMonkey, entre el int√©rprete y el compilador de optimizaci√≥n IonMonkey, hay un nivel intermedio representado por el compilador b√°sico (se llama "The Baseline Compiler" en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de</a> Mozilla, pero "baseline" no es un nombre propio). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">Niveles de optimizaci√≥n del c√≥digo SpiderMonkey</font></i> <br><br>  El int√©rprete genera r√°pidamente el c√≥digo de bytes, pero dicho c√≥digo se ejecuta con relativa lentitud.  El compilador base tarda m√°s en generar el c√≥digo, pero este c√≥digo ya es m√°s r√°pido.  Finalmente, el compilador de optimizaci√≥n de IonMonkey toma m√°s tiempo para generar c√≥digo de m√°quina, pero este c√≥digo puede ejecutarse de manera muy eficiente. <br><br>  Echemos un vistazo a un ejemplo espec√≠fico y veamos c√≥mo las tuber√≠as de varios motores manejan el c√≥digo.  En el ejemplo presentado aqu√≠, hay un bucle "activo" que contiene c√≥digo que se repite tantas veces. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 comienza a ejecutar bytecode en el int√©rprete de encendido.  En alg√∫n momento, el motor descubre que el c√≥digo est√° "activo" y lanza la interfaz de TurboFan, que es parte de TurboFan que trabaja con datos de creaci√≥n de perfiles y crea una representaci√≥n de m√°quina b√°sica del c√≥digo.  Luego, los datos se pasan al optimizador TurboFan, que opera en una secuencia separada, para mejoras adicionales. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Optimizaci√≥n de c√≥digo activo en V8</font></i> <br><br>  Durante la optimizaci√≥n, V8 contin√∫a ejecutando bytecode en Ignition.  Cuando se completa el optimizador, tenemos un c√≥digo de m√°quina ejecutable que puede usarse en el futuro. <br><br>  El motor SpiderMonkey tambi√©n comienza a ejecutar bytecode en el int√©rprete.  Pero tiene un nivel adicional representado por el compilador b√°sico, lo que lleva al hecho de que el c√≥digo "activo" primero llega a este compilador.  Genera el c√≥digo base en el hilo principal, la transici√≥n a la ejecuci√≥n de este c√≥digo se realiza cuando est√° listo. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Optimizaci√≥n de c√≥digo activo en SpiderMonkey</font></i> <br><br>  Si el c√≥digo base se ejecuta el tiempo suficiente, SpiderMonkey finalmente lanza la interfaz y el optimizador IonMonkey, que es muy similar a lo que sucede en V8.  El c√≥digo base contin√∫a ejecut√°ndose como parte del proceso de optimizaci√≥n de c√≥digo realizado por IonMonkey.  Como resultado, cuando se completa la optimizaci√≥n, se ejecuta el c√≥digo optimizado en lugar del c√≥digo base. <br><br>  La arquitectura del motor Chakra es muy similar a la arquitectura de SpiderMonkey, pero Chakra se esfuerza por lograr un mayor nivel de concurrencia para evitar bloquear el hilo principal.  En lugar de resolver cualquier tarea de compilaci√≥n en el hilo principal, Chakra copia y env√≠a el bytecode y los datos de perfil que el compilador probablemente necesitar√° en un proceso de compilaci√≥n separado. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Optimizaci√≥n de c√≥digo activo en Chakra</font></i> <br><br>  Cuando el c√≥digo generado preparado por SimpleJIT est√° listo, el motor lo ejecutar√° en lugar de bytecode.  Este proceso se repite para continuar con la ejecuci√≥n del c√≥digo preparado por FullJIT.  La ventaja de este enfoque es que las pausas asociadas con la copia de datos suelen ser mucho m√°s cortas que las causadas por la operaci√≥n de un compilador completo (front-end).  Sin embargo, la desventaja de este enfoque es el hecho de que los algoritmos de copia heur√≠stica pueden perder informaci√≥n que puede ser √∫til para alg√∫n tipo de optimizaci√≥n.  Aqu√≠ vemos un ejemplo de compromiso entre la calidad del c√≥digo recibido y los retrasos. <br><br>  En JavaScriptCore, todas las tareas de compilaci√≥n de optimizaci√≥n se realizan en paralelo con el hilo principal responsable de ejecutar el c√≥digo JavaScript.  Sin embargo, no hay etapa de copia.  En cambio, el hilo principal simplemente invoca tareas de compilaci√≥n en otro hilo.  El compilador luego usa un complejo esquema de bloqueo para acceder a los datos de creaci√≥n de perfiles desde el hilo principal. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimizaci√≥n del c√≥digo "hot" en JavaScriptCore</font></i> <br><br>  La ventaja de este enfoque es que reduce el bloqueo forzado del hilo principal causado por el hecho de que realiza tareas de optimizaci√≥n de c√≥digo.  Las desventajas de esta arquitectura son que su implementaci√≥n requiere la soluci√≥n de tareas complejas de procesamiento de datos multiproceso, y que en el curso del trabajo, para realizar varias operaciones, uno tiene que recurrir a las cerraduras. <br><br>  Acabamos de discutir las compensaciones que los motores se ven obligados a hacer, eligiendo entre la generaci√≥n r√°pida de c√≥digos con int√©rpretes y la creaci√≥n de c√≥digos r√°pidos con compiladores optimizadores.  Sin embargo, estos est√°n lejos de todos los problemas que enfrentan los motores.  La memoria es otro recurso del sistema cuando se utiliza y debe recurrir a soluciones de compromiso.  Para demostrar esto, considere un programa JS simple que agregue n√∫meros. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Aqu√≠ est√° el c√≥digo de bytes de la funci√≥n de <code>add</code> generada por el int√©rprete de encendido en V8: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  No puede entrar en el significado de este c√≥digo de bytes, de hecho, su contenido no es de particular inter√©s para nosotros.  Lo principal aqu√≠ es que solo tiene cuatro instrucciones. <br><br>  Cuando un c√≥digo de este tipo est√° "activo", se utiliza TurboFan, que genera el siguiente c√≥digo de m√°quina altamente optimizado: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Como puede ver, el volumen de c√≥digo, en comparaci√≥n con el ejemplo anterior de cuatro instrucciones, es muy grande.  Normalmente, el c√≥digo de bytes es mucho m√°s compacto que el c√≥digo de m√°quina, y en particular el c√≥digo de m√°quina optimizado.  Por otro lado, se necesita un int√©rprete para ejecutar bytecode, y el c√≥digo optimizado se puede ejecutar directamente en el procesador. <br>  Esta es una de las razones principales por las que los motores de JavaScript no optimizan absolutamente todo el c√≥digo.  Como vimos anteriormente, la creaci√≥n de c√≥digo de m√°quina optimizado lleva mucho tiempo y, adem√°s, como acabamos de descubrir, se necesita m√°s memoria para almacenar el c√≥digo de m√°quina optimizado. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Uso de memoria y nivel de optimizaci√≥n</font></i> <br><br>  Como resultado, podemos decir que la raz√≥n por la cual los motores JS tienen diferentes niveles de optimizaci√≥n es el problema fundamental de elegir entre la generaci√≥n r√°pida de c√≥digo, por ejemplo, usando un int√©rprete, y la generaci√≥n r√°pida de c√≥digo, que se ejecuta mediante el compilador de optimizaci√≥n.  Si hablamos de los niveles de optimizaci√≥n de c√≥digo utilizados en los motores, cuantos m√°s haya, m√°s optimizaciones sutiles puede sufrir el c√≥digo, pero esto se logra debido a la complejidad de los motores y a la carga adicional en el sistema.  Adem√°s, aqu√≠ no debemos olvidar que el nivel de optimizaci√≥n del c√≥digo afecta la cantidad de memoria que ocupa este c√≥digo.  Es por eso que los motores JS intentan optimizar solo las funciones "activas". <br><br><h2>  <font color="#3AC1EF">Optimizaci√≥n del acceso a las propiedades del prototipo de objeto.</font> </h2><br>  Los motores de JavaScript optimizan el acceso a las propiedades de los objetos mediante el uso de los llamados formularios de objetos (Shape) y cach√©s en l√≠nea (Cach√© en l√≠nea, IC).  Los detalles sobre esto se pueden leer en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material, pero para resumirlo, podemos decir que el motor almacena la forma del objeto por separado de los valores del objeto. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objetos que tienen la misma forma.</font></i> <br><br>  El uso de formas de objetos permite realizar una optimizaci√≥n llamada almacenamiento en cach√© en l√≠nea.  El uso conjunto de formularios de objetos y cach√©s en l√≠nea le permite acelerar las operaciones repetidas de acceso a las propiedades de los objetos, realizadas desde el mismo lugar en el c√≥digo. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Acelerar el acceso a una propiedad de objeto</font></i> <br><br><h2>  <font color="#3AC1EF">Clases y Prototipos</font> </h2><br>  Ahora que sabemos c√≥mo acelerar el acceso a las propiedades de los objetos en JavaScript, eche un vistazo a una de las innovaciones recientes de JavaScript: las clases.  As√≠ es como se ve la declaraci√≥n de clase: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Aunque puede parecer la aparici√≥n en JS de un concepto completamente nuevo, las clases son en realidad solo az√∫car sint√°ctica para el sistema prototipo para construir objetos, que siempre ha estado presente en JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Aqu√≠ escribimos la funci√≥n en la propiedad <code>getX</code> objeto <code>getX</code> .  Esta operaci√≥n funciona exactamente de la misma manera que cuando se crean las propiedades de cualquier otro objeto, ya que los prototipos en JavaScript son objetos.  En los lenguajes basados ‚Äã‚Äãen el uso de prototipos, como JavaScript, los m√©todos que pueden compartir todos los objetos de cierto tipo se almacenan en prototipos, y los campos de los objetos individuales se almacenan en sus instancias. <br><br>  Veamos qu√© sucede, por as√≠ decirlo, detr√°s de escena cuando creamos una nueva instancia del objeto <code>Bar</code> , asign√°ndola al <code>foo</code> constante. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Despu√©s de ejecutar dicho c√≥digo, la instancia del objeto creado aqu√≠ tendr√° un formulario que contiene una sola propiedad <code>x</code> .  El prototipo del objeto <code>foo</code> es <code>Bar.prototype</code> , que pertenece a la clase <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Objeto y su prototipo</font></i> <br><br>  <code>Bar.prototype</code> tiene su propia forma que contiene una sola propiedad <code>getX</code> cuyo valor es una funci√≥n que, cuando se llama, devuelve el valor de <code>this.x</code>  El prototipo prototipo <code>Bar.prototype</code> es <code>Object.prototype</code> , que forma parte del lenguaje.  <code>Object.prototype</code> es el elemento ra√≠z del √°rbol prototipo, por lo que su prototipo es <code>null</code> . <br><br>  Ahora veamos qu√© sucede si crea otro objeto de tipo <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Varios objetos del mismo tipo.</font></i> <br><br>  Como puede ver, tanto el objeto <code>foo</code> como el objeto <code>qux</code> , que son instancias de la clase <code>Bar</code> , como ya hemos dicho, usan la misma forma del objeto.  Ambos usan el mismo prototipo: el objeto <code>Bar.prototype</code> . <br><br><h2>  <font color="#3AC1EF">Acceder a las propiedades del prototipo</font> </h2><br>  Entonces, ahora sabemos lo que sucede cuando declaramos una nueva clase y la instanciamos.  ¬øY qu√© hay de la llamada al m√©todo del objeto?  Considere el siguiente fragmento de c√≥digo: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Una llamada al m√©todo puede entenderse como una operaci√≥n que consta de dos pasos: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  En el primer paso, se carga el m√©todo, que es solo una propiedad del prototipo (cuyo valor es la funci√≥n).  En el segundo paso, se llama a una funci√≥n con <code>this</code> conjunto.  Considere el primer paso para cargar el m√©todo <code>getX</code> desde el objeto <code>foo</code> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Cargando el m√©todo getX desde el objeto foo</font></i> <br><br>  El motor analiza el objeto <code>foo</code> y descubre que no hay propiedad <code>getX</code> en la forma del objeto <code>foo</code> .  Esto significa que el motor necesita mirar la cadena de prototipos del objeto para encontrar este m√©todo.  El motor accede al prototipo <code>Bar.prototype</code> y observa la forma del objeto de este prototipo.  All√≠, encuentra la propiedad deseada en el desplazamiento 0. A continuaci√≥n, <code>Bar.prototype</code> al valor almacenado en este desplazamiento en <code>Bar.prototype</code> , se detecta <code>JSFunction</code> <code>getX</code> all√≠, y esto es exactamente lo que estamos buscando.  Esto completa la b√∫squeda del m√©todo. <br><br>  La flexibilidad de JavaScript hace posible cambiar las cadenas de prototipos.  Por ejemplo, as√≠: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  En este ejemplo, llamamos al m√©todo <code>foo.getX()</code> dos veces, pero cada una de estas llamadas tiene un significado y un resultado completamente diferentes.  Es por eso que, aunque los prototipos de JavaScript son solo objetos, acelerar el acceso a las propiedades de los prototipos es a√∫n m√°s dif√≠cil para los motores JS que acelerar el acceso a sus propias propiedades de los objetos ordinarios. <br><br>  Si observamos los programas de la vida real, resulta que cargar las propiedades del prototipo es una operaci√≥n muy com√∫n.  Se ejecuta cada vez que se llama a un m√©todo. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Anteriormente, hablamos sobre c√≥mo los motores optimizan la carga de propiedades regulares y personalizadas de objetos mediante el uso de formularios de objetos y cach√©s en l√≠nea.  ¬øC√≥mo optimizar la carga de propiedades de prototipo repetidas para objetos con la misma forma?  Arriba, vimos c√≥mo se cargan las propiedades. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Cargando el m√©todo getX desde el objeto foo</font></i> <br><br>  Para acelerar el acceso al m√©todo con llamadas repetidas, en nuestro caso, necesita saber lo siguiente: <br><br><ol><li>  La forma del objeto <code>foo</code> no contiene el m√©todo <code>getX</code> y no cambia.  Esto significa que el objeto <code>foo</code> no se modifica al agregarle propiedades o eliminarlo o cambiar los atributos de las propiedades. </li><li>  El prototipo <code>foo</code> sigue siendo el prototipo original de <code>Bar.prototype</code> .  Esto significa que el prototipo <code>foo</code> no cambia utilizando el m√©todo <code>Object.setPrototypeOf()</code> o asignando un nuevo prototipo a la propiedad especial <code>_proto_</code> . </li><li>  El formulario <code>Bar.prototype</code> contiene <code>getX</code> y no cambia.  Es decir, <code>Bar.prototype</code> no cambia al eliminar propiedades, agregarlas o cambiar sus atributos. </li></ol><br>  En el caso general, esto significa que necesitamos hacer 1 comprobaci√≥n del objeto en s√≠ y 2 comprobaciones para cada prototipo hasta el prototipo que almacena la propiedad que estamos buscando.  Es decir, debe realizar verificaciones 1 + 2N (donde N es el n√∫mero de prototipos probados), que en este caso no se ve tan mal, ya que la cadena de prototipos es bastante corta.  Sin embargo, los motores a menudo tienen que trabajar con cadenas de prototipos mucho m√°s largas.  Esto, por ejemplo, es t√≠pico de los elementos DOM ordinarios.  Aqu√≠ hay un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Aqu√≠ tenemos <code>HTMLAnchorElement</code> y llamamos a su m√©todo <code>getAttribute()</code> .  ¬°La cadena de prototipos de este elemento simple que representa un enlace HTML incluye 6 prototipos!  Los m√©todos DOM m√°s interesantes no est√°n en su propio prototipo <code>HTMLAnchorElement</code> .  Est√°n en prototipos ubicados m√°s abajo en la cadena. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Cadena prototipo</font></i> <br><br>  El m√©todo <code>getAttribute()</code> se puede encontrar en <code>Element.prototype</code> .  Esto significa que cada vez que se <code>anchor.getAttribute()</code> m√©todo <code>anchor.getAttribute()</code> , el motor se ve obligado a realizar las siguientes acciones: <br><br><ol><li>  Comprueba el objeto de <code>anchor</code> s√≠ para <code>getAttribute</code> . </li><li>  Verificar que el prototipo directo del objeto es <code>HTMLAnchorElement.prototype</code> . </li><li>  Descubrir que <code>HTMLAnchorElement.prototype</code> no tiene un m√©todo <code>getAttribute</code> . </li><li>  Verificar que el pr√≥ximo prototipo sea <code>HTMLElement.prototype</code> . </li><li>  Descubrir que no hay un m√©todo necesario aqu√≠. </li><li>  Finalmente, descubriendo que el pr√≥ximo prototipo es <code>Element.prototype</code> . </li><li>  Descubrir que hay un m√©todo <code>getAttribute</code> . </li></ol><br>  Como puede ver, aqu√≠ se realizan 7 comprobaciones.  Dado que dicho c√≥digo es muy com√∫n en la programaci√≥n web, los motores utilizan optimizaciones para reducir la cantidad de comprobaciones necesarias para cargar las propiedades del prototipo. <br><br>  Si volvemos a uno de los ejemplos anteriores, podemos recordar que cuando llamamos al m√©todo <code>getX</code> del objeto <code>getX</code> , realizamos 3 comprobaciones: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Para cada objeto que est√° en la cadena del prototipo, hasta el que contiene la propiedad deseada, necesitamos verificar la forma del objeto solo para descubrir la ausencia de lo que estamos buscando.  Ser√≠a bueno si pudi√©ramos reducir el n√∫mero de controles reduciendo el control del prototipo a verificar la presencia o ausencia de lo que estamos buscando.  Esto es lo que hace el motor con un simple movimiento: en lugar de almacenar el enlace prototipo en la propia instancia, el motor lo almacena en forma de un objeto. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Prototipo de almacenamiento de referencia</font></i> <br><br>  Cada formulario tiene un enlace a un prototipo.  Esto tambi√©n significa que cada vez que el prototipo cambia, el motor se mueve a la nueva forma del objeto.  Ahora solo tenemos que verificar la forma del objeto para detectar la presencia de una propiedad en √©l y cuidar de proteger el enlace prototipo. <br><br>  Gracias a este enfoque, podemos reducir el n√∫mero de comprobaciones de 1 + 2N a 1 + N, lo que acelerar√° el acceso a las propiedades de los prototipos.  Sin embargo, tales operaciones a√∫n requieren muchos recursos, ya que existe una relaci√≥n lineal entre su n√∫mero y la longitud de la cadena del prototipo.  Los motores han implementado varios mecanismos destinados a garantizar que el n√∫mero de comprobaciones no dependa de la longitud de la cadena del prototipo, expresado como una constante.  Esto es especialmente cierto en situaciones donde la carga de la misma propiedad se realiza varias veces. <br><br><h2>  <font color="#3AC1EF">Propiedad ValidityCell</font> </h2><br>  V8 se refiere a las formas de prototipos espec√≠ficamente para el prop√≥sito anterior.  Cada prototipo tiene una forma √∫nica que no se comparte con otros objetos (en particular, con otros prototipos), y cada uno de los formularios de objetos prototipo tiene una propiedad <code>ValidityCell</code> asociada a ellos. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">Propiedad ValidityCell</font></i> <br><br>  Esta propiedad se declara inv√°lida cuando se cambia el prototipo asociado con el formulario o cualquier prototipo superpuesto.  Considere este mecanismo con m√°s detalle. <br><br>  Para acelerar las operaciones secuenciales de las propiedades de carga de los prototipos, V8 utiliza un cach√© en l√≠nea que contiene cuatro campos: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Campos de cach√© en l√≠nea</font></i> <br><br>  Durante el "calentamiento" del cach√© en l√≠nea la primera vez que se ejecuta el c√≥digo, V8 recuerda el desplazamiento en el que se encontr√≥ la propiedad en el prototipo, el prototipo en el que se encontr√≥ la propiedad (en este ejemplo, <code>Bar.prototype</code> ), la forma del objeto ( <code>foo</code> en este caso) y, adem√°s, un enlace al par√°metro <code>ValidityCell</code> actual del prototipo inmediato, un enlace que tiene la forma de un objeto (en este caso, tambi√©n es <code>Bar.prototype</code> ). <br><br>  La pr√≥xima vez que acceda al cach√© en l√≠nea, el motor deber√° verificar la forma del objeto y <code>ValidityCell</code> .  Si <code>ValidityCell</code> sigue siendo v√°lido, el motor puede aprovechar directamente el desplazamiento previamente guardado en el prototipo sin realizar operaciones de b√∫squeda adicionales. <br><br>  Cuando el prototipo cambia, se crea un nuevo formulario y la propiedad <code>ValidityCell</code> anterior se declara inv√°lida.  Como resultado, la pr√≥xima vez que intente acceder al cach√© en l√≠nea, no ofrece ning√∫n beneficio, lo que conduce a un bajo rendimiento. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Las consecuencias de cambiar el prototipo</font></i> <br><br>  Si volvemos al ejemplo con el elemento DOM, esto significa que cualquier cambio, por ejemplo, en el prototipo de <code>Object.prototype</code> , conducir√° no solo a invalidar el cach√© en l√≠nea para <code>Object.prototype</code> s√≠, sino tambi√©n para cualquier prototipo ubicado debajo de √©l en la cadena de prototipos. incluidos <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., hasta <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Implicaciones de cambiar Object.prototype</font></i> <br><br>  De hecho, modificar <code>Object.prototype</code> durante la ejecuci√≥n del c√≥digo significa hacer un da√±o grave al rendimiento.  No hagas esto. <br><br>  Estudiamos lo anterior con un ejemplo.  Supongamos que tenemos la clase <code>Bar</code> y la funci√≥n <code>loadX</code> , que llama al m√©todo de los objetos creados a partir de la clase <code>Bar</code> .  Llamamos a la funci√≥n <code>loadX</code> varias veces, pas√°ndole instancias de la misma clase. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  El cach√© en <code>loadX</code> en <code>loadX</code> ahora apunta a <code>Bar.prototype</code> para <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> ‚Äî    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> ‚Äî   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , ¬´  ¬ª,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    ‚Äî   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Estimados lectores!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422321/">https://habr.com/ru/post/es422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422309/index.html">C√≥mo proteger los datos en redes neuronales en la nube: se propone un nuevo m√©todo de cifrado</a></li>
<li><a href="../es422311/index.html">Interesante y utilidad de python. Parte 2</a></li>
<li><a href="../es422315/index.html">C√≥mo sobrevivir a un cazador de insectos: lucha diaria por los ingresos</a></li>
<li><a href="../es422317/index.html">¬øPor qu√© los TPU son tan buenos para el aprendizaje profundo?</a></li>
<li><a href="../es422319/index.html">Por primera vez, el equipo ruso se meti√≥ en el acelerador cient√≠fico m√°s grande IndieBio</a></li>
<li><a href="../es422323/index.html">Hackers: Rusia y China</a></li>
<li><a href="../es422325/index.html">DevDay sobre pruebas: Rel√°jate. Pru√©balo f√°cil</a></li>
<li><a href="../es422327/index.html">Cronograma del proyecto vs Backlog: Batalla sin posibilidades</a></li>
<li><a href="../es422329/index.html">Seguridad de la informaci√≥n de los pagos bancarios sin efectivo. Parte 8 - Modelos de amenaza t√≠picos</a></li>
<li><a href="../es422331/index.html">C√≥mo el contador h√≠brido de autopago aumenta la eficiencia de la tienda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>