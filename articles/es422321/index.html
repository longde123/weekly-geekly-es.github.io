<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😢 🏣 🐆 Optimización del trabajo con prototipos en motores JavaScript. 📕 👊 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya traducción publicamos hoy, fue preparado por Matthias Binens y Benedict Meirer. Están trabajando en el motor V8 JS en Google. Este a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimización del trabajo con prototipos en motores JavaScript.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/422321/">  El material, cuya traducción publicamos hoy, fue preparado por Matthias Binens y Benedict Meirer.  Están trabajando en el motor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V8</a> JS en Google.  Este artículo está dedicado a algunos mecanismos básicos que son característicos no solo para V8, sino también para otros motores.  La familiaridad con la estructura interna de dichos mecanismos permite a los involucrados en el desarrollo de JavaScript navegar mejor por los problemas de rendimiento del código.  En particular, aquí hablaremos sobre las características de las tuberías de optimización del motor y cómo acelerar el acceso a las propiedades de los prototipos de objetos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/za/lq/gg/zalqgg3vwvoc-wprqwob9r0fosq.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Niveles de optimización de código y compensaciones</font> </h2><br>  El proceso de convertir los textos de programas escritos en JavaScript en código adecuado para la ejecución se ve aproximadamente igual en diferentes motores. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/534/0ab/f1e/5340abf1e4b0dfa64f1e2bb294765560.png"></div> <i><font color="#999999">El proceso de convertir el código fuente JS en código ejecutable</font></i> <br><br>  Los detalles se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Además, debe tenerse en cuenta que aunque, en un nivel alto, las canalizaciones para convertir el código fuente en ejecutable son muy similares para diferentes motores, sus sistemas de optimización de código a menudo difieren.  ¿Por qué es esto así?  ¿Por qué algunos motores tienen más niveles de optimización que otros?  Resulta que los motores tienen que comprometerse de una forma u otra, lo que consiste en el hecho de que pueden generar rápidamente código que no es el más eficiente pero adecuado para la ejecución, o pasar más tiempo creando dicho código, pero debido a esto, lograr un rendimiento óptimo <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e35/973/c56e359735f983dae9b32294192bd26d.png"></div>  <i><font color="#999999">Preparación rápida de código para ejecución y código optimizado que lleva más tiempo pero se ejecuta más rápido</font></i> <br><br>  El intérprete puede generar rápidamente un código de bytes, pero dicho código generalmente no es muy eficiente.  El compilador de optimización, por otro lado, necesita más tiempo para generar el código, pero al final se optimiza, el código de máquina más rápido. <br><br>  Es este modelo de preparación de código para ejecución que se utiliza en V8.  El intérprete V8 se llama Ignition, es el más rápido de los intérpretes existentes (en términos de ejecución del código de bytes de origen).  El compilador de optimización V8 se llama TurboFan, que es responsable de crear un código de máquina altamente optimizado. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2b/624/62a/e2b62462a5f2563b27a6c362d031b7f2.png"></div>  <i><font color="#999999">Intérprete de encendido y compilador de optimización TurboFan</font></i> <br><br>  La compensación entre el retraso en el inicio del programa y la velocidad de ejecución es la razón por la que algunos motores JS tienen niveles adicionales de optimización.  Por ejemplo, en SpiderMonkey, entre el intérprete y el compilador de optimización IonMonkey, hay un nivel intermedio representado por el compilador básico (se llama "The Baseline Compiler" en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación de</a> Mozilla, pero "baseline" no es un nombre propio). <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/212/702/0c821270298b4860ab99918d2dd575a3.png"></div>  <i><font color="#999999">Niveles de optimización del código SpiderMonkey</font></i> <br><br>  El intérprete genera rápidamente el código de bytes, pero dicho código se ejecuta con relativa lentitud.  El compilador base tarda más en generar el código, pero este código ya es más rápido.  Finalmente, el compilador de optimización de IonMonkey toma más tiempo para generar código de máquina, pero este código puede ejecutarse de manera muy eficiente. <br><br>  Echemos un vistazo a un ejemplo específico y veamos cómo las tuberías de varios motores manejan el código.  En el ejemplo presentado aquí, hay un bucle "activo" que contiene código que se repite tantas veces. <br><br><pre><code class="hljs matlab">let result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) {    result += <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(result);</code> </pre> <br>  V8 comienza a ejecutar bytecode en el intérprete de encendido.  En algún momento, el motor descubre que el código está "activo" y lanza la interfaz de TurboFan, que es parte de TurboFan que trabaja con datos de creación de perfiles y crea una representación de máquina básica del código.  Luego, los datos se pasan al optimizador TurboFan, que opera en una secuencia separada, para mejoras adicionales. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db3/20b/52a/db320b52a7d116d205dc13004852418c.png"></div>  <i><font color="#999999">Optimización de código activo en V8</font></i> <br><br>  Durante la optimización, V8 continúa ejecutando bytecode en Ignition.  Cuando se completa el optimizador, tenemos un código de máquina ejecutable que puede usarse en el futuro. <br><br>  El motor SpiderMonkey también comienza a ejecutar bytecode en el intérprete.  Pero tiene un nivel adicional representado por el compilador básico, lo que lleva al hecho de que el código "activo" primero llega a este compilador.  Genera el código base en el hilo principal, la transición a la ejecución de este código se realiza cuando está listo. <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/782/299/ef4782299d5b523414d85adc16f79d07.png"></div>  <i><font color="#999999">Optimización de código activo en SpiderMonkey</font></i> <br><br>  Si el código base se ejecuta el tiempo suficiente, SpiderMonkey finalmente lanza la interfaz y el optimizador IonMonkey, que es muy similar a lo que sucede en V8.  El código base continúa ejecutándose como parte del proceso de optimización de código realizado por IonMonkey.  Como resultado, cuando se completa la optimización, se ejecuta el código optimizado en lugar del código base. <br><br>  La arquitectura del motor Chakra es muy similar a la arquitectura de SpiderMonkey, pero Chakra se esfuerza por lograr un mayor nivel de concurrencia para evitar bloquear el hilo principal.  En lugar de resolver cualquier tarea de compilación en el hilo principal, Chakra copia y envía el bytecode y los datos de perfil que el compilador probablemente necesitará en un proceso de compilación separado. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/6f7/5e8/f446f75e844d7be0086fde0237f63b9d.png"></div>  <i><font color="#999999">Optimización de código activo en Chakra</font></i> <br><br>  Cuando el código generado preparado por SimpleJIT está listo, el motor lo ejecutará en lugar de bytecode.  Este proceso se repite para continuar con la ejecución del código preparado por FullJIT.  La ventaja de este enfoque es que las pausas asociadas con la copia de datos suelen ser mucho más cortas que las causadas por la operación de un compilador completo (front-end).  Sin embargo, la desventaja de este enfoque es el hecho de que los algoritmos de copia heurística pueden perder información que puede ser útil para algún tipo de optimización.  Aquí vemos un ejemplo de compromiso entre la calidad del código recibido y los retrasos. <br><br>  En JavaScriptCore, todas las tareas de compilación de optimización se realizan en paralelo con el hilo principal responsable de ejecutar el código JavaScript.  Sin embargo, no hay etapa de copia.  En cambio, el hilo principal simplemente invoca tareas de compilación en otro hilo.  El compilador luego usa un complejo esquema de bloqueo para acceder a los datos de creación de perfiles desde el hilo principal. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f7/0ab/101/2f70ab101c3ea308d1275a44bde4eecd.png"></div>  <i><font color="#999999">Optimización del código "hot" en JavaScriptCore</font></i> <br><br>  La ventaja de este enfoque es que reduce el bloqueo forzado del hilo principal causado por el hecho de que realiza tareas de optimización de código.  Las desventajas de esta arquitectura son que su implementación requiere la solución de tareas complejas de procesamiento de datos multiproceso, y que en el curso del trabajo, para realizar varias operaciones, uno tiene que recurrir a las cerraduras. <br><br>  Acabamos de discutir las compensaciones que los motores se ven obligados a hacer, eligiendo entre la generación rápida de códigos con intérpretes y la creación de códigos rápidos con compiladores optimizadores.  Sin embargo, estos están lejos de todos los problemas que enfrentan los motores.  La memoria es otro recurso del sistema cuando se utiliza y debe recurrir a soluciones de compromiso.  Para demostrar esto, considere un programa JS simple que agregue números. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Aquí está el código de bytes de la función de <code>add</code> generada por el intérprete de encendido en V8: <br><br><pre> <code class="hljs pgsql">StackCheck Ldar a1 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span></code> </pre> <br>  No puede entrar en el significado de este código de bytes, de hecho, su contenido no es de particular interés para nosotros.  Lo principal aquí es que solo tiene cuatro instrucciones. <br><br>  Cuando un código de este tipo está "activo", se utiliza TurboFan, que genera el siguiente código de máquina altamente optimizado: <br><br><pre> <code class="hljs powershell">leaq rcx,[<span class="hljs-type"><span class="hljs-type">rip</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x0</span></span>] movq rcx,[<span class="hljs-type"><span class="hljs-type">rcx</span></span>-<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x37</span></span>] testb [<span class="hljs-type"><span class="hljs-type">rcx</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xf</span></span>],<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[<span class="hljs-type"><span class="hljs-type">r13</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">xe88</span></span>] jna StackOverflow movq rax,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rbx,[<span class="hljs-type"><span class="hljs-type">rbp</span></span>+<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-type"><span class="hljs-type">x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0</span></span>x18</code> </pre> <br>  Como puede ver, el volumen de código, en comparación con el ejemplo anterior de cuatro instrucciones, es muy grande.  Normalmente, el código de bytes es mucho más compacto que el código de máquina, y en particular el código de máquina optimizado.  Por otro lado, se necesita un intérprete para ejecutar bytecode, y el código optimizado se puede ejecutar directamente en el procesador. <br>  Esta es una de las razones principales por las que los motores de JavaScript no optimizan absolutamente todo el código.  Como vimos anteriormente, la creación de código de máquina optimizado lleva mucho tiempo y, además, como acabamos de descubrir, se necesita más memoria para almacenar el código de máquina optimizado. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/c84/e9a/f0bc84e9ac477b1e85eb19f306c99597.png"></div>  <i><font color="#999999">Uso de memoria y nivel de optimización</font></i> <br><br>  Como resultado, podemos decir que la razón por la cual los motores JS tienen diferentes niveles de optimización es el problema fundamental de elegir entre la generación rápida de código, por ejemplo, usando un intérprete, y la generación rápida de código, que se ejecuta mediante el compilador de optimización.  Si hablamos de los niveles de optimización de código utilizados en los motores, cuantos más haya, más optimizaciones sutiles puede sufrir el código, pero esto se logra debido a la complejidad de los motores y a la carga adicional en el sistema.  Además, aquí no debemos olvidar que el nivel de optimización del código afecta la cantidad de memoria que ocupa este código.  Es por eso que los motores JS intentan optimizar solo las funciones "activas". <br><br><h2>  <font color="#3AC1EF">Optimización del acceso a las propiedades del prototipo de objeto.</font> </h2><br>  Los motores de JavaScript optimizan el acceso a las propiedades de los objetos mediante el uso de los llamados formularios de objetos (Shape) y cachés en línea (Caché en línea, IC).  Los detalles sobre esto se pueden leer en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> material, pero para resumirlo, podemos decir que el motor almacena la forma del objeto por separado de los valores del objeto. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c63/861/ba8/c63861ba87ef40cdeea866edefe8b000.png"></div>  <i><font color="#999999">Objetos que tienen la misma forma.</font></i> <br><br>  El uso de formas de objetos permite realizar una optimización llamada almacenamiento en caché en línea.  El uso conjunto de formularios de objetos y cachés en línea le permite acelerar las operaciones repetidas de acceso a las propiedades de los objetos, realizadas desde el mismo lugar en el código. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mr/5n/cn/mr5ncnmioer4qo4o-aiwlqslo_q.png"></div>  <i><font color="#999999">Acelerar el acceso a una propiedad de objeto</font></i> <br><br><h2>  <font color="#3AC1EF">Clases y Prototipos</font> </h2><br>  Ahora que sabemos cómo acelerar el acceso a las propiedades de los objetos en JavaScript, eche un vistazo a una de las innovaciones recientes de JavaScript: las clases.  Así es como se ve la declaración de clase: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x;   }   getX() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x;   } }</code> </pre> <br>  Aunque puede parecer la aparición en JS de un concepto completamente nuevo, las clases son en realidad solo azúcar sintáctica para el sistema prototipo para construir objetos, que siempre ha estado presente en JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Aquí escribimos la función en la propiedad <code>getX</code> objeto <code>getX</code> .  Esta operación funciona exactamente de la misma manera que cuando se crean las propiedades de cualquier otro objeto, ya que los prototipos en JavaScript son objetos.  En los lenguajes basados ​​en el uso de prototipos, como JavaScript, los métodos que pueden compartir todos los objetos de cierto tipo se almacenan en prototipos, y los campos de los objetos individuales se almacenan en sus instancias. <br><br>  Veamos qué sucede, por así decirlo, detrás de escena cuando creamos una nueva instancia del objeto <code>Bar</code> , asignándola al <code>foo</code> constante. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Después de ejecutar dicho código, la instancia del objeto creado aquí tendrá un formulario que contiene una sola propiedad <code>x</code> .  El prototipo del objeto <code>foo</code> es <code>Bar.prototype</code> , que pertenece a la clase <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/52a/630/26b52a63051f760544368abc000ff13d.png"></div>  <i><font color="#999999">Objeto y su prototipo</font></i> <br><br>  <code>Bar.prototype</code> tiene su propia forma que contiene una sola propiedad <code>getX</code> cuyo valor es una función que, cuando se llama, devuelve el valor de <code>this.x</code>  El prototipo prototipo <code>Bar.prototype</code> es <code>Object.prototype</code> , que forma parte del lenguaje.  <code>Object.prototype</code> es el elemento raíz del árbol prototipo, por lo que su prototipo es <code>null</code> . <br><br>  Ahora veamos qué sucede si crea otro objeto de tipo <code>Bar</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/972/b2f/7a0972b2f7e264f2e58e399d7f29f5c6.png"></div>  <i><font color="#999999">Varios objetos del mismo tipo.</font></i> <br><br>  Como puede ver, tanto el objeto <code>foo</code> como el objeto <code>qux</code> , que son instancias de la clase <code>Bar</code> , como ya hemos dicho, usan la misma forma del objeto.  Ambos usan el mismo prototipo: el objeto <code>Bar.prototype</code> . <br><br><h2>  <font color="#3AC1EF">Acceder a las propiedades del prototipo</font> </h2><br>  Entonces, ahora sabemos lo que sucede cuando declaramos una nueva clase y la instanciamos.  ¿Y qué hay de la llamada al método del objeto?  Considere el siguiente fragmento de código: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Una llamada al método puede entenderse como una operación que consta de dos pasos: <br><br><pre> <code class="hljs ruby">const x = foo.getX(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         : const $getX = foo.getX; const x = $getX.call(foo);</code> </pre> <br>  En el primer paso, se carga el método, que es solo una propiedad del prototipo (cuyo valor es la función).  En el segundo paso, se llama a una función con <code>this</code> conjunto.  Considere el primer paso para cargar el método <code>getX</code> desde el objeto <code>foo</code> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b94/46f/291/b9446f291449153c1de7b7f6fafcbb5b.png"></div>  <i><font color="#999999">Cargando el método getX desde el objeto foo</font></i> <br><br>  El motor analiza el objeto <code>foo</code> y descubre que no hay propiedad <code>getX</code> en la forma del objeto <code>foo</code> .  Esto significa que el motor necesita mirar la cadena de prototipos del objeto para encontrar este método.  El motor accede al prototipo <code>Bar.prototype</code> y observa la forma del objeto de este prototipo.  Allí, encuentra la propiedad deseada en el desplazamiento 0. A continuación, <code>Bar.prototype</code> al valor almacenado en este desplazamiento en <code>Bar.prototype</code> , se detecta <code>JSFunction</code> <code>getX</code> allí, y esto es exactamente lo que estamos buscando.  Esto completa la búsqueda del método. <br><br>  La flexibilidad de JavaScript hace posible cambiar las cadenas de prototipos.  Por ejemplo, así: <br><br><pre> <code class="hljs pgsql">const foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bar(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); foo.getX(); // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.setPrototypeOf(foo, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); foo.getX(); // Uncaught TypeError: foo.getX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span></code> </pre> <br>  En este ejemplo, llamamos al método <code>foo.getX()</code> dos veces, pero cada una de estas llamadas tiene un significado y un resultado completamente diferentes.  Es por eso que, aunque los prototipos de JavaScript son solo objetos, acelerar el acceso a las propiedades de los prototipos es aún más difícil para los motores JS que acelerar el acceso a sus propias propiedades de los objetos ordinarios. <br><br>  Si observamos los programas de la vida real, resulta que cargar las propiedades del prototipo es una operación muy común.  Se ejecuta cada vez que se llama a un método. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">//        ^^^^^^^^^^</span></span></code> </pre> <br>  Anteriormente, hablamos sobre cómo los motores optimizan la carga de propiedades regulares y personalizadas de objetos mediante el uso de formularios de objetos y cachés en línea.  ¿Cómo optimizar la carga de propiedades de prototipo repetidas para objetos con la misma forma?  Arriba, vimos cómo se cargan las propiedades. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/020/076/65c/02007665c3b9d613e5ccb1daa53a55cd.png"></div>  <i><font color="#999999">Cargando el método getX desde el objeto foo</font></i> <br><br>  Para acelerar el acceso al método con llamadas repetidas, en nuestro caso, necesita saber lo siguiente: <br><br><ol><li>  La forma del objeto <code>foo</code> no contiene el método <code>getX</code> y no cambia.  Esto significa que el objeto <code>foo</code> no se modifica al agregarle propiedades o eliminarlo o cambiar los atributos de las propiedades. </li><li>  El prototipo <code>foo</code> sigue siendo el prototipo original de <code>Bar.prototype</code> .  Esto significa que el prototipo <code>foo</code> no cambia utilizando el método <code>Object.setPrototypeOf()</code> o asignando un nuevo prototipo a la propiedad especial <code>_proto_</code> . </li><li>  El formulario <code>Bar.prototype</code> contiene <code>getX</code> y no cambia.  Es decir, <code>Bar.prototype</code> no cambia al eliminar propiedades, agregarlas o cambiar sus atributos. </li></ol><br>  En el caso general, esto significa que necesitamos hacer 1 comprobación del objeto en sí y 2 comprobaciones para cada prototipo hasta el prototipo que almacena la propiedad que estamos buscando.  Es decir, debe realizar verificaciones 1 + 2N (donde N es el número de prototipos probados), que en este caso no se ve tan mal, ya que la cadena de prototipos es bastante corta.  Sin embargo, los motores a menudo tienen que trabajar con cadenas de prototipos mucho más largas.  Esto, por ejemplo, es típico de los elementos DOM ordinarios.  Aquí hay un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Aquí tenemos <code>HTMLAnchorElement</code> y llamamos a su método <code>getAttribute()</code> .  ¡La cadena de prototipos de este elemento simple que representa un enlace HTML incluye 6 prototipos!  Los métodos DOM más interesantes no están en su propio prototipo <code>HTMLAnchorElement</code> .  Están en prototipos ubicados más abajo en la cadena. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/e76/10d/753e7610da32acbfd576fd0c61226bc7.png"></div>  <i><font color="#999999">Cadena prototipo</font></i> <br><br>  El método <code>getAttribute()</code> se puede encontrar en <code>Element.prototype</code> .  Esto significa que cada vez que se <code>anchor.getAttribute()</code> método <code>anchor.getAttribute()</code> , el motor se ve obligado a realizar las siguientes acciones: <br><br><ol><li>  Comprueba el objeto de <code>anchor</code> sí para <code>getAttribute</code> . </li><li>  Verificar que el prototipo directo del objeto es <code>HTMLAnchorElement.prototype</code> . </li><li>  Descubrir que <code>HTMLAnchorElement.prototype</code> no tiene un método <code>getAttribute</code> . </li><li>  Verificar que el próximo prototipo sea <code>HTMLElement.prototype</code> . </li><li>  Descubrir que no hay un método necesario aquí. </li><li>  Finalmente, descubriendo que el próximo prototipo es <code>Element.prototype</code> . </li><li>  Descubrir que hay un método <code>getAttribute</code> . </li></ol><br>  Como puede ver, aquí se realizan 7 comprobaciones.  Dado que dicho código es muy común en la programación web, los motores utilizan optimizaciones para reducir la cantidad de comprobaciones necesarias para cargar las propiedades del prototipo. <br><br>  Si volvemos a uno de los ejemplos anteriores, podemos recordar que cuando llamamos al método <code>getX</code> del objeto <code>getX</code> , realizamos 3 comprobaciones: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; }   getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = new Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Para cada objeto que está en la cadena del prototipo, hasta el que contiene la propiedad deseada, necesitamos verificar la forma del objeto solo para descubrir la ausencia de lo que estamos buscando.  Sería bueno si pudiéramos reducir el número de controles reduciendo el control del prototipo a verificar la presencia o ausencia de lo que estamos buscando.  Esto es lo que hace el motor con un simple movimiento: en lugar de almacenar el enlace prototipo en la propia instancia, el motor lo almacena en forma de un objeto. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/643/1d0/c33/6431d0c33d2d03bea86e6adfffed4569.png"></div>  <i><font color="#999999">Prototipo de almacenamiento de referencia</font></i> <br><br>  Cada formulario tiene un enlace a un prototipo.  Esto también significa que cada vez que el prototipo cambia, el motor se mueve a la nueva forma del objeto.  Ahora solo tenemos que verificar la forma del objeto para detectar la presencia de una propiedad en él y cuidar de proteger el enlace prototipo. <br><br>  Gracias a este enfoque, podemos reducir el número de comprobaciones de 1 + 2N a 1 + N, lo que acelerará el acceso a las propiedades de los prototipos.  Sin embargo, tales operaciones aún requieren muchos recursos, ya que existe una relación lineal entre su número y la longitud de la cadena del prototipo.  Los motores han implementado varios mecanismos destinados a garantizar que el número de comprobaciones no dependa de la longitud de la cadena del prototipo, expresado como una constante.  Esto es especialmente cierto en situaciones donde la carga de la misma propiedad se realiza varias veces. <br><br><h2>  <font color="#3AC1EF">Propiedad ValidityCell</font> </h2><br>  V8 se refiere a las formas de prototipos específicamente para el propósito anterior.  Cada prototipo tiene una forma única que no se comparte con otros objetos (en particular, con otros prototipos), y cada uno de los formularios de objetos prototipo tiene una propiedad <code>ValidityCell</code> asociada a ellos. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fb/f9c/3f9/7fbf9c3f987b8def69855e849c71c01a.png"></div>  <i><font color="#999999">Propiedad ValidityCell</font></i> <br><br>  Esta propiedad se declara inválida cuando se cambia el prototipo asociado con el formulario o cualquier prototipo superpuesto.  Considere este mecanismo con más detalle. <br><br>  Para acelerar las operaciones secuenciales de las propiedades de carga de los prototipos, V8 utiliza un caché en línea que contiene cuatro campos: <code>ValidityCell</code> , <code>Prototype</code> , <code>Shape</code> , <code>Offset</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/a3b/04f/0baa3b04faebad191e769279c6eb1cd8.png"></div>  <i><font color="#999999">Campos de caché en línea</font></i> <br><br>  Durante el "calentamiento" del caché en línea la primera vez que se ejecuta el código, V8 recuerda el desplazamiento en el que se encontró la propiedad en el prototipo, el prototipo en el que se encontró la propiedad (en este ejemplo, <code>Bar.prototype</code> ), la forma del objeto ( <code>foo</code> en este caso) y, además, un enlace al parámetro <code>ValidityCell</code> actual del prototipo inmediato, un enlace que tiene la forma de un objeto (en este caso, también es <code>Bar.prototype</code> ). <br><br>  La próxima vez que acceda al caché en línea, el motor deberá verificar la forma del objeto y <code>ValidityCell</code> .  Si <code>ValidityCell</code> sigue siendo válido, el motor puede aprovechar directamente el desplazamiento previamente guardado en el prototipo sin realizar operaciones de búsqueda adicionales. <br><br>  Cuando el prototipo cambia, se crea un nuevo formulario y la propiedad <code>ValidityCell</code> anterior se declara inválida.  Como resultado, la próxima vez que intente acceder al caché en línea, no ofrece ningún beneficio, lo que conduce a un bajo rendimiento. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/c30/c97/c95c30c97ee0429bf1400163309c6354.png"></div>  <i><font color="#999999">Las consecuencias de cambiar el prototipo</font></i> <br><br>  Si volvemos al ejemplo con el elemento DOM, esto significa que cualquier cambio, por ejemplo, en el prototipo de <code>Object.prototype</code> , conducirá no solo a invalidar el caché en línea para <code>Object.prototype</code> sí, sino también para cualquier prototipo ubicado debajo de él en la cadena de prototipos. incluidos <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., hasta <code>HTMLAnchorElement.prototype</code> . <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/5f7/ff7/4445f7ff7b11c00e40aeac4fd1945ae1.png"></div>  <i><font color="#999999">Implicaciones de cambiar Object.prototype</font></i> <br><br>  De hecho, modificar <code>Object.prototype</code> durante la ejecución del código significa hacer un daño grave al rendimiento.  No hagas esto. <br><br>  Estudiamos lo anterior con un ejemplo.  Supongamos que tenemos la clase <code>Bar</code> y la función <code>loadX</code> , que llama al método de los objetos creados a partir de la clase <code>Bar</code> .  Llamamos a la función <code>loadX</code> varias veces, pasándole instancias de la misma clase. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); // IC  <span class="hljs-string"><span class="hljs-string">'getX'</span></span>   `Bar`. } loadX(new Bar(true)); loadX(new Bar(false)); // IC  `loadX`    `ValidityCell`  // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // `ValidityCell`  IC `loadX`   //    `Object.prototype`  .</code> </pre> <br>  El caché en <code>loadX</code> en <code>loadX</code> ahora apunta a <code>Bar.prototype</code> para <code>Bar.prototype</code> .  , ,  <code>Object.prototype</code> —    JavaScript,   <code>ValidityCell</code>  ,   -          ,     . <br><br>  <code>Object.prototype</code> —   ,        -      ,       .     ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//    : someObject.foo(); //     . delete Object.prototype.foo;</span></span></code> </pre> <br>   <code>Object.prototype</code> ,     - ,   .     ,    .      -   ,          .       , «  »,   ,  . <br><br> ,  ,  .             .    <code>Object.prototype</code> ,   ,   -            . <br><br>       ,    —   , JS-    -  ,       .        .       ,     ,      .  ,   ,       ,      . <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>       ,  JS-    ,  ,   , -,  <code>ValidityCell</code>   ,     .            JavaScript,    ,       (       , ,  ,        ). <br><br>  <b>Estimados lectores!</b>       ,    - ,   JS,          ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422321/">https://habr.com/ru/post/es422321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422309/index.html">Cómo proteger los datos en redes neuronales en la nube: se propone un nuevo método de cifrado</a></li>
<li><a href="../es422311/index.html">Interesante y utilidad de python. Parte 2</a></li>
<li><a href="../es422315/index.html">Cómo sobrevivir a un cazador de insectos: lucha diaria por los ingresos</a></li>
<li><a href="../es422317/index.html">¿Por qué los TPU son tan buenos para el aprendizaje profundo?</a></li>
<li><a href="../es422319/index.html">Por primera vez, el equipo ruso se metió en el acelerador científico más grande IndieBio</a></li>
<li><a href="../es422323/index.html">Hackers: Rusia y China</a></li>
<li><a href="../es422325/index.html">DevDay sobre pruebas: Relájate. Pruébalo fácil</a></li>
<li><a href="../es422327/index.html">Cronograma del proyecto vs Backlog: Batalla sin posibilidades</a></li>
<li><a href="../es422329/index.html">Seguridad de la información de los pagos bancarios sin efectivo. Parte 8 - Modelos de amenaza típicos</a></li>
<li><a href="../es422331/index.html">Cómo el contador híbrido de autopago aumenta la eficiencia de la tienda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>