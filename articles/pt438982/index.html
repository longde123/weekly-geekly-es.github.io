<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏻 ⏱️ 🦀 Guia Kubernetes, Parte 1: Aplicativos, Microsserviços e Contêineres 🌝 ⚽️ 👩‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A nosso pedido, a Habr criou o hub Kubernetes e temos o prazer de publicar a primeira publicação nele. Inscreva-se! 
 Kubernetes é fácil. Por que os b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia Kubernetes, Parte 1: Aplicativos, Microsserviços e Contêineres</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438982/"><blockquote>  A nosso pedido, a Habr criou o hub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> e temos o prazer de publicar a primeira publicação nele.  Inscreva-se! </blockquote><br>  Kubernetes é fácil.  Por que os bancos me pagam muito dinheiro por trabalhar nesta área, enquanto alguém pode dominar essa tecnologia em apenas algumas horas? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/d3/4l/ic/d34licaikjsxfxisetkc9arcpdi.jpeg"></a> <br><a name="habracut"></a><br>  Se você duvida que o Kubernetes possa ser aprendido tão rapidamente, sugiro que tente fazer isso sozinho.  Ou seja, depois de dominar este material, você poderá executar o aplicativo com base em microsserviços no cluster Kubernetes.  Eu posso garantir isso, porque é exatamente pela metodologia usada aqui que eu treino o Kubernetes para trabalhar com nossos clientes.  O que distingue este manual dos outros?  De fato - muitas coisas.  Portanto, a maioria desses materiais começa com uma explicação de coisas simples - conceitos do Kubernetes e recursos da equipe do kubectl.  Os autores desses materiais acreditam que seus leitores estão familiarizados com o desenvolvimento de aplicativos, microsserviços e contêineres do Docker.  Vamos para o outro lado.  Primeiro, vamos falar sobre como executar um aplicativo com base em microsserviços em um computador.  Em seguida, considere a montagem de imagens de contêiner para cada microsserviço.  Depois disso, conheceremos o Kubernetes e analisaremos a implantação de um aplicativo baseado em microsserviço em um cluster gerenciado pelo Kubernetes. <br><br>  Essa abordagem, com uma abordagem gradual ao Kubernetes, fornecerá a profundidade do entendimento que está acontecendo com uma pessoa comum, a fim de entender como tudo é organizado de maneira simples no Kubernetes.  O Kubernetes é, é claro, uma tecnologia simples, desde que quem queira aprender saiba onde e como é usado. <br><br>  Agora, sem mais delongas, vamos trabalhar e falar sobre o aplicativo com o qual iremos trabalhar. <br><br><h2>  <font color="#3AC1EF">Aplicação experimental</font> </h2><br>  Nossa aplicação executará apenas uma função.  Ele aceita, como entrada, uma sentença e, usando os meios de análise de texto, realiza uma análise de sentimentos dessa sentença, recebendo uma estimativa da atitude emocional do autor da sentença em relação a um determinado objeto. <br><br>  É assim que a janela principal deste aplicativo se parece. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/7e1/415/6747e14151585819867c880f52fa9d21.gif"></div><br>  <i><font color="#999999">Aplicativo da Web para análise de sentimentos de texto</font></i> <br><br>  Do ponto de vista técnico, o aplicativo consiste em três microsserviços, cada um dos quais resolve um determinado conjunto de tarefas: <br><br><ul><li>  O SA-Frontend é um servidor da web Nginx que serve arquivos estáticos do React. </li><li>  O SA-WebApp é um aplicativo da web baseado em Java que processa solicitações do front-end. </li><li>  O SA-Logic é um aplicativo Python que executa análise de sentimentos de texto. </li></ul><br>  É importante observar que os microsserviços não existem isoladamente.  Eles implementam a idéia de "separação de tarefas", mas, no entanto, precisam interagir entre si. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/f93/0c0/94bf930c03220c1eec6957a0f7308046.gif"></div><br>  <i><font color="#999999">Fluxos de dados do aplicativo</font></i> <br><br>  No diagrama acima, você pode ver os estágios numerados do sistema, ilustrando os fluxos de dados no aplicativo.  Vamos analisá-los: <br><br><ol><li> O navegador solicita o arquivo <code>index.html</code> do servidor (que, por sua vez, baixa o pacote do aplicativo React). </li><li>  O usuário interage com o aplicativo, isso causa uma chamada para um aplicativo Web baseado no Spring. </li><li>  O aplicativo da Web redireciona a solicitação de análise de texto para o aplicativo Python. </li><li>  O aplicativo Python analisa a tonalidade do texto e retorna o resultado como uma resposta à solicitação. </li><li>  O aplicativo Spring envia uma resposta ao aplicativo React (e, por sua vez, mostra o resultado da análise de texto ao usuário). </li></ol><br>  O código para todos esses aplicativos pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Eu recomendo que você agora copie esse repositório para si mesmo, pois há muitas experiências interessantes à sua frente. <br><br><h2>  <font color="#3AC1EF">Iniciando um aplicativo baseado em microsserviço em um computador local</font> </h2><br>  Para que o aplicativo funcione, precisamos executar todos os três microsserviços.  Vamos começar com o mais bonito deles - com o aplicativo front-end. <br><br><h3>  <font color="#3AC1EF">ReaConfigurando o React para o desenvolvimento local</font> </h3><br>  Para executar o aplicativo React, você precisa instalar as plataformas Node.js e NPM no seu computador.  Depois de instalar tudo isso, passe pelo terminal até a pasta do projeto <code>sa-frontend</code> e execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">npm install</code> </pre> <br>  Graças à execução deste comando, as dependências do aplicativo React, entradas sobre as quais estão no arquivo <code>package.json</code> , serão carregadas na pasta <code>node_modules</code> .  Após o download das dependências na mesma pasta, execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Isso é tudo.  Agora, o aplicativo React está em execução. O acesso a ele pode ser obtido acessando o endereço <code>localhost:3000</code> no navegador.  Você pode mudar algo no código dele.  Você verá imediatamente o efeito dessas alterações no navegador.  Isso é possível graças à chamada substituição "quente" de módulos.  Graças a isso, o desenvolvimento do front-end se torna uma tarefa simples e agradável. <br><br><h3>  <font color="#3AC1EF">▍ Preparação de um aplicativo React para saída para produção</font> </h3><br>  Para o uso real do aplicativo React, precisamos convertê-lo em um conjunto de arquivos estáticos e entregá-los aos clientes usando um servidor da web. <br><br>  Para criar o aplicativo React, novamente, usando o terminal, vá para a pasta <code>sa-frontend</code> e execute o seguinte comando: <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> <br>  Isso criará um diretório de <code>build</code> na pasta do projeto.  Ele conterá todos os arquivos estáticos necessários para o aplicativo React funcionar. <br><br><h3>  <font color="#3AC1EF">ErvServindo arquivos estáticos usando as ferramentas Nginx</font> </h3><br>  Primeiro, você precisa instalar e executar o servidor da web Nginx.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> você pode baixá-lo e encontrar instruções de instalação e inicialização.  Em seguida, você precisa copiar o conteúdo da pasta <code>sa-frontend/build</code> para a pasta <code>[your_nginx_installation_dir]/html</code> . <br><br>  Com essa abordagem, o arquivo <code>index.html</code> gerado durante a compilação do aplicativo React estará disponível em <code>[your_nginx_installation_dir]/html/index.html</code> .  Esse é o arquivo que, por padrão, o servidor Nginx emite ao acessá-lo.  O servidor está configurado para escutar na porta <code>80</code> , mas você pode configurá-lo conforme necessário editando o arquivo <code>[your_nginx_installation_dir]/conf/nginx.conf</code> . <br><br>  Agora abra seu navegador e vá para <code>localhost:80</code> .  Você verá a página do aplicativo React. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a50/b83/f39/a50b83f390ff0434ef817f357a041941.png"></div><br>  <i><font color="#999999">React Application Served by Nginx Server</font></i> <br><br>  Se você digitar algo no campo <code>Type your sentence</code> agora e clicar no botão <code>Send</code> , nada acontecerá.  Mas, se você olhar para o console, poderá ver mensagens de erro lá.  Para entender exatamente onde esses erros ocorrem, vamos analisar o código do aplicativo. <br><br><h3>  <font color="#3AC1EF">▍Análise do código do aplicativo front-end</font> </h3><br>  <code>App.js</code> analisado o código do arquivo <code>App.js</code> , podemos ver que clicar no botão <code>Send</code> chama o método <code>analyzeSentence()</code> .  O código para este método é fornecido abaixo.  Ao mesmo tempo, preste atenção ao fato de que, para cada linha para a qual há um comentário no formulário <code># </code> , há uma explicação fornecida abaixo do código.  Da mesma forma, analisaremos outras partes do código. <br><br><pre> <code class="plaintext hljs">analyzeSentence() {   fetch('http://localhost:8080/sentiment', {  // #1       method: 'POST',       headers: {           'Content-Type': 'application/json'       },       body: JSON.stringify({                      sentence: this.textField.getValue()})// #2   })       .then(response =&gt; response.json())       .then(data =&gt; this.setState(data));  // #3 }</code> </pre> <br>  <b>1.</b> URL em que a solicitação POST é executada.  Entende-se que este endereço contém um aplicativo que está aguardando tais solicitações. <br><br>  <b>2.</b> O corpo da solicitação enviado ao aplicativo.  Aqui está um exemplo de corpo de solicitação: <br><br><pre> <code class="plaintext hljs">{   sentence: "I like yogobella!" }</code> </pre> <br>  <b>3.</b> Após o recebimento de uma resposta à solicitação, o estado do componente é atualizado.  Isso faz com que o componente seja renderizado novamente.  Se recebermos dados (ou seja, um objeto JSON contendo os dados inseridos e a pontuação calculada do texto), produziremos o componente <code>Polarity</code> , pois as condições correspondentes serão atendidas.  É assim que descrevemos o componente: <br><br><pre> <code class="plaintext hljs">const polarityComponent = this.state.polarity !== undefined ?   &lt;Polarity sentence={this.state.sentence}             polarity={this.state.polarity}/&gt; :   null;</code> </pre> <br>  O código parece estar funcionando muito bem.  O que há de errado aqui, afinal?  Se você presumir que no endereço em que o aplicativo está tentando enviar uma solicitação POST, até o momento não há nada que possa aceitar e processar essa solicitação, você estará absolutamente certo.  Ou seja, para processar solicitações que chegam ao endereço <code>http://localhost:8080/sentiment</code> , precisamos executar um aplicativo Web baseado no Spring. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/848/f16/5a3/848f165a308f9ae73ffd3f8186b23aee.png"></div><br>  <i><font color="#999999">Precisamos de um aplicativo Spring que possa aceitar uma solicitação POST.</font></i> <br><br><h3>  <font color="#3AC1EF">ApplicationConfigurar o aplicativo Web baseado em Spring</font> </h3><br>  Para implantar o aplicativo Spring, você precisará de JDK8 e Maven e variáveis ​​de ambiente adequadamente configuradas.  Depois de instalar tudo isso, você pode continuar trabalhando no nosso projeto. <br><br><h3>  <font color="#3AC1EF">AckEmbalando o aplicativo em um arquivo jar</font> </h3><br>  Vá, usando o terminal, para a pasta <code>sa-webapp</code> e digite o seguinte comando: <br><br><pre> <code class="plaintext hljs">mvn install</code> </pre> <br>  Após executar este comando, o diretório de <code>target</code> será criado na pasta <code>sa-webapp</code> .  Haverá um aplicativo Java empacotado em um arquivo jar representado por <code>sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> . <br><br><h3>  <font color="#3AC1EF">▍Inicie o aplicativo Java</font> </h3><br>  Vá para a pasta de <code>target</code> e inicie o aplicativo com o seguinte comando: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar</code> </pre> <br>  Ocorrerá um erro durante a execução deste comando.  Para começar a corrigi-lo, podemos analisar as informações de exceção nos dados de rastreamento da pilha: <br><br><pre> <code class="plaintext hljs">Error creating bean with name 'sentimentController': Injection of autowired dependencies failed; nested exception is java.lang.IllegalArgumentException: Could not resolve placeholder 'sa.logic.api.url' in value "${sa.logic.api.url}"</code> </pre> <br>  Para nós, o mais importante aqui é a menção da impossibilidade de determinar o significado de <code>sa.logic.api.url</code> .  Vamos analisar o código no qual o erro ocorre. <br><br><h3>  <font color="#3AC1EF">Analysis Análise de código de aplicativo Java</font> </h3><br>  Aqui está o trecho de código em que o erro ocorre. <br><br><pre> <code class="plaintext hljs">@CrossOrigin(origins = "*") @RestController public class SentimentController {   @Value("${sa.logic.api.url}")    // #1   private String saLogicApiUrl;   @PostMapping("/sentiment")   public SentimentDto sentimentAnalysis(       @RequestBody SentenceDto sentenceDto)   {       RestTemplate restTemplate = new RestTemplate();       return restTemplate.postForEntity(               saLogicApiUrl + "/analyse/sentiment",    // #2               sentenceDto, SentimentDto.class)               .getBody();   } }</code> </pre> <br><ol><li>  S <code>entimentController</code> possui um campo <code>saLogicApiUrl</code> .  Seu valor é definido pela propriedade <code>sa.logic.api.url</code> . </li><li>  A cadeia <code>saLogicApiUrl</code> concatenada com o valor <code>/analyse/sentiment</code> .  Juntos, eles formam um endereço para acessar um microsserviço que executa análise de texto. </li></ol><br><h3>  <font color="#3AC1EF">Definir valor da propriedade</font> </h3><br>  No Spring, a fonte padrão de valores de propriedade é o arquivo <code>application.properties</code> , que pode ser encontrado em <code>sa-webapp/src/main/resources</code> .  Mas seu uso não é a única maneira de definir valores de propriedade.  Você pode fazer isso com um comando como o seguinte: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=WHAT.IS.THE.SA.LOGIC.API.URL</code> </pre> <br>  O valor dessa propriedade deve apontar para o endereço do nosso aplicativo Python. <br><br>  Ao configurá-lo, informamos ao aplicativo da Web Spring para onde ele deve ir para executar solicitações de análise de texto. <br><br>  Para não complicar nossas vidas, decidimos que o aplicativo Python estará disponível no <code>localhost:5000</code> e tentamos não esquecê-lo.  Como resultado, o comando para iniciar o aplicativo Spring ficará assim: <br><br><pre> <code class="plaintext hljs">java -jar sentiment-analysis-web-0.0.1-SNAPSHOT.jar --sa.logic.api.url=http://localhost:5000</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30d/445/815/30d44581533865907366e867c029124e.png"></div><br>  <i><font color="#999999">Nosso sistema não possui um aplicativo Python</font></i> <br><br>  Agora basta iniciar o aplicativo Python e o sistema funcionará conforme o esperado. <br><br><h3>  <font color="#3AC1EF">▍Configurando um aplicativo Python</font> </h3><br>  Para executar um aplicativo Python, você deve ter o Python 3 e o Pip instalados e definir as variáveis ​​de ambiente apropriadas corretamente. <br><br><h3>  <font color="#3AC1EF">Instalação de dependências</font> </h3><br>  Vá para a pasta do projeto <code>sa-logic/sa</code> e execute os seguintes comandos: <br><br><pre> <code class="plaintext hljs">python -m pip install -r requirements.txt python -m textblob.download_corpora</code> </pre> <br><h3>  <font color="#3AC1EF">▍Iniciar aplicação</font> </h3><br>  Depois de instalar as dependências, estamos prontos para iniciar o aplicativo: <br><br><pre> <code class="plaintext hljs">python sentiment_analysis.py</code> </pre> <br>  Após executar este comando, seremos informados do seguinte: <br><br><pre> <code class="plaintext hljs">* Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</code> </pre> <br>  Isso significa que o aplicativo está em execução e aguarda solicitações no <code>localhost:5000/</code> <br><br><h3>  <font color="#3AC1EF">▍ Pesquisa de código</font> </h3><br>  Considere o código do aplicativo Python para entender como ele responde às solicitações: <br><br><pre> <code class="plaintext hljs">from textblob import TextBlob from flask import Flask, request, jsonify app = Flask(__name__)                                   #1 @app.route("/analyse/sentiment", methods=['POST'])      #2 def analyse_sentiment():   sentence = request.get_json()['sentence']           #3   polarity = TextBlob(sentence).sentences[0].polarity #4   return jsonify(                                     #5       sentence=sentence,       polarity=polarity   ) if __name__ == '__main__':   app.run(host='0.0.0.0', port=5000)                #6</code> </pre> <br><ol><li>  Inicializando um objeto <code>Flask</code> . </li><li>  Configurando o endereço para executar solicitações POST. </li><li>  Recuperando a propriedade da <code>sentence</code> do corpo da solicitação. </li><li>  Inicializando o objeto <code>TextBlob</code> anônimo e obtendo o valor de <code>polarity</code> para a primeira sentença no corpo da solicitação (no nosso caso, esta é a única sentença passada para análise). </li><li>  O retorno da resposta, no corpo da qual contém o texto da proposta e o índice de <code>polarity</code> calculado para ela. </li><li>  Ativando o aplicativo Flask, que estará disponível em <code>0.0.0.0:5000</code> (você também pode acessá-lo usando uma construção <code>localhost:5000</code> ). </li></ol><br>  Agora, os microsserviços que compõem o aplicativo estão em execução.  Eles estão configurados para interagir entre si.  É assim que o diagrama do aplicativo se parece nesta fase do trabalho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75a/fcc/135/75afcc1352ed237efaf0a2280c2df295.png"></div><br>  <i><font color="#999999">Todos os microsserviços que compõem o aplicativo são trazidos para um estado íntegro.</font></i> <br><br>  Agora, antes de continuar, abra o aplicativo React em um navegador e tente analisar algumas sugestões usando-o.  Se tudo for feito corretamente, depois de clicar no botão <code>Send</code> , você verá os resultados da análise na caixa de texto. <br><br>  Na próxima seção, falaremos sobre como executar nossos microsserviços em contêineres do Docker.  Isso é necessário para preparar o aplicativo para o lançamento no cluster Kubernetes. <br><br><h2>  <font color="#3AC1EF">Docker Containers</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Kubernetes</a> é um sistema para automatizar a implantação, dimensionamento e gerenciamento de aplicativos em contêiner.  É também chamado de "orquestrador de contêineres".  Se o Kubernetes trabalha com contêineres, primeiro precisamos adquiri-los antes de usar este sistema.  Mas primeiro, vamos falar sobre o que são contêineres.  Talvez a melhor resposta para a pergunta sobre o que é possa ser encontrada na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do Docker: <br><br>  <i>Uma imagem de contêiner é um pacote executável leve, independente, contendo algum tipo de aplicativo que inclui tudo o que você precisa para executá-lo: código do aplicativo, tempo de execução, ferramentas e bibliotecas do sistema, configurações.</i>  <i>Programas em contêineres podem ser usados ​​em ambientes Linux e Windows e sempre funcionarão da mesma maneira, independentemente da infraestrutura.</i> <br><br>  Isso significa que os contêineres podem ser executados em qualquer computador, incluindo servidores de produção, e em qualquer ambiente que os aplicativos contidos neles funcionem da mesma maneira. <br><br>  Para explorar os recursos dos contêineres e compará-los com outras maneiras de iniciar aplicativos, considere um exemplo de veiculação de um aplicativo React usando uma máquina virtual e um contêiner. <br><br><h3>  <font color="#3AC1EF">ErvServindo Arquivos estáticos do aplicativo React usando máquina virtual</font> </h3><br>  Tentando organizar a manutenção de arquivos estáticos por meio de máquinas virtuais, encontraremos as seguintes desvantagens: <br><br><ol><li>  Uso ineficiente de recursos, pois cada máquina virtual é um sistema operacional completo. </li><li>  Depende da plataforma.  O que funciona em um determinado computador local pode não funcionar em um servidor de produção. </li><li>  Escala lenta e com muitos recursos de uma solução baseada em máquina virtual. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c26/927/523/c26927523b6072ce65bfaf8b01a1e330.png"></div><br>  <i><font color="#999999">Servidor da Web do servidor estático Nginx em execução em uma máquina virtual</font></i> <br><br>  Se os contêineres são usados ​​para resolver um problema semelhante, então, em comparação com as máquinas virtuais, podem ser observados os seguintes pontos fortes: <br><br><ol><li>  Uso eficiente de recursos: trabalhando com o sistema operacional usando o Docker. </li><li>  Independência da plataforma.  Um contêiner que um desenvolvedor possa executar em seu computador funcionará em qualquer lugar. </li><li>  Implantação leve através do uso de camadas de imagem. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28b/593/b01/28b593b01ce003c246843d9c9f2bd05f.png"></div><br>  <i><font color="#999999">Servidor da Web do servidor estático Nginx em execução em um contêiner</font></i> <br><br>  Comparamos máquinas virtuais e contêineres em apenas alguns pontos, mas mesmo isso é suficiente para sentir a força dos contêineres.  Saiba mais sobre os contêineres do Docker aqui. <br><br><h3>  <font color="#3AC1EF">▍ Montando uma imagem de contêiner para um aplicativo React</font> </h3><br>  O principal <code>Dockerfile</code> do contêiner do Docker é o <code>Dockerfile</code> .  No início deste arquivo, faça um registro da imagem básica do contêiner e, em seguida, inclua uma sequência de instruções que indica a ordem em que o contêiner será criado para atender às necessidades de um determinado aplicativo. <br><br>  Antes de começarmos a trabalhar com o arquivo <code>Dockerfile</code> , lembremos o que fizemos para preparar os arquivos do aplicativo React para upload no servidor Nginx: <br><br><ol><li>  Crie um pacote de aplicativos React ( <code>npm run build</code> ). </li><li>  Iniciando o servidor Nginx. </li><li>  Copie o conteúdo do diretório de <code>build</code> da pasta do projeto <code>sa-frontend</code> para a pasta do servidor <code>nginx/html</code> . </li></ol><br>  Abaixo, você pode ver os paralelos entre a criação do contêiner e as ações acima, executadas no computador local. <br><br><h3>  <font color="#3AC1EF">RePreparando um Dockerfile para SA-Frontend</font> </h3><br>  As instruções que estarão contidas no <code>Dockerfile</code> para o aplicativo <code>SA-Frontend</code> consistem em apenas dois comandos.  O fato é que a equipe de desenvolvimento do Nginx preparou uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">imagem</a> básica para o Nginx, que usaremos para criar nossa imagem.  Aqui estão as duas etapas que precisamos descrever: <br><br><ol><li>  A base da imagem que você precisa para criar uma imagem Nginx. </li><li>  O conteúdo da pasta <code>sa-frontend/build</code> deve ser copiado para a pasta de imagem <code>nginx/html</code> . </li></ol><br>  Se passarmos desta descrição para o <code>Dockerfile</code> , será semelhante a este: <br><br><pre> <code class="plaintext hljs">FROM nginx COPY build /usr/share/nginx/html</code> </pre> <br>  Como você pode ver, tudo aqui é muito simples, enquanto o conteúdo do arquivo acaba sendo bastante legível e compreensível.  Esse arquivo informa ao sistema para levar a imagem <code>nginx</code> com tudo o que já possui e copiar o conteúdo do diretório de <code>build</code> para o diretório <code>nginx/html</code> . <br><br>  Aqui você pode ter uma pergunta sobre onde eu sei exatamente onde eu preciso copiar arquivos da pasta de <code>build</code> , ou seja, de onde veio o caminho <code>/usr/share/nginx/html</code> .  De fato, e não há nada complicado.  O fato é que as informações relevantes podem ser encontradas na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrição da</a> imagem. <br><br><h3>  <font color="#3AC1EF">UildConstruindo uma imagem e enviando-a para o repositório</font> </h3><br>  Antes de podermos trabalhar com a imagem final, precisamos enviá-la para o repositório de imagens.  Para fazer isso, usaremos a plataforma de nuvem gratuita para hospedar imagens do Docker Hub.  Nesta fase do trabalho, você precisa fazer o seguinte: <br><br><ol><li>  Instale o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> . </li><li>  Registre-se no site do Docker Hub. </li><li>  Efetue login na conta executando o seguinte comando no terminal: <br><br><pre> <code class="plaintext hljs">docker login -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD"</code> </pre> </li></ol><br>  Agora você precisa usar o terminal para acessar o diretório <code>sa-frontend</code> e executar o seguinte comando: <br><br><pre> <code class="plaintext hljs">docker build -f Dockerfile -t $DOCKER_USER_ID/sentiment-analysis-frontend .</code> </pre> <br>  A seguir, em comandos semelhantes, <code>$DOCKER_USER_ID</code> precisa ser substituído pelo seu nome de usuário no Docker Hub.  Por exemplo, esta parte do comando pode ser assim: <code>rinormaloku/sentiment-analysis-frontend</code> . <br><br>  Ao mesmo tempo, esse comando pode ser abreviado removendo <code>-f Dockerfile</code> , pois esse arquivo já existe na pasta em que executamos esse comando. <br><br>  Para enviar a imagem finalizada para o repositório, precisamos do seguinte comando: <br><br><pre> <code class="plaintext hljs">docker push $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Após sua execução, verifique a lista de seus repositórios no Docker Hub para entender se a imagem foi enviada para a nuvem com sucesso. <br><br><h3>  <font color="#3AC1EF">ContainerIniciar o contêiner</font> </h3><br>  Agora qualquer pessoa pode baixar e executar uma imagem conhecida como <code>$DOCKER_USER_ID/sentiment-analysis-frontend</code> .  Para fazer isso, você precisa executar a seguinte sequência de comandos: <br><br><pre> <code class="plaintext hljs">docker pull $DOCKER_USER_ID/sentiment-analysis-frontend docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>  Agora o contêiner foi lançado e podemos continuar trabalhando, criando as outras imagens de que precisamos.  Mas, antes de continuar, vejamos <code>80:80</code> construção <code>80:80</code> , encontrada no comando de inicialização da imagem e pode parecer incompreensível. <br><br><ul><li>  O primeiro número <code>80</code> é o número da porta do host (ou seja, o computador local). </li><li>  O segundo número <code>80</code> é a porta do contêiner para o qual a solicitação deve ser redirecionada. </li></ul><br>  Considere a seguinte ilustração. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/775/394/6cd/7753946cde3287113b82f00921ced889.png"></div><br>  <i><font color="#999999">Encaminhamento de porta</font></i> <br><br>  O sistema redireciona solicitações da porta <code>&lt;hostPort&gt;</code> para a porta <code>&lt;containerPort&gt;</code> .  Ou seja, o acesso à porta <code>80</code> computador é redirecionado para a porta <code>80</code> contêiner. <br><br>  Como a porta <code>80</code> aberta no computador local, você pode acessar o aplicativo neste computador em <code>localhost:80</code> .  Se o seu sistema não suportar o Docker, você poderá executar o aplicativo na máquina virtual do Docker, cujo endereço será semelhante a <code>&lt;docker-machine ip&gt;:80</code> .  Para descobrir o endereço IP da máquina virtual do Docker, você pode usar o <code>docker-machine ip</code> . <br><br>  Nesse estágio, após iniciar com êxito o contêiner do aplicativo frontend, você poderá abrir sua página em um navegador. <br><br><h3>  <font color="#3AC1EF">▍ arquivo .dockerignore</font> </h3><br>  Coletando a imagem do aplicativo <code>SA-Frontend</code> , podemos observar que esse processo é extremamente lento.  Isso acontece devido ao fato de que o contexto de construção da imagem deve ser enviado ao daemon do Docker.  O diretório que representa o contexto de construção é especificado pelo último argumento para o <code>docker build</code> .  No nosso caso, no final deste comando, há um período.  Isso resulta na inclusão da seguinte estrutura no contexto da montagem: <br><br><pre> <code class="plaintext hljs">sa-frontend: |   .dockerignore |   Dockerfile |   package.json |   README.md +---build +---node_modules +---public \---src</code> </pre> <br>  Mas de todas as pastas presentes aqui, precisamos apenas da pasta de <code>build</code> .  Baixar qualquer outra coisa é uma perda de tempo.  As compilações podem ser aceleradas, informando ao Docker quais diretórios devem ser ignorados.  É para fazer isso que precisamos de um arquivo <code>.dockerignore</code> .  Se você estiver familiarizado com o arquivo <code>.gitignore</code> , a estrutura desse arquivo certamente parecerá familiar.  Ele lista os diretórios que o sistema de montagem de imagens pode ignorar.  No nosso caso, o conteúdo deste arquivo se parece com o seguinte: <br><br><pre> <code class="plaintext hljs">node_modules src public</code> </pre> <br>  O arquivo <code>.dockerignore</code> deve estar na mesma pasta que o <code>Dockerfile</code> .  Agora, a montagem da imagem levará alguns segundos. <br><br>  Agora vamos dar uma olhada no aplicativo Java. <br><br><h3> <font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UildConstruindo uma imagem de contêiner para um aplicativo Java</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você sabe o que, mas você já aprendeu tudo o que precisa para criar imagens de contêiner. </font><font style="vertical-align: inherit;">É por isso que esta seção será muito curta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abra o arquivo </font></font><code>Dockerfile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localizado na pasta do projeto </font></font><code>sa-webapp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se você ler o texto deste arquivo, nele encontrará apenas duas novas construções começando com palavras-chave </font></font><code>ENV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>EXPOSE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">ENV SA_LOGIC_API_URL http://localhost:5000 … EXPOSE 8080</code> </pre> <br>   <code>ENV</code>       Docker.  ,       URL    API ,   . <br><br>   <code>EXPOSE</code>   Docker  ,    .          .   ,   <code>Dockerfile</code>   <code>SA-Frontend</code>   .      ,  ,     ,    <code>Dockerfile</code> . <br><br>           ,    .           —       <code>README.md</code>   <code>sa-webapp</code> . <br><br><h3> <font color="#3AC1EF">▍    Python-</font> </h3><br>       <code>Dockerfile</code>   <code>sa-logic</code> ,         .               ,  ,        ,     <code>README.md</code>   <code>sa-logic</code> . <br><br><h3> <font color="#3AC1EF">▍  </font> </h3><br>     - ,    ?    .   . <br><br><ol><li>    <code>sa-logic</code>       <code>5050</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 5050:5000 $DOCKER_USER_ID/sentiment-analysis-logic</code> </pre> </li><li>    <code>sa-webapp</code>       <code>8080</code> .  ,    ,   Python-     Java-,    <code>SA_LOGIC_API_URL</code> : <br><br><pre> <code class="plaintext hljs">$ docker run -d -p 8080:8080 -e SA_LOGIC_API_URL='http://&lt;container_ip or docker machine ip&gt;:5000' $DOCKER_USER_ID/sentiment-analysis-web-app</code> </pre> </li></ol><br>      ,   IP-     Docker —    <a href="">README</a> . <br><br>    <code>sa-frontend</code> : <br><br><pre> <code class="plaintext hljs">docker run -d -p 80:80 $DOCKER_USER_ID/sentiment-analysis-frontend</code> </pre> <br>     ,       <code>localhost:80</code>   . <br><br>    ,       <code>sa-webapp</code> ,        Docker,     <code>App.js</code>   <code>sa-frontend</code> ,  IP-      <code>analyzeSentence()</code> ,      .         . <br><br>       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/71e/87a/79671e87adea76c8873cac180e2fe8c0.png"></div><br> <i><font color="#999999">   </font></i> <br><br><h2> <font color="#3AC1EF">:    Kubernetes?</font> </h2><br>      <code>Dockerfile</code> ,   ,         Docker.  ,     ,   <code>.dockerignore</code> .         Docker.          ,   Kubernetes.          .      : <br> ,   -      .       .  ,   <code>sa-webapp</code>  <code>sa-logic</code>     .   ,    ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438982/">https://habr.com/ru/post/pt438982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438972/index.html">O cérebro por dentro (visualização da passagem do padrão através do modelo de rede neural artificial)</a></li>
<li><a href="../pt438974/index.html">Realidade virtual ajuda a lidar com transtornos mentais</a></li>
<li><a href="../pt438976/index.html">O livro "Primavera. Todos os padrões de design »</a></li>
<li><a href="../pt438978/index.html">Aprendendo sempre e em qualquer lugar! Podcasts para desenvolvedores em inglês</a></li>
<li><a href="../pt438980/index.html">Spring Boot 2: o que há de novo?</a></li>
<li><a href="../pt438984/index.html">Guia Kubernetes, Parte 2: Criando e trabalhando com um cluster</a></li>
<li><a href="../pt438986/index.html">Tutorial Reagir Parte 14: Workshop sobre componentes baseados em classe, status do componente</a></li>
<li><a href="../pt438988/index.html">Tutorial Reagir Parte 15: Workshops sobre o estado dos componentes</a></li>
<li><a href="../pt438992/index.html">Diário do desenvolvedor ou decisões incorretas</a></li>
<li><a href="../pt438994/index.html">Intel Xeon W-3175X, um baterista quente. Teste</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>