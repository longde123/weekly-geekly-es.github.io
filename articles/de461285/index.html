<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöñ üö∂üèæ ü§∞üèª 5 Haupt-Sampling-Algorithmen ü¶ï üßîüèª ‚ú≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit Daten arbeiten - mit Datenverarbeitungsalgorithmen arbeiten. 


 Und ich musste t√§glich mit den verschiedensten arbeiten, also beschloss ich, eine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 Haupt-Sampling-Algorithmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461285/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b28/2dd/37e/b282dd37ee67bc3a63741a4f6b263815.png"></div><br><p>  Mit Daten arbeiten - mit Datenverarbeitungsalgorithmen arbeiten. </p><br><p>  Und ich musste t√§glich mit den verschiedensten arbeiten, also beschloss ich, eine Liste der beliebtesten in einer Reihe von Ver√∂ffentlichungen zu erstellen. </p><br><p>  <strong>Dieser Artikel konzentriert sich auf die g√§ngigsten Stichprobenverfahren f√ºr die Arbeit mit Daten.</strong> </p><a name="habracut"></a><br><hr><br><br><h1>  <strong>Einfache Zufallsauswahl</strong> </h1><br><p>  <em>Angenommen, Sie m√∂chten eine Auswahl treffen, bei der jedes Element die gleiche Wahrscheinlichkeit hat, ausgew√§hlt zu werden.</em> </p><br><p> Nachfolgend w√§hlen wir 100 solcher Elemente aus dem Datensatz aus. </p><br><pre><code class="python hljs">sample_df = df.sample(<span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><hr><br><h1>  <strong>Geschichtete Probenahme</strong> </h1><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/56f/edb/a5256fedba383abefb27d0d2ecd90286.jpg" width="700" height="341"></div><br><p>  Angenommen, wir m√ºssen die durchschnittliche Anzahl der Stimmen f√ºr jeden Kandidaten bei der Wahl sch√§tzen.  Die Abstimmung findet in drei St√§dten statt: </p><br><p>  1 Million Arbeiter leben in Stadt <strong>A.</strong> </p><br><p>  In Stadt <strong>B</strong> leben 2 Millionen K√ºnstler </p><br><p>  In der Stadt <strong>C</strong> leben 3 Millionen Senioren </p><br><p>  Wenn wir versuchen, gleich wahrscheinliche Stichproben von 60 Personen aus der gesamten Bev√∂lkerung zu entnehmen, sind diese wahrscheinlich im Verh√§ltnis zu verschiedenen St√§dten unausgewogen und daher voreingenommen, was zu einem schwerwiegenden Fehler in den Vorhersagen f√ºhrt. </p><br><p>  Wenn wir speziell eine Stichprobe von 10, 20 und 30 Personen aus den St√§dten <strong>A</strong> , <strong>B</strong> und <strong>C</strong> erstellen, ist der Fehler minimal. </p><br><p>  In Python kann dies folgenderma√üen geschehen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, test_size=<span class="hljs-number"><span class="hljs-number">0.25</span></span>)</code> </pre> <br><hr><br><h1>  <strong>Probenahme im Reservoir</strong> </h1><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/b0f/72f/8fdb0f72f33efad234ffce5636d0e570.jpg" width="700" height="467"></div><br><p>  Ich mag diese Formulierung des Problems: </p><br><p>  <strong><em>Angenommen, Sie haben einen Stream von Elementen einer gro√üen unbekannten Gr√∂√üe, die Sie nur einmal durchlaufen k√∂nnen.</em></strong> </p><br><p>  <strong><em>Erstellen Sie einen Algorithmus, der ein Element zuf√§llig aus dem Stream ausw√§hlt, als ob ein Element mit gleicher Wahrscheinlichkeit ausgew√§hlt werden k√∂nnte.</em></strong> </p><br><p>  Wie kann man das machen? </p><br><p>  Angenommen, wir m√ºssen 5 Objekte aus einem unendlichen Stream ausw√§hlen, damit jedes Element im Stream gleich wahrscheinlich ausgew√§hlt werden kann. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(max)</span></span></span><span class="hljs-function">:</span></span> number = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> number &lt; max: number += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> number <span class="hljs-comment"><span class="hljs-comment">#    stream = generator(10000) #    k=5 reservoir = [] for i, element in enumerate(stream): if i+1&lt;= k: reservoir.append(element) else: probability = k/(i+1) if random.random() &lt; probability: #    ,    reservoir[random.choice(range(0,k))] = element print(reservoir) ------------------------------------ [1369, 4108, 9986, 828, 5589]</span></span></code> </pre> <br><p>  Es ist mathematisch m√∂glich zu beweisen, dass jedes Element gleich wahrscheinlich ausgew√§hlt werden kann. </p><br><p>  Wie? </p><br><p>  Wenn es um Mathematik geht, versuchen Sie am besten, die L√∂sung mit einem kleinen Sonderfall zu beginnen. </p><br><p>  Schauen wir uns also einen Stream an, der aus 3 Elementen besteht, wobei wir nur 2 ausw√§hlen m√ºssen. </p><br><p>  Wir sehen das erste Element, speichern Sie es in der Liste, da noch Platz im Tank ist.  Wir sehen das zweite Element, speichern Sie es in der Liste, da noch Platz im Tank ist. </p><br><p>  Wir sehen das dritte Element.  Hier wird es interessanter.  Wir werden das dritte Element mit einer Wahrscheinlichkeit von 2/3 speichern. </p><br><p>  Lassen Sie uns nun die endg√ºltige Wahrscheinlichkeit sehen, mit der das erste Element gespeichert wird: </p><br><p>  Die Wahrscheinlichkeit der Verschiebung des ersten Elements aus dem Reservoir ist gleich der Wahrscheinlichkeit, dass das dritte Element ausgew√§hlt wird, multipliziert mit der Wahrscheinlichkeit, dass es das erste Element der beiden Elemente ist, das f√ºr die Verschiebung ausgew√§hlt wird.  Also: </p><br><p>  <b>2/3 * 1/2 = 1/3</b> </p><br><p>  Das hei√üt, die endg√ºltige Wahrscheinlichkeit, dass das erste Element gespeichert wird: </p><br><p>  <b>1 - 1/3 = 2/3</b> </p><br><p>  Auf das zweite Element kann absolut dieselbe Logik angewendet werden, die es in Zukunft mit zunehmendem Reservoir auf eine gr√∂√üere Anzahl von Elementen erweitert. </p><br><p>  Das hei√üt, jedes Element wird mit einer Wahrscheinlichkeit von <b>2/3</b> oder im allgemeinen Fall <b>k / n</b> gespeichert. </p><br><hr><br><h1>  Zuf√§lliges Unter- und √úberabtasten </h1><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef1/7fd/7b5/ef17fd7b511aa0ae67d398b3205068b8.png" width="700" height="206"></div>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a></em> <br><p>  Zu oft im Leben gibt es unausgeglichene Datens√§tze. </p><br><p>  Die in diesem Fall weit verbreitete Methode wird Resampling genannt <em>(manchmal hei√üt es in der russischen √úbersetzung ‚ÄûResampling‚Äú - ca. Transl.)</em> .  Sein Kern liegt darin, entweder Elemente aus einer zu gro√üen Menge zu entfernen (Unterabtastung) und / oder einer unzureichend gro√üen Menge weitere Elemente hinzuzuf√ºgen (√úberabtastung). </p><br><p>  Beginnen wir mit der Erstellung einiger unausgeglichener Mengen. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.datasets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> make_classification X, y = make_classification( n_classes=<span class="hljs-number"><span class="hljs-number">2</span></span>, class_sep=<span class="hljs-number"><span class="hljs-number">1.5</span></span>, weights=[<span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>], n_informative=<span class="hljs-number"><span class="hljs-number">3</span></span>, n_redundant=<span class="hljs-number"><span class="hljs-number">1</span></span>, flip_y=<span class="hljs-number"><span class="hljs-number">0</span></span>, n_features=<span class="hljs-number"><span class="hljs-number">20</span></span>, n_clusters_per_class=<span class="hljs-number"><span class="hljs-number">1</span></span>, n_samples=<span class="hljs-number"><span class="hljs-number">100</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">10</span></span> ) X = pd.DataFrame(X) X[<span class="hljs-string"><span class="hljs-string">'target'</span></span>] = y</code> </pre> <br><p>  Jetzt k√∂nnen wir zuf√§lliges Unter- und √úberabtasten wie folgt durchf√ºhren: </p><br><pre> <code class="python hljs">num_0 = len(X[X[<span class="hljs-string"><span class="hljs-string">'target'</span></span>]==<span class="hljs-number"><span class="hljs-number">0</span></span>]) num_1 = len(X[X[<span class="hljs-string"><span class="hljs-string">'target'</span></span>]==<span class="hljs-number"><span class="hljs-number">1</span></span>]) print(num_0,num_1) <span class="hljs-comment"><span class="hljs-comment">#   undersampled_data = pd.concat([ X[X['target']==0].sample(num_1) , X[X['target']==1] ]) print(len(undersampled_data)) #   oversampled_data = pd.concat([ X[X['target']==0] , X[X['target']==1].sample(num_0, replace=True) ]) print(len(oversampled_data)) ------------------------------------------------------------ OUTPUT: 90 10 20 180</span></span></code> </pre> <br><hr><br><h1>  Andersampling und Oversampling mit unausgeglichenem Lernen </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">imbalanced-learn</a> (imblearn) ist eine Python-Bibliothek zur Behandlung der Probleme unausgeglichener Datens√§tze. </p><br><p>  Es enth√§lt verschiedene Methoden zum Resampling. </p><br><h3>  a.  Andersampling mit Tomek Links: </h3><br><p>  Eine der bereitgestellten Methoden hei√üt Tomek Links.  "Links" sind in diesem Fall Paare von Elementen aus verschiedenen Klassen, die sich in der N√§he befinden. </p><br><p>  Mit dem Algorithmus entfernen wir schlie√ülich das Paarelement aus der gr√∂√üeren Menge, wodurch der Klassifikator besser arbeiten kann. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/0f9/4cb/39c0f94cbe7ea3162713d0b00fac912b.png" width="700" height="199"></div>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a></em> <br><hr><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> imblearn.under_sampling <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TomekLinks tl = TomekLinks(return_indices=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, ratio=<span class="hljs-string"><span class="hljs-string">'majority'</span></span>) X_tl, y_tl, id_tl = tl.fit_sample(X, y)</code> </pre> <br><h3>  b.  √úberabtastung mit SMOTE: </h3><br><p>  In SMOTE (Synthesis Minority Oversampling Method) erstellen wir Elemente in unmittelbarer N√§he zu vorhandenen Elementen in einer kleineren Menge. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/e7e/f4f/c57e7ef4f8711ad2eda881651a027867.png" width="700" height="215"></div>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a></em> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> imblearn.over_sampling <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SMOTE smote = SMOTE(ratio=<span class="hljs-string"><span class="hljs-string">'minority'</span></span>) X_sm, y_sm = smote.fit_sample(X, y)</code> </pre> <br><p>  In <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">imblearn</a> gibt es jedoch auch andere Methoden der Unterabtastung (Cluster Centroids, NearMiss usw.) und √úberabtastung (ADASYN und bSMOTE), die ebenfalls n√ºtzlich sein k√∂nnen. </p><br><hr><br><h1>  Fazit </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmen</a> sind das Blut der Datenwissenschaft. </p><br><p>  <strong>Die Probenahme ist einer der wichtigsten Bereiche bei der Arbeit mit Daten, und oben wird nur eine oberfl√§chliche √úbersicht gegeben.</strong> </p><br><p>  Eine gut gew√§hlte Stichprobenstrategie kann das gesamte Projekt vorantreiben.  Schlechte Auswahl f√ºhrt zu fehlerhaften Ergebnissen.  Daher muss die Wahl mit Bedacht getroffen werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461285/">https://habr.com/ru/post/de461285/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461273/index.html">Gieriger Ansatz und Spielautomaten. Analyse der Aufgaben der ML-Strecke der Programmiermeisterschaft</a></li>
<li><a href="../de461277/index.html">√úbersicht √ºber das kostenlose SQLIndexManager-Tool</a></li>
<li><a href="../de461279/index.html">So erstellen Sie einen einfachen Microservice f√ºr Golang und gRPC und containerisieren ihn mit Docker</a></li>
<li><a href="../de461281/index.html">Exemplarische Vorgehensweise zum Einrichten eines BIND-DNS-Servers in einer Chroot-Umgebung f√ºr Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../de461283/index.html">Softwarearchitektur und Systemdesign: Das Big Picture and Resource Guide</a></li>
<li><a href="../de461287/index.html">Entwicklung einer listigen KI in einem taktischen Spiel, das auf Heuristiken und Mutationen basiert</a></li>
<li><a href="../de461289/index.html">CLion 2019.2 ver√∂ffentlicht: Unterst√ºtzung f√ºr eingebettete Entwicklung, Debugger f√ºr MSVC, Suche nach nicht verwendeten Header-Dateien</a></li>
<li><a href="../de461291/index.html">Golang: spezifische Leistungsprobleme</a></li>
<li><a href="../de461297/index.html">Wie moderne gezielte Angriffe aussehen</a></li>
<li><a href="../de461299/index.html">Wie der PC die Medienbranche mit erfolgreicher Software eroberte: Er√∂rterung von Pro Tools und Media Composer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>