<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÖüèº ü§Æ üêÄ ¬øDe d√≥nde vienen los mojibakes? Fundamentos de codificaciones üíÜüèº üóÇÔ∏è ‚õπüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo explora los conceptos b√°sicos detr√°s de la codificaci√≥n de caracteres y luego profundiza en los detalles t√©cnicos de los sistemas de cod...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øDe d√≥nde vienen los mojibakes? Fundamentos de codificaciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/480688/"><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/6b/fx/u8/6bfxu80gx8ygam-qemhdptmtsvc.jpeg"></a> </p><br><p>  Este art√≠culo explora los conceptos b√°sicos detr√°s de la codificaci√≥n de caracteres y luego profundiza en los detalles t√©cnicos de los sistemas de codificaci√≥n. </p><br><p>  Si solo tiene un conocimiento b√°sico de la codificaci√≥n de caracteres y desea comprender mejor los elementos esenciales, las diferencias entre los sistemas de codificaci√≥n, por qu√© a veces terminamos con texto sin sentido y los principios detr√°s de la diferente arquitectura del sistema de codificaci√≥n, siga leyendo. </p><br><p>  Entender la codificaci√≥n de caracteres en detalle requiere una lectura extensa y una buena cantidad de tiempo.  Trat√© de ahorrarle algo de ese esfuerzo reuni√©ndolo todo en un solo lugar mientras proporciono lo que creo que es un fondo bastante completo del tema. </p><br><p>  Voy a repasar c√≥mo funcionan las codificaciones de un solo byte (ASCII, Windows-1251, etc.), la historia de c√≥mo surgi√≥ Unicode, las codificaciones basadas en Unicode UTF-8, UTF-16 y c√≥mo difieren, el caracter√≠sticas espec√≠ficas, compatibilidad y falta de ellas entre varias codificaciones, principios de codificaci√≥n de caracteres y una gu√≠a pr√°ctica sobre c√≥mo se codifican y decodifican los caracteres. </p><a name="habracut"></a><br><p>  Si bien la codificaci√≥n de caracteres puede no ser un tema de vanguardia, es √∫til comprender c√≥mo funciona ahora y c√≥mo funcion√≥ en el pasado sin perder mucho tiempo. </p><br><h3 id="history-of-unicode">  Historia de unicode </h3><br><p>  Creo que es mejor comenzar nuestra historia desde el momento en que las computadoras no eran tan avanzadas ni tan comunes como una parte de nuestras vidas como lo son ahora.  Los desarrolladores e ingenieros que intentaban crear est√°ndares en ese momento no ten√≠an idea de que las computadoras e Internet ser√≠an tan populares y dominantes como ellos.  Cuando eso sucedi√≥, el mundo necesitaba codificaciones de caracteres. </p><br><p>  Pero, ¬øc√≥mo podr√≠a tener una computadora para almacenar caracteres o letras cuando solo entend√≠a unos y ceros?  De esta necesidad surgi√≥ la primera codificaci√≥n ASCII de 1 byte, que aunque no necesariamente fue la primera codificaci√≥n, fue la m√°s utilizada y estableci√≥ el punto de referencia.  Por lo tanto, es un buen est√°ndar de uso. </p><br><p>  ¬øPero qu√© es ASCII?  El c√≥digo ASCII consta de 8 bits.  Algunos c√°lculos aritm√©ticos f√°ciles muestran que este juego de caracteres contiene 256 s√≠mbolos (ocho bits, ceros y unos 2‚Å∏ = 256). </p><br><p>  Los primeros 7 bits - 128 s√≠mbolos (2‚Å∑ = 128) en el conjunto se usaron para letras latinas, caracteres de control (como saltos de l√≠nea, pesta√±as, etc.) y s√≠mbolos gramaticales.  Las otras partes eran para idiomas nacionales.  De esta manera, los primeros 128 caracteres son siempre los mismos, y si desea codificar su idioma nativo, ay√∫dese con los s√≠mbolos restantes. </p><br><p>  Esto dio lugar a una panoplia de codificaciones nacionales.  Termina con una situaci√≥n como esta: digamos que est√° en Rusia creando un archivo de texto que, de forma predeterminada, utilizar√° Windows-1251 (la codificaci√≥n rusa utilizada en Windows).  Y env√≠a su documento a alguien fuera de Rusia, digamos en los Estados Unidos.  Incluso si el destinatario sabe ruso, no tendr√° suerte cuando abra el documento en su computadora (con el software de procesamiento de texto usando ASCII como c√≥digo predeterminado) porque ver√° caracteres extra√±os ilegibles (mojibake) en lugar de letras rusas .  M√°s precisamente, cualquier letra en ingl√©s aparecer√° bien, porque los primeros 128 s√≠mbolos en Windows-1251 y ASCII son id√©nticos, pero donde haya texto en ruso, el software de procesamiento de texto de nuestro destinatario usar√° la codificaci√≥n incorrecta a menos que el usuario haya configurado manualmente el car√°cter correcto codificaci√≥n </p><br><p>  El problema con los est√°ndares del c√≥digo de car√°cter nacional es obvio.  Y, finalmente, estos c√≥digos nacionales comenzaron a multiplicarse, Internet comenz√≥ a explotar y todos quer√≠an escribir en su idioma nacional sin producir estos mojibakes indescifrables. </p><br><p>  Hab√≠a dos opciones en este punto: usar una codificaci√≥n para cada pa√≠s o crear un mapa de caracteres universal para representar a todos los personajes del planeta. </p><br><h3 id="a-short-primer-on-ascii">  Una breve cartilla sobre ASCII </h3><br><p>  Puede parecer demasiado elemental, pero si vamos a ser minuciosos tenemos que cubrir todas las bases. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"></a> </p><br><p>  Hay 3 grupos de columnas en la tabla ASCII: </p><br><ul><li>  el valor decimal del caracter </li><li>  El valor hexadecimal del personaje </li><li>  el glifo del personaje en s√≠ </li></ul><br><p> Digamos que queremos codificar la palabra "ok" en ASCII.  La letra "o" tiene un valor decimal de 111 y 6F en hexadecimal.  En binario ser√≠a - 01101111. La letra "k" es la posici√≥n 107 en decimal y 6B en hexadecimal, o - 01101011 en binario.  Entonces la palabra "OK" en ASCII se ver√≠a como 01101111 01101011. El proceso de decodificaci√≥n ser√≠a lo opuesto.  Comenzamos con 8 bits, los traducimos a codificaci√≥n decimal y terminamos con el n√∫mero de caracteres, y buscamos en la tabla el s√≠mbolo correspondiente. </p><br><h3 id="unicode">  Unicode </h3><br><p>  De lo anterior, deber√≠a ser bastante obvio por qu√© se necesitaba un solo mapa de caracteres com√∫n.  ¬øPero c√≥mo se ver√≠a?  La respuesta es Unicode, que en realidad no es una codificaci√≥n, sino un conjunto de caracteres.  Consiste en 1,114,112 posiciones, o puntos de c√≥digo, la mayor√≠a de los cuales todav√≠a est√°n vac√≠os, por lo que no es probable que el conjunto deba expandirse. </p><br><p>  El est√°ndar Unicode consta de 17 planos con 65.536 puntos de c√≥digo cada uno.  Cada plano contiene un grupo de s√≠mbolos.  El plano cero es el plano multiling√ºe b√°sico donde encontramos los caracteres m√°s utilizados en todos los alfabetos modernos.  El segundo plano contiene caracteres de idiomas muertos.  Incluso hay dos aviones reservados para uso privado.  La mayor√≠a de los aviones todav√≠a est√°n vac√≠os. </p><br><p>  Unicode tiene puntos de c√≥digo para 0 a 10FFFF (en hexadecimal). </p><br><p>  Los caracteres est√°n codificados en formato hexadecimal precedido por una "U +".  Entonces, por ejemplo, el primer plano b√°sico incluye los caracteres U + 0000 a U + FFFF (0 a 65,535), y el bloque 17 contiene U + 100000 a U + 10FFFF (1,048,576 a 1,114,111). </p><br><p>  Ahora, en lugar de una colecci√≥n de numerosas codificaciones, tenemos una tabla que abarca todos los s√≠mbolos y caracteres que podr√≠amos necesitar.  Pero no est√° exento de fallas.  Si bien cada car√°cter se codific√≥ previamente por un byte, ahora se puede codificar utilizando diferentes n√∫meros de bytes.  Por ejemplo, sol√≠a necesitar solo un byte para codificar todas las letras del alfabeto ingl√©s.  Por ejemplo, la letra latina "o" en Unicode es U + 006F.  En otras palabras, el mismo n√∫mero que en ASCII: 6F en hexadecimal y 111 en binario.  Pero para codificar el s√≠mbolo "U + 103D5" (el n√∫mero persa "100"), necesitamos 103D5 en hexadecimal y 66.517 en decimal, y ahora necesitamos tres bytes. </p><br><p>  Esta complejidad debe abordarse mediante codificaciones Unicode como UTF-8 y UTF-16.  Y m√°s adelante los veremos. </p><br><h3 id="utf-8">  Utf-8 </h3><br><p>  UTF-8 es una codificaci√≥n Unicode del sistema de codificaci√≥n de ancho variable que se puede utilizar para mostrar cualquier s√≠mbolo Unicode. </p><br><p>  ¬øQu√© queremos decir cuando hablamos de ancho variable?  En primer lugar, debemos entender que la unidad estructural (at√≥mica) en la codificaci√≥n es un byte.  La codificaci√≥n de ancho variable significa que un car√°cter puede codificarse utilizando diferentes n√∫meros de unidades o bytes.  Por ejemplo, las letras latinas est√°n codificadas con un byte y las letras cir√≠licas con dos. </p><br><p>  Antes de continuar, un poco a un lado con respecto a la compatibilidad entre ASCII y UTF. </p><br><p>  El hecho de que las letras latinas y los caracteres de control de teclas, como saltos de l√≠nea, tabulaciones, etc.  contener un byte hace que la codificaci√≥n UTF sea compatible con ASCII.  En otras palabras, la escritura latina y los caracteres de control se encuentran exactamente en los mismos puntos de c√≥digo en ASCII y UTF y est√°n codificados usando un byte en ambos, y por lo tanto son compatibles con versiones anteriores. </p><br><p>  Usemos la letra "o" de nuestro ejemplo ASCII de antes.  Recuerde que su posici√≥n en la tabla ASCII es 111, o 01101111 en binario.  En la tabla Unicode, es U + 006F, o 01101111. Y ahora como UTF es un sistema de codificaci√≥n de ancho variable "o" ser√≠a un byte.  En otras palabras, "o" se representar√≠a de la misma manera en ambos.  Y lo mismo para los caracteres 0 - 128. Entonces, si su documento contiene letras en ingl√©s, no notar√≠a una diferencia si lo abriera usando UTF-8, UTF-16 o ASCII, y solo notar√≠a una diferencia si comenzara a trabajar con codificaciones nacionales. </p><br><p>  Veamos c√≥mo aparecer√≠a la frase mixta ingl√©s / ruso "Hola mundo" en tres sistemas de codificaci√≥n diferentes: Windows-1251 (codificaci√≥n rusa), ISO-8859-1 (sistema de codificaci√≥n para idiomas de Europa occidental), UTF-8 (Unicode) .  Este ejemplo es revelador porque tenemos una frase en dos idiomas diferentes. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/3c/xa/rk/3cxarky4ifw35kpwa2fhcoslen8.jpeg"></a> </p><br><p>  Ahora consideremos c√≥mo funcionan estos sistemas de codificaci√≥n y c√≥mo podemos traducir una l√≠nea de texto de una codificaci√≥n a otra, y qu√© sucede si los caracteres se muestran incorrectamente, o si simplemente no podemos hacer esto debido a las diferencias en los sistemas. </p><br><p>  Supongamos que nuestra frase original fue escrita con codificaci√≥n Windows-1251.  Cuando miramos la tabla de arriba podemos ver, traduciendo de decimal o hexadecimal a decimal, que obtenemos la siguiente codificaci√≥n en binario usando Windows-1251. </p><br><p>  01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000 </p><br><p>  As√≠ que ahora tenemos la frase "Hola mundo" en la codificaci√≥n de Windows-1251. </p><br><p>  Ahora imagine que tenemos un archivo de texto pero no sabemos en qu√© sistema de codificaci√≥n se guard√≥ el texto.  Asumimos que est√° codificado en ISO-8859-1 y lo abrimos en nuestro procesador de textos usando este sistema de codificaci√≥n.  Como vimos anteriormente, algunos de los caracteres parecen estar bien, ya que existen en este sistema de codificaci√≥n, e incluso est√°n en los mismos puntos de c√≥digo, pero los caracteres en la palabra rusa "mundo" no funcionan tan bien.  Estos caracteres no existen en el sistema de codificaci√≥n, y en sus lugares o puntos de c√≥digo, en ISO-8859-1 encontramos caracteres completamente diferentes.  Entonces "m" es el punto de c√≥digo 236, "y" es 232, y "p" es 240. Pero en ISO-8859-1 estos puntos de c√≥digo corresponden a "√¨" (236), "√®" (232) y " √∞ ‚Äù(240). </p><br><p>  Por lo tanto, nuestra frase de lenguaje mixto "Hello World" codificada en Windows-1251 y le√≠da en ISO-8859-1 se ver√° como "Hello √¨√®√∞".  Tenemos compatibilidad parcial y no podemos mostrar una frase codificada en un sistema correctamente en el otro, porque los s√≠mbolos que necesitamos simplemente no existen en la segunda codificaci√≥n. </p><br><p>  Necesitamos una codificaci√≥n Unicode; en nuestro caso, usaremos UTF-8 como ejemplo.  Ya hemos discutido que los caracteres pueden tomar entre 1 y 4 bytes en UTF-8, pero otra ventaja es que UTF, a diferencia de los dos sistemas de codificaci√≥n anteriores, no est√° restringido a 256 s√≠mbolos, sino que contiene todos los s√≠mbolos en el conjunto de caracteres Unicode . </p><br><p>  Funciona de la siguiente manera: el primer bit de cada car√°cter codificado no corresponde al glifo o s√≠mbolo en s√≠, sino a un byte espec√≠fico.  Entonces, si el primer bit es cero, sabemos que el s√≠mbolo codificado usa solo un byte, lo que hace que el conjunto sea compatible con ASCII.  Si observamos detenidamente la tabla de s√≠mbolos ASCII, vemos que los primeros 128 s√≠mbolos (el alfabeto ingl√©s, los caracteres de control y los signos de puntuaci√≥n) se expresan en binario, todos comienzan con un valor de bit de 0 (tenga en cuenta que si traduce caracteres a binario usando un convertidor en l√≠nea o cualquier cosa similar, el primer bit de orden superior cero puede descartarse, lo que puede ser un poco confuso). </p><br><p>  01001000: el valor del primer bit es 0, por lo que 1 byte codifica 1 car√°cter -&gt; "H". </p><br><p>  01100101: el valor del primer bit es 0, por lo que 1 byte codifica 1 car√°cter-&gt; "e". </p><br><p>  Si el valor del primer bit no es cero, el s√≠mbolo se codificar√° en varios bytes. </p><br><p>  Una codificaci√≥n de dos bytes tendr√° 110 para los primeros tres valores de bit. </p><br><p>  11010000 10111100: los bits de marcador son 110 y 10, por lo que utilizamos 2 bytes para codificar 1 car√°cter.  El segundo byte en este caso siempre comienza con "10". Por lo tanto, omitimos los bits de control (los bits principales que est√°n resaltados en rojo y verde) y miramos el resto del c√≥digo (10000111100), y lo convertimos a hexadecimal (043) -&gt; U + 043C que nos da la "m" rusa en Unicode. </p><br><p>  Los bits iniciales para un car√°cter de tres bytes son 1110. </p><br><p>  11101000 10000111 101010101: sumamos todos los bits, excepto los bits de control, y encontramos que en hexadecimal tenemos 103B5, U + 103D5, el antiguo n√∫mero persa cien (10000001111010101). </p><br><p>  Las codificaciones de caracteres de cuatro bytes comienzan con los bits iniciales 11110. </p><br><p>  11110100 10001111 10111111 10111111 - U + 10FFFF, que es el √∫ltimo car√°cter disponible en el conjunto Unicode (10000111111111111111111). </p><br><p>  Ahora, podemos escribir f√°cilmente nuestra frase en varios idiomas en codificaci√≥n UTF-8. </p><br><h3 id="utf-16">  Utf-16 </h3><br><p>  UTF-16 es otra codificaci√≥n de ancho variable.  La principal diferencia entre UTF-16 y UTF-8 es que UTF-16 usa 2 bytes (16 bits) por unidad de c√≥digo en lugar de 1 bye (8 bits).  En otras palabras, cualquier car√°cter Unicode codificado en UTF-16 puede tener dos o cuatro bytes.  Para simplificar las cosas, me referir√© a estos dos bytes como una unidad de c√≥digo.  Entonces, en UTF-16, cualquier car√°cter puede representarse utilizando una o dos unidades de c√≥digo. </p><br><p>  Comencemos con los s√≠mbolos codificados usando una unidad de c√≥digo.  Podemos calcular f√°cilmente que hay 65.535 (216) caracteres con una unidad de c√≥digo, que se alinea completamente con el plano multiling√ºe b√°sico de Unicode.  Todos los caracteres en este plano estar√°n representados por una unidad de c√≥digo (dos bytes) en UTF-16. </p><br><p>  Letra latina "o" - 00000000 01101111. </p><br><p>  Letra cir√≠lica "M" - 00000100 00011100. </p><br><p>  Ahora consideremos caracteres fuera del plano multiling√ºe b√°sico.  Estos requieren dos unidades de c√≥digo (4 bytes) y est√°n codificados de una manera un poco m√°s complicada. </p><br><p>  Primero, necesitamos definir el concepto de un par sustituto.  Un par sustituto son dos unidades de c√≥digo utilizadas para codificar un solo car√°cter (totalizando 4 bytes).  El conjunto de caracteres Unicode reserva un rango especial D800 a DFFF para pares sustitutos.  Esto significa que al convertir un par sustituto a bytes en hexadecimal, terminamos con un punto de c√≥digo en este rango que es un par sustituto en lugar de un car√°cter separado. </p><br><p>  Para codificar un s√≠mbolo en el rango de 10000 - 10FFFF (es decir, caracteres que requieren m√°s de una unidad de c√≥digo) procedemos de la siguiente manera: </p><br><ol><li><p>  Reste 10000 (hexadecimal) del punto de c√≥digo (este es el punto de c√≥digo m√°s bajo en el rango de 10000 - 10FFFF). </p><br></li><li><p>  Terminamos con un n√∫mero de hasta 20 bits no mayor que FFFF. </p><br></li><li><p>  Los 10 bits de orden superior con los que terminamos se agregan a D800 (el punto de c√≥digo m√°s bajo en el rango de pares sustitutos en Unicode). </p><br></li><li><p>  Los siguientes 10 bits se agregan a DC00 (tambi√©n del rango de pares sustitutos). </p><br></li><li><p>  A continuaci√≥n, terminamos con 2 unidades de c√≥digo sustituto de 16 bits, cuyos primeros 6 bits definen la unidad como parte de un par sustituto. </p><br></li><li><p>  El d√©cimo bit en cada sustituto define el orden del par.  Si tenemos un "1" es el sustituto principal o alto, y si tenemos un "0" es el sustituto final o bajo. </p><br></li></ol><br><p>  Esto tendr√° un poco m√°s de sentido cuando se ilustra con el siguiente ejemplo. </p><br><p>  Codifiquemos y luego decodifiquemos el n√∫mero persa cien (U + 103D5): </p><br><ol><li><p>  103D5 - 10000 = 3D5. </p><br></li><li><p>  3D5 = 0000000000 1111010101 (los 10 bits m√°s altos son cero, y cuando se convierten a hexadecimales terminamos con "0" (los primeros diez) y 3D5 (los segundos diez)). </p><br></li><li><p>  0 + D800 = D800 (1101100000000000) los primeros 6 bits nos dicen que este punto de c√≥digo cae en el rango del par sustituto, el d√©cimo bit (desde la derecha) tiene un valor "0", por lo que este es el sustituto alto. </p><br></li><li><p>  3D5 + DC00 = DFD5 (1101111111010101) los primeros 6 bits nos dicen que este punto de c√≥digo cae en el rango del par sustituto, el d√©cimo bit (desde la derecha) es un "1", por lo que sabemos que este es el sustituto bajo. </p><br></li><li><p>  El car√°cter resultante codificado en UTF-16 se ve como - 1101100000000000 1101111111010101. </p><br></li></ol><br><p>  Ahora decodifiquemos el personaje.  Digamos que tenemos el siguiente punto de c√≥digo: 1101100000100010 1101111010001000: </p><br><ol><li><p>  Convertimos a hexadecimal = D822 DE88 (ambos puntos de c√≥digo caen en el rango de pares sustitutos, por lo que sabemos que estamos tratando con un par sustituto). </p><br></li><li><p>  1101100000100010 - el d√©cimo bit (desde la derecha) es un "0", por lo que este es el sustituto alto. </p><br></li><li><p>  1101111010001000: el d√©cimo bit (desde la derecha) es un "1", por lo que este es el sustituto bajo. </p><br></li><li><p>  Ignoramos los 6 bits que identifican esto es como un sustituto y quedamos con 0000100010 1010001000 (8A88). </p><br></li><li><p>  Agregamos 10000 (el punto de c√≥digo m√°s bajo en el rango sustituto) 8A88 + 10000 = 18A88. </p><br></li><li><p>  Observamos la tabla Unicode para U + 18A88 = Tangut Component-649. </p><br></li></ol><br><p>  ¬°Felicitaciones a todos los que leen hasta aqu√≠! </p><br><p>  Espero que esto haya sido informativo sin dejarte demasiado aburrido. </p><br><p>  <strong>Tambi√©n te puede resultar √∫til:</strong> <strong><br></strong> <br>  <a href="https://unicode-table.com/en/">El conjunto de caracteres unicode</a> </p><br><p>  <a href="https://habr.com/ru/company/alconost/blog/473960/">Estrategias para la localizaci√≥n de contenido: basada en IP o navegador</a> <a href="https://habr.com/ru/company/alconost/blog/473960/"><br></a> </p><br><h3 id="about-the-translator">  Sobre el traductor </h3><br><p>  <a href="https://alconost.com/en%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Alconost</a> es un proveedor global de servicios de <a href="https://alconost.com/en/services/software-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">localizaci√≥n para aplicaciones</a> , <a href="https://alconost.com/en/services/game-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">juegos</a> , videos y <a href="https://alconost.com/en/services/website-translation%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">sitios web</a> en m√°s de 70 idiomas.  Ofrecemos traducciones de ling√ºistas nativos, pruebas ling√º√≠sticas, flujo de trabajo basado en la nube, localizaci√≥n continua, gesti√≥n de proyectos 24/7 y trabajamos con cualquier formato de recursos de cadena.  Tambi√©n hacemos <a href="https://alconost.com/en/services/video-production%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">videos</a> e im√°genes publicitarias y educativas, teasers, explicadores y trailers para Google Play y App Store. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480688/">https://habr.com/ru/post/480688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480674/index.html">Prueba de servidores virtuales de DigitalOcean, Vultr, Linode y Hetzner. Bajas humanas: 0.0</a></li>
<li><a href="../480680/index.html">Estrategia de defensa NGINX y solicitud a Igor Sysoev</a></li>
<li><a href="../480682/index.html">Intel RealSense LiDAR L515 - Otro nuevo RealSense</a></li>
<li><a href="../480684/index.html">DIY StarWars Snowflakes (upd.2019)</a></li>
<li><a href="../480686/index.html">Por qu√© rechac√© las soluciones multiplataforma en desarrollo m√≥vil</a></li>
<li><a href="../480690/index.html">Administramos persianas de pulgadas a bajo costo</a></li>
<li><a href="../480692/index.html">MobX o Redux: ¬øcu√°l es mejor para la gesti√≥n del estado de reacci√≥n?</a></li>
<li><a href="../480694/index.html">¬øPodemos dejar de llamar a la accesibilidad y usabilidad de UX?</a></li>
<li><a href="../480700/index.html">Usamos console.log () en Chrome al m√°ximo</a></li>
<li><a href="../480702/index.html">Recursos humanos y talentos, expertos y creativos: c√≥mo fue el octavo Seminario Habrase</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>