<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“– ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘¨ğŸ¿ ğŸ‘¸ğŸ¼ JPEG studi isi ulang berganda ğŸ”µ ğŸ¤·ğŸ¿ ğŸ§‘ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VK memiliki grup dengan uraian berikut: 
 Foto yang sama disimpan secara manual setiap hari ke komputer dan diunggah lagi, secara bertahap kehilangan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JPEG studi isi ulang berganda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473544/"><p>  VK memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup</a> dengan uraian berikut: </p><br><blockquote>  Foto yang sama disimpan secara manual setiap hari ke komputer dan diunggah lagi, secara bertahap kehilangan kualitas. </blockquote><p>  Di sebelah kiri adalah gambar asli yang diunggah pada 7 Juni 2012, di sebelah kanan adalah seperti sekarang. </p><br><p><img src="https://habrastorage.org/webt/k1/nd/gc/k1ndgcipxujc4rl7mplffliy3ae.jpeg" alt="KDPV"></p><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ymca5aWPurM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><p>  Perbedaan ini sangat mencurigakan.  Mari kita coba mencari tahu apa yang terjadi selama 7 tahun ini.  Untuk kenalan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> tentang Medusa tentang grup ini, tetapi hanya sisi teknis yang akan menarik perhatian kita. </p><a name="habracut"></a><br><h1 id="pochemu-i-na-kakom-etape-jpeg-szhimaet-s-poteryami">  Mengapa dan pada tahap apa JPEG menekan dengan kerugian </h1><br><p>  Pertimbangkan skema penyandian dan penguraian JPEG yang sangat disederhanakan.  Hanya operasi-operasi itu yang diperlihatkan yang menggambarkan prinsip-prinsip dasar dari algoritma JPEG. </p><br><p><img src="https://habrastorage.org/webt/bf/3l/mo/bf3lmo7c2boozc7d2id4pkqslka.png" alt="Prinsip JPEG"></p><br><p>  Jadi, 4 operasi: </p><br><ul><li>  DCT adalah transformasi kosinus diskrit. </li><li>  Kuantisasi - membulatkan setiap nilai ke kelipatan terdekat dari langkah kuantisasi: y = [x / h] * h, di mana h adalah langkah. </li><li>  IDCT adalah transformasi cosinus diskrit terbalik. </li><li>  Pembulatan adalah pembulatan normal.  Tahap ini tidak dapat ditampilkan dalam diagram, karena jelas.  Tetapi kemudian pentingnya akan ditunjukkan. </li></ul><br><p>  Warna hijau menunjukkan operasi yang menyimpan semua informasi (tanpa memperhitungkan kerugian saat bekerja dengan angka floating point), yang berwarna merah muda - hilang.  Yaitu, kerugian dan artefak muncul bukan karena transformasi cosinus, tetapi karena kuantisasi sederhana.  Artikel ini tidak akan mempertimbangkan tahap penting - pengkodean Huffman, karena dilakukan tanpa kerugian. </p><br><p>  Pertimbangkan langkah-langkah ini secara lebih rinci. </p><br><h3 id="dct">  DCT </h3><br><p>  Karena ada beberapa variasi DCT, untuk berjaga-jaga, saya akan menjelaskan bahwa JPEG menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tipe kedua DCT</a> dengan normalisasi.  Saat menyandikan, setiap gambar dibagi menjadi 8x8 kotak (untuk setiap saluran).  Setiap kotak seperti itu dapat direpresentasikan sebagai vektor 64 dimensi.  Transformasi kosinus adalah untuk menemukan koordinat vektor ini dalam basis ortonormal lain.  Sulit untuk memvisualisasikan ruang 64 dimensi, jadi analogi 2 dimensi akan diberikan di bawah ini.  Anda dapat membayangkan bahwa gambar dibagi menjadi 2x1 blok.  Dalam grafik yang akan ditampilkan di bawah ini, sumbu x sesuai dengan nilai-nilai piksel pertama dari blok, sumbu y ke yang kedua. </p><br><p>  Melanjutkan analogi dengan contoh spesifik, anggaplah bahwa nilai dua piksel dari gambar asli adalah 3 dan 4. Gambarlah vektor (3, 4) dengan dasar aslinya, seperti yang ditunjukkan pada gambar di bawah ini.  Dasar aslinya ditandai dengan warna biru.  Koordinat vektor dalam beberapa basis baru adalah (4.8, 1.4). </p><br><p><img src="https://habrastorage.org/webt/qx/dh/xk/qxdhxkiyfx4j5uyh98m1y4c1ava.png" alt="Contoh transformasi vektor dalam basis baru"></p><br><p>  Dalam contoh yang dipertimbangkan, basis baru dipilih secara acak.  DCT menawarkan dasar tetap 64-dimensi yang sangat spesifik.  Pembenaran mengapa ini digunakan dalam JPEG sangat menarik, dan dijelaskan oleh saya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> lain.  Kami hanya akan menyentuh intinya.  Secara umum, nilai semua piksel adalah setara.  Tetapi jika kita mengonversinya menggunakan DCT, maka dari 64 koordinat yang dihasilkan dalam basis baru (disebut koefisien transformasi DCT), kita dapat dengan aman memundurkan atau sekitar beberapa dari mereka, dengan kerugian minimal.  Ini dimungkinkan berkat fitur gambar yang dapat dikompres. </p><br><h3 id="kvantovanie">  Kuantisasi </h3><br><p>  Nilai pecahan tidak dapat disimpan dalam file.  Oleh karena itu, tergantung pada langkah kuantisasi, nilai 4.8, 1.4 akan disimpan sebagai berikut: </p><br><ul><li>  pada langkah 1 (opsi paling lembut): 5 dan 1, </li><li>  pada langkah 2: 4 dan 2, </li><li>  pada langkah 3: 6 dan 0. </li></ul><br><p>  Biasanya langkah yang dipilih berbeda untuk setiap nilai.  File JPEG memiliki setidaknya satu larik, yang disebut tabel kuantisasi, yang menyimpan 64 langkah kuantisasi.  Tabel ini tergantung pada kualitas kompresi yang diatur dalam editor grafis apa pun. </p><br><h3 id="idct">  IDCT </h3><br><p>  Sama seperti DCT, tetapi dengan basis yang dialihkan.  Secara matematis, x = IDCT (DCT (x)), jadi jika tidak ada kuantisasi, maka akan mungkin untuk memulihkan tanpa kehilangan.  Tetapi tidak akan ada kompresi.  Karena penggunaan kuantisasi, vektor asli tidak selalu dapat dihitung secara akurat.  Gambar berikut menunjukkan 2 contoh dengan pemulihan yang akurat dan tidak akurat.  Kisi miring sesuai dengan basis baru, garis lurus ke yang asli. </p><br><p><img src="https://habrastorage.org/webt/cl/ne/1g/clne1geexpruaosbsgwypmla0_8.png" alt="2 contoh dengan rekonstruksi vektor yang akurat dan tidak akurat"></p><br><p>  Pertanyaan yang jelas muncul: dapatkah urutan transcoding mengarah ke vektor yang sangat berbeda dari aslinya?  Mungkin </p><br><p><img src="https://habrastorage.org/webt/df/hm/ww/dfhmwwv_bcn3ru6qcgq8lrupkac.png" alt="Urutan Transcoding Vektor"></p><br><p>  Akan menarik untuk memilah-milah semua vektor integer dan melihat apa yang akan menyebabkan transcoding mereka.  Untuk mengurangi kebisingan informasi, kami menghapus kisi-kisi dasar awal dan kami akan langsung menghubungkan vektor asli dan yang direkonstruksi (tanpa langkah perantara) dengan segmen.  Pertama, pertimbangkan langkah kuantisasi sama dengan 1 untuk semua koordinat.  Basis baru pada gambar berikut diputar 45 derajat dan untuk itu kami memiliki 17,1% dari pemulihan yang tidak akurat.  Warna segmen tidak berarti apa-apa, tetapi mereka akan berguna untuk mencegah penggabungan visual mereka. </p><br><p><img src="https://habrastorage.org/webt/qv/oc/xv/qvocxvslveuyrvh76oxhqa-4tjk.png" alt="Menghitung vektor untuk basis baru pada 45 derajat"></p><br><p>  Dasar ini adalah 10,3 derajat dengan pemulihan 7,4% tidak akurat: </p><br><p><img src="https://habrastorage.org/webt/bs/ig/3k/bsig3kc6xvaiympimbjemxmz6ci.png" alt="Menghitung vektor untuk basis baru pada 10,3 derajat"></p><br><p>  Dekat: </p><br><p><img src="https://habrastorage.org/webt/zz/nx/lk/zznxlkpwk7zcgdjbzotimj5p6ho.png" alt="Menghitung vektor untuk basis baru di 10,3 derajat dekat"></p><br><p>  Dan yang ini di 10.4 dari 6.4%: </p><br><p><img src="https://habrastorage.org/webt/3j/uj/w_/3jujw_15jsspkq_gyi8ke-o-xje.png" alt="Menghitung vektor untuk basis baru pada 10,4 derajat"></p><br><p>  19 derajat dari 12,5%: </p><br><p><img src="https://habrastorage.org/webt/4o/xb/cf/4oxbcfgakefxb4jwkcna18nv_04.png" alt="Menghitung vektor untuk basis baru pada 19 derajat"></p><br><p>  Tetapi jika Anda mengatur langkah kuantisasi lebih besar dari 1, maka vektor yang direkonstruksi mulai dengan jelas berkonsentrasi dekat dengan node grid.  Ini adalah langkah 5: </p><br><p><img src="https://habrastorage.org/webt/lc/2v/uh/lc2vuhd2pk0dyvk7c3e3malrrqw.png" alt="Langkah 5"></p><br><p>  Ini 2: </p><br><p><img src="https://habrastorage.org/webt/0j/dj/wi/0jdjwier8s0zqh162fbq1k7evmw.png" alt="Langkah 2"></p><br><p>  Jika Anda mengkode ulang gambar beberapa kali, tetapi dengan nada yang sama, maka hampir tidak ada yang terjadi dibandingkan dengan pengodean ulang tunggal.  Nilai-nilai tampaknya "terjebak" di node grid dan tidak bisa lagi "melompat" dari sana ke node lain.  Jika langkahnya berbeda, maka vektor akan "melompat" dari satu simpul kisi ke yang lain.  Ini bisa membawanya ke mana saja.  Gambar berikut menunjukkan hasil 4 transkode dengan langkah 1, 2, 3, 4. Anda dapat melihat kisi besar dengan langkah 12. Nilai ini adalah kelipatan umum terkecil dari 1, 2, 3, 4. </p><br><p><img src="https://habrastorage.org/webt/t7/ee/tx/t7eetx-d2upsghi2ayvlz1jh7ra.png" alt="Hasil 4 pengodean ulang dengan langkah 1, 2, 3, 4"></p><br><p>  Dan pada ini - dengan langkah-langkah dari 1 hingga 7. Visualisasi ditampilkan hanya untuk bagian dari vektor asli untuk meningkatkan visualisasi. </p><br><p><img src="https://habrastorage.org/webt/xj/mw/t2/xjmwt2uyzvtcpjuq64xsj5qerqg.png" alt="4 hasil pengodean ulang dalam langkah 1 hingga 4"></p><br><h3 id="okruglenie">  Pembulatan </h3><br><p>  Mengapa melengkapi nilai setelah IDCT?  Lagipula, jika Anda menyingkirkan tahap ini, maka gambar yang dipulihkan akan diwakili oleh nilai fraksional, dan kami tidak akan kehilangan apa pun saat melakukan penyandian ulang.  Dari sudut pandang matematika, kita hanya akan berpindah dari satu basis ke basis lainnya tanpa kehilangan.  Perlu disebutkan di sini konversi ruang warna.  Meskipun JPEG tidak mengatur ruang warna dan memungkinkan Anda untuk menyimpan langsung dalam sumber RGB, tetapi dalam sebagian besar kasus, konversi awal ke YCbCr digunakan.  Fitur mata dan semua itu.  Dan konversi semacam itu juga menyebabkan kerugian. </p><br><p>  Misalkan kita mendapatkan file JPEG yang dikompres dengan kualitas maksimum, yaitu, dengan langkah kuantisasi 1 untuk semua koefisien.  Kita tidak tahu codec mana yang digunakan, tetapi biasanya codec melakukan pembulatan setelah konversi RGB -&gt; YCbCr.  Karena kualitasnya maksimum, setelah IDCT kami mendapatkan nilai fraksional, tetapi agak mendekati nilai aslinya di ruang YCbCr.  Jika kita berputar, maka sebagian besar dari mereka akan dipulihkan dengan tepat. </p><br><p>  Tetapi jika tidak bulat, maka karena perbedaan kecil seperti itu, konversi YCbCr -&gt; RGB bahkan dapat semakin menjauhkan mereka dari nilai-nilai asli.  Dengan transcoding berikutnya, kesenjangan akan meningkat semakin banyak.  Untuk memvisualisasikan proses ini, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode komponen utama</a> untuk memproyeksikan vektor 64-dimensi ke dalam bidang.  Kemudian untuk 1000 transkode, kami mendapatkan kira-kira urutan perubahan berikut: </p><br><p><img src="https://habrastorage.org/webt/lk/et/ii/lketiizdbzs1n3ak2ou9pm39rem.png" alt="Perubahan tanpa pembulatan"></p><br><p>  Nilai absolut dari sumbu di sini tidak masuk akal, tetapi signifikansi relatif dari distorsi dapat digunakan. </p><br><h1 id="primery-mnogokratnogo-perekodirovaniya">  Beberapa Contoh Transcoding </h1><br><p>  Sumber kucing: </p><br><p><img src="https://habrastorage.org/webt/xf/n8/uh/xfn8uhltsnwghy5mdkgffzis0jc.jpeg" alt="Sumber kucing"></p><br><p>  Setelah satu pemeliharaan ulang dengan kualitas 50: </p><br><p><img src="https://habrastorage.org/webt/lz/fh/gb/lzfhgbgntfvhase6t7z-kisz_ja.jpeg" alt="Kucing asli setelah satu pemeliharaan ulang dengan kualitas 50"></p><br><p>  Setelah jumlah transkode berikutnya dengan kualitas yang sama, gambar tidak berubah.  Sekarang kita akan secara bertahap mengurangi kualitas dari 90 menjadi 50 dalam 1: </p><br><p><img src="https://habrastorage.org/webt/br/zj/px/brzjpxgha8w0sfl_wzwzg0uybwq.jpeg" alt="Penurunan kualitas secara bertahap dari 90 menjadi 50 dalam 1"></p><br><p>  Tentang hal yang sama terjadi pada bagan di bawah ini: </p><br><p><img src="https://habrastorage.org/webt/xj/mw/t2/xjmwt2uyzvtcpjuq64xsj5qerqg.png" alt="4 hasil pengodean ulang dalam langkah 1 hingga 4"></p><br><p>  Setelah satu pemeliharaan ulang dengan kualitas 20: </p><br><p><img src="https://habrastorage.org/webt/zz/pq/lc/zzpqlcbvnfdv-af3zscizmk4eeg.jpeg" alt="Setelah satu pemeliharaan ulang dengan kualitas 20"></p><br><p>  Dari 90 hingga 20: </p><br><p><img src="https://habrastorage.org/webt/ve/3z/qo/ve3zqos_tivr6s6vw4cdgncizpw.jpeg" alt="Penurunan kualitas secara bertahap dari 90 menjadi 20"></p><br><p>  Sekarang 1000 kali dengan kualitas acak dari 80 hingga 90: </p><br><p><img src="https://habrastorage.org/webt/iw/4u/zg/iw4uzgbnuyp5x8z40dhcd-qhxfg.jpeg" alt="1000 toko ulang dengan kualitas acak dari 80 hingga 90"></p><br><p>  10.000 kali: </p><br><p><img src="https://habrastorage.org/webt/ve/eh/ww/veehwwqlhvfzy2rlk9hgjrqh2qu.jpeg" alt="10.000 toko ulang dengan kualitas acak dari 80 hingga 90"></p><br><h1 id="analiz-kartinok-gruppy-vk">  Analisis Gambar Grup VK </h1><br><p>  Mari kita mulai analisis lebih dari 2000 gambar dari grup VK.  Pertama, periksa rata-rata deviasi absolut dari awal.  Sumbu x adalah nomor gambar (atau hari), sumbu y adalah penyimpangan. </p><br><p><img src="https://habrastorage.org/webt/ln/5v/4h/ln5v4hqh-48jdun5t95ruzo0gue.png" alt="Penyimpangan absolut rata-rata dari yang pertama"></p><br><p>  Mari kita beralih ke grafik diferensial yang menunjukkan rata-rata deviasi absolut dari gambar tetangga. </p><br><p><img src="https://habrastorage.org/webt/hv/gg/i5/hvggi5lzyjh4bdyt3i2zelokkv4.png" alt="Deviasi absolut rata-rata dari gambar yang berdekatan"></p><br><p>  Fluktuasi kecil pada awalnya adalah normal.  Sampai tanggal 232, semuanya berjalan dengan baik, gambar-gambarnya benar-benar identik.  Dan tanggal 233 tiba-tiba berbeda dengan rata-rata 1,23 untuk setiap piksel (pada skala dari 0 hingga 255).  Ini banyak sekali.  Mungkin tabel kuantisasi baru saja berubah.  Lihat itu.  Dan pada saat yang sama, itu sebanding dengan ukuran file yang diterima. </p><br><p><img src="https://habrastorage.org/webt/xb/cg/qo/xbcgqoo2ifxqgr8c2gtusw64kgm.png" alt="Perubahan kualitas"></p><br><p>  Ya, tabel telah berubah.  Tapi tidak lebih awal dari tahun 700-an.  Kemudian, mungkin, transcoding tersembunyi antara dengan kualitas rendah terjadi.  Mari kita coba untuk menyandikan ulang 232 kali.  Untuk pertama kalinya, kita akan melalui tingkat kualitas yang berbeda, dan untuk yang kedua kita menggunakan tabel kuantisasi yang sama untuk semua dari 1 hingga 700-an.  Tujuan kami adalah untuk mendapatkan gambar semirip mungkin dengan yang ke-233.  Pada gambar berikut, sepanjang sumbu x adalah kualitas transcoding perantara, sepanjang y adalah penyimpangan absolut rata-rata dari 233. </p><br><p><img src="https://habrastorage.org/webt/sg/6o/ax/sg6oaxjxeqk75kwsantwy2gncbu.png" alt="Menambahkan transcoding tersembunyi"></p><br><p>  Meskipun ada kegagalan pada grafik dengan kualitas 75%, kira-kira sama dengan 1, tetapi masih jauh dari nol yang diinginkan.  Menambahkan tahap menengah ke-2 dan mengubah parameter subsampling tidak memperbaiki situasi. </p><br><p>  Dengan sisa gambar, semuanya hampir sama, ditambah perubahan dalam tabel kuantisasi juga ditumpangkan.  Artinya, pada titik tertentu, gambar berubah secara dramatis, kemudian stabil dalam beberapa hari, tetapi hanya sampai lonjakan baru terjadi.  Mungkin ada perubahan pada gambar itu sendiri di server.  Saya tidak dapat sepenuhnya mengecualikan keterlibatan administrator grup. </p><br><p>  Sayangnya, saya tidak mengetahui apa yang sebenarnya terjadi dengan gambar tersebut.  Setidaknya sekarang saya yakin itu bukan hanya pelestarian kembali.  Tetapi, yang paling penting, menjadi lebih baik untuk mewakili proses yang sedang berlangsung selama encoding dan decoding.  Semoga kamu juga. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsipkan dengan gambar</a> , untuk penelitian independen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473544/">https://habr.com/ru/post/id473544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473516/index.html">Menulis Blog Microservice - Bagian 2 dari API Gateway</a></li>
<li><a href="../id473528/index.html">Kota Tanpa Kemacetan</a></li>
<li><a href="../id473530/index.html">Pengantar untuk mengeksploitasi dan membalikkan (bukan dari awal) menggunakan IDA GRATIS dan alat gratis lainnya</a></li>
<li><a href="../id473532/index.html">Apa bahaya serangan hacker pada perangkat IoT: kisah nyata</a></li>
<li><a href="../id473534/index.html">Mengotomatiskan Perubahan Informasi OEM</a></li>
<li><a href="../id473546/index.html">Aplikasi pada TSD dan komunikasi dengan 1C: Enterprise 8.3 melalui HTTP-Service. Bagian 2 (Implementasi API di sisi 1C)</a></li>
<li><a href="../id473548/index.html">Desentralisasi PKI: Usulan Pendekatan untuk Peningkatan Keamanan</a></li>
<li><a href="../id473550/index.html">Joker 2019: Kemenangan Tahun Ini</a></li>
<li><a href="../id473552/index.html">Deanonimisasi melalui Clickjacking pada tahun 2019</a></li>
<li><a href="../id473560/index.html">Membuat API REST dengan Node.js dan Oracle Database. Bagian 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>