<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ğŸ¼ ğŸ”› ğŸ›• Kisah monolit. Bagian 2 ğŸ§›ğŸ» â˜ƒï¸ ğŸ”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel sebelumnya , saya menceritakan sejarah singkat tentang pengembangan produk internal dan eksternal DublGIS. Hari ini kita menyelami rinci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kisah monolit. Bagian 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/464869/"><img src="https://habrastorage.org/webt/ey/y4/pm/eyy4pmvrfn_bptplc1fl0vt9kpu.png"><br><br>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya menceritakan sejarah singkat tentang pengembangan produk internal dan eksternal DublGIS.  Hari ini kita menyelami rincian pengembangan salah satu produk, yaitu, ekspor data.  Saya akan berbicara tentang arsitektur proyek dan solusi teknis individual yang memungkinkan kami untuk secara bertahap mengembangkan proyek dan menyesuaikannya dengan perubahan persyaratan seiring waktu. <br><a name="habracut"></a><br><h4>  Ringkasan singkat dari artikel terakhir </h4><br>  Ada beberapa produk internal yang mengumpulkan sejumlah besar data peta, direktori organisasi, iklan, umpan balik pengguna, ulasan, foto, berbagai analitik.  Produk-produk ini saling berkomunikasi melalui bus data atau melalui Rest Api.  Dan ada proses ekspor terpisah yang mengumpulkan semua data ini dalam tumpukan, memproses dan menguraikannya dalam format yang diinginkan, mengemas dan membentuk "bundel" siap pakai untuk pengiriman ke produk akhirnya.  Pengiriman dilakukan melalui server pembaruan untuk versi PC dan seluler, atau di backend online untuk, pada kenyataannya, versi online 2GIS. <br><br><img src="https://habrastorage.org/webt/0o/v4/xl/0ov4xlhfak0bifcv8xk42nladwg.png"><br><br><h4>  Sumber data </h4><br>  Jadi, di pintu masuk kami memiliki: <br><br><ul><li>  beberapa sumber data yang sama; </li><li>  berbagai metode pengiriman (Firebird, bus, FTP, RestAPI); </li><li>  struktur berbeda dari objek yang sama; </li><li>  perubahan konstan dalam struktur data; </li><li>  format berbeda (data mentah dalam database, XML, JSON). </li></ul><br>  Dari sudut pandang konsumen: <br><br><ul><li>  sekali lagi, format yang berbeda (format datanya untuk versi produk yang berbeda, format terpisah untuk dijual); </li><li>  perubahan format konstan; </li><li>  data agregat (Anda perlu menggabungkan objek yang berbeda menjadi satu, mengumpulkan data tentang perusahaan dari semua cabang, melengkapi mereka dengan tautan ke foto, ulasan, pemberhentian terdekat, dll.); </li><li>  pra-dan pasca-pemrosesan yang rumit (memperbarui beberapa data berdasarkan yang lain, mengonversi data, menghasilkan data yang hilang, misalnya, mengatur iklan mini-logo pada bangunan, menghapus atau memperbaiki data yang salah); </li><li>  persyaratan konsistensi dan validitas data; </li><li>  <b>SEMUA</b> data dibutuhkan. </li></ul><br>  Di sini perlu fokus pada paragraf terakhir.  Seperti yang Anda ketahui, fitur utama 2GIS adalah pekerjaan offline.  Artinya, sebagian besar data yang Anda lihat di versi PC dan seluler kami ada di perangkat Anda.  Tapi ini adalah susunan besar: ratusan ribu objek geo (laut, hutan, sungai, jalan, bangunan, pintu masuk, beranda, tanda tangan, denah lantai, model 3D), puluhan dan ratusan ribu perusahaan dan cabangnya dengan kontak, jam kerja, atribut tambahan seperti tagihan rata-rata dan ketersediaan Wi-Fi.  Dan, tentu saja, mengiklankan teks dan gambar. <br><br>  Dan semuanya terus berubah, ditambahkan, dihapus. <br><br>  Dan agar tidak tenggelam dalam arus perubahan tanpa akhir ini, ketika mengembangkan arsitektur ekspor, kami harus fokus pada beberapa bidang utama: <br><br><ul><li>  sumber data; </li><li>  metode pengiriman; </li><li>  algoritma pemrosesan; </li><li>  format data konsumen. </li></ul><br><h4>  Kami abstrak dari berbagai sumber dan format data </h4><br>  Berbagai sumber memperkenalkan kesulitan-kesulitan berikut: <br><br><ul><li>  mereka memberikan data yang sama dalam berbagai format; </li><li>  memiliki sekumpulan entitas atau atribut yang berbeda yang perlu direduksi menjadi satu objek domain. </li></ul><br>  Ini adalah masalah yang cukup standar, dan diselesaikan sebagai standar.  Kita hanya perlu membuat antarmuka untuk menerima data, dan implementasi spesifik sudah berjalan di tempat yang diperlukan dan akan mendapatkan data dalam bentuk yang kita butuhkan. <br><br><img src="https://habrastorage.org/webt/wh/sg/tx/whsgtxlho1otzxvy2lc1kniydnq.png"><br><br>  Contoh antarmuka: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface ISource : IDisposable { <span class="hljs-function"><span class="hljs-function">ISourceReader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDeletedRows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ISourceReader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInsertedOrUpdatedRows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; byte[] GetDataVersion(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> interface ISourceReader : IDisposable { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; object <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> columnName] { get; } }</code> </pre> <br>  Contoh penerapan perusahaan yang mendapatkan: <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirmSetSource</span></span></span><span class="hljs-class"> :</span></span> ISource { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ISourceReader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDeletedRows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_lastDataVersion == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; var query = DataContext.ExecuteObject&lt;EsbFirmDeleted&gt;(_lastDataVersion); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeletedIdsSourceReader&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;( query.Select(x =&gt; x.Id).GetEnumerator()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ISourceReader </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInsertedOrUpdatedRows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnumeratorSourceReader(typeof(FirmSet), GetNewOrChangedRows().GetEnumerator()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> byte[] GetDataVersion() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataContext.ExecuteObject&lt;EsbFirm&gt;().Max(x =&gt; x.RowVersion); } }</code> </pre><br>  Abstraksi ini sebagian memungkinkan kita untuk menyelesaikan masalah dengan perbedaan dalam model domain, tetapi tidak sepenuhnya.  Keterbatasan yang signifikan adalah kebutuhan untuk menerima data secara bertahap, yaitu, hanya menerima pembaruan mereka, dan tidak menghisap semuanya setiap saat.  Dalam hal ini, agak tidak nyaman untuk melacak hubungan antara data untuk mengumpulkan beberapa agregat.  Dan relatif sulit untuk melakukan semuanya tanpa kesalahan.  Oleh karena itu, kami memutuskan bahwa pada tahap ini kami akan mengekstraksi data dari sumber satu ke satu, dan kami akan menyelesaikan masalah dengan model domain pada tingkat yang berbeda. <br><br><h4>  Model domain </h4><br>  Agar tidak bergantung pada perubahan dalam kumpulan data dan strukturnya dalam sumber data, basis data ekspor dibuat dengan daftar tabel yang relatif stabil, yang pada akhirnya jatuh pada domain kami.  Jika sumber 1 tidak memiliki atribut untuk entitas A (Objek Data pada gambar berikutnya), maka mereka menerima nilai default atau opsional.  Dan jika entitas B adalah semacam agregat dari data sumber atau bahkan sumber yang berbeda, maka setiap bagian dapat diperoleh secara terpisah dan kemudian dikumpulkan secara keseluruhan di tahap berikutnya. <br><br><img src="https://habrastorage.org/webt/xe/yl/8j/xeyl8jchpmefkzixpxnojxxenje.png"><br><br><h4>  Kami abstrak dari metode pengiriman data </h4><br>  Bahkan, memiliki database Anda sendiri dalam ekspor dan tampilan antarmuka <i>ISourceReader</i> sudah menyelesaikan masalah ini.  Tetapi ada satu titik yang tidak terselesaikan: model akuisisi data yang sedikit berbeda.  Dalam satu kasus, kami menarik dan mendapatkan snapshot pada saat saat ini, di yang lain - delta perubahan pada bus, di ketiga - juga status saat ini pada saat permintaan, tetapi dengan informasi tentang objek yang dihapus dari saat permintaan sebelumnya. <br><br>  Untuk membawa keseragaman ke kebun binatang ini, kami akan menambahkan satu lagi basis data yang akan kami gabungkan semua data dari semua sumber. <br><br>  Anda mendapatkan gambar seperti itu. <br><br><img src="https://habrastorage.org/webt/bn/vu/d7/bnvud7u46kgmhbmgzxr2rcsv-l4.png"><br><br>  Akibatnya, kami membaca semua data dari saluran mana saja di semua kota ke basis data pusat.  Hampir selalu pengiriman bersifat inkremental, yaitu hanya perubahan yang datang.  DGPP lama, saat masih hidup, tetap menjadi sumber alternatif.  Mampu memompa data dari satu DBMS ke yang lain tidak ada. <br><br>  Selanjutnya, ekspor melalui ISource menarik data kota dari DGPP atau EMDB ke dalam basis data sinkronisasi yang stabil dan mengubahnya menjadi model domainnya. <br><br>  Kemudian tinggal memprosesnya dan mengunggahnya dalam format konsumen. <br><br><h4>  Mengabstraksi dari algoritma persiapan data </h4><br>  Dan di sini muncul satu kesulitan lagi.  Pertama, konsumen yang berbeda menginginkan data dalam format mereka.  Selain itu, mereka menginginkan set data yang berbeda.  Dan dalam lampiran, data offline harus sekompak dan terstruktur mungkin sehingga dapat dibaca dengan cepat.  Sebagai hasilnya, kami mendapatkan format biner yang dikembangkan oleh tim produk akhir.  Dan ini adalah orang-orang yang bekerja pada tumpukan teknologi yang sama sekali berbeda.  Kami memiliki familiar dan tercinta untuk mengembangkan .NET backend dan terkadang Java, mereka terutama memiliki C ++ dan python. <br><br>  Secara umum, kebun binatang teknologi. <br><br>  Pada awal perkembangan pesat, ketika kami hanya memiliki DGPP (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelumnya) dan versi PC 2GIS, format data akhir adalah binar, yang disiapkan oleh perpustakaan khusus yang ditulis dalam C ++ dan dibungkus dengan objek COM.  Tampaknya bukan integrasi kode heterogen.  Kami menghubungkan referensi, antarmuka .NET dihasilkan - dan mengendarainya.  Dan pertama kali kami melakukannya. <br><br>  Tapi, seperti biasa, beberapa masalah muncul. <br><br><ol><li>  Data kami mulai tumbuh dengan cepat.  Jenis data baru muncul, kota-kota besar baru seperti Moskow. </li><li>  OS X64-bit mulai menyebar secara aktif. </li><li>  Masalah dalam COM perlu di-debug entah bagaimana. </li></ol><br>  Mari kita bahas poinnya. <br><br>  Pertumbuhan data yang sangat dibutuhkan oleh produk kami telah menyebabkan fakta bahwa pemrosesan mereka mulai mengkonsumsi sejumlah besar RAM.  Dan setelah menghubungkan pustaka COM ke proses .NET x86 kami, kami secara otomatis menerima proses x86, yaitu, maksimum operator 3Gb dengan ruang alamat yang ditingkatkan.  Tim tidak memiliki dukungan pustaka untuk sumber daya x64, tetapi pustaka itu sendiri memiliki kemampuan untuk menggunakan disk, bukan memori, yang agak mengurangi masalah. <br><br>  Tetapi debugging masih sangat sulit.  Itu perlu untuk memulai ekspor, menunggu untuk menyiapkan data, mulai menambahkan data ini ke perpustakaan.  Dan setelah kesalahan muncul, Anda perlu memahami dari log apa yang salah dan ulangi proses itu lagi.  Tidak bagus, sangat buruk. <br><br>  Solusinya seperti biasa di permukaan.  Sudah cukup untuk mengambil semua kode asing ke dalam proses terpisah, dan menjalin komunikasi melalui file perantara dalam format biner atau teks sederhana. <br><br><img src="https://habrastorage.org/webt/it/iz/3z/itiz3zov4vs_st9jlsexawhwlsg.png"><br><br>  Akibatnya, proses .NET asli kami menjadi sepenuhnya cpu.  Tidak ada kebocoran memori atau kesalahan kritis dalam kode pihak ketiga tidak lagi mempengaruhinya.  Ekspor menyiapkan data, mengunggahnya ke file perantara, memasukkannya ke utilitas dan menerima hasilnya dari itu juga dalam bentuk file.  Orang-orang dari tim pihak ketiga menulis algoritma mereka dalam bahasa mereka (C ++ atau Python) dan dapat men-debug mereka pada data nyata jika terjadi kesalahan pada mesin mereka tanpa perlu mulai mengekspor. <br><br>  Kami hanya perlu membuat perjanjian pada antarmuka utilitas, yang disediakan dengan runtime, memiliki daftar parameter yang disepakati, dan menampilkan pesan informasi dan kesalahan dalam stdout dalam format yang diperlukan. <br><br><img src="https://habrastorage.org/webt/lt/ja/15/ltja15n_x-u5dgdycaju5vuud1u.png"><br>  <i>Contoh format teks menengah</i> <br><br><h4>  Ringkasan </h4><br>  Dalam artikel itu, saya berbicara tentang beberapa pendekatan yang kami gunakan di berbagai tingkat aplikasi untuk mengisolasi proses persiapan data: <br><br><ul><li>  menyembunyikan detail akses ke sumber data di balik antarmuka; </li><li>  diabstraksi dari saluran pengiriman data menggunakan penyimpanan perantara; </li><li>  buat domain stabil Anda dan konversikan data asli ke dalamnya; </li><li>  melakukan setiap tahapan pemrosesan data menjadi proses dan kode yang digunakan dalam bahasa lain. </li></ul><br>  Terima kasih sudah sampai di akhir.  Saya akan menjawab semua pertanyaan di komentar, pastikan untuk bertanya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464869/">https://habr.com/ru/post/id464869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464859/index.html">Mengontrol beberapa motor stepper Nema 17 secara bersamaan atau NemaStepper</a></li>
<li><a href="../id464861/index.html">Referensi dan Panduan Scrum Mini</a></li>
<li><a href="../id464863/index.html">Natas Web. Passage dari platform KKP bertujuan untuk mengeksploitasi kerentanan Web. Bagian 4</a></li>
<li><a href="../id464865/index.html">Telegram sebagai gudang data untuk proyek-proyek TI</a></li>
<li><a href="../id464867/index.html">"Penghapus"</a></li>
<li><a href="../id464871/index.html">15 buku pembelajaran mesin untuk pemula</a></li>
<li><a href="../id464873/index.html">Mengapa melakukan operasi dengan mata uang di bursa: 3 skenario praktis</a></li>
<li><a href="../id464877/index.html">Berita dari dunia OpenStreetMap No. 473 (08/06/2019 - 12/08/2019)</a></li>
<li><a href="../id464881/index.html">Menyesuaikan komposisi tes JUnit5 dengan application.properties</a></li>
<li><a href="../id464883/index.html">Ke mana Jaringan menuju</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>