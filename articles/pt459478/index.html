<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶â üíÄ ‚¨áÔ∏è Minha experi√™ncia na cria√ß√£o de um aplicativo multithread para trabalhar com backups üëéüèº ü§õüèª üôå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No momento, voc√™ n√£o surpreender√° ningu√©m com aplicativos multithread, mas acho que neste artigo voc√™ pode encontrar algumas id√©ias interessantes. Meu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minha experi√™ncia na cria√ß√£o de um aplicativo multithread para trabalhar com backups</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  No momento, voc√™ n√£o surpreender√° ningu√©m com aplicativos multithread, mas acho que neste artigo voc√™ pode encontrar algumas id√©ias interessantes.  Meu estudo de Java come√ßou com esse projeto em particular; talvez, em alguns lugares, eu esteja muito errado ou construa uma bicicleta grande, mas espero que algu√©m se interesse pela experi√™ncia de um iniciante em Java.  Vou dar v√°rios recursos do aplicativo: </p><br><ul><li>  Funciona com backups exclusivamente na mem√≥ria, independentemente do tamanho do backup </li><li>  N√£o carrega o backup inteiro na mem√≥ria </li><li>  As opera√ß√µes de backup / restaura√ß√£o podem ser canceladas </li></ul><br><p>  Sob o corte ser√° considerada a arquitetura do aplicativo, bem como os principais problemas encontrados e sua solu√ß√£o. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Vis√£o geral do aplicativo </h2><br><p>  A comunica√ß√£o com o aplicativo ocorre por meio da UI da Web, mas no futuro ser√° poss√≠vel adicionar uma API REST, se necess√°rio. </p><br><p>  O aplicativo pode: </p><br><ol><li>  Crie backups e envie-os para um ou mais armazenamentos </li><li>  Restaurar backups carregando-os do armazenamento </li><li>  Excluir backups de todos os armazenamentos </li><li>  Crie backups periodicamente </li></ol><br><p>  Reposit√≥rios atualmente suportados: </p><br><ul><li>  Sistema de arquivos local (n√£o suportado no Docker) </li><li>  Dropbox </li></ul><br><p>  Bancos de dados atualmente suportados: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  De um aplicativo especial, posso observar: </p><br><ol><li>  Trabalho correto em uma configura√ß√£o de cluster </li><li>  Um backup nunca √© totalmente carregado na mem√≥ria, independentemente do tamanho do backup.  O sistema de arquivos para armazenamento de backup tempor√°rio tamb√©m n√£o est√° envolvido.  A cria√ß√£o de um backup e a restaura√ß√£o e, portanto, o carregamento / descarregamento de um backup, ocorrem exclusivamente na mem√≥ria. </li><li>  Plataforma cruzada - funciona em Windows e Linux. </li><li>  Podemos monitorar todas as tarefas em execu√ß√£o e cancel√°-las, se necess√°rio. </li></ol><br><p>  Abaixo est√£o as capturas de tela da interface do usu√°rio da Web que descrevem claramente os recursos do aplicativo. </p><br><div class="spoiler">  <b class="spoiler_title">Gerenciamento de armazenamento</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Adicionando armazenamento"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Lista de armazenamento"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Gerenciamento de banco de dados</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Adicionando um banco de dados"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Lista de bancos de dados"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Cria√ß√£o de backup</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Cria√ß√£o de backup"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Recupera√ß√£o de backup</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="Recupera√ß√£o de backup"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Gerenciar backups criados</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Lista de backups criados"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backups peri√≥dicos</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Crie uma tarefa peri√≥dica"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Controlar tarefas em execu√ß√£o</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Lista de tarefas em execu√ß√£o"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  Arquitetura </h2><br><p>  O trabalho principal ser√° realizado em tr√™s servi√ßos - <em>DatabaseBackup</em> , <em>Processor</em> , <em>Storage</em> , e n√≥s os conectaremos usando o <em>conceito de tarefas</em> .  Sobre tudo isso ainda mais. </p><br><h3 id="databasebackup">  Databasebackup </h3><br><p>  Este servi√ßo √© respons√°vel por criar e restaurar backups em texto sem formata√ß√£o. </p><br><p>  Interface de servi√ßo: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Os dois m√©todos de interface operam nas inst√¢ncias <strong>InputStream</strong> , pois precisamos que o backup inteiro n√£o seja carregado na mem√≥ria, o que significa que o backup deve ser lido / gravado no modo de streaming.  A entidade <em>DatabaseSettings</em> √© pr√©-criada a partir da interface da Web da Web e armazena as v√°rias configura√ß√µes necess√°rias para acessar o banco de dados.  O que √© esse par√¢metro - <code>id</code> - ser√° explicado um pouco mais. </p><br><p>  Os requisitos de servi√ßo s√£o os seguintes: </p><br><ol><li>  Ambos os m√©todos n√£o devem ler o backup inteiro na mem√≥ria. </li><li>  O m√©todo <code>restoreBackup()</code> deve restaurar o backup em uma √∫nica transa√ß√£o, para que, em caso de erro, n√£o deixe o banco de dados em um estado inconsistente. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Implementa√ß√£o para PostgreSQL (descri√ß√£o do texto)</b> <div class="spoiler_text"><p>  Especificamente, na implementa√ß√£o do PostgreSQL, o servi√ßo √© implementado da seguinte maneira: </p><br><ol><li>  <code>createBackup()</code> : √© criado um processo <em>pg_dump</em> que cria um backup e o grava no fluxo de sa√≠da padr√£o.  O fluxo de sa√≠da do processo padr√£o √© retornado do m√©todo (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  Os fluxos de E / S no sistema s√£o baseados em um buffer de um determinado tamanho e, quando um processo grava no fluxo de sa√≠da, ele realmente grava no buffer na mem√≥ria.  O mais importante aqui √© que o encadeamento do processo n√£o ser√° gravado no buffer <em>preenchido</em> at√© que o √∫ltimo tenha sido lido pelo outro lado, o que significa que o encadeamento estar√° em um estado bloqueado e o backup n√£o ser√° carregado completamente na mem√≥ria.  Voc√™ pode ter encontrado uma situa√ß√£o em que seu programa Java travou um impasse ao trabalhar com processos devido ao fato de voc√™ n√£o ter lido o stdout ou stderr do processo.  √â extremamente importante monitorar isso, porque o processo n√£o pode continuar se estiver bloqueado em uma chamada de bloqueio de E / S ao gravar em um buffer completo e ningu√©m l√™ esse buffer. </li><li>  <code>restoreBackup()</code> : um processo <em>psql</em> √© criado, o backup √© lido a partir do <code>restoreBackup()</code> passado para o m√©todo e √© gravado simultaneamente no fluxo de entrada padr√£o psql (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process. html # getOutputStream--</a> ).  Isso funciona porque o backup PostgreSQL em texto simples √© apenas uma cole√ß√£o de comandos DDL e DML que s√£o f√°ceis de entender o psql. </li></ol><br><p>  H√° muito c√≥digo, por isso n√£o o darei aqui, mas voc√™ pode v√™-lo no GitHub usando o link no final do artigo. </p></div></div><br><h3 id="processor">  Processador </h3><br><p>  Este servi√ßo √© respons√°vel pelo uso de processadores e pelo reprocessamento de backup reverso.  Os processadores s√£o usados ‚Äã‚Äãantes do download para armazenamento ou ap√≥s o descarregamento do armazenamento.  Exemplo de processador: compressor, criptografia. </p><br><p>  Interface de servi√ßo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Cada processador tem prioridade - se v√°rios processadores forem especificados, eles ser√£o aplicados em ordem decrescente de prioridade.  Aplicando a fun√ß√£o inversa na mesma ordem em que os processadores foram aplicados, obtemos o backup original. </p><br><h3 id="storage">  Armazenamento </h3><br><p>  Este servi√ßo √© respons√°vel por carregar e descarregar um backup, bem como por sua remo√ß√£o do armazenamento.  Exemplo de armazenamento: Dropbox, sistema de arquivos local. </p><br><p>  Interface de servi√ßo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Cada backup criado recebe um nome exclusivo - para que possamos encontr√°-lo em qualquer um dos armazenamentos para os quais foi baixado.  A maneira como o backup √© apresentado ao armazenamento √© uma quest√£o exclusiva da implementa√ß√£o do servi√ßo, mas ao transferir o nome do backup para uma das fun√ß√µes, devemos esperar o comportamento correto.  A entidade <em>StorageSettings</em> √© pr√©-criada a partir da interface da Web da Web e armazena as configura√ß√µes necess√°rias para acessar o armazenamento. </p><br><hr><br><h3 id="koncepciya-taskov">  Conceito de tarefa </h3><br><p>  Gostar√≠amos de poder rastrear o status de nossas tarefas, lidar com poss√≠veis erros, dependendo do andamento da tarefa, e tamb√©m cancelar tarefas.  Portanto, continuaremos a operar apenas com tarefas.  Cada tarefa ser√° representada no banco de dados por um registro na tabela e programaticamente pela inst√¢ncia <strong>Future</strong> (consulte Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Future</a> ).  Cada registro na tabela est√° associado ao seu pr√≥prio futuro (al√©m disso, se v√°rios servidores estiverem em execu√ß√£o, as inst√¢ncias do futuro poder√£o estar na mem√≥ria de diferentes servidores). </p><br><p>  Vamos sequencialmente.  Primeiro de tudo, precisamos de um servi√ßo para iniciar tarefas - criar, restaurar e excluir backups. </p><br><h4 id="zapusk-zadach">  In√≠cio da tarefa </h4><br><p>  <strong>Criando um backup:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  A cria√ß√£o de um backup realiza tr√™s etapas principais na seguinte ordem: cria√ß√£o de um backup -&gt; aplicativo de processadores -&gt; upload para armazenamento.  Em quase todos os m√©todos de servi√ßo, encaminhamos o ID da tarefa atual para que o servi√ßo possa relatar um erro de um encadeamento que funciona em segundo plano.  Sobre o tratamento de erros, por que o <em>InterruptedException</em> est√° aqui e o que acontece com um erro ap√≥s o recebimento de um <em>RuntimeException</em> ser√° discutido mais adiante. </p><br><p>  E aqui est√° como executaremos a tarefa de criar um backup: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  O primeiro par√¢metro que passamos ao iniciador da tarefa: o usu√°rio ou a tarefa interna do servidor (um exemplo de tarefa interna √© um backup peri√≥dico).  O conhecimento do iniciador de tarefas nos permite mostrar na interface da Web da Web apenas as tarefas que foram iniciadas pelo usu√°rio.  Os par√¢metros restantes s√£o necess√°rios para criar um backup diretamente - uma lista de armazenamentos, processadores a serem usados, um banco de dados cujo dump voc√™ precisa criar. </p><br><p>  Ao criar um backup, tamb√©m √© criado um registro no banco de dados chamado <strong>BackupProperties</strong> .  Essa entidade armazenar√° propriedades de backup, como nome, processadores usados ‚Äã‚Äãe a lista de reposit√≥rios nos quais o backup foi baixado.  Al√©m disso, para restaurar ou excluir o backup, operaremos com essa entidade espec√≠fica. </p><br><p>  A tarefa no banco de dados √© armazenada no seguinte formato: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  Assim, voc√™ pode descrever o processo de cria√ß√£o de um backup na forma de um diagrama da seguinte maneira: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="  " title="Processo de backup"></p><br><hr><br><p>  Outros tipos de tarefas s√£o iniciados por analogia.  Para n√£o sobrecarregar o artigo com uma enorme quantidade de c√≥digo, para os curiosos, darei o c√≥digo para iniciar tarefas para restaurar e excluir backup separadamente no spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">Recupera√ß√£o de backup</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  A restaura√ß√£o de um backup realiza tr√™s etapas principais na seguinte ordem: descarregando um backup do armazenamento -&gt; usando deprocessadores para obter o backup em texto sem formata√ß√£o original -&gt; restaurando um backup. </p><br><p>  Inicie a recupera√ß√£o da seguinte maneira: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  O processo de restaura√ß√£o de um backup na forma de um diagrama: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="Processo de recupera√ß√£o de backup" title="Processo de recupera√ß√£o de backup"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Excluir backup</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  O processo de exclus√£o de um backup √© bastante simples: um backup √© simplesmente exclu√≠do de todos os armazenamentos para os quais foi baixado. </p><br><p>  Execute a desinstala√ß√£o da seguinte maneira: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  O processo de exclus√£o de um backup na forma de um diagrama: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="Processo de remo√ß√£o de backup" title="Processo de remo√ß√£o de backup"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Cancelar tarefa </h3><br><p>  O que √© cancelamento de tarefa?  Obviamente, isso nada mais √© do que um encerramento de thread.  Voc√™ pode ver que todo o c√≥digo principal em execu√ß√£o no Future est√° agrupado na seguinte constru√ß√£o try-catch: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  E tamb√©m ap√≥s cada m√©todo importante, cujo fluxo de execu√ß√£o controlamos, a seguinte constru√ß√£o √© instalada: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Antes de prosseguir, uma breve teoria das interrup√ß√µes e estados dos encadeamentos da JVM deve ser fornecida. </p><br><p>  Os encadeamentos na JVM podem ter os seguintes estados: </p><br><ol><li>  Novo </li><li>  Execut√°vel </li><li>  Espera cronometrada </li><li>  Esperando </li><li>  Bloqueado </li><li>  Terminado </li></ol><br><p>  Estamos interessados ‚Äã‚Äãapenas nos estados Em espera e Em espera temporizada.  O <code>Object.wait()</code> no estado <em>Waiting</em> pelos m√©todos <code>Object.wait()</code> , <code>Thread.join()</code> e outros.  O encadeamento √© colocado no estado de <em>espera Temporizada</em> (ou seja, uma espera que dura um certo per√≠odo de tempo) usando os m√©todos <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> e outros. </p><br><p>  O mais importante aqui √© que, se voc√™ interromper o encadeamento <em>antes de entrar no estado Em</em> espera ou Em espera temporizada, ou quando o encadeamento <em>estiver nesse estado</em> , o encadeamento ser√° ativado, lan√ßando uma <strong>InterruptedException</strong> . </p><br><p>  Mas isso n√£o √© tudo.  N√£o √© de todo um fato que um encadeamento entre nos dados do estado criando, restaurando ou excluindo um backup.  Como ent√£o informar o thread que foi interrompido? </p><br><p>  A primeira maneira √© verificar independentemente o sinalizador de interrup√ß√£o com o thread usando os m√©todos Thread.interrupted <code>Thread.interrupted()</code> ou <code>Thread.currentThread.isInterrupted()</code> .  A diferen√ßa entre eles √© que o primeiro chama o m√©todo nativo particular <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , passando <code>true</code> , indicando que o sinalizador de interrup√ß√£o ser√° limpo e o segundo passando <code>false</code> , deixando o sinalizador de interrup√ß√£o intacto.  A escolha entre esses dois m√©todos depende inteiramente da situa√ß√£o.  Quando uma InterruptedException √© lan√ßada, o sinalizador de interrup√ß√£o tamb√©m √© limpo - vale a pena lembrar. </p><br><p>  Mas deve haver um caminho mais f√°cil - e √©.  No aplicativo, h√° uma enorme quantidade de trabalho com fluxos de E / S e, portanto, com m√©todos de E / S.  Nossa tarefa √© garantir que, ao chamar os m√©todos <code>read()</code> ou <code>write(int b)</code> no fluxo de E / S, seja gerado um erro durante a interrup√ß√£o, informando que a chamada de E / S bloqueada foi interrompida.  Felizmente, o Java tem essa exce√ß√£o - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">InterruptedIOException</a> .  No entanto, nem todos os m√©todos de fluxo de leitura / grava√ß√£o monitoram interrup√ß√µes de encadeamento e, especificamente, apenas o <em>PipedInputStream o</em> monitora.  Portanto, nos locais em que esse fluxo n√£o est√° envolvido, devemos estender o m√©todo de leitura / grava√ß√£o para que, quando houver uma interrup√ß√£o, uma InterruptedIOException seja lan√ßada.  De fato, a extens√£o do m√©todo read () foi suficiente para mim no aplicativo apenas em um lugar - quando o InputStream retornou do m√©todo de upload de backup.  √â assim que podemos aprender sobre a origem de uma interrup√ß√£o sem precisar colocar verifica√ß√µes de modelo na bandeira em todos os lugares.  No entanto, √© importante capturar essa exce√ß√£o separadamente do IOException e manipul√°-la separadamente.  Obviamente, voc√™ n√£o pode prescindir da ajuda de uma verifica√ß√£o de modelo da bandeira em alguns lugares, mas ela se tornou melhor. </p><br><p>  Tamb√©m √© importante observar que, se o sinalizador foi apagado durante o processamento da interrup√ß√£o, √© sempre necess√°rio configur√°-lo novamente para que, ap√≥s retornar do m√©todo, possamos descobrir a interrup√ß√£o que ocorreu. </p><br><p>  Deixe-me explicar com um exemplo por que isso √© importante.  Suponha que fa√ßamos o upload de um backup para o armazenamento no m√©todo upload () e ocorra uma interrup√ß√£o.  A interrup√ß√£o √© processada, o trabalho √© interrompido e o m√©todo retorna.  A interrup√ß√£o n√£o ocorre com casualidade - significa que ocorreu um erro em algum lugar ou o usu√°rio cancelou a tarefa.  Independentemente do motivo, devemos interromper todo o trabalho neste futuro.  Mas se voc√™ n√£o definir o sinalizador de interrup√ß√£o novamente antes de retornar do m√©todo de inicializa√ß√£o, nunca saberemos no bloco principal do futuro a interrup√ß√£o que ocorreu. <br>  O mesmo exemplo de c√≥digo: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Portanto, √© uma boa pr√°tica manipular uma <strong>InterruptedException</strong> ou <strong>InterruptedIOException da</strong> seguinte maneira: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Bem, podemos lidar com a interrup√ß√£o, mas quem realmente interromper√° os threads? <br>  Para fazer isso, criaremos outra entidade chamada <em>CancelTask</em> , que armazenar√° o ID da tarefa para cancelamento e tamb√©m escreveremos um rel√≥gio que tentar√° interromper as tarefas.  Por que tentar?  Porque: </p><br><ol><li>  N√£o foi poss√≠vel finalizar o encadeamento na mem√≥ria de outro servidor.  V√°rios servidores podem trabalhar para n√≥s, o que significa que o Future est√° espalhado em diferentes servidores.  Assim, quando uma solicita√ß√£o para cancelar uma tarefa chega em um dos servidores, o futuro desejado pode estar na mem√≥ria de outro servidor. </li><li>  A tarefa n√£o pode ser cancelada porque o Future foi perdido devido a uma falha no servidor. </li></ol><br><p>  Descreva brevemente o algoritmo de cancelamento √† noite: <br>  Watercher pega todos os registros da tabela <em>cancel_tasks</em> (ao mesmo tempo, o bloqueio n√£o est√° definido), passa por cada um e tenta obter o futuro correspondente de sua mem√≥ria.  Se o futuro for recebido com √™xito, o encadeamento correspondente ser√° interrompido, a tarefa ser√° revertida e a solicita√ß√£o ser√° exclu√≠da da tabela.  Se a solicita√ß√£o de tempo limite para cancelar a tarefa for excedida (o que significa que o servidor travou e o futuro foi perdido) - a solicita√ß√£o √© simplesmente exclu√≠da da tabela.  Se v√°rios servidores notarem um tempo limite e excluir o registro da tabela, nada de ruim acontecer√°, porque a exclus√£o no PostgreSQL √© idempotente. </p><br><p>  <strong>CancelTasksWatcher Code:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Texto oculto</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Tratamento de erros </h4><br><p>    ,    ,   Future,    try-catch : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  ‚Äî  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos analisar as poss√≠veis situa√ß√µes: </font></font></p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> ‚Äî    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> ‚Äî  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> ‚Äî       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       ‚Äî       Future. </p><br><p>   ,      ,    ,      I/O ,          ‚Äî     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      ‚Äî     . </li><li>     ‚Äî     Future   ,   .  , /   ,  ,     (  ,     ‚Äî    IOException  ,        ,   ). </li></ol><br><p>  ,   ‚Äî            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Conclus√£o </h3><br><p>   : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459478/">https://habr.com/ru/post/pt459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459464/index.html">Lua em Moscou 2019: entrevista com Roberto Jerusalem</a></li>
<li><a href="../pt459466/index.html">Lua em Moscou 2019: Entrevista com Roberto Ierusalimschy</a></li>
<li><a href="../pt459470/index.html">Parte 4: Ainda executando o Linux no RISC-V RISC-V</a></li>
<li><a href="../pt459472/index.html">Heroku + Docker + Bota de primavera</a></li>
<li><a href="../pt459474/index.html">Como criar texto perfeitamente digitado em um segundo: uma macro no Word para quem escreve muito</a></li>
<li><a href="../pt459480/index.html">Vivaldi: Como o navegador ganha dinheiro?</a></li>
<li><a href="../pt459482/index.html">Como derrotamos a √°rvore de categorias</a></li>
<li><a href="../pt459484/index.html">Gera√ß√£o Arduino. O que os estudantes modernos inventam</a></li>
<li><a href="../pt459488/index.html">Modos de jogo especiais no contexto de Roguelike</a></li>
<li><a href="../pt459490/index.html">Truques sujos de fornecedores de CRM: voc√™ compraria um carro sem rodas?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>