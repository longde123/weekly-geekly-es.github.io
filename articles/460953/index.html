<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö±Ô∏è ‚úã ü§òüèø Los punteros son complejos, ¬øo qu√© se almacena en un byte? üë©üèø‚Äçü§ù‚Äçüë®üèæ ü§© üïí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Le presento la traducci√≥n del art√≠culo "Los punteros son complicados o: ¬øqu√© hay en un byte?" autor√≠a de Ralf Jung. 


 Este verano estoy t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los punteros son complejos, ¬øo qu√© se almacena en un byte?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Hola Habr!  Le presento la traducci√≥n del art√≠culo "Los punteros son complicados o: ¬øqu√© hay en un byte?"  autor√≠a de Ralf Jung. </p><br><p>  Este verano estoy trabajando en Rust a tiempo completo nuevamente, y nuevamente (entre otras cosas) trabajar√© en un "modelo de memoria" para Rust / MIR.  Sin embargo, antes de hablar sobre mis ideas, finalmente debo disipar el mito de que "los punteros son simples: son solo n√∫meros".  Ambas partes de esta declaraci√≥n son err√≥neas, al menos en lenguajes con caracter√≠sticas inseguras, como Rust o C: los punteros no se pueden llamar n√∫meros primos o (ordinarios). </p><br><p>  Tambi√©n me gustar√≠a discutir la parte del modelo de memoria que debe abordarse antes de que podamos hablar sobre las partes m√°s complejas: <em>¬ø</em> de <em>qu√© forma se</em> almacenan <em>los</em> datos en la memoria?  Una memoria consta de bytes, unidades direccionables m√≠nimas y los elementos m√°s peque√±os a los que se puede acceder (al menos en la mayor√≠a de las plataformas), pero ¬øcu√°les son los posibles valores de bytes?  Nuevamente, resulta que "es solo un n√∫mero de 8 bits" no es adecuado como respuesta. <a name="habracut"></a></p><br><p>  Espero que despu√©s de leer esta publicaci√≥n, est√©n de acuerdo conmigo con respecto a ambas declaraciones. </p><br><h1 id="ukazateli-slozhny">  Los punteros son complicados </h1><br><p>  ¬øCu√°l es el problema con "los punteros son n√∫meros regulares"?  Veamos el siguiente ejemplo: (Aqu√≠ uso C ++, ya que escribir c√≥digo inseguro en C ++ es m√°s f√°cil que escribir en Rust, y el c√≥digo inseguro es el lugar donde aparecen los problemas. Rust inseguro y C tienen los mismos problemas que y C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Optimizar la √∫ltima lectura de y [0] con un retorno de 42 siempre es muy beneficioso.  La raz√≥n de esta optimizaci√≥n es que cambiar x_ptr que apunta a x no puede cambiar y. </p><br><p>  Sin embargo, cuando se trata de lenguajes de bajo nivel como C ++, podemos violar esta suposici√≥n asignando i el valor yx.  Como &amp; x [i] es lo mismo que x + i, escribimos 23 en &amp; y [0]. </p><br><p>  Por supuesto, esto no impide que los compiladores de C ++ hagan tales optimizaciones.  Para resolver esto, el est√°ndar dice que nuestro c√≥digo tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UB</a> . </p><br><p>  En primer lugar, no est√° permitido realizar operaciones aritm√©ticas en punteros (como en el caso de &amp; x [i]), si en este caso el puntero <a href="">va m√°s all√° de cualquiera de los l√≠mites de la matriz</a> .  Nuestro programa viola esta regla: x [i] va m√°s all√° de x, por lo que es UB.  En otras palabras, incluso <em>calcular</em> el valor x_ptr es UB, por lo que ni siquiera llegamos al lugar donde queremos <em>usar</em> este puntero. </p><br><p>  (Resulta que i = yx tambi√©n es UB, ya que <a href="">solo</a> se <a href="">pueden restar los punteros que apuntan a la misma asignaci√≥n de memoria</a> . Sin embargo, podr√≠amos escribir i = ((size_t) y - (size_t) x) / sizeof (int) para omitir esto es una limitaci√≥n) </p><br><p>  Pero a√∫n no hemos terminado: esta regla tiene la √∫nica excepci√≥n que podemos usar para nuestro beneficio.  Si la operaci√≥n aritm√©tica calcula el valor del puntero a la direcci√≥n <em>exactamente despu√©s del</em> final de la matriz, entonces todo est√° en orden.  (Esta excepci√≥n es necesaria para calcular vec.end () para los bucles m√°s comunes en C ++ 98.) </p><br><p>  Cambiemos un poco el ejemplo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Ahora imagine que x e y fueron asignados <em>uno tras otro</em> , con y teniendo una direcci√≥n m√°s grande.  Entonces x_ptr apunta <em>al comienzo de</em> y!  Entonces la condici√≥n es verdadera y ocurre la asignaci√≥n.  Al mismo tiempo, no hay UB debido a la salida del puntero al extranjero. </p><br><p>  Parece que esto no permitir√° la optimizaci√≥n.  Sin embargo, el est√°ndar C ++ tiene otro as bajo la manga para ayudar a los creadores del compilador: de hecho, no nos permite usar x_ptr.  De acuerdo con lo que dice el est√°ndar sobre <a href="">agregar n√∫meros a los punteros</a> , x_ptr apunta a la direcci√≥n despu√©s del √∫ltimo elemento de la matriz.  No apunta a un elemento espec√≠fico de otro objeto, <em>incluso si tienen la misma direcci√≥n</em> .  (Al menos, esta es una interpretaci√≥n com√∫n del est√°ndar basado en el cual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LLVM optimiza este c√≥digo</a> ). </p><br><p>  Y aunque x_ptr e &amp; y [0] apuntan a la misma <em>direcci√≥n</em> , esto no los convierte en el <em>mismo puntero</em> , es decir, no pueden usarse indistintamente: &amp; y [0] apunta al primer elemento de y;  x_ptr apunta a la direcci√≥n despu√©s de x.  Si reemplazamos * x_ptr = 23 con la cadena * &amp; y [0] = 0, cambiaremos el valor del programa, aunque se haya verificado la igualdad de los dos punteros. </p><br><p>  Vale la pena repetir esto: </p><br><blockquote>  El hecho de que dos punteros apunten a la misma direcci√≥n no significa que sean iguales y se puedan usar indistintamente. </blockquote><p>  S√≠, esta diferencia es esquiva.  De hecho, esto todav√≠a causa diferencias en los programas compilados con LLVM y GCC. </p><br><p>  Tambi√©n tenga en cuenta que esta regla de uno despu√©s no es el √∫nico lugar en C / C ++ donde podemos observar dicho efecto.  Otro ejemplo es la palabra clave restringir en C, que se puede usar para expresar que los punteros no se superponen (no son iguales): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  La llamada test () llama a UB, ya que dos accesos de memoria en foo no deber√≠an ocurrir en la misma direcci√≥n.  Reemplazando * y con * x en foo, cambiaremos el valor del programa y ya no llamar√° a UB.  Una vez m√°s: aunque x e y tienen la misma direcci√≥n, no se pueden usar indistintamente. </p><br><p>  Los punteros definitivamente no son solo n√∫meros. </p><br><h1 id="prostaya-model-ukazateley">  Modelo de puntero simple </h1><br><p>  Entonces, ¬øqu√© es un puntero?  No s√© la respuesta completa.  De hecho, esta es un √°rea abierta para la investigaci√≥n. </p><br><p>  Un punto importante: aqu√≠ estamos viendo un <em>modelo de</em> puntero <em>abstracto</em> .  Por supuesto, en una computadora real, los punteros son n√∫meros.  Pero una computadora real no lleva a cabo las optimizaciones que hacen los compiladores de C ++ modernos.  Si escribi√©ramos los programas anteriores en ensamblador, entonces no habr√≠a UB, ni optimizaciones.  C ++ y Rust adoptan un enfoque m√°s de "nivel superior" para la memoria y los punteros, limitando el programador al compilador.  Cuando es necesario describir formalmente lo que un programador puede y no puede hacer en estos lenguajes, el modelo de punteros como n√∫meros se rompe, por lo que necesitamos encontrar algo m√°s.  Este es otro ejemplo del uso de una "m√°quina virtual" diferente de una computadora real para fines de especificaci√≥n, una idea sobre la que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escrib√≠ anteriormente</a> . </p><br><p>  Aqu√≠ hay una oraci√≥n simple (de hecho, este modelo de punteros es utilizado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CompCert</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi trabajo por RustBelt</a> , as√≠ como la forma en que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">int√©rprete miri</a> implementa los <a href="">punteros</a> ): un puntero es un par de alguna ID que identifica de forma √∫nica un √°rea de memoria (asignaci√≥n), y el desplazamiento es relativo a esta zona  Si escribes esto en Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  Las operaciones de sumar (restar) un n√∫mero a un puntero (de un puntero) afectan solo el desplazamiento y, por lo tanto, el puntero nunca puede abandonar el √°rea de memoria.  Restar punteros solo es posible si pertenecen a la misma √°rea de memoria (de acuerdo con <a href="">C ++</a> ). </p><br><p>  (Como podemos ver, el est√°ndar C ++ aplica estas reglas a las matrices, no a las √°reas de memoria. Sin embargo, LLVM las aplica a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nivel de √°rea</a> ). </p><br><p>  Resulta (y miri muestra lo mismo) que este modelo nos puede servir bien.  Siempre recordamos a qu√© regi√≥n de memoria pertenece el puntero, por lo que podemos distinguir el puntero de una regi√≥n de memoria del puntero al comienzo de otra regi√≥n.  Por lo tanto, miri puede encontrar que nuestro segundo ejemplo (con &amp; x [8]) tiene UB. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Nuestro modelo se est√° desmoronando </h1><br><p>  En nuestro modelo, los punteros, aunque no son n√∫meros, son al menos simples.  Sin embargo, este modelo comenzar√° a desmoronarse ante nuestros ojos, tan pronto como recuerde la conversi√≥n de punteros a n√∫meros.  En miri, lanzar un puntero a un n√∫mero en realidad no hace nada, solo obtenemos una variable num√©rica (es decir, su <em>tipo</em> dice que es un n√∫mero) cuyo <em>valor</em> es un puntero (es decir, un par de √°rea de memoria y desplazamiento).  Sin embargo, multiplicar este n√∫mero por 2 conduce a un error, ya que no est√° completamente claro lo que significa "multiplicar un puntero abstracto de este tipo por 2". </p><br><p>  Debo aclarar: esta <em>no</em> es <em>una</em> buena soluci√≥n cuando se trata de definir la sem√°ntica de un lenguaje.  Sin embargo, esto funciona bien para el int√©rprete.  Este es el enfoque m√°s simple, y lo elegimos porque no est√° claro c√≥mo se puede hacer de otra manera (excepto para no admitir tales reducciones en absoluto, pero con su soporte miri puede ejecutar m√°s programas): en nuestra m√°quina abstracta no hay un solo "espacio de direcciones", en el que se ubicar√≠an todas las √°reas de memoria asignadas, y todos los punteros se asignaron a n√∫meros diferentes espec√≠ficos.  Cada √°rea de memoria se identifica mediante una ID (oculta).  Ahora podemos comenzar a agregar datos adicionales a nuestro modelo, como la direcci√≥n de base para cada √°rea de memoria, y de alguna manera usarlo para devolver el n√∫mero al puntero ... y en este punto el proceso se vuelve realmente muy complicado y, en cualquier caso, una discusi√≥n sobre esto Los modelos no tienen el prop√≥sito de escribir una publicaci√≥n.  Su prop√≥sito es discutir la necesidad de tal modelo.  Si est√° interesado, le recomiendo que lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este documento</a> , que analiza m√°s de cerca la idea anterior de agregar una direcci√≥n base. </p><br><p>  En resumen, los modelos de punteros y n√∫meros entre s√≠ son confusos y dif√≠ciles de determinar formalmente, dadas las optimizaciones discutidas anteriormente.  Existe un conflicto entre el enfoque de alto nivel necesario para las optimizaciones y el enfoque de bajo nivel necesario para describir los indicadores de conversi√≥n a n√∫meros y viceversa.  En su mayor parte, simplemente ignoramos este problema en miri y, siempre que sea posible, intentamos hacer todo lo posible utilizando el modelo simple con el que trabajamos.  Una definici√≥n completa de lenguajes como C ++ o Rust, por supuesto, no puede ser tan simple, deber√≠a explicar lo que realmente est√° sucediendo.  Hasta donde yo s√©, no hay una soluci√≥n adecuada, pero la investigaci√≥n acad√©mica se est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acercando a la verdad</a> . </p><br><p>  Es por eso que los punteros tampoco son simples. </p><br><h1 id="ot-ukazateley-k-baytam">  De punteros a bytes </h1><br><p>  Espero haber hecho un argumento razonablemente convincente de que los n√∫meros no son el √∫nico tipo de datos a considerar si queremos describir formalmente lenguajes de bajo nivel como C ++ o la parte (insegura) de Rust.  Sin embargo, esto significa que una operaci√≥n simple como leer un byte de la memoria no puede devolver u8.  Imagine que <a href="">implementamos memcpy</a> leyendo cada byte de la fuente a su vez en alguna variable local v, y luego almacenamos este valor en la ubicaci√≥n de destino.  Pero, ¬øqu√© pasa si este byte es parte de un puntero?  Si el puntero es un par de ID de √°rea de memoria y desplazamiento, ¬øcu√°l ser√° su primer byte?  Necesitamos decir cu√°l es el valor de v, por lo que tendremos que responder de alguna manera a esta pregunta.  (Y este es un problema completamente diferente al problema con la multiplicaci√≥n, que estaba en la secci√≥n anterior. Simplemente asumimos que hay alg√∫n tipo abstracto de Ponter). </p><br><p>  No podemos representar el byte del puntero como un valor del rango 0..256 (nota: en adelante 0 est√° activado, 256 no lo est√°).  En general, si usamos un modelo de representaci√≥n de memoria ingenuo, la parte extra "oculta" del puntero (la que lo hace m√°s que un simple n√∫mero) se perder√° cuando el puntero se escriba en la memoria y se vuelva a leer.  Tendremos que arreglar esto, y para esto tendremos que expandir nuestro concepto de "byte" para representar este estado adicional.  Por lo tanto, el byte es ahora <em>el</em> valor del rango 0..256 ("bits en bruto") <em>o</em> el en√©simo byte de alg√∫n puntero abstracto.  Si tuvi√©ramos que implementar nuestro modelo de memoria en Rust, podr√≠a verse as√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Por ejemplo, PtrFragment (ptr, 0) representa el primer byte del puntero ptr.  Por lo tanto, memcpy puede "dividir" el puntero en bytes separados que representan este puntero en la memoria y copiarlos individualmente.  En una arquitectura de 32 bits, la representaci√≥n ptr completa contendr√° 4 bytes: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Esta representaci√≥n admite todas las operaciones de mover datos sobre punteros a nivel de byte, lo cual es suficiente para memcry.  Las operaciones aritm√©ticas o de bits no son totalmente compatibles;  como se se√±al√≥ anteriormente, esto requerir√≠a una representaci√≥n m√°s compleja de punteros. </p><br><h1 id="neinicializirovannaya-pamyat">  Memoria no inicializada </h1><br><p>  Sin embargo, no hemos terminado con nuestra definici√≥n de "byte".  Para describir completamente el comportamiento del programa, debemos considerar otra opci√≥n: un byte en la memoria puede <em>no</em> ser <em>inicializado</em> .  La √∫ltima definici√≥n de byte se ver√° as√≠ (supongamos que tenemos un tipo de puntero para punteros): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Usamos el valor Uninit para todos los bytes en la memoria asignada en la que a√∫n no hemos escrito ning√∫n valor.  Es posible leer la memoria no inicializada sin problemas, pero cualquier otra <em>acci√≥n</em> con estos bytes (por ejemplo, aritm√©tica num√©rica) conduce a UB. </p><br><p>  Esto es muy similar a las reglas de LLVM con respecto al valor de veneno especial.  Tenga en cuenta que LLVM <em>tambi√©n</em> tiene un valor undef, que se utiliza para la memoria no inicializada y funciona de manera un poco diferente.  Sin embargo, compilar nuestro Uninit en undef es correcto (undef es de alguna manera "m√°s d√©bil"), y hay sugerencias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para eliminar undef de LLVM y usar veneno en su lugar</a> . </p><br><p>  Quiz√°s se pregunte por qu√© tenemos un valor especial de Uninit.  ¬øPor qu√© no elegir algunos b: u8 arbitrarios para cada nuevo byte y luego usar Bits (b) como valor inicial?  Esta es realmente una opci√≥n.  Sin embargo, en primer lugar, todos los compiladores llegaron al enfoque utilizando un valor especial para la memoria no inicializada.  No seguir este enfoque significa no solo causar problemas de compilaci√≥n a trav√©s de LLVM, sino tambi√©n revisar todas las optimizaciones y asegurarse de que funcionen correctamente con este modelo modificado.  El punto clave aqu√≠: siempre puede reemplazar Uninit de forma segura con cualquier otro valor: cualquier operaci√≥n que reciba este valor en cualquier caso conducir√° a UB. </p><br><p>  Por ejemplo, este c√≥digo C es m√°s f√°cil de optimizar con Uninit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Con Uninit, podemos decir f√°cilmente que x tiene un valor de Uninit o un valor de 1, y dado que reemplazar Uninit con 1 funciona, la optimizaci√≥n se explica f√°cilmente.  Sin Uninit, x es "alg√∫n tipo de patr√≥n de bits arbitrario" o 1, y la misma optimizaci√≥n es m√°s dif√≠cil de explicar. </p><br><p>  (Podemos argumentar que podemos intercambiar operaciones cuando hacemos una elecci√≥n no determinista, pero luego tendremos que demostrar que el c√≥digo que es dif√≠cil de analizar no usa x de ninguna manera. Uninit evita este problema con evidencia innecesaria). </p><br><p>  Finalmente, Uninit es la mejor opci√≥n para int√©rpretes como miri.  Dichos int√©rpretes tienen problemas con operaciones como "simplemente seleccione cualquiera de estos valores" (es decir, operaciones no deterministas), ya que tienden a recorrer todas las rutas posibles de ejecuci√≥n del programa, lo que significa que necesitan probar todos los valores posibles.  El uso de Uninit en lugar de un patr√≥n de bits arbitrario significa que miri puede decirle despu√©s de la ejecuci√≥n de un programa si su programa usa valores no inicializados incorrectamente. </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>  Vimos que en lenguajes como C ++ y Rust (a diferencia de las computadoras reales) los punteros pueden ser diferentes incluso si apuntan a la misma direcci√≥n, y que un byte es m√°s que solo un n√∫mero en el rango 0..256.  Por lo tanto, si en 1978 el lenguaje C podr√≠a ser "ensamblador port√°til", ahora es una declaraci√≥n incre√≠blemente err√≥nea. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460953/">https://habr.com/ru/post/460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460943/index.html">C√≥mo elegir claves prometedoras para SEO basadas en pron√≥sticos de escenarios en Google Data Studio (+ plantilla)</a></li>
<li><a href="../460945/index.html">Experiencia en el uso de un canal de telegramas para aumentar el reconocimiento y el crecimiento de los ingresos de un estudio de juegos.</a></li>
<li><a href="../460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../460949/index.html">"Y lo imposible es posible": convertimos un cuadro negro en blanco mediante an√°lisis binario</a></li>
<li><a href="../460951/index.html">Crear fondos de pantalla animados de Android</a></li>
<li><a href="../460955/index.html">Programa educativo para pasar par√°metros por valor a constructores y setters (C ++ moderno, ejemplos)</a></li>
<li><a href="../460959/index.html">La nueva tecnolog√≠a de Microsoft permite que las copias en 3D de una persona real hablen cualquier idioma</a></li>
<li><a href="../460961/index.html">Configuraci√≥n de pruebas unitarias en proyectos mixtos Swift + Objective-C</a></li>
<li><a href="../460965/index.html">Controlador dividido sin estos tus guiones gr√°ficos</a></li>
<li><a href="../460967/index.html">Troy Hunt: 10 lecciones financieras personales para profesionales de la tecnolog√≠a de la informaci√≥n</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>