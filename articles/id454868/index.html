<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤐 🈚️ ↪️ Kompilasi C di WebAssembly tanpa Emscripten 🕗 🤴🏼 🈂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kompiler adalah bagian dari Emscripten . Tetapi bagaimana jika Anda menghapus semua peluit dan hanya meninggalkannya? 

 Emscripten diperlukan untuk m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilasi C di WebAssembly tanpa Emscripten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454868/">  Kompiler adalah bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emscripten</a> .  Tetapi bagaimana jika Anda menghapus semua peluit dan hanya meninggalkannya? <br><br>  Emscripten diperlukan untuk mengkompilasi C / C ++ ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebAssembly</a> .  Tapi ini lebih dari sekedar kompiler.  Tujuan Emscripten adalah untuk sepenuhnya mengganti kompiler C / C ++ Anda dan menjalankan kode di web yang awalnya <b>tidak dirancang</b> untuk Web.  Untuk ini, Emscripten mengemulasi seluruh sistem operasi POSIX.  Jika program menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fopen ()</a> , maka Emscripten akan memberikan emulasi sistem file.  Jika OpenGL digunakan, Emscripten akan memberikan konteks GL yang kompatibel dengan C yang didukung oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebGL</a> .  Ini banyak pekerjaan, dan banyak kode yang harus diimplementasikan dalam paket akhir.  Tapi bisakah Anda ... menghapusnya? <br><a name="habracut"></a><br>  <i>Kompilator</i> aktual dalam toolkit Emscripten adalah LLVM.  Dialah yang menerjemahkan kode C ke dalam bytecode WebAssembly.  Ini adalah kerangka kerja modular modern untuk analisis, transformasi dan optimalisasi program.  LLVM bersifat modular dalam arti tidak pernah dikompilasi secara langsung ke dalam kode mesin.  Alih-alih, <i>kompiler front-end bawaan</i> menghasilkan <i>representasi perantara</i> (IR).  Representasi perantara ini, pada kenyataannya, disebut LLVM, kependekan dari Low-Level Virtual Machine, karenanya nama proyek. <br><br>  <i>Kompiler backend kemudian</i> menerjemahkan IR ke dalam kode mesin host.  Keuntungan dari pemisahan ketat ini adalah bahwa arsitektur baru didukung oleh penambahan "sederhana" dari kompiler baru.  Dalam hal ini, WebAssembly hanyalah salah satu dari banyak tujuan kompilasi yang didukung LLVM, dan untuk beberapa waktu telah diaktifkan dengan flag khusus.  Dimulai dengan LLVM 8, target kompilasi WebAssembly tersedia secara default. <br><br>  Di MacOS, Anda dapat menginstal LLVM menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">homebrew</a> : <br><br><pre><code class="bash hljs">$ brew install llvm $ brew link --force llvm</code> </pre> <br>  Periksa dukungan WebAssembly: <br><br><pre> <code class="bash hljs">$ llc --version LLVM (http://llvm.org/): LLVM version 8.0.0 Optimized build. Default target: x86_64-apple-darwin18.5.0 Host CPU: skylake Registered Targets: <span class="hljs-comment"><span class="hljs-comment"># …,  … systemz - SystemZ thumb - Thumb thumbeb - Thumb (big endian) wasm32 - WebAssembly 32-bit # ! ! ! wasm64 - WebAssembly 64-bit x86 - 32-bit X86: Pentium-Pro and above x86-64 - 64-bit X86: EM64T and AMD64 xcore - XCore</span></span></code> </pre> <br>  Sepertinya kita sudah siap! <br><br><h1>  Kompilasi C dengan Hard Way </h1><br><blockquote>  <b>Catatan:</b> berikut adalah beberapa format RAW WebAssembly tingkat rendah.  Jika Anda merasa sulit untuk dipahami, ini normal.  <b>Penggunaan WebAssembly yang baik tidak memerlukan pemahaman seluruh teks dalam artikel ini.</b>  <b>Jika Anda mencari kode untuk menempelkan salinan, lihat panggilan ke kompiler di bagian Optimasi</b> .  Tetapi jika Anda tertarik, teruslah membaca!  Saya sebelumnya menulis pengantar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Webassembly</a> dan WAT <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">murni</a> : ini adalah dasar yang diperlukan untuk memahami posting ini. </blockquote>  Peringatan: Saya akan sedikit menyimpang dari standar dan mencoba menggunakan format yang dapat dibaca manusia di setiap langkah (sejauh mungkin).  Program kami di sini akan sangat sederhana untuk menghindari situasi perbatasan dan tidak terganggu: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Filename: add.c int add(int a, int b) { return a*a + b; }</span></span></code> </pre> <br>  Sungguh prestasi teknik yang luar biasa!  Terutama karena program ini disebut <i>add</i> , tetapi pada kenyataannya ia tidak <i>menambahkan</i> apa-apa (tidak menambah).  Lebih penting lagi: program tidak menggunakan pustaka standar, dan dari jenis di sini, hanya 'int'. <br><br><h3>  Mengubah C menjadi Tampilan LLVM Internal </h3><br>  Langkah pertama adalah mengubah program C kami menjadi LLVM IR.  Ini adalah tugas dari compiler frontend <code>clang</code> , yang diinstal dengan LLVM: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ <span class="hljs-comment"><span class="hljs-comment"># Target WebAssembly -emit-llvm \ # Emit LLVM IR (instead of host machine code) -c \ # Only compile, no linking just yet -S \ # Emit human-readable assembly rather than binary add.c</span></span></code> </pre> <br>  Dan sebagai hasilnya, kita mendapatkan <code>add.ll</code> dengan representasi internal dari LLVM IR.  <b>Saya tunjukkan hanya demi kelengkapan</b> .  Saat bekerja dengan WebAssembly atau bahkan dentang, Anda sebagai pengembang C tidak <i>akan</i> pernah berhubungan dengan LLVM IR. <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'add.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"add.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-i64:64-n32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"wasm32"</span></span> ; Function Attrs: norecurse nounwind readnone define hidden i32 @add(i32, i32) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">3</span></span> = mul nsw i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">4</span></span> } attributes #<span class="hljs-number"><span class="hljs-number">0</span></span> = { norecurse nounwind readnone <span class="hljs-string"><span class="hljs-string">"correctly-rounded-divide-sqrt-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"disable-tail-calls"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"less-precise-fpmad"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"min-legal-vector-width"</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-string"><span class="hljs-string">"no-frame-pointer-elim"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-infs-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-jump-tables"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-nans-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-signed-zeros-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-trapping-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"stack-protector-buffer-size"</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span> <span class="hljs-string"><span class="hljs-string">"target-cpu"</span></span>=<span class="hljs-string"><span class="hljs-string">"generic"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"use-soft-float"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> } !llvm.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.flags = !{!<span class="hljs-number"><span class="hljs-number">0</span></span>} !llvm.ident = !{!<span class="hljs-number"><span class="hljs-number">1</span></span>} !<span class="hljs-number"><span class="hljs-number">0</span></span> = !{i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, !<span class="hljs-string"><span class="hljs-string">"wchar_size"</span></span>, i32 <span class="hljs-number"><span class="hljs-number">4</span></span>} !<span class="hljs-number"><span class="hljs-number">1</span></span> = !{!<span class="hljs-string"><span class="hljs-string">"clang version 8.0.0 (tags/RELEASE_800/final)"</span></span>}</code> </pre> <br>  <i>LLVM IR penuh dengan metadata dan anotasi tambahan, yang memungkinkan kompiler membuat keputusan yang lebih tepat ketika membuat kode mesin.</i> <br><br><h3>  Ubah LLVM IR menjadi file objek </h3><br>  Langkah selanjutnya adalah memanggil kompiler backend <code>llc</code> untuk membuat file objek dari representasi internal. <br><br>  <code>add.o</code> keluaran <code>add.o</code> sudah menjadi modul WebAssembly yang valid yang berisi semua kode yang dikompilasi dari file C. Tetapi biasanya Anda tidak akan dapat menjalankan file objek karena mereka tidak memiliki bagian-bagian penting. <br><br>  Jika kita <code>-filetype=obj</code> dalam perintah, kita akan mendapatkan assembler LLVM untuk WebAssembly, format yang dapat dibaca manusia yang agak mirip dengan WAT.  Namun, alat <code>llvm-mc</code> untuk bekerja dengan file tersebut belum sepenuhnya mendukung format dan sering tidak dapat memproses file.  Oleh karena itu, kami membongkar file objek setelah fakta.  Diperlukan alat khusus untuk memverifikasi file objek ini.  Dalam kasus WebAssembly, itu adalah <code>wasm-objdump</code> , bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebAssembly Binary Toolkit</a> atau singkatnya. <br><br><pre> <code class="bash hljs">$ brew install wabt <span class="hljs-comment"><span class="hljs-comment"># in case you haven't $ wasm-objdump -x add.o add.o: file format wasm 0x1 Section Details: Type[1]: - type[0] (i32, i32) -&gt; i32 Import[3]: - memory[0] pages: initial=0 &lt;- env.__linear_memory - table[0] elem_type=funcref init=0 max=0 &lt;- env.__indirect_function_table - global[0] i32 mutable=1 &lt;- env.__stack_pointer Function[1]: - func[0] sig=0 &lt;add&gt; Code[1]: - func[0] size=75 &lt;add&gt; Custom: - name: "linking" - symbol table [count=2] - 0: F &lt;add&gt; func=0 binding=global vis=hidden - 1: G &lt;env.__stack_pointer&gt; global=0 undefined binding=global vis=default Custom: - name: "reloc.CODE" - relocations for section: 3 (Code) [1] R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x000080) symbol=1 &lt;env.__stack_pointer&gt;</span></span></code> </pre> <br>  Output menunjukkan bahwa fungsi add () kami ada di modul ini, tetapi juga berisi bagian <i>khusus</i> dengan metadata dan, yang mengejutkan, beberapa impor.  Pada tahap <i>penautan selanjutnya,</i> bagian khusus akan dianalisis dan dihapus, dan penaut (penghubung) akan berurusan dengan impor. <br><br><h3>  Tata letak </h3><br>  Secara tradisional, tugas penghubung adalah untuk merakit beberapa file objek menjadi file yang dapat dieksekusi.  Linker LLVM disebut <code>lld</code> , dan dipanggil dengan target symlink.  Untuk WebAssembly, ini <code>wasm-ld</code> . <br><br><pre> <code class="bash hljs">wasm-ld \ --no-entry \ <span class="hljs-comment"><span class="hljs-comment"># We don't have an entry function --export-all \ # Export everything (for now) -o add.wasm \ add.o</span></span></code> </pre> <br>  Hasilnya adalah modul WebAssembly berukuran 262 byte. <br><br><h3>  Luncurkan </h3><br>  Tentu saja, yang paling penting adalah untuk melihat bahwa semuanya <i>benar-benar</i> berfungsi.  Seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir</a> , Anda dapat menggunakan beberapa baris JavaScript tertanam untuk memuat dan menjalankan modul WebAssembly ini. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(instance.exports.add(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">)); } init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Jika semuanya baik-baik saja, Anda akan melihat nomor 17 di konsol DevTool. <b>Kami baru saja berhasil mengkompilasi C ke dalam WebAssembly tanpa menyentuh Emscripten.</b>  Perlu juga dicatat bahwa tidak ada middleware untuk mengkonfigurasi dan memuat modul WebAssembly. <br><br><h1>  Kompilasi C sedikit lebih sederhana </h1><br>  Untuk mengkompilasi C di WebAssembly, kami telah mengambil banyak langkah.  Seperti yang saya katakan, untuk tujuan pendidikan, kami memeriksa secara rinci semua tahapan.  Mari kita lompati format perantara yang dapat dibaca manusia dan segera menerapkan kompiler C sebagai pisau tentara Swiss, seperti yang dikembangkan: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -nostdlib \ <span class="hljs-comment"><span class="hljs-comment"># Don't try and link against a standard library -Wl,--no-entry \ # Flags passed to the linker -Wl,--export-all \ -o add.wasm \ add.c</span></span></code> </pre> <br>  Di sini kita mendapatkan file <code>.wasm</code> sama, tetapi dengan satu perintah. <br><br><h1>  Optimasi </h1><br>  Lihatlah modul WAT WebAssembly kami dengan menjalankan <code>wasm2wat</code> : <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) (local i32 i32 i32 i32 i32 i32 i32 i32) global.get 0 local.set 2 i32.const 16 local.set 3 local.get 2 local.get 3 i32.sub local.set 4 local.get 4 local.get 0 i32.store offset=12 local.get 4 local.get 1 i32.store offset=8 local.get 4 i32.load offset=12 local.set 5 local.get 4 i32.load offset=12 local.set 6 local.get 5 local.get 6 i32.mul local.set 7 local.get 4 i32.load offset=8 local.set 8 local.get 7 local.get 8 i32.add local.set 9 local.get 9 return) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br>  Wow, kode yang luar biasa.  Yang mengejutkan saya, modul ini menggunakan memori (seperti yang terlihat dari operasi <code>i32.load</code> dan <code>i32.store</code> ), delapan lokal dan beberapa variabel global.  Mungkin, Anda dapat secara manual menulis versi yang lebih ringkas.  Program ini sangat besar karena kami tidak menerapkan optimasi apa pun.  Mari kita lakukan: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ + -O3 \ <span class="hljs-comment"><span class="hljs-comment"># Agressive optimizations + -flto \ # Add metadata for link-time optimizations -nostdlib \ -Wl,--no-entry \ -Wl,--export-all \ + -Wl,--lto-O3 \ # Aggressive link-time optimizations -o add.wasm \ add.c</span></span></code> </pre> <br><blockquote>  <b>Catatan: secara</b> teknis, optimisasi tata letak (LTO) tidak memberikan keuntungan karena kami hanya membuat satu file.  Dalam proyek-proyek besar, KPP akan membantu mengurangi ukuran file secara signifikan. </blockquote>  Setelah menjalankan perintah ini, file <code>.wasm</code> menurun dari 262 menjadi 197 byte, dan WAT juga menjadi lebih sederhana: <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) local.get 0 local.get 0 i32.mul local.get 1 i32.add) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br><h1>  Panggil perpustakaan standar </h1><br>  Menggunakan C tanpa perpustakaan libc standar tampaknya agak kasar.  Adalah logis untuk menambahkannya, tetapi saya akan jujur: itu <i>tidak</i> akan mudah.  <b>Faktanya, kami tidak secara langsung memanggil perpustakaan libc apa pun di artikel</b> .  Ada beberapa yang cocok, terutama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">glibc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">musl</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dietlibc</a> .  Namun, sebagian besar pustaka ini seharusnya berjalan di sistem operasi POSIX, yang mengimplementasikan serangkaian panggilan sistem tertentu.  Karena kita tidak memiliki antarmuka kernel dalam JavaScript, kita harus mengimplementasikan sendiri panggilan sistem POSIX ini, mungkin melalui JavaScript.  Ini adalah tugas yang sulit dan saya tidak akan melakukannya di sini.  Berita baiknya adalah <b>ini yang dilakukan Emscripten untuk Anda</b> . <br><br>  Tentu saja, tidak semua fungsi libc bergantung pada panggilan sistem.  Fungsi-fungsi seperti <code>strlen()</code> , <code>sin()</code> atau bahkan <code>memset()</code> diimplementasikan dalam C. sederhana. Ini berarti bahwa Anda dapat menggunakan fungsi-fungsi ini atau bahkan hanya menyalin / menempel implementasinya dari beberapa perpustakaan yang disebutkan. <br><br><h1>  Memori dinamis </h1><br>  Tanpa libc, antarmuka dasar C seperti <code>malloc()</code> dan <code>free()</code> tidak tersedia untuk kami.  Dalam WAT yang tidak dioptimalkan, kami melihat bahwa kompiler menggunakan memori jika perlu.  Ini berarti bahwa kita tidak bisa hanya menggunakan memori sesuka kita, tanpa risiko merusaknya.  Anda perlu memahami bagaimana ini digunakan. <br><br><h3>  Model memori LLVM </h3><br>  Metode segmentasi memori WebAssembly akan mengejutkan programmer berpengalaman sedikit.  Pertama, di WebAssembly, alamat null diizinkan secara teknis, tetapi sering kali masih diperlakukan sebagai kesalahan.  Kedua, tumpukan lebih dulu dan tumbuh turun (ke alamat yang lebih rendah), dan tumpukan muncul kemudian dan tumbuh.  Alasannya adalah bahwa memori WebAssembly dapat meningkat saat runtime.  Ini berarti bahwa tidak ada ujung yang tetap untuk mengakomodasi tumpukan atau tumpukan. <br><br>  Berikut ini tata letak <code>wasm-ld</code> : <br><br><img src="https://habrastorage.org/webt/kz/xv/z6/kzxvz60tlxzqdv_9tvxlm4m3gca.png"><br><br>  <i><font color="gray">Tumpukan tumbuh turun, dan tumpukan tumbuh.</font></i>  <i><font color="gray">Tumpukan dimulai dengan <code>__data_end</code> , dan heap <code>__heap_base</code> dengan <code>__heap_base</code> .</font></i>  <i><font color="gray">Karena tumpukan ditempatkan terlebih dahulu, ia dibatasi oleh ukuran maksimum yang ditetapkan selama kompilasi, mis. <code>__heap_base</code> dikurangi <code>__data_end</code></font></i> <br><br>  Jika kita kembali dan melihat bagian global di WAT kita, kita menemukan nilai-nilai ini: <code>__heap_base</code> diatur ke 66560, dan <code>__data_end</code> diatur ke 1024. Ini berarti bahwa tumpukan dapat tumbuh hingga maksimum 64 KiB, yang tidak banyak.  Untungnya, <code>wasm-ld</code> memungkinkan Anda untuk mengubah nilai ini: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -O3 \ -flto \ -nostdlib \ -Wl,--no-entry \ -Wl,--<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>-all \ -Wl,--lto-O3 \ + -Wl,-z,stack-size=$[8 * 1024 * 1024] \ <span class="hljs-comment"><span class="hljs-comment"># Set maximum stack size to 8MiB -o add.wasm \ add.c</span></span></code> </pre> <br><h3>  Majelis alokator </h3><br>  Area tumpukan diketahui dimulai dengan <code>__heap_base</code> .  Karena fungsi <code>malloc()</code> tidak ada, kami tahu bahwa area memori berikutnya dapat digunakan dengan aman.  Kita dapat menempatkan data di sana sesuka kita, dan tidak perlu takut akan kerusakan memori, karena tumpukan tumbuh ke arah lain.  Namun, tumpukan yang gratis untuk semua orang bisa dengan cepat tersumbat, jadi biasanya diperlukan semacam manajemen memori dinamis.  Salah satu opsi adalah mengambil implementasi malloc () lengkap, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi malloc dari Doug Lee</a> , yang digunakan dalam Emscripten.  Ada beberapa implementasi kecil dengan berbagai trade-off. <br><br>  Tapi mengapa tidak menulis <code>malloc()</code> Anda sendiri <code>malloc()</code> ?  Kami sangat terhambat sehingga tidak ada bedanya.  Salah satu yang paling sederhana adalah pengalokasi benjolan: sangat cepat, sangat kecil dan mudah diimplementasikan.  Tetapi ada kekurangannya: Anda tidak bisa membebaskan memori.  Meskipun sekilas pengalokasian seperti itu tampaknya sangat tidak berguna, tetapi ketika mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Squoosh,</a> saya menemukan preseden di mana itu akan menjadi pilihan yang sangat baik.  Konsep pengalokasi benjolan adalah bahwa kami menyimpan alamat awal memori yang tidak digunakan sebagai global.  Jika program meminta <code>n</code> byte memori, kami memindahkan marker ke <code>n</code> dan mengembalikan nilai sebelumnya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_base; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bump_pointer = &amp;__heap_base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = bump_pointer; bump_pointer += n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// lol }</span></span></code> </pre> <br>  Variabel global dari WAT sebenarnya didefinisikan oleh <code>wasm-ld</code> , sehingga kita dapat mengaksesnya dari kode C sebagai variabel biasa jika kita mendeklarasikannya sebagai <code>extern</code> .  Jadi, <b>kami hanya menulis <code>malloc()</code> kami sendiri <code>malloc()</code> ... dalam lima baris C.</b> <br><br><blockquote>  <b>Catatan:</b> pengalokasi benjolan kami tidak sepenuhnya kompatibel dengan <code>malloc()</code> dari C. Misalnya, kami tidak memberikan jaminan penyelarasan.  Tapi itu bekerja dengan cukup baik, jadi ... </blockquote><h3>  Penggunaan memori dinamis </h3><br>  Untuk menguji, mari kita membuat fungsi C, yang mengambil larik angka dengan ukuran acak dan menghitung jumlahnya.  Tidak terlalu menarik, tetapi ini memaksa kita untuk menggunakan memori dinamis, karena kita tidak tahu ukuran array saat perakitan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { sum += a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  Fungsi penjumlahan (), mudah-mudahan, cukup mudah.  Pertanyaan yang lebih menarik adalah bagaimana cara mengirimkan array dari JavaScript ke WebAssembly - setelah semua, WebAssembly hanya memahami angka.  Gagasan umum adalah menggunakan <code>malloc()</code> <i>dari JavaScript</i> untuk mengalokasikan memori, menyalin nilai-nilai di sana dan meneruskan alamat (nomor!) <i>Di mana</i> array berada: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> jsArray = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">3</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">]; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// Allocate memory for 5 32-bit integers // and return get starting address. const cArrayPointer = instance.exports.malloc(jsArray.length * 4); // Turn that sequence of 32-bit integers // into a Uint32Array, starting at that address. const cArray = new Uint32Array( instance.exports.memory.buffer, cArrayPointer, jsArray.length ); // Copy the values from JS to C. cArray.set(jsArray); // Run the function, passing the starting address and length. console.log(instance.exports.sum(cArrayPointer, cArray.length)); } init(); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Setelah memulai, Anda akan melihat jawaban 15 di konsol DevTools, yang sebenarnya merupakan jumlah semua angka dari 1 hingga 5. <br><br><h1>  Kesimpulan </h1><br>  Jadi, Anda membaca sampai akhir.  Selamat!  Sekali lagi, jika Anda merasa sedikit kelebihan beban, semuanya beres.  <b>Tidak perlu membaca semua detail.</b>  <b>Memahami mereka sepenuhnya opsional untuk pengembang web yang baik dan bahkan tidak diperlukan untuk penggunaan WebAssembly yang luar biasa</b> .  Tetapi saya ingin membagikan informasi ini, karena ini memungkinkan Anda untuk benar-benar menghargai semua pekerjaan yang dilakukan proyek seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Emscripten</a> untuk Anda.  Pada saat yang sama, ini memberikan pemahaman tentang betapa kecilnya modul komputasi WebAssembly yang murni.  Modul Wasm untuk menjumlahkan array hanya berukuran 230 byte, <i>termasuk pengalokasi memori dinamis</i> .  Mengkompilasi kode yang sama dengan Emscripten akan menghasilkan 100 byte kode WebAssembly dan 11K kode tautan JavaScript.  Kita harus berusaha demi hasil seperti itu, tetapi ada situasi ketika itu sepadan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454868/">https://habr.com/ru/post/id454868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454844/index.html">Odigest: menarik bagi desainer untuk minggu ini</a></li>
<li><a href="../id454850/index.html">Evolusi algoritma tunggal</a></li>
<li><a href="../id454856/index.html">Kami menganalisis kerentanan validasi sertifikat SSL / TLS dalam perangkat lunak non-browser</a></li>
<li><a href="../id454860/index.html">Mari kita bantu QueryProvider menangani string yang diinterpolasi</a></li>
<li><a href="../id454864/index.html">Bagaimana proses pengembangan di berbagai perusahaan</a></li>
<li><a href="../id454872/index.html">Space Invaders: sekarang dalam 512 byte (Assembler x86)</a></li>
<li><a href="../id454874/index.html">Sedikit tentang multitasking dalam mikrokontroler</a></li>
<li><a href="../id454876/index.html">Tentang merancang sistem kemampuan karakter yang fleksibel dalam game</a></li>
<li><a href="../id454878/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 3</a></li>
<li><a href="../id454880/index.html">“Off-season” dalam kehidupan freelancer: bagaimana cara bertahan dan bertahan?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>