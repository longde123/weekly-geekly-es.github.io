<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚆 💣 🔺 Generación de código de OpenAPI v3 (también conocido como Swagger 3) a TypeScript y no solo 👷🏻 ⏭️ 🐈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace dos años comencé a desarrollar  uno mas  un generador de código gratuito de OpenAPI Specification v3 a TypeScript ( está disponible en Github ). ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generación de código de OpenAPI v3 (también conocido como Swagger 3) a TypeScript y no solo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483628/"><p>  Hace dos años comencé a desarrollar <del>  uno mas </del>  un generador de código gratuito de <a href="https://swagger.io/docs/specification/about/">OpenAPI Specification</a> v3 a TypeScript ( <a href="https://github.com/koshevy/codegena">está disponible en Github</a> ).  Inicialmente, me <a href="https://json-schema.org/understanding-json-schema/reference/combining.html">propuse</a> hacer una generación eficiente de tipos de datos primitivos y complejos en TypeScript, teniendo en cuenta varias características del <a href="https://json-schema.org/">esquema JSON</a> , como <a href="https://json-schema.org/understanding-json-schema/reference/combining.html">oneOf / anyOf / allOf</a> , etc.  (La <a href="https://github.com/swagger-api/swagger-codegen">solución nativa</a> de Swagger tuvo algunos problemas con esto).  Otra idea era usar esquemas de especificaciones para validación en la parte frontal, posterior y otras partes del sistema. </p><br><p><img src="https://habrastorage.org/webt/hz/cd/u4/hzcdu47rcjbutgqbe6pdb2k46x8.png"></p><a name="habracut"></a><br><p>  Ahora el generador de código está relativamente listo, está en la etapa <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE_%25D0%25B6%25D0%25B8%25D0%25B7%25D0%25BD%25D0%25B5%25D1%2581%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BE%25D0%25B1%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BA%25D1%2582">MVP</a> .  Tiene mucho de lo que se necesita en términos de generación de tipos de datos, así como una biblioteca experimental para generar servicios front-end (hasta ahora para Angular).  En este artículo quiero mostrar los desarrollos y decirles cómo pueden ayudar si usa TypeScript y OpenAPI v3.  En el camino, quiero compartir algunas ideas y consideraciones que han surgido en mi proceso de trabajo.  Bueno, si está interesado, puede leer la historia de fondo que escondí en el spoiler para no complicar la lectura de la parte técnica. </p><br><h2 id="soderzhanie">  Contenido </h2><br><ol><li>  <a href="https://habr.com/ru/post/483628/">Antecedentes</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Descripción</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Instalación y uso</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Practica usando un generador de código</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Uso de tipos de datos generados en aplicaciones</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Descomposición de circuitos dentro de la especificación OEA</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Descomposición anidada</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Servicios generados automáticamente para trabajar con la API REST</a> <br><ol><li>  <a href="https://habr.com/ru/post/483628/">¿Por qué se necesita esto?</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Servicio de generación</a> </li><li>  <a href="https://habr.com/ru/post/483628/">Usar servicios generados</a> </li></ol></li><li>  <a href="https://habr.com/ru/post/483628/">En lugar de un epílogo</a> </li></ol><br><a name="Foreword"></a><br><h2 id="predystoriya">  Antecedentes </h2><br><div class="spoiler">  <b class="spoiler_title">Expandir para leer (omitir)</b> <div class="spoiler_text"><p>  Todo comenzó hace dos años, luego trabajé en una empresa que desarrollaba una plataforma de minería de datos y fui responsable de la interfaz (principalmente TypeScript + Angular).  Las características del proyecto eran estructuras de datos complejas con una gran cantidad de parámetros (30 o más) y no siempre relaciones comerciales obvias entre ellos.  La compañía estaba creciendo y el entorno de software estaba experimentando cambios bastante frecuentes.  El frontend tenía que estar bien informado sobre los matices, porque algunos cálculos estaban duplicados en el frente y en el backend.  Es decir, este fue el caso cuando usar OpenAPI es más que apropiado.  Encontré un período en la empresa en el que en cuestión de meses el equipo de desarrollo adquirió una sola especificación, que se convirtió en una base de conocimiento común para el departamento posterior, frontal e incluso central, que estaba oculto detrás del amplio back-end web.  La versión de OpenAPI fue elegida "para el crecimiento", entonces todavía bastante joven v3.0 </p><br><p>  Esto ya no era una especificación en uno o más archivos YML / JSON estáticos, y no el resultado de <a href="https://github.com/zircote/swagger-php">anotadores</a> , sino una biblioteca completa de componentes, métodos, plantillas y propiedades, organizados de acuerdo con el concepto DDD de la plataforma.  La biblioteca se dividió en directorios y archivos, y un recolector especialmente organizado produjo documentos de la OEA para cada área temática.  Se creó una forma experimental de flujo de trabajo, que podría describirse como Design-First. </p><br><blockquote>  Hay un <a href="https://habr.com/ru/company/yamoney/blog/347390/">buen artículo</a> en el blog de la compañía Yandex.Money, que habló sobre Design First </blockquote><p>  Design First y la especificación general ayudaron a desacralizar el conocimiento, pero se hizo evidente un nuevo problema: mantener la relevancia del código.  La especificación describe varias docenas de métodos y docenas (y luego cientos) de entidades.  Pero el código tenía que escribirse manualmente: tipos de datos, servicios para trabajar con REST, etc.  Uno o dos sprints con historias paralelas cambiaron enormemente la imagen;  Agregar complejidad a la fusión de varias historias y el factor humano.  La rutina amenazaba con ser significativa, y la solución parecía obvia: necesita generar código.  Después de todo, las especificaciones de la OEA ya contenían todo lo necesario para no volver a escribirlo manualmente.  Pero no fue tan simple. </p><br><p>  La interfaz está al final del ciclo de producción, por lo que sentí cambios más dolorosos que los colegas de otros departamentos.  Al diseñar la API REST, el entorno de back-end fue decisivo, e incluso después de la aprobación de "Design First", permaneció la inercia;  para el front end, todo parecía menos obvio.  De hecho, entendí esto desde el principio, y comencé a sondear el suelo de antemano, cuando apenas se comenzaba a hablar de una especificación "universal".  No se habló de escribir su propio generador de código;  Solo quería encontrar algo listo. </p><br><p>  Estaba decepcionado  Hubo dos problemas: la versión 3.0 de la OEA, con el apoyo de la cual, al parecer, nadie tenía prisa, y la calidad de las soluciones en sí mismas; en ese momento (recuerdo, esto fue hace dos años), logré encontrar dos soluciones relativamente listas: <a href="https://github.com/swagger-api/swagger-codegen">de Swagger</a> y de Microsoft (Parece <a href="https://github.com/Azure/autorest">que</a> ).  En el primero, el soporte para OAS 3.0 estaba en beta profunda.  El segundo funcionó solo con la versión 2.x, pero no hubo pronósticos inequívocos.  Por cierto, no pude iniciar el generador de código de Microsoft incluso en un documento de prueba del formato Swagger 2.0.  La solución de Swagger funcionó, pero un esquema más o menos complicado con enlaces $ ref se convirtió en un "ERROR" incomprensible, y las dependencias recursivas lo enviaron a un bucle sin fin.  Hubo problemas con <a href="">los tipos primitivos</a> .  Además, no entendía bien cómo trabajar con servicios generados automáticamente: parecían estar hechos para mostrar, y su uso real creó más problemas de los que resolvieron (en mi opinión).  Y finalmente, la integración del archivo JAR en un CI / CD orientado a NPM fue inconveniente: tuve que descargar manualmente la <a href="https://oss.sonatype.org/content/repositories/snapshots/io/swagger/codegen/v3/swagger-codegen-cli/3.0.15-SNAPSHOT/">instantánea necesaria</a> , que parecía pesar 13 megabytes, y hacer algo con ella.  En general, me tomé un descanso y decidí ver qué pasa después. </p><br><p>  Después de unos cinco meses, surgió nuevamente el problema de la generación de código.  Tuve que reescribir y expandir parte de la aplicación web, y al mismo tiempo quería refactorizar los servicios antiguos para trabajar con la API REST y los tipos de datos.  Pero la evaluación de la complejidad no fue optimista: de una semana a dos personas, y esto es solo para servicios REST y descripciones de tipos.  No diré que me deprimió mucho, pero aún así.  Por otro lado, nunca encontré una solución para la generación de código y no esperé, y su implementación difícilmente tomaría menos tiempo.  Es decir, no había dudas al respecto: el beneficio es dudoso, los riesgos son grandes.  Nadie apoyaría esta idea, y no lo propuse.  Mientras tanto, se acercaban las vacaciones de mayo, y la compañía me "debió" varios días por trabajar el fin de semana.  Durante dos semanas me escapé de todas las experiencias laborales a Georgia, donde una vez viví durante casi un año. </p><br><p>  Entre fiestas y fiestas, necesitaba hacer algo, y decidí escribir mi decisión.  Trabajar en cafés de verano cerca de Vake Park fue sorprendentemente productivo, y volví a Peter con un generador de código listo para usar para tipos de datos.  Luego, durante otro mes, "terminé" los servicios los fines de semana antes de que estuviera listo para trabajar. </p><br><p>  Desde el principio, abrí el generador de código, trabajando en él en mi tiempo libre.  Aunque, de hecho, escribió para un borrador de trabajo.  No diré que la revisión / ejecución se realizó sin ningún problema;  y no diré que fueron significativos.  Pero en algún momento noté que dejé de usar la documentación Redoc / Swagger: navegar por el código era más conveniente, siempre que el código esté siempre actualizado y comentado.  Pronto, "anoté" mis logros, sin desarrollarlos en absoluto, hasta que un colega (ahora hace seis meses que me fui a otra empresa) me aconsejó que los tomara más en serio (también se le ocurrió el nombre). </p><br><blockquote>  No tenía suficiente tiempo libre y me llevó varios meses finalizar en segundo plano: área de <a href="https://stackblitz.com/edit/codegena-playground">juegos</a> , aplicación de prueba, reorganización del proyecto.  Ahora estoy listo para recibir comentarios. </blockquote></div></div><br><a name="Description"></a><br><h2 id="opisanie">  Descripción </h2><br><p> Por el momento, la solución para la generación de código incluye tres bibliotecas NPM integradas en el <code>@codegena</code> @codegena y ubicadas en un <a href="https://github.com/koshevy/codegena">mono-repositorio</a> común: </p><br><div class="scrollable-table"><table><thead><tr><th>  La biblioteca </th><th>  Descripción </th></tr></thead><tbody><tr><td>  @ codegena / oapi3ts </td><td>  La biblioteca base es un convertidor de OAS3 a descripciones de tipo de datos (ahora solo admite TypeScript) </td></tr><tr><td>  @ codegena / ng-api-service </td><td>  Extensión para servicios angulares </td></tr><tr><td>  @ codegena / oapi3ts-cli </td><td>  Shell para uso conveniente en scripts CLI </td></tr></tbody></table></div><br><a name="SetupAndUsing"></a><br><h3 id="ustanovka-i-ispolzovanie">  Instalación y uso </h3><br><p>  La opción más práctica es usar los scripts NodeJS que se ejecutan desde la CLI.  Primero necesitas instalar las dependencias: </p><br><pre> <code class="plaintext hljs">npm i @codegena/oapi3ts, @codegena/ng-api-service, @codegena/oapi3ts-cli</code> </pre> <br><p>  Luego, cree un archivo js (por ejemplo, <code>update-typings.js</code> ) con el código: </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliLib = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@codegena/oapi3ts-cli'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cliLib.CliApplication; cliApp.createTypings(); <span class="hljs-comment"><span class="hljs-comment">// cliApp.createServices('angular'); // optional</span></span></code> </pre> <br><p>  Y comience pasando tres parámetros: </p><br><pre> <code class="plaintext hljs">node ./update-typings.js --srcPath ./specs/todo-app-spec.json --destPath ./src/lib --separatedFiles true</code> </pre> <br><p>  En <code>destPath</code> se generarán archivos y, de hecho, los contenidos de <a href="https://github.com/koshevy/codegena/tree/master/libs/todo-app-scheme/src/lib">este directorio</a> en el repositorio del proyecto se crean de la misma manera.  <a href="">Aquí está el script generador</a> , y <a href="">así es como</a> se ejecuta en los scripts NPM.  Sin embargo, si lo desea, puede usarlo incluso en el navegador, como se hace en <a href="https://codegena-playground.stackblitz.io/">Playground</a> . </p><br><a name="CodegenerationUsingPractice"></a><br><h2 id="praktika-ispolzovanie-kodogeneratora">  Practica usando un generador de código </h2><br><p>  A continuación, quiero hablar sobre lo que obtendremos como resultado: cuál es la idea de cómo esto nos ayudará.  Una ayuda visual será el código de la aplicación de demostración.  Consta de dos partes: un back-end (en el marco <a href="https://nestjs.com/">NestJS</a> ) y una interfaz (en <a href="https://angular.io/">Angular</a> ).  Si lo desea, incluso puede <a href="https://github.com/koshevy/codegena/tree/5367749623826d270fb652e32fa394c023751877">ejecutarlo localmente</a> . </p><br><blockquote>  Incluso si no está familiarizado con Angular y / o NestJS, esto no debería causar problemas: la mayoría de los desarrolladores de TypeScript deben entender los ejemplos de código que se proporcionarán. </blockquote><p>  Aunque la aplicación se simplifica tanto como sea posible (por ejemplo, el back-end almacena datos en una sesión, no en la base de datos), traté de recrear el flujo de datos y las características de la jerarquía de tipos de datos inherentes a la aplicación real.  Está listo en un 80-85%, pero el "acabado" puede retrasarse, pero por ahora es más importante hablar sobre lo que ya está allí. </p><br><a name="UsingGeneratedDataTypes"></a><br><h2 id="ispolzovanie-generiruemyh-tipov-dannyh-v-prilozheniyah">  Uso de tipos de datos generados en aplicaciones </h2><br><p>  Supongamos que tenemos una especificación OpenAPI (por ejemplo, <a href="">esta</a> ) con la que tenemos que trabajar.  No importa si creamos algo desde cero, o si apoyamos, hay una cosa importante con la que es más probable que comencemos: escribir.  Comenzaremos a describir los tipos de datos básicos o haremos cambios en ellos.  La mayoría de los programadores hacen esto para facilitar su desarrollo futuro.  Para que no tenga que revisar la documentación una vez más, tenga en cuenta los listados de parámetros;  y puede estar seguro de que el IDE y / o el compilador notarán un error tipográfico. </p><br><p>  Nuestra especificación puede o no incluir la sección de <a href="">componentes</a> .  Pero, en cualquier caso, describirá conjuntos de parámetros, solicitudes y respuestas, y podemos usarlo.  Considere un ejemplo: </p><br><pre> <code class="javascript hljs">@Controller(<span class="hljs-string"><span class="hljs-string">'group'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Put(':groupId') rewriteGroup( @Param(ParseQueryPipe) { groupId }: RewriteGroupParameters, @Body() body: RewriteGroupRequest, @Session() session ): RewriteGroupResponse&lt;HttpStatus.OK&gt; { return this.appService .setSession(session) .rewriteGroup(groupId, body); } // ... }</span></span></code> </pre> <br><p>  Este es un fragmento de <a href="">controlador</a> para el marco NestJS con parámetros ( <code>RewriteGroupParameters</code> ), cuerpo de solicitud ( <code>RewriteGroupRequest</code> ) y cuerpo de respuesta ( <code>RewriteGroupResponse&lt;T&gt;</code> ) <code>RewriteGroupResponse&lt;T&gt;</code> .  Ya en este fragmento de código podemos ver los beneficios de escribir: </p><br><ul><li>  Si confundimos el nombre del parámetro destruido <code>groupId</code> , especificando <code>groupId</code> en <code>groupId</code> lugar, inmediatamente recibimos un error en el editor. <br><img src="https://habrastorage.org/webt/1z/2q/0c/1z2q0cstw2lv3vncwmgi8gkxfa0.png"></li><li>  Si el <a href="">método this.appService.rewriteGroup (groupId, body)</a> tiene parámetros escritos, podemos controlar la corrección del parámetro <code>body</code> pasado.  Y si el formato de datos de entrada del método del controlador o el método del servicio cambia, lo sabremos de inmediato.  Mirando hacia el futuro, noto que el método de entrada del método de servicio tiene un tipo de datos diferente de <code>RewriteGroupRequest</code> , pero en nuestro caso, serán idénticos entre sí.  Sin embargo, si de repente se cambia el método de servicio y comienza a aceptar <code>ToDoGroup</code> lugar de <code>ToDoGroupBlank</code> , el IDE y el compilador mostrarán inmediatamente los lugares de discrepancias: <br><img src="https://habrastorage.org/webt/wo/cq/rr/wocqrrks2gtcthaq_wghrhlbbta.png"></li><li>  Del mismo modo, podemos controlar el cumplimiento del resultado devuelto.  Si el estado de una respuesta exitosa cambia repentinamente en la especificación y se convierte en <code>202</code> lugar de <code>200</code> , también lo descubriremos, porque <code>RewriteGroupResponse</code> es <a href="">un genérico con un tipo enumerado</a> : <br><img src="https://habrastorage.org/webt/pt/io/ss/ptiossjjfhihchrlwdlydrrkft4.png"></li></ul><br><p>  Ahora veamos <a href="">un ejemplo de la aplicación front-end</a> que funciona con <a href="">otro método API</a> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initSelectedGroupData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(truth: ComponentTruth)</span></span></span><span class="hljs-function">: Observable&lt;ComponentTruth&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getGroupsService.request(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, { isComplete: <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, withItems: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> }).pipe( pickResponseBody&lt;GetGroupsResponse&lt;<span class="hljs-number"><span class="hljs-number">200</span></span>&gt;&gt;(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), switchMap&lt;ToDoGroup[], Observable&lt;ComponentTruth&gt;&gt;( groups =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadItemsOfSelectedGroups({ ...truth, groups }) ) ); }</code> </pre> <br><p>  No nos adelantemos y analicemos el operador <code>pickResponseBody</code> personalizado <code>pickResponseBody</code> , sino que nos centremos en el refinamiento del tipo <code>GetGroupsResponse</code> .  Lo usamos en una cadena de operadores RxJS, y el operador que lo sigue tiene un refinamiento de entrada de <code>ToDoGroup[]</code> .  Si este código funciona, los tipos de datos indicados se corresponden entre sí.  Aquí también podemos controlar la coincidencia de tipos, y si el formato de respuesta en nuestra API cambia repentinamente, esto no escapará a nuestra atención: </p><br><p><img src="https://habrastorage.org/webt/ci/hr/7c/cihr7csbo5kqn9fqkreoij7kuxk.png"></p><br><p>  Y, por supuesto, también se escriben los parámetros de llamada de <code>this.getGroupsService.request</code> .  Pero este es el tema de los servicios generados. </p><br><blockquote>  En los ejemplos anteriores, vemos que la tipificación de solicitudes, respuestas y parámetros se puede utilizar en varias partes del sistema: frontend, back-end, etc.  Si el backend y el frontend están en el mismo mono-repositorio y tienen un entorno ecológico compatible, pueden usar la misma <a href="https://github.com/koshevy/codegena/tree/5367749623826d270fb652e32fa394c023751877/libs/todo-app-scheme">biblioteca compartida</a> con el código generado.  Pero incluso si el backend y el frontend son compatibles con diferentes equipos y no tienen nada en común, excepto la especificación pública de la OEA, aún será más fácil para ellos sincronizar su código. </blockquote><br><a name="DecompositionInOAS"></a><br><h2 id="dekompoziciya-shem-vnutri-oas-specifikacii">  Descomposición de circuitos dentro de la especificación OEA </h2><br><p>  Probablemente, en los ejemplos anteriores, prestó atención a las <code>ToDoGroup</code> <code>ToDoGroupBlank</code> , <code>ToDoGroup</code> , con las cuales <code>RewriteGroupResponse</code> y <code>GetGroupsResponse</code> .  En realidad, <code>RewriteGroupResponse</code> es solo un alias genérico para <code>ToDoGroup</code> , <code>HttpErrorBadRequest</code> , etc.  Es fácil adivinar que tanto <a href="">ToDoGroup</a> como <a href="">HttpErrorBadRequest</a> son diagramas de la sección de especificación de <a href="">componentes.schem a la que hace</a> referencia el <a href="">punto final rewriteGroup</a> (directamente o a través de <a href="">intermediarios</a> ): </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"200"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Todo group saved"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"application/json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ToDoGroup"</span></span> } } } }, <span class="hljs-attr"><span class="hljs-attr">"400"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorBadRequest"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"404"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorGroupNotFound"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"409"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorConflict"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"500"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/responses/errorServer"</span></span> } }</code> </pre><br><p>  Esta es la descomposición habitual de las estructuras de datos, y su principio es el mismo que en otros lenguajes de programación.  Los componentes, a su vez, también se pueden descomponer: consulte otros componentes (incluso de forma recursiva), use la combinación y otras características del esquema JSON.  Pero independientemente de la complejidad, deben convertirse correctamente a descripciones de tipos de datos.  Quiero mostrar cómo puede usar la descomposición en OpenAPI y cómo se verá el código generado. </p><br><blockquote>  Los componentes en una especificación OAS bien diseñada se superpondrán con el modelo DDD de las aplicaciones que lo utilizan.  Pero incluso si la especificación es imperfecta, puede confiar en ella, creando su propio modelo de datos.  Esto le dará más control sobre la correspondencia de sus tipos de datos con los tipos de datos de subsistemas integrables. </blockquote><p>  Dado que nuestra aplicación es una lista de tareas, la esencia principal es la tarea.  Es lógico ponerlo en los componentes en primer lugar, porque  otras entidades y puntos finales estarán de alguna manera conectados con él.  Pero antes de eso necesitas entender dos cosas: </p><br><ul><li>  Describimos no solo la abstracción, sino también las reglas de validación, y cuanto más precisas e inequívocas sean, mejor. </li><li>  Al igual que cualquier entidad almacenada en una base de datos, una tarea tiene dos tipos de propiedades: servicio e ingresada por el usuario. </li></ul><br><p>  Resulta que, dependiendo del escenario de uso, tenemos dos estructuras de datos: la Tarea que el usuario acaba de crear y la Tarea que ya está almacenada en la base de datos.  En el segundo caso, tiene un UID único, fecha de creación, cambio, etc., y estos datos deben asignarse en el back-end.  Describí dos entidades ( <code>ToDoTaskBlank</code> y <code>ToDoTask</code> ) de tal manera que la primera es un subconjunto de la segunda: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ToDoTaskBlank"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Base part of data of item in todo's group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Data about group item needed for creation of it"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"groupUid"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"An unique id of group that item belongs to"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/Uid"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Short brief of task to be done"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minLength"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxLength"</span></span>: <span class="hljs-number"><span class="hljs-number">64</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Detailed description and context of the task. Allowed using of Common Markdown."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: [<span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"null"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"minLength"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxLength"</span></span>: <span class="hljs-number"><span class="hljs-number">1024</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"isDone"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Status of task: is done or not"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Position of a task in group. Allows to track changing of state of a concrete item, including changing od position."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"min"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max"</span></span>: <span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"attachments"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Any material attached to the task: may be screenshots, photos, pdf- or doc- documents on something else"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMeta"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"maxItems"</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: [] } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"isDone"</span></span>, <span class="hljs-string"><span class="hljs-string">"title"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"isDone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Book soccer field"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The complainant agreed and recruited more members to play soccer."</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ToDoTask"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Item in todo's group"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Describe data structure of an item in group of tasks"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"allOf"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ToDoTaskBlank"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"uid"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"An unique id of task"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/Uid"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dateCreated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Date/time (ISO) when task was created"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"date-time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-11-17T11:20:51.555Z"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"dateChanged"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Date/time (ISO) when task was changed last time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"format"</span></span>: <span class="hljs-string"><span class="hljs-string">"date-time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"readOnly"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"example"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-11-17T11:20:51.555Z"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dateChanged"</span></span>, <span class="hljs-string"><span class="hljs-string">"dateCreated"</span></span>, <span class="hljs-string"><span class="hljs-string">"position"</span></span>, <span class="hljs-string"><span class="hljs-string">"uid"</span></span> ] } ] } }</code> </pre> <br><p>  En la salida, obtenemos dos interfaces TypeScript, y la <a href="">primera</a> será heredada por la <a href="">segunda</a> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ## Base part of data of item in todo's group * Data about group item needed for creation of it */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskBlank</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... imagine there are ToDoTaskBlank properties } /** * ## Item in todo's group * Describe data structure of an item in group of tasks */ export interface ToDoTask extends ToDoTaskBlank { /** * ## UID of element * An unique id of task */ readonly uid: string; /** * Date/time (ISO) when task was created */ readonly dateCreated: string; /** * Date/time (ISO) when task was changed last time */ readonly dateChanged: string; // ... imagine there are ToDoTaskBlank properties }</span></span></code> </pre> <br><p>  Ahora tenemos las descripciones básicas de la entidad Tarea, y nos referimos a ellas <strong>en el código de nuestra aplicación</strong> tal como se hizo en la <a href="">aplicación de demostración</a> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTask, ToDoTaskBlank, } from <span class="hljs-string"><span class="hljs-string">'@our-npm-scope/our-generated-lib'</span></span>; export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskTeaser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-class"> </span></span>{ isInvalid?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Means this task just created, has temporary uid * and not saved yet. */</span></span> isJustCreated?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Means this task is saving now. */</span></span> isPending?: <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Previous uid of task temporary assigned until * it gets saved and gets new UID from backend. */</span></span> prevTempUid?: string; }</code> </pre> <br><p>  En este ejemplo, describimos una nueva entidad, agregando a <code>ToDoTask</code> las propiedades que nos faltan en el lado de la aplicación front-end.  Es decir, de hecho, ampliamos el modelo de datos resultante teniendo en cuenta los detalles locales.  Alrededor de este modelo, un conjunto de <a href="">herramientas locales</a> y algo así como un DTO primitivo crece gradualmente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downgradeTeaserToTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> taskTeaser: ToDoTaskTeaser </span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = { ...taskTeaser }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!task.description || !task.description.trim()) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.description; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task.description = task.description.trim(); } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.isJustCreated; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.isPending; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.prevTempUid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downgradeTeaserToTaskBlank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> taskTeaser: ToDoTaskTeaser </span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToDoTaskBlank</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> task = downgradeTeaserToTask(taskTeaser) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.dateChanged; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.dateCreated; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> task.uid; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Alguien prefiere hacer que el modelo de datos sea más integral y usar clases.</b> <div class="spoiler_text"><pre> <code class="java hljs">export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTaskTeaser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoTask</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// … imagine, definitions from ToDoTask are here constructor( task: ToDoTask, public isInvalid?: boolean, public isJustCreated?: boolean, public isPending?: boolean, public prevTempUid?: string ) { Object.assign(this, task); } downgradeTeaserToTask(): ToDoTask { const task = {...this}; if (!task.description || !task.description.trim()) { delete task.description; } else { task.description = task.description.trim(); } delete task.isJustCreated; delete task.isPending; delete task.prevTempUid; return task; } downgradeTeaserToTaskBlank(): ToDoTaskBlank { // … some code } }</span></span></code> </pre> </div></div><br><p>  Pero esta es una cuestión de estilo, adecuación y cómo se desarrollará la arquitectura de la aplicación.  En general, independientemente del enfoque, podemos confiar en un modelo de datos básico y tener más control sobre la conformidad de la escritura.  Entonces, si por alguna razón el <code>uid</code> de <code>ToDoTask</code> convierte en un número, sabremos todas las partes del código que requieren actualización: </p><br><p><img src="https://habrastorage.org/webt/cc/7g/yz/cc7gyzy0tc4oh5zpomvjy09endw.png"></p><br><a name="NestedDecomposition"></a><br><h2 id="vlozhennaya-dekompoziciya">  Descomposición anidada </h2><br><p>  Así que ahora tenemos la interfaz <code>ToDoTask</code> y podemos hacer referencia a ella.  Del mismo modo, describiremos <a href="">ToDoTaskGroup</a> y <a href="">ToDoTaskGroupBlank</a> , y contendrán propiedades de los tipos <code>ToDoTask</code> y <code>ToDoTaskBlank</code> , respectivamente.  Pero ahora dividiremos el "Grupo de tareas" en dos, no en tres componentes: para mayor claridad, describiremos el delta en <a href="">ToDoGroupExtendedData</a> .  Así que quiero demostrar un enfoque en el que un componente se crea a partir de los otros dos: </p><br><pre> <code class="plaintext hljs">"ToDoGroup": { "allOf": [ { "$ref": "#/components/schemas/ToDoGroupBlank" }, { "$ref": "#/components/schemas/ToDoGroupExtendedData" } ] }</code> </pre> <br><p>  Después de comenzar la generación del código, obtenemos una construcción TypeScript ligeramente diferente: </p><br><pre> <code class="java hljs">export type ToDoGroup = ToDoGroupBlank &amp; <span class="hljs-comment"><span class="hljs-comment">// Data needed for group creation ToDoGroupExtendedData; // Extended data has to be obtained after first save</span></span></code> </pre> <br><p>  Como <code>ToDoGroup</code> no tiene su propio "cuerpo", el generador de código prefirió convertirlo en una unión de interfaces.  Sin embargo, si agrega la tercera parte con su propio esquema (anónimo), el resultado será una interfaz con dos antepasados ​​(pero es mejor no hacerlo).  Y <code>ToDoGroupBlank</code> que la propiedad de <code>items</code> de la interfaz <code>ToDoGroupBlank</code> escribe como una matriz de <code>ToDoTaskBlank</code> y se redefine en <code>ToDoGroupBlank</code> en <code>ToDoTask</code> .  Por lo tanto, el generador de código puede transferir los matices de descomposición bastante complejos del esquema JSON a TypeScipt. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTaskBlank } from <span class="hljs-string"><span class="hljs-string">'./to-do-task-blank'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * ## Base part of data of group * Data needed for group creation */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoGroupBlank</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... items?: Array&lt;ToDoTaskBlank&gt;; // ... }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ToDoTask } from <span class="hljs-string"><span class="hljs-string">'./to-do-task'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * ## Extended data of group * Extended data has to be obtained after first save */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToDoGroupExtendedData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... items: Array&lt;ToDoTask&gt;; }</span></span></code> </pre><br><p>  Bueno y, por supuesto, en <code>ToDoTask</code> / <code>ToDoTaskBlank</code> también podemos usar la descomposición.  Es posible que haya notado que la propiedad de <code>attachments</code> se describe como una matriz de elementos de tipo <a href="">AttachmentMeta</a> .  Y este componente se describe de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">"AttachmentMeta"</span></span>: { <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Common meta data model of any type of attachment"</span></span>, <span class="hljs-string"><span class="hljs-string">"oneOf"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMetaImage"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/AttachmentMetaDocument"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"$ref"</span></span>: <span class="hljs-string"><span class="hljs-string">"#/components/schemas/ExternalResource"</span></span>} ] }</code> </pre> <br><p>  Es decir, este componente se refiere a otros componentes.  Como no tiene su propio esquema, el generador de código no lo convierte en un tipo de datos separado para no multiplicar entidades, sino que convierte una descripción anónima del tipo enumerado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Any material attached to the task: may be screenshots, photos, pdf- or doc- * documents on something else */</span></span> attachments?: Array&lt; | AttachmentMetaImage <span class="hljs-comment"><span class="hljs-comment">// Meta data of image attached to task | AttachmentMetaDocument // Meta data of document attached to task | string // Link to any external resource &gt;;</span></span></code> </pre> <br><p>  Al mismo tiempo, para los componentes <code>AttachmentMetaImage</code> y <code>AttachmentMetaDocument</code> , se describen interfaces no anónimas que se importan en los archivos que las utilizan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AttachmentMetaDocument } from <span class="hljs-string"><span class="hljs-string">'./attachment-meta-document'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { AttachmentMetaImage } from <span class="hljs-string"><span class="hljs-string">'./attachment-meta-image'</span></span>;</code> </pre> <br><p>  Pero incluso en <a href="">AttachmentMetaImage,</a> podemos encontrar un enlace a otra interfaz <a href="">ImageOptions</a> renderizada, que se usa dos veces, incluso dentro de una interfaz anónima (el resultado de la conversión de <a href="">propiedades</a> <a href="">adicionales</a> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* tslint:disable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ImageOptions } from <span class="hljs-string"><span class="hljs-string">'./image-options'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Meta data of image attached to task */</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AttachmentMetaImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... /** * Possible thumbnails of uploaded image */ thumbs?: { [key: string]: { /** * Link to any external resource */ url?: string; imageOptions?: ImageOptions; }; }; // ... imageOptions: ImageOptions; }</span></span></code> </pre> <br><p>  Por lo tanto, en base a las <code>ToDoGroup</code> <code>ToDoTask</code> o <code>ToDoGroup</code> , en realidad integramos varias entidades y una cadena de sus conexiones comerciales en nuestro código, lo que nos da más control sobre los cambios en el sistema que van más allá de nuestro código.  Por supuesto, esto no tiene sentido en todos los casos.  Pero si usa OpenAPI, entonces puede tener una pequeña bonificación más, además de la documentación real. </p><br><a name="ServiceGeneration"></a><br><h2 id="avtogeneraciya-servisov-dlya-raboty-s-rest-api">  Servicios generados automáticamente para trabajar con la API REST </h2><br><a name="WhyItNeccessary"></a><br><h3 id="zachem-eto-nuzhno">  ¿Por qué se necesita esto? </h3><br><p>  Si tomamos una aplicación front-end estadística promedio que funciona con una API REST más o menos compleja, una parte considerable de su código serán servicios (o simplemente funciones) para acceder a la API.  Incluirán: </p><br><ul><li>  Asignaciones de URL y parámetros </li><li>  Validación de parámetros, solicitud y respuesta. </li><li>  Extracción de datos y manejo de emergencias </li></ul><br><p>  Es desagradable que, en muchos sentidos, esto sea típico y no contenga ninguna lógica única.  Supongamos un ejemplo: como esquema general, se puede construir el trabajo con la API: </p><br><div class="spoiler">  <b class="spoiler_title">Un ejemplo esquemático simplificado de trabajar con la API REST</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lodash'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable, fromFetch, throwError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { switchMap } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Definitions const URLS = { 'getTasksOfGroup': `${env.REST_API_BASE_URL}/tasks/\${groupId}`, // ... other urls ... }; const URL_TEMPLATES = _.mapValues(urls, url =&gt; _.template(url)); interface GetTaskConditions { isDone?: true | false; offset?: number; limit?: number; } interface ErrorReponse { error: boolean; message?: string; } // Helpers // I taken this snippet from StackOverflow only for example function encodeData(data) { return Object.keys(data).map(function(key) { return [key, data[key]].map(encodeURIComponent).join("="); }).join("&amp;"); } // REST API functions // our REST API working function example function getTasksFromServer(groupUid: string, conditions: GetTaskConditions = {}): Observable&lt;Response&gt; { if (!groupUid) { return throwError(new Error('You should specify "groupUid"!')); } if (!_.isString(groupUid)) { return throwError(new Error('`groupUid` should be string!')); } if (_.isBoolean(conditions.isDone)) { // ... applying of conditions.isDone } else if (conditions.isDone !== undefined) { return throwError(new Error('`isDone` should be "true", "false" or should\'t be set!'!)); } if (offset) { // ... check of `offset` and applying or error throwing } if (limit) { // ... check of `limit` and applying or error throwing } const url = [ URL_TEMPLATES['getTasksOfGroup']({groupUid}), ...(conditions ? [encodeData(conditions)] : []) ]; return fromFetch(url); } // Using of REST API working functions function getRemainedTasks(groupUid: number): Observable&lt;ToDoTask[] | ErrorReponse&gt; { return getTasksFromServer(groupUid, {isDone: false}).pipe( switchMap(response =&gt; { if (response.ok) { // OK return data return response.json(); } else { // Server is returning a status requiring the client to try something else. return of({ error: true, message: `Error ${response.status}` }); } }), catchError(err =&gt; { // Network or other error, handle appropriately console.error(err); return of({ error: true, message: err.message }) }) ); }</span></span></code> </pre> </div></div><br><p>  Puede utilizar una abstracción de alto nivel para trabajar con REST; en función de la pila utilizada, puede ser: <a href="https://github.com/axios/axios">Axios</a> , <a href="http">Angular HttpClient</a> o cualquier otra solución similar.  Pero lo más probable es que básicamente su código coincida con este ejemplo.  Es casi seguro que incluirá: </p><br><ul><li>  Servicios o funciones para acceder a puntos finales específicos (función <code>getTasksFromServer</code> en nuestro ejemplo) </li><li>  Piezas de código que procesan el resultado (función <code>getRemainedTasks</code> ) </li></ul><br><p>  En una aplicación del mundo real, este código será más complicado: la especificación de la aplicación de demostración <a href="">describe 5-6 opciones de respuesta</a> .  A menudo, la API REST está diseñada de tal manera que cada estado de respuesta del servidor debe manejarse en consecuencia.  Pero incluso la comprobación de los datos de entrada tiende a ser más difícil durante el desarrollo de la aplicación: cuanto más tiempo demore en admitir y procesar revisiones de errores, más querrá saber sobre los cuellos de botella en la circulación de datos en la aplicación. </p><br><blockquote>  Pueden producirse errores en cada nodo de acoplamiento de partes de software, cuya detección inoportuna (así como la búsqueda de problemas difíciles de diagnosticar) puede ser muy costosa para las empresas.  Por lo tanto, habrá verificaciones de aclaraciones adicionales.  A medida que crece la base del código, y el número de casos cubiertos, también lo hace la complejidad de realizar cambios.  Pero el negocio es un cambio constante y no hay forma de evitarlo.  Por lo tanto, debemos preocuparnos por cómo haremos cambios por adelantado. </blockquote><p>  Volviendo al tema de OpenAPI, observamos que en las especificaciones de la OEA puede haber suficiente información para: </p><br><ul><li>  Describa todos los puntos finales necesarios en forma de funciones o servicios. </li><li>       </li><li>   URL      </li><li>         </li></ul><br><p>         — <strong></strong> .    ,     ,     /  — 5, 10  200,            .  ,      ,   : , , , RxJS- <a href="">pickResponseBody</a> ,            ,     - ;  <a href="">tapResponse</a> ,    side-effect (tap)   HTTP-.     ,     -   .    ,       ,    . </p><br><blockquote> ,     —   -,      .      ,       ,  ,   ""  /     API     "-"  "" .    -   ,        "" (    ),     . </blockquote><p>   ,          REST API   Angular.         ,      ,        /.      . ,      ,    .  ,      , ..      . </p><br><a name="HowToGenerateServices"></a><br><h3 id="generaciya-servisov">   </h3><br><p>   " <a href="https://habr.com/ru/post/483628/">  </a> "      .   Angular-,       <code>update-typings.js</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliLib = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@codegena/oapi3ts-cli'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cliApp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cliLib.CliApplication; cliApp.createTypings(); cliApp.createServices(<span class="hljs-string"><span class="hljs-string">'angular'</span></span>);</code> </pre> <br><p>             ,   Angular-    API   .    , -   - ,     <a href="https://github.com/koshevy/codegena/tree/master/libs/todo-app-scheme/src/lib/services"> </a> .     ,    <a href="">RewriteGroupService</a> .    <a href="">ApiService</a> ,        ,   ,   -: </p><br><div class="spoiler"> <b class="spoiler_title">-  </b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Typings for this API method import { RewriteGroupParameters, RewriteGroupResponse, RewriteGroupRequest } from '../typings'; // Schemas import { schema as domainSchema } from './schema.b4c655ec1635af1be28bd6'; /** * Service for angular based on ApiAgent solution. * Provides assured request to API method with implicit * validation and common errors handling scheme. */ @Injectable() export class RewriteGroupService extends ApiService&lt; RewriteGroupResponse, RewriteGroupRequest, RewriteGroupParameters &gt; { protected get method(): 'PUT' { return 'PUT'; } /** * Path template, example: `/some/path/{id}`. */ protected get pathTemplate(): string { return '/group/{groupId}'; } /** * Parameters in a query. */ protected get queryParams(): string[] { return ['forceSave']; } // ... }</span></span></code> </pre> </div></div><br><p> , <a href="">   JSON Schema</a>  ,   .    <a href=""> </a> ,        ,       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schema as domainSchema } from <span class="hljs-string"><span class="hljs-string">'./schema.b4c655ec1635af1be28bd6'</span></span>;</code> </pre> <br><blockquote> ,     <code>schema.b4c655ec1635af1be28bd6.ts</code>       ,  <a href="">  </a>  ,  . </blockquote><br><a name="UsingOfGeneratedServices"></a><br><h3 id="ispolzovanie-generiruemyh-servisov">    </h3><br><p>       ,   Angular-. </p><br><div class="spoiler"> <b class="spoiler_title">    Angular-</b> <div class="spoiler_text"><p>      <code>ApiModule</code>       : </p><br><pre> <code class="plaintext hljs">import { ApiModule, API_ERROR_HANDLER } from '@codegena/ng-api-service'; import { CreateGroupItemService, GetGroupsService, GetGroupItemsService, UpdateFewItemsService } from '@codegena/todo-app-scheme'; @NgModule({ imports: [ ApiModule, // ... ], providers: [ RewriteGroupService, { provide: API_ERROR_HANDLER, useClass: ApiErrorHandlerService }, // ... ], // ... }) export class TodoAppModule { }</code> </pre> </div></div><br><p>    ,     [])( <a href="https://angular.io/guide/dependency-injection">https://angular.io/guide/dependency-injection</a> ): </p><br><pre> <code class="plaintext hljs">@Injectable() export class TodoTasksStore { constructor( protected createGroupItemService: CreateGroupItemService, protected getGroupsService: GetGroupsService, protected getGroupItemsService: GetGroupItemsService, protected updateFewItemsService: UpdateFewItemsService ) {} }</code> </pre> <br><p>         —  ,       <a href="">request</a> ,        : </p><br><pre> <code class="plaintext hljs">return this.getGroupsService.request(null, { isComplete: null, withItems: false }).pipe( pickResponseBody&lt;GetGroupsResponse&lt;200&gt;&gt;(200, null, true), switchMap&lt;ToDoGroup[], Observable&lt;ComponentTruth&gt;&gt;( groups =&gt; this.loadItemsOfSelectedGroups({ ...truth, groups }) ) );</code> </pre> <br><p>  <code>request</code>   <code>Observable&lt;HttpResponse&lt;R&gt; | HttpEvent&lt;R&gt;&gt;</code> ,   ,        . ,     ,      . ,  ,      ,     .     RxJS- <code>pickResponseBody</code> . </p><br><p>  ,    ,    ,   .         API,    .        .   ,     : </p><br><p><img src="https://habrastorage.org/webt/3y/xe/dy/3yxedy51z7su99butzrk2dvunnq.png"></p><br><p>      .   JSON Schema     .       ,   ""      - .   ,      <a href="https://sentry.io/welcome/">Sentry</a>  <a href="https://www.elastic.co/products/kibana">Kibana</a> ,   .       .  ,      ,      . </p><br><blockquote>  ,             .  ,      :) </blockquote><br><a name="AfterWord"></a><br><h2 id="vmesto-poslesloviya">  En lugar de un epílogo </h2><br><p>   ,       .       -,   "    "    —   .  ,  ,   ,   . </p><br><p>     —    ,  - /    (   ).      ,  —   . </p><br><p>   . </p></div></div><p>Source: <a href="https://habr.com/ru/post/483628/">https://habr.com/ru/post/483628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483612/index.html">Conductor de Tesla multado por cepillarse los dientes mientras conducía en piloto automático</a></li>
<li><a href="../483614/index.html">Métodos para combatir el robo en un club de robótica.</a></li>
<li><a href="../483616/index.html">Proyecto Lacmus: cómo la visión por computadora ayuda a salvar a las personas perdidas</a></li>
<li><a href="../483624/index.html">Competencia de Yandex.Taxi: análisis de la pista de back-end del campeonato de programación</a></li>
<li><a href="../483626/index.html">Cómo describir un trabajo de 100 gitlab en 100 líneas en Jsonnet</a></li>
<li><a href="../483630/index.html">The Ember Times - Número 130</a></li>
<li><a href="../483634/index.html">Propiedades de ancho / alto mínimo y máximo en CSS</a></li>
<li><a href="../483646/index.html">Hack The Box - Tutorial de Bitlab. Ofuscación JS débil, GIT y aplicaciones de Windows inversas</a></li>
<li><a href="../483648/index.html">Offshore para negocios de TI en Georgia: trucos y trampas para la vida</a></li>
<li><a href="../483650/index.html">Cosmódromos más cercanos al ecuador - Cosmódromo tropical de Wenchang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>