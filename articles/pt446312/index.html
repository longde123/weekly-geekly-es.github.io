<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò• üèáüèæ üèä Interrup√ß√µes externas no sistema x86. Parte 1. Interromper a evolu√ß√£o do controlador üßñüèæ üé§ üî≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo √© sobre o processo de entrega de interrup√ß√£o de dispositivos externos no sistema x86. Ele tenta responder perguntas como: 



- O que √© fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interrup√ß√µes externas no sistema x86. Parte 1. Interromper a evolu√ß√£o do controlador</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446312/">  Este artigo √© sobre o processo de entrega de interrup√ß√£o de dispositivos externos no sistema x86.  Ele tenta responder perguntas como: <br><br><ul><li>  O que √© foto e para que serve? </li><li>  O que √© o APIC e para que serve?  Qual √© o objetivo do LAPIC e do I / O APIC? </li><li>  Quais s√£o as diferen√ßas entre APIC, xAPIC e x2APIC? </li><li>  O que √© MSI?  Quais s√£o as diferen√ßas entre MSI e MSI-X? </li><li>  Qual √© o papel das tabelas $ PIR, MPtable e ACPI? </li></ul><br>  Se voc√™ deseja saber a resposta para uma dessas perguntas ou simplesmente deseja saber sobre a evolu√ß√£o do controlador de interrup√ß√£o, por favor, seja bem-vindo. <br><a name="habracut"></a><br><h3>  1. Introdu√ß√£o </h3><br>  Para quem n√£o sabe o que √© uma interrup√ß√£o, aqui est√° uma cita√ß√£o da Wikipedia: <br><blockquote> Na programa√ß√£o do sistema, uma interrup√ß√£o √© um sinal para o processador emitido por hardware ou software, indicando um evento que precisa de aten√ß√£o imediata.  Uma interrup√ß√£o alerta o processador para uma condi√ß√£o de alta prioridade que requer a interrup√ß√£o do c√≥digo atual que o processador est√° executando.  O processador responde suspendendo suas atividades atuais, salvando seu estado e executando uma fun√ß√£o chamada manipulador de interrup√ß√£o (ou rotina de servi√ßo de interrup√ß√£o, ISR) para lidar com o evento.  Essa interrup√ß√£o √© tempor√°ria e, ap√≥s a conclus√£o do manipulador de interrup√ß√µes, o processador retoma as atividades normais. <br><br>  Existem dois tipos de interrup√ß√µes: interrup√ß√µes de hardware e software (softirqs): <br><br><ul><li>  As interrup√ß√µes de hardware s√£o usadas pelos dispositivos para comunicar que requerem aten√ß√£o do sistema operacional.  Internamente, as interrup√ß√µes de hardware s√£o implementadas usando sinais de alerta eletr√¥nico enviados ao processador a partir de um dispositivo externo, que faz parte do pr√≥prio computador, como um controlador de disco ou um perif√©rico externo.  Por exemplo, pressionar uma tecla no teclado ou mover o mouse aciona interrup√ß√µes de hardware que fazem com que o processador leia a pressionamento de tecla ou a posi√ß√£o do mouse.  O ato de iniciar uma interrup√ß√£o de hardware √© chamado de solicita√ß√£o de interrup√ß√£o (IRQ). </li><li>  Uma interrup√ß√£o de software √© causada por uma condi√ß√£o excepcional no pr√≥prio processador ou por uma instru√ß√£o especial no conjunto de instru√ß√µes que causa uma interrup√ß√£o quando √© executada.  O primeiro √© chamado de armadilha ou exce√ß√£o e √© usado para erros ou eventos que ocorrem durante a execu√ß√£o do programa, que s√£o excepcionais o suficiente para que n√£o possam ser manipulados no pr√≥prio programa.  Por exemplo, uma exce√ß√£o de divis√£o por zero ser√° lan√ßada se a unidade l√≥gica aritm√©tica do processador for ordenada a dividir um n√∫mero por zero, pois esta instru√ß√£o √© um erro e imposs√≠vel. </li></ul></blockquote><br>  Este artigo √© sobre hardware / interrup√ß√µes externas IRQ. <br><br>  Qual √© o prop√≥sito das interrup√ß√µes?  Por exemplo, queremos executar uma a√ß√£o com um pacote recebido da placa de rede assim que o pacote chegar.  Se voc√™ n√£o quiser perguntar continuamente √† placa de rede "Meu pacote chegou?"  e desperdice o tempo do processador, voc√™ pode usar o IRQ de interrup√ß√£o de hardware externo.  A linha de interrup√ß√£o de um dispositivo deve ser conectada √† linha INTR da CPU e, ap√≥s o recebimento de cada pacote, a placa de rede far√° um sinal nessa linha.  A CPU detectar√° esse sinal e saber√° que a placa de rede possui informa√ß√µes.  Somente depois disso a CPU ler√° o pacote recebido. <br><br>  Mas o que devemos fazer se houver muitos dispositivos externos?  Seria muito improdutivo criar uma tonelada de pinos INTR na CPU para todos eles. <br><br><img src="https://habrastorage.org/webt/vg/3q/3v/vg3q3v7kx8vjttp43xo99o8pccs.png"><br><br>  Para resolver esse problema, um chip especial foi inventado - um controlador de interrup√ß√£o. <br><br><h3>  Pic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">osdev</a> ) <br><br>  O primeiro chip controlador de interrup√ß√£o foi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel 8259 PIC</a> .  Possui 8 linhas de entrada (IRQ0-7) e 1 linha de sa√≠da (que conecta o controlador de interrup√ß√£o √† linha INTR da CPU).  Quando houver uma interrup√ß√£o de um dos dispositivos em suas linhas de entrada, o 8259 far√° um sinal pela linha INTR.  Depois disso, a CPU saber√° que algum dispositivo requer aten√ß√£o imediata e o processador perguntar√° ao PIC qual das 8 linhas de entrada (IRQx) foi a fonte dessa interrup√ß√£o.  H√° alguma sobrecarga nessa pesquisa, mas agora temos 8 linhas de interrup√ß√£o em vez de 1. <br><br><img src="https://habrastorage.org/webt/le/yf/6e/leyf6enogyzp6flpijo2d0x1w9g.png"><br><br>  Logo 8 linhas n√£o eram suficientes.  Para aumentar o n√∫mero total de linhas de interrup√ß√£o, dois controladores 8259 (mestre e escravo) foram conectados em cascata (Dual PIC). <br><br>  Os IRQs de 0 a 7 s√£o processados ‚Äã‚Äãcom o primeiro Intel 8259 PIC (mestre) e os IRQs de 8 a 15 s√£o processados ‚Äã‚Äãcom o segundo Intel 8259 PIC (mestre).  Somente o mestre est√° conectado √† CPU e pode sinalizar sobre as interrup√ß√µes recebidas.  Se houver uma interrup√ß√£o nas linhas 8-15, o segundo PIC (escravo) sinalizar√° sobre isso para o mestre na linha IRQ2 e, depois disso, o mestre sinalizar√° a CPU.  Essa interrup√ß√£o em cascata remove uma das 16 linhas, mas faz um total de 15 interrup√ß√µes para todos os dispositivos externos. <br><br><img src="https://habrastorage.org/webt/xj/yn/dh/xjyndhabujjwz0alrbx831zfzt8.png"><br><br>  Esse esquema foi adotado pela comunidade e, agora, quando algu√©m fala sobre o PIC (Programm Interrupt Controller), ele se refere ao sistema Dual PIC.  Depois de algum tempo, os controladores 8259 foram aprimorados e receberam um novo nome: 8259A.  Com esses controladores, o sistema DUAL PIC foi inclu√≠do no chipset.  No momento em que o barramento principal para conex√£o de dispositivo externo era o ISA, esse sistema era suficiente.  S√≥ era necess√°rio que diferentes dispositivos n√£o se conectassem √† mesma linha de IRQ, pois as interrup√ß√µes do ISA n√£o s√£o compartilh√°veis. <br><br>  O mapeamento de interrup√ß√£o do dispositivo era praticamente padr√£o: <br><br>  Exemplo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> ): <br>  IRQ 0 - temporizador do sistema <br>  IRQ 1 - controlador de teclado <br>  IRQ 2 - cascata (interrup√ß√£o do controlador escravo) <br>  IRQ 3 - porta serial COM2 <br>  IRQ 4 - porta serial COM1 <br>  IRQ 5 - porta paralela 2 e 3 ou placa de som <br>  IRQ 6 - controlador de disquete <br>  IRQ 7 - porta paralela 1 <br>  IRQ 8 - Temporizador RTC <br>  IRQ 9 - ACPI <br>  IRQ 10 - aberto / SCSI / NIC <br>  IRQ 11 - aberto / SCSI / NIC <br>  IRQ 12 - controlador de mouse <br>  IRQ 13 - co-processador matem√°tico <br>  IRQ 14 - canal ATA 1 <br>  IRQ 15 - canal ATA 2 <br><br>  A configura√ß√£o e o trabalho com os chips 8259 s√£o realizados com portas de E / S: <br><div class="scrollable-table"><table><tbody><tr><th>  Chip </th><th>  Registre-se </th><th>  Porta de E / S </th></tr><tr><td>  Foto principal </td><td>  Comando </td><td>  0x0020 </td></tr><tr><td>  Foto principal </td><td>  Dados </td><td>  0x0021 </td></tr><tr><td>  Escravo </td><td>  Comando </td><td>  0x00A0 </td></tr><tr><td>  Escravo </td><td>  Dados </td><td>  0x00A1 </td></tr></tbody></table></div><br>  A documenta√ß√£o completa do 8259A pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  O barramento PCI posteriormente substituiu o barramento ISA.  Infelizmente, o n√∫mero de dispositivos come√ßou a exceder o n√∫mero 15. Al√©m disso, em vez do barramento ISA est√°tico, os dispositivos no barramento PCI podem ser adicionados ao sistema dinamicamente, o que pode levar a problemas ainda maiores.  Felizmente, por√©m, as interrup√ß√µes no barramento PCI podem ser compartilhadas, portanto, √© poss√≠vel conectar muitos dispositivos a um IRQ de uma linha de interrup√ß√£o.  No final, para resolver o problema da falta de linhas de interrup√ß√£o, foi decidido agrupar interrup√ß√µes de todos os dispositivos PCI em linhas PIRQ (solicita√ß√£o de interrup√ß√£o program√°vel). <br><br>  Por exemplo, suponha que tenhamos 4 linhas de interrup√ß√£o livres no controlador PIC e 20 dispositivos PCI.  Podemos combinar interrup√ß√µes de 5 dispositivos em uma linha PIRQx e conectar essas linhas PIRQx ao controlador PIC.  Nesse caso, se houver uma interrup√ß√£o em uma das linhas PIRQx, o processador precisar√° solicitar a todos os dispositivos conectados a essa linha sobre a interrup√ß√£o para saber quem √© respons√°vel por ela, mas, no final, resolve o problema.  O dispositivo que conecta as linhas de interrup√ß√£o PCI √†s linhas PIRQ √© geralmente chamado de roteador PIR. <br><br>  Com esse m√©todo, √© necess√°rio garantir que as linhas PIRQx n√£o se conectem √†s linhas com interrup√ß√µes ISA (pois isso produzir√° conflitos) e que as linhas PIRQx sejam equilibradas (quanto mais dispositivos conectamos a uma linha, mais dispositivos a CPU precisar√° para pesquisar quando precisa verificar qual dispositivo √© respons√°vel pela interrup√ß√£o). <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>Nota</b> : na imagem, o mapeamento do dispositivo PCI -&gt; PIR √© mostrado abstratamente, pois, no caso real, √© um pouco mais complicado.  No mundo real, cada dispositivo PCI possui 4 linhas de interrup√ß√£o (INTA, INTB, INTC, INTD) e at√© 8 fun√ß√µes, onde cada fun√ß√£o pode ter apenas uma dessas interrup√ß√µes INTx.  Qual linha INTx ser√° usada por cada fun√ß√£o √© determinada pela configura√ß√£o do chipset. <br><br>  Por sua natureza, as fun√ß√µes s√£o blocos l√≥gicos separados.  Por exemplo, um dispositivo PCI pode ter uma fun√ß√£o de controlador Smbus, uma fun√ß√£o de controlador SATA e uma fun√ß√£o de ponte LPC.  Do ponto de vista de um sistema operacional (SO), cada fun√ß√£o √© como um dispositivo separado com seu pr√≥prio espa√ßo de configura√ß√£o (configura√ß√£o PCI). <br><br>  As informa√ß√µes sobre o roteamento de interrup√ß√£o do controlador PIC s√£o enviadas ao sistema operacional pelo BIOS, com a ajuda da tabela $ PIR e pelos registros 3Ch (INT_LN Linha de interrup√ß√£o (R ‚Äã‚Äã/ W)) e 3Dh (INT_PN Interrupt Pin (RO)) de o espa√ßo de configura√ß√£o do PCI para cada fun√ß√£o. <br><br>  Uma especifica√ß√£o para a tabela $ PIR estava recentemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site da Microsoft</a> , mas atualmente n√£o est√° dispon√≠vel.  √â poss√≠vel entender o conte√∫do da tabela na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Especifica√ß√£o do BIOS PCI</a> [4.2.2.  Obtenha as op√ß√µes de roteamento de interrup√ß√£o PCI] ou a partir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">daqui</a> (o √∫ltimo link est√° em russo, mas voc√™ pode tentar pesquisar no Google "Especifica√ß√£o da tabela de roteamento PCI IRQ") <br><br><h3>  Apic </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">osdev</a> ) <br><br>  O √∫ltimo m√©todo funcionou at√© a chegada dos sistemas multiprocessadores.  Por natureza, o PIC s√≥ pode enviar interrup√ß√µes para uma CPU e, em um sistema multiprocessador, √© desejado carregar as CPUs de maneira equilibrada.  A solu√ß√£o para esse problema foi a nova interface APIC (Advanced PIC). <br><br>  Um controlador especial chamado LAPIC (APIC local) foi adicionado para cada processador, bem como o controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">APIC de E / S</a> para rotear interrup√ß√µes de dispositivos externos.  Todos esses controladores s√£o combinados em um barramento comum com o nome APIC (observe que os sistemas modernos usam um barramento de sistema padr√£o em vez de um barramento APIC separado para esta tarefa). <br><br>  Quando uma interrup√ß√£o externa chega na entrada I / O APIC, o controlador envia uma mensagem de interrup√ß√£o ao LAPIC de uma das CPUs do sistema.  Dessa maneira, o controlador de E / S APIC ajuda a equilibrar a carga de interrup√ß√£o entre os processadores. <br><br>  O primeiro chip APIC foi o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">82489DX</a> , que era um chip separado que possu√≠a um LAPIC e um E / S APIC conectados.  Para um sistema com processador duplo, tr√™s desses chips eram necess√°rios: dois para LAPIC e um para E / S APIC.  Posteriormente, a funcionalidade LAPIC foi inclu√≠da diretamente nos processadores e a parte I / O APIC foi separada no chip 82093AA. <br><br>  O E / S APIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">82093AA</a> tinha 24 entradas e a arquitetura APIC podia suportar at√© 16 CPUs.  As interrup√ß√µes de 0 a 15 foram deixadas para interrup√ß√µes antigas do ISA para compatibilidade com sistemas mais antigos, e as interrup√ß√µes de 16 a 23 foram feitas para todos os dispositivos PCI.  Com essa delimita√ß√£o, todos os conflitos entre as interrup√ß√µes ISA e PCI podem ser facilmente evitados.  Com o aumento do n√∫mero de linhas de interrup√ß√£o livres, tamb√©m foi poss√≠vel aumentar o n√∫mero de linhas PIRQx. <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  A programa√ß√£o de E / S APIC e LAPIC √© feita com a ajuda do MMIO.  Os registros LAPIC geralmente s√£o colocados no endere√ßo 0xFEE00000, e os E / S APIC registram no endere√ßo 0xFE0000, embora seja poss√≠vel reconfigur√°-los. <br><br>  Como no caso do PIC, chips separados no in√≠cio se tornaram parte do chipset posteriormente. <br><br>  A arquitetura APIC foi posteriormente modernizada e sua nova variante foi denominada xAPIC (x - extended).  Com compatibilidade com vers√µes anteriores, o n√∫mero total de CPUs poss√≠veis no sistema foi aumentado para 256. <br><br>  A pr√≥xima etapa no desenvolvimento da arquitetura foi denominada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">x2APIC</a> .  O n√∫mero de CPUs poss√≠veis no sistema foi aumentado para 2 ^ 32.  Esses controladores podem funcionar em um modo de compatibilidade com o xAPIC, ou podem funcionar no novo modo x2APIC.  Nesse novo modo, a programa√ß√£o do controlador n√£o √© feita atrav√©s do MMIO, mas atrav√©s dos registros MSR (que s√£o muito mais r√°pidos).  De acordo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este link</a> , o suporte ao IOMMU √© necess√°rio para este modo. <br><br>  Vale a pena notar que √© poss√≠vel ter v√°rios controladores de E / S APIC no sistema.  Por exemplo, um por 24 interrup√ß√µes em uma ponte sul e outro por 32 interrup√ß√µes em uma ponte norte.  No contexto da E / S APIC, as interrup√ß√µes s√£o geralmente chamadas GSI (Global System Interrupt).  Portanto, o sistema mencionado possui GSIs 0-55. <br><br>  Como podemos determinar se uma CPU possui um LAPIC interno e qual arquitetura APIC suporta?  √â poss√≠vel responder a essas perguntas inspecionando sinalizadores de bits do CPUID. <br>  Para ajudar o SO a descobrir o LAPIC e o I / O APIC, o BIOS deve apresentar informa√ß√µes sobre eles atrav√©s de um MPtable (m√©todo antigo) ou atrav√©s de uma tabela ACPI (neste caso, uma tabela MADT).  Al√©m de informa√ß√µes comuns, o MPtable e o ACPI (neste caso, uma tabela DSDT) devem conter informa√ß√µes sobre o roteamento de interrup√ß√£o.  Isso significa informa√ß√µes sobre qual dispositivo usa qual linha de interrup√ß√£o (semelhante √† tabela $ PIR). <br><br>  Voc√™ pode ler sobre o MPtable na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20121002210153/">especifica√ß√£o</a> oficial.  Anteriormente, a especifica√ß√£o estava no site da Intel, mas atualmente s√≥ √© poss√≠vel encontr√°-la em uma vers√£o de arquivo.  A especifica√ß√£o da ACPI pode ser encontrada no site da UEFI (a vers√£o atual √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6.2</a> ).  Vale a pena notar que, com a ACPI, √© poss√≠vel declarar o roteamento de interrup√ß√£o para sistemas sem APIC (em vez de fornecer uma tabela $ PIR separada). <br><br><h3>  Msi </h3><br>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> ) <br><br>  A √∫ltima variante do APIC foi boa, mas n√£o sem desvantagens.  Todas as linhas de interrup√ß√£o dos dispositivos tornaram o sistema muito complicado e, portanto, aumentaram a probabilidade de erro.  O barramento PCI Express veio substituir o barramento PCI, o que simplificou completamente todos os sistemas de interrup√ß√£o.  N√£o possui linhas de interrup√ß√£o.  Para compatibilidade com vers√µes anteriores, os sinais de interrup√ß√£o (INTx #) s√£o emulados com um tipo separado de mensagens.  Com as linhas de interrup√ß√£o PCI, a conex√£o era feita com fios f√≠sicos.  Com as linhas de interrup√ß√£o PCI Express, a conex√£o √© l√≥gica e √© feita por pontes PCI Express.  Mas esse suporte a interrup√ß√µes herdadas do INTx existe apenas para compatibilidade retroativa com o barramento PCI.  O PCI Express apresenta um m√©todo completamente novo de entrega de interrup√ß√£o - MSI (interrup√ß√µes sinalizadas por mensagens).  Neste m√©todo, um dispositivo sinaliza sobre a interrup√ß√£o simplesmente escrevendo em um local especial na regi√£o MMIO das CPUs LAPIC. <br><br><img src="https://habrastorage.org/webt/8z/qw/7h/8zqw7him-vupzm_wi5glkqtr1ja.png"><br><br>  Anteriormente, um √∫nico dispositivo PCI (isso significa todas as suas fun√ß√µes) poderia ter apenas 4 interrup√ß√µes, mas agora tornou-se poss√≠vel resolver at√© 32 interrup√ß√µes. <br><br>  No caso do MSI, n√£o h√° compartilhamento de linhas de interrup√ß√£o: toda interrup√ß√£o corresponde naturalmente ao seu dispositivo. <br><br>  As interrup√ß√µes MSI tamb√©m resolvem mais um problema.  Por exemplo, vamos imaginar uma situa√ß√£o em que um dispositivo fa√ßa uma transa√ß√£o de grava√ß√£o na mem√≥ria e queira sinalizar sua conclus√£o atrav√©s da interrup√ß√£o.  Mas uma transa√ß√£o de grava√ß√£o pode ser atrasada no barramento no processo de sua transmiss√£o (e o dispositivo n√£o poderia saber sobre isso).  Nesse caso, o sinal sobre a interrup√ß√£o chegar√° primeiro √† CPU, para que o processador leia os dados ainda n√£o v√°lidos.  Se o MSI for usado, as informa√ß√µes sobre o MSI s√£o transmitidas da mesma maneira que as mensagens de dados e, portanto, n√£o podem ser fornecidas mais cedo. <br><br>  Vale a pena notar que as interrup√ß√µes do MSI n√£o podem funcionar sem o LAPIC, mas os MSI podem substituir o E / S APIC (mais uma simplifica√ß√£o de design). <br><br>  Ap√≥s algum tempo, o m√©todo MSI foi estendido para o MSI-X.  Agora, todos os dispositivos podem ter at√© 2048 interrup√ß√µes.  Agora tamb√©m √© poss√≠vel especificar qual CPU deve processar qual interrup√ß√£o.  Pode ser muito √∫til para dispositivos de alta carga, como placas de rede, por exemplo. <br><br>  N√£o h√° necessidade de uma tabela BIOS separada para suporte a MSI.  Mas o dispositivo deve indicar seu suporte MSI atrav√©s de um dos recursos em seu espa√ßo PCI Config.  Al√©m disso, um driver de dispositivo deve incluir todo o suporte necess√°rio para trabalhar com o MSI. <br><br><h3>  Conclus√£o </h3><br>  Neste artigo, estudamos informa√ß√µes sobre a evolu√ß√£o do controlador de interrup√ß√£o e obtivemos um conhecimento te√≥rico comum sobre a entrega de interrup√ß√£o de dispositivos externos no sistema x86. <br><br>  Na pr√≥xima parte, iremos praticar e ver como envolver cada um dos controladores de interrup√ß√£o mencionados no Linux. <br><br>  Na terceira parte, examinaremos o c√≥digo do coreboot e veremos quais configura√ß√µes s√£o necess√°rias no chipset para o roteamento correto de interrup√ß√µes. <br><br><h4>  Liga√ß√µes: </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Controladores de interrup√ß√£o (itens intermedi√°rios)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que as diferentes interrup√ß√µes no PCIe fazem?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reduzindo a lat√™ncia de interrup√ß√£o atrav√©s do uso de interrup√ß√µes sinalizadas por mensagem</a> </li></ul><br><h4>  Segmentos reconhecidos </h4><br>  Um agradecimento especial a Jacob Garber, da comunidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coreboot</a> , por me ajudar com a tradu√ß√£o deste artigo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446312/">https://habr.com/ru/post/pt446312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446300/index.html">Como coordenar o voo da sonda na estratosfera (o que encontraremos na pr√°tica no lan√ßamento)</a></li>
<li><a href="../pt446302/index.html">9 cita√ß√µes de Habraseminar 2019 para blogueiros, empreendedores e RH</a></li>
<li><a href="../pt446304/index.html">Fun√ß√µes f√≠sicas n√£o clon√°veis: prote√ß√£o de eletr√¥nicos contra c√≥pia ilegal</a></li>
<li><a href="../pt446306/index.html">Guerras nucleares do passado distante?</a></li>
<li><a href="../pt446308/index.html">O recrutamento de refer√™ncia est√° vivo em TI?</a></li>
<li><a href="../pt446316/index.html">Apenas espa√ßo! Um enorme peda√ßo de tit√¢nio em 6,5 dias</a></li>
<li><a href="../pt446320/index.html">Como o scanner 3D permitiu abandonar o conjunto de controle em escala real da ponte</a></li>
<li><a href="../pt446322/index.html">Criptografia em Java. Utilit√°rio Keytool</a></li>
<li><a href="../pt446324/index.html">Navega√ß√£o no DataGrip com Yandex.Navigator</a></li>
<li><a href="../pt446326/index.html">Resolvendo problemas de tr√°fego</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>