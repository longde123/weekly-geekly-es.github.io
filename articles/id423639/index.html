<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€âš–ï¸ ğŸ• ğŸ¤¯ Penulisan array yang lebih efisien ke memori persisten kontrak pintar dalam Solidity ğŸ¬ ğŸ¥ ğŸ¥›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya harus bekerja sedikit dengan blockchain Ethereum . Gagasan yang saya kerjakan diperlukan untuk menyimpan sejumlah besar bilangan b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penulisan array yang lebih efisien ke memori persisten kontrak pintar dalam Solidity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423639/"> Baru-baru ini, saya harus bekerja sedikit dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blockchain Ethereum</a> .  Gagasan yang saya kerjakan diperlukan untuk menyimpan sejumlah besar bilangan bulat langsung di blockchain sehingga kontrak pintar memiliki akses mudah ke mereka.  Sebagian besar pelajaran tentang mengembangkan kontrak cerdas memberi tahu kami, "jangan menyimpan banyak data di blockchain, itu mahal!"  Tetapi berapa "banyak", dan berapa harga terlalu tinggi untuk penggunaan praktis?  Saya harus mengetahuinya, karena kami tidak bisa membuat data kami tidak terkendali, seluruh gagasan itu runtuh. <br><br>  Saya baru mulai bekerja dengan Solidity dan EVM, jadi artikel ini tidak mengklaim sebagai kebenaran pamungkas, tetapi saya tidak dapat menemukan materi lain tentang topik ini baik dalam bahasa Rusia maupun bahasa Inggris (walaupun sangat buruk bahwa saya tidak menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> sebelumnya) ), jadi saya harap ini bisa bermanfaat bagi seseorang.  Ya, atau sebagai upaya terakhir, mungkin berguna bagi saya jika kawan yang berpengalaman memberi tahu saya bagaimana dan di mana tepatnya saya salah. <br><br>  Pertama-tama, saya memutuskan untuk mencari tahu apakah kita bisa melakukannya?  Mari kita ambil tipe kontrak standar dan tersebar luas - token <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ERC20</a> .  Setidaknya, kontrak semacam itu menyimpan di blockchain korespondensi dari alamat orang-orang yang membeli token dengan saldo mereka.  Pada kenyataannya, hanya saldo yang disimpan, yang masing-masing membutuhkan 32 byte (pada kenyataannya, tidak masuk akal untuk menyimpan di sini karena fitur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solidity</a> dan EVM).  Token yang kurang lebih sukses dapat dengan mudah memiliki puluhan ribu pemilik, dan dengan demikian kita mendapatkan bahwa menyimpan sekitar 320.000 byte di blockchain dapat diterima dengan baik.  Dan kami tidak membutuhkan lebih banyak! <br><br><h2>  Pendekatan naif </h2><br>  Baiklah, mari kita coba untuk menyimpan data kita.  Sebagian besar dari mereka adalah bilangan bulat 8-bit yang tidak ditandatangani, jadi kami akan mentransfer array mereka ke kontrak, dan mencoba menulisnya ke memori hanya baca: <br><a name="habracut"></a><br><pre><code class="javascript hljs">uint8[] m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint8[] data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre> <br>  Gufi!  Fungsi ini memakan gas, seolah-olah tidak dengan sendirinya.  Upaya untuk menghemat 100 nilai biaya kami gas 814033, gas 8100 per byte! <br><br>  Buang napas dan mundur selangkah ke teori.  Berapa biaya minimum (dalam gas) untuk menyimpan data pada blockchain Ethereum?  Harus diingat bahwa data disimpan dalam blok 32 byte.  EVM dapat membaca atau menulis hanya seluruh blok sekaligus, jadi idealnya, data yang akan ditulis harus dikemas seefisien mungkin sehingga satu perintah tulis menghemat lebih cepat.  Karena perintah perekaman yang sama - SSTORE - saja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harganya 20.000 gas</a> (jika kita menulis ke sel memori yang belum pernah kita tulis sebelumnya).  Jadi minimum teoritis kami, mengabaikan semua pengeluaran lain, adalah sekitar 625 gas per byte.  Jauh dari 8100 yang kita dapatkan dalam contoh di atas!  Sekarang adalah waktunya untuk menggali lebih dalam dan mencari tahu siapa yang memakan gas kita, dan bagaimana cara menghentikannya. <br><br>  Impuls pertama kami adalah melihat kode yang dihasilkan oleh kompiler Solidity dari baris tunggal kami (m_test = data), karena tidak ada lagi yang bisa dilihat.  Ini adalah dorongan yang baik dan benar yang akan membiasakan kita dengan fakta yang menakutkan - kompiler di tempat ini menghasilkan beberapa kengerian kuno yang tidak akan Anda pahami pada pandangan pertama!  Melihat daftar dengan cepat, kita melihat di sana tidak hanya SSTORE (yang diharapkan), tetapi juga SLOAD (memuat dari memori read-only) dan bahkan EXP (exponentiation)!  Secara keseluruhan, ini terlihat seperti cara yang sangat mahal untuk merekam data.  Dan yang terburuk, menjadi sangat jelas bahwa SSTORE dipanggil terlalu sering.  Apa yang sedang terjadi di sini? <br><br>  Beberapa hal.  Ternyata menyimpan bilangan bulat 8-bit hampir merupakan hal terburuk yang dapat Anda lakukan dengan EVM / Solidity (artikel, tautan yang saya kutip di awal, berbicara tentang ini).  Kami kehilangan produktivitas (yang berarti kami membayar lebih banyak gas) di setiap belokan.  Pertama, ketika kita melewatkan array nilai 8-bit ke input fungsi kita, masing-masing dari mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengembang</a> menjadi 256 bit.  Artinya, hanya dengan ukuran data transaksi kita sudah kehilangan 32 kali!  Bagus  Namun, pembaca yang penuh perhatian akan melihat bahwa biaya untuk byte yang disimpan masih hanya 13 kali lebih tinggi dari minimum teoritis, dan bukan 32, yang berarti bahwa ketika kontrak disimpan secara permanen ke memori, semuanya tidak terlalu buruk.  Begini: ketika menyimpan, ia mengemas data, dan dalam memori permanen kontrak, nomor 8-bit kami akan disimpan dengan cara yang paling efisien, 32 buah di setiap blok memori.  Ini menimbulkan pertanyaan, tetapi bagaimana konversi nomor yang dibongkar â€œ256-bitâ€ yang datang kepada kami di input fungsi menjadi bentuk yang dikemas?  Jawabannya adalah "cara paling bodoh yang bisa saya bayangkan." <br><br>  Jika kita menuliskan semua yang terjadi dalam bentuk yang disederhanakan, maka baris kode kita yang kesepian berubah menjadi siklus yang menakutkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(uint i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.length; ++i) { <span class="hljs-comment"><span class="hljs-comment">//      ,    256-bit  8-bit uint8 from_value = uint8(data[i]); //  32-     -        ,     uint256 to_value = get_storage_data_at_offset(m_test, i); //        (    2  ) add_byte_to_value(to_value, i % 32, from_value); //  32-      set_storage_data_at_offset(m_test, i, to_value); }</span></span></code> </pre><br>  Cara kode ini terlihat hampir tidak terpengaruh dengan mengaktifkan atau menonaktifkan optimasi (setidaknya dalam kompiler Solidity versi 0.4.24), dan seperti yang Anda lihat, kode ini memanggil SSTORE (sebagai bagian dari set_storage_data_at_offset) 32 kali lebih sering daripada yang diperlukan (sekali untuk setiap nomor 8-bit, dan tidak sekali untuk 32 nomor tersebut).  Apa yang menyelamatkan kita dari kegagalan total adalah bahwa merekam ulang dalam sel yang sama harganya bukan 20.000, tetapi 5.000 gas.  Jadi setiap 32 byte biayanya 20.000 + 5.000 * 31 = 125.000 gas, atau sekitar 4.000 gas per byte.  Sisa nilai yang kami lihat di atas berasal dari membaca memori (juga bukan operasi yang murah) dan perhitungan lain yang tersembunyi dalam kode di atas dalam fungsi (dan ada banyak dari mereka). <br><br>  Yah, kita tidak bisa melakukan apa-apa dengan kompiler, <s>jadi kita akan mencari tombol</s> .  Tinggal menyimpulkan bahwa tidak perlu mentransfer dan menyimpan dalam array kontrak nomor 8-bit dengan cara ini. <br><br><h2>  Solusi sederhana untuk nomor 8-bit </h2><br>  Dan apa yang perlu?  Jadi: <br><br><pre> <code class="javascript hljs">bytes m_test; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bytes data</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ m_test = data; }</code> </pre><br>  Kami beroperasi di semua bidang tipe byte.  Dengan pendekatan ini, menghemat 100 nilai akan menelan biaya 1.29914 gas - hanya 1.300 gas per byte, 6 kali lebih baik daripada menggunakan uint8 []!  Biaya untuk hal ini adalah ketidaknyamanan - elemen-elemen dari array tipe byte adalah tipe byte1, yang tidak secara otomatis dikonversi ke tipe integer biasa, jadi Anda harus meletakkan konversi tipe eksplisit di tempat yang tepat.  Tidak terlalu bagus, tetapi keuntungannya 6 kali lipat dari biaya rekaman, saya pikir itu sepadan!  Dan, ya, kita akan kehilangan sedikit ketika bekerja dengan data ini nanti, saat membaca, dibandingkan dengan menyimpan setiap angka sebagai 256-bit, tetapi di sini skalanya mulai menjadi masalah: keuntungan dari menyimpan seribu atau dua angka 8-bit dalam bentuk yang dikemas dapat , tergantung pada tugasnya, lebih besar daripada kerugiannya saat membacanya nanti. <br><br>  Sebelum datang ke pendekatan ini, saya pertama kali mencoba untuk menulis fungsi yang lebih efisien untuk menyimpan data di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JULIA</a> assembler makro lokal, tetapi saya mengalami beberapa masalah yang membuat solusi saya sedikit kurang efisien, dan memberikan konsumsi sekitar 1530 gas per byte  Namun, hal itu tetap berguna bagi kita dalam artikel ini, sehingga pekerjaan yang dilakukan tidak sia-sia. <br><br>  Selain itu, saya perhatikan bahwa semakin banyak data yang Anda simpan pada suatu waktu, semakin sedikit biaya per byte yang keluar, yang menunjukkan bahwa sebagian dari biaya tetap.  Misalnya, jika Anda menyimpan 3000 nilai, maka ketika mendekati byte kami mendapatkan 900 gas per byte. <br><br><h2>  Solusi yang lebih umum </h2><br>  Nah, itu, semuanya baik-baik saja, itu berakhir dengan baik, bukan?  Tetapi masalah kami tidak berakhir di sini, karena kadang-kadang kami ingin menulis tidak hanya angka 8-bit ke memori kontrak, tetapi juga tipe data lain yang tidak cocok langsung dengan tipe byte.  Artinya, jelas bahwa apa pun dapat dikodekan ke buffer byte, tetapi mendapatkannya dari sana nanti mungkin tidak lagi nyaman, dan bahkan mahal karena gerakan yang tidak perlu untuk mengubah memori mentah ke tipe yang diinginkan.  Jadi fungsi yang menyimpan array byte yang dikirimkan ke array dari tipe yang diinginkan masih berguna bagi kita.  Ini cukup sederhana, tetapi butuh waktu lama untuk menemukan semua informasi yang diperlukan dan memahami EVM dan JULIA untuk menulisnya, dan semua ini tidak dikumpulkan di satu tempat.  Karena itu, saya pikir ini akan berguna jika saya membawa apa yang saya gali ke sini. <br><br>  Untuk memulai, mari kita bicara tentang bagaimana Solidity menyimpan array dalam memori.  Array adalah konsep yang hanya ada dalam kerangka Solidity, EVM tidak tahu apa-apa tentang mereka, tetapi hanya menyimpan array virtual 2 ^ 256 blok 32-byte.  Jelas bahwa blok kosong tidak disimpan, tetapi pada kenyataannya, kami memiliki tabel blok kosong, yang kuncinya adalah angka 256-bit.  Dan justru angka inilah yang diterima oleh perintah EVM SSTORE dan SLOAD sebagai input (ini tidak sepenuhnya jelas dari dokumentasi). <br><br>  Untuk menyimpan array, Solidity melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hal yang rumit</a> : pertama, array blok "utama" dialokasikan untuknya di suatu tempat dalam memori konstan, dalam urutan penempatan anggota kontrak (atau struktur, seperti biasa, tetapi ini adalah lagu yang terpisah), seolah-olah itu adalah nomor 256-bit reguler.  Ini memastikan bahwa array menerima satu blok penuh, terlepas dari variabel tersimpan lainnya.  Blok ini menyimpan panjang array.  Tetapi karena tidak diketahui sebelumnya, dan dapat berubah (kita berbicara tentang array dinamis di sini), penulis Solidity perlu mencari tahu di mana harus meletakkan data array sehingga mereka tidak akan secara tidak sengaja berpotongan dengan data array lain.  Sebenarnya, ini adalah tugas yang tidak dapat diselesaikan: jika Anda membuat dua array lebih dari 2 ^ 128 panjang, maka mereka dijamin untuk berpotongan di mana Anda tidak menempatkan mereka, tetapi dalam praktiknya tidak ada yang harus melakukan ini, jadi trik sederhana ini digunakan: ambil hash SHA3 dari jumlah blok utama array , dan angka yang dihasilkan digunakan sebagai kunci dalam tabel blok (yang, saya ingat, 2 ^ 256).  Dengan kunci ini, blok pertama dari data array ditempatkan, dan sisanya - secara berurutan setelahnya, jika perlu.  Probabilitas tabrakan array non-raksasa sangat kecil. <br><br>  Jadi, secara teori, yang perlu kita lakukan adalah menemukan di mana data array berada dan menyalin buffer byte yang dilewatkan kepada kita blok demi blok.  Sementara kita bekerja dengan tipe yang lebih kecil dari setengah ukuran blok, kita setidaknya akan sedikit memenangkan solusi "naif" yang dihasilkan oleh kompiler. <br><br>  Hanya ada satu masalah yang tersisa - jika semuanya dilakukan seperti itu, maka byte dalam array kami akan berubah mundur.  Karena EVM adalah big-endian.  Cara termudah dan paling efisien, tentu saja, adalah menggunakan byte saat mengirim, tetapi untuk kesederhanaan, saya memutuskan untuk melakukan ini dalam kode kontrak.  Jika Anda ingin menyimpan lebih banyak, jangan buang bagian fungsi ini, dan lakukan semuanya pada saat pengiriman. <br><br>  Berikut adalah fungsi yang saya harus mengubah array byte menjadi array integer bertanda 64-bit (namun, dapat dengan mudah disesuaikan dengan jenis lain): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign_int64_storage_from_bytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">int64[] storage to, bytes memory from</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">internal</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    .      int64,     8    (sizeof  Solidity  :( ) to.length = from.length / 8; //     ,  SHA3      uint256 addr; bytes32 base; assembly{ // keccak256   ,    ,          mstore(addr, to_slot) base := keccak256(addr, 32) } uint i = 0; for(uint offset = 0; offset &lt; from.length; offset += 32) { //  32-     //     32  -  ,   ,     uint256 tmp; assembly{ tmp := mload(add(from, add(offset,32))) } //   .  ,     ,       . for(uint b = 0; b &lt; 16; ++b) { uint shift = b*8; uint shift2 = (256 - (b+1)*8); uint low = (tmp &amp; (0xFF &lt;&lt; shift)) &gt;&gt; shift; uint high = (tmp &amp; (0xFF &lt;&lt; shift2)) &gt;&gt; shift2; tmp = tmp &amp; ~( (0xFF &lt;&lt; shift) | (0xFF &lt;&lt; shift2)); tmp = tmp | (low &lt;&lt; shift2) | (high &lt;&lt; shift); } //      assembly{ sstore(add(base, i), tmp) } i += 1; } }</span></span></code> </pre><br>  Dengan angka 64-bit, kami menang tidak sebanyak dengan yang 8-bit, dibandingkan dengan kode yang dihasilkan oleh kompiler, tetapi meskipun demikian fungsi ini mengkonsumsi 718466 gas (7184 gas per angka, 898 gas per byte) dibandingkan 1003225 untuk naif solusi (1003 gas per angka, 1254 per byte), yang menjadikan penggunaannya cukup berarti.  Dan seperti yang disebutkan di atas, Anda dapat menyimpan lebih banyak dengan menghapus alamat byte ke pemanggil. <br><br>  Perlu dicatat bahwa batas gas per unit di Ethereum menetapkan batas berapa banyak data yang dapat kita rekam dalam satu transaksi.  Lebih buruk lagi, menambahkan data ke array yang sudah diisi adalah tugas yang jauh lebih sulit, kecuali ketika blok array yang terakhir digunakan diisi hingga batas (dalam hal ini Anda dapat menggunakan fungsi yang sama, tetapi dengan indentasi berbeda).  Saat ini, batas gas per blok adalah sekitar 6 juta, yang berarti bahwa kita dapat lebih atau kurang menghemat 6Kb data pada suatu waktu, tetapi pada kenyataannya bahkan lebih sedikit, karena pengeluaran lain. <br><br><h2>  Perubahan yang akan terjadi </h2><br>  Perubahan mendatang dalam jaringan Ethereum pada bulan Oktober, yang akan terjadi dengan aktivasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EIP</a> milik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konstantinopel</a> , akan membuatnya lebih mudah dan lebih murah untuk menyimpan data - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EIP 1087</a> menyarankan bahwa biaya penyimpanan data akan dibebankan bukan untuk setiap perintah SSTORE, tetapi untuk jumlah blok yang diubah, yang akan membuat pendekatan naif yang digunakan oleh kompiler, hampir sama menguntungkannya dengan kode yang ditulis secara manual di JULIA (tetapi tidak cukup - akan ada banyak gerakan tubuh tambahan di sana, terutama untuk nilai 8-bit).  Transisi yang direncanakan ke WebAssembly sebagai bahasa dasar EVM akan mengubah gambar lebih banyak, tetapi ini masih merupakan prospek yang sangat jauh, dan kita perlu menyelesaikan masalah sekarang. <br><br>  Posting ini tidak mengklaim sebagai solusi terbaik untuk masalah ini, dan saya akan senang jika seseorang menawarkan yang lebih efektif - Saya baru mulai memulai dengan Ethereum, dan dapat kehilangan beberapa fitur EVM yang dapat membantu saya.  Tetapi dalam pencarian saya di internet, saya tidak melihat apa-apa tentang masalah ini, dan mungkin pemikiran dan kode di atas akan berguna bagi seseorang sebagai titik awal untuk optimasi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423639/">https://habr.com/ru/post/id423639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423629/index.html">Mars Manajemen Perubahan Infrastruktur IT</a></li>
<li><a href="../id423631/index.html">Dua keterampilan yang akan membantu Anda menjadi pengembang yang hebat</a></li>
<li><a href="../id423633/index.html">Kami menggunakan 54 Hukum Federal untuk kepentingan akuntansi rumah</a></li>
<li><a href="../id423635/index.html">Pemutar buku audio gaya retro</a></li>
<li><a href="../id423637/index.html">7 pelajaran praktis tentang UX</a></li>
<li><a href="../id423641/index.html">Pembelajaran yang mendalam dan OpenVINO Toolkit. Jawaban pakar Intel</a></li>
<li><a href="../id423643/index.html">Bank semakin memantau reputasi pelanggan: Investigasi Business Insider</a></li>
<li><a href="../id423645/index.html">Bagaimana kami melayani infrastruktur TI Luzhniki selama Piala Dunia</a></li>
<li><a href="../id423647/index.html">Buat jaringan saraf sederhana</a></li>
<li><a href="../id423649/index.html">"Kubernet ke semua bidang!" - Wawancara dengan komite program konferensi DevOops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>