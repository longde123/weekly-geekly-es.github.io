<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüåæ ü§úüèº üêâ Conceptos b√°sicos de JavaScript para principiantes üßëüèæ üïØÔ∏è ‚ôÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya traducci√≥n publicamos hoy, est√° dedicado a los conceptos b√°sicos de JavaScript y est√° destinado a programadores principiantes. Se pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos b√°sicos de JavaScript para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416375/">  El material, cuya traducci√≥n publicamos hoy, est√° dedicado a los conceptos b√°sicos de JavaScript y est√° destinado a programadores principiantes.  Se puede considerar como una peque√±a referencia a las construcciones b√°sicas de JS.  Aqu√≠, en particular, hablaremos sobre el sistema de tipo de datos, sobre variables, sobre matrices, sobre funciones, sobre prototipos de objetos y sobre algunas otras caracter√≠sticas del lenguaje. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/my/cj/zq/mycjzqfpfohnkk9vnefgsl915vm.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tipos de datos primitivos</font> </h2><br>  Los siguientes tipos de datos primitivos est√°n disponibles en JavaScript: <code>number</code> , <code>boolean</code> , <code>string</code> , <code>undefined</code> , <code>null</code> .  Cabe se√±alar de inmediato que, cuando se trabaja con tipos de datos primitivos, por ejemplo, con literales de cadena, nosotros, incluso sin realizar una conversi√≥n expl√≠cita, podremos acceder a sus m√©todos y propiedades.  El punto aqu√≠ es que cuando se intenta realizar tales operaciones, los literales se equipan autom√°ticamente con el contenedor de objetos apropiado. <br><br><h3>  <font color="#3AC1EF">‚ñç N√∫meros</font> </h3><br>  JavaScript solo tiene un tipo de n√∫mero: son n√∫meros de coma flotante de doble precisi√≥n.  Esto lleva al hecho de que los resultados del c√°lculo de algunas expresiones son aritm√©ticamente incorrectos.  Es posible que ya sepa que en JS el valor de la expresi√≥n <code>0.1 + 0.2</code> no <code>0.1 + 0.2</code> <code>0.3</code> .  Al mismo tiempo, cuando se trabaja con n√∫meros enteros, estos problemas no se observan, es decir, <code>1 + 2 === 3</code> . <br><br>  JavaScript tiene un objeto <code>Number</code> , que es un contenedor de objetos para valores num√©ricos.  Los objetos de tipo <code>Number</code> se pueden crear utilizando un comando de la forma <code>var a = new Number(10)</code> , o puede confiar en el comportamiento autom√°tico del sistema descrito anteriormente.  Esto, en particular, le permite llamar a m√©todos almacenados en <code>Number.prototype</code> como se aplica a literales num√©ricos: <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">123</span></span>).toString();  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> (<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span></code> </pre> <br>  Hay funciones globales dise√±adas para convertir valores de otros tipos a un tipo num√©rico.  Esto es <code>parseInt()</code> , <code>parseFloat()</code> y la construcci√≥n <code>Number()</code> , que en este caso act√∫a como una funci√≥n normal que realiza la conversi√≥n de tipos: <br><br><pre> <code class="hljs julia">parseInt(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)       //<span class="hljs-number"><span class="hljs-number">1</span></span> parseInt(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)    //<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> parseFloat(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>) //<span class="hljs-number"><span class="hljs-number">1.234</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)         //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>)     //<span class="hljs-number"><span class="hljs-number">1.234</span></span></code> </pre> <br>  Si durante la operaci√≥n con n√∫meros se obtiene algo que no es un n√∫mero (durante algunos c√°lculos, o al intentar convertir algo en un n√∫mero), JavaScript no arrojar√° un error, pero presentar√° el resultado de una operaci√≥n como el valor <code>NaN</code> (No-un-N√∫mero, No es un n√∫mero).  Para verificar si un cierto valor es <code>NaN</code> , puede usar la funci√≥n <code>isNaN()</code> . <br><br>  Las operaciones aritm√©ticas de JS funcionan de una manera bastante familiar, pero debe prestar atenci√≥n al hecho de que el operador <code>+</code> puede realizar la suma de n√∫meros y la concatenaci√≥n de cadenas. <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>      //<span class="hljs-number"><span class="hljs-number">2</span></span> "1" + "1"  //"11" <span class="hljs-number"><span class="hljs-number">1</span></span> + "1"    //"11"</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçStrings</font> </h3><br>  Las cadenas de JavaScript son cadenas de caracteres Unicode.  Los literales de cadena se crean encerrando el texto que se va a encerrar entre comillas dobles ( <code>""</code> ) o simples ( <code>''</code> ).  Como ya se mencion√≥, cuando trabajamos con literales de cadena, podemos confiar en el contenedor de objetos correspondiente, en cuyo prototipo hay muchos m√©todos √∫tiles, entre ellos <code>substring()</code> , <code>indexOf()</code> , <code>concat()</code> . <br><br><pre> <code class="hljs pgsql">"text".substring(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) //ex "text".indexOf(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)   //<span class="hljs-number"><span class="hljs-number">2</span></span> "text".concat(" end") //<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Las cadenas, como otros valores primitivos, son inmutables.  Por ejemplo, el m√©todo <code>concat()</code> no modifica una cadena existente, sino que crea una nueva. <br><br><h3>  <font color="#3AC1EF">‚ñç Valores l√≥gicos</font> </h3><br>  El tipo de datos l√≥gico en JS est√° representado por dos valores: <code>true</code> y <code>false</code> .  El idioma puede convertir autom√°ticamente varios valores a un tipo de datos l√≥gico.  Entonces, falso, adem√°s del valor l√≥gico <code>false</code> , son los valores <code>null</code> , <code>undefined</code> <code>''</code> (cadena vac√≠a), <code>0</code> y <code>NaN</code> .  Todo lo dem√°s, incluidos los objetos, representa verdaderos significados.  En el curso de las operaciones l√≥gicas, todo lo que se considera verdadero se convierte en <code>true</code> , y todo lo que se considera falso se convierte en <code>false</code> .  Eche un vistazo al siguiente ejemplo.  De acuerdo con los principios anteriores, una cadena vac√≠a se convertir√° en <code>false</code> y <code>false</code> como resultado de la ejecuci√≥n de este c√≥digo, la cadena <code>This is false</code> llegar√° a la consola. <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">text</span></span>) { console.log("This is true"); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log("This is false"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Los objetos</font> </h2><br>  Los objetos son estructuras din√°micas que consisten en pares clave-valor.  Los valores pueden tener tipos de datos primitivos, pueden ser objetos o funciones. <br><br>  Los objetos son m√°s f√°ciles de crear usando la sintaxis literal del objeto: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span>, <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre> <br>  Las propiedades de un objeto se pueden leer, agregar, editar y eliminar en cualquier momento.  Aqu√≠ se explica c√≥mo hacerlo: <br><br><ul><li>  Propiedades de lectura: <code>object.name, object[expression]</code> . </li><li>  Escritura de datos en propiedades (si la propiedad a la que se accede no existe, se agrega una nueva propiedad con la clave especificada): <code>object.name = value</code> , <code>object[expression] = value</code> . </li><li>  Eliminar propiedades: <code>delete object.name</code> , <code>delete object[expression]</code> . </li></ul><br>  Aqu√≠ hay algunos ejemplos: <br><br><pre> <code class="hljs ruby">let obj = {}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   delete object.message; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  </code> </pre> <br>  Los objetos en el lenguaje se implementan como tablas hash.  Se puede crear una tabla hash simple usando el <code>Object.create(null)</code> : <br><br><pre> <code class="hljs pgsql">let french = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); french["yes"] = "oui"; french["no"]  = "non"; french["yes"];//"oui"</code> </pre> <br>  Si el objeto necesita ser inmutable, puede usar el <code>Object.freeze()</code> . <br><br>  Para iterar sobre todas las propiedades de un objeto, puede usar el <code>Object.keys()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //   } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Comparaci√≥n de valores de tipos y objetos primitivos</font> </h3><br>  En el trabajo pr√°ctico con valores primitivos, puede, como ya se mencion√≥, percibirlos como objetos que tienen propiedades y m√©todos, aunque no son objetos.  Los valores primitivos son inmutables, la estructura interna de los objetos puede cambiar. <br><br><h2>  <font color="#3AC1EF">Variables</font> </h2><br>  En JavaScript, las variables se pueden declarar utilizando las palabras clave <code>var</code> , <code>let</code> y <code>const</code> . <br><br>  Con la palabra clave <code>var</code> , puede declarar una variable y, si es necesario, inicializarla con un cierto valor.  Si la variable no se inicializa, su valor <code>undefined</code> est√° <code>undefined</code> .  Las variables declaradas usando la palabra clave <code>var</code> tienen alcance funcional. <br><br>  La palabra clave <code>let</code> es muy similar a <code>var</code> , la diferencia es que las variables declaradas con la palabra clave <code>let</code> tienen alcance de bloque. <br><br>  Las variables declaradas usando la palabra clave <code>const</code> tambi√©n tienen un alcance de bloque, que, dado el hecho de que los valores de tales variables no pueden cambiarse, se denominar√°n m√°s correctamente "constantes".  La palabra clave <code>const</code> , que "congela" el valor de una variable declarada al usarla, se puede comparar con el m√©todo <code>Object.freeze()</code> , que "congela" objetos. <br><br>  Si una variable se declara fuera de una funci√≥n, su alcance es global. <br><br><h2>  <font color="#3AC1EF">Matrices</font> </h2><br>  Las matrices en JavaScript se implementan utilizando objetos.  Como resultado, cuando hablamos de matrices, de hecho, discutimos objetos similares a las matrices.  Puede trabajar con elementos de matriz utilizando sus √≠ndices.  Los √≠ndices num√©ricos se convierten en cadenas y se usan como nombres para acceder a los valores de los elementos de la matriz.  Por ejemplo, una construcci√≥n de la forma <code>arr[1]</code> similar a una construcci√≥n de la forma <code>arr['1']</code> , y ambas dar√°n acceso al mismo valor: <code>arr[1] === arr['1']</code> .  De acuerdo con lo anterior, una matriz simple declarada por el comando <code>let arr = ['A', 'B', 'C']</code> se representa como un objeto de la siguiente forma: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span> }</code> </pre> <br>  Eliminar elementos de la matriz con el comando <code>delete</code> deja agujeros en √©l.  Para evitar este problema, puede usar el comando <code>splice()</code> , pero funciona lentamente, porque, despu√©s de eliminar un elemento, mueve los elementos restantes de la matriz, desplaz√°ndolos realmente al comienzo de la matriz, a la izquierda. <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>]; delete arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; console.log(arr); // [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-type"><span class="hljs-type">empty</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>] console.log(arr.length); // <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Los m√©todos de matriz facilitan la implementaci√≥n de estructuras de datos como pilas y colas: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  let stack = []; stack.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] stack.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let last = stack.pop();  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] console.log(last);       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  let queue = []; queue.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] queue.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let first = queue.shift();/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/[2] console.log(first);      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Las funciones</font> </h2><br>  Las funciones en JavaScript son objetos.  Las funciones pueden asignarse a variables, almacenarse en objetos o matrices, pasarse como argumentos a otras funciones y devolverse desde otras funciones. <br><br>  Hay tres formas de declarar funciones: <br><br><ul><li>  Declaraci√≥n de funci√≥n cl√°sica (Declaraci√≥n de funci√≥n o Declaraci√≥n de funci√≥n). </li><li>  El uso de expresiones funcionales (Function Expression), que tambi√©n se denominan literales funcionales (Function Literal). </li><li>  Usando la sintaxis de las funciones de flecha (Funci√≥n de flecha). </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Declaraci√≥n de funci√≥n cl√°sica</font> </h3><br>  Con este enfoque para declarar funciones, se aplican las siguientes reglas: <br><br><ul><li>  La primera palabra clave en una l√≠nea de declaraci√≥n de <code>function</code> es <code>function</code> . </li><li>  Las funciones deben tener asignado un nombre. </li><li>  La funci√≥n se puede usar en el c√≥digo antes de su declaraci√≥n debido al mecanismo de elevar la declaraci√≥n de la funci√≥n a la parte superior del alcance en el que se declara. </li></ul><br>  As√≠ es como se ve una declaraci√≥n de funci√≥n cl√°sica: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Expresiones funcionales</font> </h3><br>  Cuando se usan expresiones funcionales, se debe considerar lo siguiente: <br><br><ul><li>  La palabra clave de <code>function</code> ya no es la primera palabra en una l√≠nea de declaraci√≥n de funci√≥n. </li><li>  Un nombre de funci√≥n es opcional.  Es posible utilizar expresiones funcionales an√≥nimas y con nombre. </li><li>  Los comandos para invocar tales funciones deben seguir los comandos para su declaraci√≥n. </li><li>  Dicha funci√≥n se puede iniciar inmediatamente despu√©s de la declaraci√≥n utilizando la sintaxis de IIFE (Expresi√≥n de funci√≥n invocada inmediatamente, llamada inmediatamente expresi√≥n de funci√≥n). </li></ul><br>  La expresi√≥n funcional se ve as√≠: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Funciones de flecha</font> </h3><br>  Las funciones de flecha, de hecho, pueden considerarse "az√∫car sint√°ctico" para crear expresiones funcionales an√≥nimas.  Cabe se√±alar que tales funciones no tienen sus propias entidades <code>this</code> y <code>arguments</code> .  La declaraci√≥n de la funci√≥n de flecha se ve as√≠: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = () = &gt; {};</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Formas de llamar a funciones</font> </h3><br>  Las funciones se pueden invocar de varias maneras. <br><br><h4>  Llamada a la funci√≥n normal </h4><br><pre> <code class="hljs lisp">doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Llamada de funci√≥n en forma de un m√©todo de objeto </h4><br><pre> <code class="hljs markdown">theObject.doSomething(arguments) theObject[<span class="hljs-string"><span class="hljs-string">"doSomething"</span></span>](<span class="hljs-link"><span class="hljs-link">arguments</span></span>)</code> </pre> <br><h4>  Llamada a la funci√≥n del constructor </h4><br><pre> <code class="hljs lisp">new doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Llamar a una funci√≥n usando el m√©todo apply () </h4><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.apply</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[arguments]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.call</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">arguments</span></span>)</code> </pre> <br><h4>  Llamar a una funci√≥n usando el m√©todo bind () </h4><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomethingWithObject = doSomething.bind(theObject); doSomethingWithObject();</code> </pre> <br>  Se pueden invocar funciones con m√°s o menos argumentos que el n√∫mero de par√°metros que se especificaron cuando se declararon.  En el curso del trabajo de la funci√≥n, los argumentos "adicionales" simplemente ser√°n ignorados (aunque la funci√≥n tendr√° acceso a ellos), los par√°metros faltantes obtendr√°n el valor <code>undefined</code> . <br><br>  Las funciones tienen dos pseudopar√°metros: <code>this</code> y <code>arguments</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Palabra clave esto</font> </h3><br>  La <code>this</code> representa el contexto de una funci√≥n.  El valor al que apunta depende de c√≥mo se llam√≥ la funci√≥n.  Estos son los significados de <code>this</code> palabra clave dependiendo de c√≥mo se llama la funci√≥n (se describen arriba con ejemplos de c√≥digo, cuyas construcciones se usan aqu√≠): <br><br><ul><li>  La llamada de funci√≥n habitual es <code>window</code> / <code>undefined</code> . </li><li>  Una llamada a funci√≥n en forma de m√©todo de objeto es <code>theObject</code> . </li><li>  Una llamada a funci√≥n en forma de constructor es un objeto nuevo. </li><li>  Llamar a una funci√≥n utilizando el m√©todo <code>apply()</code> : <code>theObject</code> . </li><li>  Llamar a una funci√≥n utilizando el m√©todo <code>bind()</code> : <code>theObject</code> . </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Argumentos de palabras clave</font> </h3><br>  La palabra clave <code>arguments</code> es un pseudo-par√°metro que da acceso a todos los argumentos utilizados para llamar a la funci√≥n.  Parece una matriz, pero no una matriz.  En particular, no tiene m√©todos de matriz. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reduceToSum(total, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum(){ let args = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(arguments); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); } sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Una alternativa a la palabra clave <code>arguments</code> es la nueva sintaxis para los par√°metros restantes.  En el siguiente ejemplo, <code>args</code> es una matriz que contiene todo lo que se pas√≥ a la funci√≥n cuando se llam√≥. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3>  <font color="#3AC1EF">ReturnRetorno del operador</font> </h3><br>  Una funci√≥n que no tiene una <code>return</code> devoluci√≥n volver√° <code>undefined</code> .  Con la palabra clave <code>return</code> , preste atenci√≥n a c√≥mo funciona el mecanismo de inserci√≥n autom√°tica de punto y coma.  Por ejemplo, la siguiente funci√≥n no devolver√° un objeto vac√≠o, sino un valor <code>undefined</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } } getObject()</code> </pre> <br>  Para evitar un problema similar, el corchete de apertura debe colocarse en la misma l√≠nea que la <code>return</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Escritura din√°mica</font> </h2><br>  JavaScript es un lenguaje de escritura din√°mico.  Esto significa que los valores espec√≠ficos tienen tipos, pero las variables no.  Durante la ejecuci√≥n del programa, se pueden escribir valores de diferentes tipos en la misma variable.  Aqu√≠ hay un ejemplo de una funci√≥n que funciona con valores de diferentes tipos: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ console.log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } log(<span class="hljs-number"><span class="hljs-number">1</span></span>); log("text"); log({message : "text"});</code> </pre> <br>  Para averiguar el tipo de datos almacenados en una variable, puede usar el operador <code>typeof()</code> : <br><br><pre> <code class="hljs lua">let n = <span class="hljs-number"><span class="hljs-number">1</span></span>; typeof(n);   //number let s = <span class="hljs-string"><span class="hljs-string">"text"</span></span>; typeof(s);   //<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> let fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}; typeof(fn);  //<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Modelo de ejecuci√≥n de subproceso √∫nico</font> </h2><br>  El tiempo de ejecuci√≥n de JavaScript es de un solo subproceso.  Esto, en particular, se expresa en la imposibilidad de ejecutar simult√°neamente dos funciones (si no tiene en cuenta las posibilidades de ejecuci√≥n de c√≥digo as√≠ncrono, que no tocamos aqu√≠).  El tiempo de ejecuci√≥n tiene una llamada Cola de eventos, que almacena una lista de tareas que deben procesarse.  Como resultado, el problema de los bloqueos de recursos mutuos no es t√≠pico para un esquema de ejecuci√≥n JS de subproceso √∫nico, por lo tanto, el mecanismo de bloqueo no es necesario aqu√≠.  Sin embargo, el c√≥digo que cae en la cola de eventos debe ejecutarse r√°pidamente.  Si se sobrecarga con trabajo pesado, en la aplicaci√≥n del navegador, el hilo principal, la p√°gina de la aplicaci√≥n no responder√° a las acciones del usuario y el navegador ofrecer√° cerrar esta p√°gina. <br><br><h2>  <font color="#3AC1EF">Manejo de excepciones</font> </h2><br>  JavaScript tiene un mecanismo para manejar excepciones.  Funciona de acuerdo con un principio bastante habitual para tales mecanismos: el c√≥digo que puede causar un error se ejecuta utilizando la construcci√≥n <code>try/catch</code> .  El c√≥digo en s√≠ est√° en el bloque <code>try</code> , los errores se procesan en el <code>catch</code> . <br><br>  Es interesante observar que a veces JavaScript, en caso de emergencia, no genera mensajes de error.  Esto se debe al hecho de que JS no arroj√≥ errores hasta la adopci√≥n del est√°ndar ECMAScript 3. <br><br>  Por ejemplo, en el siguiente fragmento de c√≥digo, fallar√° un intento de cambiar un objeto "congelado", pero no se lanzar√° una excepci√≥n. <br><br><pre> <code class="hljs pgsql">let obj = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({}); obj.message = "text";</code> </pre> <br>  Algunos de los errores JS "silenciosos" aparecen en modo estricto, puede habilitarlo usando la construcci√≥n <code>"use strict";</code>  . <br><br><h2>  <font color="#3AC1EF">Sistema prototipo</font> </h2><br>  La base de mecanismos JS como las funciones de constructor, el <code>Object.create()</code> , la palabra clave de <code>class</code> , se basa en un sistema prototipo. <br>  Considere el siguiente ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service = { <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> specializedService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(service); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(specializedService.__proto__ === service); <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Aqu√≠, para crear un objeto de servicio <code>specializedService</code> , cuyo prototipo era hacer un objeto de <code>service</code> , se utiliz√≥ el comando <code>Object.create()</code> .  Como resultado, resulta que se puede llamar al m√©todo <code>doSomething()</code> accediendo al objeto specialService.  Adem√°s, esto significa que la propiedad <code>__proto__</code> del objeto <code>__proto__</code> apunta a un objeto de <code>service</code> . <br><br>  Ahora cree un objeto similar usando la palabra clave de <code>class</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ doSomething(){} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecializedService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ } let specializedService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>(); console.log(specializedService.__proto__ === <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>.prototype);</code> </pre> <br>  Los m√©todos declarados en la clase de <code>Service</code> se agregar√°n al objeto <code>Service.prototype</code> .  Las instancias de la clase <code>Service</code> tendr√°n el mismo prototipo ( <code>Service.prototype</code> ).  Todas las instancias delegar√°n llamadas de m√©todo al objeto <code>Service.prototype</code> .  Como resultado, resulta que los m√©todos se declaran solo una vez, en <code>Service.prototype</code> , despu√©s de lo cual son "heredados" por todas las instancias de la clase. <br><br><h3>  <font color="#3AC1EF">‚ñç Cadena de prototipo</font> </h3><br>  Los objetos pueden ser "herederos" de otros objetos.  Cada objeto tiene un prototipo, cuyos m√©todos est√°n disponibles.  Si intenta acceder a una propiedad que no est√° en el objeto en s√≠, JavaScript comenzar√° a buscarla en la cadena de prototipos.  Este proceso continuar√° hasta que se encuentre la propiedad, o hasta que la b√∫squeda llegue al final de la cadena. <br><br><h2>  <font color="#3AC1EF">Acerca de la programaci√≥n funcional en JavaScript</font> </h2><br>  En JavaScript, las funciones son objetos de primera clase; el lenguaje admite el mecanismo de cierre.  Esto abre el camino para implementar t√©cnicas de programaci√≥n funcional en JS.  En particular, estamos hablando de la posibilidad de utilizar funciones de orden superior. <br><br>  Un cierre es una funci√≥n interna que tiene acceso a las variables declaradas dentro de la funci√≥n principal, incluso despu√©s de que se ejecuta la funci√≥n principal. <br><br>  Una funci√≥n de orden superior es una funci√≥n que puede tomar otras funciones como argumentos, devolver funciones o hacer ambas cosas. <br><br>  La programaci√≥n funcional en JS est√° cubierta en muchas publicaciones.  Si est√° interesado, aqu√≠ hay algunos materiales sobre este tema dedicados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">a funciones de primera clase</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">composici√≥n</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">decoradores</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cierres</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">legibilidad de c√≥digo</a> escrito en un estilo funcional. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  El poder de JavaScript reside en su simplicidad.  Comprender los mecanismos b√°sicos del lenguaje le permite al programador que usa JS aplicar estos mecanismos de manera m√°s efectiva y sienta las bases para su crecimiento profesional. <br><br>  <b>Estimados lectores!</b>  ¬øQu√© caracter√≠sticas de JavaScript crees que causan la mayor√≠a de los novatos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416375/">https://habr.com/ru/post/es416375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416363/index.html">Taobao abri√≥ oficialmente en Rusia</a></li>
<li><a href="../es416365/index.html">Colecci√≥n de deseos y votaci√≥n para nuevas funciones del navegador Vivaldi</a></li>
<li><a href="../es416367/index.html">Comenzamos ReactOS con BTRFS de la secci√≥n</a></li>
<li><a href="../es416369/index.html">Casi complicado. Parte 2, crear una "casa inteligente" inal√°mbrica. Basado en tecnolog√≠a Linux, software Z-Wave y MajorDoMo</a></li>
<li><a href="../es416371/index.html">Luz de camping anal√≥gica</a></li>
<li><a href="../es416377/index.html">Nos convertimos en magos en la programaci√≥n. Parte 1</a></li>
<li><a href="../es416379/index.html">Neurobugurt C√≥mo ense√±amos a la red neuronal a inventar memes un a√±o antes que Stanford</a></li>
<li><a href="../es416381/index.html">Informe del Club de Roma 2018, Cap√≠tulo 3.13: Filantrop√≠a, Inversi√≥n, Crowdsourcing y Blockchain</a></li>
<li><a href="../es416385/index.html">Si la correlaci√≥n sale al 100%, en alg√∫n lugar se ha introducido un error: la experiencia de pasant√≠a en Rambler Group</a></li>
<li><a href="../es416387/index.html">Camarones: escale y comparta im√°genes HTTP en C ++ moderno con ImageMagic ++, SObjectizer y RESTinio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>