<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸº ğŸ¤µğŸ¿ ğŸ–ğŸ¿ Arsitektur Web UI: Masa Lalu dari Kayu, Hadiah yang Aneh, dan Masa Depan yang Cerah ğŸ’µ ğŸ•µğŸ» ğŸ‘¨ğŸ¿â€ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komunitas pengembang modern sekarang lebih dari sebelumnya tunduk pada mode dan tren, dan ini terutama berlaku untuk dunia pengembangan front-end. Ker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur Web UI: Masa Lalu dari Kayu, Hadiah yang Aneh, dan Masa Depan yang Cerah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456794/"><img src="https://habrastorage.org/webt/g1/rr/97/g1rr97vliagp-2dndxhmubahvrg.png" alt="gambar"><br><br>  Komunitas pengembang modern sekarang lebih dari sebelumnya tunduk pada mode dan tren, dan ini terutama berlaku untuk dunia pengembangan front-end.  Kerangka kerja dan praktik baru kami adalah nilai utama, dan sebagian besar CV, lowongan, dan program konferensi terdiri dari daftar mereka.  Dan meskipun pengembangan ide dan alat itu sendiri tidak negatif, tetapi karena keinginan konstan pengembang untuk mengikuti tren yang sulit dipahami, kami mulai melupakan pentingnya pengetahuan teoritis umum tentang arsitektur aplikasi. <br><br>  Prevalensi penyetelan pengetahuan tentang teori dan praktik terbaik telah mengarah pada fakta bahwa sebagian besar proyek baru saat ini memiliki tingkat pemeliharaan yang sangat rendah, sehingga menciptakan ketidaknyamanan yang signifikan bagi pengembang (kompleksitas tinggi yang konsisten dalam mempelajari dan memodifikasi kode) dan untuk pelanggan (tarif rendah dan biaya pengembangan tinggi). <br><br>  Untuk setidaknya mempengaruhi entah bagaimana situasi saat ini, hari ini saya ingin memberi tahu Anda tentang apa arsitektur yang baik, bagaimana itu berlaku untuk antarmuka web, dan yang paling penting, bagaimana itu berkembang dari waktu ke waktu. <br><br>  <i><b>NB</b> : Sebagai contoh dalam artikel ini, hanya kerangka kerja yang penulis tangani langsung akan digunakan, dan perhatian yang signifikan akan dibayarkan untuk Bereaksi dan Redux di sini.</i>  <i>Namun, terlepas dari ini, banyak ide dan prinsip yang dijelaskan di sini bersifat umum dan dapat lebih atau kurang berhasil diproyeksikan ke teknologi pengembangan antarmuka lainnya.</i> <br><br><a name="habracut"></a><h2>  Arsitektur untuk Dummies </h2><br>  Untuk memulai, mari kita berurusan dengan istilah itu sendiri.  Dengan kata sederhana, arsitektur sistem apa pun adalah definisi komponennya dan skema interaksi di antara mereka.  Ini adalah semacam landasan konseptual di atas implementasi yang nantinya akan dibangun. <br><br>  Tugas arsitektur adalah untuk memenuhi persyaratan eksternal untuk sistem yang dirancang.  Persyaratan ini bervariasi dari proyek ke proyek dan bisa sangat spesifik, tetapi dalam kasus umum mereka adalah untuk memfasilitasi proses modifikasi dan perluasan solusi yang dikembangkan. <br><br>  Adapun kualitas arsitektur, biasanya dinyatakan dalam properti berikut: <br><br>  - <b>Pengiring</b> : kecenderungan sistem untuk mempelajari dan modifikasi yang telah disebutkan (kesulitan mendeteksi dan memperbaiki kesalahan, memperluas fungsionalitas, mengadaptasi solusi ke lingkungan atau kondisi lain) <br>  - <b>Replaceability</b> : kemampuan untuk mengubah implementasi setiap elemen sistem tanpa mempengaruhi elemen lainnya <br>  - <b>Testability</b> : kemampuan untuk memverifikasi operasi elemen yang benar (kemampuan untuk mengontrol elemen dan mengamati kondisinya) <br>  - <b>Portabilitas</b> : kemampuan untuk menggunakan kembali elemen dalam sistem lain <br>  - <b>Kegunaan</b> : keseluruhan tingkat kenyamanan sistem ketika dioperasikan oleh pengguna akhir <br><br>  Penyebutan terpisah juga dibuat dari salah satu prinsip utama membangun arsitektur yang berkualitas: prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemisahan masalah</a> .  Terdiri dari fakta bahwa setiap elemen sistem harus bertanggung jawab secara eksklusif untuk satu tugas tunggal (diterapkan, secara tidak sengaja, ke kode aplikasi: lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip tanggung jawab tunggal</a> ). <br><br>  Sekarang kita memiliki gagasan tentang konsep arsitektur, mari kita lihat apa pola desain arsitektur dapat menawarkan kita dalam konteks antarmuka. <br><br><h2>  Tiga kata terpenting </h2><br>  Salah satu pola pengembangan antarmuka yang paling terkenal adalah MVC (Model-View-Controller), konsep kuncinya adalah membagi logika antarmuka menjadi tiga bagian terpisah: <br><br>  1. <b>Model</b> - bertanggung jawab untuk menerima, menyimpan, dan memproses data <br>  2. <b>Lihat</b> - bertanggung jawab untuk visualisasi data <br>  3. <b>Kontroler</b> - mengontrol Model dan Tampilan <br><br>  Pola ini juga mencakup deskripsi skema interaksi di antara mereka, tetapi di sini informasi ini akan dihilangkan karena fakta bahwa setelah waktu tertentu masyarakat umum disajikan dengan modifikasi yang diperbaiki dari pola ini yang disebut MVP (Model-View-Presenter), yang skema asli ini interaksi sangat disederhanakan: <br><br><img src="https://habrastorage.org/webt/sv/j_/r2/svj_r22lb39syciykkximzlk-vy.png" alt="gambar"><br><br>  Karena kita berbicara secara khusus tentang antarmuka web, kami menggunakan elemen lain yang agak penting yang biasanya menyertai penerapan pola-pola ini - router.  Tugasnya adalah membaca URL dan memanggil presenter yang terkait dengannya. <br><br>  Skema di atas berfungsi sebagai berikut: <br><br>  1. Router membaca URL dan memanggil Presenter terkait <br>  2-5.  Presenter beralih ke Model dan mendapatkan data yang diperlukan dari itu. <br>  6. Presenter mentransfer data dari Model ke View, yang mengimplementasikan visualisasinya. <br>  7. Selama interaksi pengguna dengan antarmuka, View memberi tahu Presenter tentang ini, yang mengembalikan kita ke poin kedua <br><br>  Seperti yang telah ditunjukkan oleh praktik, MVC dan MVP bukanlah arsitektur yang ideal dan universal, tetapi mereka masih melakukan satu hal yang sangat penting - mereka menunjukkan tiga bidang tanggung jawab utama, yang tanpanya tidak ada antarmuka yang dapat diimplementasikan dalam satu bentuk atau lainnya. <br><br>  <i>NB: Secara umum, konsep Pengendali dan Presenter memiliki arti yang sama, dan perbedaan namanya hanya diperlukan untuk membedakan pola-pola yang disebutkan, yang hanya berbeda dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi komunikasi</a> .</i> <br><br><h2>  MVC dan rendering server </h2><br>  Terlepas dari kenyataan bahwa MVC adalah pola untuk mengimplementasikan klien, ia menemukan aplikasinya di server juga.  Selain itu, dalam konteks server yang paling mudah untuk menunjukkan prinsip-prinsip operasinya. <br><br>  Dalam kasus ketika kita berhadapan dengan situs informasi klasik, di mana tugas server web adalah untuk menghasilkan halaman HTML untuk pengguna, MVC juga memungkinkan kita untuk mengatur arsitektur aplikasi yang cukup ringkas: <br><br>  - Router membaca data dari permintaan HTTP yang diterima <i>(GET / user-profile / 1)</i> dan memanggil Controller yang terkait <i>(UsersController.getProfilePage (1))</i> <br>  - Pengontrol memanggil Model untuk mendapatkan informasi yang diperlukan dari database <i>(UsersModel.get (1))</i> <br>  - Pengontrol meneruskan data yang diterima ke Lihat <i>(View.render ('pengguna / profil', pengguna))</i> dan menerima markup HTML darinya, yang meneruskannya kembali ke klien <br><br>  Dalam hal ini, Lihat biasanya diterapkan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/1j/q6/_f/1jq6_frux0usp6akgw91lj3bq5o.png" alt="gambar"><br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> templates = { <span class="hljs-string"><span class="hljs-string">'users/profile'</span></span>: <span class="hljs-string"><span class="hljs-string">` &lt;div class="user-profile"&gt; &lt;h2&gt;{{ name}}&lt;/h2&gt; &lt;p&gt;E-mail: {{ email }}&lt;/p&gt; &lt;p&gt; Projects: {{#each projects}} &lt;a href="/projects/{{id}}"&gt;{{name}}&lt;/a&gt; {{/each}} &lt;/p&gt; &lt;a href=/user-profile/1/edit&gt;Edit&lt;/a&gt; &lt;/div&gt; `</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ render(templateName, data) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> htmlMarkup = TemplateEngine.render(templates[templateName], data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> htmlMarkup; } }</code> </pre> <br>  <i>NB: Kode di atas sengaja disederhanakan untuk digunakan sebagai contoh.</i>  <i>Dalam proyek nyata, template diekspor ke file terpisah dan melewati tahap kompilasi sebelum digunakan (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Handlebars.compile ()</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">_.template ()</a> ).</i> <br><br>  Di sini yang disebut engine templat digunakan, yang memberi kami alat untuk memudahkan deskripsi templat teks dan mekanisme untuk menggantikan data nyata di dalamnya. <br><br>  Pendekatan seperti itu terhadap implementasi Tampilan tidak hanya menunjukkan pemisahan tanggung jawab yang ideal, tetapi juga memberikan tingkat testabilitas yang tinggi: untuk memeriksa kebenaran tampilan, cukup bagi kita untuk membandingkan garis referensi dengan garis yang kita dapatkan dari mesin templat. <br><br>  Dengan demikian, menggunakan MVC, kita mendapatkan arsitektur yang hampir sempurna, di mana masing-masing elemen memiliki tujuan yang sangat spesifik, konektivitas minimal, dan juga memiliki tingkat testabilitas dan portabilitas yang tinggi. <br><br>  Adapun pendekatan dengan pembuatan markup HTML menggunakan alat server, karena UX rendah, pendekatan ini secara bertahap mulai digantikan oleh SPA. <br><br><h2>  Backbone dan MVP </h2><br>  Salah satu kerangka kerja pertama untuk sepenuhnya membawa logika tampilan ke klien adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Backbone.js</a> .  Implementasi Router, Presenter dan Model di dalamnya cukup standar, tetapi implementasi baru dari View layak mendapat perhatian kita: <br><br><img src="https://habrastorage.org/webt/e6/iv/ye/e6ivye6jq6mo0gq_r1re8fua5uq.png" alt="gambar"><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserProfile = Backbone.View.extend({ <span class="hljs-attr"><span class="hljs-attr">tagName</span></span>: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'user-profile'</span></span>, <span class="hljs-attr"><span class="hljs-attr">events</span></span>: { <span class="hljs-string"><span class="hljs-string">'click .button.edit'</span></span>: <span class="hljs-string"><span class="hljs-string">'openEditDialog'</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">openEditDialog</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }, initialize: function() { this.listenTo(this.model, 'change', this.render); }, template: _.template(` &lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt; &lt;p&gt;E-mail: &lt;%= email %&gt;&lt;/p&gt; &lt;p&gt; Projects: &lt;% _.each(projects, project =&gt; { %&gt; &lt;a href="/projects/&lt;%= project.id %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt; &lt;% }) %&gt; &lt;/p&gt; &lt;button class="edit"&gt;Edit&lt;/button&gt; `), render: function() { this.$el.html(this.template(this.model.attributes)); } });</span></span></code> </pre><br>  Jelas, implementasi pemetaan telah menjadi jauh lebih rumit - mendengarkan peristiwa dari model dan DOM, serta logika pemrosesan mereka, telah ditambahkan ke standardisasi dasar.  Selain itu, untuk menampilkan perubahan pada antarmuka, sangat diinginkan untuk tidak sepenuhnya merender tampilan, tetapi untuk melakukan pekerjaan yang lebih baik dengan elemen DOM tertentu (biasanya menggunakan jQuery), yang mengharuskan penulisan banyak kode tambahan. <br><br>  Karena kerumitan umum implementasi Lihat, pengujiannya menjadi lebih rumit - karena sekarang kami bekerja secara langsung dengan pohon DOM, untuk pengujian kami perlu menggunakan alat tambahan yang menyediakan atau meniru lingkungan browser. <br><br>  Dan masalah dengan implementasi Tampilan baru tidak berakhir di sana: <br><br>  Selain di atas, agak sulit untuk menggunakan bersarang di satu sama lain.  Seiring waktu, masalah ini diselesaikan dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daerah</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Marionette.js</a> , tetapi sebelum itu, pengembang harus menemukan trik mereka sendiri untuk menyelesaikan masalah yang agak sederhana dan sering timbul ini. <br><br>  Dan yang terakhir.  Antarmuka yang dikembangkan dengan cara ini cenderung untuk data tidak sinkron - karena semua model ada terisolasi pada tingkat penyaji yang berbeda, maka ketika mengubah data di satu bagian dari antarmuka, mereka biasanya tidak memperbarui di yang lain. <br><br>  Tetapi, terlepas dari masalah ini, pendekatan ini lebih dari layak, dan pengembangan Backbone yang disebutkan sebelumnya dalam bentuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Marionette</a> masih dapat berhasil diterapkan untuk pengembangan SPA. <br><br><h2>  Bereaksi dan Membatalkan </h2><br>  Sulit dipercaya, tetapi pada saat rilis awal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React.js</a> menimbulkan banyak keraguan di kalangan komunitas pengembang.  Skeptisisme ini begitu hebat sehingga untuk waktu yang lama teks berikut ini diposting di situs web resmi: <br><br><blockquote>  Berikan Lima Menit <br>  Bereaksi banyak tantangan kebijaksanaan konvensional, dan pada pandangan pertama beberapa ide mungkin tampak gila. </blockquote><br>  Dan ini terlepas dari kenyataan bahwa, tidak seperti sebagian besar pesaing dan pendahulunya, React bukan kerangka kerja lengkap dan hanya perpustakaan kecil untuk memfasilitasi tampilan data di DOM: <br><br><blockquote>  React adalah perpustakaan JavaScript untuk membuat antarmuka pengguna oleh Facebook dan Instagram.  Banyak orang memilih untuk menganggap React sebagai V di MVC. <br></blockquote><br>  Konsep utama yang ditawarkan React adalah konsep komponen, yang, pada kenyataannya, memberi kita cara baru untuk mengimplementasikan Tampilan: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ handleEdit() { <span class="hljs-comment"><span class="hljs-comment">// .. } render() { const { name, email, projects } = this.props; return ( &lt;div className="user-profile"&gt; &lt;h2&gt;{name}&lt;/h2&gt; &lt;p&gt;E-mail: {email}&lt;/p&gt; &lt;p&gt; Projects: { projects.map(project =&gt; &lt;a href="/projects/{project.id}"&gt;{project.name}&lt;/a&gt;) } &lt;/p&gt; &lt;button onClick={this.handleEdit}&gt;Edit&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br>  Bereaksi sangat menyenangkan untuk digunakan.  Di antara kelebihannya yang tak terbantahkan adalah hingga hari ini: <br><br>  1) <b>Deklarasi dan reaktivitas</b> .  Tidak perlu lagi memperbarui DOM secara manual saat mengubah data yang ditampilkan. <br><br>  2) <b>Komposisi komponen</b> .  Membangun dan menjelajahi pohon View telah menjadi tindakan yang sepenuhnya elementer. <br><br>  Namun, sayangnya, Bereaksi memiliki sejumlah masalah.  Salah satu yang paling penting adalah kenyataan bahwa Bereaksi bukan kerangka kerja lengkap dan, oleh karena itu, tidak menawarkan kepada kita segala jenis arsitektur aplikasi atau alat lengkap untuk implementasinya. <br><br>  Mengapa ini ditulis dalam kelemahan?  Ya, karena sekarang React adalah solusi paling populer untuk mengembangkan aplikasi web ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukti</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukti</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lain</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan satu lagi bukti</a> ), itu adalah titik masuk bagi pengembang front-end baru, tetapi pada saat yang sama tidak menawarkan atau mempromosikan arsitektur, maupun pendekatan dan praktik terbaik untuk membangun aplikasi lengkap.  Selain itu, ia menciptakan dan mempromosikan pendekatan kebiasaannya sendiri seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HOC</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hooks</a> , yang tidak digunakan di luar ekosistem Bereaksi.  Akibatnya, setiap aplikasi Bereaksi memecahkan masalah khas dengan caranya sendiri, dan biasanya tidak melakukannya dengan cara yang paling benar. <br><br>  Masalah ini dapat didemonstrasikan dengan bantuan salah satu kesalahan paling umum dari pengembang Bereaksi, yang terdiri dari penyalahgunaan komponen: <br><br><blockquote>  Jika satu-satunya alat yang Anda miliki adalah palu, semuanya mulai terlihat seperti paku. </blockquote><br>  Dengan bantuan mereka, pengembang memecahkan serangkaian tugas yang sama sekali tidak terpikirkan yang jauh melampaui lingkup visualisasi data.  Sebenarnya, dengan bantuan komponen, mereka benar-benar menerapkan segalanya - mulai dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan media</a> dari CSS hingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perutean</a> . <br><br><h2>  Bereaksi dan Redux </h2><br>  Mengembalikan ketertiban dalam struktur aplikasi Bereaksi sangat difasilitasi oleh penampilan dan mempopulerkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> .  Jika React adalah View from MVP, maka Redux menawari kami variasi Model yang cukup nyaman. <br><br>  Gagasan utama Redux adalah transfer data dan logika bekerja dengannya menjadi satu gudang data terpusat - yang disebut Store.  Pendekatan ini sepenuhnya menyelesaikan masalah duplikasi dan desinkronisasi data, yang telah kita bicarakan sedikit lebih awal, dan juga menawarkan banyak fasilitas lainnya, yang, di antaranya, termasuk kemudahan mempelajari keadaan data saat ini dalam aplikasi. <br><br>  Fitur lain yang sama pentingnya adalah cara komunikasi antara Store dan bagian lain dari aplikasi.  Alih-alih langsung mengakses Store atau datanya, kami ditawari untuk menggunakan Tindakan yang disebut (objek sederhana yang menggambarkan peristiwa atau perintah), yang memberikan tingkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelepasan lepas yang</a> lemah antara Store dan sumber acara, sehingga secara signifikan meningkatkan tingkat pemeliharaan proyek.  Dengan demikian, Redux tidak hanya memaksa pengembang untuk menggunakan pendekatan arsitektur yang lebih tepat, tetapi juga memungkinkan Anda untuk mengambil keuntungan dari berbagai keuntungan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber acara</a> - sekarang dalam proses debugging kita dapat dengan mudah melihat sejarah tindakan dalam aplikasi, dampaknya pada data, dan jika perlu, semua informasi ini dapat diekspor , Yang juga sangat berguna ketika menganalisis kesalahan dari produksi. <br><br>  Skema umum aplikasi menggunakan React / Redux dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/rw/x6/8f/rwx68f3sxe_rrnh609ul6rmgrsw.png" alt="gambar"><br><br>  Komponen react masih bertanggung jawab untuk menampilkan data.  Idealnya, komponen-komponen ini harus bersih dan fungsional, tetapi jika perlu, mereka mungkin memiliki keadaan lokal dan logika terkait (misalnya, untuk mengimplementasikan menyembunyikan / menampilkan elemen tertentu atau preprocessing dasar dari tindakan pengguna). <br><br>  Ketika seorang pengguna melakukan suatu tindakan di antarmuka, komponen hanya memanggil fungsi handler yang sesuai, yang diterima dari luar bersama dengan data untuk ditampilkan. <br><br>  Komponen wadah yang disebut bertindak sebagai Presenter bagi kami - merekalah yang mengendalikan komponen tampilan dan interaksinya dengan data.  Mereka dibuat menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koneksi</a> , yang memperluas fungsionalitas komponen yang diteruskan ke dalamnya, menambahkan langganan untuk mengubah data di Store dan membiarkan kami menentukan data dan penangan peristiwa mana yang harus diteruskan ke sana. <br><br>  Dan jika semuanya jelas dengan data di sini (kami hanya memetakan data dari toko ke "alat peraga" yang diharapkan), maka saya ingin membahas tentang penangan acara secara lebih detail - mereka tidak hanya mengirim Tindakan ke Toko, tetapi mungkin juga mengandung logika tambahan untuk memproses acara - misalnya, termasuk percabangan, melakukan pengalihan otomatis, dan melakukan pekerjaan lain yang khusus untuk presenter. <br><br>  Poin penting lain mengenai komponen wadah: karena fakta bahwa mereka dibuat melalui HOC, pengembang cukup sering menggambarkan komponen tampilan dan komponen wadah dalam satu modul dan hanya mengekspor wadah.  Ini bukan pendekatan yang tepat, karena untuk kemungkinan menguji dan menggunakan kembali komponen tampilan, itu harus benar-benar dipisahkan dari wadah dan lebih baik diambil dalam file terpisah. <br><br>  Nah, hal terakhir yang belum kita pertimbangkan adalah Store.  Ini berfungsi sebagai implementasi Model yang agak spesifik dan terdiri dari beberapa komponen: Status (objek yang berisi semua data kami), Middleware (seperangkat fungsi yang memproses semua Tindakan yang diterima), Peredam (fungsi yang mengubah data dalam Status) dan beberapa atau penangan efek samping yang bertanggung jawab untuk menjalankan operasi asinkron (mengakses sistem eksternal, dll.). <br><br>  Masalah paling umum di sini adalah bentuk Negara kita.  Secara formal, Redux tidak memberlakukan batasan apa pun pada kami dan tidak memberikan rekomendasi tentang apa objek ini seharusnya.  Pengembang dapat benar-benar menyimpan data apa pun di dalamnya (termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keadaan formulir</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">informasi dari router</a> ), data ini dapat dari jenis apa pun ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak dilarang</a> untuk menyimpan bahkan fungsi dan instance objek) dan memiliki tingkat bersarang.  Bahkan, ini sekali lagi mengarah pada fakta bahwa dari satu proyek ke proyek yang lain kami mendapatkan pendekatan yang sangat berbeda untuk menggunakan Negara, yang sekali lagi menyebabkan beberapa kebingungan. <br><br>  Untuk mulai dengan, kami setuju bahwa kami tidak harus menyimpan semua data aplikasi dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keadaan</a> mutlak - ini jelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditunjukkan oleh dokumentasi</a> .  Meskipun menyimpan bagian dari data di dalam status komponen menciptakan ketidaknyamanan tertentu ketika menavigasi melalui sejarah tindakan selama proses debug (keadaan internal komponen selalu tidak berubah), mentransfer data ini ke Negara menciptakan lebih banyak kesulitan - ini secara signifikan meningkatkan ukurannya dan membutuhkan penciptaan lebih banyak lagi Tindakan dan reduksi. <br><br>  Adapun untuk menyimpan data lokal lainnya di Negara, kami biasanya berurusan dengan beberapa konfigurasi antarmuka umum, yang merupakan seperangkat pasangan nilai kunci.  Dalam hal ini, kita dapat dengan mudah melakukannya dengan satu objek sederhana dan reducer untuknya. <br><br>  Dan jika kita berbicara tentang menyimpan data dari sumber eksternal, maka berdasarkan fakta bahwa dalam pengembangan antarmuka di sebagian besar kasus kita berurusan dengan CRUD klasik, maka untuk menyimpan data dari server masuk akal untuk memperlakukan Negara sebagai RDBMS: kunci adalah nama sumber daya, dan di belakangnya adalah array yang disimpan dari objek yang dimuat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tanpa bersarang</a> ) dan informasi opsional untuk mereka (misalnya, jumlah total catatan pada server untuk membuat pagination).  Bentuk umum dari data ini harus seseragam mungkin - ini akan memungkinkan kami untuk menyederhanakan pembuatan reduksi untuk setiap jenis sumber daya: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getModelReducer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modelName</span></span></span><span class="hljs-function"> =&gt;</span></span> (models = [], action) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isModelAction = modelActionTypes.includes(action.type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isModelAction &amp;&amp; action.modelName === modelName) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'ADD_MODELS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.add(action.models, models); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'CHANGE_MODEL'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.change(action.model, models); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_MODEL'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.remove(action.model, models); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'RESET_STATE'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> models; };</code> </pre> <br>  Nah, poin lain yang ingin saya bahas dalam konteks menggunakan Redux adalah penerapan efek samping. <br><br>  Pertama-tama, lupakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux Thunk</a> - transformasi Tindakan yang diusulkan olehnya menjadi fungsi dengan efek samping, meskipun ini merupakan solusi yang berfungsi, tetapi menggabungkan konsep dasar arsitektur kita dan mengurangi kelebihannya menjadi nol.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux Saga</a> menawarkan kepada kita pendekatan yang jauh lebih tepat untuk menerapkan efek samping, meskipun ada beberapa pertanyaan mengenai penerapan teknisnya. <br><br>  Selanjutnya - cobalah untuk menyatukan sebanyak mungkin efek samping Anda yang mengakses server.  Seperti formulir dan reduksi Negara, kita hampir selalu dapat mengimplementasikan logika membuat permintaan ke server menggunakan satu penangan tunggal.  Misalnya, dalam kasus RESTful API, ini dapat dicapai dengan mendengarkan Tindakan umum seperti: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CREATE_MODEL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: { <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">'reviews'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'...'</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">'...'</span></span> } } }</code> </pre><br>  ... dan membuat permintaan HTTP umum yang sama pada mereka: <br><br><pre> <code class="plaintext hljs">POST /api/reviews { title: '...', text: '...' }</code> </pre> <br>  Dengan secara sadar mengikuti semua tips di atas, Anda bisa mendapatkan, jika bukan arsitektur yang ideal, maka setidaknya dekat dengannya. <br><br><h2>  Masa depan yang cerah </h2><br>  Perkembangan modern antarmuka web benar-benar telah mengambil langkah maju yang signifikan, dan sekarang kita hidup di masa ketika sebagian besar masalah utama telah diselesaikan dengan satu atau lain cara.  Tetapi ini tidak berarti sama sekali bahwa di masa depan tidak akan ada revolusi baru. <br><br>  Jika Anda mencoba melihat ke masa depan, maka kemungkinan besar kita akan melihat yang berikut: <br><br>  <b>1. Pendekatan komponen tanpa BEJ</b> <br><br>  Konsep komponen telah terbukti sangat sukses, dan, kemungkinan besar, kita akan melihat popularisasi mereka yang lebih besar.  Tetapi BEJ itu sendiri bisa dan harus mati.  Ya, ini benar-benar cukup nyaman untuk digunakan, tetapi, bagaimanapun, ini bukan standar yang diterima secara umum atau kode JS yang valid.  Perpustakaan untuk mengimplementasikan antarmuka, betapapun baiknya, tidak boleh menemukan standar baru, yang kemudian harus diimplementasikan berulang-ulang dalam setiap toolkit pengembangan yang memungkinkan. <br><br>  <b>2. Nyatakan wadah tanpa Redux</b> <br><br>  Penggunaan gudang data terpusat, yang diusulkan oleh Redux, juga merupakan solusi yang sangat sukses, dan di masa depan harus menjadi semacam standar dalam pengembangan antarmuka, tetapi arsitektur dan implementasinya internal mungkin mengalami perubahan dan penyederhanaan tertentu. <br><br>  <b>3. Meningkatkan pertukaran perpustakaan</b> <br><br>  Saya percaya bahwa seiring waktu, komunitas pengembang front-end akan menyadari manfaat dari memaksimalkan pertukaran perpustakaan dan akan berhenti mengunci diri mereka ke dalam ekosistem kecil mereka.  Semua komponen aplikasi - router, wadah negara, dll. - mereka harus sangat universal, dan penggantiannya tidak memerlukan refactoring massal atau menulis ulang aplikasi dari awal. <br><br><h2>  Kenapa semua ini? </h2><br>  Jika kami mencoba untuk menggeneralisasi informasi yang disajikan di atas dan menguranginya ke bentuk yang lebih sederhana dan lebih pendek, maka kami mendapatkan beberapa poin yang cukup umum: <br><br>  - Agar pengembangan aplikasi berhasil, pengetahuan bahasa dan kerangka tidak cukup, perhatian harus diberikan pada hal-hal teoretis umum: arsitektur aplikasi, praktik terbaik, dan pola desain. <br><br>  "Satu-satunya yang konstan adalah perubahan."  Pendekatan pengolahan dan pengembangan akan terus berubah, sehingga proyek-proyek besar dan berumur panjang harus memperhatikan arsitektur dengan tepat - tanpanya, memperkenalkan alat dan praktik baru akan sangat sulit. <br><br>  Dan mungkin itu saja bagiku.  Banyak terima kasih kepada semua orang yang menemukan kekuatan untuk membaca artikel sampai akhir.  Jika Anda memiliki pertanyaan atau komentar, saya mengundang Anda untuk berkomentar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456794/">https://habr.com/ru/post/id456794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456774/index.html">Apa yang saya lewatkan di Jawa setelah bekerja dengan Kotlin / Scala</a></li>
<li><a href="../id456780/index.html">9 Cara untuk Meningkatkan Efisiensi Pengembang Aplikasi Seluler</a></li>
<li><a href="../id456782/index.html">Desain berorientasi model - bagaimana tidak mengulangi Chernobyl</a></li>
<li><a href="../id456790/index.html">Intisari berita PostgreSQL. Edisi No.16</a></li>
<li><a href="../id456792/index.html">Sebarkan Cluster Kubernetes di OpenStack dengan Kubespray</a></li>
<li><a href="../id456796/index.html">Svalbard - nama baru untuk proyek Have I Been Pwned sebelum dijual</a></li>
<li><a href="../id456804/index.html">Ikuti uang: bagaimana grup RTM mulai menyembunyikan alamat server C & C di dompet crypto</a></li>
<li><a href="../id456806/index.html">Satu bot dari semua kekhawatiran</a></li>
<li><a href="../id456808/index.html">Cara Meningkatkan Kinerja Aplikasi Web Front-End: Lima Tips</a></li>
<li><a href="../id456810/index.html">Yang pertama. Kisah Bebas Tesla</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>