<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏻 ⤴️ 🎇 IBM System i (alias AS / 400) - Bagaimana kami melakukan tes otomatis aplikasi layar hijau 👨🏾‍💼 ⛈️ 🕖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Anton Vorobyov, saya bertanggung jawab di Alfa Bank untuk pengembangan aplikasi untuk sistem perbankan terpusat. 

 Dalam posting ini, s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IBM System i (alias AS / 400) - Bagaimana kami melakukan tes otomatis aplikasi layar hijau</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alfa/blog/446332/"> Hai  Nama saya Anton Vorobyov, saya bertanggung jawab di Alfa Bank untuk pengembangan aplikasi untuk sistem perbankan terpusat. <br><br>  Dalam posting ini, saya akan memberi tahu Anda tentang apa aplikasi layar hijau, mengapa mereka diperlukan dan bagaimana kami melakukan autotest untuk mereka dengan menulis solusi kami sendiri untuk ini, yang memungkinkan kami untuk mempercepat autotests sebanyak 11 kali. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ui/j8/z2/uij8z2alj0kcdqv2wtd_uo4yghq.jpeg"></a> <br><br>  Platform AS / 400 (Sistem Aplikasi / 400) lahir pada tahun 1988.  OS pertama untuk platform ini adalah OS / 400, yang kemudian diubah namanya menjadi i5 / OS dan bahkan kemudian menjadi IBM i.  Belum lama berselang, dia merayakan hari ulang tahunnya yang ketiga puluh. <br><br>  Terjun ke dunia pengembangan di bawah sistem operasi IBM i, Anda memahami bahwa ini sebenarnya bukan "warisan" dalam arti kata klasik.  Ini adalah lingkungan yang berbeda dan sangat berbeda, yang sedikit mirip dengan sistem Windows atau Unix yang biasa.  Tugas utama OS ini adalah menjadi seproduktif mungkin pada peralatan yang digunakannya, dan tidak nyaman bagi pengguna. <br><br>  IMHO, OS ini dapat membuat Anda gila tentang betapa tidak efektifnya pendekatan yang biasa digunakan untuk menulis kode C ++ tidak efektif di atasnya (hingga puluhan kali kehilangan CPU), bahwa beberapa antipemut yang ditunjukkan dalam buku teks adalah praktik terbaik dari kode yang efektif, dan sumber dengan tanggal penulisan untuk 1978 tidak hanya berkumpul tanpa masalah, tetapi juga bekerja seperti yang dirancang!  Semua ini membuat kami memperhatikan pendekatan modern untuk pengembangan perangkat lunak. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Masalah peningkatan kualitas perangkat lunak dalam pengembangan menggairahkan pikiran masing-masing tim pengembangan.  Salah satu tim kredit kami, yang tugasnya mengembangkan dan mengembangkan bagian belakang modul untuk sistem perbankan otomatis Misys Equation, belum melewati momen ini juga.  Keunikan dari ABS ini adalah: <br><br><ul><li>  versi pertama dari ABS bekerja di bawah AS / 400 pendahulunya - platform IBM System / 38 (muncul pada tahun 1978) di bawah CPF OS - “Control Program Facility”; </li><li>  Ini telah dikembangkan sejak tahun 70-an abad kedua puluh, dan Anda dapat menemukan kode yang ditulis sebelum kelahiran Anda (banyak kode lama); </li><li>  fitur bekerja dengan ABS adalah karena integrasi yang erat dengan IBM i, dan karena kompatibilitas mundur yang besar dari yang terakhir, tampaknya Anda bekerja sebagai arkeolog dalam penggalian Piramida Besar. </li></ul><br><br><img src="https://habrastorage.org/webt/wu/va/gc/wuvagcwh4kmqi-fgc1sz_faezp0.jpeg"><br>  <i>IBM i (logo)</i> <br><br>  Pengembangan aplikasi untuk ABS ini (opsi ABS) dilakukan sesuai dengan standar paket pengembang ITP Misys, Paket Teknis Integrator, yang menetapkan bahwa opsi tersebut harus terdiri dari program interaktif untuk interaksi terminal dengan pengguna akhir dan mengimplementasikan API menggunakan antarmuka yang dipasang untuk eksekusi latar belakang. . <br><br>  Program interaktif semacam itu yang dikembangkan di bawah sistem operasi IBM i secara historis disebut aplikasi layar hijau dan merupakan satu-satunya UI yang berinteraksi dengan pengguna ABS ini. <br><br><h2>  Apa itu aplikasi layar hijau? </h2><br>  Jawaban sederhana adalah aplikasi yang terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/6m/gq/gy/6mgqgy4eklp7fvboyyeunnnazgy.jpeg"><br><br>  Atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih</a> : <br><br><img src="https://habrastorage.org/webt/cu/d2/km/cud2kmgmxlpe_9eqgxyymmqp9iy.png"><br><br><h2>  Mengapa aplikasi layar hijau? </h2><br>  Secara historis, satu-satunya aplikasi interaktif yang berjalan pada sistem rendah dan menengah keluarga AS / 400 dan mainframe IBM lainnya yang memungkinkan Anda untuk meminta input pengguna adalah aplikasi layar hijau.  Instalasi, administrasi, konfigurasi dan pengembangan pada sistem operasi IBM i (dan pendahulunya i5 / OS dan AS400) dilakukan (dan masih dilakukan di suatu tempat) secara eksklusif menggunakan aplikasi layar hijau. <br><br>  Gambar aplikasi layar hijau memiliki dua ukuran - 24x80 dan 27x132 karakter dan 16 warna yang memungkinkan.  Dalam skala ini, sebagian besar pekerjaan pengembang dan pengguna sistem operasi ini dilakukan. <br><br>  Ukuran layar tersebut adalah hasil dari evolusi "workstation" yang terhubung ke nenek moyang AS400 dari segmen kelas bawah dan menengah komputer bisnis IBM System / 32, System / 34, System / 36 dan System / 38.  Stasiun kerja ini disebut terminal dan terdiri dari layar dalam kotak logam dengan keyboard dan peralatan tambahan dalam bentuk pena cahaya.  Pada awalnya, hanya dua warna layar yang didukung - hijau dan hijau terang, itulah sebabnya ungkapan "aplikasi layar hijau" (aplikasi layar hijau dalam literatur bahasa Inggris) berjalan.  Pada 1970-an, jumlah warna yang didukung meningkat menjadi 16. <br><br><img src="https://habrastorage.org/webt/i-/is/u6/i-isu68vczilipq75gx8jnq8xzs.png"><br>  <i>5251 Model Stasiun Display 11</i> <br><br>  Opsi terminal yang paling umum adalah 5251 Stasiun Layar Model 1 (960 karakter pada layar) dan Model 11 (1920 karakter pada layar) dengan dimensi Lebar / Kedalaman / Tinggi masing-masing sebesar 530/400/400 mm, dan berat 34 kg.  Resolusi layar Model 1 adalah 12x80, Model 11 - 24x80.  Terminal terhubung langsung ke sistem host. <br><br>  Terminal 5251 Display Station Model 2 (960 karakter pada layar) dan Model 12 (1920 karakter pada layar) dengan dimensi besar dan berat 45 kg juga cukup umum.  Mereka dibedakan dari Model 1 dan Model 11 dengan kemungkinan meneruskan koneksi hulu melalui diri mereka ke mesin host dari klien yang lebih murah dalam bentuk Model 1 (atau 11) terminal dengan printer desktop atau printer lantai terpisah.  Dengan demikian, model 2 dan 12 bertindak sebagai hub, proksi sambungan ke host dari perangkat yang memerlukan koneksi langsung ke mesin host, dan harganya jauh lebih mahal. <br><br>  Terminal seri 5252 Dual Display Station juga akan tampak tidak biasa bagi orang awam modern. <br><br><img src="https://habrastorage.org/webt/qq/nf/qx/qqnfqxfkc_sddfyxg1nq6i-v154.png"><br>  <i>Gambar promosi dari brosur IBM System / 38 Equipment and Programs (5252 Dual Display Station)</i> <br><br>  Harga satu terminal kit dengan printer yang terhubung dapat mencapai beberapa ribu dolar AS. <br><br>  Terminal dihubungkan melalui kabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">twinaxial</a> ke mesin host dengan topologi bus dalam mode half-duplex dengan kecepatan transmisi hingga 1 Mbps.  Jumlah maksimum terminal yang didukung oleh twinaxial hingga 6 terminal, dan terminal yang paling jauh dari host harus berada pada jarak tidak lebih dari 1500 meter. <br><br>  Jumlah setiap terminal diatur selama pemasangannya oleh tiga sakelar, sehingga alamat unik ditentukan di dalam bus.  Di hadapan jaringan koaksial yang ada, dimungkinkan untuk menggunakan adaptor dari kabel twinaxial ke kabel koaksial dan satu set terminasi kabel yang sesuai untuk crimping.  Dengan skema ini, dimungkinkan untuk menghubungkan hanya dua perangkat di bus dengan panjang segmen maksimum hingga 30 meter.  Jumlah total perangkat yang terhubung bervariasi dari selusin hingga beberapa lusin, tergantung pada modelnya. <br><br>  Dengan pengembangan sistem Desktop dan jaringan akses, terminal besar digantikan oleh workstation, di mana berbagai kartu ekspansi dari perusahaan pihak ketiga digunakan sebagai sarana akses ke mesin host, mendukung koneksi langsung melalui twinaxial.  Setelah IBM mengembangkan teknologi Token Ring pada tahun 1984, solusi perangkat lunak untuk mengakses mesin, termasuk melalui antarmuka ini, muncul. <br><br><img src="https://habrastorage.org/webt/5d/ek/m2/5dekm2mgcz43rgjiaxyjje3lyas.jpeg"><br>  <i>5250 adaptor ke bus ISA (produsen tidak diketahui)</i> <br><br><img src="https://habrastorage.org/webt/mm/sr/0a/mmsr0av497ergmgdj4hjtd4a-84.png"><br>  <i>Kartu Adaptor Blackbox 5250 (PC470C, PC471C, PC472C, PC473C, PC478C)</i> <br><br>  Emulator untuk MS-DOS dan MS Windows muncul baik dari IBM maupun dari produsen pihak ketiga, termasuk implementasi OpenSource (misalnya, tn5250j.sourceforge.net) .Pada pertengahan 90-an, tumpukan TCP / IP masuk ke dunia pertengahan -range dan mesin bisnis low-end.  Untuk mendukung akses host melalui protokol baru, IBM sedang mengembangkan emulator terminal seri 5250. <br><br>  Untuk membuat protokol host, IBM sedang mengembangkan <br>  Ekstensi protokol Telnet (RFC 854, RFC 855, RFC 856, RFC 860, RFC 885, RFC 1091, RFC 1205, RFC 1572, RFC 2877), secara kolektif disebut sebagai Telnet5250 (TN5250), yang menggambarkan proses penerimaan dan pengiriman stream 5250 aliran data (5250 aliran data) melalui protokol Telnet standar. <br><br><img src="https://habrastorage.org/webt/8w/gg/_i/8wgg_idu8zojbdf5_1u-gweewkm.gif"><br>  <i>IBM Client Access / 400 untuk Pemasang Windows 3.1</i> <br><br><h2>  Apa yang istimewa tentang IBM 5250? </h2><br>  Fitur terminal IBM 5250 (dan sesuai dengan itu, protokol TN5250) adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">orientasi bloknya,</a> berbeda dengan terminal * nix biasa, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berorientasi simbol</a> .  Ini berarti bahwa 5250 data mengalir dimana host berkomunikasi dengan terminal ditransmisikan oleh blok data, dan simbol terpisah di dalamnya tanpa konteks blok yang ditransmisikan tidak masuk akal. <br><br>  Sebagai contoh, mesin host mentransmisikan ke terminal suatu blok data yang berisi informasi statis yang ditampilkan pada layar bersama dengan atribut dan koordinat bidang input dan indikasi offset di blok ini, di mana untuk menulis hasil input pengguna ke bidang.  Setelah itu, mesin host mengharapkan pesan dari terminal dan tidak berpartisipasi dalam proses input pengguna. <br><br><img src="https://habrastorage.org/webt/kg/ld/ha/kgldha8aef46matytdr3ugjm7ce.png"><br>  <i>Layar login untuk IBM saya host RZKH.de (pub400.com)</i> <br><br>  Selanjutnya, tugas terminal emulator adalah menginterpretasikan blok data dari mesin dan membentuk layar input untuk pengguna, di mana ia diberi kesempatan untuk memasukkan informasi apa pun ke dalam bidang yang diizinkan.  Selain itu, tugas terminal emulator mencakup reaksi terhadap tindakan pengguna.  Tombol F1-F24 (F13-F24 disimulasikan melalui SHIFT + Fx), Enter, Home, End, PageUp, PageDn, dan beberapa tombol khusus lainnya yang tidak tersedia pada keyboard modern dianggap sebagai kunci host.  Ini berarti bahwa dengan menekan tombol ini, buffer aliran dengan informasi dari bidang input dan posisi kursor pada layar, yang sebelumnya diisi dengan emulator terminal, akan dikirim ke host untuk diproses. <br><br><img src="https://habrastorage.org/webt/nf/oe/vx/nfoevxx5yvr-kbzcnejytv9hk4q.png"><br>  <i>WIreshark 5250 upaya masuk Stream Data dibuang di pub400.com</i> <br><br>  Host menerima buffer, mem-parsingnya, dan hasil input ditransmisikan ke program yang meminta reaksi pengguna untuk validasi data lebih lanjut dan aplikasi terus bekerja, sementara aplikasi menerima kode dari kunci host yang ditekan. <br><br><h2>  Mengapa ada autotest di sini? </h2><br>  Kami berpikir tentang mengotomatiskan pengujian manual aplikasi layar hijau ketika kami dihadapkan dengan kebutuhan untuk menguji ratusan layar dari modul yang dikembangkan, di mana hingga delapan puluh pemeriksaan bisnis yang berbeda (validasi) dapat terjadi pada satu layar. <br><br>  Rasa sakit khusus tim adalah hampir tidak ada yang lengkap untuk 2017 alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian otomatis</a> layar hijau, kecuali untuk solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UIPath</a> berpemilik.  Bahkan saat ini tidak ada banyak solusi serupa, penulis tahu Automate from HelpSystems dan ekstensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JMeter</a> untuk BlazeMeter (saya akan senang menerima informasi tentang produk serupa lainnya). <br><br><h2>  Penelitian pertama tentang masalah tersebut </h2><br>  Emulator standar terminal TN5250 yang dipasang di tempat kerja di bank adalah IBM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Personal Communications</a> for Windows 6.0 (PCOMM 6.0).  Kolega menemukan bahwa produk ini memiliki cara reguler untuk mengotomatisasi manajemennya dalam bentuk API yang beragam, yaitu: <br><br><ol><li>  Antarmuka Program Aplikasi Bahasa (HLLAPI) tingkat tinggi; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HLLAPI yang ditingkatkan;</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Windows HLLAPI</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Host Access Client Library (HACL).</a> </li></ol><br>  Tiga antarmuka pertama adalah yang tertua dan telah didukung sejak DOS dan versi 16-bit Windows.  Bekerja pada antarmuka EHLLAPI diimplementasikan dengan memanggil fungsi tunggal sesuai dengan prototipe berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hllapi</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPWORD, LPSTR, LPWORD, LPWORD)</span></span></span></span>;</code> </pre> <br>  di mana parameter pertama adalah penunjuk ke nomor numerik dari fungsi yang dieksekusi, dua lainnya adalah argumennya konteks-sensitif terhadap fungsi yang dipanggil, dan yang terakhir adalah hasil dari fungsi.  Artinya, untuk meminta status koneksi 'A' (sesi dalam emulator diberi nomor dengan huruf Latin dari rentang dari 'A' hingga 'Z'), Anda harus menjalankan kode berikut (diambil dari dokumentasi IBM): <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hapi_c.h"</span></span></span><span class="hljs-meta"> struct HLDQuerySessionStatus QueryData; int Func, Len, Rc; long Rc; memset(QueryData, 0, sizeof(QueryData)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Init buffer QueryData.qsst_shortname = 'A'; // Session to query Func = HA_QUERY_SESSION_STATUS; // Function number Len = sizeof(QueryData); // Len of buffer Rc = 0; // Unused on input hllapi(&amp;Func, (char *)&amp;QueryData, &amp;Len, &amp;Rc); // Call EHLLAPI if (Rc != 0) { // Check return code // ...Error handling }</span></span></span></span></code> </pre><br>  Jumlah fungsi yang tersedia untuk menelepon dengan cara ini adalah sekitar 60. <br><br>  Antarmuka WinHLLAPI sedikit memperluas fungsionalitas ini dengan beberapa fungsi tambahan yang memungkinkan mendaftarkan fungsi panggilan balik untuk panggilan asinkron untuk memberi tahu tentang peristiwa membangun koneksi dengan host, memutuskan koneksi dari host, mengubah data pada layar terminal, dll. <br><br>  Antarmuka Host Access Client Library (HACL) tampaknya lebih ramah pengguna, karena, berbeda dengan memanggil "fungsi dengan nama yang sama", varian hierarki kelas berorientasi objek disediakan yang sepenuhnya meniru tindakan pengguna apa pun. <br><br><img src="https://habrastorage.org/webt/bv/km/nx/bvkmnxfp3dcskk9uiw9kzbtyffo.gif"><br>  <i>HACL Emulator Class Library Class Hierarchy (C ++)</i> <br><br>  Ada implementasi HACL untuk C ++, Java, LotusScript dan server otomatisasi COM untuk Windows (nyaman untuk Visual Basic dan .NET). <br><br><h2>  Prototipe pertama </h2><br>  Karena kompleksitas yang sangat besar dari protokol aliran data 5250 dan informasi yang sangat langka tentang perangkat internal dengan tautan ke literatur berbayar tertutup dari IBM, menjadi jelas bahwa mengembangkan emulator Anda sendiri sangat tidak sepele dan memakan waktu.  Dalam hal ini, muncul ide untuk menggunakan lapisan middleware yang akan memungkinkan Anda untuk mengontrol emulator terminal dalam fungsionalitas minimum yang diperlukan, khususnya "memasukkan nilai di lapangan", "membandingkan bagian layar dengan standar" atau "tekan tombol host F22". <br><br>  Kolega yang sebelumnya menggunakan antarmuka HACL mengklaim (dan pencarian di StackOverflow dikonfirmasi) bahwa objek COM memiliki masalah stabilitas dan bisa hang setelah sejumlah perintah dieksekusi.  Hanya me-restart proses server otomatisasi yang membantu.  Analisis cepat dari versi Java menunjukkan bahwa Wrapper digunakan melalui antarmuka C ++ melalui JNI.  Oleh karena itu, pilihan jatuh pada antarmuka C ++.  File header dan file .lib yang sesuai tersedia di direktori instalasi Personal Communications For Windows itu sendiri. <br><br>  Prototipe pertama didasarkan pada Qt5, di mana dimungkinkan untuk mengeksekusi kode JavaScript melalui QtScript.  Dalam lingkungan skrip yang dapat dieksekusi, sebuah objek didaftarkan dengan sejumlah kecil metode yang memungkinkan mengeksekusi perintah dalam emulator terminal seolah-olah sedang dieksekusi oleh seseorang (memasuki bidang, menekan tombol host, menunggu garis muncul di layar).  Kami mendemonstrasikan "demo" langsung, di mana kami membuat skrip kasus pengguna untuk meluncurkan aplikasi layar hijau dari ABS Equation dengan uji reaksi aplikasi terhadap input yang salah ke bidang.  Demonstrasi menunjukkan bahwa prototipe berhasil dan kita dapat melanjutkan. <br><br><h2>  Penampilan tetangga </h2><br>  Seiring dengan demonstrasi prototipe pertama, rekan-rekan dari departemen lain mengumpulkan sekelompok modul Ruby + Mentimun + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quick3270</a> + Ruby ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cheeze / te3270</a> ).  Opsi yang diajukan menggunakan modul Ruby yang berinteraksi dengan emulator terminal DN32 Computing Quick3270 melalui objek COM khusus (tidak kompatibel dengan antarmuka HACL).  Itu adalah solusi lengkap untuk aplikasi pengujian otomatis layar hijau bergaya BDD, dengan beberapa langkah yang telah dijelaskan sebelumnya.  Namun, dalam solusi yang diusulkan, kami khawatir dengan yang berikut: <br><br><ol><li>  Kami menggunakan emulator berbayar pihak ketiga bukan dari IBM (semua emulator bekerja sedikit berbeda, tetapi kami perlu memeriksa pekerjaan pada yang standar yang digunakan di bank, harga kesalahan sangat tinggi); </li><li>  Implementasi langkah-langkah Cucumber untuk Quick3270 menggunakan sejumlah besar tidur untuk menunggu respons dari mesin; </li><li>  Performa Quick3270 yang sangat buruk melalui antarmuka otomatisasi (bekerja dengan HACL dalam prototipe melalui antarmuka C ++ tampak jauh lebih dinamis). </li></ol><br><img src="https://habrastorage.org/webt/wy/j3/2u/wyj32ub0tvoxzbh-va3yxajiqfs.jpeg"><br>  <i>Emulator terminal Quick3270</i> <br><br>  Berdasarkan prototipe, kami memutuskan untuk mencoba menerapkan server otomasi kami sendiri untuk menyambungkan Mentimun ke Komunikasi Pribadi untuk Windows dan merancang langkah-langkah sehingga waktu henti antar tindakan pada layar emulator minimal. <br><br>  <i><b>Penyimpangan liris</b> .</i>  <i>Terlepas dari kenyataan bahwa ada sejumlah besar masalah teknis di sekitar "warisan" yang seharusnya IBM, yang, tampaknya, harus sudah diselesaikan untuk sistem tingkat bisnis menengah dan perusahaan, relevansi mengadaptasi dan mentransfer solusi teknis yang ada sangat tinggi hanya karena ketidakhadiran mereka di platform.</i>  <i>Seringkali ketidakhadiran terhubung dengan fitur-fitur OS ini, yang pada dasarnya berbeda dari * nix modern, Windows atau MacOS X, yang memerlukan optimalisasi perangkat lunak yang signifikan untuk tumpukan ini.</i> <br><br><h2>  Keputusan sendiri </h2><br>  Sebagai solusi kami sendiri, kami menciptakan server otomasi sebagai pengembangan dari prototipe yang ditunjukkan sebelumnya.  Server ini menjalankan perintah untuk mengotomatisasi interaksi dari konsumen melalui server RPC (Qt5 WebSocket).  Ini berinteraksi dengan Komunikasi Pribadi untuk Windows, yang merupakan bagian dari gambar sistem operasi Windows perusahaan, dan memungkinkan Anda untuk: <br><br><ul><li>  memulai / menghentikan sesi terminal emulator; </li><li>  Lakukan Screen Scraping Green Screen; </li><li>  mencari kolom input di layar; </li><li>  mengontrol kursor dan mensimulasikan penekanan tombol (termasuk host); </li><li>  dan lainnya </li></ul><br><img src="https://habrastorage.org/webt/ub/qf/xp/ubqfxpqwu5q9pz3ievcpkfb0_sm.png"><br>  <i>Mulai Server Otomasi</i> <br><br>  Namun, untuk semua kelebihan API HACL, ia memiliki satu kelemahan - ia tidak tahu cara bekerja dengan DB2 untuk i DBMS yang dibangun ke dalam OS dan tidak memungkinkan menjalankan perintah yang penting untuk membangun lingkungan tiruan di mana skrip uji akan dieksekusi.  Jika klien DB2 untuk Ruby ada dari IBM, maka klien untuk perintah jarak jauh dan server panggilan program terdistribusi hanya untuk Java dalam bentuk perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JTOpen</a> : Versi Open Source dari IBM Toolbox for Java (juga dikenal sebagai jt400 )  Kami "mengintip" solusi untuk masalah ini di IBM sendiri dengan menganalisis perilaku produk-produknya dengan fungsionalitas yang serupa (khususnya, Komunikasi Pribadi untuk Transfer Data Windows, iSeries ke PC / PC ke Transfer iSeries, dll.).  Ternyata produk-produk ini, dengan implementasinya, menjalankan IBM JRE 6 atau 8, tergantung pada versi aplikasi, dan menggunakan perpustakaan jt400. <br><br>  Untuk server otomatisasi, kami memutuskan untuk melakukan hal yang sama.  JNI meluncurkan IBM JVM, yang dikirimkan bersama Personal Communications for Windows.  Menggunakan metode pembungkus khusus, perintah dari server RPC yang datang dari luar dieksekusi dengan mem-proksi mereka ke dalam panggilan ke fungsionalitas jt400 yang diperlukan.  Karena yang terakhir ini juga berisi driver JDBC untuk DB2, diputuskan untuk menggunakannya untuk mengakses DBMS pada IBM i. <br><br>  Penting untuk dicatat bahwa Anda tidak dapat menggunakan Oracle JVM saat menggunakan HACL.  Jika Anda menjalankan sesi emulator terminal, maka mencoba membuat instance dari mesin virtual akan macet.  Demikian pula, jika Anda menjalankan Oracle JVM di ruang alamat suatu proses yang berinteraksi dengan HACL, yang terakhir hang tanpa penjelasan. <br><br>  Seiring waktu, solusinya diimplementasikan pada peningkatan jumlah pekerjaan.  Ini bekerja lebih cepat daripada solusi dengan Quick3270.  Popularitas tumbuh, demikian pula jumlah autotest.  Namun, selama operasi, kesulitan tambahan muncul: <br><br><ol><li>  Terminal sesekali membeku; </li><li>  Ketidakmampuan untuk bekerja pada dudukan regresi karena emulator terminal menolak untuk memulai jika desktop pengguna di mana emulator mulai diblokir atau sesi RDP-nya diblokir; </li><li>  Khusus Windows; </li><li>  Prosedur kompleks untuk menginstal, mengkonfigurasi, dan memperbarui alat (melalui paket MSI); </li><li>  Siklus regresi kami untuk 130 autotest (sekitar 4000 langkah) mulai memakan waktu 7-8 jam. </li></ol><br><h2>  Sesuatu perlu dilakukan ... </h2><br>  Dengan menganalisis jejak jejak dari banyak peluncuran autotest, menemukan hambatan dalam kinerja langkah-langkah yang sering digunakan, total waktu pelaksanaan regresi berkurang menjadi 4-5 jam.  Tetapi jelas bahwa menggunakan lapisan middleware dalam bentuk server RPC otomatisasi bersamaan dengan antarmuka HACL, yang juga memiliki kesalahan "mengambang" yang terakumulasi selama durasi seluruh sistem, tidak akan membantu dalam meningkatkan kinerja solusi. <br><br>  Di sisi lain, sebagai alternatif dari IBM Personal Communications untuk Windows, vendor menyediakan solusi lintas platform yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBM i Access - Solusi Klien.</a> <br><br><img src="https://habrastorage.org/webt/et/8d/kr/et8dkrlouhhuuqe3ew3krvyjq6u.png"><br>  <i>IBM i Access - Solusi Klien</i> <br><br>  Analisis struktur internal pada hari Sabtu dan Minggu pagi di atas cangkir kopi menunjukkan bahwa basis kodenya didasarkan pada produk lain dari IBM yang disebut IBM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Host on-Demand</a> (IBM HOD).  Ini adalah solusi lengkap untuk mengakses IBM i, dikembangkan di Java 6, yang tidak hanya memiliki implementasi penuh dari berbagai protokol komunikasi yang digunakan dalam mesin IBM (TN3270, TN5250, VTxxx, dll.), Tetapi juga komponen java-swing UI tingkat tinggi, digunakan untuk membangun emulator terminal mereka sendiri dalam bentuk konstruktor, yang dapat dikumpulkan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> IBM yang sedikit  Studi yang lebih rinci tentang IBM HOD menunjukkan bahwa komponen UI didasarkan pada implementasi Java dari antarmuka HACL, yang dokumentasinya terbuka.  Perilaku mereka bertepatan dengan hanya sedikit perbedaan dari dokumentasi C ++ HACL. <br><br><img src="https://habrastorage.org/webt/8u/fx/7-/8ufx7-3eikew1kjwcr0h-3uuw40.png"><br>  <i>IBM Host On-Demand (logo)</i> <br><br>  Selanjutnya, kami membuat perpustakaan Java untuk penggunaan internal, yang mengimplementasikan antarmuka yang sama dengan server otomatisasi C ++ RPC, tetapi secara internal menggunakan IBM HOD.  Untuk mengurangi overhead selama pelaksanaan langkah-langkah autotest, kami bermigrasi dari Ruby Cucumber ke cucumber-jvm dengan implementasi ulang semua langkah yang mirip dengan opsi Ruby.  Di hadapan antarmuka perangkat lunak yang mirip dengan server RPC, ini bukan masalah besar, terutama mengingat bahwa kami mencoba menahan pertumbuhan tak terkendali dalam jumlah langkah itu sendiri dan kami memiliki nilai ini di wilayah 30 unit. <br><br><h2>  Apa hasilnya </h2><br>  Akibatnya, kami mencapai operabilitas semua autotes tanpa mengubahnya, dan kecepatan kerja menjadi sangat tinggi sehingga kami harus memperkenalkan penundaan artifisial di antara langkah-langkah sehingga ketika mengembangkan autotest, Anda dapat mengamati kerjanya, jika tidak, UI tidak punya waktu untuk menggambar layar sampai akhir. <br><br>  Sudah ada 180 autotest dengan lebih dari 16.000 langkah dengan penundaan set 60 ms antara langkah mulai berjalan sekitar 30 menit terhadap 5 jam 30 menit, yang sesuai dengan peningkatan sebelas kali lipat dalam kinerja stand regresi. <br><br>  Hasilnya melebihi semua harapan.  Kami dekat dengan batas fisik protokol TN5250. <br><br>  Hingga saat ini, keputusan tersebut telah dipublikasikan ke seluruh bank, dan rekan-rekan dari kota-kota lain telah ikut serta dalam perbaikan.  Dari perubahan terbaru, kolega mengintegrasikan solusi dengan Jenkins, dalam versi pengujian, pengujian peluncuran pada server Linux dengan Xvfb selesai dan tahap operasi percontohan menjalankan autotest dimulai. <br><br>  Terima kasih sudah membaca sampai akhir! <br>  Semua sukses! <br><br>  PS Pada bulan Desember 2018, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konferensi Pengembang IBMi</a> berikutnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diadakan,</a> di mana sebuah laporan dibuat tentang topik artikel ini. <br><br>  Hingga saat ini, kami telah menyelenggarakan Konferensi setiap tahun hanya untuk karyawan Bank.  Mulai 2019, kami akan mengundang peserta dari perusahaan lain.  Sangat menarik untuk memperluas lingkaran komunikasi profesional dan pribadi, berbagi emosi, pengetahuan, dan pengalaman. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446332/">https://habr.com/ru/post/id446332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446322/index.html">Kriptografi di Jawa. Utilitas Keytool</a></li>
<li><a href="../id446324/index.html">Navigasi di DataGrip dengan Yandex.Navigator</a></li>
<li><a href="../id446326/index.html">Memecahkan masalah lalu lintas</a></li>
<li><a href="../id446328/index.html">Mengapa kita membutuhkan layanan penerimaan SMS dan makan apa dengan mereka</a></li>
<li><a href="../id446330/index.html">Mesin otomatis terhadap kode spageti</a></li>
<li><a href="../id446334/index.html">Refleksi tentang karir di bidang TI dan tips untuk pemula</a></li>
<li><a href="../id446336/index.html">Cara melarang kata sandi standar dan membuat semua orang membenci Anda</a></li>
<li><a href="../id446338/index.html">SVG 3D: Buat, Putar, dan Hidupkan</a></li>
<li><a href="../id446340/index.html">Sistem Operasi: Tiga Potongan Mudah. Bagian 1: Intro (terjemahan)</a></li>
<li><a href="../id446342/index.html">Dampak Halaman Besar Transparan pada Kinerja Sistem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>