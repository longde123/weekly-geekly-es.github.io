<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦🏻 💰 🦊 提前使用Geeta还是六个月前如何退休？ 💗 ❕ 💃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我不知道您使用的是哪种编程语言，但是我确定您在开发过程中会使用Geet。 有越来越多的工具来支持开发，但是即使是最小的测试项目，我也总是从git init命令开始。 在工作日中，我平均会再输入80个团队，以引用此版本控制系统。 


 当我开始重新学习十指印刷方法时，我非常紧张。 最后，这是改善您的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>提前使用Geeta还是六个月前如何退休？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420529/"><p><img src="https://habrastorage.org/webt/g_/v7/lg/g_v7lgawugfumbtsi3edevsencc.png"></p><br><p>我不知道您使用的是哪种编程语言，但是我确定您在开发过程中会使用Geet。 有越来越多的工具来支持开发，但是即使是最小的测试项目，我也总是从<code>git init</code>命令开始。 在工作日中，我平均会再输入80个团队，以引用此版本控制系统。 </p><br><p> 当我开始重新学习十指印刷方法时，我非常紧张。 最后，这是改善您的个人工作流程的最佳决定。 接下来最重要的优化是Geeta的高级开发。 </p><br><p> 关于Gita的许多文章已经在Habr上写过，但是它们并没有超出官方文档的范围，并且作者建议使用自制的拐杖简化工作。 我相信有必要研究Geet的具体任务示例，并提高使用标准化手段处理它的效率。 </p><br><h2 id="komu-budet-polezna-eta-statya"> 谁将从本文中受益？ </h2><br><p> 您已经掌握了绅士的《吉塔》系列，并且准备好继续前进了吗？ 有两种方法： </p><br><ol><li>  <strong>主缩略命令-别名。</strong> 它们几乎总是助记符且易于记忆。 忘记原始命令是有问题的，我在需要时轻松键入它们。 另外，我不会在编写代码时检查Gita中的内容而感到困惑。 </li><li>  <strong>了解有关团队的其他标志以及它们之间的集成。</strong> 我了解有人讨厌切割。 对于您来说，文章中也有有趣的内容- <em>如何提高命令输出的实用性和便利性，以及如何解决最琐碎但在实践中经常遇到的问题</em> 。 </li></ol><br><p> 今天花几个小时参加本文所述的实验，并通过近似计算节省六个月的工作寿命。 </p><br><p> 欢迎来到猫！ </p><a name="habracut"></a><br><h2 id="podgotovka"> 准备工作 </h2><br><p> 在开发人员中， <code>Bash</code>替代产品的标准是<code>Zsh</code> ，它是支持微调的高级软件外壳。 在<code>Zsh</code>用户中，标准是使用<code>Oh My Zsh</code> ，这是<code>Oh My Zsh</code>一组预定义设置。 因此，安装了该工具包后，我们将立即摆脱社区多年来为我们收集和开发的一系列黑客。 </p><br><p> 值得注意的是， <code>Zsh</code>适用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Linux</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mac</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Windows</a> 。 </p><br><p>  <strong>安装<code>Zsh</code>和<code>Oh My Zsh</code></strong> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">根据说明使用</a>一个命令安装<code>Zsh</code>和<code>Oh My Zsh</code> ： </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># macOS brew install zsh zsh-completions &amp;&amp; sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" # Ubuntu, Debian, ... apt install zsh &amp;&amp; sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"</span></span></code> </pre> <br><p> 由于任务是<em>优化与Geet的交互，因此</em>我们将向<code>Zsh</code>添加几个插件。 打开<code>~/.zshrc</code> ，并将<code>plugins</code>添加到列表中： </p><br><pre> <code class="hljs lisp">plugins=(<span class="hljs-name"><span class="hljs-name">git</span></span> gitfast)</code> </pre> <br><p> 总计： </p><br><ul><li>  <code>git</code>一组别名和辅助功能； </li><li>  <code>gitfast</code>增强了Gita的自动完成功能。 </li></ul><br><p>  <strong><code>tig</code>设定</strong> </p><br><p> 最后一点是<code>tig</code>控制台实用程序的安装： </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># macOS brew install tig # Ubuntu, Debian, ... # https://jonas.github.io/tig/INSTALL.html</span></span></code> </pre> <br><p> 我们将进一步讨论。 </p><br><h2 id="git-na-praktike"> 实践中的Git </h2><br><p> 与Geeta打交道最好通过解决特定的问题来完成。 接下来，我们考虑日常实践中的任务以及可方便解决的方案。 为此，请考虑使用带有文本文件的特定存储库。 </p><br><blockquote>  <strong>黄色方框表示本节中解决问题的主要别名。</strong>  <strong>仅学习它，并将其他所有东西留给一般开发。</strong> </blockquote><br><h3 id="proveryaem-sostoyanie-rabochey-direktorii"> 检查工作目录的状态 </h3><br><p> 让我们从最基本的事情开始。 我们做了一些工作，现在让我们看看工作目录中发生了什么： </p><br><pre> <code class="bash hljs">$ git status On branch master Changes to be committed: (use <span class="hljs-string"><span class="hljs-string">"git reset HEAD &lt;file&gt;..."</span></span> to unstage) new file: e.md Changes not staged <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit: (use <span class="hljs-string"><span class="hljs-string">"git add &lt;file&gt;..."</span></span> to update what will be committed) (use <span class="hljs-string"><span class="hljs-string">"git checkout -- &lt;file&gt;..."</span></span> to discard changes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> working directory) modified: b.md Untracked files: (use <span class="hljs-string"><span class="hljs-string">"git add &lt;file&gt;..."</span></span> to include <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> what will be committed) d.md</code> </pre> <br><p> 详细描述了所有文件的当前状态，并提供了其他操作说明。 刚开始使用Geeta时，它非常有用，但是日常工作中有很多多余的东西。 让我们通过其他按键降低噪声级别： </p><br><pre> <code class="bash hljs">$ git status -sb <span class="hljs-comment"><span class="hljs-comment">## master M b.md A e.md ?? d.md</span></span></code> </pre> <br><p> 是的，我们在<code>master</code>分支中，更改了<code>b.md</code> （ <code>M-odified</code> <code>b.md</code> ）文件并创建了两个文件，将第一个添加到Geeta索引（ <code>A-dded</code> ），然后将第二个添加到索引之外（ <code>??</code> ）。 简短明了。 </p><br><p> 仍然需要通过别名<em>“ <strong>g</strong> it <strong>s</strong> tatus with <strong>b</strong> ranch”</em>来优化此命令的无尽输入： </p><br><blockquote>  <strong>显示缩短的工作目录状态</strong> <br><br><pre> <code class="bash hljs">$ gsb <span class="hljs-comment"><span class="hljs-comment"># git status -sb</span></span></code> </pre> <br></blockquote><br><h3 id="sozdayom-kommit"> 创建一个提交 </h3><br><p> 我们继续。 </p><br><p> 当然，您可以进行提交。 但是，让我们尝试优化此简单任务的解决方案。 使用别名<em>“ <strong>g</strong> it dd dd ll”</em>将所有更改添加到索引： </p><br><pre> <code class="bash hljs">$ gaa <span class="hljs-comment"><span class="hljs-comment"># git add --all</span></span></code> </pre> <br><p> 我们使用别名<em>“ <strong>g</strong> it diff ched”</em>来检查索引是否恰好满足了我们的需要： </p><br><pre> <code class="diff hljs">$ gdca # git diff --cached diff --git a/b.md b/b.md index 698d533..cf20072 100644 --- a/b.md +++ b/b.md @@ -1,3 +1,3 @@ # Beta -Next step. +Next step really hard. diff --git a/d.md b/d.md new file mode 100644 index 0000000..9e3752e --- /dev/null +++ b/d.md @@ -0,0 +1,3 @@ +# Delta + +Body of article.</code> </pre> <br><p> 嗯，解决单个任务的更改应该落入一次提交。 在这里，两个文件的更改都不会以任何方式连接。 让我们从别名为<em>“ <strong>g</strong> it <strong>r</strong> set n ndo”</em>的索引中排除<code>d.md</code>文件： </p><br><pre> <code class="hljs pgsql">$ gru d.md # git <span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> <span class="hljs-comment"><span class="hljs-comment">-- d.md</span></span></code> </pre> <br><p> 并创建一个别名为<em>“ <strong>g</strong> it <strong>c</strong> ommit”</em>的提交： </p><br><pre> <code class="hljs ruby">$ gc <span class="hljs-comment"><span class="hljs-comment"># git commit</span></span></code> </pre> <br><p> 我们写出提交的名称并保存。 然后，使用别名<em>“ <strong>g</strong> it commit <strong>m</strong> e <strong>s</strong> sa <strong>g</strong> e”，</em>使用更熟悉的命令为<code>d.md</code>文件创建另一个提交： </p><br><pre> <code class="bash hljs">$ gaa <span class="hljs-comment"><span class="hljs-comment">#    $ gcmsg "Add new file" # git commit -m "Add new file"</span></span></code> </pre> <br><p>  <strong>我们可以...</strong> </p><br><p>  ...使用一个命令从索引提交修改的文件： </p><br><pre> <code class="bash hljs">$ gcam <span class="hljs-string"><span class="hljs-string">"Add changes"</span></span> <span class="hljs-comment"><span class="hljs-comment"># git commit -a -m "Add changes"</span></span></code> </pre> <br><p>  ...查看按单词而不是行的更改（在处理文本时非常有用）： </p><br><pre> <code class="bash hljs">$ gdw <span class="hljs-comment"><span class="hljs-comment"># git diff --word-diff</span></span></code> </pre> <br><p>  ...分部分添加文件（当您只需要将文件更改的一部分添加到提交中时非常有用）： </p><br><pre> <code class="bash hljs">$ gapa <span class="hljs-comment"><span class="hljs-comment"># git add --patch</span></span></code> </pre> <br><p>  ...仅将已经在Geeta监督下的文件添加到索引中： </p><br><pre> <code class="bash hljs">$ gau <span class="hljs-comment"><span class="hljs-comment"># git add --update</span></span></code> </pre> <br><p> 总计： </p><br><blockquote>  <strong>添加到索引/创建提交</strong> <br><br><pre> <code class="bash hljs">$ ga <span class="hljs-comment"><span class="hljs-comment"># git add $ gc # git commit</span></span></code> </pre> <br></blockquote><br><h3 id="ispravlyaem-kommit"> 修正提交 </h3><br><p> 上次提交的名称不能解释我们所做的更改。 让我们重新制定： </p><br><pre> <code class="bash hljs">$ gc! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --amend</span></span></code> </pre> <br><p> 在打开的文本编辑器中，我们将其更清楚地称为： <code>"Add Delta article"</code> 。 我确信您永远不会使用<code>-v</code>开关，尽管在编辑提交说明时，它会显示所做的所有更改，这有助于更好地导航。 </p><br><p>  <strong>我们可以...</strong> </p><br><p>  ...使文件更改为提交，但不要触摸描述： </p><br><pre> <code class="bash hljs">$ gcn! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --no-edit --amend</span></span></code> </pre> <br><p>  ...使所有文件更改立即提交，而无需先添加到索引： </p><br><pre> <code class="bash hljs">$ gca! <span class="hljs-comment"><span class="hljs-comment"># git commit -v -a --amend</span></span></code> </pre> <br><p>  ...结合前两个命令： </p><br><pre> <code class="bash hljs">$ gcan! <span class="hljs-comment"><span class="hljs-comment"># git commit -v -a --no-edit --amend</span></span></code> </pre> <br><p> 好了，请再次注意，我们只输入了三个字符，而不是键入完整的常规<code>git commit -v --amend</code> ： </p><br><blockquote>  <strong>更改最后一次提交</strong> <br><br><pre> <code class="bash hljs">$ gc! <span class="hljs-comment"><span class="hljs-comment"># git commit -v --amend</span></span></code> </pre> <br></blockquote><br><h3 id="nachinaem-rabotat-nad-novoy-fichey"> 新功能入门 </h3><br><p> 从当前别名<em>“ <strong>g</strong> it <strong>c</strong> heckout <strong>b</strong> ranch”</em>创建一个新分支： </p><br><pre> <code class="bash hljs">$ gcb erlang <span class="hljs-comment"><span class="hljs-comment"># git checkout --branch erlang</span></span></code> </pre> <br><p> 尽管没有，但最好写一篇有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Elixir</a>别名<em>“用钥匙移动它”</em>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更现代语言</a>的文章（在Gita中重新命名是通过<code>move</code> ）： </p><br><pre> <code class="bash hljs">$ gb -m elixir <span class="hljs-comment"><span class="hljs-comment"># git branch -m elixir</span></span></code> </pre> <br><p> 使用别名<code>gbmv</code>是合乎逻辑的，但是不幸的是，它尚未被发明。 一个好的选择。 </p><br><p> 我们已经知道：对存储库进行更改并创建一个提交： </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"#  —     ."</span></span> &gt; e.md $ gaa &amp;&amp; gcmsg <span class="hljs-string"><span class="hljs-string">"Add article about Elixir"</span></span></code> </pre> <br><p> 并记住： </p><br><blockquote>  <strong>创建一个新分支</strong> <br><br><pre> <code class="bash hljs">$ gcb <span class="hljs-comment"><span class="hljs-comment"># git checkout --branch</span></span></code> </pre> <br></blockquote><br><h3 id="slivaem-izmeneniya"> 合并变更 </h3><br><p> 现在，我们将有关Elixir的新文章添加到<code>master</code> 。 首先，切换到别名为<em>“ <strong>g</strong> it <strong>c</strong> heckout <strong>m</strong> aster”</em>的主分支： </p><br><pre> <code class="bash hljs">$ gcm <span class="hljs-comment"><span class="hljs-comment"># git checkout master</span></span></code> </pre> <br><p> 不，真的。 三种易于记忆的字符中最常用的命令之一。 现在，别名更改的名称为<em>“ gerge”</em> ： </p><br><pre> <code class="bash hljs">$ gm elixir <span class="hljs-comment"><span class="hljs-comment"># git merge elixir</span></span></code> </pre> <br><p> 糟糕，但是已经有人设法对<code>master</code>进行更改。 而不是我们的项目采用了优美的线性历史，我创造了 <del> 讨厌的 </del> 合并提交。 </p><br><blockquote>  <strong>合并分支</strong> <br><br><pre> <code class="bash hljs">$ gm <span class="hljs-comment"><span class="hljs-comment"># git merge</span></span></code> </pre> <br></blockquote><br><h3 id="udalyaem-posledniy-kommit"> 删除最后一次提交 </h3><br><p> 不用担心！ 您只需要删除最后的提交，然后尝试再次合并更改<em>“ <strong>g</strong> <strong>r</strong> reset <strong>hh</strong> ard”</em> ： </p><br><blockquote>  <strong>删除上一次提交</strong> <br><br><pre> <code class="bash hljs">$ grhh HEAD~ <span class="hljs-comment"><span class="hljs-comment"># git reset --hard HEAD~</span></span></code> </pre> <br></blockquote><br><h3 id="reshaem-konflikty"> 我们解决冲突 </h3><br><p> 用于准备线性更改历史记录的标准<code>checkout – rebase – merge</code>序列由以下别名序列执行： </p><br><pre> <code class="bash hljs">gco elixir <span class="hljs-comment"><span class="hljs-comment"># git checkout elixir grbm # git rebase master gcm # git checkout master gm elixir # git merge elixir</span></span></code> </pre> <br><p> 所有这些字母都经常被使用，以至于它们已经从手指上飞走了，在执行此类操作时，无需考虑要键入哪一组字母。 并且不要忘记，在<code>Zsh</code>您可以使用<code>Tab</code>键来补充分支的名称。 </p><br><blockquote>  <strong>变基</strong> <br><br><pre> <code class="bash hljs">$ grb <span class="hljs-comment"><span class="hljs-comment"># git rebase</span></span></code> </pre> <br></blockquote><br><h3 id="otpravka-izmeneniy-na-server"> 将更改提交到服务器 </h3><br><p> 首先，我们添加<code>origin</code>别名<em>“ <strong>g</strong> it <strong>r</strong> emote dd”的</em> <code>origin</code> ： </p><br><pre> <code class="bash hljs">$ gra origin git@github.com/... <span class="hljs-comment"><span class="hljs-comment"># git remote add origin git@github.com/...</span></span></code> </pre> <br><p> 然后，我们将更改直接发送到存储库的当前分支（ <em>“ gg”</em> -命令开头加倍的<code>g</code>表示当前分支中操作的执行）： </p><br><pre> <code class="bash hljs">$ ggpush <span class="hljs-comment"><span class="hljs-comment"># git push origin git_current_branch</span></span></code> </pre> <br><p>  <strong>您也可以...</strong> </p><br><p>  ...将更改与<code>upstream</code>安装的<em>“ <strong>g</strong> <strong>向上</strong>推送”</em>别名发送到服务器： </p><br><pre> <code class="bash hljs">$ gpsup <span class="hljs-comment"><span class="hljs-comment"># git push --set-upstream origin $(git_current_branch)</span></span></code> </pre> <br><blockquote>  <strong>将更改提交到服务器</strong> <br><br><pre> <code class="bash hljs">$ gp <span class="hljs-comment"><span class="hljs-comment"># git push</span></span></code> </pre> <br></blockquote><br><h3 id="poluchaem-izmeneniya-s-servera"> 我们收到来自服务器的更改 </h3><br><p> 工作如火如荼。 我们设法将新文章<code>f.md</code>添加到<code>master</code> ，而我们的同事更改了文章<code>a.md</code>并将此更改发送到服务器。 这种情况也可以很简单地解决： </p><br><pre> <code class="bash hljs">$ gup <span class="hljs-comment"><span class="hljs-comment"># git pull --rebase</span></span></code> </pre> <br><p> 然后，您可以安全地将更改发送到服务器。 冲突解决了。 </p><br><blockquote>  <strong>从服务器获取更改</strong> <br><br><pre> <code class="bash hljs">$ gl <span class="hljs-comment"><span class="hljs-comment"># git pull</span></span></code> </pre> <br></blockquote><br><h3 id="udalyaem-slitye-vetki"> 删除合并的分支 </h3><br><p> 因此，我们成功地将几个分支合并到<code>master</code> ，包括上一个示例中的<code>elixir</code>分支。 我们不再需要它们了。 您可以删除别名<em>“ <strong>g</strong> it ranch delete <strong>a</strong> nother”</em> ： </p><br><pre> <code class="bash hljs">$ gbda <span class="hljs-comment"><span class="hljs-comment"># git branch --no-color --merged | command grep -vE "^(\*|\s*(master|develop|dev)\s*$)" | command xargs -n 1 git branch -d</span></span></code> </pre> <br><p> 非常美丽而狡猾的团队。 通常我会忘记清除失去相关性的分支，而这支优雅的团队是真正的救赎。 如果您不想使用别名，只需将命令的完整版本复制到笔记中，然后根据需要执行即可。 </p><br><h3 id="sozdayom-vremennyy-kommit"> 创建一个临时提交 </h3><br><p>  <code>h.md</code>有关Haskell的新文章正在紧锣密鼓地进行。 写了一半，您需要得到同事的反馈。 无需<em>三思</em> ，我们输入别名<em>“ <strong>g</strong> it <strong>w</strong> ork <strong>i</strong> n <strong>p</strong> rogress”</em> ： </p><br><pre> <code class="bash hljs">$ gwip <span class="hljs-comment"><span class="hljs-comment"># git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m "--wip-- [skip ci]"</span></span></code> </pre> <br><p> 然后创建一个名称为<code>Work in Progress</code>的提交，跳过CI并删除“多余”文件。 我们将分支发送到服务器，讨论此同事，然后等待审核。 </p><br><p> 然后可以撤消此提交，并将文件返回到其原始状态： </p><br><pre> <code class="bash hljs">$ gunwip <span class="hljs-comment"><span class="hljs-comment"># git log -n 1 | grep -q -c "\-\-wip\-\-" &amp;&amp; git reset HEAD~1</span></span></code> </pre> <br><p> 要检查分支中是否有<code>WIP</code>提交，请使用以下命令： </p><br><pre> <code class="bash hljs">$ work_in_progress</code> </pre> <br><p> 当您需要切换到相邻分支时， <code>gwip</code>命令是相当可靠的<code>gwip</code> 。 但是在<code>Zsh</code>中， <code>stash</code>本身有很多别名。 </p><br><blockquote>  <strong>添加临时提交/重置临时提交</strong> <br><br><pre> <code class="bash hljs">$ gwip $ gunwip</code> </pre> <br></blockquote><br><h2 id="pryachem-izmeneniya"> 隐藏变更 </h2><br><p>  <strong>您需要小心使用此命令。</strong> 可以隐藏文件，然后执行粗心操作将其完全删除，因为这里有一个<code>reflog</code> ，您可以在其中查找丢失的工作。 </p><br><p> 让我们用<em>ll</em>别名隐藏我们正在处理的文件： </p><br><pre> <code class="bash hljs">$ gsta <span class="hljs-comment"><span class="hljs-comment"># git stash save</span></span></code> </pre> <br><p> 然后使用别名<em>“ <strong>g</strong> it <strong>st</strong> ash <strong>p</strong> op”</em>将它们返回： </p><br><pre> <code class="bash hljs">$ gstp <span class="hljs-comment"><span class="hljs-comment"># git stash pop</span></span></code> </pre> <br><p> 或更安全的<em>“隐藏起来”的方法是</em> ： </p><br><pre> <code class="bash hljs">$ gstaa <span class="hljs-comment"><span class="hljs-comment"># git stash apply</span></span></code> </pre> <br><p>  <strong>您也可以...</strong> </p><br><p>  ...看看我们到底隐藏了什么： </p><br><pre> <code class="bash hljs">gsts <span class="hljs-comment"><span class="hljs-comment"># git stash show --text</span></span></code> </pre> <br><p>  ...对相关命令使用缩写： </p><br><pre> <code class="bash hljs">gstc <span class="hljs-comment"><span class="hljs-comment"># git stash clear gstd # git stash drop gstl # git stash list</span></span></code> </pre> <br><blockquote>  <strong>隐藏更改/获取更改</strong> <br><br><pre> <code class="bash hljs">$ gsta $ gstaa</code> </pre> <br></blockquote><br><h3 id="ischem-bag"> 寻找错误 </h3><br><p>  <code>git-bisect</code>工具多次挽救了我的性命，也有自己的别名。 我们首先使用<em>别名“ <strong>g</strong> it <strong>b</strong> i <strong>s</strong> <strong>s s</strong> tart”</em>开始“二进制错误搜索”过程： </p><br><pre> <code class="bash hljs">$ gbss <span class="hljs-comment"><span class="hljs-comment"># git bisect start</span></span></code> </pre> <br><p> 我们注意到，当前分支的最后一次提交包含一个错误，别名为<em>“ <strong>g</strong> it <strong>b</strong> i sect <strong>b</strong> ad”</em> ： </p><br><pre> <code class="bash hljs">$ gbsb <span class="hljs-comment"><span class="hljs-comment"># git bisect bad</span></span></code> </pre> <br><p> 现在，我们将保证我们应用程序运行状态的提交标记为<em>“ <strong>g</strong> it <strong>b</strong> i <strong>s</strong> ect ood”</em> ： </p><br><pre> <code class="bash hljs">$ gbsg HEAD~20 <span class="hljs-comment"><span class="hljs-comment"># git bisect good HEAD~20</span></span></code> </pre> <br><p> 现在仍然可以继续用短语<code>gbsb</code>或<code>gbsg</code>回答Gita的问题，找到罪魁祸首之后，重置该过程： </p><br><pre> <code class="bash hljs">$ gbsr <span class="hljs-comment"><span class="hljs-comment"># git bisect reset</span></span></code> </pre> <br><p> 我在使用此工具时确实写了这些缩写。 </p><br><blockquote>  <strong>错误提交搜索</strong> <br><br><pre> <code class="bash hljs">$ gbss <span class="hljs-comment"><span class="hljs-comment"># git bisect start $ gbsb # git bisect bad $ gbsg # git bisect good $ gbsr # git bisect reset</span></span></code> </pre> <br></blockquote><br><h3 id="ischem-zachinschika-bespredela"> 我们正在寻找无法无天的煽动者 </h3><br><p> 即使测试的代码覆盖率很高，也没有人能够避免应用程序崩溃并友好地指向带有错误的特定行的情况。 或者，例如，在我们的情况下，我们想在<code>a.md</code>文件的第二行中找出谁犯了错误。 为此，运行命令： </p><br><pre> <code class="bash hljs">$ gbl a.md -L 2 <span class="hljs-comment"><span class="hljs-comment"># git blame -b -w a.md -L 2</span></span></code> </pre> <br><p> 您会看到，“ <code>Oh My Zsh</code>贡献者不仅为<code>git blame</code>团队创建了别名，还为它添加了密钥，使您可以轻松地直接找到煽动者。 </p><br><h2 id="bonus"> 红利 </h2><br><h3 id="prosmotr-spiska-kommitov"> 查看提交列表 </h3><br><p> 要查看提交列表，请使用<code>git log</code>命令和其他输出格式键。 通常，此命令以及按键会输入到Gita的自定义别名中。 幸运的是，我们已经有现成的别名<code>glog</code> 。 而且，如果您从本文开头的建议中安装了<code>tig</code>实用程序，那么您将是绝对的拥护者。 </p><br><p> 现在，要以一种非常方便的方式了解控制台中的提交历史，您需要输入单词<code>git</code>反之亦然： </p><br><pre> <code class="bash hljs">$ tig</code> </pre> <br><p> 该实用程序还提供了一些有用的附加功能，这些附加功能开箱即用不在Gita中。 </p><br><p> 首先，一个搜索故事内容的命令： </p><br><pre> <code class="bash hljs">$ tig grep</code> </pre> <br><p> 其次，查看所有源，分支，标签及其历史的列表： </p><br><pre> <code class="bash hljs">$ tig refs</code> </pre> <br><p> 第三，也许您会发现一些有趣的事情： </p><br><pre> <code class="bash hljs">$ tig --<span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre> <br><h3 id="sluchayno-sdelal-git-reset---hard"> 偶然使<code>git reset --hard</code> </h3><br><p> 您整天在<code>elixir</code>分支上工作： </p><br><pre> <code class="hljs pgsql">$ glog * <span class="hljs-number"><span class="hljs-number">17</span></span>cb385 (HEAD -&gt; elixir) Refine Elixir article * c14b4dc <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> article about Elixir * db84d54 (master) Initial <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span></code> </pre> <br><p> 最后，他们不小心删除了所有内容： </p><br><pre> <code class="bash hljs">$ grhh HEAD~2 HEAD is now at db84d54 Initial commit</code> </pre> <br><p> 不必惊慌。  <strong>最重要的规则是停止在Gita中执行任何命令并呼气</strong> 。 本地存储库中的所有操作均记录在特殊的日志<code>reflog</code>日志中。 从中，您可以获取所需提交的哈希并将其还原到工作树中。 </p><br><p> 让我们看一下reflog，但不是通过<code>git reflog</code>的通常方式，而是通过详细的脚本更加有趣： </p><br><pre> <code class="bash hljs">$ glg -g</code> </pre> <br><p> 找到所需的<code>17cb385</code>提交的哈希并恢复它： </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#           $ gcb elixir-recover 17cb385 #    $ gbd elixir #     $ gb -m elixir</span></span></code> </pre> <br><h3 id="sluchayno-vmesto-sozdaniya-novogo-kommita-vnyos-izmeneniya-v-predyduschiy"> 偶然地，我没有创建一个新的提交，而是对上一个进行了更改 </h3><br><p> 在这里，我们再次来到救援现场。 我们会找到原始<code>17cb385</code>提交的哈希，如果立即取消提交，则可以使用指向<code>HEAD@{1}</code>的快速链接来代替查找哈希。 接下来，我们进行软重置，而索引未重置： </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      $ grh --soft HEAD@{1} # git reset -soft #   $ gcmsg "Commit description"</span></span></code> </pre> <br><h3 id="vetka-slishkom-silno-ustarela"> 分支太旧了 </h3><br><p> 有时，您开始使用某个功能，但是其发布会无限期地延迟。 您提交并切换到其他任务。 与团队一起，您对母版进行了大量更改，并在一段时间后返回具有功能的分支。 您尝试重新设置基准，但是他提供了在12次提交中解析冲突的方法。 您可以尝试解决所有问题或使其变得更容易。 </p><br><p> 让我们看一个名为<code>elixir</code>的功能分支的示例： </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   master $ gcm # git checkout master #        $ gcb elixir-new # git checkout --branch elixir-new #           $ gcp elixir@{0} # git cherry-pick elixir@{0}</span></span></code> </pre> <br><p> 因此，我们没有尝试更新分支，而是采取并转移了一个提交，而没有任何问题。 </p><br><h3 id="udalenie-vazhnyh-dannyh-iz-repozitoriya"> 从存储库中删除重要数据 </h3><br><p> 要从存储库中删除重要数据，我保存了以下代码段： </p><br><pre> <code class="bash hljs">$ git filter-branch --force --index-filter <span class="hljs-string"><span class="hljs-string">'git rm --cached --ignore-unmatch &lt;path-to-your-file&gt;'</span></span> --prune-empty --tag-name-filter cat -- --all &amp;&amp; git push origin --force --all</code> </pre> <br><p>  <strong>运行此命令将破坏您的<code>stash</code> 。</strong> 建议在执行之前获取所有隐藏的更改。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关此技术的更多信息。 </p><br><h3 id="obraschenie-k-predyduschey-vetke"> 引用上一个分支 </h3><br><p> 当执行一些期望输入分支名称的命令时，我们可以将连字符作为对我们所伴随的分支的引用。 使用以下结帐技巧特别好： </p><br><pre> <code class="bash hljs">$ gco - <span class="hljs-comment"><span class="hljs-comment"># git checkout - $ gm - # git merge - $ grb - # git rebase -</span></span></code> </pre> <br><h3 id="udalenie-vseh-faylov-otmechennyh-v-gitignore"> 删除标记为<code>.gitignore</code>所有文件 </h3><br><p> 另一个常见的挫折为时已晚，无法将任何不需要的文件或目录添加到<code>.gitignore</code> 。 为了从存储库中清理它们（ <strong>并从disk删除它们</strong> ），已经有<code>git clean</code>命令的现成键： </p><br><pre> <code class="bash hljs">$ gclean -X <span class="hljs-comment"><span class="hljs-comment"># git clean -Xfd</span></span></code> </pre> <br><p>  <strong>小心点！</strong> </p><br><p> 阅读正确的方法。 </p><br><h3 id="zachem-mnogim-komandam-nuzhen-klyuch---dry-run"> 为什么许多团队需要<code>--dry-run</code>开关？ </h3><br><p>  <code>--dry-run</code>需要的，作为卸载和更新时的预防措施。 例如，上一节描述了如何删除<code>.gitignore</code>文件中指定的所有内容。 最好小心并使用<code>--dry-run</code>开关， <code>--dry-run</code>所有要删除文件<code>--dry-run</code>列表，然后再运行不带<code>--dry-run</code>的命令。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 本文显示了优化程序员工作的重点。 记住10-20个助记符的缩写并不困难，忘记原来的团队几乎是不可能的。 别名是标准化的，因此当您将整个团队切换到<code>Zsh</code> + <code>Oh My Zsh</code> ，即使使用结对编程，也可以以相同的速度和舒适度进行工作。 </p><br><h3 id="kuda-dvigatsya-dalshe"> 接下来要去哪里？ </h3><br><p> 我提供以下选项： </p><br><ol><li> 最后，弄清楚Geet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在里面的排列方式</a> 。 它有助于了解您在做什么以及为什么您想做什么不起作用。 </li><li> 不要懒于再次查看命令的文档： <code>git --help</code>或<code>ghh</code> 。 </li><li> 请参阅<a href="">链接中</a>的完整别名列表。 试图记住它们都是疯狂的，但是将列表用作有趣的命令和键的集合是一个好主意。 </li></ol><br><p> 某些别名不是平凡的，但在实践中证明是非常有用的。 所提供的许多别名不仅是缩写，而且是进一步优化工作的小功能。 使用Git变得更加愉快，提交的质量得到了提高。 </p><br><p> 我希望这些资料对您有用，并且您可以自己学习一些新知识。 也许他们已经开始积极引入一种新方法。 祝你好运 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420529/">https://habr.com/ru/post/zh-CN420529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420519/index.html">科学普及</a></li>
<li><a href="../zh-CN420521/index.html">现在正式发布：TLS 1.3被认可为标准</a></li>
<li><a href="../zh-CN420523/index.html">二元期权图表分析或我再次向自己证明免费赠品不存在</a></li>
<li><a href="../zh-CN420525/index.html">网络最老练。 第十五部分。 服务质量</a></li>
<li><a href="../zh-CN420527/index.html">可以发出微笑并具有感染力</a></li>
<li><a href="../zh-CN420533/index.html">使用Java 8方法参考模拟属性文字</a></li>
<li><a href="../zh-CN420537/index.html">关于扩音器如何相对诚实地赚钱的另一个故事</a></li>
<li><a href="../zh-CN420539/index.html">用于规范化和重置样式的自定义方法（custom-reset.css）</a></li>
<li><a href="../zh-CN420541/index.html">卡内基·梅隆大学的研究人员创造了最可信的“ deepfakes”</a></li>
<li><a href="../zh-CN420547/index.html">当我从零开始撰写和捍卫1C中的DEVOPS和工程实践文凭时</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>