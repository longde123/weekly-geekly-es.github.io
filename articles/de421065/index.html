<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐧 👩🏼‍🎨 ➡️ Wie ich AI beigebracht habe, Tetris für NES zu spielen. Teil 2: KI 🏀 🐗 🧘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der erste Teil (Code-Analyse) ist hier: https://habr.com/post/420725/ . 

 Algorithmus 
 Beschreibung 
 Der Algorithmus führt kontinuierlich die folge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich AI beigebracht habe, Tetris für NES zu spielen. Teil 2: KI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421065/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/2c5/a7e/cfd2c5a7e44131bfc188c3eea6ad5139.png" alt="Bild"></div><br>  Der erste Teil (Code-Analyse) ist hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/post/420725/</a> . <br><br><h2>  Algorithmus </h2><br><h3>  Beschreibung </h3><br>  Der Algorithmus führt kontinuierlich die folgenden Schritte aus: <br><br><ol><li>  Er wartet, bis ein neues Tetrimino entsteht. </li><li>  Überprüft den Typ des neu erstellten Tetriminos, den Typ des nächsten Tetriminos (Abbildung im Vorschaufeld) und den Inhalt des Spielfelds. </li><li>  Untersucht alle möglichen Möglichkeiten, um dem Spielfeld zwei Tetriminos hinzuzufügen, und bewertet jede Wahrscheinlichkeit. </li><li>  Verschiebt das neu erstellte Tetrimino so, dass es mit dem Ort der am besten erkannten Wahrscheinlichkeit übereinstimmt. </li></ol><br>  Jeder dieser Schritte wird nachstehend ausführlich beschrieben. <br><br><h3>  Suche sperren </h3><br>  Stellen Sie sich eine vereinfachte Version von Tetris vor, bei der die Formen nicht automatisch fallen.  Die einzige Möglichkeit, die Figur zu senken, besteht darin, sie vorsichtig abzusenken.  Nachdem wir das Timing aus dem Spiel entfernt haben, können wir den Zustand des aktiven Tetriminos anhand seiner Position und Ausrichtung vollständig beschreiben.  Die Figur hat einen bekannten Ort der anfänglichen Erstellung, und die folgenden Operationen werden verwendet, um von einem Zustand in einen anderen zu konvertieren: <br><br><ul><li>  Einen Schritt zurück </li><li>  Ein Schritt nach links </li><li>  Bewegen Sie sich einen Schritt nach rechts </li><li>  Drehen Sie einen Schritt gegen den Uhrzeigersinn </li><li>  Drehung im Uhrzeigersinn </li></ul><a name="habracut"></a><br>  Diese Operationen sind nur anwendbar, wenn die Quadrate des resultierenden Tetriminos leeren Zellen des Spielfelds entsprechen.  Wenn es unmöglich ist, einen Schritt nach unten zu gehen, wird der Status als blockiert betrachtet.  Da wir jedoch Tetris vereinfacht haben und das Warten auf das Sperren im Wesentlichen unendlich ist, kann der gesperrte Zustand durch Schieben und Scrollen durch andere Operationen weiter transformiert werden. <br><br>  Viele blockierte Zustände mit einer minimalen Folge von Operationen, die sie erstellen, können mithilfe der Breitensuche (BFS) gefunden werden.  Wie unten angegeben, wird eine Warteschlange zum Speichern von Zwischenergebnissen verwendet. <br><br><ol><li>  Wir stellen den Status bei der Erstellung in die Warteschlange. </li><li>  Wir leiten den Status aus der Warteschlange ab. </li><li>  Mit der Konvertierungsoperation erhalten wir die folgenden Zustände. </li><li>  Wenn sich zwischen ihnen keine Abwärtsbewegung befindet, wird der aus der Warteschlange entfernte Status blockiert. </li><li>  Wir stellen nachfolgende Zustände in die Warteschlange, die wir noch nicht besucht haben. </li><li>  Wenn die Warteschlange nicht leer ist, wiederholen Sie ab Schritt 2. </li></ol><br>  Das Programm repräsentiert jeden Zustand als Objekt mit den folgenden Feldern: <br><br> <code>{ x, y, rotation, visited, predecessor }</code> <br> <br>  Während der Vorbereitung erstellt das Programm ein dreidimensionales Array von Zustandsobjekten (20 Zeilen × 10 Spalten × 4 Umdrehungen), wobei <code>x</code> , <code>y</code> und <code>rotation</code> entsprechend initialisiert werden. <br><br>  Das <code>visited</code> Feld wird markiert, wenn sich der Status in der Warteschlange befindet.  In BFS ist dies gültig, da jeder nachfolgende Status die Gesamtpfadlänge um 1 erhöht. Das heißt, durch Erhöhen der Pfadlänge ist es unmöglich, einen nachfolgenden Status zu erstellen, der an einer anderen Stelle als dem Ende der Warteschlange eingefügt werden muss, um die Reihenfolge aufrechtzuerhalten. <br><br>  Das <code>predecessor</code> gibt das Statusobjekt an, von dem der aktuelle Status abgeleitet wird.  Es wird festgelegt, wenn der Status in die Warteschlange gestellt wird.  Der Erstellungsstatus hat keine vorherigen Status. <br><br>  Die Menge der während der Suche erkannten Sperrzustände wird durch die Art des Tetriminos und die gefüllten Blöcke auf dem Spielfeld bestimmt.  Die Reihenfolge der Bewegungen, die sie generiert haben, kann (in umgekehrter Reihenfolge) geklärt werden, indem Sie den <code>predecessor</code> zum Erstellungsstatus folgen.  Wenn die Konstante <code>PLAY_FAST</code> zu Beginn des Programms auf <code>true</code> <code>PLAY_FAST</code> ist, werden die vorherigen Zustände vollständig übersprungen, indem Tetrimino direkt auf das Feld gesetzt und blockiert wird. <br><br>  Ein dreidimensionales Array von Statusobjekten, eine Warteschlange und BFS werden in eine Klasse gepackt.  Er hat eine Suchmethode, die das Spielfeld (zweidimensionales Array), die Art des Tetriminos und den Hörer empfängt.  Jedes Mal, wenn ein gesperrter Zustand erkannt wird, wird das Spielfeld aktualisiert, indem Tetrimino an der entsprechenden Stelle hinzugefügt wird.  Dann wird das geänderte Spielfeld zusammen mit Informationen über die Änderungen zur Verarbeitung an den Hörer übertragen.  Nachdem der Listener die Rückkehr abgeschlossen hat, wird das Spielfeld wiederhergestellt. <br><br>  Der Listener wird verwendet, um mehrere Suchvorgänge in einer Kette zu kombinieren, wodurch alle möglichen Möglichkeiten gefunden werden, zwei (oder mehr) Tetriminos zum Spielfeld hinzuzufügen.  Die erste Suchmaschine in der Kette führt BFS nur einmal aus.  Die zweite Suchmaschine führt jedoch jedes Mal BFS aus, wenn die erste Suche einen gesperrten Zustand erkennt.  Und so weiter, wenn es andere Suchmaschinen in der Kette gibt. <br><br>  Der Listener der letzten Suchmaschine wertet das geänderte Spielfeld aus.  Wenn er das Spielfeld besser findet als zuvor untersucht, schreibt er das verwendete Objekt des gesperrten Zustands auf, das zu diesem Zeitpunkt die erste Suchmaschine in der Kette verwendet.  Da die erste Suchmaschine BFS nur einmal ausführt, bleiben die <code>predecessor</code> ihrer Statusobjekte bis zum Abschluss des gesamten Suchvorgangs gültig.  Das heißt, der letzte Zuhörer zeichnet im Wesentlichen den Weg auf, den das erste Tetrimino gehen sollte, um als Ergebnis die beste Konfiguration des Spielfelds zu erreichen. <br><br><h3>  Bewertungsfunktion </h3><br>  Die Bewertungsfunktion weist dem veränderten Spielfeld einen Wert zu - eine gewichtete Summe verschiedener Einflussparameter.  Die in diesem Fall verwendete Bewertungsfunktion basiert auf der vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Islam Al-Ashi</a> entwickelten Funktion.  Es werden die folgenden Parameter verwendet: <br><br><ul><li>  <b>Gesamtzahl der gelöschten Zeilen</b> : Dies ist die Gesamtzahl der Zeilen, die durch Hinzufügen von zwei Tetriminos gelöscht werden. </li><li>  <b>Gesamte Blockierhöhe</b> : Die <b>Blockierhöhe</b> ist die Höhe über dem Boden des Spielfelds, auf dem die Figur gesperrt ist.  Dies ist der vertikale Abstand, um den eine gesperrte Figur fallen würde, wenn Sie alle anderen belegten Felder des Spielfelds entfernen und die Ausrichtung der Figur beibehalten.  Die gesamte Blockierhöhe ist die Summe der Blockierhöhen der beiden Tetriminos. </li><li>  <b>Die Gesamtzahl der "Well" -Zellen</b> : Eine Well-Zelle ist eine leere Zelle, die sich über allen besetzten Zellen in einer Spalte befindet, sodass ihre linken und rechten Nachbarn besetzte Zellen sind.  Bei der Bestimmung von Brunnen werden die Wände des Spielfelds als besetzte Zellen betrachtet.  Die Idee ist, dass ein Brunnen eine Struktur ist, die oben offen, unten geschlossen und auf beiden Seiten von Wänden umgeben ist.  Die Wahrscheinlichkeit intermittierender Lücken in den Wänden des Bohrlochs bedeutet, dass Bohrlochzellen nicht unbedingt in einem kontinuierlichen Haufen innerhalb einer Säule auftreten. </li><li>  <b>Gesamtzahl der Löcher in den Spalten</b> : Das Loch in der Spalte ist eine leere Zelle, die sich unmittelbar unter der belegten Zelle befindet.  Das Geschlecht des Spielfeldes wird nicht mit der darüber liegenden Zelle verglichen.  Es gibt keine Löcher in den leeren Spalten. </li><li>  <b>Gesamtzahl der Übergänge in Spalten</b> : Ein Übergang in Spalten ist eine leere Zelle neben einer belegten Zelle (oder umgekehrt) innerhalb einer einzelnen Spalte.  Die Kombination des obersten belegten Spaltenblocks mit dem leeren Raum darüber wird nicht als Übergang betrachtet.  In ähnlicher Weise wird auch der Boden des Spielfelds nicht mit der darüber liegenden Zelle verglichen.  Daher gibt es in einer vollständig leeren Spalte keine Übergänge. </li><li>  <b>Gesamtzahl der Übergänge in Zeilen</b> : Ein Übergang in Zeilen ist eine leere Zelle neben einer belegten Zelle (oder umgekehrt) innerhalb derselben Zeile.  Leere Zellen in der Nähe der Wände des Spielfelds gelten als Übergänge.  Der Gesamtbetrag wird für alle Linien des Spielfelds berechnet.  Bei der Gesamtzahl der Übergänge werden jedoch vollständig leere Zeilen nicht berücksichtigt. </li></ul><br>  El-Ashi schlug vor, dass nützliche Gewichte unter Verwendung des Particle Swarm Optimization (PSO) -Algorithmus gefunden werden können, der den Satz von Lösungen iterativ verbessert, indem das in der Natur beobachtete Schwarmverhalten simuliert wird.  In unserem Fall ist jede Lösung ein Gewichtsvektor, und die Eignung der Option wird durch das Spiel in Tetris bestimmt.  Dies ist die Gesamtzahl der Tetriminos, in denen er bis zum Ende des Spiels überlebt hat. <br><br>  Diese Ideen werden in der unten beschriebenen Java-Version angewendet.  Es läuft außerhalb von FCEUX und kann für ein nicht grafisches In-Memory-Spiel konfiguriert werden, das mit einer viel höheren Geschwindigkeit ausgeführt wird.  Nach der Vorbereitung des PSO war ich überrascht zu sehen, dass sich der Algorithmus nach der ersten Iteration nicht weiter bewegt.  Nach dieser Iteration spielten mehrere zufällig generierte Lösungsvarianten bereits recht gut.  Für mehrere Tage nahm die Größe dieses Satzes ab, bis nur noch eine Option übrig blieb.  Hier sind die Werte für diese Lösung: <br><br><table><tbody><tr><th>  Parameter </th><th>  Gewicht </th></tr><tr><td>  Gesamtzahl der gelöschten Zeilen </td><td> <code>1.000000000000000</code> </td> </tr><tr><td>  Gesamte Blockierhöhe </td><td> <code>12.885008263218383</code> </td> </tr><tr><td>  Gesamtzahl der Wellzellen </td><td> <code>15.842707182438396</code> </td> </tr><tr><td>  Die Gesamtzahl der Löcher in den Spalten </td><td> <code>26.894496507795950</code> </td> </tr><tr><td>  Die Gesamtzahl der Übergänge in Spalten </td><td> <code>27.616914062397015</code> </td> </tr><tr><td>  Total Line Jumps </td><td> <code>30.185110719279040</code> </td> </tr></tbody></table><br>  Das Spielfeld wurde geschätzt, indem die Parameter mit ihren jeweiligen Gewichten multipliziert und die Ergebnisse addiert wurden.  Je niedriger der Wert, desto besser die Lösung.  Da alle Parameter und Gewichte positive Werte haben, beeinträchtigen alle Parameter die Gesamtbewertung.  Jeder von ihnen muss minimiert werden.  Dies bedeutet auch, dass die beste Punktzahl 0 ist. <br><br>  Da diese Gewichte zufällig ausgewählt wurden, kann der Bereich geeigneter Werte sehr breit sein.  Dieser bestimmte Satz von Zahlen und die geschätzte relative Bedeutung jedes Parameters sind möglicherweise nicht relevant.  Trotzdem wird es interessant sein, sie genau zu beobachten. <br><br>  Der am wenigsten schädliche Parameter ist die Gesamtzahl der gelöschten Zeilen.  Die Tatsache, dass diese Option schädlich ist, ist nicht intuitiv.  Aber das Hauptziel der KI ist das Überleben.  Er strebt nicht nach den meisten Punkten.  Stattdessen spielt er konservativ und räumt normalerweise die Ränge nacheinander ab.  Um Double, Triple oder Tetris zu erhalten, muss man einen Haufen wachsen lassen, der gegen das langfristige Ziel verstößt. <br><br>  Als nächstes in der Liste steht die gesamte Blockierungshöhe.  Dies kann minimiert werden, indem das Tetrimino so nahe wie möglich am Boden abgesenkt wird.  Dies ist eine einfache Strategie, die langfristig zum Überleben und kurzfristig zur hochwertigen Verpackung von Teilen beiträgt. <br><br>  Das Gewicht, das der Gesamtzahl der Well-Zellen zugeordnet ist, scheint ein wenig überraschend, da erfahrene Spieler normalerweise absichtlich tiefe Wells bauen, um mehrere Tetris (vierzeilige Kombinationen) hintereinander zu sammeln.  Aber wie oben erwähnt, ist dies ein riskantes Spiel, das dem Hauptziel - dem Überleben - widerspricht.  Darüber hinaus ist die Anzahl der Vertiefungen ein Indikator für die „Rauheit“ des Pfahls.  Ein gewisses Maß an Unebenheiten ist beim Platzieren bestimmter Figuren oder Figurenkombinationen von Vorteil.  Eine hohe Rauheit führt jedoch zu einer Beschädigung der dichten Verpackung. <br><br>  Die Gesamtzahl der Löcher in den Spalten beträgt ungefähr die Hälfte der Gesamtzahl der Übergänge in den Spalten.  Diese Parameter können kombiniert und zu einem gemeinsamen verwandten Parameter zusammengefasst werden, wodurch ein umfangreicherer und schädlicherer Parameter erhalten wird: die Gesamtzahl der Übergänge. <br><br>  Die dicht gepackten Bereiche weisen eine geringe Anzahl von Übergängen in alle Richtungen auf.  Daher kann die Hauptstrategie, die von künstlicher Intelligenz angetrieben wird, kurz wie folgt beschrieben werden: Packen Sie die Teile so nah wie möglich aneinander. <br><br><h3>  Andere Optionen </h3><br>  Hier ist eine Liste einiger weiterer Parameter, mit denen ich während der Entwicklung der KI experimentiert habe: <br><br><ul><li>  <b>Haufenhöhe</b> : Besetzte Blöcke können über leeren Zellen hängen und Vorsprünge und Löcher erzeugen.  Es ist jedoch nicht möglich, belegte Blöcke über vollständig leere Zeilen zu sperren.  Daher ist die Heap-Höhe die Anzahl der Zeilen, die mindestens einen belegten Block enthalten. </li><li>  <b>Gesamtzahl der belegten Spalten</b> : Dies ist die Anzahl der Spalten, die mindestens eine belegte Zelle enthalten. </li><li>  <b>Gesamtzahl der belegten Zellen</b> : Die Anzahl der belegten Zellen auf dem Spielfeld. </li><li>  <b>Gesamtzahl der verbundenen Bereiche</b> : Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Füllalgorithmus</a> wird hier verwendet, um die Anzahl der kontinuierlich verbundenen Bereiche zu berechnen.  Er findet nicht nur besetzte "Inseln", sondern entdeckt auch Löcher, die sich entlang beider Achsen erstrecken. </li><li>  Säulenhöhenstreuung: Dies ist ein statistisches Maß für die Variation der Säulenhöhen.  Es ist ein Indikator für die Oberflächenrauheit. </li><li>  <b>Gesamtanpassungswert</b> : Berechnet den Anpassungswert des Heaps für die nächste unbekannte Zahl.  Es zählt die Gesamtzahl der Möglichkeiten, wie 7 Arten von Formen zum Spielfeld hinzugefügt werden können, ohne dass neue Löcher auftreten.  Für eine genaue Zählung ist die wiederholte Verwendung von BFS erforderlich.  Für eine ungefähre Berechnung kann der Suchbaum jedoch stark abgeschnitten werden. </li><li>  <b>Durchschnittliche Bewertung für die nächste Figur</b> : Dieser Parameter vertieft die Suche, indem er alle Möglichkeiten für die nächste unbekannte Figur analysiert.  Es verwendet andere Parameter, um die Position jedes Figurentyps zu trennen, und gibt dann den Durchschnitt für 7 Bewertungen zurück.  Für jede Platzierung der Figur ist BFS erforderlich. </li><li>  <b>Gemitteltes simuliertes Spiel</b> : Der Parameter simuliert eine Reihe von Spielen in Tetris, wählt Teile mit einem eigenen Pseudozufallszahlengenerator aus und verwendet KI, um mit ihnen zu arbeiten.  Am Ende jedes Spiels wird das Spielfeld anhand anderer Parameter bewertet.  Der Durchschnittswert für alle Chargen wird zurückgegeben. </li></ul><br>  Alle Parameter können durch Hinzufügen von benutzerdefinierten Faktoren angepasst werden.  Anstatt einfach die gelöschten Zeilen zu berechnen, können Sie beispielsweise Ihre eigenen Gewichte für Single, Double, Triple und Tetris zuweisen und so ein Punktesystem simulieren.  Wenn die gleichzeitige Reinigung mehrerer Reihen das langfristige Überlebensziel beeinträchtigt, können einzelnen Reihen ein negatives Gewicht zugewiesen werden, während andere positiv werden können. <br><br>  Ein weiterer nützlicher Faktor ist der Offsetwert.  Zum Beispiel hat eine perfekt flache Oberfläche eines Haufens eine Streuung der Säulenhöhen von 0. Eine perfekt flache Oberfläche passt sich jedoch nicht an S und Z sowie an andere Formkombinationen an.  Daher muss durch Subtrahieren der Konstante die Varianz um die optimale Rauheit zentriert werden. <br><br>  Die angepassten und vorgespannten Parameter können bis zu einem gewissen Grad angehoben werden, so dass sie vor der Berechnung der gewichteten Summe logarithmisch oder exponentiell skaliert werden können.  Alle diese Wahrscheinlichkeiten können als zusätzliche Gewichte betrachtet werden, die möglicherweise durch Methoden wie PSO optimiert werden können. <br><br>  Viele der Parameter geben Aufschluss darüber, wie gut der Haufen mit zusätzlichen Stücken umgehen kann, z. B. solchen, die sich mit der Rauheit der Oberfläche befassen. Der „Gesamtbetrag der Anpassung“, die „durchschnittliche Bewertung der nächsten Figur“ und das „durchschnittliche simulierte Spiel“ bewerten jedoch das veränderte Spielfeld Einfügen von Zahlen, die nicht in den beiden bekannten enthalten sind.  Bei der Untersuchung nachfolgender Figuren nimmt aufgrund der schnellen Eliminierung der Reihe die Menge an zusätzlichem Wissen mit der Tiefe ab.  Dies bedeutet, dass der lange Verlauf der Partei in der Vergangenheit nicht so wichtig ist und der Verlauf der Partei in ferner Zukunft ebenfalls nicht sehr wichtig ist.  Wenn eine kurze Folge von Figuren zufällig falsch eingestellt ist, stellt die KI das Spiel schnell wieder her und verwendet die folgenden Zahlen, um die betroffenen Reihen zu löschen.  Die Bestimmung des optimalen Wertes für die Analyse nachfolgender Zahlen erfordert weitere Untersuchungen. <br><br>  Ein weiterer Aspekt der Nützlichkeit eines Parameters sind die Rechenkosten.  Die Kosten sind stark erhöht, da die Bewertungsfunktion für jede mögliche Platzierung von zwei Figuren aufgerufen wird.  Da AI in der Lage sein muss, Tetris in Echtzeit zu spielen, können die Kostenfaktoren, die wertvolle Informationen liefern, gegen nähere Techniken ausgetauscht werden, die schneller laufen. <br><br><h3>  KI-Training </h3><br>  Es gibt pathologische Sequenzen, die unabhängig von der Strategie zu Game Over führen können.  Das einfachste Beispiel ist die endlose Folge von Tetrimino S und Z, die, wie in der Animation gezeigt, schnell dazu führt, dass die KI verliert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb2/66a/2ba/cb266a2ba3575a43876e33f6a2948737.gif"></div><br>  Da es Tage dauert, bis die AI-Variante ausgeführt ist, bevor mehrere Chargen abgeschlossen und der Durchschnitt berechnet wurden, ist es völlig unpraktisch, die durchschnittliche Chargendauer als PSO-Kontrollmetrik zu verwenden.  Stattdessen können Sie die Komplexität des Spiels mit einer kontrollierten Geschwindigkeit erhöhen, indem Sie die Frequenz von S und Z erhöhen, was im Laufe der Zeit dazu führt, dass nur dieses Figurenpaar alternativ erstellt wird. <br><br>  Ich habe versucht, diese Lehrmethode zu verwenden, aber festgestellt, dass das Unterrichten von KI für das Arbeiten mit häufigem S und Z tatsächlich die Fähigkeit beeinträchtigt, mit gleichmäßig verteilten zufälligen Formen umzugehen. <br><br>  Bei einer alternativen Methode, die vom B-Type-Spiel inspiriert ist, steuert die PSO-Metrik die Häufigkeit der Zeilenreinigung.  Das Spielfeld ist ein 10-Zeilen-Diagramm mit zufälligen Müllblöcken. Jedes Mal, wenn die Linie gelöscht wird, wird unten eine neue Mülllinie angezeigt, die die Höhe des Haufens wiederherstellt.  Da das Spielfeld eine Breite von 10 Spalten hat und jedes Tetrimino im Durchschnitt aus 4 Quadraten besteht, sollte die KI alle 2,5 Tetrimino eine Zeile löschen.  Und um den Müll loszuwerden, muss er es noch schneller machen. <br><br>  Leider hat diese Technik auch die Leistung nicht verbessert.  Ein wahrscheinlicher Grund ist, dass zufällige Mülllöcher nicht genau mit den Zeichenfolgen übereinstimmen, mit denen sich die KI im realen Spiel befasst.  Darüber hinaus ist die Reinigung der Reihe ein kurzfristiges Ziel.  Eine gierige Reihenreinigung verbessert nicht unbedingt das langfristige Überleben.  Von Zeit zu Zeit sollten die Zeilen nicht berührt werden, um bestimmte Kombinationen nachfolgender Figuren zu verarbeiten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colin Fei</a> schlug auf seiner Webseite einen anderen Ansatz vor.  Er erstellte Histogramme, die den Prozentsatz der Formen anzeigen, die in jeder Reihe während der Versuchslose blockiert sind.  Interessanterweise sehen alle Histogramme unabhängig von der Anzahl der erstellten Figuren nahezu identisch aus.  Auf dieser Grundlage schlug er vor, dass Sie ein ungefähres Bild der Funktion für jeden Teststapel verwenden können, wenn Sie die statistische Erwartung bewerten, eine Figur in der Erstellungslinie zu blockieren, um so die Zeit zu erhalten, in der die KI bis zum Ende des Spiels spielt.  Ich beschloss, diese Möglichkeit zu prüfen. <br><br>  Unten finden Sie eine Wärmekarte vieler Testchargen mit insgesamt 2.039.900.000 Tetrimino.  Jede Zelle wird basierend auf dem Prozentsatz der darin gesperrten Formen gefärbt.  Um den visuellen Kontrast zu verbessern, wird eine nichtlineare Palette ausgewählt.  Die Karte wurde erstellt, indem die Zellwerte normalisiert wurden, indem durch den maximalen Prozentsatz der Zellen dividiert und dann die Potenz von 0,19 angegeben wurde (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Gammakorrektur"</a> ). <br><br><table><tbody><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d13/bcd/196/d13bcd1968b1f71c3311f7007c6f573e.png"></div></td><td><table><tbody><tr><th>  Farbe </th><th>  Prozentsatz </th></tr><tr><td>  <font color="#000000">■</font> </td><td> <code>0.00000000</code> </td> </tr><tr><td>  <font color="#0066FF">■</font> </td><td> <code>0.00000315</code> </td> </tr><tr><td>  <font color="#00CCFF">■</font> </td><td> <code>0.00024227</code> </td> </tr><tr><td>  <font color="#00FFCC">■</font> </td><td> <code>0.00307038</code> </td> </tr><tr><td>  <font color="#00FF66">■</font> </td><td> <code>0.01860818</code> </td> </tr><tr><td>  <font color="#00FF00">■</font> </td><td> <code>0.07527774</code> </td> </tr><tr><td>  <font color="#66FF00">■</font> </td><td> <code>0.23582574</code> </td> </tr><tr><td>  <font color="#CCFF00">■</font> </td><td> <code>0.61928352</code> </td> </tr><tr><td>  <font color="#FFCC00">■</font> </td><td> <code>1.42923040</code> </td> </tr><tr><td>  <font color="#FF6600">■</font> </td><td> <code>2.98867416</code> </td> </tr><tr><td>  <font color="#FF0000">■</font> </td><td> <code>5.78182519</code> </td> </tr></tbody></table></td></tr></tbody></table><br>  Die dunkelorangen und roten Streifen in den Zeilen 17 und 18 bedeuten, dass die überwiegende Mehrheit der Figuren dort landet.  Der hellgrüne Farbton von unten ist eine Folge der Geometrie der Figuren: Nur 4 der 7 Tetrimino-Arten können in der unteren Zeile erscheinen.  Die unteren Ecken sind schwarz, weil es unmöglich ist, dorthin zu gelangen. <br><br>  Die Farbe entlang jeder Linie ist nahezu gleichmäßig, was darauf hindeutet, dass die Formen horizontal gleichmäßig verteilt sind.  Leichte Lücken lassen sich anhand der Histogramme einzelner Formtypen erklären: <br><br><table><tbody><tr><td>  <b>T.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82c/fb3/c14/82cfb3c1456fce7726985859554021d8.png"></div></td><td>  <b>J.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebd/f38/1a2/ebdf381a25323b9c73eaed6c467064b5.png"></div></td><td>  <b>Z.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/986/389/38198638921c4dcbc3a8f1978e665b89.png"></div></td><td>  <b>O.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/669/be1/5e4/669be15e4ba1b9becffb4ee97e398cbb.png"></div></td><td>  <b>S.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/79c/2a5/dc879c2a52f1020a69f76e9554fca978.png"></div></td><td>  <b>L.</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/204/acb/fbf204acb6d376818fc6e98f8f517e4e.png"></div></td><td>  <b>Ich</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/e41/92b/7bbe4192bbb2204d4b677a9a36354da2.png"></div></td></tr></tbody></table><br>  T stellt sich als der universellste Typ heraus: Sein Histogramm ist einheitlicher als alle anderen.  Anomalien im Histogramm J - das Ergebnis des Einflusses der Wände;  Nur <code>Jr</code> und <code>Jl</code> können sich in den Seitenspalten befinden, wodurch AI die Spalten 1 und 9 häufiger zum Kompensieren verwendet. Gleiches gilt für L. Die Histogramme Z und S sehen ungefähr gleich aus, was das Ungleichgewicht aufgrund der Tatsache betont, dass <code>Zv</code> und <code>Sv</code> sind keine perfekten Spiegelbilder voneinander.  Typ O ist auf ein 19 × 9-Spielfeld beschränkt, und es sieht so aus, als würde AI O eher an den Seiten als in der Mitte verwenden.  Tetrimino I ist nach rechts verschoben, weil sich dort sein Startpunkt befindet;  Daher ist das Sperren in Spalte 1 selten. <br><br>  Die Tabelle zeigt den Prozentsatz der Zahlen, die in jeder Zeile blockiert sind. <br><br><table><tbody><tr><th>  String </th><th>  Prozentsatz </th></tr><tr><td>  0 </td><td>  0,0000000000 </td></tr><tr><td>  1 </td><td>  0,0000000000 </td></tr><tr><td>  2 </td><td>  0,0000004902 </td></tr><tr><td>  3 </td><td>  0,0000026472 </td></tr><tr><td>  4 </td><td>  0,0000066180 </td></tr><tr><td>  5 </td><td>  0,0000172557 </td></tr><tr><td>  6 </td><td>  0,0000512280 </td></tr><tr><td>  7 </td><td>  0,0001759400 </td></tr><tr><td>  8 </td><td>  0,0006681210 </td></tr><tr><td>  9 </td><td>  0,0023187901 </td></tr><tr><td>  10 </td><td>  0,0077928820 </td></tr><tr><td>  11 </td><td>  0,0259672043 </td></tr><tr><td>  12 </td><td>  0,0866187068 </td></tr><tr><td>  13 </td><td>  0,2901315751 </td></tr><tr><td>  14 </td><td>  0,9771663807 </td></tr><tr><td>  15 </td><td>  3.3000408353 </td></tr><tr><td>  16 </td><td>  10.6989059268 </td></tr><tr><td>  17 </td><td>  28.5687976371 </td></tr><tr><td>  18 </td><td>  50.0335706162 </td></tr><tr><td>  19 </td><td>  6.0077671454 </td></tr></tbody></table><br>  Hier ist eine Grafik der Werte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a6/943/9d8/8a69439d8d818e46921cc5c9b75bd345.png"></div><br>  Wenn Linie 19 nicht berücksichtigt wird, zeigt die Grafik ein exponentielles Wachstum. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Folgende ist eine Liste der Verhältnisse der Anzahl gesperrter Formen in benachbarten Zeilen. </font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / String </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B.</font></font></sub> </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verhältnis (%) </font></font></th></tr><tr><td>  1/2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,00 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2/3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.52 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3/4 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 40.00 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4/5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 38,35 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5/6 </font></font></td><td>  33,68 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6/7 </font></font></td><td>  29.12 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7/8 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 26.33 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8/9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28,81 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9/10 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29,76 </font></font></td></tr><tr><td>  10/11 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30.01 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11/12 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29,98 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12/13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29,85 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13/14 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29,69 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14/15 </font></font></td><td>  29,61 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15/16 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30,84 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16/17 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 37,45 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 17/18 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 57.10 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18/19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 832,81 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Linien </font></font><code>16–19</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berücksichtigen die Figuren, die mit dem Boden des Spielfelds interagieren, so dass sie verworfen werden können. In Zeilen ist die </font></font><code>0–5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswahl zu klein, um sinnvoll zu sein. Die übrigen Verhältnisse, Paare 6 / 7–14 / 15, sind nahezu identisch; ihr Durchschnittswert beträgt 29,24%. Dies bedeutet, dass die Wahrscheinlichkeit, dass der Heap um eine Zeile wächst, unabhängig von der Höhe des Heaps ungefähr gleich ist. Dies ist logisch, da Tetris-Regeln die Interaktion am oberen Rand des Heaps einschränken, wenn dieser dicht gepackt ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die folgende Grafik zeigt das Protokoll von </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prozent der Zahlen in den Zeilen 6–15.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd6/7ec/745/fd67ec745b6509ae7c165ae0ebabedcc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es liegt nahe an einer vollkommen geraden Linie mit einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestimmungskoeffizienten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nahe 1 </font><font style="vertical-align: inherit;">. Die aus der oben gezeigten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen Regression</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abgeleitete Formel </font><font style="vertical-align: inherit;">gibt den Schnittpunkt mit der Y-Achse an, vorausgesetzt, der Prozentsatz der Formen in Zeile 0 beträgt ungefähr 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">–7,459</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> %. Die Umkehrung dieses Wertes ergibt eine statistische Erwartung von 2.877.688.349 Tetrimino oder 1.151.175.340 Zeilen bis zum Ende des Spiels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies macht uns das Protokoll </font><sub><font style="vertical-align: inherit;">10</font></sub><font style="vertical-align: inherit;"> verständlich</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Prozentsatz der Zahlen in jeder Zeile bleibt bis zur Zeile 0 linear. Wenn der Haufen jedoch fast die Decke des Spielfelds erreicht, ist die Bewegungsfreiheit so eingeschränkt, dass diese Eigenschaft verletzt wird. Darüber hinaus bedeutet das Blockieren eines Stücks in Zeile 0 nicht unbedingt, dass das Spiel beendet ist. Sie können weiterhin gespeichert werden, wenn ein Ort zum Erstellen neuer Figuren vorhanden ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Möglichkeit, die Stärke der KI zu bewerten, besteht darin, die durchschnittliche Anzahl der erstellten Formen zwischen der vollständigen Reinigung des Spielfelds zu messen. Eine vollständige Reinigung kann mit nur 5 Tetriminos erreicht werden. Dies kann unter anderem durch fünf O-Figuren erreicht werden, die auf dem Boden des Spielfelds angeordnet sind. Da jedes Tetrimino aus 4 Quadraten besteht und die Breite des Spielfelds 10 Quadrate beträgt, sollte die Anzahl der zwischen der vollständigen Reinigung erstellten Figuren ein Vielfaches von 5 sein ( als</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 × 5n = 2 × 10n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meine KI hat eine durchschnittliche Anzahl von Formen, die zwischen vollständigen Feldreinigungen von 1.181 erstellt wurden - eine relativ kleine Anzahl. Da eine vollständige Bereinigung dem Neustart eines Spiels gleicht, kann ein vollständiger Stapel als extrem lange Serie von Neustarts des Spiels angesehen werden, gefolgt von einem schnellen Fortschritt zum Ende des Spiels. Wie die oben beschriebene Folge von Alternativen </font></font><code>SZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sind pathologische Sequenzen, die zum Ende des Spiels führen, normalerweise sehr kurz. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das folgende Histogramm zeigt die Wahrscheinlichkeit (in Prozent), dass die KI nach der angegebenen Anzahl erstellter Figuren eine vollständige Löschung des Feldes erreicht.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7f/665/112/f7f66511246ef114d27d325a21c9b785.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gradreihenfolge in der obigen Formel bestimmt die Abnahmerate und vermutlich die Stärke der KI. Nach dieser Formel enden ungefähr 0,4% oder ungefähr 1 von 253 Spielen, die mit einem leeren Spielfeld beginnen, mit einer vollständigen Bereinigung nach nur 5 Tetriminos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu dem, was Faye vorgeschlagen hat, erfordern die Konstanten in den linearen und exponentiellen Näherungen eine sehr große Stichprobengröße, so dass R </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">näherte sich 1, daher ist diese Methode für PSO nicht anwendbar. </font><font style="vertical-align: inherit;">Die mit langen Chargen erhaltenen Konstanten können jedoch verwendet werden, um die Approximationsfunktion zu optimieren, die mögliche konstante Werte für kurze Chargen erzeugt. </font><font style="vertical-align: inherit;">In einer Art Entwicklungsrückkopplungsschleife kann die optimierte Approximationsfunktion im PSO verwendet werden, wodurch die AI verbessert wird, die wiederum zur Berechnung neuer Konstanten verwendet werden kann, die als Referenzkriterien für die Approximationsfunktion dienen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java-Version </font></font></h3><br><h4>  Über das Programm </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Entwickler, die mit Lua nicht vertraut sind, habe ich </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Quell-Zip-Datei</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen </font><font style="vertical-align: inherit;">Java AI-Port </font><font style="vertical-align: inherit;">hinzugefügt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Klassen sind fast zeilenweise Übersetzungen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von Lua-Objekten basierend auf Abschlüssen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pakete </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Code ist in zwei Pakete unterteilt: </font></font><br><br><ul><li> <code>tetris.ai</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> enthält AI-Klassen und Schnittstellen. </font></font></li><li> <code>tetris.gui</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellt ein grafisches Modell des Spielfelds. </font></font></li></ul><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> KI-Klassen und Schnittstellen </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse mit dem entsprechenden Namen </font></font><code>Tetriminos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beschreibt Tetrimino. </font><font style="vertical-align: inherit;">Es wird ähnlich verwendet </font></font><code>enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und enthält Konstanten für alle Arten von Tetrimino:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NONE = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> T = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> J = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> O = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> S = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> L = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br> <code>NONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet nicht zugewiesener Wert. </font><font style="vertical-align: inherit;">Es wird für leere Zellen des Spielfelds verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auch </font></font><code>Tetriminos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält zwei Orientierungen des Tischmodell. </font></font><code>PATTERNS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist ein 4-dimensionales ganzzahliges Array (Typ × Drehung × Quadrat × Koordinaten), das die relativen Koordinaten der Quadrate enthält. </font><font style="vertical-align: inherit;">Die Linien sind so angeordnet, dass bei jedem Typ die Ausrichtung der Formerstellung an erster Stelle steht. </font></font><code>ORIENTATIONS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist ein anderes Modell, ein zweidimensionales Array (Typ × Drehung) von Objekten </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jedes </font></font><code>Orientation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die Koordinaten des Quadrats als Array von Objekten </font></font><code>Point</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es enthält auch Felder, die den Bereich der zulässigen Positionen für die entsprechende Ausrichtung beschreiben.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Point[] squares = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Point[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxY; ... }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tetrimino-Rotation (der zweite Index in beiden Ausrichtungstabellen) wird in Objekten verwendet </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die von BFS bearbeitet werden.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> visited; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State predecessor; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> State next; ... }</code> </pre> <br> <code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und </font></font><code>rotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammen , um </font><font style="vertical-align: inherit;">die Position und Orientierung der Figur beschreiben. </font><font style="vertical-align: inherit;">Da der Tetrimino-Typ vom Moment der Erstellung bis zur Blockierung konstant bleibt, ist ein Feld dafür optional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klasse </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die den BFS-Algorithmus enthält, erstellt beim Erstellen einen vollständigen Satz aller möglichen Objekte </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createStates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ states = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State[AI.PLAYFIELD_HEIGHT][AI.PLAYFIELD_WIDTH][<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; AI.PLAYFIELD_HEIGHT; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; AI.PLAYFIELD_WIDTH; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rotation = <span class="hljs-number"><span class="hljs-number">0</span></span>; rotation &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; rotation++) { states[y][x][rotation] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> State(x, y, rotation); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl Java über eine umfangreiche Sammlungs-API verfügt, </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält es eine eigene Implementierung der Warteschlange. Die Klasse </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet </font></font><code>State.next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte zu verbinden , </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der verknüpften Liste. Da alle Objekte </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vordefiniert sind und jedes </font><font style="vertical-align: inherit;">Objekt </font><font style="vertical-align: inherit;">nur </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einmal zur Warteschlange hinzugefügt </font><font style="vertical-align: inherit;">werden </font><font style="vertical-align: inherit;">kann, kann die Warteschlange an Ort und Stelle arbeiten, sodass keine unnötigen temporären Containerobjekte erforderlich sind, die in allgemeinen Warteschlangenimplementierungen verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das „Herz“ von BFS ist die unten gezeigte Methode </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxRotation = Tetriminos.ORIENTATIONS[tetriminoType].length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mark = globalMark++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addChild(playfield, tetriminoType, mark, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(queue.isNotEmpty()) { State state = queue.dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxRotation != <span class="hljs-number"><span class="hljs-number">0</span></span>) { addChild(playfield, tetriminoType, mark, state, state.x, state.y, state.rotation == <span class="hljs-number"><span class="hljs-number">0</span></span> ? maxRotation : state.rotation - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxRotation != <span class="hljs-number"><span class="hljs-number">1</span></span>) { addChild(playfield, tetriminoType, mark, state, state.x, state.y, state.rotation == maxRotation ? <span class="hljs-number"><span class="hljs-number">0</span></span> : state.rotation + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } addChild(playfield, tetriminoType, mark, state, state.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, state.y, state.rotation); addChild(playfield, tetriminoType, mark, state, state.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, state.y, state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!addChild(playfield, tetriminoType, mark, state, state.x, state.y + <span class="hljs-number"><span class="hljs-number">1</span></span>, state.rotation)) { lockTetrimino(playfield, tetriminoType, id, state); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es erzeugt eine Warteschlange mit dem Status des erstellten Tetriminos und ruft dann nacheinander die untergeordneten Elemente aus den Status ab, die aus der Warteschlange entfernt wurden, und fügt sie der Warteschlange wieder hinzu, wenn sie auf dem Spielfeld angezeigt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spielfeld, das eine Kombination aus besetzten und leeren Zellen, den erstellten Tetrimino-Typ und eine beliebige Kennung enthält, wird an die </font><font style="vertical-align: inherit;">Methode übergeben </font><font style="vertical-align: inherit;">. Während der Ausführung des BFS wird ein Listener aufgerufen, wenn eine Sperrposition erkannt wird.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISearchListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, State state)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Hörer erhält ein geändertes Spielfeld, das ein festes Tetrimino enthält. Der Typ des erstellten Tetrimino und eine beliebige Kennung werden ebenfalls übertragen. Der letzte Parameter ist, </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in dem Tetrimino blockiert ist. Wenn Sie der Kette von Gliedern folgen </font></font><code>State.predecessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können Sie die </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Form </font><font style="vertical-align: inherit;">wiederherstellen </font><font style="vertical-align: inherit;">. </font></font><br><br> <code>State.visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">könnte implementiert werden als </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; In diesem Fall müssten jedoch vor der Suche alle Objekte sortiert werden, </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf die zurückgesetzt werden </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soll </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Stattdessen habe ich einen </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert im </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleich zu einem Zähler erstellt, der mit jedem Aufruf erhöht wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode</font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stellt nachfolgende Zustände in die Warteschlange. Der nachfolgende Zustand muss sich innerhalb des Feldes befinden und sich auf 4 leeren Zellen des Spielfelds befinden. Außerdem muss der nachfolgende Zustand nicht besucht werden </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn die Position gültig ist, wird </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurückgegeben, </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch wenn der nachfolgende Status nicht in die Warteschlange gestellt werden konnte, da er bereits besucht wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet den Rückgabewert </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um zu bestimmen, ob eine Form erstellt werden kann. Wenn die Figur nicht erstellt werden kann, hat der Heap den oberen Rand erreicht und die Suche kann nicht mehr durchgeführt werden. deshalb kehrt es zurück </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrweg</font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird auch die Bedeutung für die Möglichkeit untersucht, einen weiteren Schritt nach unten zu gehen. Wenn dies nicht möglich ist, ist der aktuelle Status die Sperrposition und der Anruf beginnt </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Methode </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ändert das Spielfeld, ruft den Listener auf und stellt dann das Spielfeld wieder her. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Zeile des Arrays </font></font><code>playfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält 1 zusätzliches Element, in dem die Anzahl der belegten Zellen in der Zeile gespeichert ist. Das Inkrementieren eines Elements wird von der Methode ausgeführt, </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da die Zellen als beschäftigt markiert werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Hörer ein modifiziertes Spielfeld erhält, ruft er an</font></font><code>PlayfieldUtil.clearRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gefüllte Zeilen löschen Die Methode erkennt sie, indem sie den Wert im zusätzlichen Element des Arrays überprüft. Um eine Zeichenfolge zu entfernen, nutzt der Code die Tatsache, dass zweidimensionale Arrays in Java im Wesentlichen Arrays von Arrays sind. Es werden nur Links zu Zeichenfolgen gedrückt. </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält freie Zeilen; Er schließt den Reinigungsprozess ab, indem er einen Link zu einem von ihnen einfügt. Vor dem Durchführen der Verschiebung wird der Index der zu löschenden Zeile in einem zusätzlichen Zeilenelement gespeichert. Dann wird die Verbindung zur Linie auf den Stapel geschoben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann ruft der Hörer an</font></font><code>PlayfieldUtil.restoreRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen am Spielfeld zu verwerfen. </font><font style="vertical-align: inherit;">Schritte werden in umgekehrter Reihenfolge abgebrochen. </font><font style="vertical-align: inherit;">Zuerst bekommen wir eine freie Reihe von oben. </font><font style="vertical-align: inherit;">Dann wird die gefüllte Zeile vom Stapel abgerufen und der Index vom zusätzlichen Element wird wiederhergestellt. </font><font style="vertical-align: inherit;">Es wird verwendet, um Zeilenreferenzen zu verschieben und an die Stelle der gelöschten Zeile zurückzukehren. </font><font style="vertical-align: inherit;">Schließlich wird ein zusätzliches Element wiederhergestellt, dem der Wert der Breite des Spielfelds zugewiesen wird - die Anzahl der belegten Zellen in der gefüllten Zeile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch eine Methode </font></font><code>evaluatePlayfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die 4 Bewertungsparameter berechnet und in die unten gezeigte Containerklasse schreibt.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayfieldEvaluation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> holes; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> columnTransitions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rowTransitions; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wells; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klasse schafft das alles </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es enthält zwei Objekte, </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die durch den unten gezeigten Listener miteinander verbunden sind.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, State state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-number"><span class="hljs-number">0</span></span>) { result0 = state; } Orientation orientation = Tetriminos.ORIENTATIONS[tetriminoType][state.rotation]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = playfieldUtil.clearRows(playfield, state.y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalTotalRows = totalRows; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalTotalDropHeight = totalDropHeight; totalRows += rows; totalDropHeight += orientation.maxY - state.y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextID = id + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextID == tetriminoIndices.length) { playfieldUtil.evaluatePlayfield(playfield, e); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fitness = computeFitness(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fitness &lt; bestFitness) { bestFitness = fitness; bestResult = result0; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { searchers[nextID].search(playfield, tetriminoIndices[nextID], nextID); } totalDropHeight = originalTotalDropHeight; totalRows = originalTotalRows; playfieldUtil.restoreRows(playfield, rows); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann mit einer beliebigen Anzahl von Objekten umgehen </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Nintendo Tetris zeigt jedoch nur eine Form im Voraus an. Objekte </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden in einem Array gespeichert, und der oben gezeigte Code dient als gemeinsamer Listener. Die zufällige Kennung, die an die Methode übergeben wird, </font></font><code>Searcher.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist tatsächlich der Index des Arrays, der auch die Tiefe der Suche darstellt. Wenn der Listener aufgerufen wird, leitet der Bezeichner den Anruf zum nächsten </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Kette. Wenn er das Ende des Arrays erreicht, wertet er das Spielfeld aus. Und wenn er ein Spielfeld mit einem höheren Fitness-Score findet, schreibt er das blockierte </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vom ersten </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Kette auf. </font></font><br><br> <code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält eine Methode </font></font><code>search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die das Spielfeld empfängt, und ein Array, das die Typen des erstellten und des nächsten Tetriminos enthält. Er kehrt zurück</font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die Position und Drehung, in der das erste Tetrimino blockiert werden soll. </font><font style="vertical-align: inherit;">Er konzentriert sich nicht auf das zweite Tetrimino; </font><font style="vertical-align: inherit;">Beim nächsten Aufruf wird die Punktzahl neu berechnet. </font><font style="vertical-align: inherit;">Wenn der Haufen zu hoch ist und die Kette </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht beide Tetriminos platzieren kann, kehrt sie </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurück </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> State </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] tetriminoIndices)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tetriminoIndices = tetriminoIndices; bestResult = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; bestFitness = Double.MAX_VALUE; searchers[<span class="hljs-number"><span class="hljs-number">0</span></span>].search(playfield, tetriminoIndices[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bestResult; }</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> KI-Herausforderung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Java-Version nicht an FCEUX gebunden ist, kann sie möglicherweise für andere Projekte verwendet werden. Für diejenigen, die daran interessiert sind, KI an einem anderen Ort zu integrieren, beschreibt dieser Abschnitt alles, was Sie brauchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zunächst eine Instanz </font></font><code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, eine Instanz </font></font><code>PlayfieldUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ein Array für alle bekannten Tetrimino-Typen. Erstellen Sie außerdem eine </font></font><code>PlayfieldUtil.createPlayfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instanz des Spielfelds, indem Sie </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">. Es gibt ein zweidimensionales Array mit einer zusätzlichen Spalte zurück, die wir oben untersucht haben. Sie benötigen wahrscheinlich auch einen Zufallsgenerator.</font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(); PlayfieldUtil playfieldUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayfieldUtil(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tetriminos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[AI.TETRIMINOS_SEARCHED]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] playfield = playfieldUtil.createPlayfield(); Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangs ist das Spielfeld leer und alle Zellen sind relevant </font></font><code>Tetriminos.NONE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie die Zellen programmgesteuert ausfüllen, vergessen Sie nicht, die </font></font><code>playfield[rowIndex][AI.PLAYFIELD_WIDTH]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anzahl der belegten Zellen in jeder Zeile </font><font style="vertical-align: inherit;">aufzuschreiben </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Füllen Sie das Array der Tetrimino-Typen mit den Typen der ursprünglich erstellten Form und der nächsten Form, die normalerweise manuell ausgewählt werden.</font></font><br><br><pre> <code class="java hljs">tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann übergeben wir das Spielfeld und das Array von Typen an die Methode </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Er wird zurückkehren, </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in dem Sie das erste Tetrimino blockieren müssen. </font><font style="vertical-align: inherit;">Wenn er zurückkommt </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ist ein Spielende unvermeidlich.</font></font><br><br><pre> <code class="java hljs">State state = ai.search(playfield, tetriminos);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie einen Weg vom Erstellen einer Figur zum Sperren benötigen, übergeben Sie ihn an die </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>AI.buildStateList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs">State[] states = ai.buildStatesList(state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Spielfeld zu aktualisieren, geben wir es </font></font><code>PlayfieldUtil.lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammen mit seinem Typ und Objekt weiter </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Methode löscht automatisch die gefüllten Zeilen.</font></font><br><br><pre> <code class="java hljs">playfieldUtil.lockTetrimino(playfield, tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>], state);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor Sie erneut anrufen, </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen Sie das nächste Tetrimino zufällig auswählen.</font></font><br><br><pre> <code class="java hljs">tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>]; tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusammen sieht es so aus: </font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(); PlayfieldUtil playfieldUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayfieldUtil(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tetriminos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[AI.TETRIMINOS_SEARCHED]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] playfield = playfieldUtil.createPlayfield(); Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); tetriminos[<span class="hljs-number"><span class="hljs-number">0</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); tetriminos[<span class="hljs-number"><span class="hljs-number">1</span></span>] = random.nextInt(<span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... print playfield ... State state = ai.search(playfield, tetriminos); if (state == null) { break; // game over } playfieldUtil.lockTetrimino(playfield, tetriminos[0], state); tetriminos[0] = tetriminos[1]; tetriminos[1] = random.nextInt(7); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstatt das Spielfeld in Textform anzuzeigen, können Sie auf interessantere Weise anzeigen, was gerade passiert ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spielfeldanzeige </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Klasse </font></font><code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imitiert Nintendo Tetris-Grafiken, einschließlich der im vorherigen Teil des Artikels beschriebenen Verhaltensfunktionen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/dac/a4c/d58daca4c668408a42efa51ad7508d75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie es aus, um es in Aktion zu sehen </font></font><code>tetris.gui.Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie bei der Lua-Version können wir die Spielgeschwindigkeit anpassen, indem wir den konstanten Wert am Anfang der Datei ändern.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> PLAY_FAST = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br> <code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat 4 Methoden zur Manipulation des Bildschirms. </font><font style="vertical-align: inherit;">Die Methode </font></font><code>displayTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendert aktives Tetrimino in den angegebenen Koordinaten. </font><font style="vertical-align: inherit;">Es erhält einen Verzögerungsparameter, der die Methode warten lässt, bevor die angegebene Anzahl von Animationsframes zurückgegeben wird.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">displayTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delay)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>lockTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verriegelt die Figur. </font><font style="vertical-align: inherit;">Der Zeilenzähler, die Punkte, die Ebene und die Tetrimino-Farben werden entsprechend aktualisiert und zeigen das erwartete merkwürdige Verhalten, wenn die Werte die zulässigen Werte überschreiten. </font><font style="vertical-align: inherit;">Das Zuweisen eines </font></font><code>animate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werts </font><font style="vertical-align: inherit;">zu einem Parameter </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">umfasst Zeilenbereinigungsanimationen und Bildschirmflackern beim Empfang von Tetris. </font><font style="vertical-align: inherit;">Die Methode wird blockiert, bis die Animation beendet ist.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lockTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animate)</span></span></span></span></code> </pre> <br> <code>updateStatisticsAndNext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Führt ein Inkrement des Statistikzählers für das neu erstellte Tetrimino durch und aktualisiert die Anzeige der nächsten Abbildung. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateStatisticsAndNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> activeTetrimino, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nextTetrimino)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>dropTetrimino</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erzeugt eine Form und ermöglicht es ihr, unter dem Einfluss der "Schwerkraft" abzusteigen, ohne zu versuchen, sie zu drehen oder zu bewegen. </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet es für die letzten beiden Ziffern, wenn es </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurückkehrt </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Parameter </font></font><code>animate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wichtig </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist und es unmöglich ist, eine Figur zu erstellen, fällt der Vorhang zum Ende des Spiels. Wie bei allen anderen Methoden wird diese Methode blockiert, bis die Animation beendet ist. Es wird </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur zurückgegeben, wenn eine Figur auf einem geschäftigen Spielfeld erstellt werden kann.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dropTetrimino</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> animate)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese 4 Methoden müssen vom Workflow aufgerufen, aber </font></font><code>TetrisFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im Event Dispatch Thread selbst erstellt werden. </font><font style="vertical-align: inherit;">Informationen dazu finden Sie in der Klasse </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus Gründen des Interesses </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet er eine Klasse </font></font><code>Randomizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die einen voreingenommenen Pseudozufallszahlengenerator von Nintendo Tetris simuliert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Paket </font></font><code>tetris.gui.images</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält anzeigebezogene Dateien. </font></font><code>tiles.png</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Dies ist eine Mustertabelle, die alle Kachelgrafiken enthält. </font></font><code>background.dat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speichert die Kennungen der Kacheln, aus denen der Hintergrund besteht; </font><font style="vertical-align: inherit;">Daten extrahiert aus </font></font><code>$BF3F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und es </font></font><code>colors.dat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält Bytes, die ungewöhnliche quadratische Farben erzeugen, die ab Ebene 138 erscheinen. Es </font></font><br><br> <code>ImageLoader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält eine Tabelle mit NES-Paletten, und der </font></font><code>ImagePane</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollständige Satz der angezeigten Ebenenwerte wird gespeichert.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andere Projekte </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möglicherweise kann der Code verwendet werden, anstatt für den Demo-Modus zu schreiben. Tatsächlich kann eine solche Demo für immer gerendert werden, wobei ausgenutzt wird, wie schnell die KI das gesamte Spielfeld räumen kann. Um dies zu erreichen, müssen Sie im Pseudozufallszahlengenerator eine beliebige Konstante als Startwert verwenden, wodurch wir eine deterministische Tetrimino-Sequenz erhalten. Die ersten beiden Tetrimino-Sequenzen werden aufgezeichnet. Wenn die KI die vollständige Feldbereinigung erreicht, werden die nächsten beiden Tetriminos mit den ersten beiden der Sequenz verglichen. Wenn sie übereinstimmen (dieses Ereignis wird alle 49 vollständigen Feldreinigungen erwartet), kann dem Pseudozufallszahlengenerator dieselbe Konstante wie Seed übergeben werden, wodurch eine Endlosschleife erstellt wird. Die Dauer des Zyklus kann sehr lang sein, um die Tatsache zu verbergen, dass es sich um einen Zyklus handelt. Außerdem,Die Demo kann an einem zufälligen Punkt in der Schleife beginnen und jedes Mal eine neue Demo erstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Möglichkeit, KI zu verwenden, besteht darin, einen "Player versus Computer" -Modus zu erstellen. Während im Mehrspieler-Tetris mehrere Linien gleichzeitig gelöscht werden, erscheinen im unteren Teil des gegnerischen Feldes Mülllinien, die das Spielfeld erhöhen. Die KI muss in der Lage sein, sich aus dem gleichen Grund vor Schmutz zu schützen, aus dem sie B-Type-Spiele spielen kann. Wie bereits erwähnt, spielt AI jedoch konservativ und versucht normalerweise, jeweils eine Zeile zu löschen. Das heißt, er wird sich gegen Angriffe verteidigen können, aber er kann nicht angreifen. Um sein Verhalten ändern zu können, habe ich eine Schnittstelle namens erstellt </font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IChildFilter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] playfield, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tetriminoType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotation)</span></span></span></span>; }</code> </pre> <br> <code>AI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat einen alternativen Konstruktor, der eine Implementierung erhält </font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Falls verfügbar, </font></font><code>IChildFilter.validate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dient es als zusätzliche Überprüfung für die Erlaubnis des untergeordneten Staates. Wenn es zurückkehrt </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird der untergeordnete Status nicht in die Warteschlange gestellt. </font></font><br><br> <code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist eine Implementierung</font></font><code>IChildFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zielte darauf ab, vier Reihen (Tetris) aufzunehmen. </font><font style="vertical-align: inherit;">Wie lebende Spieler baut sie nach und nach einen Brunnen in der rechten Spalte des Spielfelds und steigt Zeile für Zeile von unten nach oben an. </font><font style="vertical-align: inherit;">Da es zeilenweise arbeitet, lehnt es untergeordnete Zustände ab, die der Spalte ganz rechts ein Quadrat hinzufügen. </font><font style="vertical-align: inherit;">Wenn die gesamte Zeile mit Ausnahme der Bohrlochspalte vollständig gefüllt ist, fährt die KI mit der nächsten Zeile fort. </font><font style="vertical-align: inherit;">Wenn 4 oder mehr dieser Leitungen fertig sind, kann der "Stock" in den Brunnen fallen und Tetris erhalten. </font><font style="vertical-align: inherit;">Außerdem wird die Höhe des Haufens verfolgt. </font><font style="vertical-align: inherit;">Wenn es zu groß wird, wirkt es sich </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht mehr auf die KI aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/82b/c27/710/82bc27710c0e5200d599be07bf549206.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen Sie die </font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Änderungen vor </font><font style="vertical-align: inherit;">, um den Betrieb zu testen </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WellFilter());</code> </pre> <br> <code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert, aber nicht besonders effektiv. Es enthält eine einfache Heuristik, die das Konzept demonstrieren soll. Um Tetris häufiger zu erhalten, müssen Sie eine ausgefeiltere Strategie verwenden, die möglicherweise mithilfe von PSO optimiert werden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus können Sie die Filterung des untergeordneten Status verwenden, um Muster zu generieren. Unten ist ein Beispiel dafür, wozu er fähig ist </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/e21/15f/569e2115f8936fc3391d1bb330017d8a.png"></div><br> <code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellt Bilder Zeile für Zeile von unten nach oben, ähnlich wie es funktioniert </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstatt die Spalte ganz rechts beizubehalten, werden jedoch </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur untergeordnete Zustände genehmigt, die einem bestimmten Muster entsprechen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Konstruktor </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhält den Namen eines der Bilder im Paket </font></font><code>tetris.gui.patterns</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das er als Vorlage verwendet. </font><font style="vertical-align: inherit;">Jedes 20 × 10-Bild enthält Schwarz-Weiß-Pixel, die den Zellen im Spielfeld entsprechen.</font></font><br><br><pre> <code class="java hljs">AI ai = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AI(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PatternFilter(<span class="hljs-string"><span class="hljs-string">"tetriminos"</span></span>));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die oben gezeigte Codezeile erzeugt die Silhouetten von sieben Arten von Tetrimino. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/0c8/d79/cb30c8d795e12e41d3831a0735637a55.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein weiteres Beispiel mit einem großen Tetrimino T, das in einem Winkel gedreht wurde. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/f95/14c/cf0f9514c3a08b88c4f67117614ade91.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Beispiel. </font><font style="vertical-align: inherit;">Wenn Sie genau hinschauen, sehen Sie den Namen des Spiels.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a26/712/284/a267122840a2373e7bb5fb6fa6282018.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie </font></font><code>WellFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>PatternFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es ist nichts anderes als ein Proof of Concept. </font><font style="vertical-align: inherit;">Die Muster, die er verarbeitet, beschränken sich auf den unteren Rand des Spielfelds, da Versuche, sie zu erhalten, normalerweise mit dem Ende des Spiels enden. </font><font style="vertical-align: inherit;">Dies ist jedoch eine interessante Idee, die es wert ist, weiter untersucht zu werden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gamepad-Version </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Lua-Skript und das Java-Programm ignorieren die Schwerkraft. Für sie ist die Abstiegsgeschwindigkeit nicht wichtig, da sie je nach Konfiguration die Figuren entweder sofort an den gewünschten Ort teleportieren oder auf einem beliebigen Pfad ziehen. In gewisser Weise ahmen sie nur Tetris nach und spielen es nicht. In der </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip-Datei mit den Quellen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> befindet sich jedoch ein weiteres Lua-Skript, das die Signale der Gamepad-Schaltflächen generiert, sodass das Spiel die Bewegung von Figuren, die Schwerkraft und alles andere steuern kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Hinzufügen von Schwerkraft erweitert den Suchraum erheblich und zwingt die KI, die listigen Regeln für die Manipulation von Formen zu berücksichtigen. Details dieser Regeln werden im ersten Teil des Artikels beschrieben und können durch eine direkte Untersuchung des Codes vollständig erkannt werden.</font></font> Hier sind die wichtigsten: <br><br><ul><li>       : ,   . </li><li>   «»   . </li><li>   «»  «»    . </li><li>         . </li><li>          . </li><li>          . </li><li>          . </li><li>   ,        . </li><li>   A  B           . </li><li>  «»  «»       6      16 .     «»  «»   ,     . </li><li>  «»            3 . </li><li>       96 .    ,    — . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um all diese Regeln zu berücksichtigen, müssen historische Informationen in die Suchzustände eingebettet werden. Sie benötigen Felder, in denen die Anzahl der Haltebilder für jede Schaltfläche und die Anzahl der Bilder nach der letzten automatischen Freigabe gespeichert werden. Jeder eindeutige Satz von Werten, einschließlich Koordinaten </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Tetrimino-Rotation kennzeichnen einen separaten und eindeutigen Zustand. Leider ist die Anzahl der Möglichkeiten so groß, dass eine vollständige Suche in diesem Raum unpraktisch ist. Die KI-Version für das Gamepad untersucht nur einen Teil davon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AI verwendet ein Objekt </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit den folgenden Feldern:</font></font><br><br><pre> <code class="java hljs">{ x, y, rotation, Left, Right, Down, A, B, fallTimer, visited, predecessor }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anstatt die automatische KI-Verschiebung in alternativen Frames zu verwenden, drücken Sie kurz die Umschalttaste. </font><font style="vertical-align: inherit;">Daher muss er nur dann überwachen, ob die Taste gedrückt wird und nicht wie lange sie gedrückt wird. </font><font style="vertical-align: inherit;">Da keine automatische Drehung gilt die gleiche Idee zu den Tasten A und B. Daher Bereich </font></font><code>Left</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann als die </font><font style="vertical-align: inherit;">Auflistung , </font><font style="vertical-align: inherit;">die eine der folgenden Werte interpretiert werden:</font></font><br><br><pre> <code class="java hljs">{ RELEASED, PRESSED }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf der anderen Seite müssen Sie für einen sanften Abstieg zunächst die Taste „Ab“ für drei Frames gedrückt halten, was die Existenz von 4 Zuständen erfordert: </font></font><br><br><pre> <code class="java hljs">{ RELEASED, PRESSED_FOR_1_FRAME, PRESSED_FOR_2_FRAMES, PRESSED_FOR_3_FRAMES }</code> </pre> <br> <code>Down</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhöht sich schrittweise von dem Wert </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font></font><code>PRESSED_FOR_3_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bei dem ein weicher Abstieg auftritt. Danach kann es einen Wert empfangen </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder zu zurückkehren </font></font><code>PRESSED_FOR_2_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was jeden zweiten Frame nach der anfänglichen Verzögerung einen weichen Abstieg verursacht. Es kann nicht </font></font><code>RELEASED</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von </font></font><code>PRESSED_FOR_1_FRAME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder von sein </font></font><code>PRESSED_FOR_2_FRAMES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigentlich verwendet der Lua-Code eine Ganzzahlkonstante, aber das Prinzip ist dasselbe. In </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ähnlicher Weise </font></font><code>visited</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>predecessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird der erhaltene Wert zugewiesen wird, </font><font style="vertical-align: inherit;">wenn in der Hilfswarteschlangenstatus zu </font><font style="vertical-align: inherit;">schreiben; Es </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist eins mehr als der Wert des übergeordneten Status. Bedingung enthaltend</font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, gleich der Abstiegsgeschwindigkeit, impliziert, dass in diesem Rahmen ein automatischer Abstieg stattfindet, und für nachfolgende Zustände dieses Zustands ist der Wert </font></font><code>fallTimer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder </font></font><code>Searcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert ein </font></font><code>8-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array vor, das alle möglichen Zustände enthält ( </font></font><code>20  × 10  × 4  × 2  × 2  × 4  × 2 A × 2 B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), und BFS wird ähnlich der für das </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array </font><font style="vertical-align: inherit;">gezeigten Methode ausgeführt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der unten gezeigte Pseudocode beschreibt, wie nachfolgende Zustände aus den Ruhezuständen erhalten werden.</font></font><br><br><pre> <code class="cpp hljs">Slide = (Left == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (Right == PRESSED) Rotate = (A == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (B == PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == RELEASED <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> Down == PRESSED_FOR_3_FRAMES then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == RELEASED then nextDown = PRESSED_FOR_1_FRAME <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> nextDown = PRESSED_FOR_2_FRAMES end addChild(Down = nextDown) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED, Down = nextDown) addChild(B = PRESSED, Down = nextDown) end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Slide then addChild() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED) addChild(B = PRESSED) end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> addChild(Left = PRESSED) addChild(Right = PRESSED) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(Left = PRESSED, A = PRESSED) addChild(Left = PRESSED, B = PRESSED) addChild(Right = PRESSED, A = PRESSED) addChild(Right = PRESSED, B = PRESSED) end end <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == PRESSED_FOR_1_FRAME then nextDown = PRESSED_FOR_2_FRAMES <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> nextDown = PRESSED_FOR_3_FRAMES end addChild(Down = nextDown) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Rotate then addChild(A = PRESSED, Down = nextDown) addChild(B = PRESSED, Down = nextDown) end end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie im folgenden Pseudocode gezeigt, </font></font><code>addChild</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berücksichtigt </font><font style="vertical-align: inherit;">die Funktion </font><font style="vertical-align: inherit;">die Reihenfolge der Ereignisse, die in jedem Frame auftreten (z. B. Verschiebung, Drehung und Abstieg).</font></font><br><br><pre> <code class="cpp hljs">nextFallTimer = fallTimer + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Left == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y, rotation) then x = x - <span class="hljs-number"><span class="hljs-number">1</span></span> elseif Right == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y, rotation) then x = x + <span class="hljs-number"><span class="hljs-number">1</span></span> end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x, y, nextClockwiseRotation) then rotation = nextClockwiseRotation elseif B == PRESSED <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> testPosition(x, y, nextCounterclockwiseRotation) then rotation = nextCounterclockwiseRotation end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Down == PRESSED_FOR_3_FRAMES <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> nextFallTimer &gt;= dropSpeed then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> testPosition(x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>, rotation) then y = y + <span class="hljs-number"><span class="hljs-number">1</span></span> nextFallTimer = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lockTetrimino() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end end childState = states[y][x][rotation][Left][Right][Down][A][B] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> childState.visited then childState.visited = mark childState.predecessor = state childState.fallTimer = nextFallTimer <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.enqueue(childState) end</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in der vorherigen Version wird </font></font><code>AI.search</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Kette von Objekten zurückgegeben </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In diesem Fall </font></font><code>State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält </font><font style="vertical-align: inherit;">jede jedoch </font><font style="vertical-align: inherit;">viele Schaltflächen, die in jedem Frame gedrückt werden müssen. Feld </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>rotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist für die </font><font style="vertical-align: inherit;">Manipulation der Zahlen nicht verwendet, sondern kann verwendet werden , um </font><font style="vertical-align: inherit;">die Richtigkeit der Zahlen bewegen zu überprüfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl der Suchraum aufgrund der oben beschriebenen Einschränkungen erheblich reduziert wurde, dauert es 1-3 Sekunden, um die Suche abzuschließen. Wenn Sie es ausführen, werden Sie nach dem Erstellen jedes Tetriminos eine Pause bemerken. Außerdem sehen die Bewegungen sehr unnatürlich aus; Normalerweise wird eine Drehung unmittelbar vor dem Verriegeln durchgeführt. Diese KI spielt sich jedoch fast genauso ab wie die Version, bei der die Schwerkraft selbst bei maximaler Geschwindigkeit ignoriert wurde.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um es zu überprüfen, führen Sie es aus </font></font><code>lua/NintendoTetrisAIGamepadVersion.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das sich in der </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zip-Datei mit den Quellen befindet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine einfachere Möglichkeit, die Schwerkraft zu berücksichtigen, besteht darin, die Bewegung der Figuren nur durch Drehen, gefolgt von einer Verschiebung und anschließendem Abstieg nach unten zu begrenzen. </font><font style="vertical-align: inherit;">Die Idee ist, dass die vertikale Geschwindigkeit der Figuren wenig Einfluss auf die KI hat, wenn Sie das Gleiten und Scrollen loswerden. </font><font style="vertical-align: inherit;">Alles, was er tun muss, ist, die Figur an die gewünschte Säule zu liefern, und die Schwerkraft erledigt den Rest. </font><font style="vertical-align: inherit;">Ein weiterer Vorteil dieser Technik besteht darin, dass der Suchraum sehr klein ist, sodass Sie ohne Verzögerung für Berechnungen in Echtzeit spielen können. </font><font style="vertical-align: inherit;">Der Nachteil dieses Ansatzes ist jedoch, dass die KI ohne Gleiten und Scrollen viel schlechter spielt. </font><font style="vertical-align: inherit;">Die Tetris-KI, die nicht in Echtzeit spielen kann, ist jedoch praktisch wertlos.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ergänzung </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfd/2c5/a7e/cfd2c5a7e44131bfc188c3eea6ad5139.png" alt="Tetris"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor habe ich ein Plugin geschrieben, das einen Spieler in Tetris prozedural simuliert. </font><font style="vertical-align: inherit;">Mein Projekt hatte jedoch einige Nachteile:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Bot hat die Schwerkraft ausgeschaltet, sodass Sie Folien und Scrollen ausführen können, die die Fähigkeiten des Players auf der niedrigstmöglichen Stufe von Nintendo Tetris übertreffen. </font><font style="vertical-align: inherit;">Er hebt die Figuren nie an, aber der einzige Weg, die Zahlen zu senken, ist ein kontrollierter sanfter Abstieg. </font><font style="vertical-align: inherit;">Das heißt, er spielt in einer theoretischen, idealisierten Welt. </font><font style="vertical-align: inherit;">Um es ganz klar auszudrücken, er betrügt.</font></font></li><li>   .    —  ,      .     Double, Triple  Tetris,         —  ,    .         90.    ,   ,       29   -     . </li><li>          .      .       .     ,  Tetris      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt werde ich über einen fortgeschrittenen Bot sprechen, der Nintendo Tetris spielt, ohne die Schwerkraft zu deaktivieren. </font><font style="vertical-align: inherit;">Er bewertet das Risiko und verwaltet es, wobei er aggressiv versucht, die maximale Punktzahl zu erreichen, bevor er eine hohe Abstiegsgeschwindigkeit erreicht.</font></font><br><br><hr><br><h1>  Video </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beobachten Sie, wie der Bot in allen unten gezeigten Videos ab Stufe 19 die maximale Anzahl an Nintendo Tetris-Punkten erreicht. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/l2YOt_GdfA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zsd3eAYMlN0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/efh-_zeQH4Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><hr><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Herunterladen </font></font></h1><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TetrisAI_2018-01-28.zip</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Datei </font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält:</font></font><br><br><ul><li> <code>src</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Quellcodebaum. </font></font></li><li> <code>TetrisAI.jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - kompilierte Binärdatei. </font></font></li><li> <code>lgpl-2.1.txt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Lizenz für freie Software. </font></font></li></ul><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starten </font></font></h1><br><h2>  Voraussetzungen </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nintaco</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein NES / Famicom-Emulator.</font></font></li><li> <code>Tetris (U) [!].nes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Nintendo Tetris ROM-Datei. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plugin starten </font></font></h2><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten Sie Nintaco und öffnen Sie </font></font><code>Tetris (U) [!].nes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug </font></font><code>TetrisAI.jar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem heruntergeladenen </font></font><code>.zip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Öffnen Sie das Fenster Programm ausführen, indem Sie Extras | wählen </font><font style="vertical-align: inherit;">Programm ausführen ...</font></font></li><li>        JAR        Find JAR… . </li><li>  Load JAR,   . </li><li>  Run. </li><li>        ,       <code>GAME TYPE</code>  <code>MUSIC TYPE</code> .   <code>D-pad</code> (     )  <code>A-TYPE</code>   .   Start (Enter),      . </li><li>    <code>A-TYPE</code>  <code>D-pad</code> (  )   <code>LEVEL 9</code> . ,    <code>A</code>    Start (   <code>X</code>   Enter),     19,    . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass der Bot nur für Level 19 und höher ausgelegt ist. </font><font style="vertical-align: inherit;">In niedrigeren Levels kann er die Teile nicht kontrollieren.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geschwindigkeitsreferenz </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Spiel schneller zu machen, wählen Sie Maschine | </font><font style="vertical-align: inherit;">Geschwindigkeit | </font><font style="vertical-align: inherit;">Max</font></font><br><br><hr><br><h1>  Details </h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hochebene </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterhalb von Stufe 10 ist die Abstiegsgeschwindigkeit in jeder Stufe etwas höher als in der vorherigen. </font><font style="vertical-align: inherit;">Ab Stufe 10 gibt es jedoch mehrere Plateaus, bei denen die Geschwindigkeit für mehrere Stufen konstant bleibt. </font><font style="vertical-align: inherit;">Dies ist eine Folge der Funktionsweise des Auslösemechanismus. </font><font style="vertical-align: inherit;">Die Geschwindigkeit wird als Anzahl der Frames pro Abstieg dargestellt, was ein ganzzahliger Wert ist. </font><font style="vertical-align: inherit;">Das heißt, für höhere Ebenen gibt es nicht mehr viele Optionen: 10–12, 13–15, 16–18, 19–28 und 29+ sind 5, 4, 3, 2 und 1 Rahmen für den Abstieg.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Bot wurde nur unter Berücksichtigung des Plateaus 19–28 entwickelt. In geraden Frames klickt er auf das Gamepad "Links", "Rechts", A, B oder nichts. Und in ungeraden Bildern ermöglicht es den automatischen Abstieg ohne Drücken von Tasten. Es scheint, dass das Spiel die horizontale Bewegung, die mit der Rotation zusammenfällt, nicht wahrnimmt; Daher wird jede Taste unabhängig in geraden Bildern gedrückt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu Meistern, die auf hohem Niveau spielen, nutzt der Bot Delayed Auto Shift (DAS), auch als Auto-Repeat bezeichnet, und verwandte Techniken nicht. Seine Arbeit erinnert eher an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die vibrierende Daumentechnik von Thor Akerlund</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Es erhöht jedoch die Schwingungsfrequenz auf das theoretische Maximum, das das Spiel zulässt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spieler werden mit 40, 100, 300 und 1200 Punkten für Einzel, Doppel, Dreifach und Tetris belohnt. </font><font style="vertical-align: inherit;">Und die Punkte werden mit der Levelnummer plus 1 multipliziert. Mit anderen Worten, um die maximale Punktzahl zu erreichen, muss der Spieler die maximale Anzahl von Tetris anstreben und so lange wie möglich auf hohen Levels spielen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level 19 ist das höchste Level, das als erstes ausgewählt werden kann, wodurch der Bot direkt zum Plateau 19–28 springen kann. </font><font style="vertical-align: inherit;">Aufgrund eines Fehlers im Level-Berechnungsmechanismus, den ich im vorherigen Teil erwähnt habe, geht das Spiel nach dem Löschen von 140 Zeilen auf Level 20 anstatt auf die erwarteten 200. Danach wechselt das Spiel alle 10 Zeilen das Level. </font><font style="vertical-align: inherit;">Nach Erreichen von 230 Reihen steigt der Bot jedoch vom Plateau auf und gibt schnell auf. </font><font style="vertical-align: inherit;">Das heißt, er muss so viele Tetris wie möglich wählen, bevor er 230 Zeilen säubert.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sanfter Abstieg </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein sanfter Abstieg kann auch die Anzahl der Punkte erhöhen. </font><font style="vertical-align: inherit;">Um Punkte zu erhalten, muss die Figur vorsichtig abgesenkt werden, um das Spielfeld zu fixieren. </font><font style="vertical-align: inherit;">Ein kurzfristiger sanfter Abstieg, der beim Positionieren einer Figur auftritt, hat keinen Einfluss auf die Punktzahl. </font><font style="vertical-align: inherit;">Wenn der Abstieg erfolgreich ist, erhält der Spieler einen Punkt für jede Linie, die während des weichen Abstiegs gekreuzt wurde. </font><font style="vertical-align: inherit;">Und der resultierende Wert wird nicht mit der Ebenennummer multipliziert, selbst wenn ein sanfter Abstieg zum Löschen der Zeilen führt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein sanfter Abstieg hat wenig Einfluss auf die Gesamtpunktzahl. </font><font style="vertical-align: inherit;">Wenn möglich, vervollständigt der Bot die Platzierung der Figur, indem er auf „Nach unten“ klickt, um diese Punkte zu erhalten. </font><font style="vertical-align: inherit;">In seltenen Fällen kann die Differenz zwischen einer sehr hohen Punktzahl und einer Überschreitung der Maximalpunktzahl gemittelt werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AI-Algorithmus </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen einer Form untersucht der Bot jede mögliche Platzierung der aktuellen und nächsten Form. Zulässige Platzierung ist die Position, in der die Figur entweder auf besetzten Zellen oder auf dem Boden des Spielfeldes ruht. Vom Erstellungsort der Figur aus kann diese Position durch eine Abfolge horizontaler Bewegungen, Drehungen und Abfahrten erreicht werden. Gültige Orte und Pfadsequenzen werden mit BSF gefunden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Platzieren eines Stücks auf dem Spielfeld hat Konsequenzen: 4 leere Zellen werden besetzt, und alle gefüllten Reihen werden gelöscht, wodurch die Reihen nach unten gehen. Für jede zulässige Platzierung der aktuellen Figur und die damit verbundenen Konsequenzen überprüft der Bot jede gültige Platzierung der nächsten Figur und bewertet die Kombination der Konsequenzen. Eine solche Suchkette wird vorgestellt </font></font><code>SearchChain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede der kombinierten Konsequenzen wird auf eine Bewertungsfunktion übertragen, die den Inhalt des Spielfelds berechnet. </font><font style="vertical-align: inherit;">Die Kombination mit der niedrigsten Punktzahl gewinnt und das aktuelle Stück wird entsprechend platziert. </font><font style="vertical-align: inherit;">Suchkettenergebnisse wirken sich nur auf die aktuelle Form aus. </font><font style="vertical-align: inherit;">Beim Erstellen der nächsten Abbildung wird diese in Kombination mit der darauf folgenden Abbildung usw. ausgewertet.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewertungsfunktion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Bewertungsfunktion ist eine gewichtete Summe der folgenden Parameter: </font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Gesamtzahl der gelöschten Zeilen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Anzahl der Zeilen, die durch Hinzufügen beider Tetriminos gelöscht wurden.</font></font></li><li> <strong>  </strong> –      ,   .     —   ,        ,       . </li><li> <strong>  -</strong> –    . </li><li> <strong>   </strong> –  ,     -. </li><li> <strong>    </strong> –   ,      .         .     . </li><li> <strong>     </strong> –      .       ,   1.   ,         ,           . </li><li> <strong>     </strong> –         ,    .  —        ,    —          . </li><li> <strong>    </strong> –     .   ,         (20). </li><li> <strong>    </strong> –     .   ,      0. </li><li> <strong>    </strong> –   ,     ( )    . </li><li> <strong>    </strong> :    —   ,     ( )    .         .        .          . </li><li> <strong>   </strong> –           . ,   1  ,   1,     —  0. </li><li> <strong> </strong> –   . </li><li> <strong>  </strong> –         . </li><li> <strong>   </strong> –      . </li><li> <strong>    </strong> –     .     . </li><li> <strong>  </strong> –        . </li></ul><br><h2>  Maschinelles Lernen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Gewichte der Bewertungsfunktion zu ermitteln, verwendeten wir eine Variante der in Fußnote [1] beschriebenen Methode der Partikelschwarmoptimierung (PSO). Um ein gutes Konvergenzverhalten zu erhalten, werden die vorgeschlagenen Trägheits- und Beschleunigungskoeffizienten angewendet. Und die maximalen Größen von Partikelschritten werden durch die Begrenzung ihrer Geschwindigkeitswerte bestimmt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Während jeder Iteration wurden Partikel parallel ausgewertet, um die verfügbaren Rechenressourcen voll auszunutzen. Nachdem Konvergenz festgestellt wurde (keine Verbesserung nach einer bestimmten Anzahl von Iterationen), wurde das PSO so eingestellt, dass es automatisch mit zufällig ausgewählten Gewichten neu gestartet wird, sodass wir den Suchraum weiter untersuchen konnten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Partikelpositionsvektor wurde bewertet, indem die Fertigstellung von 100 Chargen auf einem Plateau der Ebenen 19–28 simuliert wurde. Bei einer vollständigen Charge werden 230 Zeilen gereinigt, aber viele endeten mit einem Überlauf des Feldes. Die Chargenbewertungen wurden sortiert und die Partikelbewertungen wurden als Durchschnitt von 33 von 100 Chargen bestimmt. Die Idee war, basierend auf Aggressivität zu wählen. Die Partikel im oberen Drittel gewöhnen sich nur an die gewünschten Zahlenfolgen, was die Notwendigkeit eines konservativen Spiels einschränkt. Infolgedessen neigen sie dazu, das übliche Spiel an den Rand zu drängen und auf den nächsten "Stock" zu warten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mustersequenzen für 100 Chargen wurden vor dem PSO erzeugt und die gleichen Sequenzen wurden immer wieder verwendet. Dies war notwendig, um den Suchraum zu reparieren, damit die Lösungsoptionen miteinander verglichen werden konnten. Sequenzen wurden mit der Logik eines echten PRNG Nintendo Tetris erstellt, mit dem die Wahrscheinlichkeit verringert werden soll, dass Duplikate aufeinander folgen. PRNG weist jedoch auch Schwächen auf (siehe Abschnitt „Auswahl von Tetrimino“ aus einem früheren Artikel): Die Zahlen werden nicht gleichmäßig ausgewählt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erste Versuche führten dazu, dass Bots zu aggressiv agierten. Wenn sie das Plateau 19-28 überwunden haben, haben sie normalerweise die maximale Punktzahl erreicht. Leider führten sie oft zu früh zu Feldüberläufen. Als Reaktion darauf wurden vier Schritte unternommen, um die Bots zu „beruhigen“:</font></font><br><br><ol><li>    :        Tetris,   .      «»          .          .     ;     230 .  ,      Tetris   .        Single, Double  Triple.          ;        . </li><li>          .      ,   ,      7 .         . </li><li>  ,          ,           .        ,       7 . </li><li>          ,      ,      .       ,       .         ,      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachdem alle diese Regeln angewendet wurden, um die Bots zu „beruhigen“, ergab die PSO-Methode die folgenden Gewichte: </font></font><br><br><table><tbody><tr><th>  Parameter </th><th>  Gewicht </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl der gelöschten Zeilen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,286127095297893900 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamte Blockierhöhe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.701233676909959200 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl der Wellzellen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,711304230768307700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl der Tiefbrunnen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,910665415998680400 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Gesamtzahl der Löcher in den Spalten </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.879338064244357000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtgewichtete Säulenlöcher </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.168463848297177000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl der Lochtiefen in Säulen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.265587111961757270 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Minimale Tiefe des Säulenlochs </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,289886584949610500 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maximale Tiefe des Säulenlochs </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,362361055261181730 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Gesamtzahl der Übergänge in Spalten </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.028668795795469625 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total Line Jumps </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,874179981113233100 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtsäulenhöhen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −0.507409683144361900 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Haufenhöhe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −2.148676202831281000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spaltenhöhenstreuung </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −1.187558540281141700 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtzahl der besetzten Zellen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> −2.645656132241128000 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesamtgewichtete Anzahl besetzter Zellen </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,242043416268706620 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Säulenhöhen-Dispersion </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0,287838126164431440 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Kette eine Kombination anstrebt, die die Bewertungsfunktion minimiert, können Parameter mit positivem Gewicht als Boni und die Reststrafen betrachtet werden. </font><font style="vertical-align: inherit;">Die Gewichte zeigen jedoch nicht unbedingt die Bedeutung der entsprechenden Parameter; </font><font style="vertical-align: inherit;">Sie sind nicht normalisiert und können daher nicht verglichen werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> KI-Stärke </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Stärke der KI zu beurteilen, wurden ungefähr 1,7 Millionen Ergebnisse (in Punkten) von simulierten Spielen auf einem Plateau von 19 bis 28 gesammelt. Die Punktzahl spiegelt nicht das Spiel auf Stufe 29 oder höher wider und berücksichtigt keine Punkte, die durch sanften Abstieg erzielt wurden. Es enthält jedoch Spiele, die aufgrund von Feldüberläufen vorzeitig abgeschlossen wurden. Die Nintendo Tetris PRNG-Logik wurde verwendet, um die Tetrimino-Sequenzen zu erzeugen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter diesen Ergebnissen ist die größte Punktzahl 1.313.600. Die minimale Punktzahl ist 0. Der </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchschnitt liegt bei 816.379 und scheint klein zu sein. Wie unten erwähnt, sind die Daten jedoch verzerrt, sodass der Medianwert von 989.200 Punkten eine bessere Vorstellung vom typischen Wert gibt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oben angegeben, optimierte PSO die Gewichte basierend auf dem Durchschnitt des besten Drittels der Chargen. </font><font style="vertical-align: inherit;">In diesem Fall beträgt die durchschnittliche Punktzahl des besten Drittels 1 108 860. Tatsächlich beträgt die durchschnittliche Punktzahl der besten 75% 1.000.000. Der </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot hat eine Wahrscheinlichkeit von 47%, die Punktgrenze auf Stufe 29 zu erreichen. Es besteht eine Wahrscheinlichkeit von 61%, 900.000 Punkte auf die Stufe zu bringen 29. Die folgende Grafik zeigt die Wahrscheinlichkeiten für die Bewertung bis Stufe 29.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/082/43a/5a808243a35de546e886bcf6cc8663aa.png" alt="Wahrscheinlichkeitsdichte"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass die Wahrscheinlichkeit linear auf etwa 900.000 Punkte abnimmt. </font><font style="vertical-align: inherit;">Dann geht es in eine invertierte Sigmoidkurve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten finden Sie ein geglättetes Histogramm mit der Anzahl der Parteien für jeden der erzielten Punkte. </font><font style="vertical-align: inherit;">Seine Form wird durch die Ableitung des oben gezeigten Graphen bestimmt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/cf4/a7c/7b4cf4a7cfc06203bedef3b81243d20b.png" alt="Histogramm"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Schwankungen ignorieren, ist es bis zu ungefähr 900.000 flach und geht dann in eine Normalverteilung mit dem Zentrum um ungefähr 1.050.000 Punkte über. </font><font style="vertical-align: inherit;">Die Gründe für die Schwankungen sind nicht klar. </font><font style="vertical-align: inherit;">Es scheint, dass die Anzahl der Punkte es bevorzugt, in Schritten von 20.000 Punkten zu springen. </font><font style="vertical-align: inherit;">Vielleicht liegt das am Haufenbauzyklus und am Erhalten von Tetris.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RAM- und ROM-Zuordnung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um den CPU-Speicher zu manipulieren, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastenklicks zu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> senden und Frame-Rendering-Ereignisse zu empfangen, verwendet das Plugin die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Nintaco-API</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alle Speicheradressen wurden mit den Nintaco-Debugging-Tools ermittelt und Informationen zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Crystal ROMhacking.net-Wiki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzugefügt </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im Quellcode sehen sie wie Konstanten in der Schnittstelle aus </font></font><code>Addresses</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><hr><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Referenzen </font></font></h1><br><ol><li> van den Bergh, F.; Engelbrecht, AP (2006) <br> A study of particle swarm optimization particle trajectories <br> In: <i>Information Sciences 176 (2006)</i> (pp. 937–971) <br> Retrieved from <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://researchspace.csir.co.za/dspace/bitstream/handle/10204/1155/van%20den%20bergh_2006_D.pdf</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421065/">https://habr.com/ru/post/de421065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421055/index.html">Benutzerdefinierte Webentwicklung: Skalieren eines ständig wachsenden Projekts</a></li>
<li><a href="../de421057/index.html">So montieren Sie Wagen für Personenzüge</a></li>
<li><a href="../de421059/index.html">Beschleunigung von Websites mit frühen Tipps</a></li>
<li><a href="../de421061/index.html">PostgreSQL: Wie und warum schwillt WAL an</a></li>
<li><a href="../de421063/index.html">Neue Bücher über Kinderprogrammierung bei Scratch</a></li>
<li><a href="../de421067/index.html">Wie wir die AR-Anwendung zur Überprüfung historischer Orte entwickelt haben</a></li>
<li><a href="../de421069/index.html">Bobby Urban Rucksack: Im Schloss</a></li>
<li><a href="../de421071/index.html">Mod und Rest sind nicht gleich</a></li>
<li><a href="../de421073/index.html">Folge 1. Hackkosten</a></li>
<li><a href="../de421075/index.html">Digitales Wörterbuch von A bis Z.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>