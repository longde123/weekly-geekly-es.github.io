<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∂Ô∏è üé® üåÄ Erstellen Sie Ihr Minecraft: Generieren Sie 3D-Level aus W√ºrfeln üé£ üßëüèø‚Äçü§ù‚Äçüßëüèæ üë¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teilweise aufgrund der Popularit√§t von Minecraft hat das Interesse an der Idee eines Spiels, das in einer Welt aus 3D-Reliefs mit Elementen wie H√∂hlen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie Ihr Minecraft: Generieren Sie 3D-Level aus W√ºrfeln</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472574/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/jj/va/ccjjvazyarduee258az9-bbggkq.png"></div><br>  Teilweise aufgrund der Popularit√§t von <b>Minecraft</b> hat das Interesse an der Idee eines Spiels, das in einer Welt aus 3D-Reliefs mit Elementen wie H√∂hlen, Klippen usw. spielt, in letzter Zeit zugenommen.  Eine solche Welt ist eine ideale Anwendung f√ºr Rauschen, das im Stil meiner <b>ANL-</b> Bibliothek erzeugt wird.  Dieser Artikel entstand aus Diskussionen √ºber meine fr√ºheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versuche,</a> diese Technik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> implementieren.  Seitdem haben sich geringf√ºgige √Ñnderungen in der Struktur der Bibliothek ergeben. <br><br>  In fr√ºheren Beitr√§gen habe ich √ºber die Verwendung von 3D-Rauschfunktionen zur Implementierung von Gel√§nde im Minecraft-Stil gesprochen.  Danach hat sich die Bibliothek ein wenig weiterentwickelt und ich habe mich entschlossen, zu diesem Thema zur√ºckzukehren.  Da ich viele Fragen zu diesem System beantworten musste, werde ich versuchen, mehr √ºber die beteiligten Konzepte zu sprechen.  Um die Grundkonzepte klarer zu machen, beginne ich mit der Idee, ein 2D-Terrain zu generieren, das in Spielen wie Terraria und King Arthur's Gold verwendet wird, und das System dann auf 3D-Beispiele wie Minecraft zu erweitern.  Auf diese Weise kann ich Konzepte am Beispiel von Bildern effektiver demonstrieren. <br><br>  Dieses System wurde unter Ber√ºcksichtigung des folgenden abstrakten Ziels entwickelt: Wir sollten in der Lage sein, die Koordinate eines bestimmten Punkts oder einer bestimmten Zelle an das System zu √ºbergeben und zu bestimmen, welcher Blocktyp sich an dieser Stelle befinden soll.  Wir m√∂chten, dass das System eine ‚ÄûBlack Box‚Äú ist: √úbergeben Sie einen Punkt und geben Sie den Blocktyp zur√ºck.  Dies gilt nat√ºrlich nur f√ºr die erste Generation der Welt.  Bl√∂cke in solchen Spielen k√∂nnen durch die Aktionen des Spielers ge√§ndert werden, und es ist unpraktisch zu versuchen, solche √Ñnderungen mit demselben System zu beschreiben.  Solche √Ñnderungen m√ºssen auf andere Weise verfolgt werden.  Dieses System erzeugt die urspr√ºngliche Welt, makellos und unber√ºhrt von den H√§nden des Spielers und anderer Charaktere. <br><a name="habracut"></a><br>  M√∂glicherweise eignet sich diese Technik nicht f√ºr Modellierungssysteme wie Gras oder andere biologische Einheiten, da solche Systeme selbst komplexe Einheiten sind, die implizit nicht so einfach zu modellieren sind.  Gleiches gilt f√ºr Systeme wie fallenden Schnee, Eisbildung usw. ... Die in dem Artikel beschriebene Technik ist eine <i>implizite Methode</i> , d.h.  eine, die an einem Punkt gesch√§tzt werden kann und deren Wert an einem bestimmten Punkt nicht von den umgebenden Werten abh√§ngt.  Biologische und andere Arten von Systemen m√ºssen normalerweise Umgebungswerte ber√ºcksichtigen, um genaue Simulationen durchzuf√ºhren.  Zum Beispiel: Wie viel Sonnenlicht f√§llt auf einen Block?  Gibt es Wasser in der N√§he?  Diese und andere Fragen m√ºssen beantwortet werden, um das Wachstum und die Ausbreitung biologischer Systeme sowie in geringerem Ma√üe anderer Arten klimabezogener Systeme zu simulieren.  Diese Technik eignet sich auch nicht zum Modellieren von Wasser.  In diesem System gibt es kein Konzept von Str√∂mung, Kenntnis der Str√∂mungsmechanik oder Schwerkraft.  Wasser ist ein komplexes Thema, das viele komplexe Berechnungen erfordert. <br><br>  Wir modellieren also nur die Erde und die Steine.  Wir brauchen eine Funktion, die Ihnen sagt, wo der gegebene Ort sein soll: Erde, Sand, Luft, Gold, Eisen, Kohle usw. ... Aber wir werden mit der einfachsten beginnen.  Wir brauchen eine Funktion, die erkennt, ob der Block fest oder hohl ist (mit Luft gef√ºllt).  Diese Funktion sollte die uns umgebende Erde simulieren.  Das hei√üt, der Himmel ist oben, die Erde ist unten.  Nehmen wir also die biblische Aufgabe an und trennen den Himmel von der Erde.  Dazu untersuchen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gradientenfunktion</a> .  Die Gradientenfunktion erh√§lt ein Liniensegment im N-dimensionalen Raum (d. H. In jedem Koordinatenraum, ob 2D, 3D oder h√∂her) und berechnet das Gradientenfeld entlang dieses Segments.  Eingehende Koordinaten werden auf dieses Segment projiziert und ihr Gradientenwert wird abh√§ngig davon berechnet, wo sie relativ zu den Endpunkten des Segments liegen.  Projizierte Punkte erhalten Werte im Intervall (-1,1).  Und das wird ein guter Anfang f√ºr uns.  Wir k√∂nnen die Gradientenfunktion entlang der Y-Achse definieren. Am oberen Rand des Intervalls vergleichen wir das Gradientenfeld mit -1 (Luft) und unten mit 1 (Erde). <br><br><pre> Terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1}
 }} </pre><br>  (Ich werde den Eintrag kurz erl√§utern. Der Code f√ºr die Beispiele ist in der Lua-Deklarationstabelle geschrieben. Weitere Informationen zum Format finden Sie im Abschnitt zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua-Integration</a> . Im Wesentlichen ist das Format f√ºr das Parsen durch eine spezielle Klasse konzipiert, die Anzeigen liest und sie in Instanzb√§ume f√ºr Rauschmodule umwandelt. Ich bevorzuge dies Das Format ist ausf√ºhrlicher Schritt f√ºr Schritt im C ++ - Format, da es kompakter und sauberer ist. Meiner Meinung nach ist der Quellcode lesbarer und komprimierter als der C ++ - Code. Die Deklarationen sind gr√∂√ütenteils leicht zu lesen und zu verstehen. Die Module haben Namen, Quellen werden angegeben  Name oder Wert. Der zum Parsen von Tabellendeklarationen verwendete Lua-Code ist im Quellcode enthalten, falls Sie diese Deklarationen direkt verwenden m√∂chten.) <br><br>  Im Fall von 2D erh√§lt die Verlaufsfunktion ein gerades Liniensegment in der Form (x1, x2, y1, y2), und im Fall von 3D wird das Format auf (x1, x2, y1, y2, z1, z2) erweitert.  Der durch (x1, y1) gebildete Punkt bezeichnet den Beginn des mit 0 verbundenen Liniensegments. Der gebildete Punkt (x2, y2) ist das Ende des mit 1 verbundenen Segments. Das hei√üt, hier bilden wir das Liniensegment (0,1) -&gt; ( 0,0) mit einem Gef√§lle.  Daher liegt der Gradient zwischen den Bereichen der Funktion Y = 1 und Y = 0.  Das hei√üt, dieser Streifen bildet die Dimensionen der Welt in Y. Jeder Teil der Welt wird sich in diesem Streifen befinden.  Wir k√∂nnen jede Region entlang X fangen (fast unendlich, aber hier schr√§nkt uns die <code>double</code> Genauigkeit ein), aber alles ist interessant, d. H.  Die Erdoberfl√§che wird innerhalb dieses Bandes sein.  Dieses Verhalten kann ge√§ndert werden, aber darin haben wir ein hohes Ma√ü an Flexibilit√§t.  Vergessen Sie nur nicht, dass Werte, die √ºber oder unter diesem Band liegen, h√∂chstwahrscheinlich uninteressant sind, da es sich bei den obigen Werten h√∂chstwahrscheinlich um Luft handelt und die darunter liegenden Werte um Boden.  (Wie Sie gleich sehen werden, kann sich diese Aussage als falsch herausstellen.) F√ºr die meisten Bilder in dieser Serie werde ich den quadratischen Bereich anpassen, der durch das Quadrat (0,1) -&gt; (1,0) im 2D-Raum gegeben ist.  Deshalb sieht unsere Welt am Anfang so aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5f6/09d/543/5f609d54326fa4c746b5b391b1f75c6a.jpg"></div><br>  Bisher nichts Interessantes;  Dar√ºber hinaus beantwortet dieses Bild nicht die Frage ‚ÄûIst der gegebene Punkt fest oder hohl?‚Äú.  Um diese Frage zu beantworten, m√ºssen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schrittfunktion</a> (st√ºckweise definierte Funktion) anwenden.  Anstelle eines glatten Verlaufs ben√∂tigen wir eine klare Trennung, bei der alle Stellen auf einer Seite hohl und alle Stellen auf der anderen Seite fest sind.  In <b>ANL</b> kann dies mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Select-</a> Funktion implementiert werden.  Die Auswahlfunktion empf√§ngt zwei eingehende Funktionen oder Werte (in diesem Fall sind sie gleich "fest" und "hohl" (offen)) und w√§hlt sie basierend auf dem Wert der Steuerfunktion (in diesem Fall Gradient) aus.  Das Select-Modul verf√ºgt √ºber zwei zus√§tzliche Parameter, <b>Schwellenwert</b> und <b>Abfall</b> , die diesen Prozess beeinflussen.  In diesem Stadium ist ein <b>Abfall</b> unerw√ºnscht, daher wird er gleich 0 sein. Der <b>Schwellenwertparameter</b> entscheidet, wohin die Trennlinie zwischen Solid und Open f√ºhrt.  Alles, was in der Verlaufsfunktion gr√∂√üer als dieser Wert ist, wird zu Solid, und alles, was unter dem Schwellenwert liegt, wird ge√∂ffnet.  Da Gradient das Intervall mit Werten von 0 und 1 vergleicht, w√§re es logisch, den Schwellenwert auf 0,5 zu setzen.  Also teilen wir den Raum genau in zwei H√§lften.  Wert 1 ist eine feste Stelle und Wert 0 ist hohl.  Das hei√üt, wir definieren die Funktion der Erdebene wie folgt: <br><br><pre> Terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_select", type = "select", niedrig = 0, hoch = 1, schwelle = 0,5, control = "ground_gradient"}
 }}
</pre><br>  Wenn wir den gleichen Funktionsbereich wie zuvor vergleichen, erhalten wir etwas √Ñhnliches: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/d9c/4b5/35ad9c4b583840222252f7c136ba983a.jpg"></div><br>  Dieses Bild beantwortet eindeutig die Frage, ob der angegebene Punkt fest oder hohl ist.  Wir k√∂nnen die Funktion mit jeder m√∂glichen Koordinate des 2D-Raums aufrufen. Das Ergebnis ist entweder 1 oder 0, je nachdem, wo sich der Punkt relativ zur Erdoberfl√§che befindet.  Eine solche Funktion ist jedoch nicht besonders interessant, sondern nur eine flache Linie, die sich bis ins Unendliche erstreckt.  Um das Bild wiederzubeleben, verwenden wir eine Technik namens ‚ÄûTurbulenz‚Äú. <br><br>  "Turbulenz" ist eine komplexe Bezeichnung f√ºr das Konzept der Addition von Werten zu den eingehenden Koordinaten einer Funktion.  Stellen Sie sich vor, wir nennen die obige Funktion der Erde mit der Koordinate (0,1).  Sie liegt √ºber der Grundebene, da der Gradient bei Y = 1 einen Wert von 0 hat, der kleiner als der Schwellenwert = 0,5 ist.  Das hei√üt, dieser Punkt wird als offen berechnet.  Aber was ist, wenn wir diesen Punkt irgendwie transformieren, bevor wir uns auf die Funktion der Erde berufen?  Angenommen, wir subtrahieren einen Zufallswert von der Y-Koordinate, z. B. 3. Wir subtrahieren 3 und erhalten die Koordinate (0, -2).  Wenn wir nun die Grundfunktion f√ºr diesen Punkt aufrufen, wird der Punkt als fest betrachtet, da Y = -2 unter dem Gradientensegment liegt, das 1 entspricht. Pl√∂tzlich verwandelt sich der hohle Punkt (0,1) in einen festen Punkt.  Wir werden einen Block aus massivem Stein in der Luft h√§ngen lassen.  Dies kann mit jedem Punkt in der Funktion erfolgen, indem eine Zufallszahl von der Y-Koordinate des eingehenden Punkts addiert oder subtrahiert wird, bevor die Funktion ground_select aufgerufen wird.  Hier ist ein Bild der Funktion ground_select, das dies zeigt.  Vor dem Aufruf der Funktion ground_select wird der Wert im Intervall (-0,25, 0,25) zur Y-Koordinate jedes Punkts addiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f28/273/32e/f2827332ed068acf376b4b6cfbf0853d.jpg"></div><br>  Dies ist interessanter als eine flache Linie, aber der Erde nicht sehr √§hnlich, da sich jeder Punkt auf einen v√∂llig zuf√§lligen Wert bewegt, wodurch ein chaotisches Muster entsteht.  Wenn wir jedoch eine kontinuierliche Zufallsfunktion verwenden, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fraktal</a> aus der <b>ANL-</b> Bibliothek, erhalten wir anstelle eines Zufallsmusters etwas Steuerbareres.  Lassen Sie uns deshalb ein Fraktal mit der Erdebene verbinden und sehen, was passiert. <br><br><pre> Terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 6, Frequenz = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", niedrig = 0, hoch = 1, schwelle = 0,5, control = "ground_perturb"}
 }}
</pre><br>  Es gibt einige bemerkenswerte Aspekte.  Zuerst definieren wir das Fraktal-Modul und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verketten</a> es mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ScaleOffset-</a> Modul.  Das ScaleOffset-Modul skaliert die fraktalen Ausgabewerte auf eine bequemere Ebene.  Ein Teil des Reliefs kann bergig sein und einen gr√∂√üeren Ma√üstab erfordern, und ein anderer Teil - flacher und kleiner.  Wir werden sp√§ter √ºber verschiedene Gel√§ndetypen sprechen, aber im Moment werden wir sie zur Demonstration verwenden.  Die Ausgabewerte der Funktion ergeben nun folgendes Bild: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/56e/b55/8ca56eb55e7febec86f3dd80fcea2d0e.jpg"></div><br>  Das ist interessanter als nur zuf√§lliges Rauschen, oder?  Zumindest sieht es eher nach Land aus, obwohl ein Teil der Landschaft ungew√∂hnlich aussieht und die fliegenden Inseln v√∂llig seltsam sind.  Der Grund daf√ºr war, dass jeder einzelne Punkt der Ausgabekarte zuf√§llig um einen anderen vom Fraktal bestimmten Wert verschoben wird.  Um dies zu veranschaulichen, zeigen Sie die fraktale Ausgabe, die die Verzerrung ausf√ºhrt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/67d/b62/fbd67db6235a14fdf6d734d2ac73f560.jpg"></div><br>  Im obigen Bild haben alle schwarzen Punkte einen Wert von -0,25 und alle wei√üen Punkte einen Wert von 0,25.  Das hei√üt, wenn das Fraktal schwarz ist, wird der entsprechende Punkt der Erdfunktion um 0,25 "nach unten" verschoben.  (0,25 bedeutet 1/4 des Bildschirms.) Da ein Punkt leicht verschoben werden kann und der andere Punkt dar√ºber im Raum st√§rker verschoben werden kann, besteht die M√∂glichkeit, dass Felsen und fliegende Inseln hervorstehen.  Die Vorspr√ºnge in der Natur sind im Gegensatz zu den fliegenden Inseln ganz nat√ºrlich.  (Es sei denn, wir sind im Film "Avatar".) Wenn Ihr Spiel eine so fantastische Landschaft ben√∂tigt, ist es gro√üartig, aber wenn Sie ein realistischeres Modell ben√∂tigen, m√ºssen wir die Fraktalfunktion ein wenig anpassen.  Gl√ºcklicherweise kann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ScaleDomain-</a> Funktion dies tun. <br><br>  Wir m√∂chten, dass sich die Funktion wie eine H√∂henkartenfunktion verh√§lt.  Stellen Sie sich eine 2D-H√∂henkarte vor, bei der jeder Punkt auf der Karte die H√∂he eines Punkts im Raster von Rasterpunkten darstellt, die nach oben oder unten angehoben werden.  Wei√üwerte der Karte zeigen hohe H√ºgel, schwarz-niedrige T√§ler an.  Wir brauchen ein √§hnliches Verhalten, aber um es zu erreichen, m√ºssen wir im Wesentlichen eine der Dimensionen loswerden.  Bei einer H√∂henkarte erstellen wir eine 3D-H√∂he aus einer 2D-H√∂henkarte.  In √§hnlicher Weise ben√∂tigen wir im Fall von 2D-Gel√§nde eine 1D-H√∂henkarte.  Nachdem alle Punkte eines Fraktals mit derselben Y-Koordinate denselben Wert haben, k√∂nnen wir alle Punkte mit derselben X-Koordinate um denselben Betrag verschieben, sodass die fliegenden Inseln verschwinden.  Dazu k√∂nnen Sie ScaleDomain verwenden und den Skalierungskoeffizienten zur√ºcksetzen.  Das hei√üt, bevor wir die Funktion ground_shape_fractal aufrufen, rufen wir ground_scale_y auf, um die y-Koordinate auf 0 zu setzen. Dies stellt sicher, dass der Y-Wert die Ausgabe des Fraktals nicht beeinflusst und es im Wesentlichen in eine 1D-Rauschfunktion umwandelt.  Dazu nehmen wir folgende √Ñnderungen vor: <br><br><pre> Terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 6, Frequenz = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale_y"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", niedrig = 0, hoch = 1, schwelle = 0,5, control = "ground_perturb"}
 }}
</pre><br>  Wir werden die ScaleDomain-Funktion mit ground_scale verketten und dann die urspr√ºnglichen ground_perturb-Daten so √§ndern, dass sie eine ScaleDomain-Funktion sind.  Dies wird das Fraktal ver√§ndern, das die Erde verdr√§ngt und in so etwas verwandelt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/e79/4dc/ca7e794dc19c6922c6278cfdf3437caf.jpg"></div><br>  Wenn wir uns nun die Ausgabe ansehen, erhalten wir das Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/31a/5d6/bb231a5d6c2e0cfb1f8181ba6de1dc61.jpg"></div><br>  Viel besser.  Fliegende Inseln sind vollst√§ndig verschwunden, und das Relief √§hnelt eher Bergen und H√ºgeln.  Leider haben wir Vorspr√ºnge und Klippen verloren.  Jetzt ist die ganze Erde durchgehend und abfallend.  Wenn Sie m√∂chten, k√∂nnen Sie dies auf verschiedene Arten beheben. <br><br>  Erstens k√∂nnen Sie eine andere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TranslateDomain-</a> Funktion verwenden, die mit einer anderen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fractal-</a> Funktion gekoppelt ist.  Wenn wir eine kleine Menge fraktaler Turbulenzen auf die X-Richtung anwenden, k√∂nnen wir die Kanten und Oberfl√§chen der Berge leicht verzerren, und dies wird wahrscheinlich ausreichen, um Abgr√ºnde und Felsvorspr√ºnge zu bilden.  Schauen wir es uns in Aktion an. <br><br><pre> Terraintree =
 {
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "ground_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 6, Frequenz = 2},
	 {name = "ground_scale", type = "scaleoffset", scale = 0.5, offset = 0, source = "ground_shape_fractal"},
	 {name = "ground_scale_y", type = "scaledomain", source = "ground_scale", scaley = 0},
	 {name = "ground_perturb", type = "translateomain", source = "ground_gradient", ty = "ground_scale_y"},
	 {name = "ground_overhang_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 6, Frequenz = 2},
	 {name = "ground_overhang_scale", type = "scaleoffset", source = "ground_overhang_fractal", scale = 0.2, offset = 0},
	 {name = "ground_overhang_perturb", type = "translateomain", source = "ground_perturb", tx = "ground_overhang_scale"},<font></font>
	<font></font>
	 {name = "ground_select", type = "select", niedrig = 0, hoch = 1, schwelle = 0,5, control = "ground_overhang_perturb"}
 }}
</pre><br>  Und hier ist das Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c3/09f/c4e/4c309fc4e22125fa2083d5bf33e4dc20.jpg"></div><br>  Der zweite Weg: Sie k√∂nnen den <b>scaley-</b> Parameter der Funktion <b>ground_scale_y</b> einfach <b>auf einen</b> Wert gr√∂√üer als 0 setzen. Wenn Sie eine kleine Skala in Y <b>belassen</b> , erhalten Sie einen Bruchteil der Variabilit√§t. <b>Je</b> gr√∂√üer die Skala, <b>desto</b> st√§rker √§hnelt das Relief der vorherigen Version ohne Skalierung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/f3f/746/225f3f7462f1c78bb48a3603363643aa.jpg"></div><br>  Die Ergebnisse sehen viel interessanter aus als gew√∂hnliche abfallende Berge.  Egal wie interessant sie auch sein m√∂gen, der Spieler wird sich immer noch langweilen, wenn er das Relief mit demselben Muster erkundet, das sich √ºber viele Kilometer erstreckt.  Dar√ºber hinaus w√§re eine solche Erleichterung sehr unrealistisch.  In der realen Welt gibt es viele Schwankungen, die das Gel√§nde interessanter machen.  Mal sehen, was getan werden kann, um die Welt vielf√§ltiger zu machen. <br><br>  Im vorherigen Codebeispiel sehen Sie ein bestimmtes Muster.  Wir haben eine Gradientenfunktion, die durch Funktionen gesteuert wird, die der Erde eine Form geben. Danach wird eine st√ºckweise definierte Funktion angewendet und die Erde wird voll.  Das hei√üt, es wird logischer sein, das Relief im Stadium der Gestaltung der Erde zu erschweren.  Anstelle einer fraktalen Verschiebung entlang Y und einer weiteren Verschiebung entlang X k√∂nnen wir den erforderlichen Komplexit√§tsgrad erreichen (unter Ber√ºcksichtigung der Leistung: Jedes Fraktal erfordert zus√§tzliche Rechenkosten, daher m√ºssen wir versuchen, konservativ zu sein.) Wir k√∂nnen die Formen der Erde angeben, bei denen es sich um Berge und Ausl√§ufer handelt , flaches Tiefland, √ñdland usw. und verwenden Sie die Ausgabe der verschiedenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Select-</a> Funktionen, die mit niederfrequenten Fraktalen verkettet sind, um Bereiche jedes Typs zu skizzieren.  Lassen Sie uns sehen, wie Sie verschiedene Gel√§ndetypen implementieren k√∂nnen. <br><br>  Um das Prinzip zu veranschaulichen, unterscheiden wir drei Arten von Reliefs: Hochebenen (glatte abfallende H√ºgel), Berge und Tiefland (meist flach).  Um zwischen ihnen zu wechseln, verwenden wir ein auf Auswahl basierendes System und kombinieren sie zu einer komplexen Leinwand.  Also los geht's ... <br><br>  <b>Ausl√§ufer:</b> <br><br>  Mit ihnen ist alles einfach.  Wir k√∂nnen das oben verwendete Schema verwenden, die Amplitude der H√ºgel leicht verringern und sie vielleicht sogar subtraktiver als additiv machen.  die durchschnittlichen H√∂hen zu senken.  Wir k√∂nnen auch die Oktavzahl reduzieren, um sie zu gl√§tten. <br><br><pre> {name = "lowland_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 2, Frequenz = 1},
 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0,2, offset = -0,25},
 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
 {name = "lowland_terrain", type = "translateomain", source = "ground_gradient", ty = "lowland_y_scale"},
</pre><br>  <b>Hochland:</b> <br><br>  Auch bei ihnen ist alles einfach.  (Tats√§chlich ist keiner dieser Gel√§ndetypen schwierig.) Wir verwenden jedoch eine andere Basis, um die H√ºgel wie D√ºnen aussehen zu lassen. <br><br><pre> {name = "highland_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.RIDGEDMULTI, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 2, Frequenz = 2},
 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0,45, offset = 0},
 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
 {name = "highland_terrain", type = "translateomain", source = "ground_gradient", ty = "highland_y_scale"},
</pre><br>  <b>Berge:</b> <br><br><pre> {name = "Mountain_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.BILLOW, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 4, Frequenz = 1},
 {name = "hill_autocorrect", type = "autocorrect", source = "hill_shape_fractal", niedrig = 0, hoch = 1},
 {name = "hill_scale", type = "scaleoffset", source = "hill_autocorrect", scale = 0,75, offset = 0,25},
 {name = "hill_y_scale", type = "scaledomain", source = "hill_scale", scaley = 0.1},
 {name = "hill_terrain", type = "translateomain", source = "ground_gradient", ty = "hill_y_scale"},
</pre><br>  Nat√ºrlich k√∂nnen Sie diesen Prozess noch kreativer angehen, aber im Allgemeinen wird das Muster so sein.  Wir heben die Eigenschaften des Relieftyps hervor und w√§hlen f√ºr sie Rauschfunktionen aus.  F√ºr all dies gelten die gleichen Grunds√§tze;  Die Hauptunterschiede sind die Skalierung.  Um sie miteinander zu verbinden, bereiten wir jetzt zus√§tzliche Fraktale vor, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswahlfunktion</a> steuern.  Dann verketten wir Select-Module, um das gesamte Terrain zu generieren. <br><br><pre> {name = "Terrain_Type_Fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 3, Frequenz = 0,5},
 {name = "Terrain_Autokorrektur", Typ = "Autokorrektur", Quelle = "Terrain_Typ_Fractal", niedrig = 0, hoch = 1},
 {name = "Terrain_Type_Cache", Type = "Cache", Source = "Terrain_Autocorrect"},
 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "hill_terrain", control = "Terrain_type_cache", Schwelle = 0,55, Falloff = 0,15},
 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "Terrain_type_cache", Schwelle = 0,25, Falloff = 0,15},
</pre><br>  Hier definieren wir drei Haupttypen von Gel√§nde: Tiefland, Hochland und Berge.  Wir verwenden ein Fraktal, um eines davon auszuw√§hlen, so dass es nat√ºrliche √úberg√§nge gibt (Tiefland-&gt; Hochland-&gt; Berge).  Dann verwenden wir ein anderes Fraktal, um √ñdland zuf√§llig in die Karte einzuf√ºgen.  So sieht die fertige Modulkette aus: <br><br><pre> Terraintree =
 {
	 {name = "lowland_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 2, Frequenz = 1},
	 {name = "lowland_autocorrect", type = "autocorrect", source = "lowland_shape_fractal", low = 0, high = 1},
	 {name = "lowland_scale", type = "scaleoffset", source = "lowland_autocorrect", scale = 0,2, offset = -0,25},
	 {name = "lowland_y_scale", type = "scaledomain", source = "lowland_scale", scaley = 0},
	 {name = "lowland_terrain", type = "translateomain", source = "ground_gradient", ty = "lowland_y_scale"},
	 {name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},
	 {name = "highland_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.RIDGEDMULTI, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 2, Frequenz = 2},
	 {name = "highland_autocorrect", type = "autocorrect", source = "highland_shape_fractal", low = 0, high = 1},
	 {name = "highland_scale", type = "scaleoffset", source = "highland_autocorrect", scale = 0,45, offset = 0},
	 {name = "highland_y_scale", type = "scaledomain", source = "highland_scale", scaley = 0},
	 {name = "highland_terrain", type = "translateomain", source = "ground_gradient", ty = "highland_y_scale"},<font></font>
<font></font>
	 {name = "Mountain_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.BILLOW, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 4, Frequenz = 1},
	 {name = "hill_autocorrect", type = "autocorrect", source = "hill_shape_fractal", niedrig = 0, hoch = 1},
	 {name = "hill_scale", type = "scaleoffset", source = "hill_autocorrect", scale = 0,75, offset = 0,25},
	 {name = "hill_y_scale", type = "scaledomain", source = "hill_scale", scaley = 0.1},
	 {name = "hill_terrain", type = "translateomain", source = "ground_gradient", ty = "hill_y_scale"},<font></font>
<font></font>
	 {name = "Terrain_Type_Fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptype = anl.QUINTIC, Oktaven = 3, Frequenz = 0,5},
	 {name = "Terrain_Autokorrektur", Typ = "Autokorrektur", Quelle = "Terrain_Typ_Fractal", niedrig = 0, hoch = 1},
	 {name = "Terrain_Type_Cache", Type = "Cache", Source = "Terrain_Autocorrect"},
	 {name = "highland_mountain_select", type = "select", low = "highland_terrain", high = "hill_terrain", control = "Terrain_type_cache", Schwelle = 0,55, Falloff = 0,15},
	 {name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "Terrain_type_cache", Schwelle = 0,25, Falloff = 0,15},
	 {name = "ground_select", type = "select", niedrig = 0, hoch = 1, schwelle = 0,5, control = "highland_lowland_select"}
 }}
</pre><br>  Hier einige Beispiele f√ºr die daraus resultierenden Reliefs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/60f/afe/4c460fafe39eec4680ac6eb3c341beef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/241/869/9c8241869337938b628d0b9a53a3e756.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/538/67a/f3a/53867af3a00abb26d5b0f32f5f728694.jpg"></div><br>  M√∂glicherweise stellen Sie fest, dass eine ziemlich hohe Variabilit√§t erzielt wird.  An einigen Stellen erscheinen hoch aufragende, zerbrochene Berge, an anderen gibt es glatt abfallende Ebenen.  Jetzt m√ºssen wir H√∂hlen hinzuf√ºgen, damit wir die Wunder der Unterwelt erkunden k√∂nnen. <br><br>  F√ºr H√∂hlen verwende ich das multiplikative System, das auf <b>ground_select</b> angewendet <b>wird</b> .  Das hei√üt, ich erstelle eine Funktion, die 1 oder 0 ausgibt, und multipliziere sie mit der Ausgabe von <b>ground_select</b> .  Dank dessen wird jeder Punkt der Funktion hohl, f√ºr den der Wert der Funktion der H√∂hlen 0 ist. Das hei√üt, wo ich die H√∂hle erhalten m√∂chte, sollte die Funktion der H√∂hlen 0 zur√ºckgeben, und wo die H√∂hle nicht sein sollte, sollte die Funktion 1 sein. Was die Form betrifft H√∂hlen, ich m√∂chte ein H√∂hlensystem aufbauen, das auf dem 1-Oktaven- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ridged-Multifraktal basiert</a> . <br><br><pre> {name = "H√∂hle_Form", Typ = "Fraktal", Fraktaltyp = anl.RIDGEDMULTI, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 1, Frequenz = 2},
</pre><br>  Das Ergebnis ist ungef√§hr so: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/bf0/297/31cbf02975f1852907bb3a0f24ffd43a.jpg"></div><br>  Wenn wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswahlfunktion</a> wie beim Erdgradienten als st√ºckweise definierte Funktion anwenden und sie so implementieren, dass der untere Teil der Auswahlschwelle 1 ist (es gibt keine H√∂hle) und der obere Teil 0 ist (es gibt eine H√∂hle), sieht das Ergebnis ungef√§hr so ‚Äã‚Äãaus :: <br><br><pre> {name = "H√∂hle_Form", Typ = "Fraktal", Fraktaltyp = anl.RIDGEDMULTI, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 1, Frequenz = 2},
 {name = "height_select", type = "select", niedrig = 1, hoch = 0, control = "h√∂hlenform", schwelle = 0,8, falloff = 0},
</pre><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/55a/c47/1d855ac477dd48ba59d20ed30d89bde6.jpg"></div><br>  Nat√ºrlich sieht es ziemlich glatt aus, also f√ºgen Sie etwas fraktales Rauschen hinzu, um den Bereich zu verzerren. <br><br><pre> {name = "H√∂hle_Form", Typ = "Fraktal", Fraktaltyp = anl.RIDGEDMULTI, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 1, Frequenz = 2},
 {name = "H√∂hle_Auswahl", Typ = "Auswahl", niedrig = 1, hoch = 0, Kontrolle = "H√∂hlenform", Schwelle = 0,8, Abfall = 0},
 {name = "H√∂hle_Turburb_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 6, Frequenz = 3},
 {name = "height_perturb_scale", type = "scaleoffset", source = "height_perturb_fractal", scale = 0,25, offset = 0},<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "H√∂hle_Turburb", Typ = "√úbersetzte Dom√§ne", Quelle = "H√∂hlenauswahl", tx = "H√∂hle_Turburb_Skala"},</font></font><font></font>
</pre><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ec/deb/4fa/0ecdeb4faf32eea11c05a7a76b7c6225.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies macht die H√∂hlen etwas laut und macht sie nicht so glatt. </font><font style="vertical-align: inherit;">Mal sehen, was passiert, wenn Sie die H√∂hlen auf das Relief anwenden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d34/974/278/d34974278435e239ad7eb9193adc9672.jpg"></div><br><font style="vertical-align: inherit;"><b><font style="vertical-align: inherit;">Durch</font></b><font style="vertical-align: inherit;"> Experimentieren mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schwellenwert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cav_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen wir die H√∂hlen d√ºnner oder dicker machen. Aber die Hauptsache, die wir versuchen m√ºssen, ist sicherzustellen, dass die H√∂hlen nicht so gro√üe Fragmente des Oberfl√§chenreliefs wegfressen. Dazu k√∂nnen wir zur Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select zur√ºckkehren</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die, wie wir uns erinnern, die letzte Relieffunktion ist, die den Gradienten der Erde verzerrt. Was bei dieser Funktion n√ºtzlich ist, ist, dass es sich immer noch um einen Gradienten handelt, der den Wert erh√∂ht, wenn sich die Funktion in den Boden vertieft. Wir k√∂nnen den Gradienten verwenden, um die Funktion der H√∂hlen zu schw√§chen, so dass die H√∂hlen zunehmen, wenn sie tiefer in den Boden eindringen. Zum Gl√ºck kann diese D√§mpfung einfach durch Multiplikation der Ausgabe der Funktion </font><b><font style="vertical-align: inherit;">highland_lowland_select erreicht</font></b><font style="vertical-align: inherit;"> werden</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an die Ausgabe von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cav_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und √ºbergeben Sie das Ergebnis dann an den Rest der Funktionskette. Als n√§chstes werden wir hier eine wichtige √Ñnderung vornehmen - wir werden die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cache-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion hinzuf√ºgen </font><font style="vertical-align: inherit;">. Die Caching-Funktion speichert das Ergebnis der Funktion f√ºr eine bestimmte eingehende Koordinate. Wenn die Funktion wiederholt mit derselben Koordinate aufgerufen wird, gibt sie eine zwischengespeicherte Kopie zur√ºck und berechnet das Ergebnis nicht erneut. Dies ist n√ºtzlich in Situationen, in denen eine komplexe Funktion ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highland_lowland_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in einer Funktionskette mehrmals aufgerufen wird. Ohne Cache wird bei jedem Aufruf die gesamte Kette einer komplexen Funktion neu berechnet. Um den Cache hinzuzuf√ºgen, m√ºssen wir zuerst die folgenden √Ñnderungen vornehmen:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "highland_lowland_select", type = "select", low = "lowland_terrain", high = "highland_mountain_select", control = "Terrain_type_cache", Schwelle = 0,25, Falloff = 0,15},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "highland_lowland_select_cache", type = "cache", source = "highland_lowland_select"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
{name = "ground_select", type = "select", niedrig = 0, hoch = 1, Schwelle = 0,5, control = "highland_lowland_select_cache"},</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir Cache hinzugef√ºgt und die Eingabe dann auf </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ground_select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umgeleitet, </font><font style="vertical-align: inherit;">sodass sie aus dem Cache und nicht direkt aus der Funktion √ºbernommen wurde. </font><font style="vertical-align: inherit;">Dann k√∂nnen wir den Code der H√∂hlen √§ndern, um die D√§mpfung zu erh√∂hen:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{name = "H√∂hle_Form", Typ = "Fraktal", Fraktaltyp = anl.RIDGEDMULTI, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 1, Frequenz = 4},</font></font><font></font>
{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst haben wir die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bias-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion hinzugef√ºgt </font><font style="vertical-align: inherit;">. Dies dient der Vereinfachung, da hiermit das Intervall der Gradientend√§mpfungsfunktion angepasst werden kann. Dann wird die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cav_shape_attenuate hinzugef√ºgt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei der es sich um einen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kombinierer vom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">anl :: MULT handelt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie multipliziert den Gradienten mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cav_shape</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Ergebnis dieser Operation wird dann an die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cav_perturb √ºbergeben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Ergebnis sieht ungef√§hr so ‚Äã‚Äãaus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f8/55d/fd3/8f855dfd376c5d8049a075d28066f72c.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir sehen, dass n√§her an der Erdoberfl√§che d√ºnner geworden sind. </font><font style="vertical-align: inherit;">(Achten Sie nicht ganz nach oben, dies ist nur ein Artefakt negativer Gradientenwerte, es wirkt sich nicht auf die fertigen H√∂hlen aus. Wenn dies zu einem Problem wird - sagen wir, wenn wir diese Funktion f√ºr etwas anderes verwenden, k√∂nnen wir den Gradienten auf das Intervall (0, 1).) Es ist ein wenig schwer zu sehen, wie dies in Bezug auf das Gel√§nde funktioniert. Lassen Sie uns also weitermachen und alles zusammenf√ºgen, um zu sehen, was passiert. </font><font style="vertical-align: inherit;">Hier ist die gesamte Funktionskette, die wir bisher erstellt haben.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraintree =
</font></font> {<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_gradient", type = "gradient", x1 = 0, x2 = 0, y1 = 0, y2 = 1},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "lowland_shape_fractal", Typ = "Fraktal", Fraktaltyp = anl.BILLOW, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 2, Frequenz = 0,25},</font></font><font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_shape", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape", source_1="cave_attenuate_bias"},<font></font>
	{name="cave_perturb_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=6, frequency=3},<font></font>
	{name="cave_perturb_scale", type="scaleoffset", source="cave_perturb_fractal", scale=0.5, offset=0},<font></font>
	{name="cave_perturb", type="translatedomain", source="cave_shape_attenuate", tx="cave_perturb_scale"},<font></font>
	{name="cave_select", type="select", low=1, high=0, control="cave_perturb", threshold=0.48, falloff=0},<font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "height_select", source_1 = "ground_select"}</font></font><font></font>
 }}
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier sind Beispiele f√ºr zuf√§llige Karten, die von dieser Funktion abgeleitet wurden: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f8/1a5/ca8/9f81a5ca8f1b739c03721b6a5ba280a5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/5ec/b69/c865ecb69a1701a1b757535f289c6c0a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a82/332/1e3/a823321e389de00947e695424497f2e9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt sieht alles ziemlich gut aus. Alle H√∂hlen sind ziemlich gro√üe H√∂hlen tief unter der Erde, aber n√§her an der Oberfl√§che verwandeln sie sich normalerweise in kleine Tunnel. Dies tr√§gt dazu bei, eine mysteri√∂se Atmosph√§re zu schaffen. Wenn Sie die Oberfl√§che erkunden, finden Sie einen kleinen Eingang zur H√∂hle. Wohin geht sie? Wie tief erstreckt es sich? Wir k√∂nnen das nicht wissen, aber w√§hrend des Studiums beginnt es sich auszudehnen und verwandelt sich in ein ausgedehntes System von H√∂hlen voller Dunkelheit und Gefahren. Und Beute nat√ºrlich. Es gibt immer viel Beute. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen dieses System auf viele verschiedene Arten √§ndern, um unterschiedliche Ergebnisse zu erzielen. Wir k√∂nnen die Schwellenparameter f√ºr </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂hle_auswahl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Parameter f√ºr </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂hle_attenuate_bias √§ndern</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font><b><font style="vertical-align: inherit;">H√∂hle_attenuate_bias</font></b><font style="vertical-align: inherit;"> ersetzen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Funktionen, um das Gradientenintervall an andere Werte anzupassen, die Ihren Anforderungen besser entsprechen. Sie k√∂nnen auch ein weiteres Fraktal hinzuf√ºgen, das das H√∂hlensystem entlang der Y-Achse verzerrt, um die M√∂glichkeit unnat√ºrlich glatter Tunnel entlang der X-Achse auszuschlie√üen (verursacht durch die Tatsache, dass die H√∂hlenform nur entlang der X-Achse verzerrt ist). Sie k√∂nnen auch ein neues Fraktal als zus√§tzliche D√§mpfungsquelle hinzuf√ºgen und eine dritte Quelle f√ºr </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cav_shape_attenuate angeben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die D√§mpfung basierend auf Regionen skaliert, sodass H√∂hlen in einigen Gebieten dichter sind (z. B. in den Bergen) und in anderen seltener oder vollst√§ndig fehlen. Diese regionale Auswahl kann √ºber die Funktion </font><b><font style="vertical-align: inherit;">Terrain_Type_Fractal erstellt</font></b><font style="vertical-align: inherit;"> werden</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu wissen, wo sich die Berggebiete befinden. Es kommt darauf an, nur dar√ºber nachzudenken, was Sie wollen, herauszufinden, welche Auswirkungen verschiedene Funktionen auf die Ausgabe haben, und mit den Parametern zu experimentieren, bis Sie das gew√ºnschte Ergebnis erhalten. Dies ist keine exakte Wissenschaft, und oft kann der gew√ºnschte Effekt auf verschiedene Weise erreicht werden.</font></font><br><br><h2>  Nachteile </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Gel√§ndegenerierungsmethode hat Nachteile. </font><font style="vertical-align: inherit;">Der Ger√§uscherzeugungsprozess kann sehr langsam sein. </font><font style="vertical-align: inherit;">Es ist wichtig, die Anzahl der Fraktale, die Anzahl der Oktaven der von Ihnen verwendeten Fraktale und andere langsame Operationen nach M√∂glichkeit zu reduzieren. </font><font style="vertical-align: inherit;">Versuchen Sie, Fraktale wiederholt zu verwenden und alle Funktionen, die mehrmals aufgerufen werden, zwischenzuspeichern. </font><font style="vertical-align: inherit;">In diesem Beispiel habe ich frei Fraktale verwendet und f√ºr jeden der drei Relieftypen eines erstellt. </font><font style="vertical-align: inherit;">Wenn </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich ScaleOffset verwende</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Intervalle zu √§ndern und ein Fraktal als Grundlage f√ºr alle zu verwenden, w√ºrde ich viel Prozessorzeit sparen. </font><font style="vertical-align: inherit;">In 2D ist nicht alles so schlecht, aber wenn Sie zu 3D gelangen und versuchen, die Datenmengen zu vergleichen, erh√∂ht sich die Verarbeitungszeit erheblich.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehe zu 3D </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All dies ist gro√üartig, wenn Sie ein Spiel wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terraria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">King Arthur's Gold</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellen </font><font style="vertical-align: inherit;">, aber was ist, wenn Sie etwas wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minecraft</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Infiniminer</font></a><font style="vertical-align: inherit;"> ben√∂tigen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Welche √Ñnderungen m√ºssen wir an der Funktionskette vornehmen? In der Tat gibt es nicht viele. Die oben gezeigte Funktion funktioniert fast ohne √Ñnderung f√ºr 3D-Relief. Es reicht aus, wenn Sie das 3D-Volumen mit den 3D-Variationen des Generators vergleichen und die Y-Achse mit der vertikalen Achse des Volumens und nicht mit dem 2D-Bereich vergleichen. Es wird jedoch eine √Ñnderung erforderlich sein, n√§mlich eine M√∂glichkeit, die H√∂hlen zu verwirklichen. Wie Sie gesehen haben, eignet sich Ridged Multifractal hervorragend f√ºr ein 2D-H√∂hlensystem, aber in 3D werden viele gekr√ºmmte Muscheln und keine Tunnel herausgeschnitten, und die Wirkung ist falsch. Das hei√üt, in 3D m√ºssen zwei fraktale Formen von H√∂hlen angegeben werden, beide sind 1-Oktaven-Ridged-Multifractal-Rauschen, jedoch mit unterschiedlichen Samen. Setzen Sie sie mit Select auf 1 oder 0 und multiplizieren Sie sie. So erscheint am Schnittpunkt der Fraktale eine H√∂hle,und alles andere wird solide bleiben, und das Aussehen der Tunnel wird nat√ºrlicher als die Verwendung eines einzelnen Fraktals.</font></font><br><br><pre>terraintree3d=
 {<font></font>
	{name="ground_gradient", type="gradient", x1=0, x2=0, y1=0, y2=1},<font></font>
	<font></font>
	{name="lowland_shape_fractal", type="fractal", fractaltype=anl.BILLOW, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=2, frequency=0.25},<font></font>
	{name="lowland_autocorrect", type="autocorrect", source="lowland_shape_fractal", low=0, high=1},<font></font>
	{name="lowland_scale", type="scaleoffset", source="lowland_autocorrect", scale=0.125, offset=-0.45},<font></font>
	{name="lowland_y_scale", type="scaledomain", source="lowland_scale", scaley=0},<font></font>
	{name="lowland_terrain", type="translatedomain", source="ground_gradient", ty="lowland_y_scale"},<font></font>
	<font></font>
	{name="highland_shape_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=4, frequency=2},<font></font>
	{name="highland_autocorrect", type="autocorrect", source="highland_shape_fractal", low=-1, high=1},<font></font>
	{name="highland_scale", type="scaleoffset", source="highland_autocorrect", scale=0.25, offset=0},<font></font>
	{name="highland_y_scale", type="scaledomain", source="highland_scale", scaley=0},<font></font>
	{name="highland_terrain", type="translatedomain", source="ground_gradient", ty="highland_y_scale"},<font></font>
<font></font>
	{name="mountain_shape_fractal", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=8, frequency=1},<font></font>
	{name="mountain_autocorrect", type="autocorrect", source="mountain_shape_fractal", low=-1, high=1},<font></font>
	{name="mountain_scale", type="scaleoffset", source="mountain_autocorrect", scale=0.45, offset=0.15},<font></font>
	{name="mountain_y_scale", type="scaledomain", source="mountain_scale", scaley=0.25},<font></font>
	{name="mountain_terrain", type="translatedomain", source="ground_gradient", ty="mountain_y_scale"},<font></font>
<font></font>
	{name="terrain_type_fractal", type="fractal", fractaltype=anl.FBM, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=3, frequency=0.125},<font></font>
	{name="terrain_autocorrect", type="autocorrect", source="terrain_type_fractal", low=0, high=1},<font></font>
	{name="terrain_type_y_scale", type="scaledomain", source="terrain_autocorrect", scaley=0},<font></font>
	{name="terrain_type_cache", type="cache", source="terrain_type_y_scale"},<font></font>
	{name="highland_mountain_select", type="select", low="highland_terrain", high="mountain_terrain", control="terrain_type_cache", threshold=0.55, falloff=0.2},<font></font>
	{name="highland_lowland_select", type="select", low="lowland_terrain", high="highland_mountain_select", control="terrain_type_cache", threshold=0.25, falloff=0.15},<font></font>
	{name="highland_lowland_select_cache", type="cache", source="highland_lowland_select"},<font></font>
	{name="ground_select", type="select", low=0, high=1, threshold=0.5, control="highland_lowland_select_cache"},<font></font>
	<font></font>
	{name="cave_attenuate_bias", type="bias", source="highland_lowland_select_cache", bias=0.45},<font></font>
	{name="cave_shape1", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape2", type="fractal", fractaltype=anl.RIDGEDMULTI, basistype=anl.GRADIENT, interptype=anl.QUINTIC, octaves=1, frequency=4},<font></font>
	{name="cave_shape_attenuate", type="combiner", operation=anl.MULT, source_0="cave_shape1", source_1="cave_attenuate_bias", source_2="cave_shape2"},             <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "H√∂hle_Turburb_fractal", Typ = "Fraktal", Fraktaltyp = anl.FBM, Basistyp = anl.GRADIENT, Interptyp = anl.QUINTIC, Oktaven = 6, Frequenz = 3},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "height_perturb_scale", type = "scaleoffset", source = "height_perturb_fractal", scale = 0.5, offset = 0},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "H√∂hle_Turburb", Typ = "√úbersetzte Dom√§ne", Quelle = "H√∂hle_Schaffen_Matte", tx = "H√∂hle_Turburb_Skala"},</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "H√∂hle_Auswahl", Typ = "Auswahl", niedrig = 1, hoch = 0, Kontrolle = "H√∂hle_St√∂rung", Schwelle = 0,48, Abfall = 0},</font></font><font></font>
	<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	{name = "ground_cave_multiply", type = "combiner", operation = anl.MULT, source_0 = "height_select", source_1 = "ground_select"}</font></font><font></font>
 }}
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beispiele f√ºr Ergebnisse: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/484/3fa/8e9/4843fa8e95e46162345f36edcf767fbe.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/671/848/b91671848dac9a42f371d549adf07181.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass einige Einstellungen angepasst werden m√ºssen. </font><font style="vertical-align: inherit;">Es kann sich lohnen, die D√§mpfung zu verringern oder die H√∂hlen d√ºnner zu machen und die Anzahl der Oktaven im Fraktal des Reliefs zu verringern, damit das Relief glatter wird usw. Ich wiederhole, alles h√§ngt davon ab, welches Ergebnis Sie erzielen m√∂chten.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472574/">https://habr.com/ru/post/de472574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472562/index.html">Finanztrends: Gro√üe Unternehmen brauchen immer mehr IT-Experten</a></li>
<li><a href="../de472566/index.html">Die pers√∂nliche H√∂lle des Schriftstellers Fraerman oder die Geschichte der ersten Liebe</a></li>
<li><a href="../de472568/index.html">Apache Ignite Zero Deployment: genau Null?</a></li>
<li><a href="../de472570/index.html">Intel Xeon W Big Update</a></li>
<li><a href="../de472572/index.html">DevOps und Chaos: Softwarebereitstellung in einer dezentralen Welt</a></li>
<li><a href="../de472576/index.html">XVI. Konferenz freier Softwareentwickler oder wo man kostenlose Mitwirkende bekommt</a></li>
<li><a href="../de472580/index.html">Enterprise Service Management: Warum das Service Management √ºber die IT hinaus erweitern?</a></li>
<li><a href="../de472582/index.html">Internet-Geschichte: Computer als Kommunikationsger√§t</a></li>
<li><a href="../de472586/index.html">Lautsprecheranalyse: Was ist drin und wie funktioniert es?</a></li>
<li><a href="../de472588/index.html">Alles, was Sie √ºber das R√ºckw√§rtspendel wissen wollten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>