<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïØÔ∏è üìÅ üëø "Efectos algebraicos" en el lenguaje humano ü§¢ üë®‚Äçüé® üë©üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Comentario del traductor: Esta es una traducci√≥n de un gran art√≠culo de Dan Abramov, un colaborador de React. Sus ejemplos est√°n escritos para JS, per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Efectos algebraicos" en el lenguaje humano</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470718/">  Comentario del traductor: Esta es una traducci√≥n de un gran art√≠culo de Dan Abramov, un colaborador de React.  Sus ejemplos est√°n escritos para JS, pero ser√°n igualmente claros para los desarrolladores en cualquier idioma.  La idea es com√∫n a todos. <br><br><h3>  ¬øHas o√≠do hablar de los efectos algebraicos? </h3><br><p>  Mis primeros intentos de descubrir qui√©nes son y por qu√© deber√≠an excitarme no tuvieron √©xito.  Encontr√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos PDF</a> , pero me confundieron a√∫n m√°s.  (Por alguna raz√≥n, me quedo dormido mientras leo art√≠culos acad√©micos). </p><br><p>  Pero mi colega Sebastian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">continu√≥</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llam√°ndolos</a> el modelo mental de algunas de las cosas que hacemos en React.  (Sebastian trabaja en el equipo React y propuso muchas ideas, incluyendo Hooks y Suspense.) En alg√∫n momento, se convirti√≥ en un meme local en el equipo React, y muchas de nuestras conversaciones terminaron con lo siguiente: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xb/xm/oi/xbxmoi1bn7whmzill63sq1yz1tw.jpeg"></div><br><p>  Result√≥ que los efectos algebraicos son un concepto genial, y no es tan aterrador como me pareci√≥ al principio despu√©s de leer estos archivos PDF.  Si solo usa React, no necesita saber nada sobre ellos, pero si usted, como yo, est√° interesado, siga leyendo. </p><a name="habracut"></a><br><p>  (Descargo de responsabilidad: no soy un investigador en el campo de los lenguajes de programaci√≥n y puede haber estropeado algo en mi explicaci√≥n. ¬°Entonces av√≠seme si me equivoco!) </p><br><h3>  Todav√≠a es temprano en la producci√≥n </h3><br><p> Los efectos algebraicos son actualmente un concepto experimental del campo de estudio de los lenguajes de programaci√≥n.  Esto significa que, a diferencia de <code>if</code> , <code>for</code> o incluso expresiones <code>async/await</code> , lo m√°s probable es que no pueda usarlas en este momento en producci√≥n.  Solo son compatibles con unos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pocos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">idiomas</a> que se crearon espec√≠ficamente para estudiar esta idea.  Hay avances en su implementaci√≥n en OCaml, que ... todav√≠a est√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso</a> .  En otras palabras, mire, pero no toque con las manos. </p><br><h3>  ¬øPor qu√© deber√≠a molestarme? </h3><br><p>  Imagine que est√° escribiendo c√≥digo usando <code>goto</code> , y alguien le est√° contando sobre la existencia de construcciones <code>if</code> y <code>for</code> .  O tal vez est√°s atrapado en un infierno de devoluci√≥n de llamada y alguien te muestra <code>async/await</code> .  Muy bien, ¬øno? </p><br><p>  Si usted es el tipo de persona a la que le gusta aprender innovaciones de programaci√≥n unos a√±os antes de que se ponga de moda, podr√≠a ser el momento de interesarse en los efectos algebraicos.  Aunque no es necesario.  As√≠ es como se habla de <code>async/await</code> en 1999. </p><br><h3>  Bueno, ¬øqu√© tipo de efectos son estos? </h3><br><p>  El nombre puede ser un poco confuso, pero la idea es simple.  Si est√° familiarizado con <code>try/catch</code> bloques <code>try/catch</code> , comprender√° r√°pidamente los efectos algebraicos. </p><br><p>  Recordemos <code>try/catch</code> .  Digamos que tiene una funci√≥n que arroja excepciones.  Quiz√°s haya varias llamadas anidadas entre este y el <code>catch</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'  '</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">",   : "</span></span>, err); }</code> </pre> <br><p>  Lanzamos una excepci√≥n dentro de <code>getName</code> , pero "aparece" a trav√©s de <code>makeFriends</code> hasta el <code>catch</code> m√°s cercano.  Esta es la propiedad principal de <code>try/catch</code> .  <strong>El c√≥digo intermedio no es necesario para preocuparse por el manejo de errores.</strong> </p><br><p>  A diferencia de los c√≥digos de error en lenguajes como C, al usar <code>try/catch</code> no tiene que pasar los errores manualmente a trav√©s de cada nivel intermedio para manejar el error en el nivel superior.  Las excepciones aparecen autom√°ticamente. </p><br><p>  ¬øQu√© tiene esto que ver con los efectos algebraicos? </p><br><p>  En el ejemplo anterior, tan pronto como veamos un error, no podremos continuar ejecutando el programa.  Cuando nos encontramos en un <code>catch</code> , la ejecuci√≥n normal del programa se detendr√°. </p><br><p>  Se acab√≥ todo.  Es muy tarde  Lo mejor que podemos hacer es recuperarnos del fracaso y quiz√°s de alguna manera repetir lo que est√°bamos haciendo, pero no podemos m√°gicamente "regresar" a donde est√°bamos y hacer otra cosa.  Y con efectos algebraicos, podemos. </p><br><p>  Este es un ejemplo escrito en un hipot√©tico dialecto de JavaScript (llam√©moslo ES2025 por diversi√≥n), que nos permite <em>seguir</em> trabajando despu√©s del <code>user.name</code> faltante. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  (Pido disculpas a todos los lectores de 2025 que buscan "ES2025" en Internet y entran en este art√≠culo. Si para entonces los efectos algebraicos se convirtieran en parte de JavaScript, ¬°me complacer√≠a actualizar el art√≠culo!) </p><br><p>  En lugar de <code>throw</code> usamos la palabra clave hipot√©tica <code>perform</code> .  Del mismo modo, en lugar de <code>try/catch</code> usamos el hipot√©tico <code>try/handle</code> .  La <strong>sintaxis</strong> exacta <strong>no importa aqu√≠</strong> : se me ocurri√≥ algo para ilustrar la idea. </p><br><p>  Entonces, ¬øqu√© est√° pasando aqu√≠?  Echemos un vistazo m√°s de cerca. </p><br><p>  En lugar de lanzar un error, llevamos <em>a cabo el efecto</em> .  As√≠ como podemos <em>lanzar</em> cualquier objeto, aqu√≠ podemos pasar alg√∫n valor para el <em>procesamiento</em> .  En este ejemplo, paso una cadena, pero puede ser un objeto o cualquier otro tipo de datos: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; }</code> </pre> <br><p>  Cuando lanzamos una excepci√≥n, el motor busca el controlador <code>try/catch</code> m√°s cercano en la pila de llamadas.  De manera similar, cuando ejecutamos un <em>efecto</em> , el motor buscar√° el <code>try/handle</code> efecto de <code>try/handle</code> m√°s cercano en la parte superior de la pila: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br><p>  Este efecto nos permite decidir c√≥mo manejar la situaci√≥n cuando no se especifica el nombre.  Nuevo aqu√≠ (en comparaci√≥n con las excepciones) es el <code>resume with</code> hipot√©tico <code>resume with</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  Esto es algo que no puedes hacer con <code>try/catch</code> .  Nos permite <strong>volver a donde realizamos el efecto y pasar algo del controlador</strong> .  : -O </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// 1.     name = perform 'ask_name'; // 4. ...     (name   ' ') } return name; } // ... try { makeFriends(arya, gendry); } handle(effect) { // 2.    ( try/catch)  (effect === 'ask_name') { // 3. ,      (    try/catch!) resume with ' '; } }</span></span></code> </pre><br><p>  Se necesita un poco de tiempo para sentirse c√≥modo, pero conceptualmente no es muy diferente de <code>try/catch</code> con un retorno. </p><br><p>  Sin embargo, tenga en cuenta que los efectos algebraicos son una herramienta mucho m√°s poderosa que simplemente <code>try/catch</code> .  La recuperaci√≥n de errores es solo uno de los muchos casos de uso posibles.  Comenc√© con este ejemplo solo porque era m√°s f√°cil de entender. </p><br><br><h3>  La funci√≥n no tiene color. </h3><br><p>  Los efectos algebraicos tienen implicaciones interesantes para el c√≥digo asincr√≥nico. </p><br><p>  En idiomas con <code>async/await</code> funciones suelen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tener un "color"</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruso</a> ).  Por ejemplo, en JavaScript, no podemos hacer que <code>getName</code> as√≠ncrono sin infectar a <code>makeFriends</code> y sus funciones de llamada con async.  Esto puede ser un verdadero problema si parte del c√≥digo a veces necesita ser s√≠ncrono y a veces as√≠ncrono. </p><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       ... async getName(user) { // ... } //       ... async function makeFriends(user1, user2) { user1.friendNames.add(await getName(user2)); user2.friendNames.add(await getName(user1)); } //   ... async getName(user) { // ... }</span></span></code> </pre><br><p>  Los generadores de JavaScript funcionan de manera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">similar</a> : si trabaja con generadores, entonces todo el c√≥digo intermedio tambi√©n debe saber acerca de los generadores. </p><br><p>  Bueno, ¬øqu√© tiene que ver con eso? </p><br><p>  Por un momento, olvid√©monos de async / wait y regresemos a nuestro ejemplo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre><br><p>  ¬øQu√© pasa si nuestro controlador de efectos no puede devolver el "nombre de repuesto" de forma s√≠ncrona?  ¬øQu√© pasa si queremos obtenerlo de la base de datos? </p><br><p>  Resulta que podemos llamar a <code>resume with</code> asincr√≥nicamente desde nuestro controlador de efectos sin hacer ning√∫n cambio en <code>getName</code> o <code>makeFriends</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = user.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { name = perform <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeFriends</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user1, user2</span></span></span><span class="hljs-function">) </span></span>{ user1.friendNames.add(getName(user2)); user2.friendNames.add(getName(user1)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arya = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> gendry = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeFriends(arya, gendry); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect === <span class="hljs-string"><span class="hljs-string">'ask_name'</span></span>) { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre><br><p>  En este ejemplo, llamamos a <code>resume with</code> solo un segundo despu√©s.  Puede considerar <code>resume with</code> devoluci√≥n de llamada, a la que puede llamar solo una vez.  (Tambi√©n puede presumir ante sus amigos llamando a esto "una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">continuaci√≥n limitada de</a> una sola vez" (el t√©rmino <i>continuaci√≥n delimitada</i> a√∫n no ha recibido una traducci√≥n estable al ruso - aprox. Transl.)). </p><br><p>  Ahora la mec√°nica de los efectos algebraicos deber√≠a ser un poco m√°s clara.  Cuando arrojamos un error, el motor de JavaScript hace girar la pila al destruir las variables locales en el proceso.  Sin embargo, cuando <em>ejecutamos el</em> efecto, nuestro motor hipot√©tico crea una devoluci√≥n de llamada (en realidad un "marco de continuaci√≥n", aprox. Transl.) Con el resto de nuestra funci√≥n, y la <code>resume with</code> lo llamar√°. </p><br><p>  Una vez m√°s, un recordatorio: la sintaxis espec√≠fica y las palabras clave espec√≠ficas se inventan completamente solo para este art√≠culo.  El punto no est√° en eso, sino en la mec√°nica. </p><br><br><h3>  Nota de limpieza </h3><br><p>  Vale la pena se√±alar que los efectos algebraicos surgieron como resultado del estudio de la programaci√≥n funcional.  Algunos de los problemas que resuelven son exclusivos de la programaci√≥n funcional.  Por ejemplo, en lenguajes que no permiten efectos secundarios arbitrarios (como Haskell), debe usar conceptos como m√≥nadas para arrastrar los efectos a trav√©s de su programa.  Si alguna vez has le√≠do el tutorial de m√≥nada, entonces sabes que puede ser dif√≠cil de entender.  Los efectos algebraicos ayudan a hacer algo similar con un poco menos de esfuerzo. </p><br><p>  Es por eso que la mayor√≠a de las discusiones sobre los efectos algebraicos son completamente incomprensibles para m√≠.  (No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conozco a Haskell</a> y sus "amigos"). Sin embargo, creo que incluso en un lenguaje inmundo como JavaScript, los efectos algebraicos pueden ser una herramienta muy poderosa para separar el "qu√©" del "c√≥mo" en su c√≥digo. </p><br><p>  Le permiten escribir c√≥digo que describe <em>lo</em> que est√° haciendo: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateFiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> contents = perform OpenDirectory(dir); perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating files in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.files) { perform HandleFile(file); } perform Log(<span class="hljs-string"><span class="hljs-string">'Enumerating subdirectories in '</span></span>, dir); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> directory <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> contents.dir) { <span class="hljs-comment"><span class="hljs-comment">//           enumerateFiles(directory); } perform Log('Done'); }</span></span></code> </pre> <br><p>  Y luego envu√©lvelo con algo que describa el "c√≥mo" lo haces: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> files = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { myLoggingLibrary.log(effect.message); resume; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> OpenDirectory) { myFileSystemImpl.openDir(effect.dirName, (contents) =&gt; { resume <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> contents; }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HandleFile) { files.push(effect.fileName); resume; } } <span class="hljs-comment"><span class="hljs-comment">//  `files`    </span></span></code> </pre><br><p>  Lo que significa que estas partes pueden convertirse en una biblioteca: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyLoggingLibrary } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-log'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withMyFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'my-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ourProgram</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ enumerateFiles(<span class="hljs-string"><span class="hljs-string">'C:\\'</span></span>); } withMyLoggingLibrary(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { withMyFileSystem(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ourProgram(); }); });</code> </pre><br><p>  A diferencia de async / await o generadores, los efectos algebraicos no requieren la complicaci√≥n de funciones "intermedias".  Nuestro llamado a <code>enumerateFiles</code> puede estar en lo profundo de nuestro programa, pero siempre que haya un controlador de efectos para cada uno de los efectos que pueda ejecutar en alg√∫n lugar arriba, nuestro c√≥digo continuar√° funcionando. </p><br><p>  Los manejadores de efectos nos permiten separar la l√≥gica del programa de implementaciones espec√≠ficas de sus efectos sin necesidad de bailar y c√≥digo de plantilla innecesarios.  Por ejemplo, podr√≠amos redefinir completamente el comportamiento en las pruebas para usar el sistema de archivos falso y hacer instant√°neas de registros en lugar de mostrarlos en la consola: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { withFakeFileSystem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fake-fs'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withLogSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logs = []; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fn(); } handle(effect) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (effect <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Log) { logs.push(effect.message); resume; } } <span class="hljs-comment"><span class="hljs-comment">// Snapshot  . expect(logs).toMatchSnapshot(); } test('my program', () =&gt; { const fakeFiles = [ /* ... */ ]; withFakeFileSystem(fakeFiles, () =&gt; { withLogSnapshot(() =&gt; { ourProgram(); }); }); });</span></span></code> </pre><br><p>  Dado que las funciones no tienen un "color" (el c√≥digo intermedio no tiene que saber acerca de los efectos), y los controladores de efectos se pueden componer (se pueden anidar), puede crear abstracciones muy expresivas con ellos. </p><br><br><h3>  Nota de tipos </h3><br><p>  Dado que los efectos algebraicos provienen de lenguajes tipados est√°ticamente, la mayor parte del debate sobre ellos se centra en c√≥mo expresarlos en tipos.  Sin duda, esto es importante, pero tambi√©n puede complicar la comprensi√≥n del concepto.  Es por eso que este art√≠culo no habla sobre tipos en absoluto.  Sin embargo, debo tener en cuenta que, por lo general, el hecho de que una funci√≥n pueda realizar un efecto se codificar√° con una firma de su tipo.  Por lo tanto, estar√° protegido de una situaci√≥n en la que se realizan efectos impredecibles o no puede rastrear de d√≥nde provienen. </p><br><p>  Aqu√≠ puede decir que los efectos t√©cnicamente algebraicos "dan color" a las funciones en lenguajes est√°ticamente tipados, ya que los efectos son parte de una firma de tipo.  Realmente lo es  Sin embargo, arreglar la anotaci√≥n de tipo para que una funci√≥n intermedia incluya un nuevo efecto no es en s√≠ un cambio sem√°ntico, a diferencia de agregar as√≠ncrono o convertir la funci√≥n en un generador.  La inferencia de tipos tambi√©n puede ayudar a evitar la necesidad de cambios en cascada.  Una diferencia importante es que puede "suprimir" los efectos insertando un trozo vac√≠o o una implementaci√≥n temporal (por ejemplo, una llamada de sincronizaci√≥n para un efecto asincr√≥nico), que, si es necesario, le permite evitar su efecto en el c√≥digo externo, o convertirlo en otro efecto. </p><br><br><h3>  ¬øNecesito efectos algebraicos en JavaScript? </h3><br><p>  Honestamente, no lo se.  Son muy poderosos y se puede argumentar que son demasiado poderosos para un lenguaje como JavaScript. </p><br><p>  Creo que podr√≠an ser muy √∫tiles para lenguajes donde la mutabilidad es rara y donde la biblioteca est√°ndar admite completamente los efectos.  Si primero realiza <code>perform Timeout(1000), perform Fetch('http://google.com')</code> y <code>perform ReadFile('file.txt')</code> , y su idioma tiene "coincidencia de patrones" y escritura est√°tica para los efectos, luego Este puede ser un entorno de programaci√≥n muy agradable. </p><br><p>  ¬°Quiz√°s este lenguaje incluso se compilar√° en JavaScript! </p><br><br><h3>  ¬øQu√© tiene esto que ver con React? </h3><br><p>  No muy grande  Incluso puedes decir que tir√© una lechuza en un globo. </p><br><p>  Si viste mi charla sobre Time Slicing and Suspense, entonces la segunda parte incluye componentes que leen datos del cach√©: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovieDetails</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ id }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         ? const movie = movieCache.read(id); }</span></span></code> </pre><br><p>  (El informe usa una API ligeramente diferente, pero ese no es el punto). </p><br><p>  Este c√≥digo se basa en la funci√≥n Reaccionar para muestras de datos llamada " <code>Suspense</code> ", que se encuentra actualmente en desarrollo activo.  Lo interesante aqu√≠, por supuesto, es que los datos pueden no estar todav√≠a en movieCache; en este caso, primero debemos hacer algo, porque no podemos continuar la ejecuci√≥n.  T√©cnicamente, en este caso, la llamada a read () arroja Promise (s√≠, arroja Promise - tienes que tragar este hecho).  Esto detiene la ejecuci√≥n.  React intercepta esta Promesa y recuerda que es necesario repetir la representaci√≥n del √°rbol de componentes despu√©s de que se cumpla la Promesa arrojada. </p><br><p>  Este no es un efecto algebraico en s√≠ mismo, aunque la creaci√≥n de este truco fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inspirado por</a> ellos.  Este truco logra el mismo objetivo: algunos de los c√≥digos a continuaci√≥n en la pila de llamadas son temporalmente inferiores a algo m√°s alto en la pila de llamadas (en este caso, Reaccionar), mientras que todas las funciones intermedias no tienen que saberlo o ser "envenenadas" por as√≠ncronos o generadores.  Por supuesto, no podemos "en realidad" reanudar la ejecuci√≥n en JavaScript, pero desde el punto de vista de React, volver a mostrar el √°rbol de componentes despu√©s del permiso Promise es casi lo mismo.  ¬°Puedes hacer trampa cuando tu modelo de programaci√≥n asume idempotencia! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los ganchos</a> son otro ejemplo que puede recordarle los efectos algebraicos.  Una de las primeras preguntas que hace la gente es: ¬ød√≥nde llama useState a "saber" a qu√© componente se refiere? </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LikeButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  useState ,    ? const [isLiked, setIsLiked] = useState(false); }</span></span></code> </pre><br><p>  Ya expliqu√© esto al final de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> : en el objeto React hay un estado mutable "despachador actual", que indica la implementaci√≥n que est√° utilizando actualmente (por ejemplo, en <code>react-dom</code> ).  Del mismo modo, hay una propiedad de componente actual que apunta a la estructura de datos interna LikeButton.  As√≠ es como useState descubre qu√© hacer. </p><br><p>  Antes de acostumbrarse, la gente suele pensar que parece un truco sucio por una raz√≥n obvia.  Es incorrecto confiar en un estado mutable general.  (Nota: ¬øc√≥mo cree que se implementa try / catch en el motor de JavaScript?) </p><br><p>  Sin embargo, conceptualmente puede considerar useState () como un efecto de la ejecuci√≥n de State (), que es procesada por React cuando se ejecuta su componente.  Esto "explica" por qu√© React (lo que llama su componente) puede proporcionarle estado (es m√°s alto en la pila de llamadas, por lo que puede proporcionar un controlador de efectos).  De hecho, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementaci√≥n</a> expl√≠cita del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estado</a> es uno de los ejemplos m√°s comunes en los libros de texto sobre efectos algebraicos que he encontrado. </p><br><p>  Nuevamente, por supuesto, no es as√≠ como React realmente funciona, porque no tenemos efectos algebraicos en JavaScript.  En cambio, hay un campo oculto en el que guardamos el componente actual, as√≠ como un campo que apunta al "despachador" actual con la implementaci√≥n useState.  Como una optimizaci√≥n del rendimiento, incluso hay implementaciones useState separadas para <a href="">montajes y actualizaciones</a> .  Pero si ahora est√° muy retorcido por este c√≥digo, puede considerarlos manejadores de efectos ordinarios. </p><br><p>  En resumen, podemos decir que en JavaScript <code>throw</code> puede funcionar como una primera aproximaci√≥n para los efectos de E / S (siempre que el c√≥digo se pueda volver a ejecutar de forma segura m√°s adelante, y siempre que no est√© vinculado a la CPU), y el campo variable " el despachador "restaurado en prueba / finalmente puede servir como una aproximaci√≥n aproximada para los manejadores de efectos s√≠ncronos. </p><br><p>  Puede obtener una implementaci√≥n de efectos de mayor calidad <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilizando generadores</a> , pero esto significa que tendr√° que abandonar la naturaleza "transparente" de las funciones de JavaScript y tendr√° que hacer todo con los generadores.  Y esto es "bueno, eso ..." </p><br><h3>  D√≥nde encontrar m√°s </h3><br><p>  Personalmente, me sorprendi√≥ cu√°nto sentido adquirieron los efectos algebraicos para m√≠.  Siempre hice todo lo posible para comprender conceptos abstractos, como las m√≥nadas, pero los efectos algebraicos simplemente se activaron en la cabeza.  Espero que este art√≠culo les ayude a "unirse" con usted. </p><br><p>  No s√© si alguna vez comenzar√°n a usarse a granel.  Creo que me decepcionar√° si no se arraigan en ninguno de los idiomas principales para 2025.  ¬°Recu√©rdame verificar en cinco a√±os! </p><br><p>  Estoy seguro de que puedes hacer mucho m√°s interesante con ellos, pero es realmente dif√≠cil sentir su fuerza hasta que comienzas a escribir c√≥digo y usarlos.  Si esta publicaci√≥n despert√≥ su curiosidad, aqu√≠ hay algunos recursos m√°s donde puede leer con m√°s detalle: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/ocamllabs/ocaml-effects-tutorial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.janestreet.com/tech-talks/effective-programming</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.youtube.com/watch?v=hrBq8R_kxI0</a> </li></ul><br><p>  Muchas personas tambi√©n han se√±alado que si omite el aspecto de mecanograf√≠a (como hice en este art√≠culo), puede encontrar un uso anterior de dicha t√©cnica en un sistema de condici√≥n en Common Lisp.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  </a>  ,   ,   call/cc          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470718/">https://habr.com/ru/post/470718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470696/index.html">¬øPor qu√© Kaldi es bueno para el reconocimiento de voz? (actualizado 12.25.2019)</a></li>
<li><a href="../470700/index.html">Sobremesa Met√°lico Silencioso El tuyo</a></li>
<li><a href="../470706/index.html">Python + Keras + LSTM: haz un traductor de texto en media hora</a></li>
<li><a href="../470710/index.html">Aprendizaje autom√°tico para su caza plana. Parte 2</a></li>
<li><a href="../470714/index.html">C√≥mo fui a la Final Digital Breakthrough</a></li>
<li><a href="../470720/index.html">¬øC√≥mo escribir un contrato inteligente con Python en ontolog√≠a? Parte 2: API de almacenamiento</a></li>
<li><a href="../470722/index.html">¬øC√≥mo escribir un contrato inteligente con Python en ontolog√≠a? Parte 3: API de tiempo de ejecuci√≥n</a></li>
<li><a href="../470726/index.html">C√≥mo no ahogarse en la rutina, o nuestra experiencia comparando volcados de AWR durante pruebas de estr√©s</a></li>
<li><a href="../470728/index.html">Azure PowerShell: mayormente inofensivo</a></li>
<li><a href="../470730/index.html">Azure PowerShell: "en su mayor√≠a inofensivo"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>