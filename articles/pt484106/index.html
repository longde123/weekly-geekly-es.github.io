<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç¨ üîö ‚òùüèΩ MVCC no PostgreSQL-6. V√°cuo üòß üç¥ üë©üèø‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Come√ßamos com problemas relacionados ao isolamento , fizemos uma digress√£o sobre a estrutura de dados de baixo n√≠vel , discutimos as vers√µes de linha ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC no PostgreSQL-6. V√°cuo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/484106/">  Come√ßamos com problemas relacionados ao <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolamento</a> , fizemos uma digress√£o sobre <a href="https://habr.com/ru/company/postgrespro/blog/469087/">a estrutura de dados de baixo n√≠vel</a> , discutimos as <a href="https://habr.com/ru/company/postgrespro/blog/477648/">vers√µes de linha</a> e observamos como <a href="https://habr.com/ru/company/postgrespro/blog/479512/">os instant√¢neos de dados</a> s√£o obtidos a partir das vers√µes de linha. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Na √∫ltima vez em</a> que conversamos sobre atualiza√ß√µes QUENTES e aspira√ß√£o na p√°gina, hoje passaremos a um conhecido <em>vulgar a v√°cuo</em> .  Realmente, tanto j√° foi escrito sobre isso que mal posso acrescentar algo novo, mas a beleza de uma imagem completa requer sacrif√≠cio.  Portanto, tenha paci√™ncia. <br><br><h1>  V√°cuo </h1><br><h2>  O que o v√°cuo faz? </h2><br>  O v√°cuo na p√°gina funciona r√°pido, mas libera apenas parte do espa√ßo.  Ele funciona em uma p√°gina da tabela e n√£o toca nos √≠ndices. <br><br>  O v√°cuo b√°sico, "normal", √© feito usando o comando VACUUM, e o chamaremos apenas de "v√°cuo" (deixando "autovacuum" para uma discuss√£o em separado). <br><br>  Portanto, o v√°cuo processa a tabela inteira.  Ele aspira n√£o apenas as tuplas mortas, mas tamb√©m faz refer√™ncia a elas de todos os √≠ndices. <br><br>  Aspirar √© simult√¢neo com outras atividades no sistema.  A tabela e os √≠ndices podem ser usados ‚Äã‚Äãregularmente para leituras e atualiza√ß√µes (no entanto, a execu√ß√£o simult√¢nea de comandos como CREATE INDEX, ALTER TABLE e alguns outros √© imposs√≠vel). <br><br>  Somente essas p√°ginas da tabela s√£o examinadas onde algumas atividades ocorreram.  Para detect√°-los, o <em>mapa de visibilidade</em> √© usado (para lembr√°-lo, o mapa rastreia as p√°ginas que cont√™m tuplas bastante antigas, que s√£o vis√≠veis em todos os instant√¢neos de dados, com certeza).  Somente as p√°ginas s√£o processadas que n√£o s√£o rastreadas pelo mapa de visibilidade e o pr√≥prio mapa √© atualizado. <br><br>  O <em>mapa de espa√ßo livre</em> tamb√©m √© atualizado no processo para refletir o espa√ßo livre extra nas p√°ginas. <br><a name="habracut"></a><br>  Como sempre, vamos criar uma tabela: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Usamos o par√¢metro <em>autovacuum_enabled</em> para desativar o processo de autovacuum.  Discutiremos sobre isso na pr√≥xima vez, e agora √© fundamental para nossos experimentos controlar manualmente a aspira√ß√£o. <br><br>  A tabela agora possui tr√™s tuplas, cada uma das quais √© referenciada no √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Ap√≥s a aspira√ß√£o, as tuplas mortas s√£o aspiradas, e apenas uma permanece ativa.  E apenas uma refer√™ncia permanece no √≠ndice: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Observe que os dois primeiros ponteiros adquiriram o status "n√£o utilizado" em vez de "morto", que seriam adquiridos com o v√°cuo na p√°gina. <br><br><h2>  Sobre o horizonte de transa√ß√µes mais uma vez </h2><br>  Como o PostgreSQL descobre quais tuplas podem ser consideradas mortas?  J√° abordamos o conceito de horizonte de transa√ß√µes ao discutir <a href="https://habr.com/ru/company/postgrespro/blog/479512/">snapshots de dados</a> , mas n√£o custa reiterar um assunto t√£o importante. <br><br>  Vamos come√ßar o experimento anterior novamente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Mas antes de atualizar a linha novamente, deixe mais uma transa√ß√£o iniciar (mas n√£o terminar).  Neste exemplo, ele usar√° o n√≠vel Read Committed, mas dever√° obter um n√∫mero de transa√ß√£o verdadeiro (n√£o virtual).  Por exemplo, a transa√ß√£o pode alterar e at√© bloquear determinadas linhas em qualquer tabela, n√£o obrigat√≥ria <code>vac</code> : <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Existem tr√™s linhas na tabela e tr√™s refer√™ncias no √≠ndice agora.  O que acontecer√° ap√≥s aspirar? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Duas tuplas permanecem na tabela: VACUUM decidiu que a (0,2) tupla ainda n√£o pode ser aspirada.  O motivo est√° certamente no horizonte de transa√ß√µes do banco de dados, que neste exemplo √© determinado pela transa√ß√£o n√£o conclu√≠da: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Podemos pedir √† VACUUM para relatar o que est√° acontecendo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Note que: <br><br><ul><li>  <code>2 nonremovable row versions</code> - duas tuplas que n√£o podem ser exclu√≠das s√£o encontradas na tabela. </li><li>  <code>1 dead row versions cannot be removed yet</code> - uma delas est√° morta. </li><li>  <code>oldest xmin</code> mostra o horizonte atual. </li></ul><br>  Vamos reiterar a conclus√£o: se um banco de dados tiver transa√ß√µes de longa dura√ß√£o (n√£o conclu√≠das ou sendo executadas por muito tempo), isso pode causar incha√ßo na tabela, independentemente da frequ√™ncia com que a aspira√ß√£o ocorre.  Portanto, as cargas de trabalho dos tipos OLTP e OLAP coexistem mal em um banco de dados PostgreSQL: os relat√≥rios em execu√ß√£o por horas n√£o permitem que as tabelas atualizadas sejam devidamente aspiradas.  A cria√ß√£o de uma r√©plica separada para fins de relat√≥rio pode ser uma solu√ß√£o poss√≠vel para isso. <br><br>  Ap√≥s a conclus√£o de uma transa√ß√£o aberta, o horizonte se move e a situa√ß√£o √© corrigida: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Agora, apenas a vers√£o mais recente, ao vivo, da linha √© deixada na p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  O √≠ndice tamb√©m possui apenas uma linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  O que acontece por dentro? </h2><br>  A aspira√ß√£o deve processar a tabela e os √≠ndices ao mesmo tempo e fazer isso para n√£o bloquear os outros processos.  Como isso pode ser feito? <br><br>  Tudo come√ßa com a fase de <strong>heap de verifica√ß√£o</strong> (o mapa de visibilidade levado em considera√ß√£o, como j√° mencionado).  Nas p√°ginas lidas, as tuplas mortas s√£o detectadas e suas <code>tid</code> s√£o gravadas em uma matriz especializada.  A matriz √© armazenada na mem√≥ria local do processo de v√°cuo, onde bytes de mem√≥ria <em>maintenance_work_mem</em> s√£o alocados para ela.  O valor padr√£o deste par√¢metro √© 64 MB.  Observe que a quantidade total de mem√≥ria √© alocada de uma s√≥ vez, e n√£o conforme a necessidade.  No entanto, se a tabela n√£o for grande, uma quantidade menor de mem√≥ria ser√° alocada. <br><br>  Em seguida, chegamos ao final da tabela ou a mem√≥ria alocada para a matriz acabou.  Nos dois casos, a fase dos <strong>√≠ndices de aspira√ß√£o √©</strong> iniciada.  Para esse fim, <em>cada</em> √≠ndice criado na tabela <em>√© totalmente varrido</em> em busca das linhas que referenciam as tuplas lembradas.  As linhas encontradas s√£o aspiradas das p√°ginas de √≠ndice. <br><br>  Aqui, confrontamos o seguinte: os √≠ndices ainda n√£o t√™m refer√™ncias a tuplas mortas, enquanto a tabela ainda as possui.  E isso √© contr√°rio a nada: ao executar uma consulta, n√£o atingimos tuplas mortas (com acesso ao √≠ndice) ou as rejeitamos na verifica√ß√£o de visibilidade (ao verificar a tabela). <br><br>  Depois disso, a fase de <strong>aspira√ß√£o</strong> come√ßa.  A tabela √© digitalizada novamente para ler as p√°ginas apropriadas, aspir√°-las das tuplas lembradas e soltar os ponteiros.  Podemos fazer isso, pois n√£o h√° mais refer√™ncias dos √≠ndices. <br><br>  Se a tabela n√£o foi totalmente lida durante o primeiro ciclo, a matriz √© limpa e tudo √© repetido de onde chegamos. <br><br>  Em resumo: <br><br><ul><li>  A tabela √© sempre digitalizada duas vezes. </li><li>  Se a aspira√ß√£o excluir tantas tuplas que nem todas cabem na mem√≥ria do tamanho <em>maintenance_work_mem</em> , todos os √≠ndices ser√£o verificados quantas vezes forem necess√°rias. </li></ul><br>  Para tabelas grandes, isso pode exigir muito tempo e adicionar uma carga de trabalho significativa do sistema.  Obviamente, as consultas n√£o ser√£o bloqueadas, mas a entrada / sa√≠da extra √© definitivamente indesej√°vel. <br><br>  Para acelerar o processo, faz sentido chamar VACUUM com mais frequ√™ncia (para que n√£o sejam eliminadas muitas tuplas de cada vez) ou alocar mais mem√≥ria. <br><br>  Para observar entre par√™nteses, a partir da vers√£o 11, o PostgreSQL <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dcommit%3Bh%3D857f9c36cda520030381bd8c2af20adf0ce0e1d4">pode ignorar as verifica√ß√µes de √≠ndice, a</a> menos que seja necess√°rio.  Isso deve facilitar a vida dos propriet√°rios de tabelas grandes nas quais as linhas s√£o adicionadas apenas (mas n√£o alteradas). <br><br><h2>  Monitoramento </h2><br>  Como podemos descobrir que o VACUUM n√£o pode fazer seu trabalho em um ciclo? <br><br>  J√° vimos a primeira maneira: chamar o comando VACUUM com a op√ß√£o VERBOSE.  Nesse caso, informa√ß√µes sobre as fases do processo ser√£o enviadas para o console. <br><br>  Segundo, come√ßando com a vers√£o 9.6, a visualiza√ß√£o <code>pg_stat_progress_vacuum</code> est√° dispon√≠vel, o que tamb√©m fornece todas as informa√ß√µes necess√°rias. <br><br>  (A terceira maneira tamb√©m est√° dispon√≠vel: enviar as informa√ß√µes para o log de mensagens, mas isso funciona apenas para o v√°cuo autom√°tico, que ser√° discutido na pr√≥xima vez.) <br><br>  Vamos inserir algumas linhas na tabela, para que o processo de v√°cuo dure bastante, e vamos atualizar todas elas, para que o VACUUM consiga o que fazer. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Vamos reduzir o tamanho da mem√≥ria alocada para a matriz de identificadores: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Vamos iniciar o VACUUM e, enquanto estiver funcionando, vamos acessar a visualiza√ß√£o <code>pg_stat_progress_vacuum</code> v√°rias vezes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Aqui podemos ver, em particular: <br><br><ul><li>  O nome da fase atual - discutimos tr√™s fases principais, mas h√° <a href="https://postgrespro.com/docs/postgresql/11/progress-reporting">mais</a> delas em geral. </li><li>  O n√∫mero total de p√°ginas da tabela ( <code>heap_blks_total</code> ). </li><li>  O n√∫mero de p√°ginas digitalizadas ( <code>heap_blks_scanned</code> ). </li><li>  O n√∫mero de p√°ginas j√° <code>heap_blks_vacuumed</code> ( <code>heap_blks_vacuumed</code> ). </li><li>  O n√∫mero de ciclos de v√°cuo do √≠ndice ( <code>index_vacuum_count</code> ). </li></ul><br>  O progresso geral √© determinado pela propor√ß√£o de <code>heap_blks_vacuumed</code> e <code>heap_blks_total</code> , mas devemos levar em considera√ß√£o que esse valor muda em grandes incrementos, em vez de suavemente, devido √† varredura dos √≠ndices.  A aten√ß√£o principal, no entanto, deve ser dada ao n√∫mero de ciclos de v√°cuo: o n√∫mero maior que 1 significa que a mem√≥ria alocada n√£o foi suficiente para concluir a aspira√ß√£o em um ciclo. <br><br>  A sa√≠da do comando VACUUM VERBOSE, j√° conclu√≠da nessa √©poca, mostrar√° a imagem geral: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Podemos ver aqui que foram realizados tr√™s ciclos sobre os √≠ndices e, em cada ciclo, 174480 ponteiros para tuplas mortas foram aspirados.  Por que exatamente esse n√∫mero?  Uma vez ocupa 6 bytes e 1024 * 1024/6 = 174762, que √© o n√∫mero que vemos em <code>pg_stat_progress_vacuum.max_dead_tuples</code> .  Na realidade, um pouco menos pode ser usado: isso garante que, quando uma pr√≥xima p√°gina for lida, todos os ponteiros para tuplas mortas caber√£o na mem√≥ria, com certeza. <br><br><h2>  An√°lise </h2><br>  A an√°lise ou, em outras palavras, a coleta de estat√≠sticas para o planejador de consultas, n√£o est√° formalmente relacionada √† aspira√ß√£o.  No entanto, podemos realizar a an√°lise n√£o apenas usando o comando ANALYZE, mas combinar a aspira√ß√£o e a an√°lise no VACUUM ANALYZE.  Aqui o v√°cuo √© feito primeiro e depois a an√°lise, de modo que isso n√£o gera ganhos. <br><br>  Mas, como veremos mais adiante, o autovacuum e a an√°lise autom√°tica s√£o feitos em um processo e s√£o controlados de maneira semelhante. <br><br><h1>  V√ÅCUO CHEIO </h1><br>  Como observado acima, o v√°cuo libera mais espa√ßo do que o in-page, mas ainda assim n√£o resolve completamente o problema. <br><br>  Se, por algum motivo, o tamanho de uma tabela ou de um √≠ndice aumentar muito, o VACUUM liberar√° espa√ßo dentro das p√°ginas existentes: ocorrer√£o "furos", que ser√£o usados ‚Äã‚Äãpara a inser√ß√£o de novas tuplas.  Mas o n√∫mero de p√°ginas n√£o muda e, portanto, do ponto de vista do sistema operacional, os arquivos ocupam exatamente o mesmo espa√ßo que antes do v√°cuo.  E isso n√£o √© bom porque: <br><br><ul><li>  A verifica√ß√£o completa da tabela (ou √≠ndice) fica mais lenta. </li><li>  Um cache de buffer maior pode ser necess√°rio (pois s√£o as p√°ginas armazenadas l√° e a densidade de informa√ß√µes √∫teis diminui). </li><li>  Na √°rvore de √≠ndices, pode ocorrer um n√≠vel extra, que diminui o acesso ao √≠ndice. </li><li>  Os arquivos ocupam espa√ßo extra no disco e nas c√≥pias de backup. </li></ul><br>  (A √∫nica exce√ß√£o s√£o as p√°ginas totalmente aspiradas, localizadas no final do arquivo. Essas p√°ginas s√£o cortadas do arquivo e retornadas ao sistema operacional.) <br><br>  Se o compartilhamento de informa√ß√µes √∫teis nos arquivos cair abaixo de algum limite razo√°vel, o administrador poder√° executar VACUUM CHEIO da tabela.  Nesse caso, a tabela e todos os seus √≠ndices s√£o reconstru√≠dos do zero e os dados s√£o compactados de maneira compacta (√© claro, o par√¢metro <code>fillfactor</code> levado em considera√ß√£o).  Durante a reconstru√ß√£o, o PostgreSQL primeiro reconstr√≥i a tabela e, em seguida, cada um de seus √≠ndices, um por um.  Para cada objeto, novos arquivos s√£o criados e arquivos antigos s√£o removidos no final da reconstru√ß√£o.  Devemos levar em considera√ß√£o que ser√° necess√°rio espa√ßo em disco extra no processo. <br><br>  Para ilustrar isso, vamos novamente inserir um certo n√∫mero de linhas na tabela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Como podemos estimar a densidade da informa√ß√£o?  Para fazer isso, √© conveniente usar uma extens√£o especializada: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  A fun√ß√£o l√™ a tabela inteira e mostra estat√≠sticas: quais dados ocupam quanto espa√ßo nos arquivos.  A principal informa√ß√£o de nosso interesse agora √© o campo <code>tuple_percent</code> : a porcentagem de dados √∫teis.  √â inferior a 100 por causa da inevit√°vel sobrecarga de informa√ß√µes dentro de uma p√°gina, mas ainda √© bastante alta. <br><br>  Para o √≠ndice, s√£o <code>avg_leaf_density</code> informa√ß√µes diferentes, mas o campo <code>avg_leaf_density</code> tem o mesmo significado: a porcentagem de informa√ß√µes √∫teis (nas p√°ginas de folha). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  E estes s√£o os tamanhos da tabela e √≠ndices: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Agora vamos excluir 90% de todas as linhas.  Fazemos uma escolha aleat√≥ria de linhas a serem exclu√≠das, para que pelo menos uma linha permane√ßa altamente em cada p√°gina: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Qual o tamanho dos objetos ap√≥s o VACUUM? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Podemos ver que o tamanho n√£o mudou: VACUUM de maneira alguma pode reduzir o tamanho dos arquivos.  E isso ocorre embora a densidade de informa√ß√µes tenha diminu√≠do aproximadamente 10 vezes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Agora vamos verificar o que obtemos ap√≥s o VACUUM FULL.  Agora a tabela e os √≠ndices usam os seguintes arquivos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  Os arquivos s√£o substitu√≠dos por novos agora.  Os tamanhos da tabela e √≠ndices diminu√≠ram significativamente, enquanto a densidade de informa√ß√µes aumentou de acordo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Observe que a densidade de informa√ß√µes no √≠ndice √© ainda maior que a original.  √â mais vantajoso recriar um √≠ndice (√°rvore B) a partir dos dados dispon√≠veis do que inserir os dados em um √≠ndice existente linha por linha. <br><br>  As fun√ß√µes da extens√£o <a href="https://postgrespro.com/docs/postgresql/11/pgstattuple">pgstattuple</a> que usamos lemos a tabela inteira.  Mas isso √© inconveniente se a tabela for grande, portanto a extens√£o tem a fun√ß√£o <code>pgstattuple_approx</code> , que pula as p√°ginas marcadas no mapa de visibilidade e mostra valores aproximados. <br><br>  Mais uma maneira, mas ainda menos precisa, √© usar o cat√°logo do sistema para estimar aproximadamente a propor√ß√£o entre o tamanho dos dados e o tamanho do arquivo.  Voc√™ pode encontrar exemplos de tais consultas <a href="https://wiki.postgresql.org/wiki/Show_database_bloat">no wiki</a> . <br><br>  O VACUUM FULL n√£o se destina ao uso regular, pois bloqueia qualquer trabalho com a tabela (consultas inclu√≠das) por toda a dura√ß√£o do processo.  √â claro que, para um sistema muito usado, isso pode parecer inaceit√°vel.  Os bloqueios ser√£o discutidos separadamente, e agora mencionaremos apenas a extens√£o <a href="https://github.com/reorg/pg_repack">pg_repack</a> , que bloqueia a tabela por apenas um curto per√≠odo de tempo no final do trabalho. <br><br><h2>  Comandos semelhantes </h2><br>  Existem alguns comandos que tamb√©m reconstroem completamente tabelas e √≠ndices e, portanto, se assemelham ao VACUUM FULL.  Todos eles bloqueiam completamente qualquer trabalho com a tabela, todos removem arquivos de dados antigos e criam novos. <br><br>  O comando CLUSTER √© semelhante ao VACUUM FULL, mas tamb√©m ordena fisicamente as tuplas de acordo com um dos √≠ndices dispon√≠veis.  Isso permite que o planejador use o acesso ao √≠ndice com mais efici√™ncia em alguns casos.  Mas devemos ter em mente que o agrupamento n√£o √© mantido: a ordem f√≠sica das tuplas ser√° interrompida com as altera√ß√µes subsequentes da tabela. <br><br>  O comando REINDEX reconstr√≥i um √≠ndice separado na tabela.  VACUUM FULL e CLUSTER realmente usam esse comando para recriar √≠ndices. <br><br>  A l√≥gica do comando TRUNCATE √© semelhante √† de DELETE - exclui todas as linhas da tabela.  Mas DELETE, como j√° foi mencionado, marca apenas as tuplas como exclu√≠das, e isso requer mais limpeza.  E TRUNCATE apenas cria um arquivo novo e limpo.  Como regra, isso funciona mais r√°pido, mas devemos lembrar que o TRUNCATE bloquear√° qualquer trabalho com a tabela at√© o final da transa√ß√£o. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/486104/">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt484106/">https://habr.com/ru/post/pt484106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt484092/index.html">Pr√≠ncipes e nobres um tanto vestidos</a></li>
<li><a href="../pt484094/index.html">Crie um jogo de tiro em zumbi na terceira pessoa com DOTS</a></li>
<li><a href="../pt484096/index.html">A batalha dos dois Yakozun, ou Cassandra vs HBase. Experi√™ncia da equipe Sberbank</a></li>
<li><a href="../pt484100/index.html">Trabalhando com a interface no SDK do Google Maps para Android</a></li>
<li><a href="../pt484102/index.html">PHP vs Python vs Ruby on Rails: Compara√ß√£o Detalhada</a></li>
<li><a href="../pt484108/index.html">Encapsulador Etherblade.net e Substitui√ß√£o de Importa√ß√£o para Componentes de Rede (Parte Dois)</a></li>
<li><a href="../pt484112/index.html">√â poss√≠vel invadir um avi√£o</a></li>
<li><a href="../pt484114/index.html">Uma sele√ß√£o de 143 tradu√ß√µes do ensaio de Paul Graham (de 184)</a></li>
<li><a href="../pt484118/index.html">32 de janeiro</a></li>
<li><a href="../pt484120/index.html">As habilidades mais procuradas na profiss√£o de engenheiro de dados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>