<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíß üëèüèª üî° Sistema de diagn√≥stico m√©dico experto en Prolog üë©üèæ‚Äçü§ù‚Äçüë©üèΩ üë©üèº‚Äçüíª üñêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entrada 
 De alguna manera tuve la suerte de elegir el tema de la tesis en ingenier√≠a de software, y eleg√≠ escribir un sistema experto, adem√°s, en el ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema de diagn√≥stico m√©dico experto en Prolog</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436722/"><h2>  Entrada </h2><br>  De alguna manera tuve la suerte de elegir el tema de la tesis en ingenier√≠a de software, y eleg√≠ escribir un sistema experto, adem√°s, en el lenguaje Prolog.  Aunque casi nunca se usa en programaci√≥n industrial, es te√≥ricamente interesante y le permite tocar sistemas inteligentes (IP) de la manera m√°s r√°pida.  Adem√°s, el lenguaje en s√≠ es interesante en t√©rminos de deportes, ya que te hace pensar de una manera inusual, diferente de pensar en programaci√≥n de procedimientos y POO, que es un buen entrenamiento para el cerebro. <br><br>  Utilizamos la implementaci√≥n de Prolog - Visual Prolog, con bibliotecas GUI incorporadas.  Pero si <br>  Si desea escribir una GUI en Qt / C ++, la documentaci√≥n contiene instrucciones sobre c√≥mo importar un programa en un archivo DLL y compilarlo con un proyecto C / C ++.  De ello se deduce que se puede combinar con otros idiomas. <br><br>  En general, cuando trabaj√© en este proyecto, no encontr√© ejemplos que no fueran lo suficientemente primitivos, pero al mismo tiempo no tan grandes como ejemplos cient√≠ficos sofisticados.  Por lo tanto, este art√≠culo puede ser de gran ayuda para principiantes y personas que desean escribir al menos un poco similar a IP. <br><br>  Descripci√≥n del prop√≥sito del sistema: hay un conjunto de par√°metros a los que debe corresponder la se√±al cardiosis (ECG), por los cuales se puede determinar la enfermedad.  Una persona responde las preguntas del sistema (en modo de di√°logo), y el sistema, actuando como experto en enfermedades card√≠acas, saca conclusiones sobre una posible enfermedad humana. <br><br>  Es decir  Este c√≥digo puede considerarse como un marco (prolog-framework) para crear sistemas expertos de otras √°reas, simplemente sustituyendo sus propias reglas, sus datos.  Las reglas por las cuales se realiza la inserci√≥n se describir√°n a continuaci√≥n. <br><br><h2>  C√°lculo predicado de primer orden y lenguaje Prolog </h2><br>  El lenguaje Prolog implementa el paradigma de programaci√≥n l√≥gica, cuya idea es el uso de la tecnolog√≠a inform√°tica para la conclusi√≥n l√≥gica de la descripci√≥n declarativa del √°rea tem√°tica.  Esto lo distingue de los lenguajes de programaci√≥n de procedimientos que describen acciones secuenciales bien definidas.  Por lo tanto, los lenguajes de procedimiento no son adecuados para escribir ES, y si se usan, solo como m√≥dulos auxiliares.  Otra caracter√≠stica distintiva del lenguaje Prolog es el uso de un subconjunto del lenguaje l√≥gico de primer orden para describir un programa, que es conveniente y m√°s simple que para otros; cambia de un lenguaje natural a describir el mundo por una persona.  Al crear un ES, este es uno de los problemas importantes: c√≥mo traducir el conocimiento del dominio a un lenguaje formal limitado, mientras se preserva el contenido de informaci√≥n invertido por una persona.  Tambi√©n existe una oportunidad simple para transferir el conocimiento de la forma formal a la natural, debido a la comprensibilidad intuitiva y la simplicidad, en comparaci√≥n con la l√≥gica de segundo orden u otros c√°lculos matem√°ticos. <br><br>  Las construcciones de lenguaje del Prolog se pueden representar en forma de implicaciones de la forma: <br><br> <code>A1, A2, ‚Ä¶, An &lt;= B1, B2, ‚Ä¶,Bm (n&gt;=0, m&gt;=0) (1)</code> <br> <br>  donde Ai y Bi son f√≥rmulas at√≥micas Fi (t1, t2, ..., tk) o la negaci√≥n Fi (t1, t2, ..., tk), donde tk son t√©rminos (constante individual, variable o resultado de aplicar la funci√≥n) <br><br>  En Prolog, todas las relaciones se escriben como hechos y reglas, donde n = 1 en la f√≥rmula (1), para aumentar la eficiencia de la inferencia l√≥gica.  Las reglas corresponden a una f√≥rmula llamada f√≥rmula Horn: <br><br> <code>A&lt;=B1, B2, ‚Ä¶, Bm , m&gt;0 (2)</code> <br> <br>  Los hechos corresponden a la f√≥rmula (2) con m = 0: <br><br> <code>A&lt;= (3)</code> <br> <br>  La f√≥rmula que debe probarse en el proceso del mecanismo de inferencia es la f√≥rmula (1) para n = 0, m&gt; 0, llamada meta o solicitud: <br><br> <code>&lt;= B1, B2, ‚Ä¶Bm (4)</code> <br> <br>  Estas construcciones de lenguaje comprenden todo el programa Prolog. <br>  Por ejemplo, el siguiente conocimiento, en forma de una oraci√≥n en lenguaje natural - "Son Ani ama a Masha" puede escribirse como un hecho: <br><br><pre> <code class="plaintext hljs">((), )</code> </pre> <br>  y la frase "Anya ama a todos los que Olga ama" en la forma: <br><br><pre> <code class="plaintext hljs">((,X)&lt;=(,X))</code> </pre> <br>  O el razonamiento ‚ÄúToda persona es mortal.  Confucio es un hombre ‚Äù: <br><br><pre> <code class="plaintext hljs">(()&amp; ((X)&lt;=(X)) &lt;= ()</code> </pre> <br>  El Prolog tambi√©n proporciona herramientas para definir estructuras de datos recursivas, como √°rboles y listas, lo que brinda capacidades adicionales para una descripci√≥n conveniente del conocimiento relevante. <br><br>  Por lo tanto, se puede ver que el Prolog proporciona un lenguaje flexible, simple e intuitivo para describir el conocimiento. <br><br>  Pero luego surge la pregunta de elegir la implementaci√≥n de este lenguaje, y se decidi√≥ desarrollar ES en la extensi√≥n del lenguaje Prolog: Visual Prolog. <br><br><h2>  Pr√≥logo visual </h2><br>  Visual Prolog es un dialecto del lenguaje Prolog con una extensi√≥n orientada a objetos junto con un entorno de desarrollo integrado.  Este entorno proporciona soporte para crear interfaces gr√°ficas y muchas otras bibliotecas.  El lenguaje Prolog es bastante popular para crear ES, con una sintaxis simple que es similar en significado a las relaciones de dominio y los hechos.  En general, el propio int√©rprete de lenguaje Prolog puede considerarse como un ES en t√©rminos de l√≥gica de predicado de primer orden, en la que el usuario hace una pregunta en forma de objetivo, cuya verdad debe demostrarse.  Este es un lenguaje declarativo, describe lo que se necesita obtener, en lugar de un algoritmo secuencial, es perfecto para describir el conocimiento de un peque√±o ES.  En comparaci√≥n con entornos alternativos, AMZI Prolog y SWI-Prolog proporcionan una interfaz muy efectiva para interactuar con otros idiomas, ya sea al vincular archivos de objetos o al cargar din√°micamente archivos DLL de otros idiomas o como un m√≥dulo DLL independiente.  Visual Prolog tambi√©n est√° bien documentado y tiene muchos ejemplos.  Tambi√©n existe la opini√≥n de que la elecci√≥n de un lenguaje de implementaci√≥n, una forma de presentar el conocimiento y un m√©todo para formar el razonamiento son secundarios, en comparaci√≥n con el conocimiento de un experto, y afectan solo el mecanismo para su uso exitoso.  Sin embargo, la presencia de literatura que usa el pr√≥logo como un medio para crear ES indica la idoneidad de su uso, al menos en sistemas peque√±os. <br><br><h2>  Dise√±o ES </h2><br>  En la literatura, se acostumbra dividir los ES en varios componentes b√°sicos que dependen poco entre s√≠: la base de conocimiento, el mecanismo de salida y la interfaz de usuario. <br><br>  Hay 2 tipos de organizaci√≥n de sistemas expertos: en las reglas y en los hechos. <br><br>  El conocimiento de ES sobre las reglas se registra en forma de reglas de producci√≥n.  La parte izquierda de cada regla contiene alguna alternativa para resolver el problema, y ‚Äã‚Äãlas partes correctas (premisas) est√°n especificadas por otras reglas.  La √∫nica excepci√≥n es cuando una regla busca informaci√≥n en la base de datos, como una respuesta a una pregunta.  El algoritmo del mecanismo de salida se reduce a comparaci√≥n, luego, con muchas opciones, se selecciona la que se necesita de acuerdo con el principio de resoluci√≥n de conflictos y al final se aplica la regla seleccionada y todo comienza de nuevo.  Las ventajas de tal organizaci√≥n son que es muy f√°cil agregar reglas al sistema sin afectar otras reglas, y es f√°cil de complementar y modificar, ya que el programador solo necesita insertar la regla deseada en el bloque de reglas apropiado.  Tal organizaci√≥n tambi√©n tiene limitaciones, es decir, ser√° necesario organizar un algoritmo antinatural para guardar el rastreo o usar una variable para ello en las reglas, pero esto violar√° la conveniencia de modificar las reglas, ya que para cada predicado de regla es necesario organizar el guardado de rastreo.  Adem√°s, esto violar√° la legibilidad del programa y la posibilidad de modificar el mecanismo de salida en general, ya que junto con la informaci√≥n sobre las reglas, se mantendr√° el recorrido por la acci√≥n del mecanismo de salida.  Adem√°s, el Prolog no le permite guardar las reglas en el archivo de la base de datos y leer las reglas de la base de datos, lo que no permitir√≠a actualizar la base de conocimiento mientras se ejecuta el programa.  El Listado 1 da un ejemplo de tal organizaci√≥n de base de conocimiento. <br><br>  Listado 1 <br><br><pre> <code class="plaintext hljs">diag("SIRS"):- diag2("SIRS"). diag("Sepsis"):- diag("SIRS"), have("Sepsis character"). diag("Hard sepsis"):- diag("Sepsis"), have("Hard sepsis character"). diag("Shock sepsis"):- diag("Hard sepsis"), have("Shock sepsis character"). diag("MOF"):- diag("Hard sepsis"), have("MOF sepsis character"). diag("MOF"):- diag("Shock sepsis"), have("MOF sepsis character").</code> </pre> <br>  Como se puede ver en el Listado 1, el mecanismo de salida deber√≠a estar completamente controlado por el mecanismo de salida Prolog est√°ndar incorporado. <br><br>  Los ES organizados seg√∫n la l√≥gica (sobre los hechos) son m√°s flexibles porque, a diferencia de la conexi√≥n directa de las reglas, est√°n organizados seg√∫n un m√©todo de referencia (indirecto) para describir la relaci√≥n de las reglas.  Las relaciones se escriben en t√©rminos, como n√∫meros de reglas, y no reglas anidadas.  Tal registro es m√°s consistente con un registro estricto en forma de oraciones de l√≥gica de predicados, lo que hace que el mecanismo para derivar tales reglas sea m√°s flexible.  A diferencia de la organizaci√≥n basada en las reglas, la b√∫squeda de la soluci√≥n Prolog depende menos del proceso de inferencia l√≥gica de la siguiente regla, ya que es posible realizar otras acciones adem√°s de la salida, por ejemplo, pasar por un √°rbol de decisi√≥n alternativo o incluso cambiar el flujo de salida y volver a la posici√≥n inicial mientras se mantiene todos los datos al respecto. <br><br>  Al igual que en la organizaci√≥n, aqu√≠ funciona un ciclo sobre las reglas: correspondencia - resoluci√≥n de conflictos - transici√≥n a la siguiente regla, pero dado que el mecanismo de salida se controla indirectamente, es conveniente mostrar informaci√≥n sobre c√≥mo encontrar una soluci√≥n en el proceso y cambiar este formato sin cambiar la base de conocimiento.  La principal ventaja de una organizaci√≥n en la l√≥gica es que es posible hacer que las variables que se asignan durante el proceso de salida est√©n disponibles autom√°ticamente en el mecanismo de salida, y se pueden mostrar junto con una cadena de las √∫ltimas reglas que se env√≠an al objetivo actual.  Pero para esto, es necesario proporcionar un mecanismo adicional para los tipos de fantasmas para diferentes tipos de reglas.  Adem√°s, la base de conocimiento se almacena en forma de hechos, por lo que se puede guardar o leer desde un archivo en el medio.  Es m√°s dif√≠cil modificar y depurar el sistema en hechos que en reglas, ya que el mecanismo de salida est√° controlado por los valores de variables y t√©rminos, por ejemplo, en forma de un n√∫mero de regla, que introduce posibilidades adicionales de errores. <br><br>  Tambi√©n en el mecanismo de salida hay m√°s variables que influyen en este proceso, a veces de tipo recursivo y m√°s bien interconectado, lo que complica el desarrollo y los errores de captura, pero este es el precio por la flexibilidad que proporciona.  El sistema tambi√©n funciona en hechos m√°s eficientemente y m√°s r√°pido que en las reglas, lo cual es especialmente importante para ES voluminoso en tiempo real, o incluso para ES distribuido en tiempo real. <br><br>  Un ES grande para el diagn√≥stico m√©dico en el caso de admisi√≥n de pacientes en estado cr√≠tico, especialmente si es utilizado simult√°neamente por muchos m√©dicos, tambi√©n debe ajustarse a un marco de tiempo estricto. <br><br>  Es a√∫n m√°s dif√≠cil probar un sistema en hechos debido a su dependencia de los hechos, ya que en un sistema de reglas solo un error afectar√≠a el mecanismo de salida, y esto se har√≠a visible de inmediato, pero lo m√°s probable es que contin√∫e trabajando en hechos. <br><br>  Como resultado, dado que el sistema desarrollado debe ser informativo para el usuario, es decir, se debe mostrar una respuesta razonable a la pregunta en el proceso de inferencia l√≥gica: por qu√© el sistema necesitaba la informaci√≥n solicitada para que el usuario sepa en qu√© etapa de la b√∫squeda de soluci√≥n se encuentra, lo que no se puede lograr sin guardar el rastro buscar.  Tambi√©n al final, despu√©s de responder la pregunta, el usuario deber√≠a poder ver el √°rbol de evidencia de las soluciones encontradas.  Dados todos los par√°metros del sistema, el sistema m√°s racional me pareci√≥ las reglas, ya que puede guardarse en el disco y su mecanismo de salida ser√° m√°s f√°cil de organizar.  Adem√°s, el conocimiento sobre el diagn√≥stico de enfermedades cardiovasculares result√≥ ser bastante dif√≠cil de formalizar debido a su interconexi√≥n sem√°ntica, especialmente en aquellos lugares donde el significado de las conclusiones de las reglas significaba tener en cuenta informaci√≥n adicional, para cada uno.  Por lo tanto, al elegir un mecanismo para intercambiar datos heterog√©neos entre predicados, se realiz√≥ un c√°lculo sobre la forma l√≥gica de organizaci√≥n. <br><br>  Tambi√©n hay 2 tipos de inferencia: inferencia inversa y directa.  En los complejos sistemas de consulta m√©dica, todav√≠a se usa una combinaci√≥n de estos tipos: un tipo deduce una cierta cantidad de conocimiento, y otro ya se usa sobre la base. <br><br>  Una conclusi√≥n directa es encontrar un efecto basado en una multitud de hechos y luego sacar otras conclusiones de las nuevas consecuencias.  Es efectivo cuando hay muchas hip√≥tesis conectadas a diferentes niveles que necesitan ser probadas, o cuando hay muchos axiomas para derivar muchas m√°s hip√≥tesis. <br><br>  La conclusi√≥n inversa es la opuesta, primero se selecciona una hip√≥tesis que necesita ser probada, y luego se intenta probar la premisa de esta hip√≥tesis, hasta que la siguiente premisa se encuentre como un axioma. <br><br>  En ES, el razonamiento sobre las reglas se implementa mediante el m√©todo de inferencia l√≥gica inversa, que utiliza Prolog.  Se eligi√≥ esta opci√≥n porque, a diferencia de la inferencia directa, funciona de manera m√°s eficiente con este conocimiento, ya que el n√∫mero de v√©rtices objetivo es mucho m√°s que hechos y no hay hip√≥tesis en competencia (son independientes). <br><br><h2>  Implementaci√≥n </h2><br>  En Prolog, las reglas se implementan como un predicado de regla.  Cada regla tiene su propio n√∫mero y nombre, que es una hip√≥tesis (conclusi√≥n) que necesita ser probada.  La condici√≥n de la regla corresponde a una declaraci√≥n impl√≠cita, que determina completamente la verdad de la hip√≥tesis. <br><br>  Condici√≥n de la regla: <br><br><pre> <code class="plaintext hljs">Colclusion(K)=C1(K) and (C2(K) or C3(K)) and C4(K)</code> </pre> <br>  C1 (K) = Todas las conclusiones de las reglas con n√∫meros registrados en la primera lista para la regla Kth son verdaderas <br><br>  C2 (K) = Verdadero, al menos una regla de la segunda lista para la regla K <br>  C3 (K) = Verdaderamente exactamente N (K) Conclusiones de las reglas de la segunda lista para la regla K <br><br>  C4 (K) = El predicado para la regla Kth (predicado doc (K)), que es descrito por el usuario. <br>  Si alguna lista est√° vac√≠a, la declaraci√≥n correspondiente es verdadera. <br><br>  Al mismo tiempo, se puede ingresar cualquier otro predicado en el predicado para C4, pero al mismo tiempo no deben violar el significado l√≥gico de la conclusi√≥n.  Para apoyar la negaci√≥n, algunas conclusiones existentes en la base de conocimiento tambi√©n se pueden ingresar aqu√≠. <br><br>  El mecanismo de salida garantiza que las reglas se apliquen en la secuencia correcta y guarda la traza. <br><br>  El principio principal de la conclusi√≥n es probar la verdad de la conclusi√≥n, probar consistentemente todas sus conclusiones en la primera lista, luego probar las conclusiones de la segunda lista y al final verificar la verdad del predicado correspondiente al n√∫mero de la regla actual.  Para verificar la segunda lista, si se encuentra al menos una regla verdadera, se verificar√°n todas las reglas que van al final de la lista. <br><br><h2>  Descripci√≥n del predicado </h2><br>  En general, el principio de codificaci√≥n del conocimiento se implementa en el Prolog utilizando dos predicados de la siguiente forma: <br><br>  regla (K, "Texto de conclusi√≥n es el nombre de la regla", Id, Lista1, Lista2, N) <br>  doc (K) <br>  K - n√∫mero de regla <br>  Id: ID de datos para esta regla <br>  Lista1: la primera lista de n√∫meros de regla <br>  List2 - segunda lista de n√∫meros de regla <br>  N es el n√∫mero de conclusiones verdaderas <br><br>  Adem√°s, la regla siempre se escribe como un hecho, sin variables, y su verdad, como se dijo, determina, adem√°s de las listas, el documento predicado correspondiente. <br><br>  Aqu√≠ hay algunos ejemplos de conocimiento escrito: <br><br>  regla (93, ‚ÄúTASH - TASH-score 43%‚Äù, tashSc10, [47], [], 0) <br>  regla (33, ‚ÄúTASH - Exceso de motivos - es la suma de puntos‚Äù, ninguno, [], [29,30,31,32], 1). <br><br>  En el documento de predicados, se puede usar cualquier otro predicado, lo que hace posible asignar el texto de la declaraci√≥n de la regla al conjunto de situaciones que se pueden describir usando el Pr√≥logo. <br><br>  De esta manera, todo el conocimiento se registra utilizando estos dos predicados. <br><br>  En los predicados doc, las funciones de la interfaz de usuario se denominan principalmente, ya que algunas reglas est√°n intr√≠nsecamente vinculadas de forma inextricable con la respuesta del usuario o comprueban valores v√°lidos. <br><br>  Por ejemplo, los predicados doc para reglas cuya verdad depende del intervalo en el que se encuentra la puntuaci√≥n total hacen las verificaciones adecuadas. <br><br>  El predicado doc para el diagn√≥stico de enfermedades de sepsis utiliza el predicado docc adicional, que permite no hacer preguntas innecesarias al usuario.  Por ejemplo, si un signo requiere al menos dos signos, si la respuesta es no a dos signos, el sistema no deber√≠a hacer m√°s preguntas, ya que es obvio que el signo no puede ser verdadero.  Para hacer esto, el predicado docc proporciona una verificaci√≥n de m√°s de dos respuestas negativas en la base de datos.  Tampoco tiene sentido hacer la tercera pregunta si ya hay una respuesta a dos preguntas suficientes para establecer la verdad de la caracter√≠stica resultante. <br><br>  El predicado kolNeg (Cantidad) busca el n√∫mero de respuestas negativas en la base de datos para este grupo de atributos.  Para hacer esto, primero busca todo tipo de signos de este grupo de signos para no confundirlos con otros grupos, y luego los considera del conjunto en la base de datos usando el predicado kol_neg_list_in_db trabajando con la lista de signos de este grupo. <br><br><h2>  Ejemplos de c√≥digo </h2><br>  El proyecto es grande, por lo que dar√© los pasajes m√°s importantes. <br><br>  Listado 2 - Lista de reglas <br><br><pre> <code class="plaintext hljs">rule(11,"Sepsises - SIRS . 1: t&gt;38C  t&lt;36",sirsPr1,[],[],0). rule(12,"Sepsises -   &gt;90",sirsPr2,[],[],0). rule(13,"Sepsises -  &gt;20  PaCO2&lt;32mmHg",sirsPr3,[],[],0).</code> </pre> <br>  Listado 3 - Lista de hechos <br><br><pre> <code class="plaintext hljs">fact1(sirsPr1,"SIRS","SIRS . 1: t&gt;38C  t&lt;36"). fact1(sirsPr2,"SIRS","  &gt;90"). fact1(sirsPr3,"SIRS"," &gt;20  PaCO2&lt;32mmHg"). fact1(sirsPr4,"SIRS","- &gt;12.000/mm&gt;3, &lt;4.000/mm&gt;3  &gt;10% band").</code> </pre> <br>  - Lista de consecuencias l√≥gicas. <br><br><pre> <code class="plaintext hljs">tash_score(1,tashSc1,0,8,"  &lt;5%"). tash_score(2,tashSc2,9,9,"  6%"). tash_score(3,tashSc3,10,10,"  8%").</code> </pre> <br>  Listado 4 - M√°quina de salida <br><br><pre> <code class="1c hljs">sizeList([],<span class="hljs-number"><span class="hljs-number">0</span></span>):-!. sizeList([_<span class="hljs-string"><span class="hljs-string">|T],Size):- sizeList(T,SizeTail), Size=SizeTail+1. append_der_list([],List,List). append_der_list([H|L1],List2,[H|L3]):- append_der_list(L1,List2,L3). any2(NeedSize,NeedSize,_,[],[],_):-!. any2(_,_,[],[],[],_):-!. any2(NeedSize,Size,[H|T1],[H|T2],[FirstDer|OtherDer],Why):- Nomer=[H], go(Nomer,UnderFirstDer,Why), rule(H,Text,_,_,_,_), FirstDer=tree(Text,unmarked,UnderFirstDer,0),%der(H,UnderFirstDer), Size1=Size+1,!, any2(NeedSize,Size1,T1,T2,OtherDer,Why). any2(NeedSize,Size,[_|T1],List,OrDer,Why):- !,any2(NeedSize,Size,T1,List,OrDer,Why). go([],[],_):-!. go([H|T],[FirstDer|OtherDer],Why):- rule(H,Name,_,ListAnd,ListOr,KolOr), NewWhy=[Name|Why], go(ListAnd,UnderFirstDer,NewWhy), goOr(ListOr,KolOr,_,OrDer,NewWhy), append_der_list(UnderFirstDer,OrDer,TwoDers), FirstDer=tree(Name,unmarked,TwoDers,0), asserta(why_trace(NewWhy)), doc(H,NewWhy), go(T,OtherDer,Why). goOr([],_,[],[],_):-!. goOr(ListOr,KolOr,ListYes,OrDer,Why):- KolOr&lt;&gt;0, any2(KolOr,0,ListOr,ListYes,OrDer,Why), sizeList(ListYes,KolOr). goOr(ListOr,0,ListYes,OrDer,Why):- any2(100000,0,ListOr,ListYes,OrDer,Why), sizeList(ListYes,KolListYes), KolListYes&gt;0.</span></span></code> </pre> <br>  Listado 5 - conclusi√≥n de las consecuencias finales <br><br><pre> <code class="plaintext hljs">tashQuestion(Id):- fact2(Id,_,Prisnak,_), pos(Prisnak),!. tashQuestion(Id):- fact2(Id,_,Prisnak,_), neg(Prisnak),fail,!. tashQuestion(Id):- fact2(Id,_,Prisnak,Ball), not(neg(Prisnak)), not(pos(Prisnak)), dialog_ynw(Prisnak,Ans), tash_in_data_base(Ans,Prisnak,Ball),!. tash_in_data_base("y",Prisnak,Ball):- asserta(pos(Prisnak)),sum_tash(Sum1),Sum2=Sum1+Ball,asserta(sum_tash(Sum2)),!. tash_in_data_base("n",Prisnak,_):- asserta(neg(Prisnak)),!,fail. tash_in_data_base(_,_,_):- write("\nTASH-not correct answer"),!,fail. oneQuestion(Id):- fact1(Id,_,Prisnak), pos(Prisnak),!. oneQuestion(Id):- fact1(Id,_,Prisnak), not(neg(Prisnak)), question_sepsis(Prisnak),!.</code> </pre> <br><h2>  Conclusiones </h2><br>  Espero que este art√≠culo ayude a los principiantes a construir su propio sistema experto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436722/">https://habr.com/ru/post/es436722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436712/index.html">¬øC√≥mo promover un juego incremental? Gratis, r√°pido y efectivo *</a></li>
<li><a href="../es436714/index.html">El trabajo comienza con las pruebas.</a></li>
<li><a href="../es436716/index.html">Puerta falsa como parte del desarrollo del cliente</a></li>
<li><a href="../es436718/index.html">Experiencia personal: cinco desaf√≠os al iniciar un negocio en los EE. UU.</a></li>
<li><a href="../es436720/index.html">Existe una opini√≥n: IPv6 fall√≥: qui√©n lo cree y por qu√©</a></li>
<li><a href="../es436724/index.html">Creando productos que crean h√°bitos</a></li>
<li><a href="../es436728/index.html">Gu√≠a de ML.NET: primera aplicaci√≥n en 10 minutos</a></li>
<li><a href="../es436730/index.html">Sal√≥n de la fama de la electr√≥nica de consumo: las historias de los mejores artilugios de los √∫ltimos 50 a√±os, parte 5</a></li>
<li><a href="../es436740/index.html">Investigaci√≥n propia, ¬øqu√© nos pueden decir las fuentes abiertas?</a></li>
<li><a href="../es436742/index.html">Android Robotics hasta 2019: la historia real; en 5 partes; parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>