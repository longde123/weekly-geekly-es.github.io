<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 👨🏿‍🚒 👨🏽‍🏭 WebGL-wind和GPU编程。 FrontTalks 2018演讲 👦🏾 👨‍👩‍👦‍👦 🚚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="为了在网页上呈现复杂的图形，有一个Web图形库，简称WebGL。 界面设计师Dmitry Vasiliev从布局设计师的角度谈到了GPU编程，介绍了WebGL是什么以及我们如何解决使用此技术可视化大型天气数据的问题。 


 -我正在Yandex的叶卡捷琳堡办公室开发接口。 我开始参加运动组。 当有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WebGL-wind和GPU编程。 FrontTalks 2018演讲</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/433278/"> 为了在网页上呈现复杂的图形，有一个Web图形库，简称WebGL。 界面设计师Dmitry Vasiliev从布局设计师的角度谈到了GPU编程，介绍了WebGL是什么以及我们如何解决使用此技术可视化大型天气数据的问题。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-yvY4-ovavo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  -我正在Yandex的叶卡捷琳堡办公室开发接口。 我开始参加运动组。 当有曲棍球，足球，奥运会，残奥会和其他酷事世锦赛时，我们正在开发体育特别项目。 我还致力于特殊搜索结果的开发，该搜索结果专门用于新的索契赛道。 <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/5p/l2/e_/5pl2e_nhpyefyjt0q3wfspflpyc.jpeg"><br><br><img src="https://habrastorage.org/webt/qw/zy/xd/qwzyxdlvu0jukewd-9prrerk-a8.jpeg"><br><br><img src="https://habrastorage.org/webt/uy/7b/mp/uy7bmpkufgne4mck5yiawv3mj1o.jpeg"><br><br><img src="https://habrastorage.org/webt/q6/cu/kw/q6cukwvmpmwru6iew_ranhk7mwo.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幻灯片链接</a></sup></sub> </h5><br> 此外，在一个半盔中，我们重新启动了“错误处理”服务。 然后在Pogoda开始工作，我在那里支持该API的可操作性，其开发，围绕该API编写基础结构以及为受过训练的机器学习公式编写节点绑定程序。 <br><br><img src="https://habrastorage.org/webt/sz/xs/zy/szxszynumbssi9qyhkxwalfmsdy.jpeg"><br><br> 然后工作开始变得更加有趣。 参与了我们天气服务的重新设计。 台式机，独轮车。 <br><br><img src="https://habrastorage.org/webt/io/q4/cw/ioq4cwweh1vbjyqonlto5yuo_1e.jpeg"><br><br><img src="https://habrastorage.org/webt/ij/er/w6/ijerw62hpfkj2kvph4wvuag_www.jpeg"><br><br> 整理好标准预测之后，我们决定做出没有人预测的预测。 该预测是整个地区降水量的预测。 <br><br><img src="https://habrastorage.org/webt/xc/n_/cf/xcn_cfakd_xnyoxaazxgc4bvmso.jpeg"><br><br> 有一些特殊的天气雷达可以探测2000公里半径内的降水，它们知道其密度和与之的距离。 <br><br><img src="https://habrastorage.org/webt/as/ea/av/aseaavvwl0v3lqhex1kx_dvsr1w.jpeg"><br><br> 使用这些数据并借助机器学习对其进一步运动进行预测，我们在地图上进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了可视化</a>处理。 您可以来回移动。 <br><br><img src="https://habrastorage.org/webt/jt/qo/fj/jtqofjz8eo8wrjybcydczpxse0a.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幻灯片链接</a></sup></sub> </h5><br> 我们查看了人们的评论。 人们喜欢它。 各种各样的模因开始出现，当莫斯科泛滥成灾时，有很酷的画面。 <br><br> 由于每个人都喜欢这种格式，因此我们决定继续进行下面的预测。 <br><br><img src="https://habrastorage.org/webt/kl/mc/_f/klmc_fqnedxn-okos6d6bhmlszs.jpeg"><br><br> 显示天气预报的服务已经在那里。 这是几个杰出的。 <br><br><img src="https://habrastorage.org/webt/vo/vc/4k/vovc4kev5lhxvyph9t46z4uhei8.jpeg"><br><br> 看着他们，我们意识到我们想做同样的事情-或至少不会更糟。 <br><br> 因此，我们决定可视化根据风速在地图上平滑移动的粒子，并留下某种循环以便可以看到它们，并且可以看到风的轨迹。 <br><br> 由于我们已经很棒，并且使用2D画布绘制了一个带有降水的凉爽地图，因此我们决定对粒子进行相同的处理。 <br><br><img src="https://habrastorage.org/webt/hz/jd/yi/hzjdyivbulbjmfod7n2-nix8uca.jpeg"><br><br> 与设计师协商后，我们意识到我们需要在屏幕的约6％处填充颗粒，以达到炫酷效果。 <br><br> 为了使用标准方法绘制这么多的粒子，我们的最小时序为5毫秒。 <br><br><img src="https://habrastorage.org/webt/yu/l1/7n/yul17ngn7dfm6cadtcy2dpkf6zu.jpeg"><br><br> 如果您认为我们仍然需要移动粒子并带来某种美感（例如绘制粒子的尾巴），则可以假设我们将以至少40毫秒的时间掉线以显示流畅的动画，以便每秒至少产生25帧。 <br><br> 问题在于这里每个粒子将被顺序处理。 但是，如果您并行处理它们怎么办？ <br><br> 在一次会议上，“传奇驱逐舰”显示了中央处理器和图形处理器之间的明显区别。 他们推出了一台装有彩弹笔的机器，其任务是用一种颜色画一个笑脸。 在大约10秒钟内，他画了这样一张照片。  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到视频</a> -大约。） <br><br><img src="https://habrastorage.org/webt/kk/pi/cw/kkpicwfdskxnicbu0jb7sowhgfq.jpeg"><br><br><img src="https://habrastorage.org/webt/zd/ka/3a/zdka3al72tgfcavb5yvww_qx2ug.jpeg"><br><br><img src="https://habrastorage.org/webt/i9/tm/kh/i9tmkhykoiz8vkim-vzftxjjl44.jpeg"><br><br> 然后，这些家伙推出了独木舟，这是一个GPU，还有几口喷绘了蒙娜丽莎（Mona Lisa）。 这就是计算CPU和GPU的速度不同的方式。 <br><br><img src="https://habrastorage.org/webt/dm/x-/hc/dmx-hckqzdlztdat2wm-j88cj-k.jpeg"><br><br><img src="https://habrastorage.org/webt/zg/pa/3m/zgpa3m281vzirvjqotbuoqnmms8.jpeg"><br><br><img src="https://habrastorage.org/webt/hq/lf/uj/hqlfujoqgr4mhgxucjpx7xnmedu.jpeg"><br><br><img src="https://habrastorage.org/webt/qb/zo/xz/qbzoxzq0tywqxi0pc2xifdnvnds.jpeg"><br><br><img src="https://habrastorage.org/webt/d6/z5/kq/d6z5kq5c23fjmb2uzfx4aqqj3ec.jpeg"><br><br> 为了利用浏览器中的这些功能，发明了WebGL技术。 <br><br> 这是什么 带着这个问题，我爬上了互联网。 我添加了一些带有粒子动画和风的单词，我发现了几篇文章。 <br><br><img src="https://habrastorage.org/webt/ob/d-/w_/obd-w_edp80lvmzlh3xmh437itw.jpeg"><br><h5>  <sub><sup>幻灯片中的链接： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二</a></sup></sub> </h5><br> 其中之一是Mapbox的工程师Vladimir Agafonkin的演示，他在WebGL上风靡一时，并引用了Chris Wellons的博客，后者谈到了如何在GPU上移动和存储粒子状态。 <br><br> 我们接受并复制。 我们期待这样的结果。 在这里，粒子平滑移动。 <br><br><img src="https://habrastorage.org/webt/s6/5t/7-/s65t7-020jphv-fvyzbk5vpkmoq.jpeg"><br><br> 我们弄不清楚。 <br><br><img src="https://habrastorage.org/webt/7n/8i/t1/7n8it1gwmfklms2akt9nydmgima.jpeg"><br><br> 试图找出代码。 不断改进，但结果仍然不尽人意。 我们爬得更深-我们下雨而不是风。 <br><br><img src="https://habrastorage.org/webt/n4/bd/b1/n4bdb1-ar38mb8lokfjfgjqbrue.jpeg"><br><br> 好吧，我们决定自己做。 <br><br><img src="https://habrastorage.org/webt/lw/ue/kv/lwuekvj_c1996sjj2q1c2fl4pyk.jpeg"><br><br> 要使用WebGL，需要有框架。 它们几乎都是针对3D对象的。 我们不需要这些3D功能。 我们只需要绘制一个粒子并移动它。 因此，我们决定用手做所有事情。 <br><br><img src="https://habrastorage.org/webt/rt/db/4z/rtdb4zokw74ivcedzljp4t3fu_g.jpeg"><br><br> 当前有两个版本的WebGL技术。 第二个版本很酷，它具有高级的编程语言版本，该版本的程序在图形适配器中运行，可以直接执行计算，而不仅仅是绘制。 但是它的兼容性差。 <br><br><img src="https://habrastorage.org/webt/yk/gr/ty/ykgrtypkwclnix0f4pat1retheu.jpeg"><br><br> 好吧，我们决定使用久经考验的WebGL 1，它除了Opera Mini之外还具有很好的支持，而没人需要。 <br><br><img src="https://habrastorage.org/webt/sr/1q/xr/sr1qxr_ch7enl9z1rjwuv1hshpg.jpeg"><br><br>  WebGL是两部分的东西。 这是JS，用于执行在图形卡上运行的程序的状态。 还有直接在图形卡上运行的组件。 <br><br> 让我们从JS开始。  WebGL只是canvas元素的适当上下文。 而且，在接收到该上下文时，不仅分配了特定对象，还分配了铁资源。 而且，如果我们在浏览器上的WebGL上运行漂亮的东西，然后决定播放Quake，那么很可能这些资源会丢失，上下文可能会丢失，并且整个程序都会中断。 <br><br><img src="https://habrastorage.org/webt/y3/bm/p0/y3bmp0fddy1vkxkktxantfrfcdw.jpeg"><br><br> 因此，在使用WebGL时，您还必须倾听上下文的丢失并能够恢复它。 因此，我强调了init是。 <br><br><img src="https://habrastorage.org/webt/aj/iu/zk/ajiuzkpsukwyhrhvte4oduqivri.jpeg"><br><br> 此外，JS的所有工作归结为收集在GPU上运行的程序，向其发送图形卡，设置一些参数并说“ draw”。 <br><br><img src="https://habrastorage.org/webt/3k/2m/zd/3k2mzdhdejzpaxjrx_upik6fdeu.jpeg"><br><br> 在WebGL中，如果您查看上下文元素本身，则会看到一堆常量。 这些常量引用内存中的地址。 它们在程序执行过程中并不是真正恒定的。 因为如果上下文丢失并再次恢复，则可能会分配另一个地址池，并且这些常量对于当前上下文将有所不同。 因此，JS端WebGL中的几乎所有操作都是通过实用程序执行的。 没有人愿意做查找地址和其他垃圾的例行工作。 <br><br><img src="https://habrastorage.org/webt/ii/o7/sa/iio7sahs5z0gt5bccxesgiict44.jpeg"><br><br> 我们来看一下在视频卡本身上执行的操作-一个由两组以类C语言GLSL编写的指令组成的程序。 这些指令称为顶点着色器和片段着色器。 从他们的一对创建一个程序。 <br><br><img src="https://habrastorage.org/webt/qg/fu/lb/qgfulbs6almqwpkmutcsxv38-cm.jpeg"><br><br> 这些着色器之间有什么区别？ 顶点着色器设置应在其上绘制对象的表面。 设置完基元并进行绘制后，将调用落入该范围的片段着色器。 <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br><img src="https://habrastorage.org/webt/u7/vi/qb/u7viqbviwm76x4ovlvion5mm2o8.jpeg"><br><br> 在代码中，它看起来像这样。 着色器有一个部分，用于声明从JS外部设置的变量，并确定其类型和名称。 还有主要部分，该部分执行此迭代所需的代码。 <br><br> 在大多数情况下，期望顶点着色器将gl_Position变量设置为二维空间中的某个坐标。 这是x，y，z和空间的宽度，目前还不需要知道。 <br><br> 片段着色器希望设置特定像素的颜色。 <br><br> 在此示例中，我们从连接的纹理中选择了像素颜色。 <br><br><img src="https://habrastorage.org/webt/y8/nw/1y/y8nw1y1gnwstkv2rgqxatduyuni.jpeg"><br><br> 要将其传输到JS，只需将着色器的源代码包装在变量中即可。 <br><br><img src="https://habrastorage.org/webt/ax/fz/ou/axfzouj0xwui47sftwgdhlcadd0.jpeg"><br><br> 此外，这些变量将转换为着色器。 这是一个WebGL上下文，我们从源代码创建着色器，并行创建一个程序，然后将几个着色器附加到该程序。 我们得到了一个可行的程序。 <br><br> 在途中，我们验证了着色器的编译是否成功，程序是否已成功构建。 我们说您需要使用此程序，因为可以有多个程序用于不同的渲染值。 <br><br> 设置并说平局。 事实证明是这样。 <br><br><img src="https://habrastorage.org/webt/oz/py/ri/ozpyrifyoft_invjrawmmz-_fjg.jpeg"><br><br> 爬得更深。 在顶点着色器中，所有计算都在-1到1的空间中执行，无论输出点的大小如何。 例如，从-1到1的空间可以占据整个屏幕1920x1080。要在屏幕中央绘制一个三角形，您需要绘制一个覆盖坐标0、0的曲面。 <br><br><img src="https://habrastorage.org/webt/4q/yp/ex/4qypexiothorcvzkrk9y_p5v9tk.jpeg"><br><br> 片段着色器在0到1的空间中工作，并且颜色由四个分量显示：R，G，B，Alpha。 <br><br> 以CSS为例，使用百分比时可能会遇到类似的颜色符号。 <br><br><img src="https://habrastorage.org/webt/ys/cn/kn/yscnkn-8x_yg0bl_zknm-42l17q.jpeg"><br><br> 要绘制内容，您需要说出需要绘制哪些数据。 特别是对于三角形，我们定义了三个顶点的类型化数组，每个顶点由三个分量x，y和足够的分量组成。 <br><br> 对于这种情况，顶点着色器看起来像获取当前的一对点，坐标，以及在屏幕上设置此坐标。 在这里，不进行任何转换，就在屏幕上显示了一个点。 <br><br><img src="https://habrastorage.org/webt/up/h_/ya/uph_yasoh3q-99otxdym43zykmw.jpeg"><br><br> 片段着色器可以使用颜色为JS传递的常量着色，也无需进行其他计算。 此外，如果片段着色器中的某些变量是从外部或从先前的着色器传递的，则必须指定准确性。 在这种情况下，中等精度就足够了，几乎总是足够的。 <br><br><img src="https://habrastorage.org/webt/dx/9v/jb/dx9vjbxuiz_swlbl1hlmlb5hmys.jpeg"><br><br> 我们传递给JS。 我们将相同的着色器分配给变量，并声明一个将创建这些着色器的函数。 也就是说，创建了一个着色器，将源注入其中，然后进行了编译。 <br><br><img src="https://habrastorage.org/webt/jf/x3/eg/jfx3eg-hhqsdbmpc378peyi6tym.jpeg"><br><br> 我们制作两个着色器，顶点和片段。 <br><br><img src="https://habrastorage.org/webt/jh/pb/um/jhpbumsovp4-rkstmx9dldtg7ug.jpeg"><br><br> 之后，创建一个程序，将已经编译的着色器上载到该程序。 我们绑定程序是因为着色器可以相互交换变量。 并且在此阶段，将检查这些着色器交换的变量类型的对应关系。 <br><br> 我们说使用这个程序。 <br><br><img src="https://habrastorage.org/webt/7i/hm/rc/7ihmrctum2gyy9cuybn5pr6hcbu.jpeg"><br><br> 接下来，我们创建一个要可视化的顶点列表。  WebGL对于某些变量具有有趣的功能。 要更改特定的数据类型，您需要设置全局上下文以编辑array_buffer，然后将某些内容上传到该地址。 没有任何数据明确分配给变量。 一切都是通过包含一些上下文来完成的。 <br><br> 还必须建立从该缓冲区读取的规则。 可以看出，我们指定了一个由六个元素组成的数组，但是程序需要说明每个顶点都由两个组件组成，其类型为float，这是在最后一行完成的。 <br><br><img src="https://habrastorage.org/webt/js/_j/qe/js_jqevmwlq0fmo_n6-vbdwsr-k.jpeg"><br><br> 要设置颜色，程序将搜索u_color变量的地址并设置该变量的值。 我们将颜色设置为红色255，绿色0.8，蓝色0，完全不透明的像素-它变为黄色。 我们说要使用三角形图元执行该程序，在WebGL中，您可以绘制点，线，三角形，复杂形状的三角形等。 并取得三个高峰。 <br><br><img src="https://habrastorage.org/webt/lk/pz/xe/lkpzxe_tur-bgozsoj47kohstty.jpeg"><br><br> 您还可以指定从一开始就应该对要渲染的数组进行计数。 <br><br><img src="https://habrastorage.org/webt/p4/1f/_k/p41f_kioprwkxx7ommkzz7tcclw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幻灯片链接</a></sup></sub> </h5><br> 如果使示例复杂一点，则可以在光标位置添加颜色依赖性。 同时，每秒帧数穿过屋顶。 <br><br><img src="https://habrastorage.org/webt/sl/eu/zl/sleuzlnxn8s1tlflhawo5obsrg8.jpeg"><br><br> 要绘制世界各地的粒子，您需要了解世界上每个点的风速。 <br><br> 要放大并以某种方式移动地图，您需要创建与地图的当前位置匹配的容器。 <br><br> 要移动粒子本身，您需要提出一种可以使用GPU更新的数据格式。 制作图形本身并绘制循环。 <br><br><img src="https://habrastorage.org/webt/2o/vf/o_/2ovfo_hqaimoyygbbcpkbupf_cu.jpeg"><br><br> 我们通过纹理处理所有数据。 我们使用22个通道来确定水平和垂直速度，其中零风速对应于颜色范围的中间。 大约是128。 由于速度可以为正也可以为负，因此我们将颜色设置为相对于范围的中间值。 <br><br> 事实证明是这样。 <br><br><img src="https://habrastorage.org/webt/3-/qu/i8/3-qui8mkzufp6hucltuzpampili.jpeg"><br><br> 要将其加载到卡上，我们需要对其进行切割。 要将图片连接到地图，我们将使用标准的Yandex.Map图层工具，在其中我们将确定从中切割图块的地址，并将此图层添加到地图中。 <br><br><img src="https://habrastorage.org/webt/jo/zj/a8/jozja8duysio2wljyezgjnhfn64.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幻灯片链接</a></sup></sub> </h5><br> 我们得到一张图片，其中令人不愉快的绿色被编码为风速。 <br><br><img src="https://habrastorage.org/webt/uh/nk/jh/uhnkjh1e8sxzgzp-myix3xxyjn4.jpeg"><br><br> 接下来，您需要找到一个将绘制动画本身的位置，而该位置应对应于地图的坐标，其运动和其他动作。 <br><br> 默认情况下，我们可以假设我们将使用“图层”，但是卡片图层会创建一个画布，并从画布中立即捕获它可以捕获的2D上下文。 但是，如果我们尝试从已经具有不同类型的上下文的画布中获取并从GL上下文中获取，则结果将为null。 如果您访问它，程序将崩溃。 <br><br><img src="https://habrastorage.org/webt/lg/9a/mn/lg9amncxtx9ndmnc7bjqkzcs_lw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幻灯片链接</a></sup></sub> </h5><br> 因此，我们使用Pane，这是布局的容器，并在其中添加了画布，我们已经从中获取了所需的上下文。 <br><br><img src="https://habrastorage.org/webt/v9/on/pb/v9onpb5gnorqq05kg0og8bd6wvq.jpeg"><br><br> 为了以某种方式将粒子排列在屏幕上并能够移动它们，使用了粒子在纹理中的位置格式。 <br><br> 如何运作？ 创建正方形纹理以进行优化，并且在此已知其侧面的大小。 <br><br><img src="https://habrastorage.org/webt/ov/hm/qg/ovhmqgdfgbzg3k5wua7se3l-scm.jpeg"><br><br> 通过按顺序绘制粒子并知道粒子的序列号和存储粒子的纹理的大小，可以计算出特定像素，在其中编码了实际屏幕上的位置。 <br><br><img src="https://habrastorage.org/webt/xw/6c/ly/xw6clysjjqrtppxzih0cm4q3sis.jpeg"><br><br><img src="https://habrastorage.org/webt/a_/jt/9m/a_jt9ml9jdjn0vxxk7riv9sbkw8.jpeg"><br><br> 在着色器本身中，看起来就像读取渲染的索引，带有粒子当前位置和侧面尺寸的纹理。 接下来，我们确定该粒子的x，y坐标，读取该值并将其解码。 这是什么魔术：rg / 255 + ba？ <br><br> 对于粒子的位置，我们使用20个双通道。 颜色通道的值介于0到255之间，对于1080屏幕，我们不能将粒子放置在屏幕的任何位置一会儿，因为我们最多可以将粒子放置在255个像素中。 因此，在一个通道中，我们存储粒子通过255个像素的次数的知识，在第二通道中，我们存储粒子在之后通过多少次的确切值。 <br><br> 接下来，顶点着色器必须将这些值转换为其工作空间，即从-1到1，然后在显示器上设置此点。 <br><br><img src="https://habrastorage.org/webt/g2/ht/g_/g2htg_vqu8k5fdnn_zx6xtl82fs.jpeg"><br><br> 仅查看我们的粒子，只需将其涂成白色即可。  GLSL具有这样的优势，例如，如果我们定义变量的类型并将其传递给常量，则该常量将分布在所有四个组件中。 <br><br><img src="https://habrastorage.org/webt/ee/h-/hz/eeh-hzn9oaitmm7k7gwfpzin8rq.jpeg"><br><br> 绘制了这样一个程序，我们看到了一组相同的正方形。 让我们尝试为它们添加美丽。 <br><br><img src="https://habrastorage.org/webt/-r/ud/i1/-rudi16ytlwsw-_fvafdhqmqync.jpeg"><br><br> 首先，添加这些平方对当前风速的依赖性。 我们只需读取每个粒子的当前速度和相应的纹理即可。 我们获得矢量的长度，该矢量对应于该点的绝对速度，并将该速度添加到粒子大小中。 <br><br><img src="https://habrastorage.org/webt/or/v-/qs/orv-qs0vwvlrcxadmlpvbywokdw.jpeg"><br><br> 此外，为了不绘制正方形，在片段着色器中，我们切掉了不在半径范围内的所有像素，这些像素不包括在内切圆的半径范围内。 也就是说，我们的着色器变成了这样的东西。 <br><br><img src="https://habrastorage.org/webt/t4/rx/ah/t4rxahmunedzb3k0jamjxiikvia.jpeg"><br><br> 我们计算从中心到渲染像素的距离。 如果超过一半的空间，则我们不显示它。 <br><br><img src="https://habrastorage.org/webt/nr/do/ma/nrdomaus-zdhgroynefo3qacxck.jpeg"><br><br> 我们得到了更加多样化的图景。 <br><br> 接下来，您需要以某种方式移动这些内容。 由于WebGL 1不知道如何计算，而是直接处理数据，因此我们将利用将程序绘制到特殊组件（帧缓冲区）中的功能。 <br><br> 帧缓冲区可以映射到例如可以更新的纹理。 如果未声明帧缓冲区，则默认情况下在屏幕上进行绘制。 <br><br> 将输出从一种位置纹理切换到另一种位置纹理，我们可以一个一个地更新它们，然后将其用于渲染。 <br><br><img src="https://habrastorage.org/webt/j7/-j/tn/j7-jtnjwzj-8pav52t-ngiolwji.jpeg"><br><br><img src="https://habrastorage.org/webt/8y/me/ey/8ymeey1havzw-wavn5x8ztr87em.jpeg"><br><br> 更新位置本身的过程如下所示：读取当前位置，将其添加到当前速度矢量中，然后将其添加，编码为新颜色。 <br><br><img src="https://habrastorage.org/webt/t7/up/wj/t7upwjpzr8ubgig0cwr1_hn7npa.jpeg"><br><br> 在代码中，看起来就像读取当前位置，解码，读取当前速度，将速度恢复正常，折叠这两个分量并进行彩色编码。 <br><br><img src="https://habrastorage.org/webt/uo/cc/qo/uoccqo8i2fubmgay3oi90teclzw.jpeg"><br><br> 事实证明是这样。 粒子的状态不断变化，并出现某种动画。 <br><br> 如果将此类动画运行5-10分钟，则很明显所有粒子将到达其最终目的地。 它们都滑入漏斗中。 你得到这样的照片。 <br><br><img src="https://habrastorage.org/webt/be/m0/bx/bem0bxbrxar_it9lgdjdc2fk91y.jpeg"><br><br> 为了避免这种情况，我们在随机的位置引入一个粒子置换因子。 <br><br> 它取决于当前的风速，当前的粒子位置以及我们从JS传输的随机数-因为WebGL的第一个版本没有随机函数和某种噪声函数。 <br><br><img src="https://habrastorage.org/webt/zt/ur/_b/ztur_bhp_epcyqk1kzaz9b1r0a0.jpeg"><br><br> 在此示例中，我们计算粒子的预测位置，随机位置，并根据重置因子选择一个或另一个。 <br><br><img src="https://habrastorage.org/webt/6o/qq/m8/6oqqm8iswgovcsguseunzhwxauc.jpeg"><br><h5>  <sub><sup>幻灯片中的链接： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四</a></sup></sub> </h5><br> 要了解上一张幻灯片的内容，您可以阅读这些文章。 第一种方法极大地增进了对WebGL提供的内容，其组成以及如何避免出错的理解。 在Khronos，这是一个从事标准制定的小组，对所有功能进行了描述。 <br><br><img src="https://habrastorage.org/webt/5u/qi/st/5uqistm5t05pqha9xfm1oqdnxfu.jpeg"><br><br> 我们任务的最后一点是绘制微粒的痕迹。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，就像位置更新纹理一样，我们将以两种纹理在屏幕上记录当前位置，并显示当前位置，稍微增加其透明度，覆盖新的粒子位置，然后一次又一次地增加此图像的透明度最重要的是，我们强加了一个新职位。</font></font><br><br><img src="https://habrastorage.org/webt/es/-8/oa/es-8oakhvm9ds8uh-e7teuivgnk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到了这样的循环动画。</font></font><br><br><img src="https://habrastorage.org/webt/qv/2s/hi/qv2shigmfokikarpx9kzdx0vsck.jpeg"><br><br><img src="https://habrastorage.org/webt/mu/3s/x2/mu3sx2aovopotm_gnyln8to95rm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果将WebGL渲染的整个周期与使用2D画布在屏幕上某些点的显示进行比较，您会发现速度差距很大。</font><font style="vertical-align: inherit;">要在2D画布上绘制6万4千点，平均需要25毫秒，而WebGL阻止主流0.3毫秒。</font><font style="vertical-align: inherit;">这相差一百倍。</font></font><br><br>  ,  WebGL     ,        ,      . <br><br>   , ,    ,   - break points, -  ,   . WebGL —  . <br><br><img src="https://habrastorage.org/webt/6l/ke/u_/6lkeu_xuquuzt8pjc1uj8ckv1fa.jpeg"><br><br>    ,     . ,  Firefox    «»,        WebGL-,    ,    ,     . ,          . <br><br><img src="https://habrastorage.org/webt/w1/0j/vs/w10jvskiqvyvfrvhqwr4mpnu2uk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使生活更加轻松的第二个工具是Spector.js浏览器扩展。</font><font style="vertical-align: inherit;">它还从WebGL上下文中捕获画布，并允许您查看在此画布上执行的所有操作，时序和传递的变量。</font></font><br><br><img src="https://habrastorage.org/webt/o-/gm/sa/o-gmsa_uu9gddh7qzrept9418ne.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在总共一周的工作中，我们从头开始有了一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交钥匙的解决方案</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我希望我能够分辨出WebGL是什么技术，它包含什么，并给出在产品中使用它的真实示例。</font><font style="vertical-align: inherit;">仅此而已。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433278/">https://habr.com/ru/post/zh-CN433278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433268/index.html">PHP电报客户端（并使用MadelineProto接收消息）</a></li>
<li><a href="../zh-CN433270/index.html">用ManyToMany解决MapStruct问题</a></li>
<li><a href="../zh-CN433272/index.html">大卫·戈贝尔访谈</a></li>
<li><a href="../zh-CN433274/index.html">Oleg Dokuka关于jug.msk.ru上的反应式开发</a></li>
<li><a href="../zh-CN433276/index.html">关于将CSS嵌入JS的好处</a></li>
<li><a href="../zh-CN433280/index.html">DEFCON Conference 18.使用数学的Trollim逆向工程</a></li>
<li><a href="../zh-CN433282/index.html">Linux上工业交换协议的网关。 组装你自己</a></li>
<li><a href="../zh-CN433286/index.html">莫斯科10个最近的IT会议和黑客马拉松</a></li>
<li><a href="../zh-CN433288/index.html">Web安全：HTTP简介</a></li>
<li><a href="../zh-CN433292/index.html">＃279号移动开发人员的有趣材料摘要（12月10日至16日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>