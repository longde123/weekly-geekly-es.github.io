<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽 🙂 🐫 Metafisika Injeksi Ketergantungan 🍍 🏉 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dependency Injection adalah teknik yang umum digunakan dalam pemrograman berorientasi objek yang dirancang untuk mengurangi konektivitas komponen. Ket...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metafisika Injeksi Ketergantungan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480364/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/ha/dz/bphadz2idyr738uoocd_ykof4zm.png" alt="gambar"></div><br><br>  Dependency Injection adalah teknik yang umum digunakan dalam pemrograman berorientasi objek yang dirancang untuk mengurangi konektivitas komponen.  Ketika digunakan dengan benar, selain mencapai tujuan ini, itu dapat membawa kualitas yang sangat ajaib untuk aplikasi Anda.  Seperti sihir apa pun, teknik ini dianggap sebagai serangkaian mantra, dan bukan risalah ilmiah yang ketat.  Ini mengarah pada salah tafsir atas fenomena dan, sebagai konsekuensinya, penyalahgunaan artefak.  Dalam materi penulis saya, saya menyarankan agar pembaca selangkah demi selangkah, secara singkat dan intinya, beralih dari dasar yang tepat dari desain berorientasi objek ke keajaiban injeksi ketergantungan otomatis. <br><a name="habracut"></a><br>  Materi ini didasarkan pada pengembangan <a href="https://github.com/cylon-v/hypo" rel="nofollow">wadah Hypo IoC</a> , yang saya sebutkan di <a href="https://habr.com/ru/post/474504/">artikel sebelumnya</a> .  Dalam contoh kode miniatur, saya akan menggunakan Ruby sebagai salah satu bahasa berorientasi objek yang paling ringkas untuk menulis contoh singkat.  Ini seharusnya tidak menyebabkan masalah bagi pengembang dalam bahasa lain untuk mengerti. <br><br><h2>  Level 1: Prinsip Inversi Ketergantungan </h2><br>  Pengembang dalam paradigma berorientasi objek dihadapkan setiap hari dengan penciptaan objek, yang, pada gilirannya, mungkin bergantung pada objek lain.  Ini mengarah ke grafik ketergantungan.  Misalkan kita berhadapan dengan model objek dari bentuk: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ih/b7/vy/ihb7vyogm2d5rt-ugz_udhskzpy.png" alt="gambar"></div><br>  - beberapa layanan penagihan (InvoiceProcessor) dan layanan notifikasi (NotificationService).  Layanan pemrosesan faktur mengirim pemberitahuan ketika kondisi tertentu terpenuhi, kami akan mengambil logika ini di luar ruang lingkup.  Pada prinsipnya, model ini sudah baik karena masing-masing komponen bertanggung jawab atas berbagai tanggung jawab.  Masalahnya terletak pada bagaimana kita menerapkan dependensi ini.  Kesalahan umum adalah menginisialisasi dependensi di mana dependensi ini digunakan: <br><br><pre><code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#      notificationService = NotificationService.new notificationService.notify(invoice.owner) end end</span></span></span></span></code> </pre> <br>  Ini adalah kesalahan mengingat fakta bahwa kita mendapatkan konektivitas tinggi dari objek yang independen secara logis (Kopling Tinggi).  Hal ini menyebabkan pelanggaran terhadap Prinsip Tanggung Jawab Tunggal - sebuah objek dependen, selain tanggung jawab langsungnya, harus menginisialisasi dependensinya;  dan juga "tahu" antarmuka konstruktor dependensi, yang akan mengarah pada alasan tambahan untuk perubahan ( <a href="https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html" rel="nofollow">"alasan untuk berubah", R. Martin</a> ).  Lebih tepat untuk melewatkan dependensi semacam ini, diinisialisasi di luar objek dependen: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">process</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notify</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">owner</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationService</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoiceProcessor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Pendekatan ini konsisten dengan Prinsip Ketergantungan Inversi.  Sekarang kami mentransfer objek dengan antarmuka pengiriman pesan - tidak ada lagi kebutuhan untuk layanan penagihan untuk "tahu" bagaimana membangun objek layanan notifikasi.  Saat menulis pengujian unit untuk layanan pemrosesan faktur, pengembang tidak perlu memikirkan cara mengganti implementasi antarmuka layanan notifikasi dengan sebuah rintisan.  Dalam bahasa dengan pengetikan dinamis, seperti Ruby, Anda dapat mengganti objek apa pun yang memenuhi metode pemberitahuan;  dengan mengetik statis seperti C # / Java, Anda dapat menggunakan antarmuka INotificationService, yang membuatnya mudah untuk membuat Mock.  Masalah inversi ketergantungan diungkapkan secara rinci oleh Alexander Byndyu <a href="https://blog.byndyu.ru/2009/12/blog-post.html" rel="nofollow">dalam sebuah artikel</a> yang baru-baru ini merayakan ulang tahunnya yang ke 10! <br><br><h2>  Level 2: registrasi objek terkait </h2><br>  Menggunakan prinsip inversi ketergantungan tampaknya bukan praktik yang rumit.  Namun seiring waktu, karena peningkatan jumlah objek dan hubungan, tantangan baru muncul.  NotificationService dapat digunakan oleh layanan selain InvoiceProcessor.  Selain itu, ia sendiri dapat bergantung pada layanan lain, yang, pada gilirannya, bergantung pada layanan ketiga, dll.  Juga, beberapa komponen mungkin tidak selalu digunakan dalam satu salinan.  Tugas utama adalah menemukan jawaban untuk pertanyaan - "kapan membuat dependensi?". <br>  Untuk mengatasi masalah ini, Anda dapat mencoba membangun solusi berdasarkan array dependensi asosiatif.  Contoh antarmuka karyanya mungkin terlihat seperti ini: <br><br><pre> <code class="ruby hljs">registry.add(InvoiceProcessor) .depends_on(NotificationService) registry.add(NotificationService) .depends_on(ServiceX) invoiceProcessor = registry.resolve(InvoiceProcessor) invoiceProcessor.process(invoice)</code> </pre><br>  Tidak sulit untuk menerapkannya dalam praktik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rd/bj/v4/rdbjv49agcxw3fhhask4uv5ysew.png" alt="gambar"></div><br>  Setiap kali container.resolve () dipanggil, kami akan beralih ke pabrik, yang akan membuat instance ketergantungan, secara rekursif melewati grafik ketergantungan yang dijelaskan dalam registri.  Dalam kasus `container.resolve (InvoiceProcessor)`, berikut ini akan dieksekusi: <br><br><ol><li>  factory.resolve (InvoiceProcessor) - pabrik meminta dependensi InvoiceProcessor dalam register, menerima NotificationService, yang juga perlu dirakit. </li><li>  factory.resolve (NotificationService) - pabrik meminta dependensi NotificationService dalam register, menerima ServiceX, yang juga perlu dirakit. </li><li>  factory.resolve (ServiceX) - tidak memiliki dependensi, membuat, mengembalikan tumpukan panggilan ke langkah 1, dapatkan objek rakitan tipe InvoiceProcessor. </li></ol><br>  Setiap komponen mungkin bergantung pada beberapa yang lain, jadi pertanyaan yang jelas adalah "bagaimana mencocokkan parameter desainer dengan contoh ketergantungan yang dihasilkan?".  Contoh: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">notificationService</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">paymentService</span></span></span><span class="hljs-class">) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment"># ... end end</span></span></span></span></code> </pre><br>  Dalam bahasa dengan pengetikan statis, tipe parameter dapat berfungsi sebagai pemilih: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(notificationService: NotificationService, paymentService: PaymentService) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br>  Di dalam Ruby, Anda dapat menggunakan konvensi - cukup gunakan nama jenis dalam format snake_case, ini akan menjadi nama parameter yang diharapkan. <br><br><h2>  Level 3: manajemen ketergantungan seumur hidup </h2><br>  Kami sudah mendapat solusi manajemen ketergantungan yang baik.  Satu-satunya batasan adalah kebutuhan untuk membuat instance baru dari ketergantungan dengan setiap panggilan.  Tetapi bagaimana jika kita tidak dapat membuat lebih dari satu instance komponen?  Misalnya, kumpulan koneksi ke database.  Gali lebih dalam, dan jika kita perlu menyediakan masa ketergantungan yang terkendali?  Misalnya, tutup koneksi ke database setelah penyelesaian permintaan HTTP. <br>  Menjadi jelas bahwa kandidat untuk penggantian dalam solusi asli adalah InstanceFactory.  Grafik yang diperbarui: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hf/ed/xl/hfedxlxxnqjmm22oevtbwqrle2k.png" alt="gambar"></div><br>  Dan solusi logisnya adalah menggunakan seperangkat strategi ( <a href="https://refactoring.guru/ru/design-patterns/strategy" rel="nofollow">Strategi, GoF</a> ) untuk mendapatkan komponen contoh.  Sekarang kami tidak selalu membuat instance baru ketika memanggil Container :: resolve, jadi pantas untuk mengubah nama Factory menjadi Resolver.  Harap dicatat bahwa metode Container :: register memiliki parameter baru - life_time (seumur hidup).  Parameter ini opsional - secara default nilainya “sementara” (transient), yang sesuai dengan perilaku yang diterapkan sebelumnya.  Strategi tunggal juga jelas - dengan penggunaannya hanya satu contoh komponen dibuat, yang akan dikembalikan setiap waktu. <br>  Lingkup adalah strategi yang sedikit lebih kompleks.  Alih-alih "jalur sementara" dan "penyendiri," sering diperlukan untuk menggunakan sesuatu di antaranya - komponen yang ada sepanjang kehidupan komponen lain.  Contoh serupa dapat berupa objek permintaan aplikasi web, yang merupakan konteks keberadaan objek seperti, misalnya, parameter HTTP, koneksi database, agregat model.  Sepanjang kehidupan permintaan, kami mengumpulkan dan menggunakan dependensi ini, dan setelah kehancurannya, kami berharap bahwa semuanya juga akan dihancurkan.  Untuk mengimplementasikan fungsionalitas seperti itu, perlu untuk mengembangkan struktur objek yang cukup kompleks: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vd/97/hh/vd97hhi_p41keoxph7ku9sdxrdm.png" alt="gambar"></div><br>  Diagram menunjukkan sebuah fragmen yang mencerminkan perubahan dalam kelas Component dan LifetimeStrategy dalam konteks implementasi Seumur Hidup Scoped.  Hasilnya adalah semacam "jembatan ganda" (mirip dengan <a href="https://refactoring.guru/ru/design-patterns/bridge" rel="nofollow">jembatan,</a> templat <a href="https://refactoring.guru/ru/design-patterns/bridge" rel="nofollow">GoF</a> ).  Menggunakan seluk-beluk teknik pewarisan dan agregasi, Komponen menjadi inti dari wadah.  Omong-omong, diagram tersebut memiliki banyak pewarisan.  Jika bahasa pemrograman dan hati nurani mengizinkannya, Anda dapat membiarkannya demikian.  Di Ruby saya menggunakan pengotor, dalam bahasa lain Anda bisa mengganti warisan dengan jembatan lain: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ri/dj/h7/ridjh7shgaolxp_mxujgvkueta4.png" alt="gambar"></div><br>  Diagram urutan menunjukkan siklus hidup komponen sesi, yang terkait dengan masa pakai komponen permintaan: <br><br><img src="https://habrastorage.org/webt/-c/im/bt/-cimbtr3sktosriryzoyrtqxht4.png" alt="gambar"><br><br>  Seperti yang dapat Anda lihat dari diagram, pada titik waktu tertentu, ketika komponen permintaan menyelesaikan misinya, metode pelepasan disebut, yang memulai proses penghancuran ruang lingkup. <br><br><h2>  Level 4: Injeksi Ketergantungan </h2><br>  Sampai sekarang, saya berbicara tentang cara menentukan registri dependensi, dan kemudian bagaimana membuat dan menghancurkan komponen sesuai dengan grafik relasi yang dibentuk.  Dan untuk apa ini?  Misalkan kita menggunakan ini sebagai bagian dari Ruby on Rails: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceController</span></span></span><span class="hljs-class"> &lt; ApplicationController </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceRepository</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">registry</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resolve</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvoiceProcessor</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_repository</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">params</span></span></span><span class="hljs-class">[:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">]) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice_processor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pay</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">invoice</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  Kode yang akan ditulis dengan cara ini tidak akan lebih mudah dibaca, diuji, atau fleksibel.  Kita tidak bisa "memaksa" Rails untuk menyuntikkan dependensi controller melalui konstruktornya, ini tidak disediakan oleh framework.  Tetapi, misalnya, dalam ASP.NET MVC ini diterapkan pada tingkat dasar.  Untuk mendapatkan hasil maksimal dari menggunakan mekanisme resolusi dependensi otomatis, Anda perlu menerapkan teknik Inversion of Control (IoC, inversion of control).  Ini adalah pendekatan di mana tanggung jawab untuk menyelesaikan dependensi melampaui ruang lingkup kode aplikasi dan berada pada kerangka kerja.  Pertimbangkan sebuah contoh. <br>  Bayangkan kita sedang merancang sesuatu seperti Rails dari awal.  Kami menerapkan skema berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/bg/bh/y1bgbh_27yevoryv4ntb58nej9w.png" alt="gambar"></div><br>  Aplikasi menerima permintaan, router mengambil parameter dan memerintahkan pengontrol yang sesuai untuk memproses permintaan ini.  Skema seperti itu secara kondisional menyalin perilaku kerangka kerja web yang khas dengan hanya sedikit perbedaan - wadah IoC terlibat dalam menciptakan dan mengimplementasikan dependensi.  Tapi di sini muncul pertanyaan, di mana wadah itu sendiri dibuat?  Untuk mencakup sebanyak mungkin objek aplikasi masa depan, kerangka kerja kami harus membuat wadah pada tahap awal operasinya.  Jelas, tidak ada tempat yang lebih cocok daripada aplikasi pembangun aplikasi.  Ini juga merupakan tempat paling cocok untuk mengonfigurasi semua dependensi: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   - ,      . def initialize </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = Container.new </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Controller) .using_lifetime(:transient) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(InvoiceService) .using_lifetime(:singleton) # ,     </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> .register(Router) .using_lifetime(:singleton) #  end #     -     , #      . def call(env) router = </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@container</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.resolve(Router) router.handle(env.path, env.method, env.params) end end</span></span></span></span></code> </pre><br>  Aplikasi apa pun memiliki titik masuk, misalnya, metode utama.  Dalam contoh ini, titik masuk adalah metode panggilan.  Tujuan dari metode ini adalah untuk memanggil router untuk memproses permintaan yang masuk.  Titik masuk harus menjadi satu-satunya tempat untuk memanggil wadah secara langsung - sejak saat itu wadah harus pergi di pinggir jalan, semua sihir berikutnya harus terjadi "di bawah tenda".  Implementasi controller dalam arsitektur seperti itu benar-benar terlihat tidak biasa.  Terlepas dari kenyataan bahwa kami tidak membuat instantiate secara eksplisit, ia memiliki konstruktor dengan parameter: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   . #    . def initialize(invoice_service) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service = invoice_service end def create_invoice(params) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@invoice</span></span></span></span><span class="hljs-class"><span class="hljs-comment">_service.create(params) end end</span></span></span></span></code> </pre><br>  Lingkungan "memahami" cara membuat instance pengontrol.  Ini dimungkinkan berkat mekanisme injeksi ketergantungan yang disediakan oleh wadah IoC yang tertanam di jantung aplikasi web.  Dalam konstruktor controller Anda sekarang dapat mendaftar semua yang diperlukan untuk operasinya.  Yang utama adalah bahwa komponen yang sesuai terdaftar dalam wadah.  Sekarang mari kita beralih ke implementasi router: <br><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Router</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#         -  #      #     . def initialize(controller) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = controller end def handle(path, method, params) #  ""- if path == '/invoices' &amp;&amp; method == 'POST' </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span></span><span class="hljs-class"><span class="hljs-comment">.create(params) end end end</span></span></span></span></code> </pre><br>  Perhatikan bahwa Router bergantung pada pengontrol.  Jika kita mengingat pengaturan ketergantungan, maka Controller adalah komponen yang berumur pendek, dan Router adalah penyendiri yang konstan.  Bagaimana ini bisa terjadi?  Jawabannya adalah bahwa komponen bukan turunan dari kelas yang sesuai, karena terlihat secara eksternal.  Bahkan, ini adalah objek proxy ( <a href="https://refactoring.guru/ru/design-patterns/proxy" rel="nofollow">Proxy, GoF</a> ) dengan contoh metode pabrik ( <a href="https://refactoring.guru/ru/design-patterns/factory-method" rel="nofollow">Metode Pabrik, GoF</a> );  mereka mengembalikan instance komponen sesuai dengan strategi yang ditugaskan.  Karena Kontroler terdaftar sebagai "sementara", Router akan selalu menangani instance baru ketika diakses.  Diagram urutan menunjukkan perkiraan mekanisme kerja: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/ng/1y/tlng1yrikuvxkenacsx-gy0x7mu.png" alt="gambar"></div><br>  Yaitu  Selain manajemen ketergantungan, kerangka kerja yang baik berdasarkan wadah IoC juga bertanggung jawab atas pengelolaan masa pakai komponen yang benar. <br><br><h2>  Kesimpulan </h2><br>  Teknik Injeksi Ketergantungan dapat memiliki implementasi internal yang cukup canggih.  Ini adalah harga untuk mentransfer kompleksitas penerapan aplikasi fleksibel ke inti kerangka kerja.  Pengguna kerangka kerja seperti itu tidak dapat khawatir tentang aspek teknis semata, tetapi mencurahkan lebih banyak waktu untuk pengembangan nyaman logika bisnis program aplikasi.  Menggunakan implementasi DI berkualitas tinggi, seorang programmer aplikasi awalnya menulis kode yang dapat diuji dan didukung dengan baik.  Contoh yang baik dari implementasi Ketergantungan Injeksi adalah kerangka <a href="https://github.com/cylon-v/dandy" rel="nofollow">Dandy yang</a> dijelaskan dalam artikel saya sebelumnya <a href="https://habr.com/ru/post/474504/">Orthodox Backend</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480364/">https://habr.com/ru/post/id480364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480352/index.html">Ahli genetika Harvard mengembangkan prototipe aplikasi kencan DNA analisis</a></li>
<li><a href="../id480354/index.html">Memulai dengan metode array JavaScript .map (), .filter () dan .reduce ()</a></li>
<li><a href="../id480356/index.html">Tips Python Berguna Anda Belum Bertemu</a></li>
<li><a href="../id480358/index.html">Harga tersembunyi perpustakaan CSS-in-JS di Bereaksi aplikasi</a></li>
<li><a href="../id480362/index.html">Petualangan Jerman menipis uranium hexafluoride di Rusia. Bagian 1. Sejarah dan teknologi pengayaan</a></li>
<li><a href="../id480368/index.html">Menangkap kebocoran memori dalam C / C ++</a></li>
<li><a href="../id480370/index.html">Konferensi DEFCON 19. Para bos menyukai Excel, peretas juga</a></li>
<li><a href="../id480374/index.html">Bereaksi Robot 'Mengejar Revolusi di Industri Konstruksi</a></li>
<li><a href="../id480376/index.html">Dari permainan komputer hingga pesan rahasia: bahas telur Paskah dalam rilis vinil</a></li>
<li><a href="../id480378/index.html">14 proyek sumber terbuka untuk memompa keterampilan Ilmu Data (mudah, normal, sulit)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>