<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏽 👩‍❤️‍👨 🚲 Génération de code dans Uber 🙇🏿 📘 🤦🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chacun de nous fait une corvée. Tout le monde écrit du code passe-partout. Pourquoi? N'est-il pas préférable d'automatiser ce processus et de travaill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Génération de code dans Uber</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/e-Legion/blog/413603/">  Chacun de nous fait une corvée.  Tout le monde écrit du code passe-partout.  Pourquoi?  N'est-il pas préférable d'automatiser ce processus et de travailler uniquement sur des tâches intéressantes?  Lisez cet article si vous souhaitez que l'ordinateur effectue un tel travail pour vous. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/144/cb5/052/144cb5052ca1830f2aac609dc3cc93c0.jpg" alt="image"></a> <br><br>  <i>Cet article est basé sur une transcription d'un rapport de Zack Sweers, développeur d'applications mobiles Uber, qui a pris la parole lors de la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MBLT DEV</a> en 2017.</i> <i><br></i> <br><a name="habracut"></a>  Uber compte environ 300 développeurs d'applications mobiles.  Je travaille dans une équipe appelée «plateforme mobile».  Le travail de mon équipe est de simplifier et d'améliorer au maximum le processus de développement d'applications mobiles.  Nous travaillons principalement sur les frameworks internes, les bibliothèques, les architectures, etc.  En raison de l'effectif important, nous devons réaliser des projets à grande échelle dont nos ingénieurs auront besoin à l'avenir.  Ce peut être demain, ou peut-être le mois prochain ou même un an. <br><br><h3>  Génération de code pour l'automatisation </h3><br>  Je voudrais démontrer la valeur du processus de génération de code, ainsi que considérer quelques exemples pratiques.  Le processus lui-même ressemble à ceci: <br><br><pre><code class="hljs python">FileSpec.builder(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Presentation"</span></span>) .addComment(<span class="hljs-string"><span class="hljs-string">"Code generating your way to happiness."</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addMember</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"%S"</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-class"><span class="hljs-params"><span class="hljs-string">"Zac Sweers"</span></span></span></span><span class="hljs-class"><span class="hljs-params">)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useSiteTarget</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(FILE)</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span></span></code> </pre> <br>  Ceci est un exemple d'utilisation de Kotlin Poet.  Kotlin Poet est une bibliothèque avec une bonne API qui génère du code Kotlin.  Alors que voit-on ici? <br><br><ol><li>  <b>FileSpec.builder</b> crée un fichier appelé « <b>Présentation</b> ». </li><li>  <b>.addComment ()</b> - Ajoute un commentaire au code généré. </li><li>  <b>.addAnnotation ()</b> - Ajoute une annotation de type <b>Auteur</b> . </li><li>  <b>.addMember ()</b> - ajoute une variable " <b>nom</b> " avec un paramètre, dans notre cas c'est " <b>Zac Sweers</b> ".  <b>% S</b> - type de paramètre. </li><li>  <b>.useSiteTarget ()</b> - Installe SiteTarget. </li><li>  <b>.build ()</b> - complète la description du code qui sera généré. </li></ol><br>  Après la génération de code, les éléments suivants sont obtenus: <br><br><pre> <code class="hljs pgsql">Presentation.kt // Code generating your way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> happiness. @file:Author(<span class="hljs-type"><span class="hljs-type">name</span></span> = "Zac Sweers")</code> </pre> <br>  Le résultat de la génération de code est un fichier avec le nom, le commentaire, l'annotation et le nom de l'auteur.  La question se pose immédiatement: "Pourquoi dois-je générer ce code si je peux le faire en quelques étapes simples?"  Oui, vous avez raison, mais que faire si j'ai besoin d'un millier de ces fichiers avec différentes options de configuration?  Que se passe-t-il si nous commençons à modifier les valeurs de ce code?  Et si nous avons plusieurs présentations?  Et si nous avons beaucoup de conférences? <br><br><pre> <code class="hljs pgsql">conferences .flatMap { it.presentations } .onEach { (presentationName, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>, author) -&gt; FileSpec.builder("", presentationName) .addComment(<span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>) .addAnnotation(AnnotationSpec.builder(Author::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) .addMember("name", "%S", author) .useSiteTarget(FILE) .build()) .build() }</code> </pre><br>  En conséquence, nous arriverons à la conclusion qu'il est tout simplement impossible de maintenir un tel nombre de fichiers manuellement - il est nécessaire d'automatiser.  Par conséquent, le premier avantage de la génération de code est de se débarrasser du travail de routine. <br><br><h3>  Génération de code sans erreur </h3><br>  Le deuxième avantage important de l'automatisation est un fonctionnement sans erreur.  Tout le monde fait des erreurs.  Cela se produit surtout souvent lorsque nous faisons la même chose.  Les ordinateurs, au contraire, font parfaitement ce travail. <br><br>  Prenons un exemple simple.  Il existe une classe Personne: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String)</code> </pre><br>  Supposons que nous voulons lui ajouter de la sérialisation en JSON.  Nous le ferons en utilisant la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Moshi</b></a> , car elle est assez simple et idéale pour la démonstration.  Créez un PersonJsonAdapter et héritez de JsonAdapter avec un paramètre de type Person: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { }</code> </pre><br>  Ensuite, nous implémentons la méthode fromJson.  Il fournit un lecteur pour lire les informations qui seront finalement retournées à la personne.  Ensuite, nous remplissons les champs avec le prénom et le nom et obtenons la nouvelle valeur de Personne: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Ensuite, nous regardons les données au format JSON, les vérifions et les entrons dans les champs nécessaires: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  Est-ce que cela fonctionnera?  Oui, mais il y a une nuance: les objets que nous lisons doivent être contenus dans JSON.  Afin de filtrer les données excédentaires pouvant provenir du serveur, ajoutez une autre ligne de code: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonJsonAdapter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JsonAdapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Person</span></span></span><span class="hljs-class">&gt;</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromJson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reader: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">JsonReader</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Person? { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstName: String <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastName: String <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (reader.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (reader.nextName()) { <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> -&gt; firstName = reader.nextString() <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> -&gt; lastName = reader.nextString() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; reader.skipValue() } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Person(firstName, lastName) } }</code> </pre><br>  À ce stade, nous avons réussi à contourner le domaine du code de routine.  Dans cet exemple, seulement deux champs de valeur.  Cependant, ce code a un tas de sections différentes où vous pourriez soudainement tomber en panne.  Soudain, nous avons fait une erreur dans le code? <br><br>  Prenons un autre exemple: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> country: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> licensePlate: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> address: Address) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> type: String) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numStars: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Correctness</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> confidence: <span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>)</code> </pre><br>  Si vous avez au moins un problème tous les 10 modèles environ, cela signifie que vous aurez certainement des difficultés dans ce domaine.  Et c'est le cas lorsque la génération de code peut vraiment vous être utile.  S'il y a beaucoup de classes, vous ne pourrez pas travailler sans automatisation, car tout le monde autorise les fautes de frappe.  Avec l'aide de la génération de code, toutes les tâches seront effectuées automatiquement et sans erreur. <br><br>  La génération de code présente d'autres avantages.  Par exemple, il donne des informations sur le code ou vous indique si quelque chose ne va pas.  La génération de code sera utile pendant la phase de test.  Si vous utilisez le code généré, vous pouvez voir à quoi ressemblera réellement le code de travail.  Vous pouvez même exécuter la génération de code pendant les tests pour simplifier votre travail. <br><br>  Conclusion: il vaut la peine de considérer la génération de code comme une solution possible pour se débarrasser des erreurs. <br><br>  Examinons maintenant les outils logiciels qui aident à la génération de code. <br><br><h3>  Les outils </h3><br><ol><li>  Les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>bibliothèques</b></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>JavaPoet</b></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>KotlinPoet</b></a> pour Java et Kotlin, respectivement.  Ce sont les normes de génération de code. </li><li>  Patternisation.  Un exemple populaire de modèles pour Java est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Apache Velocity</b></a> et pour les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>guidons</b></a> iOS. </li><li>  <b>SPI</b> - Interface du processeur de service.  Il est intégré à Java et vous permet de créer et d'appliquer une interface, puis de la déclarer dans un JAR.  Lorsque le programme est exécuté, vous pouvez obtenir toutes les implémentations prêtes à l'emploi de l'interface. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Compile Testing</b></a> est une bibliothèque de Google qui aide aux tests de compilation.  En termes de génération de code, cela signifie: "Voici ce que j'attendais, mais voici ce que j'ai finalement obtenu."  La compilation démarrera en mémoire, puis le système vous dira si ce processus s'est terminé ou quelles erreurs se sont produites.  Si la compilation est terminée, il vous sera demandé de comparer le résultat avec vos attentes.  La comparaison est basée sur le code compilé, alors ne vous inquiétez pas de choses comme la mise en forme du code ou toute autre chose. </li></ol><br><h3>  Outils de création de code </h3><br>  Il existe deux outils principaux pour créer du code: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Traitement des annotations</b></a> - vous pouvez écrire des annotations dans le code et demander au programme des informations supplémentaires à leur sujet.  Le compilateur fournira des informations avant même d'avoir fini de travailler avec le code source. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Gradle</b></a> est un système d'assemblage d'applications avec de nombreux hooks (hook - interception d'appels de fonction) dans son cycle de vie d'assembly de code.  Il est largement utilisé dans le développement Android.  Il vous permet également d'appliquer la génération de code au code source, qui est indépendant de la source actuelle. </li></ol><br>  Considérons maintenant quelques exemples. <br><br><h3>  Couteau à beurre </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Butter Knife</b></a> est une bibliothèque développée par Jake Wharton.  Il est une figure bien connue de la communauté des développeurs.  La bibliothèque est très populaire parmi les développeurs Android car elle permet d'éviter la grande quantité de travail de routine auquel presque tout le monde est confronté. <br><br>  Habituellement, nous initialisons la vue de cette façon: <br><br><pre> <code class="java hljs">TextView title; ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ title = findViewById(R.id.title); icon = findViewById(R.id.icon); }</code> </pre><br>  Avec Butterknife, cela ressemblera à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Et nous pouvons facilement ajouter un nombre illimité de vues, tandis que la méthode onCreate n'augmentera pas le code passe-partout: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.text) TextView text; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.icon) ImageView icon; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.button) Button button; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.next) Button next; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.back) Button back; <span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.open) Button open; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ ButterKnife.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Au lieu d'effectuer manuellement cette liaison à chaque fois, vous ajoutez simplement des annotations @BindView à ces champs, ainsi que les identifiants (ID) auxquels ils sont affectés. <br><br>  La chose intéressante à propos de Butter Knife est qu'il va analyser le code et générer toutes ses sections similaires pour vous.  Il a également une excellente évolutivité pour les nouvelles données.  Par conséquent, si de nouvelles données apparaissent, il n'est pas nécessaire de réappliquer onCreate ou de suivre quelque chose manuellement.  Cette bibliothèque est également idéale pour supprimer des données. <br><br>  Alors, à quoi ressemble ce système de l'intérieur?  La vue est recherchée par reconnaissance de code et ce processus est effectué au stade du traitement des annotations. <br><br>  Nous avons ce domaine: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BindView</span></span>(R.id.title) TextView title;</code> </pre><br>  A en juger par ces données, elles sont utilisées dans une certaine FooActivity: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(R.id.title) TextView title;</span></span></code> </pre><br>  Elle a sa propre signification (R.id.title), qui agit comme la cible.  Veuillez noter que lors du traitement des données, cet objet devient une valeur constante à l'intérieur du système: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// FooActivity @BindView(2131361859) TextView title;</span></span></code> </pre><br>  C'est normal.  C'est à cela que Butter Knife devrait avoir accès de toute façon.  Il existe un composant TextView en tant que type.  Le champ lui-même est appelé titre.  Si, par exemple, nous créons une classe de conteneur à partir de ces données, nous obtenons quelque chose comme ceci: <br><br><pre> <code class="java hljs">ViewBinding( target = <span class="hljs-string"><span class="hljs-string">"FooActivity"</span></span>, id = <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, name = <span class="hljs-string"><span class="hljs-string">"title"</span></span>, type = <span class="hljs-string"><span class="hljs-string">"field"</span></span>, viewType = TextView.class )</code> </pre><br>  Ainsi, toutes ces données peuvent être facilement obtenues lors de leur traitement.  Il est également très similaire à ce que fait Butter Knife à l'intérieur du système. <br><br>  En conséquence, cette classe est générée ici: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unbinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FooActivity target; <span class="hljs-meta"><span class="hljs-meta">@UiThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooActivity_ViewBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FooActivity target, View source)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; target.title = Utils.findRequiredViewAsType(source, <span class="hljs-number"><span class="hljs-number">2131361859</span></span>, <span class="hljs-comment"><span class="hljs-comment">// R.id.title "field 'title'", TextView.class); } }</span></span></code> </pre><br>  Nous voyons ici que toutes ces données sont rassemblées.  Par conséquent, nous avons la classe cible ViewBinding de la bibliothèque java Underscore.  À l'intérieur, ce système est organisé de telle manière que chaque fois que vous créez une instance de la classe, il exécute immédiatement toutes ces liaisons aux informations (code) que vous avez générées.  Et tout cela est précédemment généré statiquement lors du traitement des annotations, ce qui signifie qu'il est techniquement correct. <br><br>  Revenons à notre pipeline de logiciels: <br><br><img src="https://habrastorage.org/webt/t3/d3/jv/t3d3jv5bxgx5q3occc3ldovxfjm.png"><br><br>  Pendant le traitement des annotations, le système lit ces annotations et génère la classe ViewBinding.  Et puis pendant la méthode de liaison, nous effectuons une recherche identique pour la même classe d'une manière simple: nous prenons son nom et ajoutons le ViewBinding à la fin.  En soi, une section avec un ViewBinding pendant le traitement est écrasée dans la zone spécifiée à l'aide de JavaPoet. <br><br><h3>  Rxbindings </h3><br>  RxBindings seul n'est pas responsable de la génération de code.  Il ne gère pas les annotations et n'est pas un plugin Gradle.  Ceci est une bibliothèque ordinaire.  Il fournit des usines statiques basées sur le principe de la programmation réactive pour l'API Android.  Cela signifie que, par exemple, si vous avez setOnClickListener, une méthode de clic apparaîtra qui retournera un flux d'événements (observables).  Il agit comme un pont (modèle de conception). <br><br>  Mais en réalité, il existe une génération de code dans RxBinding: <br><br><img src="https://habrastorage.org/webt/ju/ty/bv/jutybv1ayxqhcfrs9l4virsivb8.png"><br><br>  Dans ce répertoire appelé buildSrc, il y a une tâche Gradle appelée KotlinGenTask.  Cela signifie que tout cela est réellement créé par la génération de code.  RxBinding a des implémentations Java.  Elle possède également des artefacts Kotlin qui contiennent des fonctions d'extension pour tous les types de cibles.  Et tout cela est très strictement soumis aux règles.  Par exemple, vous pouvez générer toutes les fonctions d'extension de Kotlin et vous n'avez pas besoin de les contrôler individuellement. <br><br>  À quoi ça ressemble vraiment? <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Voici une méthode RxBinding complètement classique.  Les objets observables sont retournés ici.  La méthode s'appelle les clics.  Le travail avec les événements de clic a lieu «sous le capot».  Nous omettons les fragments de code supplémentaires pour maintenir la lisibilité de l'exemple.  À Kotlin, cela ressemble à ceci: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;Object&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Cette fonction d'extension renvoie des objets observables.  Dans la structure interne du programme, il appelle directement l'interface Java habituelle pour nous.  Dans Kotlin, vous devez changer cela en Type d'unité: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Autrement dit, en Java, cela ressemble à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Observable&lt;Object&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View view)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewClickObservable(view); }</code> </pre><br>  Et le code Kotlin aussi: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br>  Nous avons une classe RxView qui contient cette méthode.  Nous pouvons remplacer les données correspondantes dans l'attribut cible, dans l'attribut name par le nom de la méthode et dans le type que nous développons, ainsi que dans le type de la valeur de retour.  Toutes ces informations seront suffisantes pour commencer à écrire ces méthodes: <br><br><pre> <code class="hljs pgsql">BindingMethod( target = "RxView", <span class="hljs-type"><span class="hljs-type">name</span></span> = "clicks", <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, returnType = "Observable&lt;Unit&gt;" )</code> </pre><br>  Maintenant, nous pouvons directement substituer ces fragments dans le code Kotlin généré à l'intérieur du programme.  Voici le résultat: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clicks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Observable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt; = RxView.clicks(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre><br><h3>  Service gen </h3><br>  Nous travaillons sur Service Gen chez Uber.  Si vous travaillez dans une entreprise et que vous traitez avec des caractéristiques générales et une interface logicielle commune pour le backend et le côté client, que vous développiez des applications Android, iOS ou Web, cela n'a aucun sens de créer manuellement des modèles et des services pour le travail d'équipe. <br><br>  Nous utilisons la bibliothèque <a href=""><b>AutoValue</b></a> de Google pour les modèles d'objets.  Il traite les annotations, analyse les données et génère un code de hachage sur deux lignes, la méthode equals () et d'autres implémentations.  Elle est également responsable du support des extensions. <br><br>  Nous avons un objet de type Rider: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Nous avons des lignes avec ID, prénom, nom et adresse.  Pour travailler avec le réseau, nous utilisons les bibliothèques Retrofit et OkHttp, et JSON comme format de données.  Nous utilisons également RxJava pour la programmation réactive.  Voici à quoi ressemble notre service API généré: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/rider"</span></span></span><span class="hljs-meta">)</span></span> Rider getRider() }</code> </pre><br>  Nous pouvons écrire tout cela manuellement, si nous le souhaitons.  Et pendant une longue période, nous l'avons fait.  Mais cela prend beaucoup de temps.  Au final, cela coûte cher en temps et en argent. <br><br><h3>  Quoi et comment Uber fait aujourd'hui </h3><br>  La dernière tâche de mon équipe est de créer un éditeur de texte à partir de zéro.  Nous avons décidé de ne plus écrire manuellement le code qui frappe ensuite le réseau, nous utilisons donc <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Thrift</b></a> .  C'est quelque chose comme un langage de programmation et un protocole à la fois.  Uber utilise Thrift comme langage pour les spécifications techniques. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string uuid; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string firstName; <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> string lastName; <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">optional</span></span> <span class="hljs-type"><span class="hljs-type">Address</span></span> address; }</code> </pre><br>  Dans Thrift, nous définissons des contrats API entre le backend et le côté client, puis générons simplement le code approprié.  Nous utilisons la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>Thrifty</b></a> pour analyser les données et JavaPoet pour la génération de code.  À la fin, nous générons des implémentations à l'aide d'AutoValue: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Nous faisons tout le travail en JSON.  Il existe une extension appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>AutoValue Moshi</b></a> , qui peut être ajoutée aux classes AutoValue à l'aide de la méthode statique jsonAdapter: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@AutoValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uuid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">firstName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> Address </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonAdapter&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsonAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Moshi moshi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoValue_Rider.JsonAdapter(moshi); } }</code> </pre> <br>  Thrift contribue également au développement de services: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() }</code> </pre><br>  Nous devons également ajouter quelques métadonnées ici pour nous faire savoir quel résultat final nous voulons atteindre: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">service</span></span> UberService { <span class="hljs-attribute"><span class="hljs-attribute">Rider</span></span> getRider() (path=<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) }</code> </pre><br>  Après la génération du code, nous recevrons notre service: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UberService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET</span></span>(<span class="hljs-string"><span class="hljs-string">"/rider"</span></span>) <span class="hljs-function"><span class="hljs-function">Single&lt;Rider&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRider</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Mais ce n'est là qu'un des résultats possibles.  Un modèle.  Comme nous le savons par expérience, personne n'a jamais utilisé un seul modèle.  Nous avons de nombreux modèles qui génèrent du code pour nos services: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rider</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vehicle</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Restaurant</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Payment</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TipAmount</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rating</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">// And 6000 more</span></span></code> </pre><br>  En ce moment, nous avons environ 5-6 applications.  Et ils ont de nombreux services.  Et tout le monde passe par le même pipeline de logiciels.  Écrire tout cela à la main serait fou. <br><br>  Dans la sérialisation en JSON, «l'adaptateur» n'a pas besoin d'être enregistré dans Moshi, et si vous utilisez JSON, vous n'avez pas besoin de vous inscrire dans JSON.  Il est également douteux de proposer aux salariés de réaliser la désérialisation en réécrivant le code via un graphe DI. <br><br>  Mais nous travaillons avec Java, nous pouvons donc utiliser le modèle Factory, que nous générons via la bibliothèque <b>Fractory</b> .  Nous pouvons générer cela parce que nous connaissons ces types avant la compilation.  Fractory génère un adaptateur comme celui-ci: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelsAdapterFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonAdapter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> JsonAdapter&lt;?&gt; create(Type type, Set&lt;? extends Annotation&gt; annotations, Moshi moshi) { Class&lt;?&gt; rawType = Types.getRawType(type); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Rider.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Rider.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(City.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> City.adapter(moshi); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rawType.isAssignableFrom(Vehicle.class)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vehicle.adapter(moshi); } <span class="hljs-comment"><span class="hljs-comment">// Etc etc return null; } }</span></span></code> </pre><br>  Le code généré n'a pas l'air très bon.  Si cela fait mal à l'œil, il peut être réécrit manuellement. <br><br>  Ici, vous pouvez voir les types mentionnés précédemment avec les noms des services.  Le système déterminera automatiquement les adaptateurs à sélectionner et les appellera.  Mais ici, nous sommes confrontés à un autre problème.  Nous avons 6000 de ces adaptateurs.  Même si vous les divisez entre eux dans le même modèle, le modèle «Eats» ou «Driver» tombera dans le modèle «Rider» ou sera dans son application.  Le code va s'étirer.  Après un certain point, il ne peut même pas tenir dans un fichier .dex.  Par conséquent, vous devez en quelque sorte séparer les adaptateurs: <br><br><img src="https://habrastorage.org/webt/ds/ul/tg/dsultg8mrgkboye3dvwmfcepdou.png"><br><br>  Finalement, nous analyserons le code à l'avance et créerons un sous-projet fonctionnel pour celui-ci, comme dans Gradle: <br><br><img src="https://habrastorage.org/webt/-4/pj/fz/-4pjfzwuq-cwmdl8lil_cia4-pi.png"><br><br>  Dans la structure interne, ces dépendances deviennent des dépendances Gradle.  Les éléments utilisant l'application Rider en dépendent désormais.  Avec eux, ils formeront les modèles dont ils ont besoin.  En conséquence, notre tâche sera résolue, et tout cela sera réglementé par le système d'assemblage de code à l'intérieur du programme. <br><br>  Mais ici, nous sommes confrontés à un autre problème: nous avons maintenant un nombre n de modèles d'usine.  Tous sont compilés en divers objets: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> GiftCardModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PricingModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DriverModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> EATSModelFactory <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PaymentsModelFactory</code> </pre><br>  Dans le processus de traitement des annotations, il ne sera pas possible de lire uniquement les annotations des dépendances externes et de générer du code supplémentaire uniquement sur celles-ci. <br><br>  Solution: nous avons un certain support dans la bibliothèque Fractory, ce qui nous aide d'une manière délicate.  Il est contenu dans le processus de liaison des données.  Nous introduisons les métadonnées en utilisant le paramètre classpath dans l'archive Java pour leur stockage supplémentaire: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RiderModelFactory // -&gt; <span class="hljs-type"><span class="hljs-type">json</span></span> // -&gt; ridermodelfactory-fractory.bin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyAppGlobalFactory // Delegates <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> discovered fractories</code> </pre><br>  Maintenant, chaque fois que vous devez les utiliser dans l'application, nous allons dans le filtre du répertoire classpath avec ces fichiers, puis nous les extrayons à partir de là au format JSON pour savoir quelles dépendances sont disponibles. <br><br><h3>  Comment tout se combine </h3><br><br><img src="https://habrastorage.org/webt/ih/nj/7i/ihnj7i5j631gcjbkgt-8u64h7l8.jpeg"><br><br>  Nous avons un <b>Thrift</b> .  Les données de là vont à <b>Thrifty</b> et passent par l'analyse.  Ils passent ensuite par un programme de génération de code que nous appelons <b>Jenga</b> .  Il produit des fichiers au format Java.  Tout cela se produit même avant la phase préliminaire du traitement ou avant la compilation.  Et pendant le processus de compilation, les annotations sont traitées.  C'est <b>au</b> tour <b>d'AutoValue de</b> générer une implémentation.  Il appelle également <b>AutoValue Moshi</b> pour fournir un support JSON.  <b>Fractory est</b> également <b>impliqué</b> .  Tout se passe pendant le processus de compilation.  Le processus est précédé d'un composant pour créer le projet lui-même, qui génère principalement des sous-projets <b>Gradle</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que vous voyez l'image complète, vous commencez à remarquer les outils mentionnés précédemment. </font><font style="vertical-align: inherit;">Ainsi, par exemple, il y a Gradle, créant des modèles, AutoValue, JavaPoet pour la génération de code. </font><font style="vertical-align: inherit;">Tous les outils sont non seulement utiles seuls, mais également en combinaison les uns avec les autres.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inconvénients de la génération de code </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il faut parler des pièges. </font><font style="vertical-align: inherit;">Le inconvénient le plus évident est de gonfler le code et de perdre le contrôle de celui-ci. </font><font style="vertical-align: inherit;">Par exemple, Dagger occupe environ 10% de tout le code de l'application. </font><font style="vertical-align: inherit;">Les modèles occupent une part beaucoup plus importante - environ 25%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chez Uber, nous essayons de résoudre le problème en jetant le code inutile. </font><font style="vertical-align: inherit;">Nous devons effectuer une analyse statistique du code et comprendre quels domaines sont vraiment impliqués dans le travail. </font><font style="vertical-align: inherit;">Quand nous le découvrons, nous pouvons faire quelques transformations et voir ce qui se passe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous prévoyons de réduire le nombre de modèles générés d'environ 40%. </font><font style="vertical-align: inherit;">Cela permettra d'accélérer l'installation et le fonctionnement des applications, ainsi que de nous faire économiser de l'argent.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment la génération de code affecte les délais de développement de projet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La génération de code, bien sûr, accélère le développement, mais le timing dépend des outils que l'équipe utilise. </font><font style="vertical-align: inherit;">Par exemple, si vous travaillez à Gradle, vous le faites très probablement à un rythme mesuré. </font><font style="vertical-align: inherit;">Le fait est que Gradle génère des modèles une fois par jour, et non quand le développeur le souhaite.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En savoir plus sur le développement chez Uber et d'autres grandes sociétés. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le 28 septembre, la 5e Conférence internationale des développeurs mobiles </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MBLT DEV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> débute à Moscou </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">800 participants, haut-parleurs, quiz et puzzles pour ceux qui sont intéressés par le développement d'Android et iOS. </font><font style="vertical-align: inherit;">Les organisateurs de la conférence sont e-Legion et RAEC. </font><font style="vertical-align: inherit;">Vous pouvez devenir participant ou partenaire de MBLT DEV 2018 </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">sur le site Web de la conférence</font></a><font style="vertical-align: inherit;"> .</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://"><img src="https://habrastorage.org/webt/yr/u2/x0/yru2x0-bqpghfoa6zqfrkyluuhq.jpeg"></a> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signaler la vidéo </font></font></h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GpMR_Zjnn_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413603/">https://habr.com/ru/post/fr413603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413591/index.html">Robotique industrielle - 57 ans! Rappelez-vous d'où vient le décompte</a></li>
<li><a href="../fr413593/index.html">Continuer à conquérir le fond de la mer. Microsoft et son projet de centre de données sous-marin Natick 2</a></li>
<li><a href="../fr413597/index.html">«Dernier recours» ou pourquoi la première conception de la base de données est nécessaire</a></li>
<li><a href="../fr413599/index.html">Il y a S.L.O.N.a en plusieurs parties. Introduisez ITAM et ne vous étouffez pas</a></li>
<li><a href="../fr413601/index.html">Le centre de données de Microsoft chauffe-t-il la mer</a></li>
<li><a href="../fr413605/index.html">Demandez à Ethan: que se passe-t-il lorsqu'une étoile traverse le système solaire?</a></li>
<li><a href="../fr413607/index.html">Fintech digest: les monnaies numériques ne menacent pas le système financier de la Fédération de Russie; PayPal a découvert combien les joueurs dépensent pour les jeux</a></li>
<li><a href="../fr413609/index.html">Syndrome d'imposteur: qu'est-ce que c'est et comment s'en débarrasser</a></li>
<li><a href="../fr413611/index.html">Comment CCTV a attaqué Positive Hack Days: concours CAMBreaker</a></li>
<li><a href="../fr413613/index.html">Ce vaisseau spatial sera plus proche du Soleil que tout ce qui l'a précédé et ne fondra pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>