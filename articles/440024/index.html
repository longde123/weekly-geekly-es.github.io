<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏿 🎻 ⚠️ Redireccionar printf () de STM32 a Qt Creator Console 🚑 💇 🐫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A menudo, al depurar el software del microcontrolador, es necesario enviar mensajes de depuración, registros, datos capturados y otras cosas a la pant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redireccionar printf () de STM32 a Qt Creator Console</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440024/"><p><img src="https://habrastorage.org/webt/gg/yw/ol/ggywoln37vevtn3jnep_hcahfhu.png" alt="kdpv.svg"></p><br><p>  A menudo, al depurar el software del microcontrolador, es necesario enviar mensajes de depuración, registros, datos capturados y otras cosas a la pantalla de la PC.  Al mismo tiempo, quiero que la salida sea más rápida y que las líneas no se muestren en ningún lado, sino directamente en el IDE, sin apartarse del código, por así decirlo.  En realidad, se trata del artículo: cómo intenté imprimir printf () para mostrar y mostrar dentro de mi entorno favorito, pero no muy microcontrolador, Qt Creator. </p><a name="habracut"></a><br><p>  En general, puede encontrar una gran cantidad de formas de generar información de texto desde el microcontrolador.  Sin embargo, las técnicas más utilizadas no son tantas: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Semihosting</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segger rtt</a> </li><li>  USB CDC </li><li>  UART </li><li>  ITM </li></ul><br><p>  El semihosting es bastante lento, RTT está vinculado a las soluciones de hardware y software Segger *, el USB no está en todos los microcontroladores.  Por lo tanto, por lo general, prefiero los dos últimos: el uso de UART e ITM.  Sobre ellos y se discutirá a continuación. </p><br><p>  * <em>Upd.</em>  <em>- De hecho, como se sugiere en los comentarios, esto no es así.</em>  <em>Hay opciones tanto en el lado del software como del hardware.</em>  <em>Por lo tanto, de los métodos anteriores, RTT será quizás el más universal.</em> </p><br><p>  Y enseguida alguna explicación sobre el software que se usará a continuación.  Ahora tengo Fedora 28 como sistema operativo, y el paquete actual de software para trabajar con microcontroladores es: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qt Creator 4.8.1</a> (enlace directo a lanzamientos, bastante cuidadosamente oculto en el sitio) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GNU Arm Embedded Toolchain 7</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenOCD 0.10.0 + dev</a> </li></ul><br><h3 id="perenapravlenie-printf-v-gcc">  Redirigir printf () en GCC </h3><br><p>  Entonces, para redirigir la salida de printf () en GCC, debe agregar claves de enlazador </p><br><pre><code class="plaintext hljs">-specs=nosys.specs -specs=nano.specs</code> </pre> <br><p>  Si necesita mostrar números de coma flotante, debe recordar la clave </p><br><pre> <code class="plaintext hljs">-u_printf_float</code> </pre> <br><p>  E implemente la función _write ().  Por ejemplo, algo como esto </p><br><pre> <code class="plaintext hljs">int _write(int fd, char* ptr, int len) { (void)fd; int i = 0; while (ptr[i] &amp;&amp; (i &lt; len)) { retarget_put_char((int)ptr[i]); if (ptr[i] == '\n') { retarget_put_char((int)'\r'); } i++; } return len; }</code> </pre> <br><p>  donde retarget_put_char () es una función que cargará el carácter directamente en la interfaz deseada. </p><br><h3 id="printf---itm---qt-creator">  printf () -&gt; ITM -&gt; Qt Creator </h3><br><p>  Instrumentation Trace Macrocell (ITM) es un bloque dentro del núcleo Cortex-M3 / M4 / M7 utilizado para la salida no invasiva (rastreo) de varios tipos de información de diagnóstico.  Para implementar printf () sobre ITM, debe saber lo siguiente: </p><br><ul><li>  Utiliza el reloj TRACECLKIN, cuya frecuencia suele ser igual a la frecuencia central </li><li>  Tiene 32 piezas de los llamados puertos de estímulo para la salida de datos </li><li>  CMSIS incorpora la función ITM_SendChar (), que carga un símbolo en el puerto de estímulo 0 </li><li>  Los datos se emiten a través de un bus síncrono (TRACEDATA, TRACECLK) o de una línea SWO asíncrona de un solo cable (TRACESWO) </li><li>  La línea SWO generalmente se multiplexa con JTDO, lo que significa que solo funciona en modo de depuración por SWD </li><li>  La retirada por SWO se lleva a cabo utilizando el código Manchester o NRZ (UART 8N1) </li><li>  Los datos se transmiten en cuadros de cierto formato: necesita un analizador en el lado receptor </li><li>  ITM generalmente se configura desde el IDE o la utilidad correspondiente (sin embargo, nadie prohíbe configurarlo en el código del programa; luego, la salida a SWO funcionará sin una sesión de depuración elevada) </li></ul><br><p>  La forma más conveniente de usar ITM es emitir a través de SWO usando la codificación NRZ; por lo tanto, solo necesita una línea, y será posible recibir datos no solo usando un depurador con una entrada especial, sino también un adaptador USB-UART normal, aunque a una velocidad menor. </p><br><p>  Seguí el camino usando un depurador, y me vi obligado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">modificar</a> mi STLink-V2 chino para admitir SWO.  Entonces todo es simple: conectamos el microcontrolador JTDO / TRACESWO al pin del depurador correspondiente y vamos a configurar el software. </p><br><p>  Openocd tiene el comando "tpiu config": con él puede configurar el método para mostrar información de rastreo (con más detalle en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía del usuario de OpenOCD</a> ).  Entonces, por ejemplo, usando argumentos </p><br><pre> <code class="plaintext hljs">tpiu config internal /home/esynr3z/itm.fifo uart off 168000000</code> </pre> <br><p>  configure la salida en el archivo /home/esynr3z/itm.fifo, use la codificación NRZ y calcule la velocidad de transferencia máxima en función de la frecuencia TRACECLKIN de 168 MHz, para STLink es de 2 MHz.  Y otro equipo </p><br><pre> <code class="plaintext hljs">itm port 0 1</code> </pre> <br><p>  habilitará el puerto cero para la transferencia de datos. </p><br><p>  El código fuente de OpenOCD incluye la utilidad itmdump (contrib / itmdump.c): con ella puede analizar cadenas de los datos recibidos. </p><br><p>  Para compilar entramos </p><br><pre> <code class="plaintext hljs">gcc itmdump.c -o itmdump</code> </pre> <br><p>  Al inicio, especifique el archivo / pipe / ttyUSB * necesario y el modificador -d1 para mostrar los bytes de datos recibidos como cadenas </p><br><pre> <code class="plaintext hljs">./itmdump -f /home/esynr3z/itm.fifo -d1</code> </pre> <br><p>  Y el último.  Para enviar un carácter a través de SWO, complementamos _write (), descrito anteriormente, con una función </p><br><pre> <code class="plaintext hljs">int retarget_put_char(int ch) { ITM_SendChar((uint32_t)ch); return 0; }</code> </pre> <br><p>  Entonces, el plan general es el siguiente: dentro de Qt Creator, configuramos openocd para guardar toda la información recibida en SWO en una tubería nombrada previamente creada, y podemos leer tuberías, analizar cadenas y mostrarlas usando itmdump, que se ejecuta como una herramienta externa.  Por supuesto, hay una forma más elegante de resolver el problema: escribir el complemento apropiado para Qt Creator.  Sin embargo, espero que el enfoque descrito a continuación resulte útil para alguien. </p><br><p>  Vaya a la configuración del complemento Bare Metal (Herramientas-&gt; Opciones-&gt; Dispositivos-&gt; Bare Metal). </p><br><p><img src="https://habrastorage.org/webt/_t/0e/vz/_t0evzgzyymortwmhhwnvumadrq.png" alt="config_baremetal.png"></p><br><p>  Seleccione el servidor GDB usado y agregue los comandos de inicialización de línea al final de la lista </p><br><pre> <code class="plaintext hljs">monitor tpiu config internal /home/esynr3z/itm.fifo uart off 168000000 monitor itm port 0 1</code> </pre> <br><p>  Ahora, justo antes de que el depurador coloque el cursor al principio de main (), se configurará ITM. </p><br><p>  Agregue itmdump como la herramienta externa (Herramientas-&gt; Externo-&gt; Configurar ...). </p><br><p><img src="https://habrastorage.org/webt/tx/18/mk/tx18mk_cx8zdqhxajwxsoh2ivlk.png" alt="external_itmdump.png"></p><br><p>  No olvides configurar la variable </p><br><pre> <code class="plaintext hljs">QT_LOGGING_TO_CONSOLE=1</code> </pre> <br><p>  para mostrar la salida de la utilidad a la consola Qt Creator (panel 7 Mensajes generales). </p><br><p>  Ahora encienda itmdump, active el modo de depuración, inicie la ejecución del código y ... no pasa nada.  Sin embargo, si interrumpe la depuración, la ejecución de itmdump finalizará y todas las líneas impresas a través de printf () aparecerán en la pestaña Mensajes generales. </p><br><p>  Después de una breve investigación, se descubrió que las líneas de itmdump deben almacenarse en búfer y mostrarse en stderr, luego aparecen en la consola de forma interactiva, mientras se depura el programa.  Subí una versión modificada de itmdump a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </p><br><p>  Hay una advertencia más.  La depuración en el inicio dependerá de la ejecución del comando "monitor tpiu config ..." si itmdump no se ejecutó previamente.  Esto sucede debido al hecho de que la apertura de la tubería (/home/esynr3z/itm.fifo) dentro de openocd para escritura está bloqueando, y el depurador se bloqueará hasta que la tubería se abra para leer desde el otro extremo. </p><br><p>  Esto es algo desagradable, especialmente si en algún momento no se necesita ITM, pero tiene que ejecutarlo inactivo, cambiar constantemente el servidor GDB o eliminar / agregar líneas en su configuración.  Por lo tanto, tuve que cavar un poco de fuentes abiertas y encontrar el lugar donde necesita sustituir una pequeña muleta. </p><br><p>  En el archivo src / target / armv7m_trace.c hay una línea con el procedimiento de apertura deseado </p><br><pre> <code class="plaintext hljs">armv7m-&gt;trace_config.trace_file = fopen(CMD_ARGV[cmd_idx], "ab");</code> </pre> <br><p>  necesita ser reemplazado por </p><br><pre> <code class="plaintext hljs">int fd = open(CMD_ARGV[cmd_idx], O_CREAT | O_RDWR, 0664); armv7m-&gt;trace_config.trace_file = fdopen(fd, "ab");</code> </pre> <br><p>  Ahora nuestra pipa se abrirá inmediatamente y no brillará.  Por lo tanto, puede dejar la configuración de Bare Metal sola y ejecutarla solo cuando sea necesario. </p><br><p>  Como resultado, la salida de mensajes durante la depuración se ve así </p><br><p><img src="https://habrastorage.org/webt/lz/-x/po/lz-xpo5ujcbkrga3al-pnsectme.png" alt="debug.png"></p><br><h2 id="printf---uart---qt-creator">  printf () -&gt; UART -&gt; Qt Creator </h2><br><p>  En este caso, todo es aproximadamente igual: </p><br><ul><li>  Agregue una función con inicialización UART al código </li><li>  Implementamos retarget_put_char (), donde el carácter se enviará al búfer del transceptor </li><li>  Conectamos el adaptador USB-UART </li><li>  Agregue una utilidad a Herramientas externas que leerá líneas del puerto COM virtual y las mostrará en la pantalla. </li></ul><br><p>  Bosquejé tal utilidad en C - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uartdump</a> .  El uso es bastante simple: solo necesita especificar el nombre del puerto y la velocidad en baudios. </p><br><p><img src="https://habrastorage.org/webt/wm/ov/mf/wmovmfhdw33hahv1mdaubq0432u.png" alt="external_uartdump.png"></p><br><p>  Sin embargo, vale la pena señalar una característica.  Esta utilidad no depende de la depuración, y Qt Creator no ofrece ninguna opción para cerrar la ejecución de herramientas externas.  Por lo tanto, para dejar de leer el puerto COM, agregué otra herramienta externa. </p><br><p><img src="https://habrastorage.org/webt/k8/ee/1p/k8ee1pim_owcrvyuvz3jrsezta8.png" alt="external_uartdump_close.png"></p><br><p>  Bueno, por si acaso, adjuntaré un enlace a la plantilla CMake para el proyecto que apareció en las capturas de pantalla: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440024/">https://habr.com/ru/post/440024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440014/index.html">Habilidades, autoeducación y lenguajes de programación para desarrolladores principiantes: HackerRank Research</a></li>
<li><a href="../440016/index.html">Cuando se puede tocar la lectura: ONYX BOOX Monte Cristo 4 review</a></li>
<li><a href="../440018/index.html">Exposición local dinámica</a></li>
<li><a href="../440020/index.html">Regresión o regresión en pruebas</a></li>
<li><a href="../440022/index.html">Un pequeño Ferrari: Fintech-startup Rally Rd te permitirá comprar "acciones" de autos raros</a></li>
<li><a href="../440026/index.html">Kaggle: no puede caminar - corramos</a></li>
<li><a href="../440030/index.html">Identifique el bloqueo de PKH en un enrutador OpenWrt con WireGuard y DNSCrypt</a></li>
<li><a href="../440032/index.html">Inteligencia Artificial Horizon Zero Dawn</a></li>
<li><a href="../440034/index.html">BESO Arquitectura. Del microservicio al monolito</a></li>
<li><a href="../440036/index.html">Mecanografía táctil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>