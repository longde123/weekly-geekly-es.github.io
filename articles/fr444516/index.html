<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚úàÔ∏è üßôüèø üî© Wolfenstein 3D: lancer de rayons avec WebGL1 üë©üèæ‚Äçüç≥ üõ°Ô∏è üå∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apr√®s l'apparition des cartes graphiques Nvidia RTX l'√©t√© dernier, le lancer de rayons a retrouv√© son ancienne popularit√©. Au cours des derniers mois,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wolfenstein 3D: lancer de rayons avec WebGL1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444516/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png" alt="image"></div><br>  Apr√®s l'apparition des cartes graphiques Nvidia RTX l'√©t√© dernier, le lancer de rayons a retrouv√© son ancienne popularit√©.  Au cours des derniers mois, mon flux Twitter a √©t√© rempli d'un flux sans fin de comparaisons graphiques avec RTX activ√© et d√©sactiv√©. <br><br>  Apr√®s avoir admir√© tant de belles images, j'ai voulu essayer de combiner le rendu classique classique avec un traceur de rayons par moi-m√™me. <br><br>  Souffrant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du syndrome de rejet des d√©veloppements des autres</a> , j'ai donc cr√©√© mon propre moteur de rendu hybride bas√© sur WebGL1.  Vous pouvez jouer avec le rendu du niveau de d√©monstration de Wolfenstein 3D avec des sph√®res (que j'ai utilis√© en raison du lancer de rayons) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><a name="habracut"></a><br><h3>  Prototype </h3><br>  J'ai commenc√© ce projet en cr√©ant un prototype, en essayant de recr√©er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'√©clairage global avec le</a> lancer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de rayons de Metro Exodus</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/61a/447/26261a447cd19758715a3cbde356eeb7.png"></div><br>  <i>Le premier prototype √† montrer un √©clairage global diffus (Diffuse GI)</i> <br><br>  Le prototype est bas√© sur un moteur de rendu vers l'avant, qui rend la g√©om√©trie enti√®re de la sc√®ne.  Le shader utilis√© pour pixelliser la g√©om√©trie non seulement calcule l'illumination directe, mais √©met √©galement des rayons al√©atoires √† partir de la surface de la g√©om√©trie rendue pour s'accumuler √† l'aide du traceur de rayons r√©flexion indirecte de la lumi√®re provenant de surfaces non brillantes (GI diffus). <br><br>  Dans l'image ci-dessus, vous pouvez voir comment toutes les sph√®res sont correctement √©clair√©es uniquement par un √©clairage indirect (les rayons lumineux sont r√©fl√©chis par le mur derri√®re la cam√©ra).  La source de lumi√®re elle-m√™me est recouverte d'un mur brun sur le c√¥t√© gauche de l'image. <br><br><h3>  Wolfenstein 3D </h3><br>  Le prototype utilise une sc√®ne tr√®s simple.  Il n'a qu'une seule source de lumi√®re et seules quelques sph√®res et cubes sont rendus.  Gr√¢ce √† cela, le code de lancer de rayons dans le shader est tr√®s simple.  Le cycle de v√©rification de la force brute de l'intersection dans lequel le faisceau est test√© pour l'intersection avec tous les cubes et sph√®res de la sc√®ne est encore assez rapide pour que le programme l'ex√©cute en temps r√©el. <br><br>  Apr√®s avoir cr√©√© ce prototype, je voulais faire quelque chose de plus complexe en ajoutant plus de g√©om√©trie et beaucoup de sources lumineuses √† la sc√®ne. <br><br>  Le probl√®me avec un environnement plus complexe est que j'ai encore besoin de pouvoir tracer les rayons de la sc√®ne en temps r√©el.  Habituellement, une structure de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hi√©rarchie de volume englobante</a> (BVH) serait utilis√©e pour acc√©l√©rer le processus de lancer de rayons, mais ma d√©cision de cr√©er ce projet sur WebGL1 ne le permettait pas: il est impossible de charger des donn√©es 16 bits dans une texture dans WebGL1 et les op√©rations binaires ne peuvent pas √™tre utilis√©es dans un shader.  Cela complique le calcul pr√©liminaire et l'application de BVH dans les shaders WebGL1. <br><br>  C'est pourquoi j'ai d√©cid√© d'utiliser le niveau de d√©monstration Wolfenstein 3D pour cela.  En 2013, j'ai cr√©√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shader WebGL fragment√©</a> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadertoy</a> qui rend non seulement les niveaux de Wolfenstein, mais cr√©e √©galement toutes les textures n√©cessaires de mani√®re proc√©durale.  D'apr√®s mon exp√©rience de travail sur ce shader, je savais que la conception de niveaux bas√©e sur la grille de Wolfenstein peut √©galement √™tre utilis√©e comme structure d'acc√©l√©ration rapide et facile, et que le lancer de rayons sur cette structure sera tr√®s rapide. <br><br>  Vous trouverez ci-dessous une capture d'√©cran de la d√©mo, et en mode plein √©cran, vous pouvez la lire ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://reindernijhoff.net/wolfrt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/gl/fp/euglfpjgl9503fy-_hjdwmr5hdi.png"></div><br><h3>  Br√®ve description </h3><br>  La d√©mo utilise un moteur de rendu hybride.  Pour rendre tous les polygones du cadre, il utilise la tramage traditionnelle, puis combine le r√©sultat avec des ombres, une IG diffuse et des r√©flexions cr√©√©es par le lancer de rayons. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f7/fd8/bb9/8f7fd8bb9324905edf5200fedb28bb7a.png"></div><br>  <i>Ombres</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/5b5/6ba/5245b56ba3a1feb02a9401857d625514.png"></div><br>  <i>Diffuse gi</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/885/df3/33c/885df333c0da45fcbb909c01c5da9648.png"></div><br>  <i>R√©flexions</i> <br><br><h3>  Rendu proactif </h3><br>  Les cartes Wolfenstein peuvent √™tre enti√®rement encod√©es dans une grille bidimensionnelle 64 √ó 64.  La carte utilis√©e dans la d√©mo est bas√©e sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier niveau de l'√©pisode 1 de</a> Wolfenstein 3D. <br><br>  Au d√©marrage, toute la g√©om√©trie n√©cessaire pour passer le rendu proactif est cr√©√©e.  Un maillage de murs est g√©n√©r√© √† partir des donn√©es cartographiques.  Il cr√©e √©galement des plans de plancher et de plafond, des maillages s√©par√©s pour les lumi√®res, les portes et des sph√®res al√©atoires. <br><br>  Toutes les textures utilis√©es pour les murs et les portes sont regroup√©es dans un seul atlas de texture, de sorte que tous les murs peuvent √™tre dessin√©s en un seul appel. <br><br><h4>  Ombres et √©clairage </h4><br>  L'√©clairage direct est calcul√© dans le shader utilis√© pour la passe de rendu vers l'avant.  Chaque fragment peut √™tre √©clair√© (au maximum) par quatre sources diff√©rentes.  Pour savoir quelles sources peuvent influencer le fragment dans le shader, lorsque la d√©mo d√©marre, la texture de recherche est pr√©calcul√©e.  Cette texture de recherche a une taille de 64 par 128 et code les positions des 4 sources lumineuses les plus proches pour chaque position dans la grille de la carte. <br><br><pre><code class="cpp hljs">varying vec3 vWorldPos; varying vec3 vNormal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ vec3 ro = vWorldPos; vec3 normal = normalize(vNormal); vec3 light = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;LIGHTS_ENCODED_IN_MAP; i++) { light += sampleLight(i, ro, normal); }</code> </pre> <br>  Pour obtenir des ombres douces pour chaque fragment et source lumineuse, une position al√©atoire dans la source lumineuse est √©chantillonn√©e.  En utilisant le code de tra√ßage des rayons dans le shader (voir la section Tra√ßage des rayons ci-dessous), un rayon d'ombre est √©mis au point d'√©chantillonnage pour d√©terminer la visibilit√© de la source de lumi√®re. <br><br>  Apr√®s avoir ajout√© des r√©flexions (auxiliaires) (voir la section R√©flexion ci-dessous), le GI diffus est ajout√© √† la couleur calcul√©e du fragment en effectuant une recherche dans la cible de rendu du GI diffus (voir ci-dessous). <br><br><h3>  Ray tracing </h3><br>  Bien que le prototype de code de tra√ßage des rayons pour l'IG diffuse ait √©t√© combin√© avec un shader pr√©emptif, dans la d√©mo, j'ai d√©cid√© de les s√©parer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58b/8fd/3ab/58b8fd3abd38a86da42e1454df7109de.png"></div><br>  Je les ai s√©par√©s en faisant un deuxi√®me rendu de toute la g√©om√©trie dans une cible de rendu s√©par√©e (Diffuse GI Render Target) en utilisant un autre shader qui n'√©met que des rayons al√©atoires pour collecter le GI diffus (voir la section ¬´Diffuse GI¬ª ci-dessous).  L'√©clairage collect√© dans cette cible de rendu est ajout√© √† l'√©clairage direct calcul√© dans le passage de rendu vers l'avant. <br><br>  En s√©parant la passe proactive et l'IG diffus, nous pouvons √©mettre moins d'un faisceau IG diffus par pixel d'√©cran.  Cela peut √™tre fait en r√©duisant l'√©chelle du tampon (en d√©pla√ßant le curseur dans les options dans le coin sup√©rieur droit de l'√©cran). <br><br>  Par exemple, si l'√©chelle du tampon est de 0,5, alors un seul rayon sera √©mis pour quatre pixels d'√©cran.  Cela permet une √©norme augmentation de la productivit√©.  En utilisant la m√™me interface utilisateur dans le coin sup√©rieur droit de l'√©cran, vous pouvez √©galement modifier le nombre d'√©chantillons par pixel dans la cible de rendu (SPP) et le nombre de r√©flexions du faisceau. <br><br><h4>  Emettre un faisceau </h4><br>  Afin de pouvoir √©mettre des rayons dans la sc√®ne, tous les niveaux de g√©om√©trie doivent avoir un format que le traceur de rayons du shader peut utiliser.  La couche Wolfenstein codait une grille 64 √ó 64, il est donc assez facile de coder toutes les donn√©es en une seule texture 64 √ó 64: <br><br><ul><li>  Dans le canal rouge de la couleur de texture, tous les objets situ√©s dans la cellule correspondante <em>x, y de</em> la grille de carte sont cod√©s.  Si la valeur du canal rouge est nulle, il n'y a aucun objet dans la cellule, sinon, il est occup√© par un mur (valeurs de 1 √† 64), une porte, une source de lumi√®re ou une sph√®re qui doit √™tre v√©rifi√©e pour l'intersection. </li><li>  Si une sph√®re occupe une cellule de grille de niveau, les canaux vert, bleu et alpha sont utilis√©s pour coder le rayon et les coordonn√©es <em>x</em> et <em>y</em> relatives de la sph√®re √† l'int√©rieur de la cellule de grille. </li></ul><br>  Un rayon est √©mis dans une sc√®ne en parcourant une texture √† l'aide du code suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worldHit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n vec3 ro,in vec3 rd,in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_min, in </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t_max, inout vec3 recPos, inout vec3 recNormal, inout vec3 recColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 pos = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(ro); vec3 ri = <span class="hljs-number"><span class="hljs-number">1.0</span></span>/rd; vec3 rs = sign(rd); vec3 dis = (pos-ro + <span class="hljs-number"><span class="hljs-number">0.5</span></span> + rs*<span class="hljs-number"><span class="hljs-number">0.5</span></span>) * ri; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAXSTEPS; i++ ) { vec3 mm = step(dis.xyz, dis.zyx); dis += mm * rs * ri; pos += mm * rs; vec4 mapType = texture2D(_MapTexture, pos.xz * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / <span class="hljs-number"><span class="hljs-number">64.</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWall(mapType)) { ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Un code de tra√ßage de rayons maill√© similaire peut √™tre trouv√© dans ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shader Wolfenstein</a> sur Shadertoy. <br><br>  Apr√®s avoir calcul√© le point d'intersection avec le mur ou la porte (en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le test d'intersection avec un parall√©logramme</a> ), la recherche dans le m√™me atlas de texture qui a √©t√© utilis√© pour passer le rendu proactif nous donne des points d'intersection d'alb√©do.  Les sph√®res ont une couleur qui est d√©termin√©e par la proc√©dure en fonction de leurs coordonn√©es <em>x, y</em> dans la grille et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction de d√©grad√© de couleurs</a> . <br><br>  Les portes sont un peu plus compliqu√©es car elles bougent.  Pour que la repr√©sentation de la sc√®ne dans le CPU (utilis√©e pour rendre les maillages dans la passe de rendu vers l'avant) soit la m√™me que la repr√©sentation de la sc√®ne dans le GPU (utilis√©e pour le lancer de rayons), toutes les portes se d√©placent automatiquement et de mani√®re d√©terministe, en fonction de la distance entre la cam√©ra et la porte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d7/ded/058/3d7ded058d2f62fcf298c9b68b568a69.png"></div><br><br><h4>  Diffuse gi </h4><br>  L'√©clairage global diffus√© (IG diffus) est calcul√© en √©mettant des rayons dans le shader, qui est utilis√© pour dessiner toute la g√©om√©trie dans la cible de rendu de l'IG diffus.  La direction de ces rayons d√©pend de la normale √† la surface, d√©termin√©e en √©chantillonnant l'h√©misph√®re pond√©r√© en cosinus. <br><br>  Ayant la direction du faisceau <em>rd</em> et le point de d√©part <em>ro</em> , l'√©clairage r√©fl√©chi peut √™tre calcul√© en utilisant le cycle suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBounceCol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in vec3 ro, in vec3 rd, in vec3 col)</span></span></span><span class="hljs-function"> </span></span>{ vec3 emitted = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); vec3 recPos, recNormal, recColor; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;MAX_RECURSION; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (worldHit(ro, rd, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, <span class="hljs-number"><span class="hljs-number">20.</span></span>, recPos, recNormal, recColor)) { <span class="hljs-comment"><span class="hljs-comment">// if (isLightHit) { // direct light sampling code // return vec3(0); // } col *= recColor; for (int i=0; i&lt;2; i++) { emitted += col * sampleLight(i, recPos, recNormal); } } else { return emitted; } rd = cosWeightedRandomHemisphereDirection(recNormal); ro = recPos; } return emitted; }</span></span></code> </pre> <br>  Pour r√©duire le bruit, un √©chantillonnage de lumi√®re directe est ajout√© √† la boucle.  Ceci est similaire √† la technique utilis√©e dans mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">encore un autre</a> shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cornell Box</a> sur Shadertoy. <br><br><h4>  La r√©flexion </h4><br>  Gr√¢ce √† la possibilit√© de tracer la sc√®ne avec des rayons dans le shader, il est tr√®s facile d'ajouter des reflets.  Dans ma d√©mo, des r√©flexions sont ajout√©es en appelant la m√™me m√©thode <em>getBounceCol</em> montr√©e ci-dessus en utilisant le faisceau r√©fl√©chi de la cam√©ra: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> REFLECTION col = mix(col, getReflectionCol(ro, reflect(normalize(vWorldPos - _CamPos), normal), albedo), .15); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Des r√©flexions sont ajout√©es dans la passe de rendu avant, par cons√©quent, un rayon de r√©flexion √©mettra toujours un faisceau de r√©flexion. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/e84/d6a/a88e84d6a2d0209234d6edaf02fcc441.png"></div><br><h3>  Anticr√©nelage temporel </h3><br>  √âtant donn√© que les ombres douces du passage de rendu proactif et l'approximation GI diffuse utilisent environ un √©chantillon par pixel, le r√©sultat final est extr√™mement bruyant.  Pour r√©duire la quantit√© de bruit, l'anti-cr√©nelage temporel (TAA) a √©t√© utilis√© sur la base du TAA de Playdead: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Anti-aliasing de reprojection temporelle dans INSIDE</a> . <br><br><h4>  Re-projection </h4><br>  L'id√©e derri√®re TAA est assez simple: TAA calcule un sous-pixel par image, puis fait la moyenne de ses valeurs avec le pixel corr√©latif de l'image pr√©c√©dente. <br><br>  Pour savoir o√π se trouvait le pixel actuel dans l'image pr√©c√©dente, la position du fragment est re-projet√©e √† l'aide de la matrice de projection de vue mod√®le de l'image pr√©c√©dente. <br><br><h4>  Supprimer des √©chantillons et limiter les quartiers </h4><br>  Dans certains cas, un √©chantillon enregistr√© dans le pass√© n'est pas valide, par exemple, lorsque la cam√©ra s'est d√©plac√©e de telle mani√®re qu'un fragment de l'image actuelle dans l'image pr√©c√©dente a √©t√© ferm√© par la g√©om√©trie.  Pour supprimer ces √©chantillons non valides, une restriction de voisinage est utilis√©e.  J'ai choisi le type de restriction le plus simple: <br><br><pre> <code class="cpp hljs">vec3 history = texture2D(_History, uvOld ).rgb; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; x &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; x+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = <span class="hljs-number"><span class="hljs-number">-1.</span></span>; y &lt;= <span class="hljs-number"><span class="hljs-number">1.</span></span>; y+=<span class="hljs-number"><span class="hljs-number">1.</span></span>) { vec3 n = texture2D(_New, vUV + vec2(x,y) / _Resolution).rgb; mx = max(n, mx); mn = min(n, mn); } } vec3 history_clamped = clamp(history, mn, mx);</code> </pre> <br>  J'ai √©galement essay√© d'utiliser la m√©thode de restriction bas√©e sur le parall√©logramme de d√©limitation, mais je n'ai pas vu beaucoup de diff√©rence avec ma solution.  Cela est probablement d√ª au fait que dans la sc√®ne de la d√©mo, il existe de nombreuses couleurs sombres identiques et presque aucun objet en mouvement. <br><br><h4>  Vibrations de la cam√©ra </h4><br>  Pour obtenir l'anticr√©nelage, la cam√©ra dans chaque image oscille en raison de l'utilisation d'un d√©calage (pseudo) al√©atoire de sous-pixels.  Ceci est mis en ≈ìuvre en changeant la matrice de projection: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._projectionMatrix[<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>] += (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHaltonSequence(frame % <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) - <span class="hljs-number"><span class="hljs-number">.5</span></span>) / renderHeight;</code> </pre> <br><h3>  Le bruit </h3><br>  Le bruit est la base des algorithmes utilis√©s pour calculer l'IG diffus et les ombres douces.  L'utilisation d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bon bruit</a> affecte consid√©rablement la qualit√© de l'image, tandis qu'un mauvais bruit cr√©e des artefacts ou ralentit la convergence de l'image. <br><br>  J'ai peur que le bruit blanc utilis√© dans cette d√©mo ne soit pas tr√®s bon. <br><br>  L'utilisation d'un bon bruit est probablement l'aspect le plus important de l'am√©lioration de la qualit√© d'image dans cette d√©mo.  Par exemple, vous pouvez utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du bruit bleu</a> . <br><br>  J'ai men√© des exp√©riences avec du bruit bas√© sur le nombre d'or, mais elles ont √©chou√©.  Jusqu'√† pr√©sent, le tristement c√©l√®bre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hash sans Sine de</a> Dave Hoskins est utilis√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 p3 = fract(vec3(g_seed += <span class="hljs-number"><span class="hljs-number">0.1</span></span>) * HASHSCALE3); p3 += dot(p3, p3.yzx + <span class="hljs-number"><span class="hljs-number">19.19</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract((p3.xx+p3.yz)*p3.zy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a81/338/42a/a8133842a43266dad1b4e9ee50c59228.png"></div><br><h3>  R√©duction du bruit </h3><br>  M√™me avec TAA activ√©, la d√©mo montre toujours beaucoup de bruit.  Il est particuli√®rement difficile de rendre le plafond, car il n'est √©clair√© que par un √©clairage indirect.  Cela ne simplifie pas la situation o√π le plafond est une grande surface plane, remplie d'une couleur unie: s'il avait une texture ou des d√©tails g√©om√©triques, le bruit deviendrait moins perceptible. <br><br>  Je ne voulais pas passer beaucoup de temps sur cette partie de la d√©mo, j'ai donc essay√© d'appliquer un seul filtre de r√©duction du bruit: Median3x3 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Morgan McGuire et Kyle Witson</a> .  Malheureusement, ce filtre ne fonctionne pas tr√®s bien avec les graphiques "pixel art" des textures de mur: il supprime tous les d√©tails √† distance et arrondit les coins des pixels des murs voisins. <br><br>  Dans une autre exp√©rience, j'ai appliqu√© le m√™me filtre √† la cible de rendu GI diffus.  Bien qu'il ait l√©g√®rement r√©duit le bruit, en m√™me temps presque sans changer les d√©tails des textures des murs, j'ai d√©cid√© que cette am√©lioration ne valait pas les millisecondes suppl√©mentaires d√©pens√©es. <br><br><h3>  D√©mo </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vous pouvez jouer la d√©mo ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444516/">https://habr.com/ru/post/fr444516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444502/index.html">La cryptographie quantique est-elle vraiment fiable?</a></li>
<li><a href="../fr444504/index.html">Utilisation du r√©pertoire de packages local en Python maintenant</a></li>
<li><a href="../fr444508/index.html">Comment nous avons rendu PHP 7 deux fois plus rapide que PHP 5. Partie 1: optimisation des structures de donn√©es</a></li>
<li><a href="../fr444512/index.html">Cr√©ation d'une application graphique pour r√©soudre le probl√®me du parcours du cheval</a></li>
<li><a href="../fr444514/index.html">Webinaire "S√©curit√© de l'apprentissage automatique: probl√®mes naturels de l'intelligence artificielle"</a></li>
<li><a href="../fr444518/index.html">Vers une th√©orie fondamentale de la conscience</a></li>
<li><a href="../fr444520/index.html">2. Check Point Getting Started R80.20. Architecture de la solution</a></li>
<li><a href="../fr444522/index.html">Apocalypse est annul√©e</a></li>
<li><a href="../fr444524/index.html">Lambdas: de C ++ 11 √† C ++ 20. Partie 1</a></li>
<li><a href="../fr444526/index.html">Pile DOTS: C ++ & C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>