<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📧 🤙🏼 🚔 程序层生成 🍊 ⛅️ 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在一些新游戏中 ，有关编程，图形和声音的工作已经结束-仅保留关卡。 简单而有趣的工作，但是由于某些原因却很难。 也许是普遍疲劳的效果。 


 在思考如何简化他的生活时，程序生成的想法浮现在脑海。 当然，它也必须写出来，但是正如在一项著名的作品中所说的那样，“最好是丢掉一天，然后在五分钟内飞起来。”...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>程序层生成</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418685/"><p><img src="https://habrastorage.org/webt/2m/0y/gv/2m0ygvmlc1izxgmo4chumrammxi.png"></p><br><p> 在<em>一些新游戏中</em> ，有关编程，图形和声音的工作<em>已经</em>结束-仅保留关卡。 简单而有趣的工作，但是由于某些原因却很难。 也许是普遍疲劳的效果。 </p><br><p> 在思考如何简化他的生活时，程序生成的想法浮现在脑海。 当然，它也必须写出来，但是正如在一项著名的作品中所说的那样，“最好是丢掉一天，然后在五分钟内飞起来。” </p><br><p>  <strong>注意！</strong>  <strong>下切了很多文字和“胖子”的GIF。</strong> </p><a name="habracut"></a><br><h2 id="vvodnaya"> 介绍性 </h2><br><p> 水平仪仍将手动抛光，因此对内存，速度甚至所产生水平仪的质量没有特殊要求。 </p><br><p> 最初，我计划生成器仅抛出房间和门，并且所有进一步的优化（情节，风景和敌人）都将以手动模式执行。 但就目前而言，我认为发电机可以做的更多。 尽管如此，手动调整仍然会保留-玩家必须感觉到至少在关卡上投入了一点爱。 </p><br><p> 我查看了有关游戏开发人员的知识，并在单独的文档中写了有关程序生成的文章的链接。 当然，大多数都与生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经典迷宫</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成地形</a> （顺便说一句，结果非常令人印象深刻）有关，这不适合3D射击游戏。 但是有些接近我的需求（用星号标出那些最适合我的星号）： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.progamer.ru/dev/procedural-dungeon-generation.htm（*</a> ） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/post/333692/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://www.gamasutra.com/blogs/GrahamDavis/20170130/290326/Procedural_Level_Generation_in_Unity_for_MERC_part_1_of_2.php</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://ijdykeman.github.io/ml/2017/10/12/wang-tile-procedural-generation.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/post/332832/（*</a> ） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://habr.com/post/184818/（*</a> ） </li></ul><br><p> 我决定从最后两个开始-它们正在实施中，并给出了良好的结果。 </p><br><h2 id="struktura-generatora"> 发电机结构 </h2><br><p> 实际上，我并不是立即进入这种结构，而是在进行大量的重构和重写的过程中，但是我马上就写了一下，这样很清楚发生了什么事情： </p><br><ol><li> 生成初始几何体（从“ BSP”或房间布局中选择）。 </li><li> 清除垃圾区（游戏中不存在的垃圾区）。 </li><li> 建立连接。 </li><li> 清除垃圾子图（这些相互连接的部分组，但与其余部分没有任何关系）。 </li><li> 清除不必要的连接（建立<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生成树</a> ，将链接指向<strong>最小</strong>生成树，因为那里有图片，但是对于生成器，则不需要<strong>最小</strong>生成树）。 </li><li> 连接的随机化是恢复一些远程连接（对于更“人性化”的级别），以及将其他一些连接转换为部分之间的通道（将多个部分合并为一个更复杂的形式）。 </li><li> 秘密房间的一代。 </li><li> 生成“方案”（初始和最终部分将位于何处，以及必须经过哪条路径才能从初始到最终）。 </li><li> 连接优化。 </li><li> 创建门窗。 </li><li> 选择本节中要执行的操作（按开关，抬起钥匙或找到秘密墙）。 </li></ol><br><p> 大约还有12点，但是还没有完成（当我完成时，我将写一篇关于它们的单独文章）。 </p><br><h2 id="generaciya-iznachalnoy-geometrii-bsp"> 初始几何生成：“ BSP” </h2><br><p><img src="https://habrastorage.org/webt/zn/j4/_k/znj4_kemnzlvr4cfr45tqtzami8.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该翻译</a>被作为基础。 我不确定此算法中发生的次数是否接近实际的BSP，因此我将“ BSP”写在引号中。 </p><br><p> 该算法非常简单。 首先，创建一个矩形，该矩形的大小等于整个运动场的大小： </p><br><p><img src="https://habrastorage.org/webt/fh/mx/x-/fhmxx-boo4euwsc4dl2g0gfc2nk.png"></p><br><p> 然后，我们将其随机分为两部分-水平或垂直。 分隔线所在的位置，我们还随机选择： </p><br><p><img src="https://habrastorage.org/webt/ml/lo/jm/mllojmhd2qxiga7ma_skqxqoera.png"></p><br><p> 我们递归地对新矩形执行相同的操作： </p><br><p><img src="https://habrastorage.org/webt/ew/sw/wf/ewswwfagu3jcskhcebem5sd-jo8.png"></p><br><p> 在一定程度上一次又一次地： </p><br><p><img src="https://habrastorage.org/webt/fl/s-/hd/fls-hd2xm17ghbjbvnwpyhwzd_m.png"></p><br><p> 然后，在每个矩形中选择一个“房间”，即与原始尺寸相同或更小的矩形（但不小于3x3-在下面的矩形上更大）。 </p><br><p><img src="https://habrastorage.org/webt/r8/h1/_y/r8h1_yacj5bpuux_xmmxuwzdlo0.png"></p><br><p> 然后，房间通过走廊相连。 但是不是每个，但是有些棘手，因为它们存储在类似“ BSP”的结构中（有关更多详细信息，请参见原始算法）。 </p><br><p><img src="https://habrastorage.org/webt/5t/y6/3e/5ty63ewmz5eey4oaphja4uixjuu.png"><br>  <em>连接紫色和白色部分的走廊。</em> </p><br><p> 在原始算法中，房间和走廊的颜色相同（即相等），因此仅在房间顶部绘制走廊。 在我的情况下，应保留原始房间，以便绘制走廊，就像在房间“后面”一样。 </p><br><p> 此外，如果房间（图中的绿松石色）穿过走廊，则应将其分成两个不同的部分（因此，可以用不同的颜色绘制同一条走廊）： </p><br><p><img src="https://habrastorage.org/webt/5n/wr/51/5nwr510wdeg8x9iw3cgy_eorsau.png"></p><br><p> 结果如下： </p><br><p><img src="https://habrastorage.org/webt/q4/hq/7r/q4hq7rocs2amqbt-guzspzcmbp4.png"></p><br><p> 然后开始标记垃圾单元的阶段： </p><br><p><img src="https://habrastorage.org/webt/f0/ob/sc/f0obscdf1tabhec9mxv4m-wrj5s.png"></p><br><p> 正如我已经写过的，任何扇区都不能小于3x3单元。 这是由于以下事实：该扇区必须被墙壁包围（每侧至少1个单元），并且必须至少具有一个自由空间单元： </p><br><p><img src="https://habrastorage.org/webt/iy/e8/ne/iye8ne6qltvzxtwrpgrtjgmgeae.png"></p><br><p> 因此，所有不符合此规则的单元格都将被标记。 但是，只要接受它，您就无法删除它们-如此多的连接消失了，而且级别很薄。 </p><br><p> 而是，为每个标记的单元格搜索其可以加入的扇区（遵守3x3规则）： </p><br><p><img src="https://habrastorage.org/webt/nc/6q/-y/nc6q-yh8jlkx_rhlilpamtzt27s.png"><br>  <em>如果该单元格仍不能归因于任何扇区，则将其删除（但在这种情况下不能删除-此处一切正常）。</em> </p><br><p> 在最后阶段，将这张精美的图片矢量化，并将绘制的扇区变成多边形盒-这样的多边形，其中每个边缘要么严格垂直要么严格水平（可能有一个更科学的名称）： </p><br><p><img src="https://habrastorage.org/webt/xx/8x/8v/xx8x8vpyawz-uricpycndaadgfy.png"></p><br><h2 id="generaciya-iznachalnoy-geometrii-planirovka-pomescheniy"> 初始几何图形生成：房间布局 </h2><br><p><img src="https://habrastorage.org/webt/7w/jh/nb/7wjhnbk6xzc6zmdaqyiufpq7t5m.gif"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一篇文章</a>被作为依据。 该算法比以前的算法要复杂一些，但火箭科学也没有。 </p><br><p> 首先，在运动场中填充特定的停止值，然后在其上随机清除一个矩形区域： </p><br><p><img src="https://habrastorage.org/webt/4n/24/py/4n24pyropjvmm0d8gsmzj9znte0.png"></p><br><p> 清理随机矩形的阶段进行了多次（也是随机的）次数，因此，获得了水准仪的外部轮廓： </p><br><p><img src="https://habrastorage.org/webt/np/4v/fi/np4vfi_iumlrznv8bsy8ba3babk.png"></p><br><p> 在自由空间中，房间生长点是随机分散的（最小房间大小为3x3）： </p><br><p><img src="https://habrastorage.org/webt/2y/wm/3n/2ywm3n3lgak23tcn0dmyshbicne.png"></p><br><p> 房间生长的第一阶段开始-为每个房间选择最大的一面，该面仍然可以生长，并且以一个单元格增长（如果有多个相同长度的面，则是一个随机面）。 房间依次移动，因此没有路口。 </p><br><p><img src="https://habrastorage.org/webt/-b/4r/cd/-b4rcdczwe-_hu8xvha_cko1ihk.gif"></p><br><p> 然后将房间转换为多用盒： </p><br><p><img src="https://habrastorage.org/webt/pd/j8/qo/pdj8qos36_hf4slo-jlm2eailsw.png"></p><br><p> 第二阶段开始增长-在这一阶段，这一方面可以分为几个部分。 与第一阶段不同，它不会一次生长一个细胞，而是立即生长到最大停止位置-避免了房间接合处的“梯子”。 如果经过所有房间后仍然有空的牢房，则重复该循环。 </p><br><p> 结果是充满了空间： </p><br><p><img src="https://habrastorage.org/webt/mi/8j/zf/mi8jzfzhpksr2cz7jzd1_k3gmng.png"></p><br><p> 然后以栅格的形式绘制多边形框，并且（如“ BSP”生成器一样），标记“垃圾”单元的阶段开始： </p><br><p><img src="https://habrastorage.org/webt/ev/na/ru/evnaruhyjwsei7hfbywiiuxyzq4.png"></p><br><p> 并将它们加入现有行业： </p><br><p><img src="https://habrastorage.org/webt/1h/yv/kf/1hyvkfcnerw5yu30txvbztecfzw.png"><br>  <em>在这里，不可能附加所有单元格-多余的单元格被删除了。</em> </p><br><p> 结果将转换回多边形框： </p><br><p><img src="https://habrastorage.org/webt/ji/l3/yq/jil3yqqnbqpf4cfjyx-sklb_g8w.png"></p><br><h2 id="ochistka-ot-musornyhsekciy"> 清洁垃圾区 </h2><br><p> 有时会出现其中不遵守3x3规则的部分： </p><br><p><img src="https://habrastorage.org/webt/6v/zx/2v/6vzx2vnhvhn_kkxvqp1jyzenh6g.png"></p><br><p> 您可以尝试“还原”这些部分，但我采用了更简单的方法，只需删除它们即可： </p><br><p><img src="https://habrastorage.org/webt/gc/5s/4y/gc5s4yzeywvc6pi1kh0apfk90pm.png"></p><br><h2 id="postroenie-soedineniy"> 建筑连接 </h2><br><p><img src="https://habrastorage.org/webt/af/3m/w2/af3mw25mgkjtqwskriypbpzzaeo.gif"></p><br><p> 对于每个部分，将搜索其相邻部分，并在此类部分的接触位置中创建连接。 在两侧都创建了连接-如果A部分与B部分接触，则将存在从A到B以及从B到A的连接。结果是一个双向图。 </p><br><h2 id="ochistka-ot-musornyh-podgrafov"> 清除垃圾子图 </h2><br><p> 有时，由于清理了垃圾部分，因此我们得到的不是一个图，而是几个独立的图，如本例所示： </p><br><p><img src="https://habrastorage.org/webt/yi/s5/5u/yis55urvft0bohq8x0dsurgyyam.png"></p><br><p> 在这种情况下，选择子图作为主要图，子图的部分区域最大，其余部分被删除（“区域”用引号引起，因为尽管可以计算多边形框的实际面积，但我简化了任务，并考虑了边界框的面积-这是错误的，但适用于发电机）。 </p><br><h2 id="ochistka-ot-izlishnih-soedineniy"> 去除多余的化合物 </h2><br><p> 如果每个扇区到与之相连的每个通道都有一条通道，则在水平面上将有太多的门，并且会更强烈地感觉到它是生成的。 因此，在此阶段，将删除多余的连接： </p><br><p><img src="https://habrastorage.org/webt/oa/sh/oy/oashoyuavho98281lo_s4hpc-ks.gif"></p><br><p> 为了获得更多的随机性，我不会以最少的通过次数生成生成树，而是一次删除一个随机边（在当前步骤中从所有可能的情况中随机选择）。 </p><br><p>  <em>虽然，当我写这篇文章时，想法似乎是随机选择初始扇区，并删除已经更有效的边缘算法。</em> </p><br><h2 id="randomizaciya-soedineniy"> 连接随机化 </h2><br><p><img src="https://habrastorage.org/webt/ok/zl/vk/okzlvk4rclc7x3imkpjnjza3kje.gif"><br>  <em>在下文中，插图将来自另一代人，因为</em>  <em>在上一个中，生成器中存在一个错误，由于该错误导致其他图片不正确。</em> </p><br><p> 但是没有单个多余连接的级别看起来也不是很人道，因此引入了一些混乱： </p><br><ol><li> 恢复一些删除的边缘。 </li><li> 有些变成过道。 </li></ol><br><p> 此外，在其间形成通道的那些部分合并为一个： </p><br><p><img src="https://habrastorage.org/webt/nh/j_/uj/nhj_ujd0n7sqjdnddlvs9uozq5u.gif"><br>  <em>如果在您看来，在此插图中，重新出现了在上一步删除的连接-在您看来：)。</em>  <em>当我阅读文字时，在我看来也是如此，但是仔细看一下前面的插图，很明显，一切都很好。</em> </p><br><h2 id="generaciya-sekretnyh-komnat"> 秘密房间的产生 </h2><br><p> 在图上选择了只有一个连接的扇区： </p><br><p><img src="https://habrastorage.org/webt/xt/ku/qw/xtkuqweqgctwcbcckilick4-es4.png"></p><br><p> 如果有几个这样的扇区，则它们全部聚集在一个阵列中，并按“区域”排序。 然后，该数组被随机截断（但是至少要保留一个元素）。 这些部门将成为秘密房间： </p><br><p><img src="https://habrastorage.org/webt/pf/w0/yu/pfw0yufvv3orwiw_xohtfii8gqi.png"></p><br><h2 id="generaciya-scenariya"> 脚本生成 </h2><br><p><img src="https://habrastorage.org/webt/p2/ql/dn/p2qldn0n-scgjotykszlvsvd05a.gif"></p><br><p> 首先，选择具有最少空闲连接数的扇区（即，靠近图形“边缘”的扇区）： </p><br><p><img src="https://habrastorage.org/webt/lc/iw/7v/lciw7vahyrhoirla-hyahd7jzhu.png"><br>  <em>在此图示中，选择了一个扇区，但是如果有更多扇区，则无论如何都会（随机）选择一个扇区。</em> </p><br><p>  <em>注意</em>  <em>在本文的校对过程中，我能够想到一种情况，一个空闲连接数最少的扇区不仅会处于边缘，而且为其分配脚本将导致无法实现的目标。</em>  <em>实际上，您可以选择任何扇区，但只能选择一个扇区，此后该图将不会分成几个子图。</em> </p><br><p> 接下来，选择连接到当前扇区并且只有一个空闲连接的扇区。 它们很有可能会用于继续执行脚本。 例如，如果图形与下图相同，则问题所指示的扇区可以包含在列表中。 </p><br><p><img src="https://habrastorage.org/webt/6u/b6/vf/6ub6vfbxncsmbug4optzec19gyw.png"><br>  <em>秘密室用灰色标记，十字线是应在原始图中删除的那些连接，而源扇区为加号。</em> </p><br><p>  <em>注意</em>  <em>在本文的校对过程中，在我看来，仅存在一个连接的条件太严格，与上一步中的条件相同就足够了-因此删除该扇区后，该图将不会破裂。</em> </p><br><p> 然后，将脚本编号分配给该扇区列表（只是一个数字，在此阶段并不表示任何特定的含义），并且此脚本列表将边界列表的边界处的连接标记为已关闭。 </p><br><p><img src="https://habrastorage.org/webt/tw/4w/3w/tw4w3wxhybxndd5_94mw-l0e1zc.png"><br>  <em>在这些插图中，不同的场景将具有不同的扇区填充颜色。</em>  <em>它们与扇形边框的颜色无关（在接下来的步骤中将对其进行校正，但在这一步中，对我来说更方便）。</em> </p><br><p> 接下来，选择下一个扇区，编译一个列表，并用新的场景标记该列表： </p><br><p><img src="https://habrastorage.org/webt/qo/01/qw/qo01qww9cg-s2km6vfrjvoqb_vk.png"></p><br><p> 注意红色方块内的小蓝点-这是场景开瓶器的绘制方式-即 在带有红色脚本的区域内的某个地方，将有一个键或开关，以打开带有蓝色脚本的扇区的通道。 </p><br><p> 一直持续到没有可用的空闲扇区为止： </p><br><p><img src="https://habrastorage.org/webt/5f/ok/yn/5fokynxff0gfpspu7-d8paaw7wi.png"></p><br><p> 最近的扇区未分配脚本，而仅分配了方案启动器。 该扇区将是玩家开始游戏的扇区。 </p><br><p> 对于此级别： </p><br><ul><li> 玩家从起始区域开始，在那里找到黄色区域的“开瓶器”，然后去那里。 </li><li> 在黄色部分中，打开蓝色部分，然后去那里。 </li><li> 在蓝色区域中打开绿色，然后去那里。 </li><li> 在绿色区域中打开紫色，然后转到那里。 </li><li> 以紫色打开红色。 </li><li> 红色-蓝色。 </li><li> 他在哪里找到末级开关。 </li></ul><br><p> 示意性地可以如下所示： </p><br><p><img src="https://habrastorage.org/webt/c7/6o/xd/c76oxdwcgff53io6pv3sfcptpuu.png"></p><br><p>  “开启者”可以是钥匙或开关，也可以是其他任何东西，例如，消灭任何部门中所有敌人的任务（但我不打算在不久的将来由发电机或发动机支持）。 </p><br><h2 id="optimizaciya-soedineniy"> 连接优化 </h2><br><p><img src="https://habrastorage.org/webt/5q/vl/gw/5qvlgwjtnablead4upxcwph7m6k.gif"></p><br><p> 在此步骤中，为每个连接选择了一侧（您还记得，最初在两个方向上都生成了连接）。 这对于使关卡看起来更“手动”并简化下一步是必要的<em>（但对于更有趣的关卡类型，我计划在不久的将来采取“对某些连接进行“优化”的步骤）</em> 。 </p><br><h2 id="sozdanie-dverey-iokon"> 创建门窗 </h2><br><p><img src="https://habrastorage.org/webt/xr/je/m5/xrjem5kqzr7ncka2vuf8nsukw2c.gif"></p><br><p> 对于每个扇区，都将查看其所有连接（在上一步之后，该连接仅在一个方向上查看），并且在查看的每个连接上都放置了门窗。 </p><br><ul><li> 首先，在连接处选择一个点，最好靠近中心。 </li><li> 然后在这一点上放置一扇门或一扇窗户（如果与秘密室相连，则是秘密墙）。 </li><li> 如果放置门，则门的大小可以为1到3个单元（一个是普通门，两个或三个是厚的密闭门，按下开关即可打开）。 </li><li> 此外，连接分为两部分-所选点之前的部分和之后的部分。 并且，如果之前或之后还有空间，则将以递归方式调用该函数。 </li></ul><br><p> 为了使关卡看起来更有趣，在不同的步骤中放置门或窗的可能性不同： </p><br><ol><li> 在第一步，门总是被放置，因为 如果只有窗户，连接有什么用？ </li><li> 在第二步中，以高于门的概率（75％）放置窗。 </li><li> 如果有第三步（例如，连接很长），则必须在其上放置一个窗口。 </li><li> 在第四步的情况下，门或窗户的放置可能性相同。 </li><li> 如果连接很长，则生成器将返回第二步。 </li></ol><br><h2 id="vybor-deystviya"> 动作选择 </h2><br><p> 尽管这与生成无关，但可视化在这一步发生了变化-现在，扇区边框以脚本的颜色绘制： </p><br><p><img src="https://habrastorage.org/webt/rc/6y/xv/rc6yxvsq6duv-xdujaamzq0fdry.png"><br>  <em>起始扇区为浅灰色，最终扇区为蓝色。</em>  <em>还要注意，不是绘制了秘密室的门（左侧为深灰色），而是绘制了一面墙-一切正确，这是一面秘密墙。</em> </p><br><p> 接下来，选择可以放置键的扇区： </p><br><p><img src="https://habrastorage.org/webt/kl/os/jz/klosjzmyvv_tl2djbz5v6b9sqze.png"></p><br><p> 它们的选择非常简单： </p><br><ul><li> 如果这是一个秘密房间，则其中不能有“开启者”，也不能将钥匙放在那里。 </li><li> 您也不能将密钥也放置在最终扇区中，因为它是最终的。 </li><li> 另外，钥匙不能打开双开门和三开门-由于发动机的特性，只能使用开关打开<em>（上图中没有这样的扇区）</em> 。 </li></ul><br><p> 此后，随机选择一个级别（从零到三个）的键数，然后从可用的扇区列表中随机选择其中将有键的那些键。 </p><br><p> 在其余的扇区中将有开关。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418685/">https://habr.com/ru/post/zh-CN418685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418675/index.html">我如何去柏林Droidcon</a></li>
<li><a href="../zh-CN418677/index.html">关于RTOS的全部真相。 第6条。 其他RTOS服务</a></li>
<li><a href="../zh-CN418679/index.html">我们为Svelte用“ material”按钮编写一个组件</a></li>
<li><a href="../zh-CN418681/index.html">友谊日-为我们的朋友提供所有JetBrains IDE的50％优惠</a></li>
<li><a href="../zh-CN418683/index.html">创建一个模拟器街机。 第二部分</a></li>
<li><a href="../zh-CN418687/index.html">3.5“革命：带有蒸汽的软盘的小繁荣的细节</a></li>
<li><a href="../zh-CN418689/index.html">如何使用在线拍卖的示例在Figma中创建组件库，节省预算</a></li>
<li><a href="../zh-CN418691/index.html">牧场主：5分钟内使用裸机进行Kubernetes</a></li>
<li><a href="../zh-CN418693/index.html">为什么幸福很难在大脑中发现</a></li>
<li><a href="../zh-CN418695/index.html">反盗版战争-帝国反击</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>