<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤨 🏐 🤖 Pequeños experimentos multitarea en un microcontrolador 👠 🍚 🙎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En una de las notas anteriores, el autor trató de argumentar que al programar el microcontrolador, un simple cambio de tarea será útil en situaciones ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pequeños experimentos multitarea en un microcontrolador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461121/"><p>  En una de las notas anteriores, el autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trató de</a> argumentar que al programar el microcontrolador, un simple cambio de tarea será útil en situaciones en las que usar el sistema operativo en tiempo real es demasiado, y el bucle integral para todas las acciones requeridas es demasiado pequeño ( Él dijo, al igual que el Conde de La Fer).  Más precisamente, no muy poco, pero demasiado confundido. </p><br><p>  En una nota posterior, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se planeó</a> optimizar el acceso a los recursos compartidos por varias tareas usando colas basadas en buffers de anillo (FIFO) y una tarea separada especialmente asignada para esto.  Habiendo dispersado para diferentes tareas aquellas acciones que no están relacionadas entre sí, tenemos derecho a esperar un código más visible.  Y si al mismo tiempo obtenemos algo de comodidad y simplicidad, ¿por qué no probarlo? </p><br><p>  Obviamente, el microcontrolador no está diseñado para resolver ninguna tarea concebible del usuario.  Entonces, tal vez, un conmutador de tareas de este tipo será suficiente en muchas situaciones.  En resumen, es poco probable que un pequeño experimento duela.  Por lo tanto, para no ser infundado, su humilde servidor decidió escribir algo y probar sus garabatos. </p><a name="habracut"></a><br><p>  En los microcontroladores, debo decir que el requisito de contar con el tiempo como algo importante y rígido es más común que en las computadoras de uso general.  Ir más allá del marco en el primer caso es equivalente a la inoperancia, y en el segundo caso, solo conduce a un aumento en el tiempo de espera, que es bastante aceptable si los nervios están en orden.  Incluso hay dos términos "tiempo real suave" y "tiempo real duro". </p><br><p>  Permítame recordarle que estábamos hablando de controladores con el núcleo Cortex-M3,4,7.  Hoy es una familia muy común.  En los ejemplos a continuación, utilizamos el microcontrolador STM32F303, que forma parte de la placa STM32F3DISCOVERY. </p><br><p>  El conmutador es un archivo de ensamblador único. <br>  El ensamblador no le tiene miedo al autor, pero, por el contrario, inspira esperanza de que se alcance la velocidad máxima. </p><br><p>  Inicialmente, se planificó la lógica más simple de la operación del interruptor, que se presenta en la Figura 1 para ocho tareas. </p><br><p><img src="https://habrastorage.org/webt/ul/ot/pm/ulotpmeuad4zcxqcgroa_t92al0.jpeg"></p><br><p>  En este esquema, las tareas toman su porción de tiempo una por una y solo pueden dar el resto de su tic y, si es necesario, omitir algunas de ellas.  Esta lógica demostró ser buena, porque el tamaño cuántico puede hacerse pequeño.  Y esto es precisamente lo que se requiere para no plantear urgentemente una tarea para la que acaba de ocurrir una interrupción, y también para plantear, y luego reducir su prioridad.  El paquete que se acaba de recibir esperará silenciosamente 200-300 microsegundos hasta que su tarea reciba su tic.  Y si tenemos un Cortex-M7 operando a una frecuencia de 216 MHz, entonces 20 microsegundos para un tic es bastante razonable, ya que tomará menos de medio microsegundo para cambiar.  Y cualquier tarea del ejemplo anterior nunca tardará más de 140 microsegundos. </p><br><p>  Sin embargo, con un aumento en el número de tareas, incluso con un tamaño extremadamente pequeño del tiempo cuántico, la demora en el inicio de la actividad de la tarea requerida puede dejar de ser agradable.  En base a esto, y también teniendo en cuenta que solo una pequeña parte de las tareas realmente requieren un tiempo real difícil, se decidió modificar ligeramente la lógica del interruptor.  Se muestra en la Figura 2. </p><br><p><img src="https://habrastorage.org/webt/iq/gs/qi/iqgsqiqf4zigukr5vvrfi2sbgki.jpeg"></p><br><p>  Ahora seleccionamos solo una parte de las tareas que reciben un cuanto completo, y seleccionamos solo una marca para el resto, en el que se turnan en el juego.  En este caso, la subrutina de inicialización recibe un parámetro de entrada, a saber, el número de posición, a partir del cual todas las tareas se verán afectadas en los derechos y compartirán una marca.  Al mismo tiempo, el antiguo esquema permaneció disponible, para esto es suficiente establecer el valor del parámetro en cero o el número total de tareas.  Los costos de cambio aumentaron con solo unas pocas instrucciones del ensamblador. </p><br><p>  Se utilizan dos esquemas similares para permitir el acceso a recursos compartidos.  El primero, que se mencionó en una nota anterior, utiliza varios FIFO (o búferes circulares por el número de productores de mensajes) y una tarea de correspondencia separada.  Está diseñado para comunicarse con el mundo exterior y no requiere expectativas de tareas que generan mensajes.  Solo es necesario asegurarse de que las colas no estén llenas. </p><br><p>  El segundo esquema también utiliza una tarea separada para permitir el acceso, pero introduce expectativas porque administra el recurso interno en ambas direcciones.  Estas acciones no pueden estar vinculadas al tiempo.  La figura 3 muestra los componentes del segundo circuito. </p><br><p><img src="https://habrastorage.org/webt/-m/fb/4r/-mfb4rum70winng8agin4yqbf3e.jpeg"></p><br><p>  Los elementos principales que contiene son un búfer de solicitudes, de acuerdo con el número de tareas deseadas, y un indicador de acceso.  El funcionamiento de este diseño es bastante simple.  La tarea de la izquierda envía una solicitud de acceso a un lugar especialmente asignado para ello (por ejemplo, la tarea 2 escribe 1 en la Solicitud 2).  Tarea: el despachador selecciona a quién permitir y escribe el número de la tarea seleccionada en el indicador de resolución.  La tarea que recibió permiso realiza sus acciones y escribe el signo del final del acceso a la solicitud, el valor 0xFF.  El planificador, al ver que la solicitud se borra, restablece el indicador de permiso, restablece la solicitud anterior y restablece la solicitud de otra tarea. </p><br><p>  Aquí se pueden ver dos proyectos de prueba bajo IAR y una descripción de la placa STM32F3DISCOVERY utilizada.  En el primer proyecto, el ATS303 simplemente verificó su rendimiento y lo depuró.  Todos los LED instalados en esta placa fueron útiles.  Nadie resultó herido. </p><br><p>  El segundo borrador de BTS303 probó las dos opciones de asignación de recursos mencionadas.  En él, las tareas 1 y 2 generan mensajes de prueba que son recibidos por el operador.  Para comunicarme con el operador, tuve que agregar una bufanda con un puerto COM TTL, como se muestra en la foto a continuación. </p><br><p><img src="https://habrastorage.org/webt/za/hh/_c/zahh_cdcuabvgg-o92ukph_feji.jpeg"></p><br><p>  El operador usa un emulador de terminal.  Creo que el lector disculpará al autor por el color suave del tubo.  Se ve así. </p><br><p><img src="https://habrastorage.org/webt/1r/wa/aj/1rwaajjm2zx_ue2tglhquc7suw4.jpeg"></p><br><p>  Para iniciar todo el sistema, antes de resolver las interrupciones, se requieren pasos preliminares en el cuerpo de la tarea cero main (), que se presentan a continuación. </p><br><pre><code class="plaintext hljs">void main_start_task_switcher(U8 border); U8 task_run_and_return_task_number((U32)t1_task); U8 task_run_and_return_task_number((U32)t2_task); U8 task_run_and_return_task_number((U32)t3_human_link); U8 task_run_and_return_task_number((U32)t4_human_answer); U8 task_run_and_return_task_number((U32)task_5); U8 task_run_and_return_task_number((U32)task_6); U8 task_run_and_return_task_number((U32)task_7);</code> </pre> <br><p>  En estas líneas, el interruptor comienza primero y luego, a su vez, las siete tareas restantes. </p><br><p>  Aquí está el conjunto mínimo de llamadas necesarias para el trabajo. </p><br><pre> <code class="plaintext hljs"> void task_wake_up_action(U8 taskNumber);</code> </pre> <br><p>  Esta llamada se utiliza en una interrupción de un temporizador de hardware del usuario.  Los desafíos de las tareas mismas hablan por sí mismos. </p><br><pre> <code class="plaintext hljs"> void release_me_and_set_sleep_steps(U32 ticks); U8 get_my_number(void);</code> </pre><br><p>  Todas estas funciones están en el archivo del conmutador ensamblador.  Hay varias funciones más que son útiles para las pruebas, pero que no son necesarias. </p><br><p>  En el proyecto BTS303, la tarea 3 recibe comandos del operador desde el exterior y le envía las respuestas que provienen de la tarea 4. La tarea 4 recibe los comandos del operador de la tarea 3 y los ejecuta con posibles respuestas.  La tarea 3 también recibe mensajes de las tareas 1 y 2 y la envía a través de UART al emulador de terminal (por ejemplo, masilla). </p><br><p>  La tarea 0 (principal) realiza un trabajo auxiliar, por ejemplo, verifica el número de palabras que no se ven afectadas en el área apilada de cada tarea.  El operador puede solicitar esta información y tener una idea del uso de la pila.  Inicialmente, para cada tarea, se asigna un área de pila de 512 bytes (128 palabras) y es necesario monitorear (al menos en la etapa de depuración) que estas áreas no se acercan al desbordamiento. </p><br><p>  Las tareas 5 y 6 hacen cálculos en alguna variable de coma flotante común.  Para hacer esto, solicitan acceso desde la tarea 7. </p><br><p>  Hay otra característica adicional que se puede ver en los proyectos de prueba.  Está diseñado para que pueda despertar la tarea no después de que haya expirado el número de tics, sino después de un tiempo específico, y se ve así. </p><br><pre> <code class="plaintext hljs"> void wake_me_up_after_milliSeconds(U32 timeMS);</code> </pre> <br><p>  Para su implementación, también se requiere un temporizador de hardware adicional, que también se implementa en casos de prueba. </p><br><p>  Como puede ver, la lista de todas las llamadas necesarias cabe en una página. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461121/">https://habr.com/ru/post/461121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461099/index.html">Juego AirAttack! - nuestra primera experiencia de desarrollo de realidad virtual</a></li>
<li><a href="../461101/index.html">Android Jetpack Compose Primera impresión</a></li>
<li><a href="../461105/index.html">5 complementos útiles para webpack</a></li>
<li><a href="../461107/index.html">Dosímetro para Seryozha. Parte II Tubos centenarios vs átomo pacífico</a></li>
<li><a href="../461113/index.html">Cinco años de uso de C ++ para proyectos de microcontroladores en producción</a></li>
<li><a href="../461125/index.html">La tarea de crear códigos numéricos secuenciales para numerar mensajes en el código fuente en Visual Studio (ej. C #)</a></li>
<li><a href="../461127/index.html">Análisis de rendimiento de VM en VMware vSphere. Parte 3: Almacenamiento</a></li>
<li><a href="../461129/index.html">Sobre kote, esposa, dos hijos, la idea ... y no solo. Historia con continuación</a></li>
<li><a href="../461131/index.html">Carro carro ROS Parte 2. Software</a></li>
<li><a href="../461133/index.html">Probar el código de SQL Server con tSQLt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>