<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕘 ⚓️ 🕺🏾 Classification de la couverture terrestre à l'aide de l'eo-learn. 3e partie 👉🏾 🖖🏻 🚢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque vous avez besoin de meilleurs résultats que satisfaisants 


 Partie 1 
 2e partie 





 La transition de la zone de l'hiver à l'été est comp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classification de la couverture terrestre à l'aide de l'eo-learn. 3e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453354/"><p>  Lorsque vous avez besoin de meilleurs résultats que satisfaisants </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2e partie</a> </p><br><p><img src="https://habrastorage.org/webt/c0/ls/b2/c0lsb2it_c9qwggm74kdk3uglw4.png"></p><br><p> <em>La transition de la zone de l'hiver à l'été est composée d'images Sentinel-2.</em>  <em>Vous pouvez remarquer quelques différences dans les types de couverture dans la neige, qui ont été décrites dans un article précédent.</em> </p><a name="habracut"></a><br><h2 id="predislovie">  Préface </h2><br><p> Les deux dernières semaines ont été très difficiles.  Nous avons publié les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième</a> parties de nos articles sur la classification de la couverture sur l'ensemble du pays en utilisant le cadre <code>eo-learn</code> .  <code>eo-learn</code> est une bibliothèque open source pour créer une couche entre la réception et le traitement d'images satellites et l'apprentissage automatique.  Dans les articles précédents des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemples,</a> nous n'avons indiqué qu'un petit sous-ensemble des données et montré les résultats uniquement sur un petit pourcentage de l'ensemble de la zone d'intérêt (AOI - zone d'intérêt).  Je sais que cela semble au moins pas très impressionnant, et peut-être très grossier de notre part.  Pendant tout ce temps, vous avez été tourmenté par des questions sur la façon dont vous pouvez utiliser ces connaissances et les transférer au niveau <em>suivant</em> . </p><br><p>  Ne vous inquiétez pas, c'est à cela que sert le troisième article de cette série!  Prenez une tasse de café et asseyez-vous ... </p><br><h2 id="all-our-data-are-belong-to-you">  Toutes nos données vous appartiennent! </h2><br><p>  Êtes-vous déjà assis?  Peut-être laisser le café sur la table pendant une seconde, car maintenant vous entendrez les meilleures nouvelles pour aujourd'hui ... <br>  Chez Sinergise, nous avons décidé de publier l'ensemble complet de données pour la Slovénie pour 2017.  Gratuitement.  Vous pouvez accéder librement à 200 Go de données sous la forme de ~ 300 fragments d'EOPatch, chacun d'environ 1000x1000, dans une résolution de 10m!  Vous pouvez en savoir plus sur le format EOPatch dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article</a> sur l' <code>eo-learn</code> , mais en fait c'est un conteneur pour les données <em>géo-temporelles</em> EO (Observation de la Terre) et non-EO: par exemple, les images satellites, les masques, les cartes, etc. </p><br><p><img src="https://habrastorage.org/webt/dc/nt/gy/dcntgywsu4la7pdpwegv5m6eskc.png"><br>  <em>Structure EOPatch</em> ) </p><br><p>  Nous n'avons pas piraté lorsque nous avons téléchargé ces données.  Chaque EOPatch contient des images Sentinel-2 L1C, leur masque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s2cloudless</a> correspondant et la carte officielle de la couverture terrestre au format raster! </p><br><p>  Les données sont stockées sur AWS S3 à: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://eo-learn.sentinel-hub.com/</a> </p><br><p>  La désérialisation d'un objet EOPatch est assez simple: </p><br><pre> <code class="python hljs">EOPatch.load(<span class="hljs-string"><span class="hljs-string">'path_to_eopatches/eopatch-0x6/'</span></span>)</code> </pre> <br><p>  Par conséquent, vous obtenez un objet de la structure suivante: </p><br><pre> <code class="python hljs">EOPatch( data: { BANDS: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>), dtype=float32) } mask: { CLM: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=uint8) IS_DATA: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=uint8) IS_VALID: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=bool) } mask_timeless: { LULC: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=uint8) VALID_COUNT: numpy.ndarray(shape=(<span class="hljs-number"><span class="hljs-number">1010</span></span>, <span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), dtype=int64) } meta_info: { maxcc: <span class="hljs-number"><span class="hljs-number">0.8</span></span> service_type: <span class="hljs-string"><span class="hljs-string">'wcs'</span></span> size_x: <span class="hljs-string"><span class="hljs-string">'10m'</span></span> size_y: <span class="hljs-string"><span class="hljs-string">'10m'</span></span> time_difference: datetime.timedelta(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">86399</span></span>) time_interval: (datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) } bbox: BBox(((<span class="hljs-number"><span class="hljs-number">370230.5261411405</span></span>, <span class="hljs-number"><span class="hljs-number">5085303.344972428</span></span>), (<span class="hljs-number"><span class="hljs-number">380225.31836121203</span></span>, <span class="hljs-number"><span class="hljs-number">5095400.767924464</span></span>)), crs=EPSG:<span class="hljs-number"><span class="hljs-number">32633</span></span>) timestamp: [datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>), ..., datetime.datetime(<span class="hljs-number"><span class="hljs-number">2017</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)], length=<span class="hljs-number"><span class="hljs-number">80</span></span> )</code> </pre> <br><p>  L'accès aux différents attributs EOPatch est le suivant: </p><br><pre> <code class="python hljs">eopatch.timestamp eopatch.mask[<span class="hljs-string"><span class="hljs-string">'LULC'</span></span>] eopatch.data[<span class="hljs-string"><span class="hljs-string">'CLM'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] eopatch.data[<span class="hljs-string"><span class="hljs-string">'BANDS'</span></span>][<span class="hljs-number"><span class="hljs-number">5</span></span>][..., [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]]</code> </pre> <br><h3 id="eoexecute-order-66">  EOExecute Order 66 </h3><br><p>  Génial, les données se chargent.  Pendant que nous attendons l'achèvement de ce processus, examinons les capacités d'une classe qui n'a pas encore été discutée dans ces articles - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>EOExecutor</code></a> .  Ce module est engagé dans l'exécution et la surveillance du pipeline et permet d'utiliser le multi-threading sans efforts inutiles.  Plus de recherches sur Stack Overflow pour savoir comment paralléliser correctement le pipeline ou comment faire fonctionner la barre de progression dans ce mode - nous avons déjà tout fait pour vous! </p><br><p>  En outre, il gère les erreurs qui se produisent et peut générer un bref résumé du processus d'exécution.  Ce dernier est le moment le plus important pour être sûr de la répétabilité de vos résultats à l'avenir, afin que l'utilisateur n'ait pas à passer un temps de travail précieux à rechercher les paramètres qu'il a utilisés jeudi dernier à 9h après une nuit entière de réjouissances (ne mélangez pas alcool et programmation ça vaut le coup!).  Cette classe est également capable de générer un joli graphique de dépendance pour le pipeline, que vous pouvez montrer à votre patron! </p><br><p><img src="https://habrastorage.org/webt/_o/x7/0q/_ox70q41_uiebqp7opyqbeu0nx0.png"><br>  <em>Graphique de dépendance de pipeline généré par <code>eo-learn</code></em> </p><br><h3 id="eksperimenty-s-mashinnym-obucheniem">  Expériences d'apprentissage automatique </h3><br><p>  Comme promis, cet article est principalement destiné à étudier différents modèles avec <code>eo-learn</code> utilisant les données que nous avons fournies.  Ci-dessous, nous avons préparé deux expériences où nous étudions l'effet des nuages ​​et différents algorithmes de rééchantillonnage pendant l'interpolation temporelle sur le résultat final.  Après tout cela, nous commencerons à travailler avec les réseaux de convolution (CNN) et comparerons les résultats de deux approches - l'analyse pixel par pixel de l'arbre de décision et l'apprentissage en profondeur à l'aide de réseaux de neurones convolutionnels. </p><br><p>  Malheureusement, on ne peut pas donner une réponse sans ambiguïté quant aux décisions à prendre lors des expériences.  Vous pouvez étudier le sujet plus en profondeur et faire des hypothèses afin de décider si le jeu en vaut la chandelle, mais en fin de compte, le travail se résumera à des essais et des erreurs. </p><br><h3 id="igraem-s-oblakami">  Jouez avec les nuages </h3><br><p>  Les nuages ​​sont une énorme douleur dans le monde de l'OE, en particulier en ce qui concerne les algorithmes d'apprentissage automatique, où vous souhaitez les déterminer et les supprimer de l'ensemble de données pour une interpolation basée sur des valeurs manquantes.  Mais quel est le bénéfice de cette procédure?  Est-ce que ça vaut le coup?  Rußwurm et Körner, dans leur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article Classification multi-temporelle de la couverture terrestre avec encodeurs récurrents séquentiels, ont</a> même montré que pour l'apprentissage en profondeur, le processus de filtrage des nuages ​​est probablement absolument sans importance, car le classificateur lui-même est capable de détecter les nuages ​​et de les ignorer. </p><br><p><img src="https://habrastorage.org/webt/gz/c8/zs/gzc8zsp0nrdjtgbewqqysxulaiu.png"><br>  Activation de la couche d'entrée (en haut) et de la couche de modulation (en bas) dans la séquence d'images d'un fragment spécifique pour un réseau neuronal.  Vous remarquerez peut-être que ce fragment de réseau a appris à créer des masques cloud et à filtrer les résultats obtenus.  (Page 9 sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.researchgate.net/publication/322975904_Multi-Temporal_Land_Cover_Classification_with_Sequential_Recurrent_Encoders</a> ) </p><br><p>  Nous rappelons brièvement la structure de l'étape de filtrage des données (pour plus de détails, voir [article précédent] ()).  Après avoir pris des instantanés Sentinel-2, nous commençons à filtrer les instantanés cloud.  Toutes les images dans lesquelles le nombre de pixels non nuageux ne dépasse pas 80% sont soumises au filtrage (les valeurs de seuil peuvent différer selon les zones d'intérêt).  Après cela, pour obtenir des valeurs de pixels sur des jours arbitraires, des masques de nuage sont utilisés afin de ne pas prendre en compte ces données. </p><br><p>  Au total, quatre comportements sont possibles: </p><br><ol><li>  <strong>avec</strong> filtre d'image, <strong>donné des</strong> masques de nuages </li><li>  <strong>pas de</strong> filtre d'instantané, <strong>compte tenu des</strong> masques de cloud </li><li>  <strong>avec</strong> filtre d'image, à l'exclusion des masques de nuage </li><li>  <strong>sans</strong> filtre d'image, à l'exclusion des masques de nuage </li></ol><br><p><img src="https://habrastorage.org/webt/rd/3i/ne/rd3ineypd8f0akhs41yve8mtgso.png"><br>  <em>Affichage visuel de la pile d'images du satellite Sentinel-2.</em>  <em>Les pixels transparents à gauche signifient des pixels manquants en raison de la couverture nuageuse.</em>  <em>La pile centrale affiche les valeurs des pixels après avoir filtré les images et les interpoler avec un masque de nuage (cas 4), et la pile de droite montre le résultat de l'interpolation dans le cas sans filtrer les images et sans masques de nuage (1).</em>  <em>(Notez la piste - apparemment, l'article contient une faute de frappe, et c'était le contraire - cas 1 au centre et 4 à droite).</em> </p><br><p>  Dans le dernier article, nous avons déjà effectué une variation du cas 1 et montré les résultats, nous allons donc les utiliser pour la comparaison.  Préparer d'autres convoyeurs et former le modèle semble être une tâche simple - il vous suffit de vous assurer que nous comparons les valeurs correctes.  Pour ce faire, il suffit de prendre le même ensemble de pixels pour entraîner et valider le modèle. </p><br><p>  Les résultats sont présentés dans le tableau ci-dessous.  Vous pouvez voir qu'en général, l'influence des nuages ​​sur le résultat du modèle est assez faible!  Cela peut être dû au fait que la carte de référence est de très bonne qualité et que le modèle est capable d'ignorer la plupart des images.  Dans tous les cas, ce comportement ne peut être garanti pour aucun AOI, alors prenez le temps de jeter cette étape hors de vos modèles! </p><br><div class="scrollable-table"><table><thead><tr><th>  Modèle </th><th>  Précision [%] </th><th>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">F_1</a> [%] </th></tr></thead><tbody><tr><td>  Pas de filtres, pas de masque </td><td>  92,8 </td><td>  92,6 </td></tr><tr><td>  Pas de filtres, avec masque </td><td>  94,2 </td><td>  93,9 </td></tr><tr><td>  Avec filtre, sans masque </td><td>  94,0 </td><td>  93,8 </td></tr><tr><td>  Avec filtre, avec masque </td><td>  94,4 </td><td>  94,1 </td></tr></tbody></table></div><br><h3 id="vliyanie-raznyh-podhodov-k-resemplingu">  L'impact des différentes approches de rééchantillonnage </h3><br><p>  Le choix des options de rééchantillonnage temporel n'est pas évident.  D'une part, nous avons besoin d'un tableau détaillé d'images qui montrent bien les détails des images source - nous voulons inclure le nombre d'images le plus proche possible des données source.  D'un autre côté, nous sommes limités par les ressources informatiques.  La réduction de l'étape de rééchantillonnage double le nombre de trames après interpolation et augmente ainsi le nombre d'attributs utilisés dans la formation.  Une telle amélioration vaut-elle le coût des ressources?  C'est ce que nous devons découvrir. </p><br><p>  Pour cette expérience, nous utiliserons la variante 1 de l'étape précédente.  Après interpolation, nous rééchantillonnons avec les variations suivantes: </p><br><ol><li>  Rééchantillonnage uniforme avec un intervalle de 16 jours </li><li>  Rééchantillonnage uniforme avec un intervalle de 8 jours </li><li>  Le choix des "meilleures" dates, le nombre coïncide avec le cas 2. </li></ol><br><p>  L'échantillon dans le cas 3 est basé sur le plus grand nombre de dates communes pour tous les EOPatch dans la zone d'intérêt sélectionnée <br><img src="https://habrastorage.org/webt/xg/qa/9w/xgqa9w17-oe4dbtxca22yejwhzo.png"><br>  <em>Le graphique montre le nombre de fragments EOPatch qui contiennent des données pour chaque jour de 2017 (bleu).</em>  <em>Les lignes rouges indiquent les dates optimales pour le rééchantillonnage, qui sont basées sur les dates des images Sentinel-2 pour l'AOI 2017 donné.</em> </p><br><p>  En regardant le tableau ci-dessous, vous pouvez voir que les résultats ne sont pas très impressionnants, comme par le passé.  Pour les cas 2 et 3, le temps passé double, mais la différence avec l'approche initiale est inférieure à 1%.  Ces améliorations sont trop discrètes pour une utilisation pratique, nous pouvons donc considérer l'intervalle de 16 jours adapté à la tâche. </p><br><div class="scrollable-table"><table><thead><tr><th>  Modèle </th><th>  Précision [%] </th><th>  F_1 [%] </th></tr></thead><tbody><tr><td>  Uniformément tous les 16 jours </td><td>  94,4 </td><td>  94,1 </td></tr><tr><td>  Uniformément tous les 8 jours </td><td>  94,5 </td><td>  94,3 </td></tr><tr><td>  Choisir les meilleures dates </td><td>  94,6 </td><td>  94,4 </td></tr></tbody></table></div><br><p>  <em>Résultats de la précision globale et de la F1 pondérée pour différents pipelines avec un changement dans l'approche du rééchantillonnage.</em> </p><br><h2 id="glubokoe-obuchenie-ispolzuem-svyortochnuyu-neyronnuyu-set-cnn">  Deep Learning: Utilisation du réseau neuronal convolutif (CNN) </h2><br><p>  L'apprentissage en profondeur est devenu l'approche standard pour de nombreuses tâches, telles que la vision par ordinateur, le traitement de texte en langage naturel et le traitement du signal.  Cela est dû à leur capacité à extraire des modèles à partir d'entrées multidimensionnelles complexes.  Les approches classiques d'apprentissage automatique (comme les arbres de décision) ont été utilisées dans de nombreuses tâches de géodonnées temporelles.  Les réseaux convolutifs, d'autre part, ont été utilisés pour analyser la corrélation spatiale entre les images adjacentes.  Fondamentalement, leur utilisation se limitait à travailler avec des images uniques. </p><br><p>  Nous voulions étudier l'architecture des modèles d'apprentissage profond et essayer d'en choisir une capable d'analyser à la fois les aspects spatiaux et temporels des données satellitaires. </p><br><p>  Pour ce faire, nous avons utilisé Netvork temporel entièrement convolutionnel, TFCN, ou plutôt l'expansion temporelle vers U-Net, implémentée dans TensorFlow.  Plus précisément, l'architecture utilise des corrélations spatio-temporelles pour améliorer le résultat.  Un avantage supplémentaire est que la structure du réseau vous permet de mieux représenter les relations spatiales à différentes échelles grâce au processus de codage / décodage dans U-net.  Comme dans les modèles classiques, en sortie, nous obtenons une matrice bidimensionnelle d'étiquettes, que nous comparerons avec la vérité. </p><br><p><img src="https://habrastorage.org/webt/p0/jl/mg/p0jlmgxi9euwvodwonx4zrmezsw.png"></p><br><p>  Nous avons utilisé le modèle entraîné pour prédire les marques sur l'ensemble de test, et les valeurs obtenues ont été vérifiées avec la vérité.  Dans l'ensemble, la précision était de 84,4% et F1 était de 85,4%. </p><br><p><img src="https://habrastorage.org/webt/ol/z2/zj/olz2zjp3waghaak9hnirzcwa258.png"></p><br><p>  <em>Comparaison de différentes prédictions pour notre tâche.</em>  <em>Image visuelle (en haut à gauche), vraie carte de référence (en haut à droite), prédiction du modèle LightGBM (en bas à gauche) et prédiction U-net (en bas à droite)</em> </p><br><p>  Ces résultats ne montrent que le travail initial sur ce prototype, qui n'est pas hautement optimisé pour la tâche en cours.  Malgré cela, les résultats concordent avec certaines statistiques obtenues dans la région.  Pour libérer le potentiel d'un réseau neuronal, il est nécessaire d'optimiser l'architecture (ensemble d'attributs, la profondeur du réseau, le nombre de circonvolutions), ainsi que de définir des hyper paramètres (vitesse d'apprentissage, nombre d'époques, pondération de classe).  Nous nous attendons à approfondir ce sujet (ha ha) encore plus, et prévoyons de distribuer notre code lorsqu'il sera sous une forme acceptable. </p><br><h3 id="drugie-eksperimenty">  D'autres expériences </h3><br><p>  Vous pouvez trouver de <em>nombreuses</em> façons d'améliorer vos résultats actuels, mais nous ne pouvons ni les trier ni les essayer tous.  C'est à ce moment que vous apparaissez sur la scène!  Montrez ce que vous pouvez faire avec cet ensemble de données et aidez-nous à améliorer les résultats! </p><br><p>  Par exemple, un de nos collègues dans un proche avenir sera engagé dans la classification de la couverture basée sur la pile temporelle d'images <em>individuelles à l'</em> aide de réseaux de convolution.  L'idée est que certaines surfaces, par exemple artificielles, peuvent être distinguées sans caractéristiques temporelles - assez spatiales.  Nous serons heureux d'écrire un article séparé lorsque ce travail aboutira à des résultats! </p><br><h3 id="ot-perevodchika">  Du traducteur </h3><br><p>  Malheureusement, la partie suivante de cette série d'articles n'est pas sortie, ce qui signifie que les auteurs n'ont pas montré d'exemples de code source avec la construction de U-Net.  Comme alternative, je peux vous proposer les sources suivantes: </p><br><ol><li>  <em>U-Net: Réseaux convolutionnels pour la segmentation d'images biomédicales - Olaf Ronneberger, Philipp Fischer, Thomas Brox</em> est l'un des articles de base sur l'architecture U-Net qui n'implique pas de données temporelles. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://eo-learn.readthedocs.io/en/latest/examples/land-cover-map/SI_LULC_pipeline.html</a> - La page de documentation eo-learn, où se trouve (éventuellement) une version plus récente des pipelines de 1.2 parties. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/divamgupta/image-segmentation-keras</a> - Un référentiel avec plusieurs réseaux implémentés à l'aide de keras.  J'ai quelques questions sur les implémentations (elles sont légèrement différentes de celles décrites dans les articles originaux), mais en général, les solutions sont facilement adaptables à des fins personnelles et fonctionnent assez bien. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453354/">https://habr.com/ru/post/fr453354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453342/index.html">Mythes sur les employés distants que nous nous sommes détruits</a></li>
<li><a href="../fr453346/index.html">Technologies de stockage et de protection des données - le troisième jour de VMware EMPOWER 2019</a></li>
<li><a href="../fr453348/index.html">À l'intérieur d'Asyncio</a></li>
<li><a href="../fr453350/index.html">Diffusion ouverte du hall principal du RIT ++ 2019</a></li>
<li><a href="../fr453352/index.html">Comment les drones délivrent des médicaments essentiels au Ghana</a></li>
<li><a href="../fr453356/index.html">Tendances actuelles et recommandations sur l'agglomération des grandes institutions financières</a></li>
<li><a href="../fr453360/index.html">Ville sans embouteillage</a></li>
<li><a href="../fr453362/index.html">HabraConf # 1 - Vers l'arrière pour le backend</a></li>
<li><a href="../fr453364/index.html">Une histoire de déploiement qui a tout affecté</a></li>
<li><a href="../fr453366/index.html">Comment utiliser les virgules en anglais: 15 règles et exemples d'erreur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>