<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸ­ ğŸ¤ ğŸ™‡ğŸ» Projet de FAQ: Pourquoi les normes C ++ sont-elles publiÃ©es tous les trois ans? ğŸ‘‰ğŸ¼ ğŸ’ƒğŸ¿ ğŸ¥ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le WG21 a un calendrier strict (voir P1000 ) pour une sortie standard tous les trois ans. Et pas de retards. 

 Au cours de chaque cycle, nous recevon...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Projet de FAQ: Pourquoi les normes C ++ sont-elles publiÃ©es tous les trois ans?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/460665/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/9v/zg/u29vzg2wz-7letn3lbp4ulyk9um.jpeg" width="400"></div><br>  Le WG21 a un calendrier strict (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P1000</a> ) pour une sortie standard tous les trois ans.  Et pas de retards. <br><br>  Au cours de chaque cycle, nous recevons rÃ©guliÃ¨rement des questions Â«Pourquoi est-ce si strict?Â», En particulier de nouveaux membres du comitÃ© qui ne connaissent pas son histoire et les raisons de l'Ã©tat actuel des choses.  Et lors d'une tÃ©lÃ©confÃ©rence prÃ©liminaire avec l'administration de Cologne, plusieurs personnes ont recommandÃ© de dÃ©crire pourquoi nous faisions cela et comment la dÃ©cision a Ã©tÃ© prise d'adopter ce calendrier. <br><br>  J'ai peint tout cela sous forme de questions et rÃ©ponses pour le prochain projet de P1000 et j'en ai envoyÃ© une copie aux membres du comitÃ© en route pour Cologne.  Ce matÃ©riel sera publiÃ© dans la prochaine version publique de P1000, nous vous l'enverrons dans quelques semaines Ã  partir du moment actuel. <br><br>  Cependant, le projet de FAQ peut intÃ©resser le public, je vous en offre donc une copie.  J'espÃ¨re que, pour la plupart, il vous sera utile, vous Ã©clairera Ã  certains Ã©gards et peut-Ãªtre mÃªme vous divertira un peu. <br><br><a name="habracut"></a><br><h2>  Il y a des bogues dans la norme, devriez-vous reporter C ++ 20? </h2><br>  Bien sÃ»r, oui et non. <br><br>  Nous Ã©voluons dans une direction donnÃ©e Ã  une vitesse choisie: des corrections de bogues sont prÃ©vues pour cette derniÃ¨re annÃ©e, donc le calendrier du dÃ©but C ++ "19" (Kona) fixe une date limite pour arrÃªter l'ajout de fonctionnalitÃ©s (gel des fonctionnalitÃ©s) en C ++ "20", de sorte que nous avons eu un an pour corriger les bugs, notamment en travaillant avec les commentaires de diffÃ©rents pays cet Ã©tÃ©.  Avant le dÃ©but de 2020 (rÃ©unions Ã  Cologne, Belfast et Prague), nous devons donner un retour et appliquer toute autre solution aux problÃ¨mes, ainsi que des corrections de bugs. <br><br><h2>  Si nous avons une ou deux rÃ©unions supplÃ©mentaires, nous pourrions ajouter un &lt;nom de fonctionnalitÃ©&gt;, qui est presque prÃªt, alors devriez-vous reporter C ++ 20? </h2><br>  Bien sÃ»r, oui et non. <br><br>  Attendez quelques rÃ©unions supplÃ©mentaires (aprÃ¨s Prague), et C ++ 23 sera ouvert aux entreprises, et tout d'abord nous voterons pour l'ajout de &lt;fonctionnalitÃ© nom&gt; au projet de travail de C ++ 23.  C'est ce que nous avons fait avec les concepts: ils n'Ã©taient pas prÃªts pour la transition de TS directement en C ++ 17.  Par consÃ©quent, lors de la premiÃ¨re rÃ©union sur C ++ 20 (Ã  Toronto), ils ont votÃ© pour transfÃ©rer la fonctionnalitÃ© de base des concepts au projet C ++ 20, ce qui a donnÃ© beaucoup de temps pour amÃ©liorer et affiner le reste de la partie contradictoire de TS (syntaxe non Â«modÃ¨leÂ»), qui a Ã©tÃ© introduite. l'annÃ©e prochaine (San Diego).  Maintenant, toutes les fonctionnalitÃ©s sont prÃªtes. <br><br><h2>  Cela semble trop strict.  Pourquoi publier des versions IS Ã  intervalles fixes (trois ans)? </h2><br>  Parce que dans le cas de la sortie de C ++ IS, c'est l'une des deux options principales pour la gestion de projet, et l'expÃ©rience montre que cette option est meilleure que la seconde. <br><br><h2>  Quelles sont les deux options de gestion de projet pour la sortie de C ++ IS? </h2><br>  Heureux que vous ayez demandÃ©. <br><br>  Dans le cas d'une version, il existe deux options principales: choisir une fonctionnalitÃ© ou une date de sortie, et lorsque vous en sÃ©lectionnez une, vous perdez le contrÃ´le de la dÃ©finition de l'autre.  Vous ne pouvez pas contrÃ´ler simultanÃ©ment les deux.  En bref: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Si nous le contrÃ´lons <br></th><th>  Nous allons arrÃªter de le contrÃ´ler <br></th><th> Pouvons-nous travailler sur de Â«grandesÂ» fonctionnalitÃ©s pluriannuelles? <br></th><th>  Quand ajoutons-nous des fonctionnalitÃ©s au projet IS? <br></th><th>  Que faisons-nous si nous rencontrons des problÃ¨mes avec des fonctionnalitÃ©s supplÃ©mentaires? <br></th></tr><tr><td>  <b>Â«QuoiÂ»: fonctionnalitÃ©s que nous livrons</b> <br></td><td>  Â«QuandÂ»: date de sortie. <br></td><td>  Oui, dans les documents contenant les propositions et le projet de SI. <br></td><td>  Habituellement, plus tÃ´t pour effectuer davantage de tests d'intÃ©gration â†’ la stabilitÃ© moyenne du projet de travail est rÃ©duite. <br></td><td>  Nous retardons la publication de la norme. <br></td></tr><tr><td>  <b>Quand: Date de sortie</b> <br></td><td>  Â«QuoiÂ»: fonctionnalitÃ©s que nous livrons <br></td><td>  Oui, dans les documents avec des offres et des "branches de fonctionnalitÃ©s" dans TS. <br></td><td>  Habituellement plus tard, lorsque la fonctionnalitÃ© est mieux Ã©laborÃ©e â†’ la stabilitÃ© moyenne du projet de travail augmente. <br></td><td>  Nous supprimons la fonctionnalitÃ©, nous pourrons l'ajouter ultÃ©rieurement si elle est prÃªte au moment de l'envoi du prochain train IS. <br></td></tr></tbody></table></div><br>  J'explique: <br><br>  <b>(1) Â«QuoiÂ»: nous sÃ©lectionnons les fonctionnalitÃ©s et expÃ©dions comme prÃªt, pas besoin de choisir une heure de sortie</b> .  S'il s'avÃ¨re que vous avez besoin de plus de temps pour finaliser une fonctionnalitÃ© du projet de norme, alors le monde entier devra vous attendre.  Vous travaillez sur de grandes fonctionnalitÃ©s qui nÃ©cessitent plusieurs annÃ©es de dÃ©veloppement, puis vous essayez d'arrÃªter de travailler sur de nouvelles fonctionnalitÃ©s tout en stabilisant la version. <br><br>  Donc c'Ã©tait avec C ++ 98 (c'Ã©tait prÃ©vu vers 1994, BjÃ¶rn a dit que si la version ne sortait pas alors ce serait un Ã©chec) avec C ++ 11 (Ã§a s'appelait 0x parce que x Ã©tait attendu en 2007 )  Il s'agit d'une approche Â«laisser le patient sans surveillanceÂ» pour une durÃ©e indÃ©terminÃ©e, ce qui a entraÃ®nÃ© un retard dans les tests d'intÃ©gration et la libÃ©ration.  Et cela, Ã  son tour, a conduit Ã  une grande incertitude du marchÃ© concernant le calendrier de la prochaine norme, et si elle sera publiÃ©e (oui, non seulement les participants au dÃ©veloppement, mais mÃªme certains membres du comitÃ© sÃ©rieusement doutÃ©s en 1996 et 2009, apparaÃ®tront existe-t-il des versions pertinentes).  Pendant plusieurs annÃ©es, la plupart des compilateurs n'ont pas respectÃ© la norme, car personne ne savait combien de changements incompatibles le comitÃ© allait dÃ©ployer dans la nouvelle version, ou quand serait-il attendu du tout?  Cela a conduit Ã  une grande variÃ©tÃ© et Ã  une fragmentation de la prise en charge C ++ dans les compilateurs disponibles pour la communautÃ©. <br><br>  Pourquoi avons-nous fait cela, sommes-nous des idiots?  Pas vraiment, ils Ã©taient juste inexpÃ©rimentÃ©s et ... disons, "optimistes".  C'Ã©tait une route pavÃ©e des meilleures intentions.  En 1994-1996 et en 2007-2009, nous pensions vraiment que nous allions maintenant proposer une, deux ou trois rÃ©unions de plus, nous ferions tout et chaque fois, elles seraient reportÃ©es de quatre ans.  Et maintenant, ils ont vu de leur propre expÃ©rience qu'il ne peut y avoir de transfert pendant un an ou deux. <br><br>  Heureusement, tout a changÃ© grÃ¢ce Ã  l'option (2). <br><br>  <b>(2) Â«QuandÂ»: nous sÃ©lectionnons la date de sortie et expÃ©dions les fonctionnalitÃ©s qui sont prÃªtes, vous n'avez pas besoin de sÃ©lectionner un ensemble de fonctionnalitÃ©s</b> .  S'il s'avÃ¨re que plus de temps est nÃ©cessaire pour affiner une fonction d'un projet de norme, nous la rejetons et expÃ©dions ce qui est prÃªt.  Vous pouvez continuer Ã  travailler sur de grandes fonctionnalitÃ©s, dont la crÃ©ation prend du temps comme pour plusieurs versions, mais faites-le dans des "branches" tierces, en les ajoutant Ã  la branche maÃ®tre IS dÃ¨s que vous le pouvez.  Et vous travaillez constamment sur les fonctionnalitÃ©s, car leur dÃ©veloppement est complÃ¨tement distinct de la version actuelle (il n'y a pas de gros point de connexion). <br><br>  Nous adhÃ©rons Ã  cette dÃ©marche depuis 2012 et ne souhaitons pas l'abandonner.  Il s'agit de l'approche consistant Ã  Â«rafistoler rÃ©guliÃ¨rement le patientÂ», ce qui conduit Ã  s'attendre Ã  une qualitÃ© supÃ©rieure en raison des intÃ©grations rÃ©guliÃ¨res forcÃ©es et au refus d'ajouter du travail au projet IS jusqu'Ã  ce qu'il atteigne un certain niveau de stabilitÃ©, gÃ©nÃ©ralement dans la branche des fonctionnalitÃ©s.  Cela crÃ©e Ã©galement un cycle de publication prÃ©visible sur lequel le marchÃ© peut compter.  Au fil des ans, les auteurs de compilateurs ont commencÃ© de plus en plus tÃ´t, aprÃ¨s la prochaine version, Ã  publier des versions de leurs produits conformes Ã  la norme, ce qui n'Ã©tait jamais arrivÃ© auparavant.  Et en 2020, nous attendons la sortie d'implÃ©mentations entiÃ¨rement conformes dans un an avec la sortie de la norme, ce qui n'a jamais eu lieu auparavant.  Ce n'est que pour le bÃ©nÃ©fice de l'ensemble du marchÃ© - dÃ©veloppeurs, utilisateurs, enseignants. <br><br>  Et notez Ã©galement que depuis que nous avons commencÃ© Ã  adhÃ©rer Ã  cette approche, nous avons commencÃ© Ã  en faire plus (si mesurÃ© par des fonctionnalitÃ©s grandes, moyennes et petites) et avec une qualitÃ© supÃ©rieure (si mesurÃ© par une rÃ©duction stricte du nombre de rapports de bogues et de commentaires sur projets de chaque norme).  Bien que nous expÃ©dions ce que nous avons rÃ©ussi Ã  prÃ©parer (et si nous n'avons pas rÃ©ussi quelque chose, nous ne l'expÃ©dions pas). <br><br><h2>  Ã€ quel point Ãªtes-vous sÃ©rieux au sujet de l'approche (2)?  Si, selon un membre faisant autoritÃ© du comitÃ©, une grande caractÃ©ristique est Â«presque prÃªteÂ», alors vous serez tentÃ© d'attendre un peu, non? </h2><br>  TrÃ¨s sÃ©rieusement, et non. <br><br>  Nous avons des statistiques: en 2016 Ã  Jacksonville, lorsque nous avons finalement dÃ©cidÃ© des fonctionnalitÃ©s pour C ++ 17, BjÃ¶rn Straustrup a pris la parole lors d'une rÃ©union plÃ©niÃ¨re avec une proposition d'inclure des concepts dans C ++ 17.  Quand aucun consensus n'a Ã©tÃ© atteint, Straustrup a Ã©tÃ© directement demandÃ© s'il voulait retarder la sortie de C ++ 17 pendant un an afin d'y inclure des concepts.  BjÃ¶rn a rÃ©pondu Â«nonÂ» sans hÃ©sitation et Ã©vasion, et a ajoutÃ© que C ++ 17 sans concepts Ã©tait plus important que C ++ 18 ou C ++ 19 avec concepts, bien que Straustrup y travaille depuis environ 15 ans.  Le choix Ã©tait le suivant: (2) nous publions C ++ 17 sans concepts, puis C ++ 20 avec concepts (ce que nous avons fait), ou (1) nous renommons C ++ 17 en C ++ 20, qui est isomorphe (2) Ã  l'exception de sauter C ++ 17 et de refuser de libÃ©rer ce qui Ã©tait dÃ©jÃ  prÃªt pour C ++ 17. <br><br><h2>  Qu'en est-il du compromis entre (1) et (2)?  Disons, nous adhÃ©rons gÃ©nÃ©ralement Ã  (2), mais avec Â«peuÂ» de flexibilitÃ© pour obtenir Â«un peuÂ» de temps supplÃ©mentaire, si vous avez besoin d'affiner la fonctionnalitÃ©? </h2><br>  Non, car il s'avÃ¨re (1). <br><br>  Fred Brooks dans <i>The Mythical Man-Month a</i> populairement expliquÃ© "le petit transfert mythique" et a conclu: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ne permettez pas de petits transferts</a> ." <br><br>  Imaginez que nous ayons portÃ© C ++ 20.  Nous devions revenir de (2) Ã  (1), peu importe Ã  quel point nous essayons de l'Ã©viter, et en mÃªme temps, nous ne recevrions aucun avantage.  Si nous dÃ©cidions de reporter le C ++ 20 pour le peaufiner, nous retarderions la norme d'au moins deux ans.  Il n'y a pas de concepts tels que le transfert d'une ou trois rÃ©unions, car pendant ce temps, d'autres continueront (assez) Ã  dire: "Eh bien, ma fonctionnalitÃ© n'a besoin que d'une rÃ©union de plus, nous l'avons toujours reportÃ©e, transfÃ©rons-en une autre."  Et si nous transfÃ©rons au moins deux ans, cela signifie que C ++ 20 devient C ++ 22, et trÃ¨s probablement C ++ 23 ... mais nous allons dÃ©jÃ  expÃ©dier C ++ 23!  - C'est-Ã -dire, dans tous les cas, nous expÃ©dierons C ++ 23, et la seule diffÃ©rence est que nous <b>ne</b> transfÃ©rons <b>pas</b> C ++ 20 avec une grande quantitÃ© de travail effectuÃ©, prÃªt Ã  Ãªtre publiÃ©, et ne faisons pas attendre le monde entier encore trois ans.  Le retard ne bÃ©nÃ©ficiera pas Ã  ces fonctionnalitÃ©s, la plupart d'entre elles ou toutes ensemble. <br><br>  Par consÃ©quent, la phrase Ã©quivaut Ã  Â«transformons C ++ 20 en C ++ 22 ou C ++ 23Â», et la rÃ©ponse simple: Â«oui, nous aurons C ++ 23, mais en plus de C ++ 20, et pas Ã  sa place. "  Un dÃ©lai C ++ 20 signifie ignorer C ++ 20 au lieu de publier un bon produit fini et stable, et cela ne sera pas avantageux. <br><br><h2>  Mais la fonctionnalitÃ© X est cassÃ©e / cela prend plus de temps qu'il ne nous en reste pour corriger les bugs en C ++ 20! </h2><br>  Pas question!  Nous pouvons simplement le couper. <br><br>  Dans ce cas, quelqu'un devra rÃ©diger une lettre en EWG ou LEWG (selon la situation) avec une description de la situation et proposer de supprimer la fonctionnalitÃ© du projet de travail IS.  Ces groupes considÃ©reront l'appel, et s'ils dÃ©cident que la fonctionnalitÃ© est cassÃ©e (et le plÃ©num est d'accord avec eux), alors la fonctionnalitÃ© sera reportÃ©e jusqu'Ã  la prochaine version C ++.  Nous l'avons dÃ©jÃ  fait avec les concepts C ++ 0x. <br><br>  Mais dans le cas de (1), nous transfÃ©rerons non seulement cette fonctionnalitÃ©, mais l' <b>ensemble complet des fonctionnalitÃ©s</b> du C ++ 20 au C ++ 23!  Ce serait ... un buste. <br><br><h2>  L'approche (2) signifie-t-elle des versions Â«majeures / mineuresÂ»? </h2><br>  Non.  Au dÃ©but, nous l'avons dit jusqu'Ã  ce que nous rÃ©alisions que (2) signifie seulement que vous n'avez pas besoin de choisir un ensemble de fonctionnalitÃ©s, mÃªme du point de vue de la version Â«principale / secondaireÂ». <br><br>  L'approche (2) signifie seulement Â«nous expÃ©dions ce qui est prÃªtÂ».  Les versions sont obtenues: <br><br><ul><li>  la mÃªme taille (c'est-Ã -dire gÃ©nÃ©ralement moyenne) pour les fonctionnalitÃ©s est Â«plus petiteÂ» car moins de temps est consacrÃ© Ã  leur dÃ©veloppement (disons moins de trois ans chacune), et en gÃ©nÃ©ral, nous obtenons le mÃªme nombre de fonctionnalitÃ©s terminÃ©es dans la version; <br></li><li>  et une taille variable (ce n'est pas nÃ©cessaire une ou deux fois) pour les fonctionnalitÃ©s "plus grandes", qui prennent plus de temps (disons, plus de trois ans chacune), et chaque version du SI inclut autant de ces fonctionnalitÃ©s qu'elles parviennent Ã  complÃ©ter pour Ãªtre publiÃ©es.  Par consÃ©quent, dans certaines versions, il y en a plus, dans d'autres moins. <br></li></ul><br>  C ++ 14 et C ++ 17 Ã©taient relativement petits, car beaucoup d'efforts de normalisation ont Ã©tÃ© consacrÃ©s aux fonctionnalitÃ©s de longue durÃ©e dÃ©crites dans les propositions d'implÃ©mentation (par exemple, les contrats) et aux Â«branches de fonctionnalitÃ©sÂ» dans TS (par exemple, les concepts). <br><br><h2>  C ++ 20 est une excellente version ... </h2><br>  Oui  C ++ 20 possÃ¨de de nombreuses fonctionnalitÃ©s majeures.  Trois des plus grands commencent par Â«koÂ» (concepts, contrats, coroutines), nous pourrions donc l'appeler co_cpp20.  Ou co_dÃ©pendant. <br><br><h2>  ... et ce n'est pas trop fait dans le cycle de trois ans pour C ++ 20? </h2><br>  Non, voir ci-dessus "une fois Ã  la fois n'est pas nÃ©cessaire." <br><br>  Le C ++ 20 est important non pas parce que nous avons fait plus en trois ans, mais parce qu'il y a beaucoup de longs dÃ©veloppements (dont au moins deux sur lesquels nous travaillons sous la forme actuelle depuis 2012 sous la forme de phrases P et de branches TS ) ont atteint le stade de prÃ©paration et ils ont dÃ©cidÃ© de les inclure dans le projet de SI de la mÃªme version. <br><br>  Presque toujours, les principales fonctionnalitÃ©s sont dÃ©veloppÃ©es depuis de nombreuses annÃ©es.  La principale diffÃ©rence entre l'approche (1) pour C ++ 98 et C ++ 11 et l'approche (2) est qu'en C ++ 98 et C ++ 11, la publication a Ã©tÃ© retardÃ©e jusqu'Ã  ce que toutes ces fonctionnalitÃ©s soient prÃªtes, et maintenant nous expÃ©dions dÃ¨s que nous serons prÃªts, et avec eux, nous publierons beaucoup plus. <br><br>  C ++ 20 a suivi le mÃªme cycle de trois ans que C ++ 14 et C ++ 17.  Nous n'avons pas fait plus au cours des trois derniÃ¨res annÃ©es qu'au cours des deux cycles prÃ©cÃ©dents, nous avons simplement ajoutÃ© plus aux principales caractÃ©ristiques.  Si l'un d'eux n'Ã©tait pas prÃªt, nous l'aurions jetÃ© et terminÃ© dÃ©jÃ  pour C ++ 23.  Si cela se produit, nous le signalerons dans la proposition de mise en Å“uvre et expliquerons les raisons. <br><br>  C ++ 14 + 17 + 20 a constituÃ© notre troisiÃ¨me cycle de neuf ans (2011-2020) aprÃ¨s C ++ 98 (1989-1998) et C ++ 11 (2002-2011).  Mais puisque nous avons adhÃ©rÃ© Ã  l'approche (2), nous avons <b>Ã©galement</b> publiÃ© des dÃ©veloppements qui Ã©taient prÃªts pour la fin des cycles de trois et six ans. <br><br><h2>  N'est-il pas prÃ©fÃ©rable d'attraper des bogues lorsqu'un produit est en cours de dÃ©veloppement, et non aprÃ¨s sa sortie? </h2><br>  Bien sÃ»r, c'est mieux. <br><br>  Mais si nous parlons des raisons du retard dans la publication de la norme C ++, alors cette question implique deux fausses hypothÃ¨ses: <br><br><ul><li>  qu'avant la publication de la norme, les fonctionnalitÃ©s n'Ã©taient pas sorties et n'Ã©taient pas utilisÃ©es (pour beaucoup, il y a dÃ©jÃ  de l'expÃ©rience en production); <br></li><li>  et que toutes les fonctionnalitÃ©s peuvent Ãªtre utilisÃ©es ensemble jusqu'Ã  ce que la norme soit publiÃ©e (non autorisÃ©). <br></li></ul><br>  J'explique: <br><br><ol><li>  La plupart des principales fonctionnalitÃ©s de C ++ 20 ont Ã©tÃ© implÃ©mentÃ©es sous la forme dans laquelle elles sont reflÃ©tÃ©es dans le projet actuel de la norme dans au moins un compilateur, et dans la plupart des cas ont dÃ©jÃ  Ã©tÃ© utilisÃ©es dans le code de production (c'est-Ã -dire qu'elles sont dÃ©jÃ  disponibles pour les utilisateurs qui sont trÃ¨s satisfaits) .  Par exemple, les coroutines (introduites seulement cinq mois avant cet article) ont Ã©tÃ© utilisÃ©es pendant deux ans en production chez MSVC et un an chez Clang, qui Ã©tait trÃ¨s satisfait des gros clients (par exemple, Azure et Facebook). </li><li>  Nous n'attraperons pas beaucoup de problÃ¨mes d'interaction entre les fonctionnalitÃ©s jusqu'Ã  ce que les utilisateurs commencent Ã  les utiliser en production, c'est-Ã -dire avant la publication de la norme, car de nombreux dÃ©veloppeurs attendront qu'elle soit publiÃ©e afin de mettre en Å“uvre diffÃ©rents projets.  Et si nous montrons de l'incertitude quant au moment de la publication, ces implÃ©mentations seront Ã©galement retardÃ©es.  Eh bien, ils implÃ©mentent toujours quelque chose, mais beaucoup seront suspendus jusqu'Ã  ce que les dÃ©veloppeurs soient sÃ»rs que nous sommes prÃªts Ã  publier.  Demandez aux crÃ©ateurs de &lt;nom du compilateur prÃ©fÃ©rÃ©&gt; ce qui s'est passÃ© lorsqu'ils ont implÃ©mentÃ© &lt;nom de la grande fonctionnalitÃ©&gt; avant qu'il n'apparaisse dans la norme publiÃ©e.  Dans de nombreux cas, il est nÃ©cessaire de mettre en Å“uvre Ã  plusieurs reprises et de rompre les consommateurs Ã  plusieurs reprises.  Par consÃ©quent, les dÃ©veloppeurs prÃ©fÃ¨rent attendre que le comitÃ© approuve certaines fonctionnalitÃ©s. </li></ol><br>  Enfin, n'oubliez pas le problÃ¨me des fonctionnalitÃ©s d'interaction.  Nous ne les publions pas seulement lorsque nous sommes prÃªts, aprÃ¨s cela, nous avons encore besoin de temps pour rechercher les problÃ¨mes d'interaction entre les fonctionnalitÃ©s et ajouter le support de telles interactions, ce que nous ne pouvons tout simplement pas dÃ©couvrir avant que les nouvelles fonctionnalitÃ©s ne soient largement utilisÃ©es.  Et peu importe Ã  quel point nous retardons la publication de la norme, il y aura toujours des interactions que nous ne pourrons explorer que beaucoup plus tard.  Vous devez gÃ©rer ce risque Ã  l'aide d'une conception flexible, garantissant la compatibilitÃ© des fonctionnalitÃ©s, et ne pas attendre pour vous dÃ©barrasser de tous les risques. <br><br><h2>  La norme ne sera jamais parfaite ... ne libÃ©rez-vous pas de bugs? </h2><br>  Oui <br><br>  Si nous constatons que la fonctionnalitÃ© n'est pas prÃªte, nous devons la supprimer de la version. <br><br>  Si nous voyons qu'une fonctionnalitÃ© peut Ãªtre meilleure et que nous savons que le changement peut s'avÃ©rer Ãªtre rÃ©trocompatible, alors ce n'est pas une raison pour refuser sa sortie maintenant.  Il peut Ãªtre publiÃ© en tant qu'extension dans le C ++ suivant. <br><br>  Nous publions intentionnellement des fonctionnalitÃ©s que nous prÃ©voyons d'amÃ©liorer Ã  l'avenir, tout en Ã©tant convaincus que nous pouvons maintenir la compatibilitÃ© descendante. <br><br><h2>  Mais ne devriez-vous pas essayer de minimiser les erreurs de publication? </h2><br>  Oui  Nous essayons. <br><br>  Mais nous n'essayons pas d'Ã©viter tous les risques.  Il y a aussi un risque et un prix (possible) de refuser de divulguer ce qui nous semble prÃªt.  Et le plus souvent, nous avons raison. <br><br><h2>  Etes-vous sÃ»r que maintenant la qualitÃ© est meilleure que d'utiliser l'approche (1)? </h2><br>  Oui <br><br>  Selon des mesures objectives, le volume de commentaires de diffÃ©rents pays et les rapports de bogues, C ++ 14 et C ++ 17 Ã©taient nos versions les plus stables, et selon ces mesures, ils Ã©taient 3-4 fois plus Ã©levÃ©s que C ++ 98 et C ++ 11.  Et la raison rÃ©side prÃ©cisÃ©ment dans la rÃ©gularitÃ© des versions, en plaÃ§ant les grandes fonctionnalitÃ©s en premier dans les branches TS (y compris les descriptions complÃ¨tes de leur intÃ©gration avec la norme principale) et dans leur infusion ultÃ©rieure, lorsque nous sommes convaincus de la disponibilitÃ©. <br><br>  Depuis 2012, la norme principale <b>a toujours Ã©tÃ©</b> maintenue dans un Ã©tat presque prÃªt Ã  Ãªtre expÃ©diÃ© (donc mÃªme des Ã©bauches de travail de la mÃªme qualitÃ© que les versions des normes C ++ 98 et C ++ 11).  Cela ne s'est jamais produit auparavant, lorsque nous avons gardÃ© le patient non sÃ©curisÃ© pendant une longue pÃ©riode, avec de longues listes de problÃ¨mes et d'organes rÃ©partis, que nous allons remettre bientÃ´t.  Maintenant, nous savons que nous pouvons maintenir un calendrier avec un travail de haute qualitÃ©, car nous restons toujours dans un Ã©tat de prÃ©paration rapprochÃ©e pour la libÃ©ration.  Si vous le souhaitez, vous pouvez sortir un CD mÃªme maintenant, sans vous rÃ©unir Ã  Cologne, et la qualitÃ© serait toujours beaucoup plus Ã©levÃ©e que jamais avec un CD C ++ 98 ou C ++ 11 (en vÃ©ritÃ©, et leurs normes publiÃ©es) .  Et Ã©tant donnÃ© que C ++ 98 et C ++ 11 ont rÃ©ussi, la comprÃ©hension que maintenant la qualitÃ© est encore plus Ã©levÃ©e signifie que nous sommes sur la bonne voie. <br><br><h2>  C ++ 98 et C ++ 11 ont Ã©tÃ© dÃ©veloppÃ©s pendant environ 9 ans et Ã©taient de trÃ¨s bons produits ... </h2><br>  Oui: 1989-1998 et 2002-2011. <br><br><h2>  ... et C ++ 14 et C ++ 17 Ã©taient des versions mineures.  C ++ 20 est-il une version majeure? </h2><br>  Je rÃ©pÃ¨te, je pense qu'il est correct de comparer C ++ 14 + 17 + 20 dans son ensemble: c'est notre cycle de neuf ans, mais puisque nous avons adhÃ©rÃ© Ã  l'approche (2), nous avons Ã©galement publiÃ© les dÃ©veloppements qui Ã©taient prÃªts Ã  terminer les cycles de trois et six ans . <br><br><h2>  L'approche (2) vous permet d'atteindre des objectifs basÃ©s sur les fonctionnalitÃ©s comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">P0592</a> pour le prochain C ++? </h2><br>  Bien sÃ»r!  Bien qu'il n'y ait pas de mots comme Â«devrait inclure ces fonctionnalitÃ©sÂ», parce que ce sera l'approche (1). <br><br>  Tendre vers un certain ensemble de fonctionnalitÃ©s et donner la prioritÃ© Ã  l'une d'entre elles est normal, mais c'est une question de prioritÃ©.  Jusqu'Ã  prÃ©sent, nous ne prendrons que ce qui est prÃªt, mais nous pouvons d'abord choisir sur quoi travailler afin de nous prÃ©parer le plus rapidement possible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460665/">https://habr.com/ru/post/fr460665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460647/index.html">RÃ©soudre un travail avec pwnable.kr 05 - mot de passe. RÃ©Ã©crire la table des liens de procÃ©dure via la vulnÃ©rabilitÃ© de chaÃ®ne de format</a></li>
<li><a href="../fr460651/index.html">RÃ©union de la Society of Anonymous Testers: TMS, monitoring monitoring, search quality evaluation and native iOS tests</a></li>
<li><a href="../fr460655/index.html">Comment j'ai brisÃ© Telegram</a></li>
<li><a href="../fr460659/index.html">Utilisation de tuyaux pour pivoter</a></li>
<li><a href="../fr460661/index.html">Tout ce que vous devez savoir sur Node.js</a></li>
<li><a href="../fr460667/index.html">Automatisation des tests de services payants sur iOS</a></li>
<li><a href="../fr460669/index.html">Comment assurer la sÃ©curitÃ© du dÃ©veloppement, gagner du temps et des nerfs</a></li>
<li><a href="../fr460671/index.html">PropriÃ©tÃ© et emprunt en D</a></li>
<li><a href="../fr460673/index.html">Exposez la magie de DiffUtil</a></li>
<li><a href="../fr460675/index.html">Extraction de donnÃ©es d'apprentissage automatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>