<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 ✋🏽 👨🏿‍🏫 Croissance continue JSON 🖋️ 👲🏼 🐉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article écrit en septembre 2017 



 JSON a conquis le monde. Si aujourd'hui deux applications communiquent entre elles via Internet, il est fort prob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Croissance continue JSON</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421657/"> <font color="gray">Article écrit en septembre 2017</font> <br><br><img src="https://habrastorage.org/webt/ii/hb/aw/iihbawucazwacx5s_urrndg_ws4.png"><br><br>  JSON a conquis le monde.  Si aujourd'hui deux applications communiquent entre elles via Internet, il est fort probable qu'elles le fassent en utilisant JSON.  La norme est acceptée par tous les principaux acteurs: sur les dix API Web les plus populaires, qui sont développées principalement par de grandes entreprises telles que Google, Facebook et Twitter, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une seule API</a> transfère des données en XML, pas JSON.  Par exemple, Twitter a pris en charge XML jusqu'en 2013, date à laquelle il a publié une nouvelle version de l'API exclusivement en JSON.  Parmi les autres développeurs, JSON est également populaire: selon Stack Overflow, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus de questions sont posées sur JSON que sur tout autre format d'échange de données</a> . <br><a name="habracut"></a><br>  XML est toujours vivant et utilisé beaucoup.  Par exemple, dans les formats Web SVG, RSS et Atom.  Si l'auteur de l'application Android souhaite déclarer qu'il a besoin de l'autorisation de l'utilisateur, il le fait dans le manifeste de l'application écrit en XML.  Et XML n'est pas la seule alternative JSON: certains développeurs optent pour le YAML ou les tampons de protocole de Google.  Mais ces formats sont loin d'être aussi populaires que JSON, qui est maintenant devenu presque la norme de facto pour l'échange de données entre programmes sur Internet. <br><br>  La domination de JSON est étonnante, car en 2005, tout le monde discutait du potentiel de «JavaScript et XML asynchrone» plutôt que de «JavaScript et JSON asynchrone».  Bien sûr, il est possible que cela ne dise rien sur la popularité relative des deux formats, juste AJAX semblait être une abréviation plus attrayante que AJAJ.  Mais bien qu'en 2005, certaines personnes utilisaient déjà JSON au lieu de XML (en fait peu de gens), on se demande encore comment XML pourrait tomber si brutalement qu'une décennie plus tard, l'expression «JavaScript et XML asynchrone» provoque un sourire ironique.  Que s'est-il passé pendant cette décennie?  Comment JSON a-t-il remplacé XML dans de nombreuses applications?  Et qui a inventé ce format de données, dont dépendent désormais les ingénieurs et les systèmes du monde entier? <br><br><h1>  La naissance de JSON </h1><br>  Le premier message JSON a été envoyé en avril 2001 depuis un ordinateur dans un garage près de San Francisco.  L'histoire a conservé les noms des personnes impliquées dans l'événement: Douglas Crockford et Chip Morningstar, co-fondateurs de la société de conseil en technologie State Software. <br><br>  Ces deux-là développaient des applications AJAX bien avant l'apparition du terme AJAX.  Mais le support des applications dans les navigateurs n'était pas très bon.  Ils voulaient transférer des données vers leur application après le chargement initial de la page, mais n'ont pas trouvé de moyen qui fonctionnerait dans tous les navigateurs. <br><br>  C'est difficile à croire aujourd'hui, mais Internet Explorer était le navigateur le plus avancé en 2001.  Depuis 1999, Internet Explorer 5 prend en charge la première forme de XMLHttpRequest via ActiveX.  Crockford et Morningstar pouvaient utiliser cette technologie pour récupérer des données dans l'application, mais cela ne fonctionnait pas dans Netscape 4. J'ai donc dû chercher un format différent qui fonctionnait dans les deux navigateurs. <br><br>  Le premier message JSON ressemblait à ceci: <br><br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> document.domain = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'fudco'</span></span></span><span class="actionscript">; parent.session.receive( { to: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"session"</span></span></span><span class="actionscript">, </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">do</span></span></span><span class="actionscript">: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"test"</span></span></span><span class="actionscript">, text: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"Hello world"</span></span></span><span class="actionscript"> } ) </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Seule une petite partie du message ressemble au JSON tel que nous le connaissons aujourd'hui.  Le message lui-même est en fait un document HTML avec quelques lignes de JavaScript.  La partie de type JSON n'est qu'un littéral JavaScript pour la fonction <code>receive()</code> . <br><br>  Crockford et Morningstar ont décidé d'abuser du cadre HTML pour envoyer des données.  Pour un cadre, vous pouvez spécifier une URL qui renvoie un document HTML similaire à celui ci-dessus.  Lorsque le code HTML est reçu, JavaScript est lancé et retransmet le littéral à l'application.  Cela fonctionnait à condition que la protection du navigateur soit soigneusement contournée pour empêcher l'enfant d'accéder à la fenêtre parent: comme vous pouvez le voir, Crockford et Morningstar définissent explicitement le domaine du document.  Cette technique est parfois appelée un cadre caché; elle était <abbr title="Zakas, Nicholas C. et al. &quot;Qu'est-ce que l'Ajax?&quot; Ajax professionnel, 2e éd., Wiley, 2007">souvent utilisée à la fin des années 90 avant le XMLHttpRequest normal</abbr> . <br><br>  Ce qui est surprenant dans le premier article JSON, c'est qu'il n'est pas du tout évident qu'il s'agit de la première utilisation d'un nouveau type de format de données.  C'est juste du JavaScript!  En fait, l'idée d'utiliser JavaScript de cette manière est si simple que Crockford lui-même pense qu'il n'était pas le premier à le faire - il prétend que quelqu'un dans Netscape a utilisé des littéraux de tableau JavaScript pour transmettre des informations <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en 1996</a> .  La publication en JavaScript simple ne nécessite aucune analyse particulière.  Tout est fait par l'interpréteur JavaScript. <br><br>  En fait, le premier message JSON de l'histoire a rencontré des problèmes avec l'interpréteur.  JavaScript réserve un grand nombre de mots - 64 mots sont réservés dans ECMAScript 6 - et Crockford et Morningstar les ont involontairement utilisés dans leur message: à savoir, le mot réservé <code>do</code> la clé.  Étant donné que JavaScript a tant de mots réservés, Crockford a décidé de ne pas les éviter, mais simplement de citer toutes les clés JSON.  La clé entre guillemets est considérée par l'interpréteur JavaScript comme une chaîne, vous pouvez donc utiliser en toute sécurité les mots réservés.  C'est pourquoi les clés JSON sont toujours entre guillemets. <br><br>  Crockford et Morningstar ont réalisé que la nouvelle méthode peut être utilisée dans toutes sortes d'applications.  Ils voulaient appeler le format JSML (JavaScript Markup Language), mais il s'est avéré que l'abréviation était déjà occupée par quelque chose appelé Java Speech Markup Language.  Par conséquent, nous avons choisi la notation d'objet Javascript, c'est-à-dire JSON.  Ils ont commencé à offrir le format à leurs clients, mais il est vite devenu évident qu'ils ne risquaient pas d'utiliser une technologie inconnue sans spécification officielle.  Crockford a donc décidé de l'écrire. <br><br>  En 2002, Crockford a acheté le domaine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON.org</a> , publié la syntaxe JSON et un exemple d'implémentation de l'analyseur.  Le site Web fonctionne toujours, bien qu'il affiche désormais un lien vers la norme JSON ECMA adoptée en 2013.  En plus de lancer le site, Crockford n'a pratiquement rien fait pour promouvoir JSON, mais bientôt il y a eu des implémentations de l'analyseur JSON dans une variété de langages de programmation.  Initialement, JSON était clairement associé à JavaScript, mais il est devenu clair qu'il convenait bien à l'échange de données entre des paires de langues arbitraires. <br><br><h1>  Mauvais AJAX </h1><br>  JSON a obtenu un gros coup de pouce en 2005.  Puis un concepteur et développeur nommé Jesse James Garrett a inventé le terme AJAX dans son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> .  Il a essayé de souligner que AJAX n'est pas seulement une nouvelle technologie, mais plutôt «plusieurs à sa manière de bonnes technologies combinées de nouvelles façons puissantes».  Garrett a appelé AJAX une nouvelle approche pour le développement d'applications Web.  Dans un article de blog, il a décrit comment les développeurs peuvent utiliser JavaScript et XMLHttpRequest pour créer des applications plus interactives.  Il a appelé Gmail et Flickr des exemples de sites qui s'appuient sur les méthodes AJAX. <br><br>  Bien sûr, "X" dans AJAX signifiait XML.  Mais dans les questions et réponses ultérieures, Garrett a qualifié le JSON d'alternative parfaitement acceptable.  Il a écrit que "XML est l'outil d'échange de données le plus fonctionnel pour le client AJAX, mais le même effet peut être obtenu en utilisant Javascript Object Notation ou tout autre format de structuration de données similaire." <br><br>  Les développeurs ont vraiment découvert qu'ils pouvaient facilement utiliser JSON pour créer des applications AJAX, et beaucoup l'ont choisi au lieu de XML.  Ironiquement, l'intérêt pour AJAX a conduit à une explosion de la popularité de JSON.  À cette époque, JSON a attiré l'attention de la blogosphère. <br><br>  En 2006, Dave Weiner, un blogueur prolifique et créateur d'un certain nombre de technologies XML, telles que RSS et XML-RPC, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s'est plaint</a> que JSON réinventait XML sans raison valable: <br><br><blockquote>  «Bien sûr, je peux écrire une procédure pour analyser [JSON], mais regardez jusqu'où ils sont allés pour réinventer la technologie: pour une raison quelconque, XML n'est pas assez bon pour eux (je me demande pourquoi).  Qui a créé cette parodie?  Trouvons un arbre et pendons un gars.  Maintenant. " </blockquote><br>  Il est facile de comprendre la déception de Weiner.  XML n'a jamais été particulièrement apprécié.  Même Weiner lui-même a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dit qu'il n'aimait pas XML</a> .  Mais XML a été conçu comme un système universel pour toutes les applications imaginables.  XML est en fait un métalangage qui vous permet de définir des langues de domaine pour des applications individuelles - par exemple, RSS et SOAP.  Weiner estime qu'il est important de dégager un consensus pour tous les avantages que le format d'échange commun apporte.  À son avis, la flexibilité de XML est capable de satisfaire tous les besoins.  Pourtant, JSON est un format qui n'offre aucun avantage sur XML, à l'exception de la suppression des fichiers indésirables, qui a rendu XML si flexible. <br><br>  Crockford a vu le blog de Weiner et a commenté.  En réponse à l'accusation selon laquelle JSON réinvente XML, Crockford a écrit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> Réinventer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">roue est bon parce que vous pouvez la faire tourner</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> <br><br><h1>  JSON vs XML </h1><br>  En 2014, JSON a été officiellement reconnu comme une norme ECMA et RFC.  Il a obtenu son type MIME.  JSON est entré dans les grandes ligues. <br><br>  Pourquoi JSON est-il devenu beaucoup plus populaire que XML? <br><br>  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON.org,</a> Crockford répertorie certains des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avantages de JSON sur XML</a> .  Il écrit que JSON est plus facile à comprendre par les personnes et les machines, car sa syntaxe est minimale et sa structure est prévisible.  D'autres blogueurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mentionnent la</a> verbosité XML et la «taxe sur les balises».  Chaque balise d'ouverture en XML doit avoir une balise de fermeture, ce qui signifie beaucoup d'informations redondantes.  Cela rend XML beaucoup plus volumineux que le document JSON équivalent, mais plus important encore, pour cette raison, le document XML est plus difficile à lire. <br><br>  Crockford a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appelé</a> un autre grand avantage de JSON: qu'il a été initialement conçu comme un format pour l'échange d'informations structurées entre les programmes.  Bien que XML ait été utilisé dans le même but, il a été initialement développé comme langage de balisage de document.  Il est né du SGML (Standard Generalized Markup Language), qui, à son tour, a évolué à partir du langage de balisage Scribe, destiné au texte de balisage, comme LaTeX.  En XML, à l'intérieur d'une balise, il peut y avoir ce que l'on appelle du «contenu mixte», c'est-à-dire du texte avec des balises intégrées entourant des mots ou des phrases.  Il ressemble à un éditeur marquant un manuscrit avec un marqueur rouge ou bleu, une sorte de métaphore du langage de balisage.  JSON, en revanche, ne prend pas en charge un analogue exact de contenu mixte, ce qui signifie simplifier la structure.  Le document est mieux représenté sous la forme d'une arborescence, mais abandonnant l'idée du document, Crockford a pu limiter JSON aux dictionnaires et aux tableaux d'éléments familiers que tous les programmeurs utilisent pour créer leurs programmes. <br><br>  Enfin, ma propre supposition est que les gens n'aimaient pas la complexité de XML, et c'était vraiment à cause de sa diversité.  À première vue, il est difficile de faire la distinction entre le XML lui-même et ses sous-langues, telles que RSS, ATOM, SOAP ou SVG.  Les premières lignes d'un document XML type établissent la version de XML, puis le sous-langage spécifique auquel le document XML doit correspondre.  Il s'agit de nombreuses options par rapport à JSON, qui est si simple qu'aucune nouvelle version de la spécification JSON ne sera jamais écrite.  Les développeurs XML, dans une tentative de créer un format d'échange de données unique pour tout, ont été victimes du piège du programmeur classique: une complication technique excessive.  XML est si général qu'il est difficile de l'utiliser pour quelque chose de simple. <br><br>  En 2000, une campagne a commencé à aligner le HTML sur la norme XML.  Publication d'une spécification pour HTML conforme à XML, connue plus tard sous le nom de XHTML.  Certains fabricants de navigateurs ont immédiatement commencé à prendre en charge la nouvelle norme, mais il est rapidement devenu évident que le grand public travaillant avec HTML ne voulait pas changer ses habitudes.  La nouvelle norme exigeait une validation XHTML plus stricte que ce qui était habituel pour HTML, mais trop de sites dépendaient de règles HTML gratuites.  En 2009, les militants avaient cessé d'essayer d'écrire une deuxième version de XHTML quand il est devenu clair que l'avenir reposait sur la norme HTML5, qui ne nécessitait pas la conformité XML. <br><br>  Si les efforts de XHTML réussissaient, alors peut-être que XML deviendrait un format de données commun, comme l'espéraient ses développeurs.  Imaginez un monde dans lequel les documents HTML et les réponses API ont exactement la même structure.  Dans un tel monde, JSON n'est peut-être pas devenu aussi populaire qu'aujourd'hui.  Mais je considère l'échec de XHTML comme une sorte de défaite morale pour le camp XML.  Si XML n'a pas aidé HTML, il pourrait y avoir de meilleurs outils pour d'autres applications.  Dans le monde réel, il est facile de comprendre pourquoi le format JSON simple et hautement spécialisé a connu un tel succès. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421657/">https://habr.com/ru/post/fr421657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421643/index.html">Artisanat - à la bibliothèque</a></li>
<li><a href="../fr421647/index.html">Un moyen pratique de tester les composants React</a></li>
<li><a href="../fr421649/index.html">«Top 3D Expo. Digital Education 2018 »21 septembre au Technopolis Moscou</a></li>
<li><a href="../fr421653/index.html">Aperçu et dispositif des compteurs électriques modernes</a></li>
<li><a href="../fr421655/index.html">Ingénieurs Jetpack: Alexander Fedorovich Andreev</a></li>
<li><a href="../fr421659/index.html">Comment Microsoft a oublié la moitié du monde ou lu des messages d'erreur</a></li>
<li><a href="../fr421663/index.html">Conteneurs pour adultes (partie 03): 10 choses que vous n'avez pas besoin de faire avec des conteneurs</a></li>
<li><a href="../fr421665/index.html">Android Jetpack: transformer des applications en fusées</a></li>
<li><a href="../fr421667/index.html">CJM Meetup in MegaFon - comment c'était et de quoi nous avons parlé (reportages vidéo)</a></li>
<li><a href="../fr421669/index.html">Le tribunal a interdit la distribution gratuite de fichiers CAO de qualité militaire, de sorte que le créateur a commencé à les vendre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>