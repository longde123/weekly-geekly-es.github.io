<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ¨ ğŸ”… ğŸ‡ğŸ» Pemrograman Berorientasi Objek dalam Bahasa Grafis ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ¾ ğŸŒ… ğŸš®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Object-oriented programming (OOP) adalah konsep yang dirancang untuk memfasilitasi pengembangan sistem yang kompleks dengan memperkenalkan konsep-kons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Berorientasi Objek dalam Bahasa Grafis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451148/"><p> Object-oriented programming (OOP) adalah konsep yang dirancang untuk memfasilitasi pengembangan sistem yang kompleks dengan memperkenalkan konsep-konsep baru yang lebih dekat ke dunia nyata daripada bahasa pemrograman fungsional dan prosedural.  Seperti Wikipedia menulis, "Bahasa manusia biasa secara keseluruhan mencerminkan ideologi OOP, dimulai dengan merangkum ide suatu objek dalam bentuk namanya dan berakhir dengan polimorfisme menggunakan kata dalam arti kiasan, yang akhirnya mengembangkan ekspresi representasi melalui nama objek ke konsep lengkap - kelas." </p><br><img src="https://habrastorage.org/webt/yj/wm/tf/yjwmtfu4vnkaz5hwovolbkseny8.png"><br><br><p>  Tetapi dari sudut pandang setiap orang yang pertama kali menemukan abstraksi ini, setelah bahasa prosedural klasik tidak menjadi lebih jelas, tampaknya sebaliknya itu masih lebih membingungkan. </p><a name="habracut"></a><br><p>  Di sisi lain, ada notasi grafis dari program, yang tidak dekat dengan bahasa manusia, tetapi jauh lebih dimengerti daripada kode apa pun, tidak seperti OOP.  Mungkin saja ini lebih jelas bagi saya, dimanjakan oleh pendidikan teknik, tetapi ada banyak orang seperti saya dan teks ini untuk fisikawan manja yang sama yang tidak mengerti abstraksi tinggi. </p><br><p>  Di sini, misalnya, adalah deskripsi nyata dalam notasi grafis dari algoritma kontrol katup gerbang NPP: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ii/qf/jk/iiqfjkygs4f0kcfu8znjh88yvg8.png"></div><br>  <i><font color="#999999">Gambar 1. Contoh program kontrol NPP dalam notasi grafis</font></i> <br><p>  Di sebelah kiri adalah sinyal input, di sebelah kanan adalah perintah. <br><br>  Menurut saya, bahkan seorang anak pun dapat membaca algoritma seperti ini: <br><br></p><ul><li>  Jika pompa dihidupkan selama 60 detik dan laju aliran kurang dari 10, maka buka katup resirkulasi. </li><li>  Jika pompa dihidupkan, maka berikan perintah untuk membuka dalam waktu 5 detik ke katup 001 dan 002. </li><li>  Jika laju aliran lebih besar dari 20 dan pompa dihidupkan, maka dalam 5 detik untuk mengirim katup rana 003 untuk menutup. </li></ul><br><p>  Ketika saya masih mahasiswa, saya bekerja paruh waktu dengan membuat perpustakaan komponen untuk Delphi dan terbiasa dengan OOP secara langsung.  Kemudian, ketika saya menemukan program kontrol pembangkit listrik tenaga nuklir yang sebenarnya, saya sangat terkejut bahwa tidak ada abstraksi, enkapsulasi dan, maafkan saya, polimorfisme, hanya rekomendasi C murni, dan MISRA C yang telah ditebang oleh peraturan sehingga semuanya <b>dapat diandalkan</b> , portabel, aman. </p><br><p>  Puncak cutoff C dalam praktik saya adalah FIL, untuk sistem kontrol reaktor RBMK.  Di dalamnya, fungsi ditulis dalam bahasa C, dikompilasi, dan kemudian dipanggil berdasarkan file teks, di mana mereka dijelaskan dalam bahasa FIL.  Akibatnya, dimungkinkan untuk memanggil hanya sejumlah fungsi yang terbatas, tetapi diuji dengan cermat dan di-debug.  Dan semua ini atas nama keselamatan dan keandalan. </p><br><p>  Tetapi pada saat yang sama, sistem kontrol reaktor dan sistem kontrol NPP secara keseluruhan hanyalah kasus di mana prinsip-prinsip OOP harus diterapkan pada potensi penuh mereka.  Bahkan, ada banyak peralatan serupa - katup, pompa, sensor, semuanya mudah diklasifikasikan, ada benda jadi yang sesuai dengan peralatan nyata.  Tampaknya di sini - gunakan OOP, kelas, warisan, abstraksi, dan polimorfisme.  Tapi tidak, Anda perlu C murni dan ini adalah persyaratan keamanan. </p><br><p>  Dan kemudian - bahkan lebih menarik.  Bahkan, program untuk mengelola pembangkit listrik tenaga nuklir tidak ditulis oleh programmer, tetapi oleh teknolog - hanya dia yang tahu apa dan kapan harus menutup, membuka, menghidupkan, dan yang paling penting - dia tahu kapan harus mematikan sampan, agar tidak jatuh.  Dan programmer harus hati-hati mengimplementasikan semua ini dalam kode C.  Dan lebih baik lagi, bahwa tidak akan ada programmer sama sekali, dan teknologinya sendiri menggambar algoritma teknologi dari program kontrol dalam bentuk grafis, secara otomatis menghasilkan kode C dan memasukkannya ke dalam peralatan kontrol.  Standar keselamatan internasional merekomendasikan hal ini, dalam hal ini, seorang programmer - seperti pemain biola - tidak diperlukan.  Dia hanya memperkenalkan kesalahan dan distorsi tambahan dalam implementasi pemikiran teknolog. </p><br><img src="https://habrastorage.org/webt/jw/v0/kd/jwv0kdcn8__n1s4mzpdfvqdolm4.jpeg"><br><br><p>  Apa yang mengejutkan saya ketika saya menemukan bahwa teknologi NPP dan desainer, terlepas dari programmer, telah mengembangkan dan berhasil menggunakan pemrograman berorientasi objek, dan bahkan dalam notasi grafis, tetapi kode yang dihasilkan sepenuhnya memenuhi persyaratan keamanan dan tidak mengandung artefak dari metodologi OOP . </p><br><p>  Bahkan, jika Anda melihat kode yang dihasilkan dari rangkaian pada Gambar 1, kita akan melihat C murni tanpa kelas di sana. <br>  Misalnya, tabel entri algoritme: </p><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=0 UID=0 GeneratorClassName=TSignalReader Name=KBA__AA.KBA31EY001.alg_inp Type=  */</span></span> state_vars-&gt;kbaalgsv0_out_1_ = kba31ap001_xb01; state_vars-&gt;kbaalgsv0_out_4_ = kba31cf001_xq01;</code> </pre> <br><p>  Hanya menetapkan variabel. <br>  Setiap blok digambarkan sebagai menghitung output dengan input, dengan mempertimbangkan parameter yang ditentukan dalam daftar konstanta.  Misalnya, blok "Lainnya" terlihat seperti ini dalam kode: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=5 UID=5 GeneratorClassName=TLogBlock Name=KBA__AA.KBA31EY001.smu.GT2 Type=  */</span></span> locals-&gt;v5_out_0_ = state_vars-&gt;kbaalgsv0_out_4_ &gt; consts-&gt;kbaalgsv3_a_;</code> </pre> <br><p>  Output blok adalah hasil membandingkan sinyal input dengan nilai dalam konstanta. </p><br><p>  Dengan demikian, di blok lain, variabel lokal dari variabel input dihitung secara berurutan, dan pada akhir siklus program, variabel ditulis ke variabel output. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=14 UID=14 GeneratorClassName=TSignalWriter Name=KBA__AA.KBA31EY001.alg_out Type=  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((action==f_InitState)||(action==f_GoodStep)||(action==f_RestoreOuts)){ kba31ey001_yb01 = locals-&gt;v8_out_0_; kba31ey001_yb11 = state_vars-&gt;kbaalgsv9_out_0_; kba31ey001_yb12 = state_vars-&gt;kbaalgsv12_out_0_; kba31ey001_yb02 = locals-&gt;v13_out_0_; };</code> </pre> <br><p>  Di mana kelas di sini, Anda bertanya? </p><br><p>  Seluruh metodologi yang terkait dengan OOP ada dalam nama variabel.  Tampaknya ini bisa dalam nama variabel?  Dan mungkin ada jurang yang dalam.  Sebagai contoh, nama variabel adalah kba31ap001_xb01, hanya variabel dalam kode C yang memenuhi persyaratan untuk nama variabel.  Namun, untuk seorang insinyur desain, tampilannya seperti ini: "Kompartemen reaktor, sistem pasokan air industri, pompa pertama, permulaan".  Semua keajaiban konversi ini terjadi berkat sistem pengkodean Jerman yang luar biasa (Kraftwerk-Kennzeichensystem) KKS, kutipan: </p><br><p>  â€œSistem klasifikasi pengkodean ini dirancang untuk pembangkit listrik dan memiliki potensi besar, dan juga memperhitungkan fitur perangkat keras mikroprosesor yang dapat diprogram secara bebas. </p><br><p>  Seiring dengan penandaan peralatan teknologi, badan eksekutif (shut-off, safety, shut-off, dll. Katup, mekanisme tambahan), titik pengukuran, unit pemasangan, perangkat otomasi, bangunan dan struktur, sistem KKS memungkinkan penandaan algoritma dan program dari berbagai jenis dan tujuan (pemrosesan algoritma untuk parameter teknologi yang diukur, pensinyalan, regulasi otomatis, perlindungan teknologi, kontrol logis: kunci, ABP, program langkah-demi-langkah, - kalkulasi  Indikator hniko-ekonomi dan diagnostik peralatan teknologi), input, output dan sinyal antara algoritma dan program, rekaman video dari semua tingkatan yang ditampilkan pada terminal video, kabel, dll ... " </p><br><p>  Tetapi yang paling menarik di bagian akhir nama adalah <b>_xb01</b> , yang ditentukan melalui garis bawah.  Jika Anda melihat basis sinyal untuk proyek manajemen, kita akan melihat kelas-kelas di sana yang dapat dimengerti dan akrab bagi semua orang yang dulu, di suatu tempat dan di suatu tempat tertarik pada OOP (lihat Gambar 2). </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/ct/ts/urcttsuadp4hqqlqbo073lqgxhi.png"></div><br>  <i><font color="#999999">Gambar 2. Contoh struktur basis sinyal untuk sistem kontrol pembangkit listrik tenaga nuklir.</font></i> <br><p>  Kami memiliki kelas, atau tabel, pada gambar ini adalah kolom "Kategori".  Misalnya, "KD1" yang memiliki tabel sinyal pola, bidang kelas <i>Batas pengukuran atas, batas pengukuran lebih rendah, pembacaan sensor</i> , dll.  Merupakan abstraksi. </p><br><p>  Dan ada juga implementasi kelas ini - sensor spesifik, misalnya, TK21F02B1, yang terletak di sirkuit, seperti yang mungkin Anda tebak dari namanya, di "Kompartemen reaktor, sistem pasokan air industri, pada pompa pertama", dan fakta bahwa ini adalah sensor aliran ada dalam judul ini, tetapi tidak akurat. </p><br><p>  Dan instance dari kelas ini memiliki sinyal dan nilai-nilainya spesifik, dalam proses program, dan mereka dapat diakses dengan nama-nama bidang kelas.  Misalnya, pembacaan sensor ditunjukkan oleh variabel TK21F02B1_XQ04. </p><br><p>  Pada titik ini, kita dapat mengatakan, tunggu, ini bukan OOP sama sekali, atau bahkan tidak OOP sama sekali, itu hanya struktur data, itu dalam standar C.  Dan di mana enkapsulasi metode di kelas?  Pemrosesan data harus di kelas, maka ini akan menjadi metode OOP halal nyata. <br>  Mari kita lihat bagaimana subroutine kontrol keandalan sensor terlihat dalam bentuk grafis.  Gambar 3 adalah bagian dari rangkaian pemrosesan sinyal: </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/zc/gg/chzcggvc87mpu5z0ya6ui32cx54.png"></div><br>  <i><font color="#999999">Gambar 3. Contoh program pemrosesan sinyal.</font></i> <br><p>  Dapat dilihat bahwa dalam pemrosesan subrutin nama variabel TK21F02B1_XQ04 digunakan, dibentuk sesuai dengan aturan KKS dan berdasarkan tabel bidang kelas.  Dalam contoh di atas, pembacaan sensor dihitung dalam persen TK21F02B1_XQ03 sesuai dengan nilai yang ditetapkan dari bidang kelas contoh seperti TK21F02B1_Xmin dan TK21F02B1_Xmax. </p><br><p>  Jika kita beralih ke kode yang dihasilkan dari skema ini, kita akan melihat tugas sederhana dari nilai ke variabel, C murni dan tidak ada plus dan OOP. </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Index=12 UID=12 GeneratorClassName=TSignalReader Name=KD1.kd3_45.SR6 Type=    */</span></span> state_vars-&gt;su100v12_out_0_ = tk21f02b1_ai;</code> </pre> <br><p>  Dan penugasan hasil perhitungan, juga sebagai penugasan sederhana dari suatu variabel (dengan memeriksa validitas nomor, agar tidak menjatuhkan sistem jika kami menerima kesalahan sebagai hasil dari pemrosesan sinyal) </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Index=100 UID=100 GeneratorClassName=TSignalWriter Name=KD1.kd3_45.SW3 Type=    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isfinite(locals-&gt;v63_out_0_)){ tk21f02b1_xq04 = locals-&gt;v63_out_0_; };</code> </pre> <br><p>  Dan pada saat apa persatuan bidang metode pengolahan kelas ini muncul?  Bahkan, saya kenal dengan dua opsi untuk fokus ini.  Sekarang kita akan menganalisis salah satunya.  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opsi kedua diuraikan di sini ..</a> ) <br>  Mari kita lihat bagaimana blok tempat rangkaian program pemrosesan dikonfigurasikan pada diagram (lihat Gbr. 4). </p><br><p>  Kami memiliki sirkuit di mana kami menempatkan blok submodel dari bahasa pemrograman grafis, di dalam blok ini adalah sirkuit grafis, bagian dari yang ditunjukkan pada Gambar 3, sebuah program untuk memproses sinyal dari sensor. </p><br><p>  Dalam properti blok ini, kita melihat bidang basis data sinyal dan daftar drop-down yang berisi sinyal yang sudah ada dalam basis data, contoh kelas, sensor spesifik jenis ini.  Cukup memilih sensor yang diinginkan, instance kelas dengan nama, dan keajaiban terjadi.  Dalam skema tersebut, semua blok baca dan tulis menerima nama dari tipe <b>TK21F02B1_XQ03</b> , (kelas contoh nama sensor + nama bidang). </p><br><p>  Sekarang, ketika membuat kode C, semua variabel akan menerima nilai dari sensor yang diinginkan.  Dan programmer tidak diperlukan, teknologis melakukan semuanya sendiri ketika ia mengembangkan skema dalam bahasa pemrograman grafis untuk algoritma kontrol NPP. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/ev/pv/wsevpvuvpzcp4vzvnny_zdjq6m4.png"></div><br>  <i><font color="#999999">Gambar 4. Contoh pengaturan sirkuit pemrosesan sensor.</font></i> <br><p>  Untuk menetapkan nama, skrip otomasi khusus digunakan dalam lingkungan desain sistem kontrol, kira-kira sama seperti pada Gambar 5. Semua blok bacaan dalam diagram diberi nama yang terdiri dari nama objek dan nama bidang dalam kelas (lihat Gambar 5). </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xo/ni/7s/xoni7sgyktrabfhnt-bnhslgbem.png"></div><br>  <i><font color="#999999">Gambar 5. Mengatur nama variabel dalam membaca blok.</font></i> <br><p>  Jelaslah bahwa dengan cara yang sama sejumlah opsi pemrosesan sinyal yang tidak terbatas dapat dibuat, pada dasarnya metode untuk kelas dalam metodologi OOP.  Dengan cara yang sama, mereka dapat dibentuk untuk sensor, yang disimpulkan ketika ditampilkan pada frame video sistem SCADA, atau misalnya, pemrosesan prosedur untuk mengubah pengaturan.  Diagram dibuat dalam bentuk grafis, disimpan sebagai blok dan digunakan jika perlu. </p><br><p>  Untuk meringkas: dalam bahasa pemrograman grafis, metode OOP juga digunakan dan bermanfaat.  Dan setelah menghasilkan kode sumber untuk program kontrol, semua artefak dari metodologi OOP menghilang dan tetap bersih C, aman, dapat diandalkan, diverifikasi. </p><br><p>  Jelas bahwa aplikasi alat otomasi tersebut, selain mempercepat pengembangan, juga dapat secara signifikan mengurangi waktu pengembangan, jumlah kesalahan dalam program kontrol. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451148/">https://habr.com/ru/post/id451148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451136/index.html">Diperkenalkan oleh .NET 5</a></li>
<li><a href="../id451138/index.html">Symfony CLI - Alat Pengembangan Lokal Baru</a></li>
<li><a href="../id451140/index.html">Berapa Biayanya Untuk Membuat Solusi IoT?</a></li>
<li><a href="../id451144/index.html">Antiquities: Teknik dalam Iklan TV</a></li>
<li><a href="../id451146/index.html">Mempercepat pembuatan aplikasi web dengan webpack</a></li>
<li><a href="../id451150/index.html">Tangkap aku jika kau bisa. Versi manajer</a></li>
<li><a href="../id451152/index.html">Resistor di sirkuit gerbang atau cara melakukannya dengan benar</a></li>
<li><a href="../id451154/index.html">Sistem Akusisi Data Otonomi Daerah (lanjutan)</a></li>
<li><a href="../id451158/index.html">Sirkuit listrik. Jenis sirkuit</a></li>
<li><a href="../id451160/index.html">Apache Kafka dan Streaming dengan Spark Streaming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>