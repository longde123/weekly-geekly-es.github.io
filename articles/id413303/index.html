<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôè ‚úùÔ∏è üí∫ Kisah Masalah: Memoizer JavaScript Terpendek ü¶ç üòì üç∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Itu di malam hari, pada malam konferensi tahunan HolyJS di St. Petersburg. Perusahaan kami telah menjadi sponsor selama beberapa tahun: karenanya, ia ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kisah Masalah: Memoizer JavaScript Terpendek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/semrush/blog/413303/"><p><img src="https://habrastorage.org/webt/bn/ca/u1/bncau1_hr7wuzgyelj-ebncmyl4.png" alt="gambar"></p><br><p>  Itu di malam hari, pada malam konferensi tahunan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS</a> di St. Petersburg.  Perusahaan kami telah menjadi sponsor selama beberapa tahun: karenanya, ia juga memiliki pendirian sendiri dengan minat yang menarik bagi pikiran ingin tahu pengembang yang peduli.  Ketika hidangan utama sudah siap dan semua tugas ditinjau dan diselesaikan oleh pengacara, saya memutuskan untuk memberikan makanan intelektual kepada teman-teman saya di malam hari: </p><br><blockquote>  Menulis memoizer - fungsi dekorator yang menyimpan hasil menjalankan fungsi yang dibungkus untuk mencegah perhitungan berulang.  Anda hanya memiliki 50 karakter. </blockquote><p>  Bahasanya, tentu saja, <strong>JavaScript</strong> .  Tugas itu sendiri adalah klasik, tetapi batas 50 karakter berubah menjadi tantangan nyata. </p><br><p>  Di sela-sela hari pertama konferensi, kami membahas opsi untuk mencapai tujuan, secara bertahap mengurangi respons.  Semua hype dimahkotai dengan gagasan berbagi tugas dengan semua peserta konferensi, dan pada hari kedua kami memvisualisasikan tugas (lihat lampiran) dan mulai membagikan formulir kepada mereka yang ingin.  Akibatnya, kami mendapat sekitar 40 solusi dan sekali lagi menjadi yakin dengan komunitas luar biasa pengembang js, tetapi catatan <strong>Dmitry Kataev</strong> (SEMrush) dari <strong>53</strong> karakter tetap ada.  Mari kita cari tahu! </p><a name="habracut"></a><br><h3 id="privychnaya-realizaciya">  Implementasi kebiasaan </h3><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cache = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ret</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.hasOwnProperty(key)) { cache[key] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[key]; } }</code> </pre> <br><p>  Hasil: ~ <strong>190</strong> karakter </p><br><ul><li>  memoize - memoizer kami </li><li>  f - didekorasi, fungsi dibungkus </li><li>  fungsi ret - result </li></ul><br><p>  Untuk mendapatkan jawaban - ukuran fungsi - kami menggunakan: </p><br><pre> <code class="javascript hljs">memoize.toString().replace(<span class="hljs-regexp"><span class="hljs-regexp">/\s+/g</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>).length</code> </pre> <br><p>  Saat mengevaluasi ukuran suatu fungsi, kami memperhatikan tubuhnya dan daftar parameter.  Jika fungsinya anonim, maka deklarasi tidak diperhitungkan. </p><br><p>  Tes sederhana untuk menguji kesehatan setelah pelecehan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = memoize(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inc = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> ox + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><table><thead><tr><th>  Tidak. </th><th>  Panggilan fungsi </th><th>  Hasil eksekusi di konsol </th></tr></thead><tbody><tr><td>  1. </td><td> <code>log(false)</code> </td> <td>  &gt; salah </td></tr><tr><td>  2. </td><td> <code>log('2', {x:1})</code> </td> <td>  &gt; '2', {x: 1} </td></tr><tr><td>  3. </td><td> <code>log(false)</code> </td> <td>  Tidak ada, karena fungsi telah dieksekusi untuk nilai-nilai ini. </td></tr><tr><td>  4. </td><td> <code>log('2', {x:1})</code> </td> <td>  Tidak ada, karena fungsi telah dieksekusi untuk nilai-nilai ini. </td></tr><tr><td>  5. </td><td> <code>inc({x:1})</code> </td> <td>  2 </td></tr><tr><td>  6. </td><td> <code>inc({x:2})</code> </td> <td>  3 </td></tr></tbody></table><br><p>  Selanjutnya, hasil dari setiap implementasi akan ditandai oleh hasil tes. </p><br><h3 id="chistaya-realizaciya">  Implementasi bersih </h3><br><p>  Pertama-tama, saya ingin menyingkirkan <em>Deklarasi Fungsi</em> untuk mendukung fungsi panah, karena kami tidak tertarik dengan konteks <em>ini</em> , kami tidak menarik <em>argumen,</em> dan sebagai konstruktor kami tidak bermaksud untuk memanggil melalui yang <em>baru</em> .  Pada saat yang sama, kami akan mengurangi nama-nama variabel lokal yang digunakan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Hasil: <strong>154</strong> , tes lulus </p><br><p>  Kemudian kita dapat melakukan operasi yang sama dengan fungsi yang dihasilkan, tetapi kita membutuhkan <em>argumen</em> .  Di sini <em>operator spread</em> datang untuk menyelamatkan, memungkinkan kami untuk mengganti objek iterable argumen yang dilewatkan dengan variabel array <em>a</em> .  Selain itu, kami tidak akan lagi meneruskan konteks <em>ini</em> ke fungsi yang sedang didekorasi: jika perlu, <em>Function.prototype.bind</em> atau polyfil kami akan membantu. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!c.hasOwnProperty(k)) { c[k] = f(...a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k]; } }</code> </pre> <br><p>  Hasil: <strong>127</strong> , tes lulus </p><br><p>  Sekarang kita beralih ke tubuh fungsi yang dihasilkan.  Jelas, menemukan kunci dalam cache dan mengembalikan nilainya merepotkan.  Mari kita coba kurangi caranya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c[k] || (c[k] = f(...a)); } }</code> </pre> <br><p>  Hasil: <strong>101</strong> , tes 3 dan 4 jatuh </p><br><p>  Di sini kita meninggalkan metode <em>hasOwnProperty</em> .  Kita dapat membelinya, karena hasil serialisasi array argumen melalui <em>JSON.stringify</em> akan selalu menjadi "[...]" dan tidak mungkin bahwa properti seperti itu akan <em>muncul</em> dalam cache prototipe ( <em>Obyek</em> ). </p><br><p>  Selanjutnya, kami menggunakan fitur operator "logis" ATAU untuk mengembalikan ekspresi pertama jika dapat dikonversi ke <em>true</em> , atau yang kedua, dengan perhitungan fungsi sebelumnya. </p><br><p>  Dan di sini kita jatuh tes 3 dan 4. Ini terjadi karena fungsi <em>console.log yang</em> dihiasi tidak mengembalikan nilai: hasilnya akan tidak <em>ditentukan</em> .  Kami memasukkan ini ke dalam cache, dan ketika kami mencoba memeriksa fitur disjunctor ketika kami menyebutnya lagi, secara implisit kami menampilkan <em>false</em> di operan pertama dan, karenanya, masuk ke yang kedua, yang mengarah ke pemanggilan fungsi.  Efek ini akan terjadi untuk semua hasil dikurangi menjadi <em>false</em> : <em>0, "", null, NaN</em> , dll. </p><br><p>  Alih-alih ATAU dan <em>jika pernyataan,</em> kita dapat menggunakan operator ternary bersyarat: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.hasOwnProperty(k) ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Hasil: <strong>118</strong> , tes lulus </p><br><p>  Mengurangi sangat sedikit.  Tetapi bagaimana jika Anda menggunakan <em>Peta</em> sebagai penyimpanan alih-alih objek sederhana?  Ada juga metode singkat: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c.has(k) ?c :c.set(k, f(...a))).get(k); } }</code> </pre> <br><p>  Hasil: <strong>121</strong> , tes lulus </p><br><p>  Mengurangi sepenuhnya gagal.  Tapi segera buang <em>Peta</em> tidak layak.  Implementasi penyimpanan nilai-kunci ini memungkinkan Anda untuk menggunakan objek sebagai kunci.  Dan itu berarti, haruskah kita melepaskan <em>JSON. Perjelas</em> sama sekali? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> (c.has(a) ?c :c.set(a, f(...a))).get(a); }</code> </pre> <br><p>  Hasil: <strong>83</strong> , tes 3 dan 4 jatuh </p><br><p>  Itu terlihat sangat menjanjikan!  Namun, tes 3 dan 4 mulai turun lagi, ini karena perbandingan kunci dalam objek <em>Peta</em> diimplementasikan menggunakan algoritma <em>SameValueZero</em> .  Jika Anda menghilangkan detail dengan <em>NaN, -0</em> dan <em>0</em> , maka itu bekerja sama dengan <em>operator perbandingan ketat</em> ( <em>===</em> ).  Dan kami memiliki array argumen baru (dan karenanya sebuah objek) untuk setiap panggilan dari fungsi yang dibungkus, bahkan dengan nilai yang sama.  Perbandingan terjadi sesuai dengan referensi objek dan oleh karena itu metode <em>Map.prototype.has</em> tidak <em>akan</em> pernah menemukan apa pun. </p><br><p>  Dengan demikian, penggunaan <em>Peta</em> tidak mengurangi kami <em>hasOwnProperty</em> atau <em>JSON.stringify</em> . </p><br><p>  Dalam <em>operator</em> datang ke penyelamatan, yang memeriksa keberadaan properti di suatu objek atau dalam rantai prototipe.  Mengapa kita tidak perlu takut dengan pencarian prototipe telah dijelaskan di atas. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> c = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> k = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] :c[k] = f(...a); } }</code> </pre> <br><p>  Hasil: <strong>105</strong> , tes lulus </p><br><p>  Badan memoizer dan fungsi yang dihasilkan terdiri dari dua ekspresi dengan kebutuhan untuk mendeklarasikan dan menginisialisasi variabel lokal sebelum logika dalam <em>pernyataan kembali</em> .  Apakah mungkin untuk mengurangi isi fungsi panah menjadi satu ekspresi di sini?  Tentu saja, menggunakan pola <em>IIFE</em> ( <em>Ekspresi Fungsi Langsung</em> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoize = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function"> =&gt;</span></span> (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> (...a) =&gt; (<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function"> =&gt;</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c ?c[k] : c[k] = f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)) )({});</code> </pre> <br><p>  Hasil: <strong>82</strong> , tes lulus </p><br><p>  Saatnya untuk menyingkirkan ruang ekstra: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)))({});</code> </pre> <br><p>  Hasil: <strong>68</strong> , tes lulus </p><br><p>  Jelas, bottleneck sekarang adalah metode <em>JSON.stringify</em> panjang, yang secara serial membuat objek menjadi string JSON, yang kami gunakan sebagai kuncinya.  Sebenarnya, kita tidak memerlukan fungsi serialisasi, tetapi fungsi hash yang dengannya kita bisa memeriksa kesetaraan objek, karena berfungsi dalam bahasa lain.  Tapi, sayangnya, tidak ada solusi asli dalam JavaScript, dan kode <em>hashCode yang</em> ditulis sendiri dalam prototipe <em>Object</em> jelas di luar ruang lingkup. </p><br><p>  Hmm, kenapa kita harus membuat cerita bersambung?  Saat menambahkan elemen ke objek dengan kunci, toStringnya akan dipanggil secara implisit.  Karena kami menolak untuk menggunakan objek <em>argumen</em> iterable yang mendukung array melalui <em>operator spread</em> , panggilan ke <em>String</em> tidak akan berasal dari <em>Object.prototype</em> , tetapi dari <em>Array.prototype</em> , di mana ia didefinisikan ulang dan dipisahkan oleh elemen-elemennya.  Jadi, untuk serangkaian argumen yang berbeda, kami mendapatkan kunci yang berbeda. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c=&gt;(...a</span></span></span><span class="hljs-function">)=&gt;</span></span>a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[a]:c[a]=f(...a))({});</code> </pre> <br><p>  Hasil: <strong>44</strong> , tes 6 jatuh </p><br><p>  Tes 6 baru saja mulai turun. Tampaknya nilai kembali adalah hasil dari panggilan fungsi sebelumnya dalam tes 5. Mengapa ini terjadi?  Ya, kami melewati panggilan <em>toString</em> untuk objek <em>argumen</em> , tetapi kami tidak memperhitungkan bahwa argumen apa pun bisa menjadi objek yang kompleks, memanggil <em>toString</em> dari mana kami mendapatkan <em>[objek objek]</em> favorit semua orang.  Ini berarti bahwa argumen {x: 1} dan {x: 2} akan menggunakan kunci yang sama dalam hash. </p><br><p>  <em>Btoa yang</em> digunakan untuk mengkonversi ke base64 tampak seperti pesaing yang baik untuk fungsi serialisasi.  Tapi dia memimpin dulu ke tali, jadi tidak ada peluang.  Kami berpikir ke arah menghasilkan URI, dan membentuk <em>ArrayBuffer</em> , fungsi apa pun untuk mendapatkan nilai hash atau serial.  Tapi mereka tetap di tempatnya. </p><br><p>  Ngomong-ngomong, <em>JSON.stringify</em> memiliki kekhasan sendiri: <em>Infinity, NaN, undefined, Symbol</em> akan dilemparkan ke <em>nol</em> .  Hal yang sama berlaku untuk fungsi.  Jika memungkinkan, panggilan implisit ke <em>JSON</em> dari objek terjadi, dan <em>Map</em> dan <em>Set</em> akan diwakili oleh elemen yang hanya disebutkan.  Dapat dimengerti, mengingat format terakhir: JSON. </p><br><p>  Apa selanjutnya </p><br><h3 id="toksichnaya-dorabotka">  Modifikasi beracun </h3><br><p>  Kita semua tentu menyukai fitur murni, tetapi dalam menghadapi tugas, persyaratan ini tidak sepadan.  Dan ini berarti sudah saatnya menambahkan sejumput efek samping. </p><br><p>  Pertama, mengapa tidak memulai cache sebagai berikut: </p><br><pre> <code class="javascript hljs">(f,c={})=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> c?c[k]:c[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Hasil: <strong>66</strong> , tes lulus </p><br><p>  Di sini kita menggunakan <em>parameter default</em> dalam fungsi panah.  Tentu saja, kami memberi klien kesempatan untuk mengatur cache mereka, jadi apa?  Tapi kami mengurangi 2 karakter. </p><br><p>  Bagaimana lagi saya bisa memulai cache untuk fungsi yang akan dihiasi?  Jawaban yang benar: mengapa kita perlu memulainya?  Mengapa tidak menggunakan sesuatu yang siap dalam konteks fungsi yang akan dibungkus.  Namun bagaimana jika fungsinya sendiri?  Kita semua tahu bahwa fungsi dalam JavaScript juga objek: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">=&gt;</span></span>k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a))(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a));</code> </pre> <br><p>  Hasil: <strong>59</strong> , tes lulus </p><br><p>  Di sini <em>JSON.stringify akan</em> melindungi kita dari berpotongan dengan properti dan metode lain dari objek (fungsi), membungkus argumen dalam "[...]". </p><br><p>  Pada saat ini, pola <em>IIFE yang</em> diterapkan sebelumnya <em>tidak</em> lagi membenarkan dirinya sendiri.  Tetapi menjaga satu ekspresi untuk fungsi panah sangat diperlukan untuk menghindari <em>pernyataan kembali</em> : </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a),k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a));</code> </pre> <br><p>  Hasil: <strong>57</strong> , tes lulus </p><br><p>  Karena kita tidak menggunakan <em>pernyataan blok</em> dalam fungsi panah, kita tidak dapat mendeklarasikan variabel ( <em>var</em> atau <em>let</em> ), tetapi kita dapat menggunakan konteks global - efek samping!  Di sini konflik sudah memiliki beberapa peluang. </p><br><p>  Menggunakan <em>operator koma,</em> kami menggabungkan dua ekspresi menjadi satu: operan dievaluasi dari kiri ke kanan, dan hasilnya adalah nilai yang terakhir. </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>(k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a))<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f[k]=f(...a);</code> </pre> <br><p>  Hasil: <strong>54</strong> , tes lulus </p><br><p>  Jadi, dengan mengatur ulang hanya satu braket, kami menyingkirkan tiga karakter sekaligus.  <em>Operator pengelompokan</em> dalam menghitung kunci memungkinkan kami untuk menggabungkan kedua operan dari ekspresi menjadi hanya satu ekspresi, dan braket penutup menghilangkan ruang sebelum <em>operator masuk</em> . </p><br><p>  Dan akhirnya: </p><br><pre> <code class="javascript hljs">f=&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...a</span></span></span><span class="hljs-function">)=&gt;</span></span>f[k=<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(a)]=k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> f?f[k]:f(...a);</code> </pre> <br><p>  Hasil: <strong>53</strong> , tes lulus </p><br><p>  Mengapa tidak menghitung kunci saat mengakses nilai.  Dan kemudian - operator dan tugas ternary yang sama.  Total: 53 karakter! </p><br><p>  Apakah mungkin untuk menghapus 3 karakter yang tersisa? </p><br><h3 id="osmyslenie">  Pemahaman </h3><br><p>  Kenapa semua ini?  Tugas sederhana ini dan rangkaian konversi dari kebiasaan menjadi tidak senonoh menunjukkan sejumlah besar fitur bahasa JavaScript.  Dalam diskusi kami, kami menyentuh hal-hal seperti: </p><br><ul><li>  Ekspresi fungsi panah </li><li>  Pelingkupan leksikal &amp; IIFE </li><li>  Objek argumen seperti array </li><li>  Sebarkan, koma, atau operator </li><li>  Operator perbandingan ketat </li><li>  JSON.stringify &amp; toString </li><li>  Di operator &amp; hasOwnProperty </li><li>  Pengelompokan operator &amp; pernyataan blokir </li><li>  Objek peta </li><li>  dan sesuatu yang lain </li></ul><br><p>  Kisah-kisah semacam itu adalah alasan yang baik untuk membenamkan diri dalam studi spesifik suatu bahasa, membantu untuk lebih memahaminya (atau sebaliknya).  Dan tentu saja, hanya untuk bersenang-senang! </p><br><h3 id="prilozhenie">  Aplikasi </h3><br><p><img src="https://habrastorage.org/webt/a8/n5/qp/a8n5qppehvlrsk6lmflpijrazjg.jpeg" alt="gambar"></p><br><p>  <em>Dalam petualangannya, Rick sering kali harus mengkalibrasi pistol portalnya.</em>  <em>Prosedur ini membutuhkan waktu, tetapi inputnya sering diulang.</em>  <em>Ilmuwan itu mencoba menghafal hasil yang sudah diperoleh sekali agar tidak membuat perhitungan berulang kali, tetapi alkoholisme dan pikun sangat mempengaruhi ingatannya.</em>  <em>Dia meminta Morty untuk meningkatkan modul pengaturan senjata, menambahkan fungsi memoizer.</em>  <em>Fungsi ini harus menyimpan hasil fungsi yang sedang didekorasi untuk mencegah perhitungan berulang.</em>  <em>Hanya Morty yang panik dan takut akan fungsi panjang.</em>  <em>Bantu dia memecahkan masalah sepadat <strong>mungkin</strong> .</em>  <em>Fungsi yang sedang didekorasi dapat menggunakan integer, string, Boolean, dan objek sebagai argumen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413303/">https://habr.com/ru/post/id413303/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413287/index.html">DocumentFragment: apa itu dan bagaimana (tidak) melawannya</a></li>
<li><a href="../id413289/index.html">Otomatisasi pusat data atau "pemberontakan mesin"</a></li>
<li><a href="../id413291/index.html">Buku "Deep Learning in Python"</a></li>
<li><a href="../id413293/index.html">Eksodus hebat dari industri video game</a></li>
<li><a href="../id413297/index.html">Font web variabel</a></li>
<li><a href="../id413305/index.html">Baterai, Gigafactory, Northvolt, dan Siemens. Orang Luar T</a></li>
<li><a href="../id413307/index.html">ESET menemukan bankir BackSwap menggunakan metode manipulasi browser baru</a></li>
<li><a href="../id413309/index.html">Sisi gelap lincah</a></li>
<li><a href="../id413311/index.html">Porting aplikasi web Anda dari JavaScript murni ke Vue.js</a></li>
<li><a href="../id413315/index.html">Sistem iklim di apartemen dengan tangan Anda sendiri - bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>