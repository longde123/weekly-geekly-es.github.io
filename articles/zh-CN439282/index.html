<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎓 ☝🏼 ⏪ SVG过滤效果。 第1部分。SVG过滤器101 🖐️ 👨🏾‍🏭 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="拟议的系列文章“ SVG过滤效果 ”，作者：Sara Soueidan，是自由UI / UX界面开发人员，并且是黎巴嫩的许多技术文章的作者，重点关注SVG过滤器的工作，并包括以下文章： 
 SVG过滤效果 


1. SVG滤镜的效果。 第1部分。SVG过滤器101。 
2. SVG滤镜的效果。 第...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SVG过滤效果。 第1部分。SVG过滤器101</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439282/"><p> 拟议的系列文章“ <strong>SVG过滤效果</strong> ”，作者：Sara Soueidan，是自由UI / UX界面开发人员，并且是黎巴嫩的许多技术文章的作者，重点关注SVG过滤器的工作，并包括以下文章： </p><br><h1 id="effekty-filtracii-svg">  SVG过滤效果 </h1><br><ol><li>  SVG滤镜的效果。 第1部分。SVG过滤器101。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SVG滤镜的效果。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分。使用特征形态轮廓文本</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SVG过滤效果。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分。使用feComponentTransfer进行图像后代化的效果</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SVG过滤效果。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分</a> 。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带<strong>feComponentTransfer的</strong>两色图像</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SVG过滤效果。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分。使用<strong>feDisplacementMap将</strong>文本与表面纹理<strong>匹配</strong></a> </li></ol><br><hr><br><p> 这是有关SVG过滤器系列的第一篇文章。 本指南将帮助您了解其含义，并向您展示如何使用它们创建自己的视觉效果。 </p><br><p><img src="https://habrastorage.org/webt/_8/ka/is/_8kaisnavnh_qmr3tvdsxofq0ii.png"></p><a name="habracut"></a><br><p>  <strong>CSS</strong>当前为我们提供了一种方法，可以使用<strong>滤镜</strong>属性及其随附的功能将色彩效果（例如饱和度，亮度和对比度）以及其他效果应用于图像。 </p><br><p> 现在，我们在CSS中有11个过滤器函数，它们执行从模糊到改变颜色对比度和饱和度的许多效果，以及更多功能。 有关更多信息， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅CSS参考</a> 。 </p><br><p> 尽管功能强大且非常方便，但是CSS过滤器也非常有限。 我们可以用它们创建的效果通常适用于图像，并且仅限于颜色处理和简单的模糊处理。 因此，要创建可以应用于更广泛元素的更强大的效果，我们需要更广泛的功能。 这些功能今天可用，并且在SVG中已经使用了十多年。 在SVG过滤器系列的第一篇文章中，您将了解SVG过滤器的功能（称为“原语”）以及如何使用它们。 </p><br><p>  CSS过滤器是从SVG导入的。 它们是SVG中引入的滤镜效果子集的相当优化的版本，并且已经存在于SVG规范中很多年了。 </p><br><p>  SVG比CSS具有更多的过滤效果，并且SVG版本比CSS快捷方式功能更强大且执行的效果更复杂。 例如，您当前可以使用<strong>blur（）</strong> CSS过滤器功能对元素进行<strong>模糊处理</strong> 。 通过此功能应用模糊效果将为要应用该模糊效果的元素创建均匀的高斯模糊。 下图显示了将6px模糊应用于CSS中的图像的结果： </p><br><p><img src="https://habrastorage.org/webt/b0/qa/fy/b0qafyst_uc08euvuxzilp13-wi.png" alt="应用**模糊（）函数的效果-高斯模糊"><br>  <em>图_1。</em>  <em>应用<strong>blur（）</strong> CSS函数的效果是高斯模糊。</em> </p><br><p>  <strong>blur（）</strong>函数创建一种模糊效果，该效果均匀地应用在图像的两个方向（X和Y）上。 但是，此功能只是对SVG中可用的模糊滤镜基元的简化和有限的减少，它使我们能够均匀地模糊图像或沿X轴或Y轴应用单向模糊效果。 </p><br><p><img src="https://habrastorage.org/webt/e5/gp/rr/e5gprr6riymt0ede8sxusumcyfk.png" alt="分别沿轴应用SVG函数**模糊（）**的效果"><br>  <em>图_2。</em>  <em>分别沿轴应用<strong>blur（）</strong> SVG函数的效果。</em> </p><br><p>  SVG过滤器可以应用于HTML元素和SVG元素。 可以使用url（）过滤器功能将SVG过滤效果应用于CSS中的HTML元素。 例如，如果您具有在SVG中定义的标识符<strong>myAwesomeEffect</strong>的滤镜效果（我们将在不久的将来讨论在SVG中定义滤镜效果），则可以将此效果应用于HTML元素或图像，如下所示： </p><br><pre><code class="plaintext hljs">.el { filter: url(#myAwesomeEffect); }</code> </pre> <br><p> 最好的是，正如您在本系列文章中将看到的那样，SVG滤镜能够使用几行代码在浏览器中创建Photoshop级别的效果。 我希望本系列文章将有助于消除秘密的光环，并释放SVG过滤器潜力的一部分，这将启发您在自己的项目中使用它们。 </p><br><p> 但是，您对浏览器的支持又如何呢？ </p><br><h2 id="podderzhka-brauzerami"> 浏览器支持 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器对</a>大多数SVG过滤<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">器的支持</a>令人印象深刻。 但是，在某些浏览器中，应用效果的方法可能有所不同，这取决于它们对SVG过滤效果中使用的各个过滤器原语的支持以及可能的浏览器错误。 将SVG过滤器应用于SVG元素或HTML元素时，浏览器支持也可能会有所不同。 </p><br><p> 我建议您将过滤效果视为一种扩展：几乎可以始终在不使用过滤器的完全有用的体验之上应用效果作为改进。 许多人知道，我支持在可能的情况下逐步创建UI的方法。 因此，在本系列文章中，我们不必过多担心浏览器的支持。 </p><br><p> 最后，尽管通常对SVG滤波器的支持不错，但请记住，我们稍后将讨论的某些效果可以视为实验性的。 如果有的话，我会指出任何重大问题或错误。 </p><br><p> 那么，如何在SVG中定义和创建过滤效果？ </p><br><h2 id="element--filter">  &lt;Filter&gt;元素 </h2><br><p> 像SVG中的线性渐变，蒙版，图案和其他图形效果一样，滤镜具有一个方便命名的特殊元素： <strong>&lt;filter&gt;</strong> 。 </p><br><p> 它从不直接显示，而仅用作可通过SVG中的<strong>filter</strong>属性或CSS中的<strong>url（）</strong>函数引用的对象。 在没有显式引用的情况下无法显示的元素通常被定义为SVG中<strong>&lt;defs&gt;</strong>元素内的模板。 但是SVG <strong>&lt;filter&gt;</strong>不需要包装在<strong>defs</strong>元素中。 无论您是否将过滤器包装在<strong>defs</strong>元素中，它都不会显示。 </p><br><p> 原因是<strong>滤镜需要处理原始图像</strong> 。 而且，如果您没有通过在其上调用过滤器来明确定义此源图像，则该过滤器将无法呈现任何内容，因此将无法使用。 </p><br><p> 一个非常简单，最少的代码示例，它定义了SVG过滤器并将其应用于SVG中的原始图像，如下所示： </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;!-- filter effects go in here --&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p> 上面的代码示例中的过滤器目前为空，因为它为空。 要创建滤镜效果，必须定义一系列在滤镜内部创建此效果的一个或多个滤镜操作。 换句话说， <strong>&lt;filter&gt;</strong>元素是一系列过滤操作的容器，这些操作共同创建过滤效果。  SVG中的这些过滤操作称为“ <strong>过滤器原语</strong> ”。 </p><br><h2 id="primitivy-filtra"> 过滤原语 </h2><br><p> 因此，在SVG中，每个<strong>&lt;filter&gt;</strong>元素都包含一组过滤器原语作为子元素。 每个过滤器原语在一个或几个输入上执行一个基本的图形运算，从而创建图形结果。 </p><br><p> 过滤器基元以它们执行的图形操作方便地命名。 例如，将高斯模糊效果应用于图形源的图元称为<strong>feGaussianBlur</strong> 。 所有基元都有相同的前缀：fe，“ <em>filter effect</em> ”的缩写。 同样，SVG中的名称便于选择以了解此元素的含义或作用。 </p><br><p> 以下代码段显示了对图像应用5px高斯模糊时简单滤镜的外观： </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;feGaussianBlur stDeviation="5"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p> 当前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><strong>SVG滤镜</strong></a>规范定义了17种滤镜原语，它们能够创建极其强大的图形效果，包括但不限于噪声和纹理生成，照明效果，颜色操纵（通道间）等等。 </p><br><p> 过滤器原语通过接受图形源进行输入和输出到另一个来工作。 一个滤镜效果的输出可用作另一个滤镜效果的输入。 这非常重要且非常有效，因为使用几乎无数种滤镜效果组合，您可以创建几乎无数种图形效果。 </p><br><p> 每个过滤器原语只能接受一个或两个输入，而只能输出一个结果。 过滤器原语的输入在in属性中定义。 操作的<strong>结果</strong>在<strong>result</strong>属性中定义。 如果滤镜效果需要第二个输入，则在<strong>in2</strong>属性中指定它。 该操作的结果可以用作任何其他操作的输入，但是如果未在in属性中指定该操作的输入，则前一个操作的结果将自动用作输入。 如果您未指定原语的<strong>结果</strong> ，则其结果将自动用作下一个原语的输入。 当我们开始研究代码示例时，这一点将变得更加清楚。 </p><br><p> 过滤器原语可以使用其他数据类型作为输入，其中最重要的是： </p><br><ul><li>  <strong>SourceGraphic</strong> ：整个过滤器应用于的元素； 例如，图像或一段文字。 </li><li>  <strong>SourceAlpha</strong> ：与<strong>SourceGraphic</strong>相同，除了此图形仅包含元素的alpha通道。 例如，对于JPEG图像，这是一个黑色矩形，其大小等于图像本身的大小。 </li></ul><br><p> 您会发现有时需要将图形源用作输入，有时仅将其Alpha通道用作输入。 我们将在本文及后续文章中介绍的示例将使您清楚地了解何时以及使用什么方式。 </p><br><p> 此代码段是一个过滤器的外观示例，其中一个过滤器基元数据包作为子级。 不要担心基元及其作用。 此时，只需注意如何定义和使用某些原语的输入和输出。 我添加了一些评论以寻求帮助。 </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="filter"&gt; &lt;feOffset in="SourceAlpha" dx="20" dy="20"&gt;&lt;/feOffset&gt; &lt;!-- since the previous filter did not have a result defined and this following one does not have the input set, the result of the above primitive is automatically used as input to the following filter --&gt; &lt;feGaussianBlur stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- setting/defining the result names in all caps is a good way to make them more distinguishable and the overall code more readable --&gt; &lt;feFlood flood-color="#000" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- This primitive is using the outputs of the previous two primitives as input, and outputting a new effect --&gt; &lt;feComposite in="DROP" in2="COLOR" operator="in" result="SHADOW1"&gt;&lt;/feComposite&gt; &lt;feComponentTransfer in="SHADOW1" result="SHADOW"&gt; &lt;feFuncA type="table" tableValues="0 0.5"&gt;&lt;/feFuncA&gt; &lt;/feComponentTransfer&gt; &lt;!-- You can use ANY two results as inputs to any primitive, regardless of their order in the DOM.--&gt; &lt;feMerge&gt; &lt;feMergeNode in="SHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#filter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p> 现在，在继续我们的第一个过滤器示例之前，我要简要解释的最后一个概念是<strong>Filter Region</strong>的概念。 </p><br><h2 id="oblast-filtracii"> 过滤面积 </h2><br><p> 一组过滤操作需要一个要处理的区域，一个可以对其应用的区域。 例如，您可能有一个包含许多元素的复杂SVG，并且您只想将过滤效果应用于特定区域或同一SVG中的一个或一组元素。 </p><br><p> 在SVG中，元素具有“区域”，其边界由界定元素的矩形边缘定义。 边界框（也称为“ bbox”）是元素周围最小的封闭矩形。 例如，在下图中，对于一段文本，此类矩形用粉红色突出显示。 </p><br><p><img src="https://habrastorage.org/webt/hu/uy/i1/huuyi1kr0i8ldvfpggxgwpdi6sm.png" alt="一段文字周围的最小封闭矩形"><br>  <em>图_3。</em>  <em>一段文字周围最小的封闭矩形。</em> </p><br><p> 请注意，此矩形可能包含更多垂直空间，因为在计算边界矩形的高度时会考虑文本行的高度。 </p><br><p> 默认情况下，元素过滤器区域是边界元素框架。 因此，如果您对文本片段应用滤镜效果，则该效果将仅限于此矩形，并且超出该矩形的任何滤镜结果都将被切除。 尽管这是合理的，但它不是很实用，因为许多滤镜会影响边界框外的某些像素，默认情况下，这些像素最终会被切除。 </p><br><p> 例如，如果您对文本片段应用模糊效果，则可以看到它是沿着界定文本的矩形的左右边缘裁剪的： </p><br><p><img src="https://habrastorage.org/webt/ll/ih/e4/llihe4hbwx94zl3xk-w9zmcmmkq.png" alt="缩进的文本的模糊效果会在界定文本的矩形的左右两边都进行缩小。"><br>  <em>图_4。</em>  <em>应用于文本的模糊效果会在界定文本的矩形的左右两侧都进行裁剪。</em> </p><br><p> 那么我们如何防止这种情况呢？ 答案是：通过扩大过滤面积。 我们可以通过更改&lt;filter&gt;元素的<strong>x</strong> ， <strong>y</strong> ， <strong>width</strong>和<strong>height</strong>属性来扩展应用过滤器的范围。 </p><br><p> 根据规范， </p><br><blockquote> 通常，必须在滤镜区域中提供字段，因为滤镜效果可能会影响给定对象的边界框外的某些位。 为此，您可以为<strong>X</strong>和<strong>Y</strong>属性提供负值（以百分比表示），为<strong>width</strong>和<strong>height</strong>属性提供大于100％的值。 </blockquote><p> 默认情况下，过滤器的区域在所有四个方向上都延伸出边框的宽度和高度的10％。 换句话说， <strong>x</strong> ， <strong>y</strong> ， <strong>width</strong>和<strong>height</strong>属性的默认值为： </p><br><pre> <code class="plaintext hljs">&lt;filter x="-10%" y="-10%" width="120%" height="120%" filterUnits="objectBoundingBox"&gt; &lt;!-- filter operations here --&gt; &lt;/filter&gt;</code> </pre> <br><p> 如果您未在<strong>&lt;filter&gt;</strong>元素中包括这些属性，则将使用默认值。 您也可以根据需要覆盖它们以扩大或缩小面积。 </p><br><p> 请记住，在<strong>x</strong> ， <strong>y</strong> ， <strong>width</strong>和<strong>height</strong>属性中使用的单位取决于所使用的<strong>filterUnits</strong>属性<strong>值</strong> 。 它定义了属性<strong>x</strong> ， <strong>y</strong> ， <strong>width</strong>和<strong>height</strong>的坐标系，并且可以采用以下两个值之一： </p><br><ul><li>  <strong>objectBoundingBox</strong> 。 这是默认值。 当<strong>filterUnits</strong>设置为<strong>objectBoundingBox时</strong> ， <strong>x</strong> ， <strong>y</strong> ， <strong>width</strong>和<strong>height</strong>属性值是元素边界框大小的百分比或分数。 这也意味着您可以根据需要使用分数值而不是百分比。 </li><li>  <strong>userSpaceOnUse</strong>如果将<strong>filterUnits</strong>设置为<strong>userSpaceOnUse</strong> ，则x，y，width和height属性的坐标相对于用户使用的当前坐标系。 换句话说，这与SVG中使用的当前坐标系有关，后者使用像素作为度量单位，并且通常相对于SVG本身的大小，假设<strong>viewBox</strong>值对应于原始坐标系的值。 </li></ul><br><blockquote> 您需要了解的有关SVG中坐标系统的所有信息都可以在我几年前写的这篇文章中找到。 </blockquote><br><pre> <code class="plaintext hljs">&lt;!-- Using objectBoundingBox units --&gt; &lt;filter id="filter" x="5%" y="5%" width="100%" height="100%"&gt; &lt;!-- Using userSpaceOnUse units --&gt; &lt;filter id="filter" filterUnits="userSpaceOnUse" x="5px" y="5px" width="500px" height="350px"&gt;</code> </pre> <br><h3 id="bystryy-sovet-vizualizaciya-tekuschey-oblasti-filtra-s-pomoschyu-feflood"> 快速提示：使用feFlood可视化当前过滤器区域 </h3><br><p> 如果您需要查看滤镜区域的界限，可以通过用某种颜色填充滤镜来使其可视化。 方便地，有一个名为<strong>feFlood</strong>的过滤器原语，其唯一目的就是这样做：用<strong>Flood-Color</strong>属性中指定的颜色填充当前过滤器区域。 </p><br><p> 因此，如果我们假设有一段文本，我们希望看到其过滤区域，那么代码可能看起来像这样： </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder" x="0" y="0" width="100%" height="100%"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9"&gt;&lt;/feFlood&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p> 从上面的代码片段中可以看到， <strong>feFlood</strong>原语也接受<strong>Flood-opacity</strong>属性，该属性可用于创建填充颜色层的透明度。 </p><br><p> 上面的代码段用粉红色填充了过滤器区域。 事情是这样的：当您用颜色填充区域时，实际上是用颜色填充它，这意味着颜色将覆盖滤镜区域中的所有内容，包括您先前创建的任何元素和效果以及文本本身。 毕竟，这就是填充的概念，对吗？ </p><br><p><img src="https://habrastorage.org/webt/aj/pc/qc/ajpcqctctaikdiirvjexjeuh6yg.png" alt="用颜色填充过滤器文本区域之前和之后"><br>  <em>图_5。</em>  <em>在用颜色填充过滤器的文本区域之前和之后。</em> </p><br><p> 要更改此设置，我们需要将颜色层移到下面，并在顶部显示原始文本层。 </p><br><p> 如果在SVG过滤器中有多个应在彼此之上显示的上下文层，则可以使用<strong>&lt;feMerge&gt;</strong>过滤器原语。 顾名思义， <strong>feMerge</strong>原语用于将元素或效果层组合在一起。 </p><br><p> 该原语<strong>没有in属性。</strong>  <strong>为了合并<strong>&lt;feMerge&gt;</strong>内部的层，使用了两个或多个<strong>&lt;feMergeNode&gt;</strong> ，每个层中都有自己的属性，表示我们要添加的层。</strong> <br></p><p> 层（或“节点”）的放置取决于源<strong>&lt;feMergeNode&gt;</strong>的顺序-第一个<strong>&lt;feMergeNode&gt;</strong>显示在第二个“后面”或“下面”。 最后一个<strong>&lt;feMergeNode&gt;</strong>代表最顶层。 依此类推。 </p><br><p> 因此，在带有文本的示例中，颜色填充是一个图层，文本源（图形源）是一个不同的图层，我们希望将文本放在颜色填充的顶部。 我们的代码如下所示： </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9" result="FLOOD"&gt;&lt;/feFlood&gt; &lt;feMerge&gt; &lt;feMergeNode in="FLOOD" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p> 请注意，我是<strong>如何</strong>在<strong>result</strong>属性中命名<strong>feFlood</strong>的<strong>结果的</strong> ，以便可以在<strong>&lt;feMergeNode&gt;</strong>层中将此名称用作输入。 由于我们想在流颜色的顶部显示源文本，因此我们使用<strong>SourceGraphic</strong>引用此文本。 以下演示显示了结果： </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://codepen.io/SaraSoueidan/embed/preview/dJddbK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="primenenie-teni-k-izobrazheniyu"> 对图像应用阴影 </h2><br><p> 让我以一个简短的警告开始：最好使用<strong>drop-shadow（）</strong> CSS过滤功能创建一个简单的阴影。  SVG过滤器路径更为冗长。 毕竟，正如我们前面提到的，CSS过滤器功能是便捷的快捷方式。 但是我仍然想将此示例视为更复杂的滤镜效果的简单切入点，我们将在以后的文章中介绍。 </p><br><p> 那么阴影是如何产生的呢？ </p><br><p> 阴影通常是元素后方或下方的浅灰色层，其形状与元素本身相同。 换句话说，您可以将其视为元素的模糊灰色副本。 </p><br><p> 创建SVG过滤器时，您需要分阶段进行推理。 要实现此效果，必须采取什么步骤？ 对于阴影，可以通过模糊元素的黑色副本然后为该黑色副本上色（即着色）来创建元素的灰色副本。 使她变灰。 然后，将此新创建的模糊灰色副本放置在原始元素的后面，并在两个方向上稍有偏移。 </p><br><p> 因此，我们<strong>将从获取元素的黑色副本并将其模糊化开始</strong> 。 可以使用元素的Alpha通道（使用<strong>SourceAlpha</strong>作为过滤器输入）创建黑色副本。 </p><br><p>  <strong>feGaussianBlur</strong>原语将用于将高斯模糊应用于此SourceAlpha层。 所需的模糊量在<strong>stdDeviation</strong>属性中设置（“标准偏差”的缩写）。 如果设置<strong>stdDeviation</strong>属性的一个值，则该值将用于对输入数据进行均匀模糊处理。 您还可以指定两个数值，然后第一个将用于在水平方向上模糊元素，第二个将用于垂直模糊。 对于阴影，我们需要应用均匀的模糊，因此我们的代码将从以下内容开始： </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;-- Grab a blakc copy of the source image and blur it by 10 --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p> 上面的代码段具有以下效果，其中当前仅显示图像的模糊Alpha通道： </p><br><p><img src="https://habrastorage.org/webt/zd/e9/ye/zde9ye5ycftyjmi_cru94ty3jde.png" alt="创建具有模糊（阴影）的黑色复制图像"><br>  <em>图_6。</em>  <em>创建具有模糊（阴影）图像的黑色副本。</em> </p><br><p> 然后我们要<strong>更改阴影的颜色并将其变为灰色</strong> 。 为此，我们将颜色填充应用于滤镜区域，然后将该颜色填充层与我们创建的阴影层组合在一起。 </p><br><p> 对齐是图形元素与模糊背景的连接。 模糊的背景是与元素对齐的元素后面的内容。 在我们的滤镜中，填充色是顶层，而模糊的阴影是背景，因为它位于它的后面。 在以下文章中，我们将更详细地考虑<strong>feComposite</strong>原语，因此，如果您不熟悉该组合及其工作方式，那么建议您在我的博客中阅读有关此主题的<strong>详细文章</strong> 。 </p><br><p>  <strong>feComposite</strong>原语具有一个<strong>operator</strong>属性，该属性用于指示我们要使用的复合操作。 </p><br><p> 使用<strong>in复合</strong>运算符，颜色填充层将被“剪切”，并且仅显示与阴影层匹配的颜色区域。 这两层将在它们相交的地方混合在一起，即 灰色将用于为黑色阴影着色。 </p><br><p>  <strong>feComposite</strong>      ,    <strong>in</strong>  <strong>in2</strong> .   —    ,   —   .    ,    <strong>operator</strong> ,      : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  ,   <strong>feGaussianBlur</strong>   <strong>feFlood</strong>       .     : </p><br><p><img src="https://habrastorage.org/webt/_c/c7/an/_cc7an_zj43v7gv4jka--6mpnpi.png" alt="现在阴影是灰色的"><br> <em>_7.   .</em> </p><br><p>  ,        ,       / .          .     ,      ,       ,          . </p><br><p>     SVG   <strong>feOffset</strong> .    <strong>in</strong>  <strong>result</strong>      : <strong>dx</strong>  <strong>dy</strong> ,   ,         X  Y . </p><br><p>   ,       ,  <strong>feMerge</strong> ,  ,           —  <strong>mergeNode</strong>       ,    <strong>mergeNode</strong>    ,  <strong>SourceGraphic</strong>    .     : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;!-- Get the source alpha and blur it; we'll name the result "DROP" --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- flood the region with a ligh grey color; we'll name this layer "COLOR" --&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- Composite the DROP and COLOR layers together to colorize the shadow. The result is named "SHADOW" --&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;!-- Move the SHADOW layer 20 pixels down and to the right. The new layer is now called "DROPSHADOW" --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- Layer the DROPSHADOW and the Source Image, ensuring the image is positioned on top (remember: MergeNode order matters) --&gt; &lt;feMerge&gt; &lt;feMergeNode in="DROPSHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- Apply the filter to the source image in the `filter` attribute --&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://codepen.io/SaraSoueidan/embed/preview/qpoqwQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         SVG,   SVG.  ,        . </p><br><h2 id="est-drugoy-sposob">   … </h2><br><p>  ,     .  ,         ,    ,      ,    , , . </p><br><p>     ,     ,  <strong>feFlood</strong> ,  ,  , ,      .    ,    .    ,    ,     , ,  - ,  , ,    . </p><br><p>         <strong>feColorMatrix</strong> ,  <strong>feComponentTransfer</strong> .   <strong>feComponentTransfer</strong>       ,    <strong>feColorMatrix</strong> ,     . </p><br><p>  <strong>feColorMatrix</strong>   .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Una Kravet</a> ,        . </p><br><p>  ,        R(), G(), B()  A()              -.  ,       .     : </p><br><pre> <code class="plaintext hljs">&lt;filter id="myFilter"&gt; &lt;feColorMatrix type="matrix" values="R 0 0 0 0 0 G 0 0 0 0 0 B 0 0 0 0 0 A 0 "/&gt; &lt;/feColorMatrix&gt; &lt;/filter&gt;</code> </pre> <br><p>      ,      . </p><br><p>        ,     ,     RGB,     -   : </p><br><pre> <code class="plaintext hljs">&lt;filter id="filter"&gt; &lt;!-- Get the source alpha and blur it, --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- offset the drop shadow --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- make the shadow translucent by reducing the alpha channel value to 0.3 --&gt; &lt;feColorMatrix type="matrix" in="DROPSHADOW" result="FINALSHADOW" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0"&gt; &lt;/feColorMatrix&gt; &lt;!-- Merge the shadow and the source image --&gt; &lt;feMerge&gt; &lt;feMergeNode in="FINALHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt;</code> </pre> <br><p>     : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://codepen.io/SaraSoueidan/embed/preview/opEZee" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>                   .         ,    .         ,         .  ,       ,   ,   ,   ,    .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> .   ,     ,  ,         .             . </p><br><p> ,     SVG-      ,            . 和我们在一起。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439282/">https://habr.com/ru/post/zh-CN439282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439268/index.html">VR，AR和3D打印如何协同工作：VR概念体验</a></li>
<li><a href="../zh-CN439270/index.html">在Python中使用libclang解析C ++代码的示例</a></li>
<li><a href="../zh-CN439272/index.html">Netflix上的Jupyter Notebook</a></li>
<li><a href="../zh-CN439278/index.html">我的LCD的ACS-两个螺栓的安全性</a></li>
<li><a href="../zh-CN439280/index.html">Trautonium：合成器历史上的德国浪潮</a></li>
<li><a href="../zh-CN439286/index.html">说实话静态分析</a></li>
<li><a href="../zh-CN439288/index.html">科学，优化</a></li>
<li><a href="../zh-CN439290/index.html">快速加快Xcode的编译速度</a></li>
<li><a href="../zh-CN439294/index.html">翻译评论“如果使用公款创建软件，则代码必须开放”</a></li>
<li><a href="../zh-CN439296/index.html">苏联车牌和Kolmogorov的复杂性</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>