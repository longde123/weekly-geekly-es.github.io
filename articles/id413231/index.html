<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ” ğŸ§ğŸ¿ â£ï¸ Pengantar Kontrak Cerdas ğŸ•¥ â˜ğŸ¿ ğŸ¤¹ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini kita akan melihat apa kontrak pintar, apa mereka, berkenalan dengan platform kontrak pintar yang berbeda, fitur-fiturnya, dan juga m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar Kontrak Cerdas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/distributedlab/blog/413231/">  Dalam artikel ini kita akan melihat apa kontrak pintar, apa mereka, berkenalan dengan platform kontrak pintar yang berbeda, fitur-fiturnya, dan juga membahas bagaimana mereka bekerja dan keuntungan apa yang bisa mereka bawa.  Materi ini akan sangat berguna bagi pembaca yang tidak terbiasa dengan topik kontrak pintar, tetapi ingin lebih dekat untuk memahaminya. <br><a name="habracut"></a><br><h2>  <b>Kontrak reguler vs</b>  <b>kontrak pintar</b> </h2><br>  Sebelum kita masuk ke detail, mari kita lihat contoh perbedaan antara kontrak biasa, yang ditetapkan di atas kertas, dan kontrak pintar, yang disajikan dalam bentuk digital. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e19/d3a/226/e19d3a22688347a83b9ef987a94162c7.png" alt="gambar"><br><br>  Bagaimana ini bekerja sebelum kontrak pintar?  Bayangkan sekelompok orang yang ingin menetapkan beberapa aturan dan ketentuan untuk distribusi nilai, serta mekanisme tertentu untuk menjamin implementasi distribusi ini sesuai dengan aturan dan ketentuan yang diberikan.  Kemudian mereka datang bersama-sama, membuat makalah di mana mereka menuliskan data identifikasi mereka, kondisi, nilai-nilai yang terlibat, mengatur tanggal dan menandatangani.  Kontrak ini juga disertifikasi oleh pihak yang dipercaya, seperti notaris.  Lebih lanjut, orang-orang ini menyimpang ke arah yang berbeda dengan salinan kertas dari kontrak semacam itu dan mulai melakukan beberapa tindakan yang mungkin tidak sesuai dengan kontrak itu sendiri, yaitu, mereka melakukan satu hal, dan dijamin di atas kertas bahwa mereka harus melakukan sesuatu yang sama sekali berbeda.  Dan bagaimana cara keluar dari situasi ini?  Bahkan, salah satu anggota kelompok perlu mengambil makalah ini, mengambil beberapa bukti, membawanya ke pengadilan dan mencari kepatuhan antara kontrak dan tindakan yang sebenarnya.  Cukup sering sulit untuk mencapai pelaksanaan yang adil dari kontrak ini, yang mengarah pada konsekuensi yang tidak menyenangkan. <br><br>  Apa yang bisa dikatakan tentang kontrak pintar?  Mereka menggabungkan kemungkinan penulisan ketentuan-ketentuan kontrak dan mekanisme pelaksanaannya yang ketat.  Jika kondisi telah ditetapkan dan transaksi atau permintaan yang sesuai telah ditandatangani, maka setelah menerima permintaan atau transaksi ini, tidak mungkin lagi untuk mengubah kondisi atau mempengaruhi implementasinya. <br><br>  Ada satu validator atau seluruh jaringan, serta database yang menyimpan semua kontrak pintar yang masuk untuk dieksekusi dalam urutan kronologis yang ketat.  Penting juga bahwa basis data ini harus berisi semua kondisi pemicu untuk melaksanakan kontrak pintar.  Selain itu, harus mempertimbangkan nilai yang sebenarnya, distribusi yang dijelaskan dalam kontrak.  Jika ini berlaku untuk beberapa mata uang digital, maka basis data ini harus memperhitungkannya. <br><br>  Dengan kata lain, validator kontrak pintar harus memiliki akses ke semua data yang digunakan kontrak cerdas.  Sebagai contoh, satu database harus digunakan untuk secara bersamaan merekam mata uang digital, saldo pengguna, transaksi pengguna, dan cap waktu.  Kemudian, dalam kontrak pintar, kondisinya mungkin saldo pengguna dalam mata uang tertentu, permulaan waktu tertentu atau fakta transaksi tertentu, tetapi tidak lebih. <br><br><h2>  <b>Definisi kontrak yang cerdas</b> </h2><br>  Secara umum, terminologi itu sendiri ditemukan oleh peneliti Nick Szabo dan pertama kali diterapkan pada tahun 1994, dan didokumentasikan pada tahun 1997 dalam sebuah artikel yang menggambarkan gagasan tentang kontrak pintar. <br><br>  Kontrak pintar menyiratkan bahwa beberapa otomatisasi distribusi nilai dilakukan, yang mungkin hanya bergantung pada kondisi yang telah ditentukan sebelumnya.  Dalam bentuknya yang paling sederhana, itu terlihat seperti kontrak dengan kondisi yang ditentukan secara khusus, yang ditandatangani oleh pihak-pihak tertentu. <br><br>  Kontrak pintar dirancang untuk meminimalkan kepercayaan kepada pihak ketiga.  Kadang-kadang pusat keputusan, tempat semua hal bergantung, dikecualikan sepenuhnya.  Selain itu, lebih mudah untuk melakukan audit untuk kontrak semacam itu.  Ini adalah konsekuensi dari beberapa fitur desain sistem seperti itu, tetapi yang paling sering kita maksudkan dengan kontrak pintar lingkungan terdesentralisasi dan adanya fungsi yang memungkinkan siapa saja yang ingin menganalisis database dan melakukan audit penuh pelaksanaan kontrak.  Ini memastikan perlindungan terhadap perubahan retroaktif dalam data yang akan memerlukan perubahan dalam pelaksanaan kontrak itu sendiri.  Digitalisasi sebagian besar proses ketika membuat dan meluncurkan kontrak pintar seringkali menyederhanakan teknologi dan biaya implementasinya. <br><br><h3>  Contoh sederhana - Layanan escrow </h3><br>  Mari kita lihat contoh yang sangat sederhana.  Ini akan membantu Anda lebih dekat untuk memahami fungsionalitas kontrak pintar, serta menavigasi yang lebih baik dalam kasus mana mereka harus digunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/ff9/541/c49ff9541c0289e2da814c0d62a0425a.png" alt="gambar"><br><br>  Ini juga dapat diimplementasikan menggunakan Bitcoin, meskipun sekarang masih sulit untuk menyebut Bitcoin sebagai platform lengkap untuk kontrak pintar.  Jadi, kami memiliki beberapa pembeli dan ada toko online.  Pembeli ingin membeli monitor di toko ini.  Dalam kasus paling sederhana, pembeli menyiapkan dan mengirim pembayaran, dan toko online menerimanya, mengonfirmasi, dan kemudian mengirimkan barang.  Namun, dalam situasi ini ada kebutuhan akan kepercayaan besar - pembeli harus memercayai toko online untuk seluruh biaya monitor.  Karena toko online mungkin memiliki reputasi rendah di mata pembeli, ada risiko bahwa karena alasan tertentu, setelah menerima pembayaran, toko akan menolak untuk melayani dan tidak akan mengirim barang ke pembeli.  Oleh karena itu, pembeli mengajukan pertanyaan (masing-masing, dan toko online menanyakan pertanyaan ini) apa yang dapat diterapkan dalam kasus ini untuk meminimalkan risiko tersebut dan membuat transaksi tersebut lebih dapat diandalkan. <br><br>  Dalam kasus Bitcoin, Anda dapat memberi pembeli dan penjual peluang untuk memilih mediator secara independen.  Ada banyak orang yang berurusan dengan masalah kontroversial.  Dan peserta kami dapat memilih dari daftar mediator umum yang akan dipercaya pada saat yang sama.  Bersama-sama mereka membuat alamat multisignature 2 dari 3, di mana ada tiga kunci dan dua tanda tangan diperlukan oleh dua kunci untuk menghabiskan koin dari alamat ini.  Satu kunci akan menjadi milik pembeli, yang kedua ke toko online, dan yang ketiga ke mediator.  Dan pembeli akan mengirimkan jumlah yang diperlukan untuk membayar monitor ke alamat multisignature.  Sekarang, ketika penjual melihat bahwa uang itu diblokir untuk sementara waktu pada alamat multisignature, yang tergantung padanya, ia dapat dengan aman mengirim monitor melalui pos. <br><br>  Selanjutnya, pembeli menerima parsel, memeriksa barang dan membuat keputusan tentang pembelian akhir.  Dia mungkin sepenuhnya setuju dengan layanan yang disediakan dan menandatangani transaksi dengan kuncinya, di mana dia mentransfer koin dari alamat multisignature kepada penjual, atau mungkin tidak puas dengan sesuatu.  Dalam kasus kedua, ia menghubungi mediator untuk menyusun transaksi alternatif, yang akan mendistribusikan koin-koin ini secara berbeda. <br><br>  Misalkan monitor tiba sedikit tergores dan tidak ada kabel untuk menghubungkan ke komputer dalam kit, meskipun itu tertulis di situs web toko online bahwa kabel harus dimasukkan dalam kit.  Kemudian pembeli mengumpulkan bukti yang diperlukan untuk membuktikan kepada mediator bahwa ia tertipu dalam situasi ini: ia mengambil screenshot situs tersebut, mengambil foto cek dari pos, mengambil foto goresan pada monitor dan menunjukkan bahwa segel rusak dan kabel ditarik keluar.  Toko online, pada gilirannya, mengumpulkan bukti dan menyerahkannya ke mediator. <br><br>  Mediator tertarik untuk memuaskan kemarahan pembeli dan kepentingan toko online (akan dipahami lebih lanjut mengapa).  Dia membuat transaksi seperti itu di mana koin dengan alamat multisignature akan dihabiskan dalam proporsi antara pembeli, toko online dan pick, karena dia mengambil bagian untuk dirinya sendiri sebagai hadiah untuk karyanya.  Misalkan 90% dari jumlah total masuk ke penjual, 5% ke mediator dan 5% kompensasi kepada pembeli.  Mediator menandatangani transaksi ini dengan kuncinya, tetapi belum dapat diterapkan, karena ini membutuhkan dua tanda tangan, tetapi hanya satu.  Dia mengirimkan transaksi seperti itu kepada pembeli dan penjual.  Jika setidaknya satu dari mereka puas dengan opsi pendistribusian koin ini, maka transaksi akan ditandatangani dan didistribusikan tambahan ke jaringan.  Untuk validasinya, cukup bagi salah satu peserta dalam transaksi untuk menyetujui opsi mediator. <br><br>  Dalam hal ini, penting untuk awalnya memilih mediator sehingga kedua peserta mempercayainya.  Dalam hal ini, ia akan bertindak terlepas dari kepentingan satu atau yang lain dan menilai situasi secara objektif.  Jika mediator tidak memberikan opsi seperti itu untuk distribusi koin yang akan memuaskan setidaknya satu peserta, maka, setelah sepakat bersama, pembeli dan toko online dapat meneruskan koin ke alamat multisignature baru, dengan menempatkan dua tanda tangan mereka.  Alamat multisignature baru akan dikompilasi dengan pick lain, yang, mungkin, akan lebih kompeten dalam masalah ini dan akan memberikan opsi yang lebih baik. <br><br><h3>  Contoh asrama dan lemari es </h3><br>  Mari kita lihat contoh yang lebih kompleks yang menampilkan kemampuan kontrak pintar secara lebih eksplisit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d9/d62/be0/4d9d62be0f11ea9938eb092ee279dd85.png" alt="gambar"><br><br>  Katakanlah ada tiga orang yang baru saja menetap di satu kamar asrama.  Mereka bertiga tertarik untuk membeli kulkas di kamar mereka, yang akan mereka bagikan.  Salah satu dari mereka secara sukarela mengumpulkan jumlah yang diperlukan untuk membeli kulkas dan bernegosiasi dengan penjual.  Namun, mereka relatif baru saja bertemu satu sama lain dan tidak ada cukup kepercayaan di antara mereka.  Jelas, dua dari mereka beresiko, memberikan uang kepada yang ketiga.  Selain itu, mereka perlu mencapai kesepakatan tentang pilihan penjual. <br><br>  Mereka dapat menggunakan layanan escrow, yaitu, memilih mediator yang akan memantau pelaksanaan transaksi dan menyelesaikan masalah yang disengketakan jika hal itu muncul.  Kemudian, setelah setuju, mereka membuat kontrak yang cerdas dan menentukan kondisi tertentu di dalamnya. <br><br>  Kondisi pertama adalah bahwa sebelum waktu tertentu, misalnya, dalam satu minggu, tiga pembayaran dari alamat tertentu untuk jumlah tertentu harus diterima pada akun yang sesuai dari kontrak pintar.  Jika ini tidak terjadi, kontrak pintar akan mengakhiri dan mengembalikan koin ke semua peserta.  Jika kondisi terpenuhi, maka nilai pengidentifikasi penjual dan mediator ditetapkan, dan kondisi bahwa semua peserta setuju dengan pilihan penjual dan mediator diperiksa.  Ketika semua persyaratan terpenuhi, maka dana akan ditransfer ke alamat yang ditentukan.  Pendekatan semacam itu dapat melindungi peserta dari penipuan di pihak mana pun dan umumnya menghilangkan kebutuhan untuk percaya. <br><br>  Kita melihat dalam contoh ini prinsip itu sendiri bahwa kesempatan seperti itu untuk langkah demi langkah menetapkan parameter untuk setiap kondisi yang harus dipenuhi memungkinkan menciptakan sistem kompleksitas dan kedalaman tingkat bersarang.  Selain itu, pertama Anda dapat menentukan kondisi pertama dalam kontrak pintar, dan hanya setelah selesai Anda sudah dapat mengatur parameter untuk kondisi berikutnya.  Dengan kata lain, secara formal, kondisi ditentukan, dan parameter untuk itu sudah dapat diatur selama operasinya. <br><br><h3>  Klasifikasi kontrak pintar </h3><br>  Untuk klasifikasi, Anda dapat menentukan kelompok kriteria yang berbeda.  Namun, pada saat pengembangan teknologi, empat di antaranya relevan. <br><br>  Kontrak pintar dapat dibedakan dengan lingkungan runtime yang dapat terpusat atau terdesentralisasi.  Dalam kasus desentralisasi, kami memiliki independensi dan toleransi kesalahan yang jauh lebih besar ketika melaksanakan kontrak pintar. <br><br>  Mereka juga dapat dibedakan dengan proses pengaturan dan memenuhi persyaratan: mereka dapat diprogram secara sewenang-wenang, terbatas, atau ditentukan sebelumnya, mis., Diketik dengan ketat.  Ketika pada platform kontrak pintar hanya ada 4 kontrak pintar tertentu, parameternya dapat diatur secara sewenang-wenang.  Dengan demikian, pengaturannya jauh lebih mudah: kami memilih kontrak dari daftar dan meneruskan parameter. <br><br>  Dengan metode inisiasi, ada kontrak pintar otomatis, yaitu, ketika kondisi tertentu terpenuhi, mereka memenuhi sendiri, dan ada kontrak seperti itu di mana persyaratan tersebut ditentukan, tetapi platform tidak secara otomatis memverifikasi pemenuhan mereka, untuk ini mereka perlu diinisiasi secara terpisah. <br><br>  Selain itu, kontrak pintar bervariasi dalam hal privasi.  Mereka dapat sepenuhnya terbuka, atau sebagian, atau sepenuhnya rahasia.  Yang terakhir berarti bahwa pengamat luar tidak melihat ketentuan kontrak pintar.  Namun, topik privasi sangat luas dan harus dipertimbangkan secara terpisah dari artikel saat ini. <br><br>  Di bawah ini kita akan membahas tiga kriteria pertama untuk memperjelas pemahaman tentang topik saat ini. <br><br><h3>  Kontrak cerdas runtime </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/64d/ffe/abc/64dffeabc36e80f36101529bd8cf1ff3.png" alt="gambar"><br><br>  Runtime membedakan antara platform kontrak pintar terpusat dan terdesentralisasi.  Dalam kasus kontrak digital terpusat, satu layanan digunakan, di mana hanya ada satu validator dan mungkin ada layanan cadangan dan pemulihan, yang juga dikelola secara terpusat.  Ada satu basis data yang menyimpan semua informasi yang diperlukan untuk menetapkan syarat-syarat kontrak pintar dan distribusi nilai yang diperhitungkan dalam basis data layanan ini.  Layanan terpusat semacam itu memiliki klien yang menetapkan persyaratan dengan permintaan tertentu dan menggunakan kontrak semacam itu.  Karena kenyataan bahwa platform terpusat, mekanisme otentikasi mungkin kurang dapat diandalkan dibandingkan dalam cryptocurrency. <br><br>  Sebagai contoh, Anda dapat mengambil penyedia seluler (operator seluler berbeda).  Misalkan operator tertentu melacak lalu lintas di servernya secara terpusat, yang dapat ditransmisikan dalam format yang berbeda, misalnya: dalam bentuk panggilan suara, SMS, lalu lintas Internet seluler, dan menurut berbagai standar, dan juga melacak dana pada saldo pengguna.  Dengan demikian, penyedia layanan seluler dapat menyusun kontrak untuk akuntansi untuk layanan yang diberikan dan pembayaran mereka dengan ketentuan yang berbeda.  Dalam hal ini, kondisi seperti "mengirim SMS dengan kode ini dan itu ke nomor ini dan itu dan Anda akan mendapatkan kondisi distribusi lalu lintas ini dan itu" dengan mudah ditetapkan. <br><br>  Satu contoh lagi dapat dikutip: bank tradisional dengan fungsi perbankan Internet canggih dan kontrak yang sangat sederhana seperti pembayaran reguler, konversi otomatis pembayaran yang masuk, pengurangan otomatis bunga pada rekening tertentu, dll. <br><br>  Jika kita berbicara tentang kontrak pintar dengan runtime terdesentralisasi, maka kita memiliki sekelompok validator.  Dalam kasus ideal, siapa pun dapat menjadi validator sama sekali.  Karena protokol sinkronisasi database dan pembangunan konsensus, kami memiliki beberapa database umum yang sekarang akan menyimpan semua transaksi dengan kontrak yang dijelaskan secara ketat, dan bukan beberapa permintaan bersyarat, format yang sering berubah, tetapi tidak ada spesifikasi terbuka.  Di sini, transaksi akan berisi instruksi tentang cara melaksanakan kontrak sesuai dengan spesifikasi yang ketat.  Spesifikasi ini terbuka dan, oleh karena itu, pengguna platform itu sendiri dapat mengaudit dan memvalidasi kontrak pintar.  Di sini kita melihat bahwa platform desentralisasi lebih unggul daripada yang terpusat dalam independensi dan toleransi kesalahan, tetapi desain dan pemeliharaannya jauh lebih rumit. <br><br><h3>  Kontrak cerdas tentang cara menetapkan dan memenuhi persyaratan </h3><br>  Sekarang kita akan menganalisis secara lebih rinci bagaimana kontrak yang cerdas dapat berbeda dalam cara mereka didefinisikan dan dipenuhi.  Di sini kita memperhatikan kontrak pintar, yang diprogram secara sewenang-wenang dan Turing-lengkap.  Kontrak pintar Turing-complete memungkinkan Anda untuk menentukan hampir semua algoritma sebagai syarat untuk memenuhi kontrak: siklus register, semacam fungsi perhitungan probabilitas, dan sejenisnya, hingga algoritma tanda tangan elektronik Anda sendiri.  Dalam hal ini, maksud kami ejaan logika yang benar-benar sewenang-wenang. <br><br>  Mereka juga memilih kontrak pintar yang sewenang-wenang, tetapi tidak lengkap menurut Turing.  Ini termasuk Bitcoin dan Litecoin dengan skrip mereka sendiri.  Ini berarti bahwa hanya mungkin untuk menggunakan operasi tertentu dalam urutan yang sewenang-wenang, tetapi tidak mungkin lagi untuk menulis loop dan algoritme khusus. <br><br>  Selain itu, ada platform kontrak pintar yang menerapkan kontrak pintar yang telah ditentukan sebelumnya.  Ini termasuk Bitshares dan Steemit.  Bitshares memiliki sejumlah kontrak pintar untuk berdagang, mengelola akun, mengelola platform itu sendiri, dan parameternya.  Steemit adalah platform yang serupa, tetapi tidak lagi berfokus pada menerbitkan token dan perdagangan seperti Bitshares, tetapi pada blogging, yaitu menyimpan dan memproses konten dengan cara yang terdesentralisasi. <br><br>  Kontrak penyelesaian-Turing sewenang-wenang termasuk platform Ethereum dan RootStock, yang masih dalam pengembangan.  Oleh karena itu, lebih jauh kita akan membahas lebih rinci tentang platform kontrak pintar Ethereum. <br><br><h3>  Kontrak pintar dengan metode inisiasi </h3><br>  Dengan metode inisiasi, kontrak pintar juga dapat dibagi menjadi setidaknya dua kelompok: otomatis dan manual (tidak otomatis).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah tipikal untuk yang otomatis yang dengan semua parameter yang diketahui dan permulaan kondisi, kontrak pintar dijalankan sepenuhnya secara otomatis, yaitu, tidak memerlukan pengiriman transaksi tambahan dan menghabiskan komisi tambahan untuk setiap eksekusi berikutnya. Platform itu sendiri memiliki semua data untuk menghitung bagaimana kontrak pintar akan berakhir. Logikanya tidak ada yang sewenang-wenang, tetapi sudah ditentukan sebelumnya, dan semua ini sudah bisa ditebak. Artinya, sebelumnya Anda dapat menilai kompleksitas kontrak pintar, menggunakan semacam komisi konstan untuknya, dan semua proses untuk implementasinya lebih efisien.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk kontrak pintar yang diprogram secara sewenang-wenang, eksekusi tidak otomatis. </font><font style="vertical-align: inherit;">Untuk memulai kontrak pintar semacam itu, praktis pada setiap langkah Anda perlu membuat transaksi baru yang akan memanggil tahap eksekusi berikutnya atau metode kontrak cerdas berikutnya, membayar komisi yang sesuai dan menunggu transaksi dikonfirmasi. </font><font style="vertical-align: inherit;">Eksekusi dapat diselesaikan dengan sukses atau tidak, karena kode kontrak pintar arbitrer dan beberapa momen yang tidak terduga dapat muncul, seperti siklus abadi, kurangnya beberapa parameter dan argumen, momen luar biasa yang tidak diolah, dll.</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akun Ethereum</font></font></b> </h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jenis Akun Ethereum </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita pertimbangkan seperti apa akun di platform Ethereum. Hanya ada dua jenis akun di sini dan tidak ada opsi lagi. Jenis pertama disebut akun pengguna, yang kedua adalah akun kontrak. Mari kita lihat perbedaannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akun pengguna hanya dikelola oleh kunci pribadi tanda tangan elektronik. Pemilik akun menghasilkan pasangan kunci untuk tanda tangan elektronik dengan algoritma ECDSA (Algoritma Tanda Tangan Digital Kurva Elliptic). Hanya transaksi yang ditandatangani oleh kunci ini yang dapat mengubah status akun ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada logika terpisah untuk akun kontrak pintar. </font><font style="vertical-align: inherit;">Ia dapat dikontrol hanya dengan bantuan kode program yang telah ditentukan yang sepenuhnya menentukan perilaku kontrak pintar: bagaimana ia akan mengelola koinnya dalam keadaan tertentu, atas prakarsa pengguna mana dan dalam kondisi apa koin-koin ini akan didistribusikan. </font><font style="vertical-align: inherit;">Jika beberapa poin tidak disediakan oleh pengembang dalam kode program, masalah mungkin timbul. </font><font style="vertical-align: inherit;">Misalnya, kontrak pintar dapat menerima beberapa keadaan tertentu di mana ia tidak menerima inisiasi untuk eksekusi lebih lanjut dari pengguna mana pun. </font><font style="vertical-align: inherit;">Dalam hal ini, koin akan benar-benar dibekukan, karena kontrak pintar tidak memberikan jalan keluar dari keadaan ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cara membuat akun di Ethereum </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam kasus akun pengguna, pemilik secara independen menghasilkan pasangan kunci melalui ECDSA. Penting untuk dicatat bahwa Ethereum menggunakan algoritma yang sama persis dan kurva eliptik yang sama persis seperti Bitcoin untuk tanda tangan elektronik, tetapi alamatnya dihitung dengan cara yang sedikit berbeda. Di sini, hasil hashing ganda tidak lagi diterapkan, seperti dalam Bitcoin, tetapi hashing satu kali oleh fungsi Keccak pada panjang 256 bit disediakan. Bit paling signifikan terputus dari nilai yang diterima, yaitu 160 bit paling signifikan dari nilai output dari fungsi hash. Akibatnya, kami mendapatkan alamat di Ethereum. Bahkan, dibutuhkan 20 byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa pengidentifikasi akun di Ethereum dikodekan dalam hex tanpa menggunakan checksum, tidak seperti Bitcoin dan banyak sistem lain di mana alamat dikodekan dalam sistem angka dasar 58 dengan penambahan sebuah checksum. Ini berarti bahwa Anda perlu bekerja dengan pengidentifikasi akun di Ethereum dengan hati-hati: bahkan satu kesalahan dalam pengidentifikasi dijamin menyebabkan hilangnya koin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada fitur penting dan terdiri dari fakta bahwa akun pengguna di tingkat basis data umum dibuat pada saat ia menerima pembayaran masuk pertama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada pendekatan yang sama sekali berbeda untuk membuat akun kontrak pintar. Awalnya, salah satu pengguna menulis kode sumber kontrak pintar, setelah itu kode tersebut melewati kompiler khusus untuk platform Ethereum, menerima kode byte untuk mesin virtual Ethereum. Bytecode yang diterima ditempatkan di bidang transaksi khusus. Itu diautentikasi atas nama akun pemrakarsa. Selanjutnya, transaksi ini didistribusikan melalui jaringan dan menjadi tuan rumah kode kontrak pintar. Komisi untuk transaksi dan, oleh karena itu, untuk pelaksanaan kontrak dihapus dari saldo akun pemrakarsa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap kontrak pintar harus mengandung konstruktor sendiri (dari kontrak ini). </font><font style="vertical-align: inherit;">Mungkin kosong, atau mungkin memiliki konten. </font><font style="vertical-align: inherit;">Setelah konstruktor dijalankan, pengidentifikasi akun kontrak pintar dibuat, yang dengannya Anda dapat mengirim koin, memanggil metode tertentu dari kontrak pintar, dll.</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur Transaksi Ethereum</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuatnya lebih jelas, kita akan mulai meninjau struktur transaksi Ethereum dan contoh kode kontrak pintar. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cf/562/c11/2cf562c11f33cc0ed594c935925a1fad.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transaksi Ethereum terdiri dari beberapa bidang. Yang pertama dari angka ini adalah nomor transaksi tertentu relatif terhadap akun itu sendiri, yang mendistribusikannya dan merupakan pembuatnya. Ini diperlukan untuk membedakan transaksi ganda, yaitu, untuk mengecualikan kasus ketika transaksi yang sama diterima dua kali. Melalui penggunaan pengenal, setiap transaksi memiliki nilai hash yang unik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini diikuti oleh ladang seperti </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harga gas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini adalah harga di mana mata uang dasar Ethereum dikonversi menjadi gas, yang membayar untuk pelaksanaan kontrak pintar dan alokasi sumber daya mesin virtual.</font></font> Apa artinya ini? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam Bitcoin, komisi dibayar langsung dengan mata uang dasar - Bitcoin itu sendiri. Ini dimungkinkan berkat mekanisme sederhana untuk menghitungnya: kami membayar dengan ketat jumlah data yang terkandung dalam transaksi. Dalam Ethereum, situasinya lebih rumit, karena sangat sulit untuk memulai dari jumlah data transaksi. Di sini, transaksi mungkin masih mengandung kode program yang akan dijalankan di mesin virtual, dan setiap operasi mesin virtual mungkin memiliki kompleksitas yang berbeda. Ada juga operasi yang mengalokasikan memori untuk variabel. Mereka akan memiliki kompleksitas sendiri, di mana pembayaran untuk setiap operasi akan bergantung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biaya setiap operasi setara gas akan konstan. Ini diperkenalkan secara khusus untuk menentukan biaya konstan dari setiap operasi. Bergantung pada beban di jaringan, harga gas akan berubah, yaitu, koefisien yang dengannya mata uang dasar akan dikonversi ke unit pelengkap ini untuk membayar komisi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada fitur lain dari transaksi di Ethereum: bytecode yang dikandungnya untuk dieksekusi di mesin virtual akan dieksekusi sampai selesai dengan beberapa hasil (kegagalan-sukses) atau sampai sejumlah koin yang dialokasikan untuk membayar komisi. Untuk menghindari situasi ketika dalam kasus kesalahan semua koin dihabiskan untuk komisi dari akun pengirim (misalnya, beberapa jenis siklus abadi diluncurkan di mesin virtual), bidang berikut ada - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai gas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sering disebut batas gas) - ia menentukan Jumlah maksimum koin yang ingin dihabiskan pengirim untuk transaksi tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang selanjutnya disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alamat tujuan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini termasuk alamat penerima koin atau alamat kontrak pintar tertentu, metode yang akan dipanggil. Setelah itu ikuti bidang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana jumlah koin yang dikirim ke alamat tujuan dimasukkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikutnya adalah bidang menarik yang disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang cocok dengan seluruh struktur. Ini bukan bidang yang terpisah, tetapi seluruh struktur di mana kode untuk mesin virtual didefinisikan. Anda dapat memasukkan data arbitrer di sini - ada aturan terpisah untuk ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan bidang terakhir disebut </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanda tangan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini secara bersamaan berisi tanda tangan elektronik dari penulis transaksi ini dan kunci publik yang dengannya tanda tangan ini akan diverifikasi. </font><font style="vertical-align: inherit;">Dari kunci publik, Anda bisa mendapatkan pengidentifikasi akun pengirim untuk transaksi ini, yaitu mengidentifikasi secara unik akun pengirim dalam sistem itu sendiri. </font><font style="vertical-align: inherit;">Berdasarkan struktur transaksi, kami menemukan hal utama.</font></font><br><br><h2> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh Kode Kontrak Cerdas untuk Soliditas</font></font></b> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang mari kita melihat lebih dekat pada kontrak pintar paling sederhana menggunakan contoh. </font></font><br><br><pre><code class="javascript hljs">contract Bank { address owner; mapping(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">address</span></span></span><span class="hljs-function"> =&gt;</span></span> uint) balances; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bank</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ owner = msg.sender; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deposit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payable</span></span></span><span class="hljs-function"> </span></span>{ balances[msg.sender] += msg.value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withdraw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint amount</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (balances[msg.sender] &gt;= amount) { balances[msg.sender] -= amount; msg.sender.transfer(amount); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMyBalance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> balances[msg.sender]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.sender == owner) selfdestruct(owner); } }</code> </pre> <br>  Di atas adalah kode sumber sederhana yang dapat menampung koin pengguna dan mengembalikannya sesuai permintaan. <br><br>  Jadi, ada kontrak pintar Bank yang melakukan fungsi-fungsi berikut: mengakumulasi koin pada saldo, yaitu, ketika transaksi dikonfirmasi dan kontrak pintar semacam itu ditempatkan, akun baru dibuat yang dapat mengandung koin pada saldo;  itu mengingat pengguna dan distribusi koin di antara mereka;  Ini memiliki beberapa metode untuk mengelola saldo, yaitu memungkinkan untuk mengisi kembali, menarik, dan memverifikasi saldo pengguna. <br><br>  Mari kita telusuri setiap baris kode sumber.  Ada bidang konstan dalam kontrak ini.  Salah satunya, dengan jenis alamat, disebut pemilik.  Di sini, kontrak mengingat alamat pengguna yang membuat kontrak pintar ini.  Lebih lanjut, ada struktur dinamis yang menjaga korespondensi antara alamat dan saldo pengguna. <br><br>  Setelah ini mengikuti metode Bank - itu disebut sama dengan kontrak.  Dengan demikian, ini adalah konstruktornya.  Di sini, variabel pemilik diberikan alamat orang yang memposting kontrak pintar ini di jaringan.  Ini adalah satu-satunya hal yang terjadi pada konstruktor ini.  Artinya, msg dalam hal ini adalah persis data yang ditransfer ke mesin virtual bersama dengan transaksi yang berisi semua kode untuk kontrak ini.  Karenanya, pengirim pesan adalah penulis dari transaksi ini, yang meng-host kode ini.  Dia akan menjadi pemilik kontrak pintar. <br><br>  Metode setoran memungkinkan transaksi untuk mentransfer sejumlah koin ke akun kontrak.  Dalam hal ini, kontrak pintar, menerima koin-koin ini, meninggalkannya di neraca, tetapi menulis ke struktur saldo siapa sebenarnya pengirim koin-koin ini untuk mengetahui siapa mereka. <br><br>  Metode selanjutnya disebut penarikan dan dibutuhkan satu parameter - jumlah koin yang ingin ditarik seseorang dari bank ini.  Berikut adalah cek untuk melihat apakah ada cukup banyak koin pada saldo pengguna yang memanggil metode ini untuk mengirimnya.  Jika jumlahnya cukup, maka kontrak pintar itu sendiri mengembalikan jumlah koin ini ke penelepon. <br><br>  Berikutnya adalah metode untuk memeriksa saldo pengguna saat ini.  Siapa pun yang memanggil metode ini akan digunakan untuk mendapatkan keseimbangan ini dalam kontrak pintar.  Perlu dicatat bahwa pengubah metode ini adalah tampilan.  Ini berarti bahwa metode itu sendiri tidak mengubah variabel kelasnya dengan cara apa pun dan pada kenyataannya itu hanya metode membaca.  Transaksi terpisah tidak dibuat untuk memanggil metode ini, tidak ada komisi yang dibayarkan, dan semua perhitungan dilakukan secara lokal, setelah itu pengguna menerima hasilnya. <br><br>  Metode pembunuhan diperlukan untuk menghancurkan status kontrak pintar.  Dan di sini cek tambahan ditulis apakah penelepon metode ini adalah pemilik kontrak ini.  Jika ya, maka kontraknya akan hancur sendiri, dan fungsi pemusnahan menerima satu parameter - pengenal akun, di mana kontrak akan mengirim semua koin yang tersisa pada saldo.  Dalam hal ini, koin yang tersisa akan secara otomatis pergi ke alamat pemegang kontrak. <br><br><h2>  <b>Bagaimana cara kerja simpul jaringan Ethereum penuh?</b> </h2><br>  Mari kita lihat secara skematis bagaimana kontrak pintar ini dijalankan pada platform Ethereum dan bagaimana simpul jaringan penuh bekerja. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/d25/63a/10bd2563a30d8284e5498e774e4abaf9.png" alt="gambar"><br><br>  Node jaringan Ethereum yang lengkap harus memiliki setidaknya empat modul. <br>  Yang pertama, seperti untuk protokol yang didesentralisasi, adalah modul jaringan P2P - modul untuk koneksi jaringan dan bekerja dengan node lain, di mana blok, transaksi, informasi tentang node lain dipertukarkan.  Ini adalah komponen tradisional untuk semua cryptocurrency terdesentralisasi. <br><br>  Lebih lanjut, kami memiliki modul untuk menyimpan data blockchain, memproses, memilih cabang prioritas, menambah blok, melepaskan blok, memeriksa blok-blok ini, dll. <br><br>  Modul ketiga disebut EVM (mesin virtual Ethereum) - ini adalah mesin virtual yang menerima kode byte dari transaksi Ethereum.  Modul ini mengambil status saat ini dari akun tertentu dan membuat perubahan pada statusnya berdasarkan kode byt yang diterima.  Versi mesin virtual pada setiap node jaringan harus sama.  Perhitungan pada masing-masing node Ethereum persis sama, tetapi mereka terjadi dalam urutan asinkron: seseorang memeriksa dan menerima transaksi ini sebelumnya, yaitu, mengeksekusi semua kode yang terkandung di dalamnya, dan seseorang kemudian.  Dengan demikian, ketika membuat transaksi, itu menyebar ke jaringan, node menerimanya dan pada saat verifikasi, seperti Bitcoin Script dieksekusi dalam Bitcoin, kode byte mesin virtual dieksekusi di sini. <br><br>  Transaksi dianggap diverifikasi jika semua kode yang terkandung di dalamnya dieksekusi, negara baru untuk akun tertentu dihasilkan dan disimpan sampai jelas apakah transaksi ini diterapkan atau tidak.  Jika transaksi diterapkan, maka keadaan ini dianggap tidak hanya selesai, tetapi sudah relevan.  Ada database yang menyimpan status setiap akun untuk setiap host.  Karena kenyataan bahwa semua perhitungan terjadi dengan cara yang sama dan keadaan blockchain adalah sama, maka database yang berisi status semua akun juga akan sama untuk setiap node. <br><br><h2>  <b>Mitos dan batasan kontrak pintar</b> </h2><br>  Adapun batasan yang ada untuk platform kontrak pintar seperti Ethereum, berikut ini dapat dikutip: <br><br><ul><li>  eksekusi kode; </li><li>  mengalokasikan memori; </li><li>  data blockchain; </li><li>  kirim pembayaran; </li><li>  buat kontrak baru; </li><li>  hubungi kontrak lainnya. </li></ul><br>  Mari kita lihat batasan yang diberlakukan pada mesin virtual, dan, dengan demikian, menghilangkan beberapa mitos tentang kontrak pintar.  Pada mesin virtual, yang tidak hanya di Ethereum, tetapi juga di platform serupa, Anda dapat melakukan operasi logis yang benar-benar sewenang-wenang, yaitu, menulis kode dan itu akan dieksekusi di sana, Anda juga dapat mengalokasikan memori.  Namun, komisi dibayarkan secara terpisah untuk setiap operasi dan untuk setiap unit memori tambahan yang dialokasikan. <br><br>  Selanjutnya, mesin virtual dapat membaca data dari database blockchain untuk menggunakan data ini sebagai pemicu untuk mengeksekusi satu atau lain logika kontrak pintar.  Mesin virtual dapat membuat dan mengirim transaksi, dapat membuat kontrak baru dan memanggil metode kontrak pintar lain yang sudah dipublikasikan di jaringan: ada, tersedia, dll. <br><br>  Mitos yang paling umum adalah bahwa kontrak pintar Ethereum dapat menggunakan informasi dari sumber daya Internet apa pun dalam kondisi mereka sendiri.  Yang benar adalah bahwa mesin virtual tidak dapat mengirim permintaan jaringan ke beberapa sumber informasi eksternal di Internet, yaitu, tidak mungkin untuk menulis kontrak pintar seperti itu yang akan mendistribusikan nilai antar pengguna tergantung pada seperti apa cuaca di jalan, atau yang menang dalam kejuaraan tertentu, atau berdasarkan pada apa yang terjadi di dunia luar, karena informasi tentang insiden-insiden ini sama sekali tidak ada dalam database platform itu sendiri.  Artinya, tidak ada yang ada di blockchain tentang ini.  Jika tidak muncul di sana, maka mesin virtual tidak dapat menggunakan data ini sebagai pemicu. <br><br><h2>  <b>Kerugian Ethereum</b> </h2><br>  Mari kita daftar yang utama.  Kelemahan pertama adalah bahwa ada beberapa kesulitan dalam merancang, mengembangkan dan menguji kontrak pintar di Ethereum (Ethereum menggunakan bahasa Solidity untuk menulis kontrak pintar).  Memang, praktik menunjukkan bahwa persentase yang sangat besar dari semua kesalahan milik faktor manusia.  Ini sebenarnya berlaku untuk kontrak pintar Ethereum yang telah ditulis, yang memiliki kompleksitas sedang atau lebih tinggi.  Jika untuk kontrak pintar sederhana probabilitas kesalahan kecil, maka dalam kontrak pintar kompleks sangat sering terjadi kesalahan yang mengarah pada pencurian dana, pembekuan mereka, ke penghancuran kontrak pintar dengan cara yang tidak terduga, dll. Banyak kasus seperti itu sudah diketahui. <br><br>  Kelemahan kedua adalah bahwa mesin virtual itu sendiri tidak sempurna, karena juga ditulis oleh orang-orang.  Itu dapat mengeksekusi perintah yang sewenang-wenang dan ini adalah kerentanan: sejumlah perintah dapat dikonfigurasi dengan cara tertentu, yang akan mengarah pada konsekuensi yang tidak terduga.  Ini adalah area yang sangat kompleks, tetapi sudah ada beberapa penelitian yang menunjukkan bahwa kerentanan ini ada dalam versi saat ini dari jaringan Ethereum dan mereka dapat menyebabkan kegagalan banyak kontrak pintar. <br><br>  Kesulitan besar lainnya, dapat dianggap sebagai kelemahan.  Itu terdiri dari fakta bahwa adalah mungkin dalam cara praktis atau teknis untuk sampai pada kesimpulan bahwa jika Anda mengkompilasi kode byte kontrak yang akan dieksekusi pada mesin virtual, Anda dapat menentukan beberapa urutan operasi tertentu.  Ketika dilakukan bersama-sama, operasi ini akan sangat memuat mesin virtual dan memperlambatnya secara tidak proporsional ke komisi yang dibayarkan untuk operasi ini. <br><br>  Di masa lalu, sudah ada periode pengembangan Ethereum, ketika banyak orang yang memahami secara rinci pengoperasian mesin virtual menemukan kerentanan tersebut.  Bahkan, transaksi membayar komisi yang sangat kecil, tetapi secara praktis memperlambat seluruh jaringan.  Masalah-masalah ini sangat sulit untuk dipecahkan, karena Anda perlu menentukannya, kedua, menyesuaikan harga untuk melakukan operasi ini dan, ketiga, melakukan garpu keras, yang berarti memperbarui semua node jaringan ke versi baru dari perangkat lunak, dan kemudian aktivasi simultan dari perubahan ini. <br><br>  Sedangkan untuk Ethereum, banyak penelitian telah dilakukan, banyak pengalaman praktis telah diperoleh: baik positif maupun negatif, namun demikian, masih ada kesulitan dan kerentanan yang masih harus diperjuangkan. <br><br>  Jadi, bagian tematik dari artikel selesai, kita beralih ke pertanyaan yang cukup sering muncul. <br><br><h2>  <b>Pertanyaan yang Sering Diajukan</b> </h2><br>  <i>- Jika semua pihak dalam kontrak pintar saat ini ingin mengubah ketentuan, dapatkah mereka membatalkan kontrak pintar ini dengan menggunakan multi-signature, dan kemudian membuat kontrak pintar baru dengan kondisi yang diperbarui untuk penerapannya?</i> <br><br>  Di sini jawabannya akan ada dua.  Mengapa  Karena, di satu sisi, kontrak pintar ditetapkan sekali dan itu tidak menyiratkan perubahan, dan di sisi lain, itu dapat memiliki logika yang telah ditetapkan yang menyediakan untuk perubahan lengkap atau sebagian dalam beberapa kondisi.  Artinya, jika Anda ingin mengubah sesuatu dalam kontrak pintar Anda, maka Anda harus menentukan kondisi di mana Anda dapat memperbarui kondisi ini.  Dengan demikian, hanya dengan cara yang bijaksana inilah pembaruan kontrak dapat diatur.  Tapi di sini, Anda juga bisa mendapat masalah: membuat kesalahan dan mendapatkan kerentanan yang sesuai.  Karena itu, hal-hal seperti itu perlu sangat rinci dan dirancang serta diuji secara menyeluruh. <br><br>  <i>- Dan jika mediator mengadakan konspirasi dengan salah satu pihak yang terlibat: escrow atau kontrak pintar?</i>  <i>Apakah mediator diperlukan dalam kontrak yang cerdas?</i> <br><br>  Seorang mediator tidak diperlukan dalam kontrak yang cerdas.  Mungkin tidak.  Jika dalam kasus escrow mediator mengadakan konspirasi dari salah satu pihak, maka ya, skema ini kemudian kehilangan semua nilainya secara tajam.  Karena itu, para mediator dipilih sedemikian rupa sehingga mereka dipercaya pada saat yang sama oleh semua pihak yang terlibat dalam proses ini.  Dengan demikian, Anda tidak akan mentransfer koin ke alamat multisignature dengan mediator yang tidak Anda percayai. <br><br>  <i>- Apakah mungkin untuk mentransfer banyak token yang berbeda dari satu alamat ke alamat target yang berbeda, misalnya alamat pertukaran, di mana token ini diperdagangkan dalam satu transaksi Ethereum?</i> <br><br>  Ini adalah pertanyaan yang bagus dan menyangkut model transaksi Ethereum dan perbedaannya dari model Bitcoin.  Dan perbedaannya dramatis.  Jika dalam model transaksi Ethereum Anda cukup mentransfer koin, maka koin hanya ditransfer dari satu alamat ke alamat lain, tanpa perubahan, hanya jumlah spesifik yang Anda tentukan.  Dengan kata lain, ini bukan model output yang tidak digunakan (UTXO), tetapi model akun dan saldo yang sesuai.  Secara teori dimungkinkan untuk mengirim beberapa token yang berbeda sekaligus dengan satu transaksi, jika Anda menulis kontrak pintar yang rumit, tetapi Anda masih harus melakukan banyak transaksi, membuat kontrak, lalu mentransfer token dan koin ke sana, dan kemudian memanggil metode yang sesuai.  Ini membutuhkan usaha dan waktu, masing-masing, dalam praktiknya itu tidak berfungsi seperti itu dan semua pembayaran dalam Ethereum dilakukan dalam transaksi terpisah. <br><br>  <i>- Salah satu mitos tentang platform Ethereum adalah bahwa tidak mungkin untuk menggambarkan kondisi yang akan tergantung pada data sumber daya Internet eksternal, lalu bagaimana?</i> <br><br>  Solusinya adalah bahwa kontrak pintar itu sendiri dapat mencakup satu atau lebih yang disebut oracle tepercaya yang mengumpulkan data tentang keadaan benda-benda di dunia luar dan mentransfernya ke kontrak pintar melalui metode khusus.  Kontrak itu sendiri menganggap data yang diterima dari pihak tepercaya itu benar.  Untuk keandalan yang lebih besar, mereka cukup memilih kelompok besar nubuat dan meminimalkan risiko kolusi.  Kontrak itu sendiri mungkin tidak memperhitungkan data akun dari nubuat yang bertentangan dengan mayoritas. <br><br>  Topik ini dibahas dalam salah satu kuliah kursus Blockchain online - â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Kontrak Cerdas</a> â€. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413231/">https://habr.com/ru/post/id413231/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413221/index.html">Bakteri bertahan hidup di "ruang bersih" selama perakitan pesawat ruang angkasa, memakan produk pembersih</a></li>
<li><a href="../id413223/index.html">Kamus Habra. Bagian 1</a></li>
<li><a href="../id413225/index.html">Security Week 20: serangan cyber nontrivial</a></li>
<li><a href="../id413227/index.html">Apa itu tuhan di bawah pakaian</a></li>
<li><a href="../id413229/index.html">Bangun Caffe di Google Colaboratory: Kartu Grafis Gratis di Awan</a></li>
<li><a href="../id413233/index.html">Layanan uLogin mengirimkan data dari formulir (surat, telepon) ke situs pihak ketiga dan tidak menghiraukannya</a></li>
<li><a href="../id413235/index.html">Bertaruh pada Prediksi yang Lebih Baik: Matematika Baru Prakiraan Cuaca</a></li>
<li><a href="../id413237/index.html">Facebook membantah produsen perangkat mengirimkan data yang sama dengan pengembang Alexander Kogan</a></li>
<li><a href="../id413239/index.html">Cara membuat smartphone sedikit bodoh</a></li>
<li><a href="../id413241/index.html">Mencegah fungsi dalam kernel Linux menggunakan ftrace</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>