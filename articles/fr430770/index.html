<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüéì üé∑ ‚òùüèΩ Sauvegarde pour Linux, ou comment cr√©er un instantan√© üö¨ üßîüèª üíπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Je travaille chez Veeam sur le projet Veeam Agent pour Linux. Avec ce produit, vous pouvez sauvegarder une machine Linux. ¬´Agent¬ª dans...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sauvegarde pour Linux, ou comment cr√©er un instantan√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/430770/">  Bonjour √† tous!  Je travaille chez Veeam sur le projet Veeam Agent pour Linux.  Avec ce produit, vous pouvez sauvegarder une machine Linux.  ¬´Agent¬ª dans le nom signifie que le programme vous permet de sauvegarder des machines physiques.  Virtualalkans sauvegarde √©galement, mais il se trouve sur le syst√®me d'exploitation invit√©. <br><br>  L'inspiration pour cet article a √©t√© mon rapport √† la conf√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Linux Piter</a> , que j'ai d√©cid√© de publier comme article pour tous les habragiteli int√©ress√©s. <br><br>  Dans l'article, je vais r√©v√©ler le sujet de la cr√©ation d'un instantan√© qui vous permet de sauvegarder et de parler des probl√®mes que nous avons rencontr√©s lors de la cr√©ation de notre propre m√©canisme pour cr√©er des instantan√©s de p√©riph√©riques de bloc. <br><br>  Tous les int√©ress√©s, demandez une coupe! <br><br><img src="https://habrastorage.org/webt/7w/qi/zh/7wqizhorjrpayiif7gin7adkisk.png"><br><a name="habracut"></a><br><h2>  Un peu de th√©orie au d√©but </h2><br>  Historiquement, il existe deux approches pour cr√©er des sauvegardes: la sauvegarde de fichiers et la sauvegarde de volumes.  Dans le premier cas, nous copions chaque fichier comme un objet s√©par√©, dans le second, nous copions le contenu entier du volume comme une sorte d'image. <br><br>  Les deux m√©thodes pr√©sentent de nombreux avantages et inconv√©nients, mais nous les consid√©rerons √† travers le prisme de la r√©cup√©ration apr√®s une d√©faillance: <br><br><ul><li>  Dans le cas de la sauvegarde de fichiers, pour r√©cup√©rer enti√®rement le serveur entier, nous devrons d'abord installer le syst√®me d'exploitation, puis les services n√©cessaires, puis seulement restaurer les fichiers √† partir de la sauvegarde. </li><li>  Dans le cas de la sauvegarde de volume, pour une r√©cup√©ration compl√®te, il suffit de restaurer simplement tous les volumes de la machine sans efforts inutiles de la part de la personne. </li></ul><br>  De toute √©vidence, dans le cas de la sauvegarde de volume, vous pouvez restaurer le syst√®me plus rapidement, et c'est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">caract√©ristique</a> importante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du syst√®me</a> .  Par cons√©quent, pour nous-m√™mes, nous consid√©rons la sauvegarde de volume comme l'option pr√©f√©r√©e. <br><br>  Comment prenons-nous et enregistrons-nous l'int√©gralit√© du volume?  Bien s√ªr, le simple fait de copier ne permettra rien de bon.  Pendant la copie, une certaine activit√© avec les donn√©es se produira sur le volume, par cons√©quent, les donn√©es incoh√©rentes appara√Ætront dans la sauvegarde.  La structure du syst√®me de fichiers sera viol√©e, les fichiers de base de donn√©es seront corrompus, ainsi que d'autres fichiers avec lesquels des op√©rations seront effectu√©es pendant la copie. <br><br>  Pour √©viter tous ces probl√®mes, l'humanit√© progressive a mis au point une technologie d'instantan√© - l'instantan√©.  En th√©orie, tout est simple: nous cr√©ons une copie inchang√©e - un instantan√© - et en sauvegardons les donn√©es.  Une fois la sauvegarde termin√©e, nous d√©truisons l'instantan√©.  Cela semble simple, mais, comme d'habitude, il y a des nuances. <br><br>  Gr√¢ce √† eux, de nombreuses impl√©mentations de cette technologie sont n√©es.  Par exemple, les solutions bas√©es sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mappeur de p√©riph√©riques</a> , telles que LVM et Thin Provisioning, fournissent des instantan√©s de volume complet, mais n√©cessitent une disposition de disque sp√©ciale au stade de l'installation du syst√®me, ce qui signifie qu'en g√©n√©ral, ils ne conviennent pas. <br><br>  BTRFS et ZFS permettent de cr√©er des instantan√©s de sous-structures de syst√®me de fichiers, ce qui est tr√®s cool, mais pour le moment leur part sur les serveurs est petite, et nous essayons de faire une solution universelle. <br><br>  Supposons qu'il y ait un EXT banal sur notre p√©riph√©rique de bloc.  Dans ce cas, nous pouvons utiliser <a href="">dm-snap</a> (soit dit en passant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dm-bow</a> est en cours de d√©veloppement), mais voici sa propre nuance.  Vous devez avoir un p√©riph√©rique de bloc gratuit pr√™t afin de pouvoir d√©poser les donn√©es d'instantan√©s o√π. <br>  En faisant attention aux solutions de sauvegarde alternatives, nous avons remarqu√© qu'en r√®gle g√©n√©rale, ils utilisent leur module de noyau pour cr√©er des instantan√©s des p√©riph√©riques de bloc.  Nous avons d√©cid√© de suivre cette voie en √©crivant notre module.  Il a √©t√© d√©cid√© de le distribuer sous licence GPL, afin qu'il soit accessible au public sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><br><h2>  Comment √ßa marche - en th√©orie </h2><br><h3>  Instantan√© du microscope </h3><br>  Nous allons donc maintenant examiner le principe g√©n√©ral de fonctionnement du module et nous attarder sur les questions cl√©s plus en d√©tail. <br><br>  En fait, veeamsnap (comme nous appelions notre module noyau) est un filtre de pilote de p√©riph√©rique de bloc. <br><br><img src="https://habrastorage.org/webt/gi/kg/ct/gikgctn2xian0bhuauiogpqqe5c.png"><br><br>  Son travail consiste √† intercepter les demandes d'un pilote de p√©riph√©rique de bloc. <br><br>  Apr√®s avoir intercept√© une demande d'√©criture, le module copie les donn√©es du p√©riph√©rique de bloc d'origine dans la zone de donn√©es de clich√©.  Nous appelons cette zone snapstore. <br><br><img src="https://habrastorage.org/webt/cl/hz/lt/clhzltlt564esinieyefu9gwqka.png"><br><br>  Et quel est l'instantan√© lui-m√™me?  Il s'agit d'un p√©riph√©rique de bloc virtuel, une copie du p√©riph√©rique d'origine √† un moment donn√©.  Lorsque vous acc√©dez √† des blocs de donn√©es sur cet appareil, ils peuvent √™tre lus soit √† partir du composant logiciel enfichable, soit √† partir de l'appareil d'origine. <br><br>  Je tiens √† noter que l'instantan√© est exactement le p√©riph√©rique de bloc qui est compl√®tement identique √† l'original au moment o√π l'instantan√© a √©t√© supprim√©.  Gr√¢ce √† cela, nous pouvons monter le syst√®me de fichiers sur un instantan√© et effectuer le pr√©traitement n√©cessaire. <br><br>  Par exemple, nous pouvons obtenir une carte des blocs occup√©s √† partir du syst√®me de fichiers.  La fa√ßon la plus simple de le faire est d'utiliser ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GETFSMAP</a> . <br>  Les donn√©es sur les blocs occup√©s vous permettent de lire uniquement les derni√®res donn√©es d'un instantan√©. <br><br>  Vous pouvez √©galement exclure certains fichiers.  Eh bien, une action compl√®tement facultative: indexez les fichiers qui tombent dans la sauvegarde, pour la possibilit√© d'un restaurant granulaire √† l'avenir. <br><br><h3>  CoW vs RoW </h3><br>  Arr√™tons-nous un peu sur le choix de l'algorithme d'instantan√©.  Le choix n'est pas tr√®s large ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Copier sur √©criture ou Rediriger sur √©criture</a> . <br><br>  La redirection sur √©criture lors de l'interception d'une demande d'√©criture la redirigera vers le composant logiciel enfichable, apr√®s quoi toutes les demandes de lecture de ce bloc y iront √©galement.  Un excellent algorithme pour les syst√®mes de stockage construits sur la base d'arbres B +, tels que BTRFS, ZFS et Thin Provisioning.  La technologie est aussi ancienne que le monde, mais elle se manifeste particuli√®rement bien dans les hyperviseurs, o√π vous pouvez cr√©er un nouveau fichier et y √©crire de nouveaux blocs pendant la dur√©e de l'instantan√©.  Les performances sont excellentes par rapport √† CoW.  Mais il y a un gros inconv√©nient - la structure du p√©riph√©rique d'origine change, et lors de la suppression de l'instantan√©, vous devez copier tous les blocs de l'instantan√© √† l'emplacement d'origine. <br><br>  La copie sur √©criture, lors de l'interception d'une demande, copie les donn√©es dans le magasin d'instantan√©s qui doivent subir une modification, apr√®s quoi elles peuvent √™tre √©cras√©es √† l'emplacement d'origine.  Utilis√© pour cr√©er des instantan√©s pour les volumes LVM et les clich√©s instantan√©s de VSS.  De toute √©vidence, il est plus appropri√© pour cr√©er des instantan√©s de p√©riph√©riques de bloc, car  ne modifie pas la structure du p√©riph√©rique d'origine et lorsque vous supprimez (ou plantez) l'instantan√© peut simplement √™tre supprim√© sans risquer de perdre des donn√©es.  L'inconv√©nient de cette approche est la d√©gradation des performances, car deux op√©rations de lecture / √©criture sont ajout√©es √† chaque op√©ration d'√©criture. <br><br>  La s√©curit√© des donn√©es √©tant notre priorit√© absolue, nous nous sommes concentr√©s sur CoW. <br><br>  Jusqu'√† pr√©sent, tout semble simple, alors passons en revue les probl√®mes de la vie r√©elle. <br><br><h2>  Comment √ßa marche - en pratique </h2><br><h3>  Condition coh√©rente </h3><br>  Pour lui, tout a √©t√© con√ßu. <br>  Par exemple, si au moment de cr√©er un instantan√© (dans une premi√®re approximation, nous pouvons supposer qu'il est cr√©√© instantan√©ment) un enregistrement sera enregistr√© dans un fichier, puis dans un instantan√© le fichier sera incomplet, ce qui signifie qu'il sera endommag√© et vide de sens.  La situation est similaire avec les fichiers de base de donn√©es et le syst√®me de fichiers lui-m√™me. <br><br>  Mais nous vivons au 21e si√®cle!  Il existe des m√©canismes de journalisation qui prot√®gent contre de tels probl√®mes!  Certes, la v√©rit√© est qu'il y a un ¬´mais¬ª important: cette protection n'est pas contre l'√©chec, mais contre ses cons√©quences.  Lors de la restauration dans un √©tat coh√©rent selon le journal, les op√©rations incompl√®tes seront ignor√©es, ce qui signifie qu'elles seront perdues.  Par cons√©quent, il est important de d√©placer la priorit√© vers la protection contre la cause, plut√¥t que de traiter les cons√©quences. <br><br>  Le syst√®me peut √™tre averti qu'un instantan√© sera d√©sormais cr√©√©.  Pour cela, le noyau a les fonctions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">freeze_bdev</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thaw_bdev</a> .  Ils tirent les fonctions du syst√®me de fichiers freeze_fs et unfreeze_fs.  Lorsque vous appelez le premier, le syst√®me doit r√©initialiser le cache, suspendre la cr√©ation de nouvelles demandes sur le p√©riph√©rique de bloc et attendre la fin de toutes les demandes g√©n√©r√©es pr√©c√©demment.  Et lorsque unfreeze_fs est appel√©, le syst√®me de fichiers r√©tablit son fonctionnement normal. <br><br>  Il s'av√®re que nous pouvons avertir le syst√®me de fichiers.  Et les applications?  Ici, malheureusement, tout va mal.  Alors que sous Windows, il existe un m√©canisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VSS</a> qui, avec l'aide de Writers, fournit une interaction avec d'autres produits, sous Linux, chacun suit sa propre voie.  Pour le moment, cela a conduit √† la situation que la t√¢che de l'administrateur syst√®me d'√©crire (copier, <s>voler</s> , acheter, etc.) pr√©-geler et post-d√©congeler les scripts par eux-m√™mes, ce qui pr√©parera leur application pour l'instantan√©.  Pour notre part, dans la prochaine version, nous introduirons la prise en charge d'Oracle Application Processing, la fonctionnalit√© la plus fr√©quemment demand√©e par nos clients.  Ensuite, d'autres applications peuvent √™tre prises en charge, mais dans l'ensemble, la situation est plut√¥t triste. <br><br><h3>  O√π placer le composant logiciel enfichable? </h3><br>  Il s'agit du deuxi√®me probl√®me qui nous g√™ne.  √Ä premi√®re vue, le probl√®me n'est pas √©vident, mais apr√®s un peu de compr√©hension, on constate qu'il s'agit toujours d'un √©clat. <br><br>  Bien s√ªr, la solution la plus simple consiste √† placer le composant logiciel enfichable dans la RAM.  Pour le d√©veloppeur, l'option est tout simplement g√©niale!  Tout est rapide, tr√®s pratique pour faire le d√©bogage, mais il y a un montant: la RAM est une ressource pr√©cieuse, et personne ne nous donnera un gros coup l√†-bas. <br><br>  OK, faisons de snap-file un fichier normal.  Mais un autre probl√®me se pose: vous ne pouvez pas sauvegarder le volume sur lequel se trouve le snapstop.  La raison est simple: nous interceptons les demandes d'enregistrement, ce qui signifie que nous intercepterons nos propres demandes d'enregistrement dans le composant logiciel enfichable.  Les chevaux ont couru de mani√®re scientifique - impasse.  Ensuite, il y a un d√©sir aigu d'utiliser un disque s√©par√© pour cela, mais personne n'ajoutera de disques √† notre serveur pour notre bien.  Vous devez √™tre capable de travailler sur ce qui est. <br><br>  Positionner √† distance le composant logiciel enfichable est une excellente id√©e, mais il peut √™tre mis en ≈ìuvre dans des cercles tr√®s √©troits de r√©seaux √† large bande passante et √† latence microscopique.  Sinon, tout en maintenant l'instantan√© sur la machine, il y aura une strat√©gie au tour par tour. <br><br>  Donc, vous devez en quelque sorte placer d√©licatement le composant logiciel enfichable sur le disque local.  Mais, en r√®gle g√©n√©rale, tout l'espace sur les disques locaux est d√©j√† r√©parti entre les syst√®mes de fichiers, et en m√™me temps, vous devez r√©fl√©chir s√©rieusement √† la mani√®re de contourner le probl√®me de blocage. <br><br>  La direction de la r√©flexion est en principe une: vous devez en quelque sorte allouer de l'espace dans le syst√®me de fichiers, mais travailler directement avec le p√©riph√©rique de bloc.  La solution √† ce probl√®me a √©t√© impl√©ment√©e dans le code de l'espace utilisateur, dans le service. <br><br>  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">appel</a> syst√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fallocate</a> qui vous permet de cr√©er un fichier vide de la taille souhait√©e.  Cependant, en fait, seules les m√©tadonn√©es sont cr√©√©es sur le syst√®me de fichiers qui d√©crit l'emplacement du fichier sur le volume.  Et ioctl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FIEMAP</a> nous permet d'obtenir une carte de l'emplacement des blocs de fichiers. <br><br>  Et le tour est jou√©: nous cr√©ons un fichier sous snap en utilisant fallocate, FIEMAP nous donne une carte de l'emplacement des blocs de ce fichier, que nous pouvons transf√©rer pour travailler dans notre module veeamsnap.  De plus, lors de l'acc√®s au snapstor, le module fait des requ√™tes directement au p√©riph√©rique de bloc dans des blocs connus de nous, et pas de blocages. <br><br>  Mais il y a une nuance.  L'appel syst√®me fallocate n'est pris en charge que par XFS, EXT4 et BTRFS.  Pour d'autres syst√®mes de fichiers comme EXT3, vous devez l'√©crire compl√®tement pour allouer le fichier.  La fonctionnalit√© est affect√©e par une augmentation du temps de pr√©paration des snappads, mais il n'y a pas de choix.  Encore une fois, vous devez √™tre capable de travailler sur ce qui est. <br><br>  Que faire si ioctl FIEMAP n'est pas non plus pris en charge?  C'est la r√©alit√© de NTFS et FAT32, o√π il n'y a m√™me pas de support pour l'ancien FIBMAP.  J'ai d√ª impl√©menter un certain algorithme g√©n√©rique, dont le fonctionnement ne d√©pend pas des fonctionnalit√©s du syst√®me de fichiers.  En un mot, l'algorithme est: <br><br><ol><li>  Le service cr√©e un fichier et commence √† y √©crire un mod√®le sp√©cifique. </li><li>  Le module intercepte les demandes d'√©criture, v√©rifie les donn√©es en cours d'√©criture. </li><li>  Si les donn√©es du bloc correspondent au mod√®le donn√©, le bloc est marqu√© comme appartenant au snapstop. </li></ol><br>  Oui, difficile, oui, lentement, mais mieux que rien.  Il est utilis√© dans de rares cas pour les syst√®mes de fichiers sans prise en charge FIEMAP et FIBMAP. <br><br><h3>  D√©bordement d'instantan√© </h3><br>  Au contraire, l'endroit que nous avons attribu√© sous le snapstore se termine.  L'essence du probl√®me est qu'il n'y a nulle part o√π jeter de nouvelles donn√©es, ce qui signifie que l'instantan√© devient inutilisable. <br>  Que faire <br><br>  De toute √©vidence, vous devez augmenter la taille des vivaneaux.  Combien?  Le moyen le plus simple de d√©finir la taille des snappants est de d√©terminer le pourcentage d'espace libre sur le volume (comme pour VSS).  Pour un volume de 20 To, 10% sera de 2 To - ce qui est beaucoup pour un serveur non charg√©.  Pour un volume de 200 Go, 10% correspond √† 20 Go, ce qui peut √™tre trop peu pour un serveur qui met √† jour intensivement ses donn√©es.  Et il y a encore des volumes minces ... <br><br>  En g√©n√©ral, seul l'administrateur syst√®me du serveur peut d√©terminer √† l'avance la taille optimale du composant logiciel enfichable requis, c'est-√†-dire que vous devez faire r√©fl√©chir la personne et donner son avis d'expert.  Cela ne respecte pas le principe ¬´√ßa marche juste¬ª. <br><br>  Pour r√©soudre ce probl√®me, nous avons d√©velopp√© l'algorithme d'√©tirement instantan√©.  L'id√©e est de casser le composant logiciel enfichable en portions.  Dans le m√™me temps, de nouvelles portions sont cr√©√©es apr√®s la cr√©ation d'un instantan√© si n√©cessaire. <br><br><img src="https://habrastorage.org/webt/7l/wi/72/7lwi72wjiwrmq9-jms-tartz6go.png"><br><br>  Encore une fois, bri√®vement l'algorithme: <br><br><ol><li>  Avant de cr√©er un instantan√©, la premi√®re partie de l'instantan√© est cr√©√©e et donn√©e au module. </li><li>  Lorsque l'instantan√© est cr√©√©, la partie commence √† se remplir. </li><li>  D√®s que la moiti√© de la portion est pleine, une demande est envoy√©e au service pour en cr√©er une nouvelle. </li><li>  Le service le cr√©e, donne les donn√©es au module. </li><li>  Le module commence √† remplir le lot suivant. </li><li>  L'algorithme est r√©p√©t√© jusqu'√† ce que la sauvegarde soit termin√©e, ou jusqu'√† ce que nous rencontrions la limite d'utilisation de l'espace disque libre. </li></ol><br>  Il est important de noter que le module doit avoir le temps de cr√©er de nouvelles portions de snapposts selon les besoins, sinon - d√©bordement, r√©initialisation des snapshots et aucune sauvegarde.  Par cons√©quent, le fonctionnement d'un tel algorithme n'est possible que sur les syst√®mes de fichiers avec prise en charge fallocate, o√π vous pouvez rapidement cr√©er un fichier vide. <br><br>  Que faire dans les autres cas?  Nous essayons de deviner la taille requise et de cr√©er enti√®rement le snappast.  Mais selon nos statistiques, la grande majorit√© des serveurs Linux utilisent d√©sormais EXT4 et XFS.  EXT3 se trouve sur les anciennes machines.  Mais dans SLES / openSUSE, vous pouvez tomber sur BTRFS. <br><br><h3>  Modifier le suivi des blocs (CBT) </h3><br>  Sauvegarde incr√©mentielle ou diff√©rentielle (au fait, le raifort au radis est plus doux ou non, je sugg√®re de le lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ) - sans lui, vous ne pouvez pas imaginer de produit de sauvegarde pour adulte.  Et pour que cela fonctionne, vous avez besoin de CBT.  Si quelqu'un a manqu√©: CBT vous permet de suivre les modifications et d'√©crire dans la sauvegarde uniquement les donn√©es modifi√©es depuis la derni√®re sauvegarde. <br><br><img src="https://habrastorage.org/webt/fk/mf/z0/fkmfz0-pa9lbjdktlu2yovstkuk.png"><br><br>  Beaucoup ont leur propre exp√©rience dans ce domaine.  Par exemple, dans VMware vSphere, cette fonctionnalit√© est disponible depuis la version 4 en 2009.  Dans Hyper-V, la prise en charge a √©t√© introduite avec Windows Server 2016 et pour prendre en charge les versions ant√©rieures, son propre pilote VeeamFCT a √©t√© d√©velopp√© en 2012.  Par cons√©quent, pour notre module, nous ne sommes pas devenus originaux et avons utilis√© des algorithmes d√©j√† fonctionnels. <br>  √Ä propos de son fonctionnement. <br><br><img src="https://habrastorage.org/webt/hs/fn/vj/hsfnvjyzfywjynwynlh9jkibaug.png"><br><br>  L'ensemble du volume suivi est divis√© en blocs.  Le module garde simplement une trace de toutes les demandes d'√©criture, marquant les blocs modifi√©s dans le tableau.  En fait, la table CBT est un tableau d'octets, o√π chaque octet correspond √† un bloc et contient le num√©ro de l'instantan√© dans lequel il a √©t√© modifi√©. <br>  Pendant la sauvegarde, le num√©ro de l'instantan√© est enregistr√© dans les m√©tadonn√©es de sauvegarde.  Ainsi, en connaissant les num√©ros de l'instantan√© actuel et celui √† partir duquel la sauvegarde r√©ussie pr√©c√©dente a √©t√© effectu√©e, vous pouvez calculer la carte de l'emplacement des blocs modifi√©s. <br><br>  Il y a deux nuances. <br><br>  Comme je l'ai dit, un octet est allou√© pour le num√©ro d'instantan√© dans la table CBT, ce qui signifie que la longueur maximale de la cha√Æne incr√©mentielle ne peut pas d√©passer 255. Lorsque ce seuil est atteint, la table est r√©initialis√©e et une sauvegarde compl√®te se produit.  Cela peut sembler g√™nant, mais en fait, une cha√Æne de 255 incr√©ments est loin d'√™tre la meilleure solution lors de la cr√©ation d'un plan de sauvegarde. <br>  La deuxi√®me caract√©ristique est le stockage de la table CBT uniquement dans la RAM.  Ainsi, lorsque vous red√©marrez la machine cible ou d√©chargez le module, il sera r√©initialis√©, et encore une fois, vous devrez cr√©er une sauvegarde compl√®te.  Une telle solution permet de ne pas r√©soudre le probl√®me de d√©marrage du module au d√©marrage du syst√®me.  De plus, il n'est pas n√©cessaire d'enregistrer les tables CBT lorsque vous √©teignez le syst√®me. <br><br><h3>  Probl√®me de performance </h3><br>  La sauvegarde est toujours une si bonne charge sur les E / S de votre √©quipement.  S'il y a d√©j√† suffisamment de t√¢ches actives dessus, le processus de sauvegarde peut transformer votre syst√®me en une sorte de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paresse</a> . <br>  Voyons pourquoi. <br><br>  Imaginez que le serveur √©crit simplement de fa√ßon lin√©aire certaines donn√©es.  La vitesse d'enregistrement dans ce cas est maximale, tous les retards sont minimis√©s, les performances tendent au maximum.  Maintenant, nous ajoutons ici le processus de sauvegarde, qui √† chaque √©criture doit encore terminer l'algorithme de copie sur √©criture, et il s'agit d'une op√©ration de lecture suppl√©mentaire avec l'√©criture suivante.  Et n'oubliez pas que pour la sauvegarde, vous devez toujours lire les donn√©es du m√™me volume.  En un mot, votre bel acc√®s lin√©aire se transforme en un acc√®s al√©atoire sans merci avec toutes les cons√©quences. <br><br>  Nous devons √©videmment faire quelque chose avec cela, et nous avons mis en place un pipeline pour traiter les demandes non pas une √† la fois, mais en paquets entiers.  Cela fonctionne comme √ßa. <br><br><img src="https://habrastorage.org/webt/br/js/pz/brjspz1fvl7yjtk_hqc_hyupb1a.png"><br><br>  Lors de l'interception de demandes, elles sont plac√©es dans une file d'attente, o√π un flux sp√©cial les prend en portions.  √Ä ce stade, des demandes CoW sont cr√©√©es, qui sont √©galement trait√©es par lots.  Lors du traitement des demandes de CoW, toutes les op√©rations de lecture sont d'abord effectu√©es pour toute la partie, apr√®s quoi les op√©rations d'√©criture sont effectu√©es.  Ce n'est qu'apr√®s la fin du traitement de la totalit√© de la demande de CoW que les demandes intercept√©es sont ex√©cut√©es.  Un tel convoyeur permet d'acc√©der au disque en gros morceaux de donn√©es, ce qui minimise les pertes de temps. <br><br><h3>  √âtranglement </h3><br>  D√©j√† au stade du d√©bogage, une autre nuance est apparue.  Pendant la sauvegarde, le syst√®me ne r√©pond plus, c'est-√†-dire  les demandes d'E / S du syst√®me ont commenc√© √† s'ex√©cuter avec de longs d√©lais.  Mais, les demandes de lecture de donn√©es √† partir d'un instantan√© ont √©t√© effectu√©es √† une vitesse proche du maximum. <br>  J'ai d√ª √©trangler un peu le processus de sauvegarde en impl√©mentant le m√©canisme de limitation.  Pour ce faire, la lecture du processus √† partir de l'image instantan√©e est mise en attente si la file d'attente des requ√™tes intercept√©es n'est pas vide.  De mani√®re attendue, le syst√®me a pris vie. <br><br><img src="https://habrastorage.org/webt/6c/f1/cj/6cf1cjerzumb96qaeslvikyobpo.png"><br><br>  Par cons√©quent, si la charge sur le syst√®me d'E / S augmente fortement, le processus de lecture √† partir de l'instantan√© attendra.  Ici, nous avons d√©cid√© d'√™tre guid√©s par le principe selon lequel il est pr√©f√©rable de terminer la sauvegarde avec une erreur plut√¥t que de perturber le serveur. <br><br><h3>  Impasse </h3><br>  Je pense que nous devons expliquer plus en d√©tail ce que c'est. <br><br>  D√©j√† au stade des tests, nous avons commenc√© √† rencontrer des situations de blocage complet du syst√®me avec un diagnostic de sept probl√®mes - une r√©initialisation. <br><br>  Ils ont commenc√© √† comprendre.  Il s'est av√©r√© que cette situation peut √™tre observ√©e si, par exemple, vous cr√©ez un instantan√© du p√©riph√©rique de bloc sur lequel se trouve le volume LVM et placez l'instantan√© sur le m√™me volume LVM.  Permettez-moi de vous rappeler que LVM utilise le module noyau du mappeur de p√©riph√©riques. <br><br><img src="https://habrastorage.org/webt/xs/n7/ac/xsn7ac1peh0sefyanlbk_2yrvb8.png"><br><br>  Dans cette situation, lors de l'interception d'une demande d'√©criture, le module, en copiant les donn√©es dans le composant logiciel enfichable, enverra la demande d'√©criture au volume LVM.  Le mappeur de p√©riph√©rique redirigera cette demande vers le p√©riph√©rique de blocage.  Une demande du mappeur de p√©riph√©rique sera √† nouveau intercept√©e par le module.  Mais une nouvelle demande ne peut pas √™tre trait√©e tant que la pr√©c√©dente n'a pas √©t√© trait√©e.  En cons√©quence, le traitement des demandes est bloqu√©, vous √™tes accueilli par un blocage. <br><br>  Pour √©viter cette situation, le module du noyau lui-m√™me fournit un d√©lai d'expiration pour l'op√©ration de copie des donn√©es dans le composant logiciel enfichable.  Cela vous permet de d√©tecter un blocage et une sauvegarde sur incident.  La logique ici est la m√™me: il vaut mieux ne pas sauvegarder que suspendre le serveur. <br><br><h3>  Base de donn√©es Round Robin </h3><br>  C'est d√©j√† un probl√®me pos√© par les utilisateurs apr√®s la sortie de la premi√®re version. <br>  Il s'est av√©r√© qu'il existe de tels services qui sont uniquement engag√©s dans l'√©crasement constant des m√™mes blocs.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple frappant est celui des services de surveillance, qui g√©n√®rent constamment des donn√©es sur l'√©tat du syst√®me et les √©crasent en cercle. </font><font style="vertical-align: inherit;">Pour ces t√¢ches, utilisez des bases de donn√©es cycliques sp√©cialis√©es ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'est av√©r√© qu'avec une sauvegarde de telles bases, l'instantan√© est garanti de d√©border. </font><font style="vertical-align: inherit;">Dans une √©tude d√©taill√©e du probl√®me, nous avons trouv√© une faille dans la mise en ≈ìuvre de l'algorithme CoW. </font><font style="vertical-align: inherit;">Si le m√™me bloc a √©t√© remplac√©, les donn√©es ont √©t√© copi√©es √† chaque fois dans le composant logiciel enfichable. </font><font style="vertical-align: inherit;">R√©sultat: duplication des donn√©es dans le snap. </font></font><br><br><img src="https://habrastorage.org/webt/tk/vf/ox/tkvfox_gygmf4gxh0cz_igw_jzw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturellement, nous avons chang√© l'algorithme. </font><font style="vertical-align: inherit;">Le volume est maintenant divis√© en blocs et les donn√©es sont copi√©es dans le bloc d'accrochage. </font><font style="vertical-align: inherit;">Si le bloc a d√©j√† √©t√© copi√© une fois, ce processus n'est pas r√©p√©t√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S√©lection de la taille des blocs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque le snapstrap est divis√© en blocs, la question se pose: quelle est en fait la taille des blocs √† faire pour casser les snappoints? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me est double. Si le bloc est grand, il est plus facile pour eux de fonctionner, mais si au moins un secteur change, vous devez envoyer le bloc entier √† la plate-forme et, par cons√©quent, les chances de trop remplir la plate-forme sont augment√©es. </font></font><br><br><img src="https://habrastorage.org/webt/dk/fy/a_/dkfya_bevzkd5mx10_pnkbxbajm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De toute √©vidence, plus la taille du bloc est petite, plus le pourcentage de donn√©es utiles envoy√©es au snapstore est √©lev√©, mais comment affectera-t-il les performances? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ils ont recherch√© la v√©rit√© empiriquement et ont trouv√© 16 Ko. Notez √©galement que Windows VSS utilise √©galement 16 blocs de Kio.</font></font><br><br><h2>  Au lieu d'une conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est tout pour l'instant. </font><font style="vertical-align: inherit;">Je laisserai bien d'autres probl√®mes non moins int√©ressants, tels que la d√©pendance aux versions du noyau, le choix des options de distribution des modules, la compatibilit√© kABI, le travail dans les conditions de backport, etc. </font><font style="vertical-align: inherit;">L'article s'est av√©r√© volumineux et j'ai donc d√©cid√© de m'attarder sur les probl√®mes les plus int√©ressants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pr√©parons maintenant la version 3.0, le code du module est sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et n'importe qui peut l'utiliser sous la licence GPL.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430770/">https://habr.com/ru/post/fr430770/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430754/index.html">Ajoutez de la profondeur aux sprites 2D en utilisant des cartes normales dessin√©es √† la main</a></li>
<li><a href="../fr430756/index.html">Fabrication de la souris WX dans le Nova Slider 600</a></li>
<li><a href="../fr430762/index.html">Comment choisir un onduleur pour optimiser les co√ªts</a></li>
<li><a href="../fr430766/index.html">Il s'agit d'Agile 1: Mythes de l'agenda populaire</a></li>
<li><a href="../fr430768/index.html">Entretien avec le cr√©ateur d'ADOM Thomas Biscap</a></li>
<li><a href="../fr430774/index.html">√ätes-vous pr√™t pour l'IA sur les panneaux d'affichage?</a></li>
<li><a href="../fr430776/index.html">Faire une IP est le seul moyen</a></li>
<li><a href="../fr430778/index.html">Processus de conception de syst√®mes √©lectriques de bout en bout 3DEXPERIENCE</a></li>
<li><a href="../fr430780/index.html">Mod√®les de s√©quence √† s√©quence, partie 1</a></li>
<li><a href="../fr430782/index.html">De combien de programmeurs avez-vous besoin pour prendre en charge du code pr√©c√©demment √©crit?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>