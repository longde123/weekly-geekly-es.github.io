<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🔬 👉🏽 🌪️ Menulis shader di Unity. GrabPass, PerRendererData 💅🏼 🛸 🛢️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Saya ingin berbagi pengalaman saya menulis shader di Unity. Mari kita mulai dengan shader Displacement / Refraction dalam 2D, pertimbangkan fungsi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menulis shader di Unity. GrabPass, PerRendererData</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427357/">  Hai  Saya ingin berbagi pengalaman saya menulis shader di Unity.  Mari kita mulai dengan shader Displacement / Refraction dalam 2D, pertimbangkan fungsionalitas yang digunakan untuk menulisnya (GrabPass, PerRendererData), dan perhatikan juga masalah yang akan muncul. <br><br>  Informasi ini berguna bagi mereka yang memiliki gagasan umum tentang shader dan mencoba membuatnya, tetapi tidak terbiasa dengan kemampuan yang disediakan Unity, dan tidak tahu sisi mana yang harus didekati.  Coba lihat, mungkin pengalaman saya akan membantu Anda mengetahuinya. <br><br><img src="https://habrastorage.org/webt/7p/cy/pr/7pcyprnckvacvecylqvlu-8g68m.gif"><br><a name="habracut"></a><br>  Inilah hasil yang ingin kita capai. <br><br><img src="https://habrastorage.org/webt/u5/wo/ll/u5woll2fo6nibjmd0lrgvszxvxk.gif" alt="gambar"><br><br><h2>  Persiapan </h2><br>  Pertama, buat shader yang hanya akan menggambar sprite yang ditentukan.  Dia akan menjadi dasar kita untuk manipulasi lebih lanjut.  Sesuatu akan ditambahkan ke dalamnya, sesuatu yang sebaliknya akan dihapus.  Ini akan berbeda dari standar "Sprite-Default" dengan tidak adanya beberapa tag dan tindakan yang tidak akan mempengaruhi hasil. <br><br><div class="spoiler">  <b class="spoiler_title">Kode shader untuk rendering sprite</b> <div class="spoiler_text"><pre><code class="hljs pgsql">Shader "Displacement/Displacement_Wave" { Properties { [PerRendererData] _MainTex ("Main Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color ("Color" , Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Tags { "RenderType" = "Transparent" "Queue" = "Transparent" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; fixed4 _Color; sampler2D _MainTex; v2f vert (appdata v) { v2f o; o.uv = v.uv; o.color = v.color; o.vertex = UnityObjectToClipPos(v.vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { fixed4 texColor = tex2D(_MainTex, i.uv)*i.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texColor; } ENDCG } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Sprite untuk ditampilkan</b> <div class="spoiler_text">  Latar belakang sebenarnya transparan, sengaja digelapkan. <br><br><img src="https://habrastorage.org/webt/7l/yu/in/7lyuingedtk8frmquebh2m0kgdy.jpeg" alt="gambar"><br></div></div><br>  Benda kerja yang dihasilkan. <br><br><img src="https://habrastorage.org/webt/yl/ir/9i/ylir9i7bz4ibkkbhag61q8v95ak.jpeg" alt="gambar"><br><br><h2>  Grabpass </h2><br>  Sekarang tugas kita adalah membuat perubahan pada gambar saat ini di layar, dan untuk ini kita perlu mendapatkan gambar.  Dan bagian <i>GrabPass</i> akan membantu kita dengan ini.  Bagian ini akan menangkap gambar layar dalam tekstur <i>_GrabTexture</i> .  Tekstur hanya akan berisi apa yang digambar sebelum objek kita menggunakan shader ini akan ditampilkan. <br><br>  Selain tekstur itu sendiri, kita perlu koordinat pemindaian untuk mendapatkan warna piksel darinya.  Untuk melakukan ini, tambahkan koordinat tekstur tambahan ke data shader fragmen.  Koordinat ini tidak dinormalisasi (nilai tidak berada dalam kisaran 0 hingga 1) dan menggambarkan posisi titik dalam ruang kamera (proyeksi). <br><br><pre> <code class="hljs pgsql">struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; float2 uv : <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; <span class="hljs-type"><span class="hljs-type">float4</span></span> grabPos : TEXCOORD1; };</code> </pre> <br>  Dan di vertex shader mengisinya. <br><br><pre> <code class="hljs">o.grabPos = ComputeGrabScreenPos (o.vertex);</code> </pre> <br>  Untuk mendapatkan warna dari <i>_GrabTexture</i> , kita dapat menggunakan metode berikut jika kita menggunakan koordinat yang tidak dinormalisasi <br><br><pre> <code class="hljs lisp">tex2Dproj(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos)</code> </pre> <br>  Tetapi kami akan menggunakan metode yang berbeda dan menormalkan koordinat kami sendiri, menggunakan pembagian perspektif, mis.  membagi semua yang lain menjadi komponen-w. <br><br><pre> <code class="hljs lisp">tex2D(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos.xy/i.grabPos.w)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">komponen w</b> <div class="spoiler_text">  Pembagian menjadi komponen-w hanya diperlukan ketika menggunakan perspektif, dalam proyeksi ortografi, itu akan selalu menjadi 1. Bahkan, <b>w</b> menyimpan nilai jarak, arahkan ke kamera.  Tapi itu bukan kedalaman - <b>z</b> , nilainya harus berkisar antara 0 hingga 1. Bekerja dengan kedalaman layak untuk topik yang terpisah, jadi kami akan kembali ke shader kami. </div></div><br>  Pembagian perspektif juga dapat dilakukan dalam vertex shader, dan data yang sudah disiapkan dapat ditransfer ke fragmen shader. <br><br><pre> <code class="hljs mel">v2f vert (appdata v) { v2f o; o.uv = v.uv; o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = v.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; o.vertex = UnityObjectToClipPos(v.vertex); o.grabPos = ComputeScreenPos (o.vertex); o.grabPos /= o.grabPos.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; }</code> </pre> <br>  Tambahkan fragmen shader, masing-masing. <br><br><pre> <code class="hljs matlab">fixed4 frag (v2f <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) : SV_Target { fixed4 = grabColor = tex2d(_GrabTexture, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.grabPos.xy); fixed4 texColor = tex2D(_MainTex, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.uv)*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grabColor; }</code> </pre> <br>  Matikan mode pencampuran yang ditentukan, karena  sekarang kami menerapkan blending mode kami di dalam fragmen shader. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Blend SrcAlpha OneMinusSrcAlpha Blend Off</span></span></code> </pre><br>  Dan lihat hasil <i>GrabPass</i> . <br><br><img src="https://habrastorage.org/webt/mh/ex/b_/mhexb_lek_zyrgsto6p0ki4rmoi.jpeg" alt="gambar"><br><br>  Sepertinya tidak ada yang terjadi, tetapi tidak.  Untuk kejelasan, kami memperkenalkan sedikit perubahan, untuk ini kami akan menambahkan nilai variabel ke koordinat tekstur.  Agar kita dapat memodifikasi variabel, tambahkan properti <i>_DisplacementPower</i> baru. <br><br><pre> <code class="hljs powershell">Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Main Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Color"</span></span> , Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _DisplacementPower (<span class="hljs-string"><span class="hljs-string">"Displacement Power"</span></span> , Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Pass { ... float _DisplacementPower; ... } }</code> </pre> <br>  Dan lagi, buat perubahan pada shader fragmen. <br><br><pre> <code class="hljs lisp">fixed4 grabColor = tex2d(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos.xy + _DisplaccementPower)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Op hop dan hasil!  Gambar dengan bergeser. <br><br><img src="https://habrastorage.org/webt/ky/yl/9w/kyyl9w51dqeap4_wvxws1nod4fg.jpeg"><br><br>  Setelah perubahan berhasil, Anda dapat melanjutkan ke distorsi yang lebih kompleks.  Kami menggunakan tekstur yang disiapkan sebelumnya yang akan menyimpan gaya perpindahan pada titik yang ditentukan.  Warna merah untuk nilai offset pada sumbu x, dan hijau pada sumbu y. <br><br><div class="spoiler">  <b class="spoiler_title">Tekstur digunakan untuk distorsi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0f/fu/-e/0ffu-ezmyhr9lb3qofn9d99ese8.png"><br><img src="https://habrastorage.org/webt/ld/mf/no/ldmfnoicn2b7e7cmsbpeml716hs.png"><br></div></div><br>  Mari kita mulai.  Tambahkan properti baru untuk menyimpan tekstur. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">_DisplacementTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Displacement Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {}</code> </pre> <br>  Dan sebuah variabel. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _DisplacementTex;</code> </pre> <br>  Dalam fragmen shader kita mendapatkan nilai offset dari tekstur dan menambahkannya ke koordinat tekstur. <br><br><pre> <code class="hljs lisp">fixed4 displPos = tex2D(<span class="hljs-name"><span class="hljs-name">_DisplacementTex</span></span>, i.uv)<span class="hljs-comment"><span class="hljs-comment">; float2 offset = (displPos.xy*2 - 1) * _DisplacementPower * displPos.a; fixed4 grabColor = tex2D (_GrabTexture, i.grabPos.xy + offset);</span></span></code> </pre><br>  Sekarang, mengubah nilai-nilai parameter <i>_DisplacementPower</i> , kita tidak hanya menggeser gambar asli, tetapi mendistorsi itu. <br><br><img src="https://habrastorage.org/webt/tu/pu/w3/tupuw3jqxaztn2jl19mdyhtvzwi.gif"><br><br><h3>  Hamparan </h3><br>  Sekarang di layar hanya ada distorsi ruang, dan sprite, yang kami tunjukkan di awal, tidak ada.  Kembalikan ke tempatnya.  Untuk melakukan ini, kita akan menggunakan campuran warna yang sulit.  Ambil sesuatu yang lain, seperti blending mode overlay.  Formulanya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/wd/qr/z7/wdqrz7rv0skaotpofwwu4owvyxy.jpeg"><br><br>  di mana S adalah gambar asli, C adalah korektif, yaitu, sprite kami, R adalah hasilnya. <br><br>  Transfer formula ini ke shader kami. <br><br><pre> <code class="hljs mel">fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>*texColor : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(<span class="hljs-number"><span class="hljs-number">1</span></span>-texColor)*(<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>);</code> </pre><br>  Penggunaan operator bersyarat dalam shader adalah topik yang agak membingungkan.  Banyak hal tergantung pada platform dan grafik API yang digunakan.  Dalam beberapa kasus, pernyataan bersyarat tidak akan mempengaruhi kinerja.  Tapi selalu layak untuk mundur.  Operator bersyarat dapat diganti menggunakan matematika dan metode yang tersedia.  Kami menggunakan konstruksi berikut <br><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = step ( y, x); r = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> * a + (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) * b;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Fungsi langkah</b> <div class="spoiler_text">  Fungsi langkah akan mengembalikan 1 jika <b>x</b> lebih besar dari atau sama dengan <b>y</b> .  Dan 0 jika <b>x</b> kurang dari <b>y</b> . <br><br>  Misalnya, jika <b>x</b> = 1, dan <b>y</b> = 0,5, maka hasil <b>c</b> akan menjadi 1. Dan ekspresi berikut akan terlihat seperti <br>  r = 1 * a + 0 * b <br>  Karena  mengalikan dengan 0 memberi 0, maka hasilnya akan menjadi nilai <b>a</b> . <br>  Kalau tidak, jika <b>c</b> adalah 0, <br>  r = 0 * a + 1 * b <br>  Dan hasil akhirnya adalah <b>b</b> . <br></div></div><br>  Tulis ulang warna untuk mode <i>overlay</i> . <br><br><pre> <code class="hljs mel">fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>));</code> </pre> <br>  Pastikan untuk mempertimbangkan transparansi sprite.  Untuk melakukan ini, kita akan menggunakan interpolasi linier antara dua warna. <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a);</code> </pre> <br>  Kode shader fragmen penuh. <br><br><pre> <code class="hljs mel">fixed4 frag (v2f i) : SV_Target { fixed4 displPos = tex2D(_DisplacementTex, i.uv); float2 offset = (displPos.xy*<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; fixed4 texColor = tex2D(_MainTex, i.uv + offset)*i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = tex2D (_GrabTexture, i.grabPos.xy + offset); fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  Dan hasil dari pekerjaan kami. <br><br><img src="https://habrastorage.org/webt/ea/au/xy/eaauxypqmxxrbcjrkl4swnctjeg.gif"><br><br><h3>  Fitur GrabPass </h3><br>  Disebutkan di atas bahwa pass <i>GrabPass {}</i> menangkap konten layar menjadi tekstur <i>_GrabTexture</i> .  Pada saat yang sama, setiap kali bagian ini dipanggil, isi tekstur akan diperbarui. <br>  Pembaruan konstan dapat dihindari dengan menentukan nama tekstur di mana konten layar akan ditangkap. <br><pre> <code class="hljs objectivec">GrabPass{<span class="hljs-string"><span class="hljs-string">"_DisplacementGrabTexture"</span></span>}</code> </pre> <br>  Sekarang konten dari tekstur akan diperbarui hanya pada panggilan pertama dari pass GrabPass per frame.  Ini menghemat sumber daya jika ada <i>banyak</i> objek menggunakan <i>GrabPass {}</i> .  Tetapi jika dua objek tumpang tindih, maka artefak akan terlihat, karena kedua objek akan menggunakan gambar yang sama. <br><br>  Menggunakan GrabPass {"_ DisplacementGrabTexture"}. <br><br><img src="https://habrastorage.org/webt/9n/uv/n9/9nuvn9st0v_t9l7rwxspbmy8iww.jpeg"><br><br>  Menggunakan GrabPass {}. <br><br><img src="https://habrastorage.org/webt/sl/ai/4a/slai4akjk0suyfp43gptuyp3pfw.jpeg"><br><br><h2>  Animasi </h2><br>  Sekarang saatnya untuk menghidupkan efek kita.  Kami ingin mengurangi kekuatan distorsi saat gelombang ledakan tumbuh, mensimulasikan kepunahannya.  Untuk melakukan ini, kita perlu mengubah properti material. <br><br><div class="spoiler">  <b class="spoiler_title">Script untuk animasi</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _elapsedTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SpriteRenderer _renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Duration; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve ScaleProgress; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ScalePower; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve PropertyProgress; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PropertyPower; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve AlphaProgress; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _renderer = GetComponent&lt;SpriteRenderer&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _elapsedTime = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elapsedTime &lt; Duration) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> progress = _elapsedTime / Duration; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scale = ScaleProgress.Evaluate(progress) * ScalePower; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property = PropertyProgress.Evaluate(progress) * PropertyPower; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alpha = AlphaProgress.Evaluate(progress); transform.localScale = scale; _renderer.material.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = _renderer.color; color.a = alpha; _renderer.color = color; _elapsedTime += Time.deltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elapsedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Dan pengaturannya</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cs/sm/9f/cssm9fqvoequsovfl8wlff72rxu.jpeg"><br></div></div><br>  Hasil dari animasi. <br><br><img src="https://habrastorage.org/webt/5j/sm/ic/5jsmicvf7jepmp-adecch-jlwb8.gif"><br><br><h2>  Perrendererdata </h2><br>  Perhatikan garis di bawah ini. <br><br><pre> <code class="cs hljs">_renderer.material.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property);</code> </pre> <br>  Di sini kita tidak hanya mengubah salah satu sifat material, tetapi membuat salinan materi sumber (hanya pada panggilan pertama dari metode ini) dan sudah bekerja dengannya.  Ini adalah opsi yang cukup berhasil, tetapi jika ada lebih dari satu objek di panggung, misalnya, seribu, maka membuat banyak salinan tidak akan menghasilkan sesuatu yang baik.  Ada opsi yang lebih baik - ini adalah menggunakan atribut <i>[PerRendererData]</i> dalam shader, dan objek <i>MaterialPropertyBlock</i> dalam skrip. <br><br>  Untuk melakukan ini, tambahkan atribut ke properti <i>_DisplacementPower</i> di shader. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplacementPower</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Displacement Power"</span></span> , Range(-.<span class="hljs-number"><span class="hljs-number">1</span></span>,.<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Setelah itu, properti tidak akan lagi ditampilkan di inspektur, karena  Sekarang adalah individual untuk setiap objek, yang akan mengatur nilai. <br><br><img src="https://habrastorage.org/webt/ni/g4/zu/nig4zujdlflr1xjm_ry-cwulane.jpeg"><br><br>  Kami kembali ke skrip dan mengubahnya. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MaterialPropertyBlock _propertyBlock; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _renderer = GetComponent&lt;SpriteRenderer&gt;(); _propertyBlock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialPropertyBlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//_renderer.material.SetFloat("_DisplacementPower", property); _renderer.GetPropertyBlock(_propertyBlock); _propertyBlock.SetFloat("_DisplacementPower", property); _renderer.SetPropertyBlock(_propertyBlock); ... }</span></span></code> </pre> <br>  Sekarang, untuk mengubah properti, kami akan memperbarui <i>MaterialPropertyBlock</i> objek kami tanpa membuat salinan materi. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang SpriteRenderer</b> <div class="spoiler_text">  Mari kita lihat baris ini di shader. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Main Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {}</code> </pre> <br>  <i>SpriteRenderer bekerja</i> serupa dengan sprite.  Ini menetapkan properti <i>_MainTex</i> ke nilainya menggunakan <i>MaterialPropertyBlock</i> .  Oleh karena itu, di inspektur, properti <i>_MainTex</i> tidak ditampilkan untuk materi, dan dalam komponen <i>SpriteRenderer</i> kami menentukan tekstur yang kami butuhkan.  Pada saat yang sama, ada banyak sprite yang berbeda di atas panggung, tetapi hanya satu materi yang akan digunakan untuk rendering mereka (jika Anda tidak mengubahnya sendiri). <br></div></div><br><h3>  Fitur PerRendererData </h3><br>  Anda bisa mendapatkan <i>MaterialPropertyBlock</i> dari hampir semua komponen yang terkait dengan render.  Misalnya, <i>SpriteRenderer</i> , <i>ParticleRenderer</i> , <i>MeshRenderer</i> , dan komponen <i>Renderer</i> lainnya.  Tapi selalu ada pengecualian, ini adalah <i>CanvasRenderer</i> .  Tidak mungkin untuk mendapatkan dan mengubah properti menggunakan metode ini.  Oleh karena itu, jika Anda menulis game 2D menggunakan komponen UI, Anda akan menghadapi masalah ini saat menulis shader. <br><br><h2>  Rotasi </h2><br>  Efek tidak menyenangkan terjadi ketika gambar diputar.  Pada contoh gelombang bulat, ini terutama terlihat. <br><br>  Gelombang yang tepat saat berputar (90 derajat) memberikan distorsi lain. <br><br><img src="https://habrastorage.org/webt/ns/gy/2e/nsgy2effgwcv8d0kavaltwd2ofi.jpeg"><br><br>  Merah menunjukkan vektor yang diperoleh dari titik yang sama dalam tekstur, tetapi dengan rotasi tekstur yang berbeda.  Nilai offset tetap sama dan tidak memperhitungkan rotasi. <br><br>  Untuk mengatasi masalah ini, kita akan menggunakan <i>matriks</i> transformasi <i>unity_ObjectToWorld</i> .  Ini akan membantu menghitung ulang vektor kami dari koordinat lokal ke koordinat dunia. <br><br><pre> <code class="hljs pgsql">float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = (displPos.xy*<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = mul( unity_ObjectToWorld, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>);</code> </pre> <br>  Tetapi matriks juga berisi data tentang skala objek, jadi ketika menunjukkan kekuatan distorsi, kita harus memperhitungkan skala objek itu sendiri. <br><br><pre> <code class="cs hljs">_propertyBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property/transform.localScale.x);</code> </pre> <br>  Gelombang kanan juga diputar 90 derajat, tetapi distorsi sekarang dihitung dengan benar. <br><br><img src="https://habrastorage.org/webt/g4/hc/gu/g4hcguat4nxvgm0b2jyylrqvlze.jpeg"><br><br><h2>  Klip </h2><br>  Tekstur kami memiliki piksel transparan yang cukup (terutama jika kami menggunakan jenis Mesh <i>persegi</i> ).  Shader memprosesnya, yang dalam hal ini tidak masuk akal.  Karena itu, kami akan mencoba mengurangi jumlah perhitungan yang tidak perlu.  Kami dapat mengganggu pemrosesan piksel transparan menggunakan metode <i>klip (x)</i> .  Jika parameter yang diteruskan ke kurang dari nol, maka shader akan berakhir.  Tetapi karena nilai alfa tidak boleh kurang dari 0, kami akan mengurangi nilai kecil darinya.  Itu juga dapat dimasukkan ke dalam properti ( <i>Potongan</i> ) dan digunakan untuk memotong bagian transparan dari gambar.  Dalam hal ini, kita tidak perlu parameter terpisah, jadi kita hanya akan menggunakan angka <b>0,01</b> . <br><br>  Kode shader fragmen penuh. <br><br><pre> <code class="hljs mel">fixed4 frag (v2f i) : SV_Target { fixed4 displPos = tex2D(_DisplacementTex, i.uv); float2 offset = (displPos.xy * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; offset = mul( unity_ObjectToWorld,offset); fixed4 texColor = tex2D(_MainTex, i.uv + offset)*i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">clip</span></span>(texColor.a - <span class="hljs-number"><span class="hljs-number">0.01</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = tex2D (_GrabTexture, i.grabPos.xy + offset); fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  PS: Kode sumber untuk shader dan skrip adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke git</a> .  Proyek ini juga memiliki generator tekstur kecil untuk distorsi.  Kristal dengan alas diambil dari aset - 2D Game Kit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427357/">https://habr.com/ru/post/id427357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427347/index.html">Bermigrasi ke Google Cloud Platform (Google Cloud Platform - GCP)</a></li>
<li><a href="../id427349/index.html">Programmer untuk keluarga tinyAVR baru berdasarkan konverter CH340 Cina yang murah</a></li>
<li><a href="../id427351/index.html">Security Week 40: Kerentanan dalam CMS Drupal dan Lainnya</a></li>
<li><a href="../id427353/index.html">Drone menunjukkan: bagaimana kita mengoordinasikan sekelompok penari menari</a></li>
<li><a href="../id427355/index.html">Kompilasi CJM, keterampilan art director utama dan pemahaman pengguna</a></li>
<li><a href="../id427359/index.html">Bagaimana ECS, Sistem Pekerjaan C #, dan Arsitektur Ubah SRP</a></li>
<li><a href="../id427361/index.html">Fitur pemfilteran jendela pada FPGA</a></li>
<li><a href="../id427363/index.html">Implementasi LoRaWAN di perusahaan pertanian. Segala sesuatu tentang konstruksi, peluncuran, dan solusi</a></li>
<li><a href="../id427365/index.html">Laporan dari RedSlerm tentang pemantauan (Monit, Zabbix)</a></li>
<li><a href="../id427367/index.html">Konferensi BLACK HAT USA. Bagaimana seorang hacker Hollywood menggunakan kamera pengintai. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>