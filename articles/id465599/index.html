<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😸 👨🏽‍⚕️ 👩🏿‍🤝‍👩🏼 IPFS tanpa rasa sakit (tapi itu tidak akurat) 🛶 🎄 ◾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terlepas dari kenyataan bahwa di Habré sudah tidak ada satu artikel tentang IPFS . 

 Saya akan segera mengklarifikasi bahwa saya bukan ahli dalam bid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IPFS tanpa rasa sakit (tapi itu tidak akurat)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465599/"><img src="https://habrastorage.org/webt/wi/od/vh/wiodvhs9bp_gm6uff-4kp8ly0ni.jpeg"><br><br>  Terlepas dari kenyataan bahwa di Habré sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak ada satu artikel tentang IPFS</a> . <br><br>  Saya akan segera mengklarifikasi bahwa saya bukan ahli dalam bidang ini, tetapi saya telah menunjukkan minat pada teknologi ini lebih dari sekali, tetapi mencoba untuk bermain dengannya sering kali menimbulkan rasa sakit.  Hari ini saya kembali melakukan percobaan dan mendapatkan beberapa hasil yang ingin saya bagikan.  Singkatnya, proses menginstal IPFS dan beberapa chip akan dijelaskan (semuanya dilakukan di ubuntu, pada platform lain saya tidak mencoba). <br><a name="habracut"></a><br>  <i>Jika Anda melewatkan apa itu IPFS, ada tertulis dalam beberapa detail di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/314768</a></i> <br><br><h2>  Instalasi </h2><br>  <i>Untuk kemurnian percobaan, saya mengusulkan untuk segera menginstalnya di beberapa server eksternal, karena kami akan mempertimbangkan beberapa jebakan dengan bekerja dalam mode lokal dan jarak jauh.</i>  <i>Maka, jika diinginkan, tidak akan dibongkar dalam waktu lama, tidak banyak.</i> <br><br><h3>  Pergi </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> <br>  Lihat versi saat ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang.org/dl</a> <br><br>  <i>Catatan: lebih baik untuk menginstal IPFS atas nama pengguna, yang seharusnya menggunakan yang paling sering.</i>  <i>Faktanya adalah bahwa di bawah ini kami akan mempertimbangkan opsi pemasangan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FUSE</a> dan ada kehalusan di sana.</i> <br><br><pre><code class="plaintext hljs">cd ~ curl -O https://dl.google.com/go/go1.12.9.linux-amd64.tar.gz tar xvf go1.12.9.linux-amd64.tar.gz sudo chown -R root:root ./go sudo mv go /usr/local rm go1.12.9.linux-amd64.tar.gz</code> </pre> <br>  Maka Anda perlu memperbarui lingkungan (lebih detail di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golang.org/doc/code.html#GOPATH</a> ). <br><br><pre> <code class="plaintext hljs">echo 'export GOPATH=$HOME/work' &gt;&gt; ~/.bashrc echo 'export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin' &gt;&gt; ~/.bashrc source ~/.bashrc</code> </pre><br>  Pastikan go sudah diinstal <br><br><pre> <code class="plaintext hljs">go version</code> </pre> <br><h3>  Instal IPFS </h3><br>  Saya suka cara menginstal melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipfs-update paling banyak</a> . <br><br>  Instal dengan perintah <br><br><pre> <code class="plaintext hljs">go get -v -u github.com/ipfs/ipfs-update</code> </pre><br>  Setelah itu, Anda dapat menjalankan perintah berikut: <br><br>  <b>versi pembaruan ipfs</b> - untuk melihat semua versi yang tersedia untuk diunduh. <br>  <b>ipfs-update version</b> - untuk melihat versi terinstal saat ini (sampai kita memiliki IPFS diinstal, itu tidak akan ada). <br>  <b>instal pembaruan ipfs terbaru</b> - instal versi terbaru IPFS.  Alih-alih terbaru, masing-masing, Anda dapat menentukan versi yang diinginkan dari daftar yang tersedia. <br><br>  Instal ipfs <br><br><pre> <code class="plaintext hljs">ipfs-update install latest</code> </pre><br>  Periksa <br><br><pre> <code class="plaintext hljs">ipfs --version</code> </pre> <br>  Langsung dengan instalasi secara umum, semuanya. <br><br><h2>  Peluncuran IPFS </h2><br><h3>  Inisialisasi </h3><br>  Pertama, Anda perlu melakukan inisialisasi. <br><br><pre> <code class="plaintext hljs">ipfs init</code> </pre> <br>  Sebagai tanggapan, Anda akan mendapatkan sesuatu seperti ini: <br><br><pre> <code class="plaintext hljs"> ipfs init initializing IPFS node at /home/USERNAME/.ipfs generating 2048-bit RSA keypair...done peer identity: QmeCWX1DD7HnXXXXXXXXXXXXXXXXXXXXXXXXxxx to get started, enter: ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre><br>  Anda dapat menjalankan perintah yang diusulkan <br><br><pre> <code class="plaintext hljs">ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Hasil</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Hello and Welcome to IPFS! ██╗██████╗ ███████╗███████╗ ██║██╔══██╗██╔════╝██╔════╝ ██║██████╔╝█████╗ ███████╗ ██║██╔═══╝ ██╔══╝ ╚════██║ ██║██║ ██║ ███████║ ╚═╝╚═╝ ╚═╝ ╚══════╝ If you're seeing this, you have successfully installed IPFS and are now interfacing with the ipfs merkledag! ------------------------------------------------------- | Warning: | | This is alpha software. Use at your own discretion! | | Much is missing or lacking polish. There are bugs. | | Not yet secure. Read the security notes for more. | ------------------------------------------------------- Check out some of the other files in this directory: ./about ./help ./quick-start &lt;-- usage examples ./readme &lt;-- this file ./security-notes</code> </pre><br></div></div><br>  Di sini, menurut saya, yang menarik sudah mulai.  Pada tahap instalasi, para pria sudah mulai menggunakan teknologi mereka sendiri.  Hash QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv yang diusulkan - tidak dibuat khusus untuk Anda, tetapi dijahit ke dalam rilis.  Artinya, sebelum rilis, mereka menyiapkan teks sambutan, menuangkannya ke IPFS dan menambahkan alamat ke installer.  Menurut saya, ini sangat keren.  Dan file ini (lebih tepatnya, seluruh folder) sekarang dapat dilihat tidak hanya secara lokal, tetapi juga pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipfs.io/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv</a> gateway resmi.  Pada saat yang sama, Anda dapat yakin bahwa isi folder tidak berubah dengan cara apa pun, karena jika sudah berubah, maka hash juga akan berubah. <br><br>  <i>Omong-omong, dalam hal ini, IPFS memiliki beberapa kesamaan dengan server kontrol versi.</i>  <i>Jika Anda membuat perubahan pada file sumber folder dan lagi menuangkan folder ke IPFS, maka itu akan menerima alamat baru.</i>  <i>Pada saat yang sama, folder lama tidak akan pergi ke mana pun seperti itu dan akan tersedia di alamat sebelumnya.</i> <br><br><h3>  Peluncuran langsung </h3><br><pre> <code class="plaintext hljs">ipfs daemon</code> </pre> <br>  Mereka harus mendapat respons seperti ini: <br><br><pre> <code class="plaintext hljs">ipfs daemon Initializing daemon... go-ipfs version: 0.4.22- Repo version: 7 System version: amd64/linux Golang version: go1.12.7 Swarm listening on /ip4/xxxx/tcp/4001 Swarm listening on /ip4/127.0.0.1/tcp/4001 Swarm listening on /ip6/::1/tcp/4001 Swarm listening on /p2p-circuit Swarm announcing /ip4/127.0.0.1/tcp/4001 Swarm announcing /ip6/::1/tcp/4001 API server listening on /ip4/127.0.0.1/tcp/5001 WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080 Daemon is ready</code> </pre><br><h4>  Kami membuka pintu ke Internet </h4><br>  Perhatikan dua baris ini: <br><br><pre> <code class="plaintext hljs">WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</code> </pre><br>  Sekarang, jika Anda menginstal IPFS secara lokal, maka Anda akan mengakses antarmuka IPFS di alamat lokal dan semuanya akan tersedia untuk Anda (Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">localhost</a> : 5001 / webui /).  Tetapi ketika diinstal pada server eksternal, secara default, gateway ditutup ke Internet.  Ada dua gateway: <br><br><ol><li>  Admin webui ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> ) pada port 5001. </li><li>  API eksternal pada port 8080 (hanya baca). </li></ol><br>  Sejauh ini, Anda dapat membuka kedua port untuk percobaan (5001 dan 8080), tetapi tentu saja, di server pertempuran, port 5001 harus ditutup dengan firewall.  Ada 4001 port, diperlukan agar rekan-rekan lain dapat menemukan Anda.  Itu harus dibiarkan terbuka untuk permintaan luar. <br><br>  Buka ~ / .ipfs / config untuk mengedit dan temukan baris berikut di dalamnya: <br><br><pre> <code class="plaintext hljs">"Addresses": { "Swarm": [ "/ip4/0.0.0.0/tcp/4001", "/ip6/::/tcp/4001" ], "Announce": [], "NoAnnounce": [], "API": "/ip4/127.0.0.1/tcp/5001", "Gateway": "/ip4/127.0.0.1/tcp/8080" }</code> </pre> <br>  Ubah 127.0.0.1 ke ip server Anda dan simpan file, lalu mulai ulang ipfs (hentikan perintah yang sedang berjalan Ctrl + C dan jalankan lagi). <br><br>  Harus mendapatkan <br><br><pre> <code class="plaintext hljs">... WebUI: http://ip__:5001/webui Gateway (readonly) server listening on /ip4/ip__/tcp/8080</code> </pre><br>  Sekarang antarmuka eksternal harus tersedia. <br><br>  Lihat <br><br><pre> <code class="plaintext hljs">http://__ip_:8080/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br>  File readme di atas harus terbuka. <br><br><pre> <code class="plaintext hljs">http://__ip_:5001/webui/</code> </pre> <br>  Antarmuka web harus terbuka. <br><br>  <i>Jika webui bekerja untuk Anda, maka pengaturan IPFS dapat diubah secara langsung di dalamnya, termasuk melihat statistik, tetapi di bawah ini saya akan mempertimbangkan opsi konfigurasi langsung melalui file konfigurasi, yang umumnya tidak kritis.</i>  <i>Lebih baik mengingat di mana letak konfigurasi dan apa yang harus dilakukan dengannya, dan jika moncong web tidak berfungsi, itu akan menjadi lebih sulit.</i> <br><br><h3>  Siapkan antarmuka web untuk bekerja dengan server Anda </h3><br>  Inilah jebakan pertama, yang menghabiskan waktu sekitar tiga jam. <br><br>  Jika Anda menginstal IPFS pada server eksternal, tetapi tidak menginstal atau memulai IPFS secara lokal, maka ketika Anda mengakses / webui di antarmuka web, Anda akan melihat kesalahan koneksi: <br><br><img src="https://habrastorage.org/webt/bp/l7/jj/bpl7jjxzunvmtl9ffvvkiwphmue.png"><br><br>  Faktanya adalah webui itu, menurut saya, bekerja sangat ambigu.  Pertama, ia mencoba untuk terhubung ke API server di mana antarmuka terbuka (tentu saja, berdasarkan alamat di browser).  dan jika tidak berfungsi di sana, maka ia mencoba untuk terhubung ke gateway lokal.  Dan jika Anda memiliki IPFS berjalan secara lokal, maka webui Anda akan berfungsi dengan baik, hanya Anda yang akan bekerja dengan IPFS lokal, bukan eksternal, meskipun Anda membuka webui pada server eksternal.  Kemudian unggah file, tetapi untuk beberapa alasan Anda tidak melihatnya begitu saja di server eksternal ... <br><br>  Dan jika tidak berjalan secara lokal, kami mendapatkan kesalahan koneksi.  Dalam kasus kami, kesalahan tersebut kemungkinan besar disebabkan oleh CORS, yang juga ditunjukkan oleh webui, yang mengusulkan untuk menambahkan konfigurasi. <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["http://ip_ :5001", "http://127.0.0.1:5001", "https://webui.ipfs.io"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST"]'</code> </pre> <br>  Saya baru saja mendaftarkan wildcard <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]'</code> </pre> <br>  Header yang ditambahkan dapat ditemukan semuanya dalam ~ / .ipfs / config yang sama.  Dalam kasus saya itu <br><br><pre> <code class="plaintext hljs"> "API": { "HTTPHeaders": { "Access-Control-Allow-Origin": [ "*" ] } },</code> </pre><br>  Kami memulai ulang ipfs dan melihat bahwa webui telah berhasil terhubung (setidaknya seharusnya jika Anda membuka gateway untuk permintaan dari luar, seperti dijelaskan di atas). <br><br>  Sekarang Anda dapat langsung mengunggah folder dan file melalui antarmuka web, serta membuat folder Anda sendiri. <br><br><h3>  Pasang sistem file FUSE </h3><br>  Ini adalah trik yang cukup menarik. <br><br>  Kita dapat menambahkan file (juga folder) tidak hanya melalui antarmuka web, tetapi juga langsung di terminal, misalnya <br><br><pre> <code class="plaintext hljs">ipfs add test -r added QmfYuz2gegRZNkDUDVLNa5DXzKmxxxxxxxxxx test/test.txt added QmbnzgRVAP4fL814h5mQttyqk1aURxxxxxxxxxxxx test</code> </pre><br>  Hash terakhir adalah hash folder root. <br><br>  Dengan menggunakan hash ini, kita dapat membuka folder pada sembarang ipfs node (yang dapat menemukan node kita dan mendapatkan isinya), kita dapat di antarmuka web pada port 5001 atau 8080, atau kita dapat secara lokal melalui ipfs. <br><br><pre> <code class="plaintext hljs">ipfs ls QmbnzgRVAP4fL814h5mQttyqk1aUxxxxxxxxxxxxx QmfYuz2gegRZNkDUDVLNa5DXzKmKVxxxxxxxxxxxxxx 10 test.txt</code> </pre><br>  Tetapi Anda masih bisa membukanya seperti folder normal. <br><br>  Mari buat dua folder di root dan beri mereka hak kepada pengguna kami. <br><br><pre> <code class="plaintext hljs">sudo mkdir /ipfs /ipns sudo chown USERNAME /ipfs /ipns</code> </pre><br>  dan mulai ulang ipfs dengan flag --mount <br><br><pre> <code class="plaintext hljs">ipfs daemon --mount</code> </pre> <br>  <i>Anda dapat membuat folder di tempat lain dan menentukan path ke sana melalui daemon ipfs --mount --mount-ipfs / ipfs_path --mount-ipns / ipns_path</i> <br><br>  Sekarang membaca dari folder ini agak tidak biasa. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs ls: reading directory '/ipfs': Operation not permitted total 0</code> </pre><br>  Artinya, tidak ada akses langsung ke root folder ini.  Tapi kemudian Anda bisa mendapatkan isinya, mengetahui hash. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx total 0 -r--r--r-- 1 root root 10 Aug 31 07:03 test.txt</code> </pre><br><pre> <code class="plaintext hljs">cat /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx/test.txt test test</code> </pre><br>  Selain itu, bahkan pelengkapan otomatis di dalam folder berfungsi saat menentukan jalur. <br><br>  Seperti yang saya katakan di atas, ada kehalusan dengan pemasangan seperti itu: secara default, folder FUSE yang dipasang hanya dapat diakses oleh pengguna saat ini (bahkan root tidak dapat membaca dari folder ini, belum lagi pengguna lain dalam sistem).  Jika Anda ingin membuat folder ini dapat diakses oleh pengguna lain, maka dalam konfigurasi Anda perlu mengubah "FuseAllowOther": false menjadi "FuseAllowOther": true.  Tapi itu belum semuanya.  Jika Anda menjalankan IPFS sebagai root, maka semuanya OK.  Dan jika atas nama pengguna biasa (meskipun sudo), Anda mendapatkan kesalahan <br><br><pre> <code class="plaintext hljs">mount helper error: fusermount: option allow_other only allowed if 'user_allow_other' is set in /etc/fuse.conf</code> </pre> <br>  Dalam hal ini, Anda perlu memperbaiki /etc/fuse.conf dengan menghapus komentar pada baris #user_allow_other. <br><br>  Setelah itu kita restart ipfs. <br><br><h4>  Masalah yang diketahui dengan FUSE </h4><br>  Lebih dari satu kali masalah diketahui bahwa setelah memulai ulang ipfs dengan pemasangan (atau mungkin dalam kasus lain), titik pemasangan / ipfs dan / ipns menjadi tidak tersedia.  Tidak ada akses ke mereka, tetapi ls -la / ipfs menunjukkan ????  dalam daftar hak. <br><br>  Menemukan solusi seperti itu: <br><br><pre> <code class="plaintext hljs">fusermount -z -u /ipfs fusermount -z -u /ipns</code> </pre> <br>  Kemudian mulai ulang ipfs. <br><br><h3>  Tambahkan layanan </h3><br>  Tentu saja, peluncuran di terminal hanya cocok untuk tes utama.  Dalam mode pertempuran, daemon akan mulai secara otomatis ketika sistem dimulai. <br><br>  Atas nama sudo, buat file /etc/systemd/system/ipfs.service dan tulis untuk itu: <br><br><pre> <code class="plaintext hljs">[Unit] Description=IPFS Daemon After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/home/USERNAME/work/bin/ipfs daemon --mount User=USERNAME Restart=always [Install] WantedBy=multi-user.target</code> </pre><br>  USERNAME, tentu saja, harus diganti dengan pengguna Anda (dan mungkin path lengkap ke program ipfs akan berbeda untuk Anda (Anda harus menentukan path lengkap)). <br><br>  Kami mengaktifkan layanan. <br><br><pre> <code class="plaintext hljs">sudo systemctl enable ipfs.service</code> </pre> <br>  Kami memulai layanan. <br><br><pre> <code class="plaintext hljs">sudo service ipfs start</code> </pre> <br>  Periksa status layanan. <br><br><pre> <code class="plaintext hljs">sudo service ipfs status</code> </pre> <br>  Untuk kemurnian percobaan, dimungkinkan untuk me-reboot server di masa depan untuk memverifikasi bahwa ipfs berhasil dimulai secara otomatis. <br><br><h3>  Tambahkan hari raya yang kita tahu </h3><br>  Pertimbangkan situasi ketika kita memiliki node IPFS diinstal pada server eksternal dan lokal.  Pada server eksternal, kami menambahkan beberapa jenis file dan mencoba untuk mendapatkannya melalui IPFS secara lokal oleh CID.  Apa yang akan terjadi  Tentu saja, server lokal kemungkinan besar tidak tahu apa-apa tentang server eksternal kami dan hanya akan mencoba untuk menemukan file dengan CID dengan "meminta" semua rekan IPFS yang tersedia untuk itu (yang dengannya ia telah berhasil "mengenal").  Mereka, pada gilirannya, akan bertanya kepada orang lain.  Maka, sampai file ditemukan.  Sebenarnya, hal yang sama terjadi ketika kita mencoba untuk mendapatkan file melalui gateway <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ipfs.io</a> resmi.  Jika Anda beruntung, maka file tersebut akan ditemukan dalam beberapa detik.  Dan jika tidak, itu tidak akan ditemukan dalam beberapa menit, yang sangat mempengaruhi kenyamanan kerja.  Tapi kita tahu di mana file ini akan muncul pertama kali.  Jadi mengapa kita tidak segera memberi tahu server lokal kami “Lihat dulu”?  Ternyata, ini bisa dilakukan. <br><br>  1. Buka server jarak jauh dan cari ~ / .ipfs / config di konfigurasi <br><br><pre> <code class="plaintext hljs">"Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuxxxxxxxxxxxxxxxx",</code> </pre><br>  2. Kami menjalankan status layanan sudo ipfs dan mencari entri Swarm di dalamnya, misalnya: <br><br><pre> <code class="plaintext hljs">Swarm announcing /ip4/ip__/tcp/4001</code> </pre> <br>  3. Dari sini kita tambahkan alamat umum dari form "/ ip4 / ip_your_server / tcp / 4001 / ipfs / $ PeerID". <br><br>  4. Untuk keandalan, melalui webui lokal kami, kami akan mencoba menambahkan alamat ini ke rekan-rekan. <br><br><img src="https://habrastorage.org/webt/g5/y2/oh/g5y2ohfylmp2be51tzh0iohq1y8.png"><br><br>  5. Jika semuanya OK, buka config lokal ~ / .ipfs / config, cari "Bootstrap" di dalamnya: [... <br>  dan tambahkan alamat yang diterima terlebih dahulu ke array. <br><br>  Mulai ulang IPFS. <br><br>  Sekarang tambahkan file ke server eksternal dan cobalah untuk memintanya di server lokal.  Harus terbang cepat. <br><br>  Tetapi fungsi ini masih tidak stabil.  Sejauh yang saya mengerti, bahkan jika kita menentukan alamat rekan di Bootstrap, dalam pekerjaan ipfs mengubah daftar koneksi aktif dengan rekan-rekan.  Dalam kasus apa pun, diskusi tentang ini dan berharap tentang kemungkinan menunjukkan rekan konstan sedang diadakan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan sepertinya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">itu seharusnya</a> menambahkan beberapa fungsionalitas ke ipfs@5.0+ <br><br>  Daftar teman sebaya saat ini dapat dilihat di webui dan di terminal. <br><br><pre> <code class="plaintext hljs">ipfs swarm peers</code> </pre> <br>  Baik di sana maupun di sana Anda dapat menambahkan pesta Anda secara manual. <br><br><pre> <code class="plaintext hljs">ipfs swarm connect "/ip4/ip__/tcp/4001/ipfs/$PeerID"</code> </pre> <br>  Sampai Anda telah meningkatkan fungsionalitas ini, Anda dapat menulis alat untuk memeriksa koneksi dengan rekan yang diinginkan, dan jika tidak, untuk menambahkan koneksi. <br><br><h2>  Alasan </h2><br>  Di antara mereka yang sudah akrab dengan IPFS, ada argumen untuk dan menentang IPFS.  Pada prinsipnya, sehari sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi</a> kemarin mendorong saya untuk menggali IPFS lagi.  Dan sehubungan dengan diskusi yang disebutkan di atas: Saya tidak bisa mengatakan bahwa saya sangat menentang beberapa argumen di atas yang diungkapkan (saya tidak setuju hanya dengan fakta bahwa satu setengah programmer menggunakan IPFS).  Secara umum, keduanya benar dengan caranya sendiri (terutama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar tentang cek</a> membuat Anda berpikir).  Tetapi jika Anda mengesampingkan penilaian moral dan hukum, siapa yang akan memberikan penilaian teknis dari teknologi ini?  Secara pribadi, saya memiliki semacam perasaan batin bahwa "ini perlu, pasti memiliki prospek tertentu."  Tapi mengapa tepatnya, tidak ada kata-kata yang jelas.  Seperti jika Anda melihat alat terpusat yang ada, maka dalam banyak hal mereka sangat maju (stabilitas, kecepatan, pengelolaan, dll.).  Namun demikian, saya punya satu pemikiran, yang tampaknya masuk akal dan yang hampir tidak dapat diimplementasikan tanpa sistem desentralisasi tersebut.  Tentu saja, saya benar-benar melambaikan pikiran, tetapi saya akan merumuskannya dengan cara ini: prinsip penyebaran informasi di Internet perlu diubah. <br><br>  Saya akan jelaskan.  Jika Anda berpikir demikian, sekarang informasi kami disebarluaskan dengan prinsip "Saya harap orang yang saya pindahkan itu akan melindunginya dan tidak akan hilang atau diterima oleh orang-orang yang tidak dimaksudkan."  Misalnya, mudah untuk mempertimbangkan berbagai layanan email, penyimpanan cloud, dll.  Dan apa yang kita miliki pada akhirnya?  Di Habré Hub, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keamanan Informasi ada</a> di baris pertama dan hampir setiap hari kami menerima berita tentang kebocoran global lainnya.  Pada prinsipnya, semua yang paling menarik tercantum dalam artikel &lt;irony&gt; luar biasa &lt;/ irony&gt; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Musim panas hampir berakhir.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hampir tidak ada data yang bocor</a> .  Artinya, raksasa internet utama menjadi lebih besar, mereka mengumpulkan semakin banyak informasi, dan kebocoran tersebut adalah semacam ledakan atom informasi.  Ini tidak pernah terjadi, dan di sini lagi.  Pada saat yang sama, meskipun banyak yang memahami bahwa ada risiko, mereka akan terus mempercayai data mereka dengan perusahaan pihak ketiga.  Pertama, tidak ada banyak alternatif, dan kedua, mereka berjanji bahwa mereka telah menambal semua lubang dan ini tidak akan pernah terjadi lagi. <br><br>  Pilihan apa yang saya lihat?  Menurut saya, data awalnya harus didistribusikan secara terbuka.  Tetapi keterbukaan dalam hal ini tidak berarti bahwa semuanya harus mudah dibaca.  Saya berbicara tentang keterbukaan penyimpanan dan distribusi, tetapi bukan keterbukaan total dalam membaca.  Saya berasumsi bahwa informasi harus didistribusikan dengan kunci publik.  Lagi pula, prinsip kunci publik / pribadi sudah lama, hampir seperti Internet.  Jika informasi tersebut tidak dirahasiakan dan dirancang untuk jangkauan yang luas, maka informasi tersebut langsung diletakkan dengan kunci publik (tetapi masih dalam bentuk terenkripsi, sembarang orang dapat mendekripsi dengan kunci yang ada).  Dan jika tidak, maka itu diletakkan tanpa kunci publik, dan kunci itu sendiri dikirimkan ke apa yang harus memiliki akses ke informasi ini.  Pada saat yang sama, orang yang perlu membacanya harus hanya memiliki kunci, dan di mana untuk mendapatkan informasi ini, itu tidak boleh melonjak - ia hanya menariknya dari jaringan (ini adalah prinsip baru distribusi ke konten, bukan ke alamat). <br><br>  Jadi, untuk serangan massal, penyerang perlu mendapatkan sejumlah besar kunci privat, dan kecil kemungkinannya mereka dapat melakukan ini di satu tempat.  Tugas ini, seperti yang saya lihat, lebih sulit daripada meretas layanan tertentu. <br><br>  Dan di sini masalah lain ditutup: konfirmasi kepengarangan.  Sekarang di Internet Anda dapat menemukan banyak kutipan yang ditulis oleh teman-teman kami.  Tetapi di mana jaminan bahwa mereka menulisnya?  Sekarang, jika setiap rekaman tersebut disertai dengan tanda tangan digital, itu akan jauh lebih sederhana.  Dan di mana pun informasi ini berada, yang utama adalah tanda tangannya, yang jelas sulit dipalsukan. <br><br>  Dan inilah yang menarik di sini: IPFS sudah membawa alat enkripsi (setelah semua, itu dibangun di atas teknologi blockchain).  Kunci pribadi segera ditentukan dalam konfigurasi. <br><br><pre> <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> + / NDI51jA0MRzpBviM3o / c / Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m + JoEplHjtc4KS5 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> 7LMS7jKpwJNJBiFAa / Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj / Fb + GJMiciJUZaAjgHoaZrrf2b / Eii3z0i + QIVG7OypXT3Z9JUS60 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> Zijgq27oLyxKNr9T7 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> </pre> <br>  Saya bukan spesialis keamanan dan saya tidak tahu persis bagaimana menggunakannya dengan benar, tetapi bagi saya sepertinya kunci ini digunakan pada tingkat pertukaran antara node IPFS.  Dan juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">js-ipfs</a> dan contoh proyek-proyek seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">orbit-db</a> , di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">orbit.chat</a> bekerja.  Artinya, secara teoritis, setiap perangkat (mobile dan tidak hanya) dapat dengan mudah dilengkapi dengan mesin enkripsi-dekripsi sendiri.  Dalam hal ini, tetap hanya bagi semua orang untuk menjaga kunci pribadi mereka dan semua orang akan bertanggung jawab atas keamanan mereka sendiri, dan tidak menjadi sandera pada faktor manusia lain dalam raksasa internet yang sangat populer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465599/">https://habr.com/ru/post/id465599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465587/index.html">Analisis: apa pasar OTC, dan transaksi apa yang dilakukan di sana</a></li>
<li><a href="../id465589/index.html">Panduan Ringkas Pilot dan PoC</a></li>
<li><a href="../id465591/index.html">Konferensi PHP Eropa Tengah dibatalkan karena fakta bahwa tidak ada wanita di antara pembicara</a></li>
<li><a href="../id465595/index.html">5G datang kepada kita?</a></li>
<li><a href="../id465597/index.html">Belajar STM8S Mulai Lambat. Bagian 0</a></li>
<li><a href="../id465601/index.html">Mengapa Anda membutuhkan DevOps dan yang merupakan spesialis DevOps</a></li>
<li><a href="../id465603/index.html">Kursus vs magang. Bagaimana cara kita mengajar midbell di SimbirSoft</a></li>
<li><a href="../id465605/index.html">Buku “Pembelajaran penguatan dalam Python. OpenAI Gym dan TensorFlow untuk Pro »</a></li>
<li><a href="../id465607/index.html">Memahami Lean dan Agile dalam Pengembangan Perangkat Lunak</a></li>
<li><a href="../id465609/index.html">Mengapa 1C-Bitrix mulai 1 Desember 2019 dapat berubah menjadi labu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>