<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗾 🐅 🎧 Créer des outils dans des projets d'apprentissage automatique, un aperçu 🧝🏼 💪🏾 🏔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je me posais des questions sur l'apprentissage automatique / la structure / le flux de travail d'un projet de science des données et je lisais différe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créer des outils dans des projets d'apprentissage automatique, un aperçu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Je me posais des questions sur l'apprentissage automatique / la structure / le flux de travail d'un projet de science des données et je lisais différentes opinions sur le sujet.  Et lorsque les gens commencent à parler de workflow, ils souhaitent que leurs workflows soient reproductibles.  Il existe de nombreux articles qui suggèrent d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">make</a> pour garder le flux de travail reproductible.  Bien que <code>make</code> soit très stable et largement utilisé, j'aime personnellement les solutions multiplateformes.  C'est 2019 après tout, pas 1977. On peut dire que se faire est multiplateforme, mais en réalité vous aurez des problèmes et passerez du temps à réparer votre outil plutôt qu'à faire le travail réel.  J'ai donc décidé de jeter un coup d'œil et de vérifier quels autres outils sont disponibles.  Oui, j'ai décidé de passer du temps sur les outils. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="image"></div><br>  Ce message est plus une invitation à un dialogue qu'à un tutoriel.  Votre solution est peut-être parfaite.  Si c'est le cas, il sera intéressant d'en entendre parler. <br><br>  Dans ce post, j'utiliserai un petit projet Python et ferai les mêmes tâches d'automatisation avec différents systèmes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pavé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Luigi</a> </li></ul><br>  Il y aura un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau de comparaison</a> à la fin de l'article. <br><a name="habracut"></a><br>  La plupart des outils que j'examinerai sont appelés <em>logiciels d'automatisation de</em> <em>construction</em> ou <em>systèmes de construction</em> .  Il y en a des myriades dans toutes les saveurs, tailles et complexités différentes.  L'idée est la même: le développeur définit des règles pour produire des résultats de manière automatisée et cohérente.  Par exemple, un résultat peut être une image avec un graphique.  Pour créer cette image, il faudrait télécharger les données, nettoyer les données et faire quelques manipulations de données (exemple classique, vraiment).  Vous pouvez commencer avec quelques scripts shell qui feront le travail.  Une fois que vous reviendrez au projet un an plus tard, il sera difficile de se souvenir de toutes les étapes et de leur ordre que vous devez prendre pour créer cette image.  La solution évidente est de documenter toutes les étapes.  Bonne nouvelle!  Les systèmes de construction vous permettent de documenter les étapes sous forme de programme informatique.  Certains systèmes de construction sont comme vos scripts shell, mais avec des cloches et des sifflets supplémentaires. <br><br>  Le fondement de ce message est une série de messages de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mateusz Bednarski</a> sur le flux de travail automatisé pour un projet d'apprentissage automatique.  Mateusz explique son point de vue et propose des recettes d'utilisation de <code>make</code> .  Je vous encourage à aller vérifier ses messages en premier.  J'utiliserai principalement son code, mais avec différents systèmes de build. <br><br>  Si vous souhaitez en savoir plus sur <code>make</code> , voici quelques références pour quelques articles.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brooke Kennedy</a> donne un aperçu de haut niveau en 5 étapes faciles pour rendre votre projet de science des données reproductible.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zachary Jones</a> donne plus de détails sur la syntaxe et les capacités ainsi que les liens vers d'autres publications.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">David Stevens</a> écrit un article très hype sur les raisons pour lesquelles vous devez absolument commencer à utiliser <code>make</code> immédiatement.  Il fournit de bons exemples comparant <i>l'ancienne</i> et <i>la nouvelle méthode</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Samuel Lampa</a> , d'autre part, explique pourquoi utiliser <code>make</code> est une mauvaise idée. <br><br>  Ma sélection de systèmes de construction n'est ni complète ni impartiale.  Si vous voulez faire votre liste, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> pourrait être un bon point de départ.  Comme indiqué ci-dessus, je couvrirai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">doit</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Luigi</a> .  La plupart des outils de cette liste sont basés sur Python et cela a du sens puisque le projet est en Python.  Ce message ne couvrira pas comment installer les outils.  Je suppose que vous maîtrisez assez bien Python. <br><br>  Je suis surtout intéressé à tester cette fonctionnalité: <br><br><ol><li>  Spécification de deux cibles avec dépendances.  Je veux voir comment le faire et à quel point c'est facile. </li><li>  Vérifier si des constructions incrémentielles sont possibles.  Cela signifie que le système de génération ne reconstruira pas ce qui n'a pas été modifié depuis la dernière exécution, c'est-à-dire que vous n'avez pas besoin de retélécharger vos données brutes.  Une autre chose que je vais rechercher est les builds incrémentiels lorsque les dépendances changent.  Imaginez que nous ayons un graphique des dépendances <code>A -&gt; B -&gt; C</code>  La cible <code>C</code> sera-t-elle reconstruite si <code>B</code> change?  Si un? </li><li>  Vérifier si la reconstruction sera déclenchée si le code source est modifié, c'est-à-dire que nous modifions le paramètre du graphique généré, la prochaine fois que nous construisons l'image doit être reconstruite. </li><li>  Découvrez les moyens de nettoyer les artefacts de génération, c'est-à-dire de supprimer les fichiers qui ont été créés pendant la génération et de revenir au code source propre. </li></ol><br>  Je n'utiliserai pas toutes les cibles de construction du post de Mateusz, seulement trois d'entre elles pour illustrer les principes. <br><br>  Tout le code est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br><h2><a name="CMake"></a>  CMake </h2><br>  CMake est un générateur de script de génération, qui génère des fichiers d'entrée pour différents systèmes de génération.  Et son nom signifie marque multiplateforme.  CMake est un outil de génie logiciel.  Sa principale préoccupation est de créer des exécutables et des bibliothèques.  CMake sait donc comment construire des <i>cibles à</i> partir du code source dans les langues prises en charge.  CMake est exécuté en deux étapes: configuration et génération.  Lors de la configuration, il est possible de configurer la future version en fonction des besoins.  Par exemple, des variables fournies par l'utilisateur sont fournies au cours de cette étape.  La génération est normalement simple et produit des fichiers avec lesquels les systèmes de construction peuvent fonctionner.  Avec CMake, vous pouvez toujours utiliser <code>make</code> , mais au lieu d'écrire directement makefile, vous écrivez un fichier CMake, qui générera le makefile pour vous. <br><br>  Un autre concept important est que CMake encourage <i>les builds hors source</i> .  Les versions hors source éloignent le code source de tout artefact qu'il produit.  Cela a beaucoup de sens pour les exécutables où la base de code source unique peut être compilée sous différentes architectures CPU et systèmes d'exploitation.  Cette approche, cependant, peut contredire la façon dont beaucoup de scientifiques de données travaillent.  Il me semble que la communauté de la science des données a tendance à avoir un couplage élevé de données, de code et de résultats. <br><br>  Voyons ce dont nous avons besoin pour atteindre nos objectifs avec CMake.  Il existe deux possibilités pour définir des éléments personnalisés dans CMake: des cibles personnalisées et des commandes personnalisées.  Malheureusement, nous devrons utiliser les deux, ce qui se traduit par plus de frappe par rapport au makefile vanila.  Une cible personnalisée est considérée comme toujours obsolète, c'est-à-dire s'il existe une cible pour le téléchargement de données brutes CMake la téléchargera toujours.  Une combinaison de commande personnalisée et de cible personnalisée permet de maintenir les cibles à jour. <br><br>  Pour notre projet, nous allons créer un fichier nommé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CMakeLists.txt</a> et le mettre à la racine du projet.  Voyons le contenu: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Cette partie est basique.  La deuxième ligne définit le nom de votre projet, sa version et spécifie que nous n'utiliserons aucune prise en charge de langage intégré (nous appellerons alors des scripts Python). <br><br>  Notre première cible téléchargera l'ensemble de données IRIS: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  La première ligne définit le paramètre <code>IRIS_URL</code> , qui est exposé à l'utilisateur lors de l'étape de configuration.  Si vous utilisez l'interface graphique CMake, vous pouvez définir cette variable via l'interface graphique: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  Ensuite, nous définissons des variables avec l'emplacement téléchargé de l'ensemble de données IRIS.  Ensuite, nous ajoutons une commande personnalisée, qui produira <code>IRIS_FILE</code> en sortie.  En fin de compte, nous définissons une <code>rawdata</code> cible <code>rawdata</code> qui dépend de <code>IRIS_FILE</code> ce qui signifie que pour construire des données <code>rawdata</code> <code>IRIS_FILE</code> doit être construit.  L'option <code>ALL</code> de la cible personnalisée indique que les données <code>rawdata</code> seront l'une des cibles par défaut à créer.  Notez que j'utilise <code>CMAKE_CURRENT_SOURCE_DIR</code> afin de conserver les données téléchargées dans le dossier source et non dans le dossier de construction.  C'est juste pour faire la même chose que Mateusz. <br><br>  D'accord, voyons comment nous pouvons l'utiliser.  Je l'exécute actuellement sur WIndows avec le compilateur MinGW installé.  Vous devrez peut-être ajuster le paramètre du générateur à vos besoins (exécutez <code>cmake --help</code> pour voir la liste des générateurs disponibles).  Lancez le terminal et accédez au dossier parent du code source, puis: <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">résultat</b> <div class="spoiler_text">  - Configuration terminée <br>  - Génération terminée <br>  - Les fichiers de construction ont été écrits dans: C: / home / workspace / surmonter-le-chaos-build <br></div></div><br>  Avec CMake moderne, nous pouvons construire le projet directement à partir de CMake.  Cette commande appellera la commande <code>build all</code> : <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">résultat</b> <div class="spoiler_text">  Analyse des dépendances des données brutes cibles <br>  [100%] Données brutes cibles construites <br></div></div><br>  Nous pouvons également consulter la liste des cibles disponibles: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Et nous pouvons supprimer le fichier téléchargé par: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Voyez que nous n'avions pas besoin de créer la cible propre manuellement. <br><br>  Passons maintenant à la prochaine cible - les données IRIS prétraitées.  Mateusz crée deux fichiers à partir d'une seule fonction: <code>processed.pickle</code> et <code>processed.xlsx</code> .  Vous pouvez voir comment il s'en va avec le nettoyage de ce fichier Excel en utilisant <code>rm</code> avec un caractère générique.  Je pense que ce n'est pas une très bonne approche.  Dans CMake, nous avons deux options pour y faire face.  La première option consiste à utiliser la propriété de répertoire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  Le code sera: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  La deuxième option consiste à spécifier une liste de fichiers en tant que sortie de commande personnalisée: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  Voyez que dans ce cas, j'ai créé la liste, mais je ne l'ai pas utilisée dans la commande personnalisée.  Je ne connais pas de moyen de référencer les arguments de sortie de la commande personnalisée à l'intérieur. <br><br>  Une autre chose intéressante à noter est l'utilisation de <code>depends</code> dans cette commande personnalisée.  Nous définissons la dépendance non seulement à partir d'une cible personnalisée, mais aussi de sa sortie et du script python.  Si nous <code>IRIS_FILE</code> pas de dépendance à <code>IRIS_FILE</code> , la modification manuelle d' <code>iris.csv</code> n'entraînera pas la reconstruction de la cible de <code>preprocess</code> .  Eh bien, vous ne devez pas modifier les fichiers de votre répertoire de construction manuellement en premier lieu.  Je vous fais juste savoir.  Plus de détails dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le post de Sam Thursdayfield</a> .  La dépendance au script python est nécessaire pour reconstruire la cible si le script python change. <br><br>  Et enfin le troisième objectif: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Cet objectif est fondamentalement le même que le second. <br><br>  Pour conclure.  CMake semble désordonné et plus difficile que Make.  En effet, beaucoup de gens critiquent CMake pour sa syntaxe.  D'après mon expérience, la compréhension viendra et il est absolument possible de donner un sens à des fichiers CMake même très compliqués. <br><br>  Vous devrez toujours vous coller beaucoup car vous devrez passer des variables correctes.  Je ne vois pas un moyen facile de référencer la sortie d'une commande personnalisée dans une autre.  Il semble qu'il soit possible de le faire via des cibles personnalisées. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  La partie PyBuilder est très courte.  J'ai utilisé Python 3.7 dans mon projet et PyBuilder version actuelle 0.11.17 ne le prend pas en charge.  La solution proposée consiste à utiliser la version de développement.  Cependant, cette version est limitée à pip v9.  Pip est v19.3 au moment de l'écriture.  Bummer.  Après l'avoir un peu tripoté, ça n'a pas marché du tout pour moi.  L'évaluation de PyBuilder a été de courte durée. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt est basé sur python, ce qui signifie que nous pouvons utiliser directement les fonctions python.  Il n'est pas nécessaire de les encapsuler avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clic</a> et de fournir une interface de ligne de commande.  Cependant, pynt est également capable d'exécuter des commandes shell.  J'utiliserai des fonctions python. <br><br>  Les commandes de construction sont données dans un fichier <code>build.py</code> .  Les cibles / tâches sont créées avec des décorateurs de fonctions.  Les dépendances de tâches sont fournies par le même décorateur. <br><br>  Comme je voudrais utiliser des fonctions python, je dois les importer dans le script de construction.  Pynt n'inclut pas le répertoire courant comme script python, donc écrire smth comme ceci: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  ne fonctionnera pas.  Nous devons faire: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  Mon fichier <code>build.py</code> initial était comme ceci: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  Et la cible de <code>preprocess</code> n'a pas fonctionné.  Il se plaignait constamment des arguments d'entrée de la fonction <code>pypreprocess</code> .  Il semble que Pynt ne gère pas très bien les arguments de fonction optionnels.  J'ai dû retirer l'argument pour faire le fichier Excel.  Gardez cela à l'esprit si votre projet a des fonctions avec des arguments facultatifs. <br><br>  Nous pouvons exécuter pynt à partir du dossier du projet et répertorier toutes les cibles disponibles: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">résultat</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Faisons la distribution par paire: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">résultat</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Si nous <code>pynt exploratory</code> nouveau la même commande (c'est-à-dire <code>pynt exploratory</code> ), il y aura une reconstruction complète.  Pynt n'a pas constaté que rien n'avait changé. <br><br><h2><a name="Paver"></a>  Pavé </h2><br>  Paver ressemble presque exactement à Pynt.  Il diffère légèrement d'une manière qui définit les dépendances entre les cibles (un autre décorateur <code>@needs</code> ).  Paver effectue une reconstruction complète à chaque fois et ne joue pas bien avec les fonctions qui ont des arguments facultatifs.  Les instructions de construction se trouvent dans le fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  doit </h2><br>  Doit semble être une tentative de créer un véritable outil d'automatisation de construction en python.  Il peut exécuter du code python et des commandes shell.  Cela semble assez prometteur.  Ce qui semble manquer (dans le contexte de nos objectifs spécifiques), c'est la capacité de gérer les dépendances entre les cibles.  Disons que nous voulons créer un petit pipeline où la sortie de la cible A est utilisée comme entrée de la cible B. Et disons que nous utilisons des fichiers comme sorties, donc la cible A crée un fichier nommé <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Afin de créer un tel pipeline, nous devrons spécifier le fichier <code>outA</code> deux fois dans la cible A (à la suite d'une cible, mais aussi retourner son nom dans le cadre de l'exécution de la cible).  Ensuite, nous devrons le spécifier comme entrée pour la cible B. Il y a donc 3 endroits au total où nous devons fournir des informations sur le fichier <code>outA</code> .  Et même après cela, la modification du fichier <code>outA</code> n'entraînera pas la reconstruction automatique de la cible B. Cela signifie que si nous demandons doit construire la cible B, doit uniquement vérifier si la cible B est à jour sans vérifier aucune des dépendances.  Pour surmonter cela, nous devrons spécifier <code>outA</code> 4 fois - également en tant que dépendance de fichier de la cible B. Je vois cela comme un inconvénient.  Make et CMake sont capables de gérer ces situations correctement. <br><br>  Les dépendances dans doit doivent être basées sur des fichiers et exprimées sous forme de chaînes.  Cela signifie que les dépendances <code>./myfile.txt</code> et <code>myfile.txt</code> sont considérées comme différentes.  Comme je l'ai écrit ci-dessus, je trouve un peu étrange la façon de transmettre des informations d'une cible à l'autre (lors de l'utilisation de cibles python).  La cible a une liste d'artefacts qu'elle va produire, mais une autre cible ne peut pas l'utiliser.  Au lieu de cela, la fonction python, qui constitue la cible, doit renvoyer un dictionnaire, accessible dans une autre cible.  Voyons cela sur un exemple: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Ici, le <code>preprocess</code> cible dépend des données <code>rawdata</code> .  La dépendance est fournie via la propriété <code>getargs</code> .  Il indique que l'argument <code>input_file</code> de la fonction <code>doit_pypreprocess</code> est le <code>filename</code> de <code>filename</code> de sortie des données <code>rawdata</code> cibles.  Jetez un œil à l'exemple complet dans le fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dodo.py.</a> <br><br>  Il peut être utile de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les histoires</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réussite</a> de l'utilisation de doit.  Il a certainement de belles fonctionnalités comme la possibilité de fournir une vérification cible mise à jour personnalisée. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  Luigi reste à l'écart des autres outils car c'est un système pour construire des pipelines complexes.  Il est apparu sur mon radar après qu'un collègue m'a dit qu'il avait essayé Make, qu'il n'a jamais pu l'utiliser sur Windows / Linux et qu'il s'est éloigné de Luigi. <br><br>  Luigi vise des systèmes prêts pour la production.  Il est livré avec un serveur, qui peut être utilisé pour visualiser vos tâches ou pour obtenir un historique des exécutions de tâches.  Le serveur est appelé un <em>ordonnanceur central</em> .  Un planificateur local est disponible à des fins de débogage. <br><br>  Luigi est également différent des autres systèmes dans la mesure où les tâches sont créées.  Lugi n'agit pas sur certains fichiers prédéfinis (comme <code>dodo.py</code> , <code>pavement.py</code> ou makefile).  Il faut plutôt passer un nom de module python.  Donc, si nous essayons de l'utiliser de la même manière que d'autres outils (placer un fichier avec des tâches à la racine du projet), cela ne fonctionnera pas.  Nous devons soit installer notre projet, soit modifier la variable d'environnement <code>PYTHONPATH</code> en ajoutant le chemin d'accès au projet. <br><br>  Ce qui est génial avec luigi, c'est la façon de spécifier les dépendances entre les tâches.  Chaque tâche est une classe.  La <code>output</code> méthode indique à Luigi où les résultats de la tâche finiront.  Les résultats peuvent être un seul élément ou une liste.  La méthode <code>requires</code> des dépendances de tâches spécifiées (autres tâches; bien qu'il soit possible de créer une dépendance à partir d'elle-même).  Et c'est tout.  Tout ce qui est spécifié comme <code>output</code> dans la tâche A sera transmis comme entrée à la tâche B si la tâche B s'appuie sur la tâche A. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  Luigi ne se soucie pas des modifications de fichiers.  Il se soucie de l'existence de fichiers.  Il n'est donc pas possible de déclencher des reconstructions lorsque le code source change.  Luigi n'a pas de fonctionnalité <i>propre</i> intégrée. <br><br>  Les tâches Luigi pour ce projet sont disponibles dans le fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">luigitasks.py</a> .  Je les lance depuis le terminal: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Comparaison </h2><br>  Le tableau ci-dessous résume le fonctionnement de différents systèmes par rapport à nos objectifs spécifiques. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Définir la cible avec dépendance </th><th>  Constructions incrémentielles </th><th>  Constructions incrémentielles si le code source est modifié </th><th>  Possibilité de déterminer les artefacts à supprimer lors de <code>clean</code> commande de <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  oui </td><td>  oui </td><td>  oui </td><td>  oui </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  oui </td><td>  non </td><td>  non </td><td>  non </td></tr><tr><td>  <strong>Pavé</strong> </td><td>  oui </td><td>  non </td><td>  non </td><td>  non </td></tr><tr><td>  <strong>doit</strong> </td><td>  Un peu oui </td><td>  oui </td><td>  oui </td><td>  oui </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  oui </td><td>  non </td><td>  non </td><td>  non </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451962/">https://habr.com/ru/post/fr451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451950/index.html">Centrales virtuelles. Est-il possible de gérer les sources d'énergie "verte"?</a></li>
<li><a href="../fr451954/index.html">Plus de télégrammes secrets</a></li>
<li><a href="../fr451956/index.html">Utilisation d'AppDynamics avec Red Hat OpenShift v3</a></li>
<li><a href="../fr451958/index.html">Nous regardons des torrents sur smart TV sans SMS ni inscription</a></li>
<li><a href="../fr451960/index.html">90 vulnérabilités d'exécution de code à distance dans la mise à jour de mai mardi</a></li>
<li><a href="../fr451966/index.html">Les périphériques d'E / S modernes sont plus rapides que les processeurs. Présentation de l'article</a></li>
<li><a href="../fr451968/index.html">Top 3D Academy - formation aux technologies additives dans les principales entreprises russes</a></li>
<li><a href="../fr451970/index.html">Thrangrycat: une vulnérabilité critique dans le micrologiciel des périphériques Cisco permet aux pirates informatiques d'y installer des portes dérobées</a></li>
<li><a href="../fr451972/index.html">QuadCast - Sons réels</a></li>
<li><a href="../fr451974/index.html">Histoire d'AMD: 50 ans de développement rapide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>