<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ï¸ ğŸ¤¶ğŸ¿ ğŸˆ Manajemen Koneksi SignalR yang Efisien ğŸ¦• ğŸ™‡ ğŸ </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habrahabr. Saat ini saya sedang mengerjakan mesin obrolan berdasarkan perpustakaan SignalR . Selain proses imersi yang menarik di dunia aplikasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen Koneksi SignalR yang Efisien</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470299/">  Halo, Habrahabr.  Saat ini saya sedang mengerjakan mesin obrolan berdasarkan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SignalR</a> .  Selain proses imersi yang menarik di dunia aplikasi waktu nyata, saya juga harus menghadapi sejumlah tantangan teknis.  Tentang salah satu dari mereka, saya ingin berbagi dengan Anda di artikel ini. <br><br><h3>  Pendahuluan </h3><br>  Apa itu SignalR - itu semacam fasad di atas <b>WebSockets</b> , <b>Polling panjang</b> , <b>Server-send events</b> technology.  Berkat fasad ini, Anda dapat bekerja secara seragam dengan semua teknologi ini dan tidak khawatir tentang detailnya.  Selain itu, berkat teknologi polling panjang, Anda dapat mendukung klien yang, karena alasan tertentu, tidak dapat bekerja di soket web, seperti IE-8.  Fasad diwakili oleh API berbasis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RPC</a> tingkat tinggi.  Selain itu, SignalR menawarkan untuk membangun komunikasi sesuai dengan prinsip "penerbit-pelanggan", yang dalam terminologi API disebut kelompok.  Ini akan dibahas lebih lanjut. <br><br><h3>  Tantangan </h3><br>  Mungkin hal yang paling menarik dalam pemrograman adalah kemampuan untuk menyelesaikan masalah yang tidak standar.  Dan hari ini kita akan menunjuk salah satu tugas ini dan mempertimbangkan solusinya. <br><a name="habracut"></a><br>  Di era pengembangan ide penskalaan dan, pertama-tama, horisontal, tantangan utama adalah kebutuhan untuk memiliki lebih dari satu server.  Dan pengembang perpustakaan yang ditunjukkan sudah mengatasi panggilan ini, deskripsi solusinya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSDN</a> .  Singkatnya, diusulkan, menggunakan prinsip penerbit-pelanggan, untuk menyinkronkan panggilan antar server.  Setiap server berlangganan bus bersama dan semua perintah yang <b>dikirim</b> dari server ini dikirim terlebih dahulu ke bus.  Selanjutnya, perintah ini berlaku untuk semua server dan hanya untuk klien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd6/7b5/81f/fd67b581f8437bf5f8984dd9470cf60f.png" alt="gambar"><br><br>  Penting untuk dicatat bahwa setiap klien yang terhubung ke server memiliki pengenal koneksi unik - <b>ConnectionId</b> - dan semua pesan pada akhirnya ditangani menggunakan pengenal ini.  Oleh karena itu, setiap server menyimpan koneksi ini. <br><br>  Namun, untuk alasan yang tidak diketahui, API pustaka SignalR tidak menyediakan akses ke data ini.  Dan di sini kita dihadapkan dengan pertanyaan yang sangat akut tentang akses ke koneksi ini.  Ini tantangan kita. <br><br><h3>  Mengapa kita perlu terhubung </h3><br>  Seperti disebutkan sebelumnya, SignalR menawarkan model penerbit-pelanggan.  Di sini, unit perutean pesan bukan <b>ConnectionId</b> tetapi grup.  Grup adalah kumpulan koneksi.  Dengan mengirim pesan ke grup, kami mengirim pesan ke semua ConnectionId yang ada di grup ini.  Lebih mudah untuk membangun grup - saat menghubungkan klien ke server, kami cukup memanggil metode API <b>AddToGroupAsync</b> : <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnConnectedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _options.Chats) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.AddToGroupAsync(ConnectionId, chat); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.AddToGroupAsync(ConnectionId, Client); }</code> </pre> <br>  Dan bagaimana cara meninggalkan grup?  Pengembang menawarkan metode API <b>RemoveFromGroupAsync</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDisconnectedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chat <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _options.Chats) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.RemoveFromGroupAsync(ConnectionId, chat); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.RemoveFromGroupAsync(ConnectionId, Client); }</code> </pre> <br>  Perhatikan bahwa unit data adalah ConnectionId.  Namun, dari sudut pandang model domain, ConnectionId tidak ada, tetapi ada klien.  Dalam hal ini, organisasi pemetaan klien ke array ConnectionId dan sebaliknya ditugaskan untuk pengguna perpustakaan yang ditentukan. <br><br>  Ini adalah array dari semua klien ConnectionId yang diperlukan ketika meninggalkan grup.  Namun, array seperti itu tidak ada.  Anda perlu mengaturnya sendiri.  Tugas menjadi jauh lebih menarik dalam kasus sistem skala horizontal.  Dalam hal ini, bagian dari koneksi bisa di satu server, sisanya di server lain. <br><br><h3>  Cara memetakan klien ke koneksi </h3><br>  Seluruh bagian tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSDN</a> didedikasikan untuk masalah ini.  Metode berikut diusulkan untuk dipertimbangkan: <br><br><ul><li>  Penyimpanan dalam memori </li><li>  "Grup Pengguna" </li><li>  Penyimpanan Eksternal Permanen </li></ul><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara melacak koneksi?</b> <div class="spoiler_text">  Anda dapat melacak koneksi menggunakan metode hub <b>OnConnectedAsync</b> dan <b>OnDisconnectedAsync</b> . <br></div></div><br>  Segera, saya perhatikan bahwa opsi yang tidak mendukung penskalaan tidak dipertimbangkan.  Ini termasuk opsi untuk menyimpan koneksi dalam memori server.  Tidak ada akses ke koneksi klien di server lain, jika ada.  Opsi penyimpanan dalam penyimpanan persisten eksternal dikaitkan dengan kelemahannya, yang mencakup masalah pembersihan koneksi tidak aktif.  Koneksi tersebut terjadi jika terjadi reboot server yang keras.  Mendeteksi dan membersihkan koneksi ini bukanlah tugas yang sepele. <br><br>  Di antara opsi di atas, opsi "grup pengguna" menarik.  Kesederhanaan tentu berlaku untuk keuntungannya - tidak ada perpustakaan, repositori diperlukan.  Yang tak kalah penting adalah konsekuensi dari kesederhanaan metode ini - keandalan. <br><br><div class="spoiler">  <b class="spoiler_title">Tapi bagaimana dengan Redis?</b> <div class="spoiler_text">  Omong-omong, menggunakan Redis untuk menyimpan koneksi juga merupakan pilihan yang buruk.  Ada masalah akut dalam mengatur data dalam memori.  Di satu sisi, kuncinya adalah klien, di sisi lain, grup. <br></div></div><br><h3>  "Grup Pengguna" </h3><br>  Apa itu "grup pengguna"?  Ini adalah grup dalam terminologi SignalR di mana hanya satu klien yang dapat menjadi klien - dia sendiri.  Ini menjamin 2 hal: <br><br><ol><li>  Pesan akan dikirimkan hanya kepada satu orang </li><li>  Pesan akan dikirim ke semua perangkat manusia </li></ol><br>  Bagaimana ini akan membantu kami?  Biarkan saya mengingatkan Anda bahwa tantangan kami adalah menyelesaikan masalah meninggalkan klien dari grup.  Kami memerlukan itu, meninggalkan grup dari satu perangkat, sisanya juga akan berhenti berlangganan, tetapi kami tidak memiliki daftar koneksi untuk klien ini, kecuali yang kami gunakan untuk memulai keluar. <br><br>  "Kelompok pengguna" adalah langkah pertama untuk menyelesaikan masalah ini.  Langkah kedua adalah membangun "cermin" pada klien.  Ya, ya, mirror. <br><br><h3>  Cermin </h3><br>  Sumber perintah yang dikirim dari klien ke server adalah tindakan pengguna.  Kirim pesan - kirim perintah ke server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.hubConnection .invoke(<span class="hljs-string"><span class="hljs-string">'post'</span></span>, {message, group, nick}) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br>  Dan kami memberi tahu semua klien grup tentang pos baru: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PostMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PostMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Clients.Group(message.Group).SendAsync(<span class="hljs-string"><span class="hljs-string">"message"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Message = message.Message, Group = message.Group, Nick = ClientNick }); }</code> </pre> <br>  Namun, sejumlah perintah harus dijalankan secara serempak di semua perangkat.  Bagaimana cara mencapai ini?  Entah memiliki array koneksi dan menjalankan perintah untuk setiap koneksi pada klien tertentu, atau menggunakan metode yang dijelaskan di bawah ini.  Pertimbangkan metode ini dengan keluar dari obrolan. <br><br>  Tim yang tiba dari klien pertama-tama akan pergi ke "grup pengguna" untuk metode khusus, yang hanya akan mengarahkannya kembali ke server, mis.  " <b>Cermin</b> ."  Dengan demikian, bukan server yang akan berhenti berlangganan perangkat, tetapi perangkat itu sendiri akan diminta untuk berhenti berlangganan. <br><br>  Berikut adalah contoh dari perintah obrolan server berhenti berlangganan: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LeaveChat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">LeaveChatMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Clients.OthersInGroup(message.Group).SendAsync(<span class="hljs-string"><span class="hljs-string">"lost"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClientCommand { Group = message.Group, Nick = Client }); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Clients.Group(Client).SendAsync(<span class="hljs-string"><span class="hljs-string">"mirror"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MirrorChatCommand { Method = <span class="hljs-string"><span class="hljs-string">"unsubscribe"</span></span>, Payload = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnsubscribeChatMessage { Group = message.Group } }); }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnsubscribeChatMessage message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Groups.RemoveFromGroupAsync(ConnectionId, message.Group); }</code> </pre> <br>  Dan di sini adalah kode klien: <br><br><pre> <code class="javascript hljs">connection.on(<span class="hljs-string"><span class="hljs-string">'mirror'</span></span>, (message) =&gt; { connection .invoke(message.method, message.payload) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)); });</code> </pre> <br>  Mari kita teliti lebih detail apa yang terjadi di sini: <br><br><ol><li>  Klien memulai berhenti berlangganan - mengirim perintah "meninggalkan" ke server </li><li>  Server mengirimkan perintah "berhenti berlangganan" ke "grup pengguna" di "mirror" </li><li>  Pesan dikirim ke semua perangkat klien. </li><li>  Pesan pada klien dikirim kembali ke server menggunakan metode yang ditentukan oleh server </li><li>  Di setiap server, klien berhenti berlangganan dari grup </li></ol><br>  Akibatnya, semua perangkat itu sendiri akan berhenti berlangganan dari server yang terhubung.  Masing-masing akan berhenti berlangganan sendiri dan kita tidak perlu menyimpan apa pun.  Tidak ada masalah juga akan muncul jika terjadi reboot dari server. <br><br><h3>  Jadi mengapa kita perlu terhubung? </h3><br>  Memiliki "grup pengguna" dan "mirror" pada klien menghilangkan kebutuhan untuk bekerja dengan koneksi.  Bagaimana menurut Anda, para pembaca, tentang hal ini?  Bagikan pendapat Anda di komentar. <br><br>  Kode sumber untuk contoh: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/aesamson/signalr-server</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/aesamson/signalr-client</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470299/">https://habr.com/ru/post/id470299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470283/index.html">Mesin pencari adalah seorang Wanita</a></li>
<li><a href="../id470285/index.html">Seekor harimau yang meringkuk bersembunyi di SQLAlchemy. Dasar-dasarnya</a></li>
<li><a href="../id470287/index.html">Migran</a></li>
<li><a href="../id470289/index.html">Bahasa pemrograman impian saya</a></li>
<li><a href="../id470295/index.html">Enkripsi SQlite DB sederhana</a></li>
<li><a href="../id470301/index.html">Pohon Kata Kunci: analisis grafik untuk ekstraksi semantik</a></li>
<li><a href="../id470303/index.html">Instal server tftp pada CentOS 8 atau RedHat 8</a></li>
<li><a href="../id470305/index.html">Mempersiapkan Sertifikasi Spring Profesional. Wadah, IOC, Kacang</a></li>
<li><a href="../id470309/index.html">Xamarin.Forms Shell</a></li>
<li><a href="../id470311/index.html">Mainan Kayu, Bagian Tujuh - 1993</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>