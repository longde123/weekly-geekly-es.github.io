<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌸 🛒 🤜🏻 Mengotomatiskan penggantian disk dengan Ansible 🛒 👦🏽 🤚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. Saya bekerja sebagai administrator sistem terkemuka di OK dan saya bertanggung jawab untuk operasi portal yang stabil. Saya ingin berbi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengotomatiskan penggantian disk dengan Ansible</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/452110/"><img src="https://habrastorage.org/webt/s9/ga/q9/s9gaq9eke8gooeu1-nnsr5ocv7o.jpeg"><br><br>  Halo semuanya.  Saya bekerja sebagai administrator sistem terkemuka di OK dan saya bertanggung jawab untuk operasi portal yang stabil.  Saya ingin berbicara tentang bagaimana kami membangun proses penggantian disk otomatis, dan kemudian, ketika seorang administrator dikeluarkan dari proses ini dan menggantinya dengan bot. <br><br>  Artikel ini adalah semacam transliterasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kinerja</a> di HighLoad + 2018 <br><a name="habracut"></a><br><h2>  Membangun proses penggantian disk </h2><br><h3>  Pertama beberapa angka </h3><br>  OK adalah layanan raksasa yang digunakan oleh jutaan orang.  Ini dilayani oleh sekitar 7 ribu server, yang berlokasi di 4 pusat data yang berbeda.  Server harganya lebih dari 70 ribu drive.  Jika Anda menumpuknya di atas satu sama lain, Anda mendapatkan menara dengan ketinggian lebih dari 1 km. <br><br>  Hard drive adalah komponen dari server yang paling sering crash.  Dengan volume seperti itu, kami harus mengubah sekitar 30 disc per minggu, dan prosedur ini telah menjadi rutin yang tidak menyenangkan. <br><br><img src="https://habrastorage.org/webt/i8/92/cg/i892cglklhooat_z_qrsexsmzfu.png"><br><br><h3>  Insiden </h3><br>  Kami telah memperkenalkan manajemen insiden lengkap di perusahaan kami.  Setiap kejadian kami rekam di Jira, lalu kami pecahkan dan bongkar.  Jika kejadian itu berpengaruh bagi pengguna, maka kita pasti akan berpikir tentang bagaimana merespons lebih cepat dalam kasus seperti itu, bagaimana mengurangi efeknya dan tentu saja bagaimana mencegah terulangnya. <br><br>  Drive tidak terkecuali.  Status mereka dipantau oleh Zabbix.  Kami memantau pesan dalam Syslog untuk kesalahan tulis / baca, menganalisis status serangan HW / SW, memantau SMART, dan menghitung keausan untuk SSD. <br><br><h3>  Bagaimana cakram berubah sebelumnya </h3><br>  Ketika pemicu menyala di Zabbix, sebuah insiden dibuat di Jira dan secara otomatis dimasukkan ke insinyur yang tepat di pusat data.  Kami melakukan ini dengan semua insiden HW, yaitu yang membutuhkan semacam pekerjaan fisik dengan peralatan di pusat data. <br>  Seorang insinyur dari pusat data adalah orang yang memecahkan masalah yang terkait dengan perangkat keras, bertanggung jawab untuk instalasi, pemeliharaan, pembongkaran server.  Setelah menerima tiket, insinyur mulai bekerja.  Di rak disk, ia mengganti disk sendiri.  Tetapi jika dia tidak memiliki akses ke perangkat yang diinginkan, insinyur beralih ke administrator sistem yang bertugas untuk membantu.  Pertama-tama, Anda perlu menghapus disk dari rotasi.  Untuk melakukan ini, Anda perlu membuat perubahan yang diperlukan di server, menghentikan aplikasi, unmount disk. <br><br>  Administrator sistem yang bertugas selama shift bertanggung jawab atas pengoperasian seluruh portal.  Dia menyelidiki insiden, perbaikan, membantu pengembang melakukan tugas-tugas kecil.  Dia tidak hanya berurusan dengan hard drive. <br><br>  Sebelumnya, para insinyur pusat data mengobrol dengan administrator sistem.  Para insinyur mengirim tautan ke tiket Jira, administrator memeriksa, menyimpan catatan pekerjaan di beberapa buku catatan.  Tetapi obrolan tidak nyaman untuk tugas-tugas seperti itu: informasi di sana tidak terstruktur dan cepat hilang.  Dan administrator hanya bisa menjauh dari komputer dan untuk beberapa waktu tidak menanggapi permintaan, dan insinyur berdiri di server dengan sekelompok disk dan menunggu. <br><br>  Tetapi yang terburuk adalah bahwa administrator tidak melihat seluruh gambar: insiden disk apa yang ada, di mana masalah tersebut berpotensi muncul.  Ini karena fakta bahwa kami memberikan semua insiden HW kepada para insinyur.  Ya, itu mungkin untuk menampilkan semua insiden di dasbor admin.  Tetapi ada banyak dari mereka, dan administrator hanya terlibat dalam beberapa dari mereka. <br><br>  Selain itu, insinyur tidak dapat memprioritaskan dengan benar, karena ia tidak tahu apa-apa tentang tujuan server tertentu, tentang distribusi informasi lintas drive. <br><br><h3>  Prosedur penggantian baru </h3><br>  Hal pertama yang kami lakukan adalah mengambil semua insiden disk menjadi tipe "HW-disk" yang terpisah dan menambahkan bidang "blok nama perangkat", "ukuran" dan "tipe disk" ke dalamnya sehingga informasi ini akan disimpan dalam tiket dan tidak harus terus mengobrol. <br><br><div style="text-align:center;"><img width="300" height="400" src="https://habrastorage.org/webt/0y/uz/jm/0yuzjmgoz4hgulcpf5o5vhwde18.png"></div><br>  Kami juga sepakat bahwa dalam kerangka satu insiden kami hanya akan mengubah satu disk.  Ini sangat menyederhanakan proses otomatisasi, pengumpulan statistik, dan pekerjaan. <br><br>  Selain itu, bidang "administrator yang bertanggung jawab" telah ditambahkan.  Administrator sistem secara otomatis diganti di sana.  Ini sangat nyaman, karena sekarang insinyur selalu melihat siapa yang bertanggung jawab.  Tidak perlu pergi ke kalender dan mencari.  Bidang inilah yang memungkinkan menempatkan tiket di dasbor administrator, di mana, mungkin, bantuannya akan dibutuhkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9x/b1/ue/9xb1ueokh0450wgkhq0ije1lfqa.png"></div><br>  Untuk memastikan bahwa semua peserta menerima manfaat maksimal dari inovasi, kami membuat filter dan dasbor, memberi tahu orang-orang tentang mereka.  Ketika orang memahami perubahan, mereka tidak menjauhkan diri dari mereka sebagai sesuatu yang tidak perlu.  Penting bagi seorang insinyur untuk mengetahui nomor rak di mana server berada, ukuran dan jenis disk.  Administrator perlu, pertama-tama, untuk memahami apa jenis grup server ini, apa efeknya ketika mengganti disk. <br><br>  Kehadiran bidang dan tampilan mereka nyaman, tetapi ini tidak menyelamatkan kita dari kebutuhan untuk menggunakan obrolan.  Untuk melakukan ini, saya harus mengubah alur kerja. <br><br>  Dulu seperti ini: <br><br><div style="text-align:center;"><img width="300" height="400" src="https://habrastorage.org/webt/we/wc/du/wewcdu4q8fqy-gd9wkbutorbabi.png"></div><br>  Saat ini, para insinyur terus bekerja seperti ini ketika mereka tidak membutuhkan bantuan administrator. <br><br>  Hal pertama yang kami lakukan adalah memperkenalkan status <b>Investigate</b> baru.  Tiket berada dalam status ini ketika insinyur belum memutuskan apakah dia akan membutuhkan administrator atau tidak.  Melalui status ini, insinyur dapat meneruskan tiket ke administrator.  Selain itu, kami menandai tiket dengan status ini saat penggantian disk diperlukan, tetapi tidak ada disk itu sendiri di situs.  Ini terjadi dengan CDN dan situs jarak jauh. <br><br>  Kami juga menambahkan status <b>Siap</b> .  Tiket ditransfer ke sana setelah mengganti disk.  Artinya, semuanya sudah dilakukan, tetapi HW / SW RAID disinkronkan di server.  Ini bisa sangat memakan waktu. <br><br>  Jika seorang administrator terlibat, skema ini sedikit lebih rumit. <br><br><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/ev/5a/58/ev5a58jyosbyuc8cfrhr7sru5zo.png"></div><br>  Dari status <b>Terbuka</b> , tiket dapat ditransfer oleh administrator sistem dan insinyur.  Dalam status <b>Dalam proses</b> , administrator menghapus disk dari rotasi sehingga insinyur dapat menghapusnya: itu menyalakan lampu latar, meng-unmount disk, dan menghentikan aplikasi, tergantung pada kelompok server tertentu. <br><br>  Kemudian tiket dikonversi ke <b>Siap untuk berubah</b> : ini adalah sinyal kepada insinyur bahwa disk dapat ditarik keluar.  Semua bidang di Jira sudah diisi, insinyur tahu apa jenis dan ukuran disk.  Data ini ditempelkan pada status sebelumnya secara otomatis atau oleh administrator. <br><br>  Setelah mengganti disk, tiket ditransfer ke status <b>Berubah</b> .  Diperiksa bahwa disk yang benar telah dimasukkan, markup dilakukan, aplikasi diluncurkan, dan beberapa tugas pemulihan data dilakukan.  Juga, tiket dapat ditransfer ke status <b>Siap</b> , dalam hal ini administrator akan tetap bertanggung jawab, karena ia memulai disk secara bergiliran.  Garis besar terlihat seperti ini. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/webt/xg/x7/_z/xgx7_zk2mlyubhzepgfw0oogbt4.png"></div><br>  Menambahkan bidang baru membuat hidup kita lebih mudah.  Orang-orang mulai bekerja dengan informasi terstruktur, menjadi jelas apa dan pada tahap apa yang harus dilakukan.  Prioritas menjadi jauh lebih relevan karena sekarang ditetapkan oleh administrator. <br><br>  Kebutuhan akan obrolan telah menghilang.  Tentu saja, administrator dapat menulis kepada insinyur "Anda harus mengganti lebih cepat di sini," atau "sudah malam, apakah Anda punya waktu untuk mengganti?".  Tapi kami tidak lagi mengobrol setiap hari tentang masalah ini. <br><br>  Disk mulai berubah dalam paket.  Jika administrator datang untuk bekerja sedikit lebih awal, ia memiliki waktu luang, dan tidak ada yang terjadi, ia dapat menyiapkan sejumlah server untuk penggantian: meletakkan bidang, menghapus disk dari rotasi dan mentransfer tugas ke insinyur.  Seorang insinyur kemudian tiba di pusat data, melihat tugas, mengambil drive yang diperlukan dari gudang dan segera mengubahnya.  Akibatnya, kecepatan penggantian telah meningkat. <br><br><h3>  Pelajaran yang Dipetik dalam Membangun Alur Kerja </h3><br><ul><li>  <b>Saat membuat prosedur, Anda perlu mengumpulkan informasi dari berbagai sumber.</b> <br>  Beberapa administrator kami tidak tahu bahwa insinyur mengubah disk sendiri.  Beberapa orang berpikir bahwa para insinyur memantau sinkronisasi MD RAID, meskipun beberapa dari mereka bahkan tidak memiliki akses ke ini.  Beberapa insinyur terkemuka melakukan ini, tetapi tidak selalu, karena prosesnya tidak dijelaskan di mana pun. </li><li>  <b>Prosedurnya harus sederhana dan mudah.</b> <br>  Sulit bagi seseorang untuk menyimpan banyak langkah di kepalanya.  Status tetangga yang paling penting di Jira perlu ditampilkan di layar utama.  Anda dapat mengubah nama mereka, misalnya, Dalam proses kami memanggil Siap untuk berubah.  Dan status yang tersisa dapat disembunyikan di menu drop-down sehingga mereka tidak memanggil mata.  Tetapi lebih baik tidak membatasi orang, untuk memberikan kesempatan untuk melakukan transisi. <br>  Jelaskan nilai inovasi.  Ketika orang mengerti, mereka lebih baik menerima prosedur baru.  Sangat penting bagi kami bahwa orang tidak memanggil keseluruhan proses, tetapi mengikutinya.  Kemudian kami membangun otomatisasi ini. </li><li>  <b>Tunggu, analisis, pahami.</b> <br>  Kami membutuhkan waktu sekitar satu bulan untuk membangun prosedur, implementasi teknis, pertemuan dan diskusi.  Dan untuk implementasi - lebih dari tiga bulan.  Saya melihat bagaimana orang perlahan mulai menggunakan inovasi.  Pada tahap awal, ada banyak hal negatif.  Tetapi dia benar-benar independen dari prosedur itu sendiri, implementasi teknisnya.  Misalnya, satu administrator tidak menggunakan Jira, tetapi plugin Jira di Confluence, dan beberapa hal tidak tersedia baginya.  Menunjukkan kepadanya Jira, administrator telah meningkatkan produktivitas dan tugas secara keseluruhan, dan untuk mengganti disk. </li></ul><br><h2>  Otomasi Pengganti Drive </h2><br>  Kami pergi ke otomatisasi mengganti disk beberapa kali.  Kami sudah memiliki waktu operasi, skrip, tetapi semuanya bekerja baik secara interaktif atau dalam mode manual, mereka membutuhkan peluncuran.  Dan hanya setelah pengenalan prosedur baru, kami menyadari bahwa itu hanya karena kami hilang. <br><br>  Karena sekarang proses penggantian dibagi menjadi beberapa tahap, yang masing-masing memiliki pelaksana dan daftar tindakan, kita dapat mengaktifkan otomatisasi secara bertahap, dan tidak semuanya sekaligus.  Misalnya, langkah paling sederhana - Siap (memeriksa RAID / sinkronisasi data) dapat dengan mudah didelegasikan ke bot.  Saat bot sedikit belajar, Anda bisa memberikannya tugas yang lebih bertanggung jawab - menempatkan disk dalam rotasi, dll. <br><br><h3>  Pengaturan kebun binatang </h3><br>  Sebelum berbicara tentang bot, kami akan melakukan perjalanan singkat ke kebun binatang instalasi kami.  Pertama-tama, itu karena ukuran infrastruktur kami yang sangat besar.  Kedua, untuk setiap layanan kami mencoba memilih konfigurasi besi yang optimal.  Kami memiliki sekitar 20 model RAID perangkat keras, terutama LSI dan Adaptec, tetapi ada versi HP dan DELL yang berbeda.  Setiap pengontrol RAID memiliki utilitas manajemennya sendiri.  Serangkaian perintah dan penerbitannya mungkin berbeda dari versi ke versi masing-masing pengontrol RAID.  Di mana HW-RAID tidak digunakan, mungkin takut. <br><br>  Hampir semua instalasi baru kami lakukan tanpa cadangan disk.  Kami mencoba untuk tidak lagi menggunakan perangkat keras dan perangkat lunak RAID, karena kami memesan sistem kami di tingkat pusat data, bukan server.  Tetapi tentu saja ada banyak server lama yang perlu didukung. <br><br>  Di suatu tempat, disk di pengendali RAID membuang perangkat mentah, di suatu tempat, mereka menggunakan JBOD.  Ada konfigurasi dengan satu drive sistem di server, dan jika Anda perlu menggantinya, Anda harus memformat ulang server dengan instalasi OS dan aplikasi, dengan versi yang sama, lalu menambahkan file konfigurasi, meluncurkan aplikasi.  Ada juga banyak kelompok server di mana redundansi dilakukan bukan pada tingkat subsistem disk, tetapi langsung di aplikasi itu sendiri. <br><br>  Secara total, kami memiliki lebih dari 400 grup server unik yang menjalankan sekitar 100 aplikasi berbeda.  Untuk mencakup sejumlah besar opsi, kami membutuhkan alat otomatisasi multifungsi.  Disarankan dengan DSL sederhana, sehingga tidak hanya orang yang menulis ini dapat mendukungnya. <br><br>  Kami memilih Ansible karena tanpa agen: tidak perlu menyiapkan infrastruktur, mulai cepat.  Selain itu, ditulis dalam Python, yang diterima sebagai standar dalam tim. <br><br><h3>  Skema umum </h3><br>  Mari kita lihat skema otomatisasi umum menggunakan satu kejadian sebagai contoh.  Zabbix mendeteksi bahwa drive sdb rusak, pemicu menyala, tiket dibuat di Jira.  Administrator melihatnya, menyadari bahwa ini bukan duplikat dan bukan false positive, yaitu, Anda perlu mengubah disk, dan menerjemahkan tiket sedang berlangsung. <br><br><img src="https://habrastorage.org/webt/9s/fy/q5/9sfyq5cucem0dbbhahfd3_w7tac.png"><br>  Aplikasi DiskoBot ditulis dengan Python secara berkala polling Jira untuk tiket baru.  Ia memperhatikan bahwa tiket In progress baru telah muncul, utas terkait dipicu, yang meluncurkan buku pedoman dalam Ansible (ini dilakukan untuk setiap status di Jira).  Dalam hal ini, Persiapan2 mulai. <br><br>  Kemungkinan pergi ke host, menghapus disk dari rotasi, dan melaporkan status ke aplikasi melalui Panggilan Balik. <br><br><img src="https://habrastorage.org/webt/i2/bk/nq/i2bknqits8exw9dtr7sj4zydl58.png"><br>  Menurut hasil, bot secara otomatis mentransfer tiket ke Siap untuk berubah.  Insinyur menerima pemberitahuan dan pergi untuk mengganti disk, setelah itu ia mentransfer tiket ke Changed. <br><br><img src="https://habrastorage.org/webt/h9/m8/zw/h9m8zwfrzltmu0q1tz8opctrccu.png"><br>  Menurut skema di atas, tiket kembali ke bot, meluncurkan playbook lain, pergi ke tuan rumah dan memasukkan disk ke dalam rotasi.  Bot menutup tiket.  Hore! <br><br><img src="https://habrastorage.org/webt/cv/js/w1/cvjsw1y9qrpkra2twsx-sy4jokc.png"><br>  Sekarang mari kita bicara tentang beberapa komponen sistem. <br><br><h3>  Diskobot </h3><br>  Aplikasi ini ditulis dengan Python.  Ini memilih tiket dari Jira menurut <abbr title="Bahasa Query JIRA">JQL</abbr> .  Tergantung pada status tiket, yang terakhir sampai ke penangan yang sesuai, yang pada gilirannya meluncurkan status Playbook yang sesuai. <br><br>  Interval JQL dan polling didefinisikan dalam file konfigurasi aplikasi. <br><br><pre><code class="plaintext hljs">jira_states: investigate: jql: '… status = Open and "Disk Size" is EMPTY' interval: 180 inprogress: jql: '… and "Disk Size" is not EMPTY and "Device Name" is not EMPTY' ready: jql: '… and (labels not in ("dbot_ignore") or labels is EMPTY)' interval: 7200</code> </pre> <br>  Misalnya, di antara tiket dalam status Dalam proses, hanya yang dengan ukuran Disk dan bidang Nama perangkat yang diisi.  Nama perangkat adalah nama perangkat blok yang diperlukan untuk menjalankan playbook.  Ukuran disk diperlukan agar insinyur mengetahui ukuran disk yang diperlukan. <br><br>  Dan di antara tiket dengan status Siap, tiket dengan label dbot_ignore disaring.  Ngomong-ngomong, kami menggunakan label Jira baik untuk penyaringan seperti itu, dan untuk menandai tiket rangkap, dan mengumpulkan statistik. <br><br>  Jika playbook mogok, Jira memberikan label dbot_failed sehingga Anda dapat mengetahuinya nanti. <br><br><h3>  Interaksi dengan Ansible </h3><br>  Aplikasi berinteraksi dengan Ansible melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ansible Python API</a> .  Di playbook_executor, kami meneruskan nama file dan set variabel.  Ini memungkinkan Anda untuk menyimpan proyek Ansible dalam bentuk file yml biasa, daripada menggambarkannya dalam kode Python. <br><br>  Juga di Ansible melalui * extra_vars * nama perangkat blok, status tiket, serta callback_url, di mana kunci masalah disambungkan, digunakan - digunakan untuk panggilan balik dalam HTTP. <br><br>  Untuk setiap peluncuran, inventaris sementara dihasilkan, terdiri dari satu host dan grup yang dimiliki host ini sehingga group_vars diterapkan. <br><br>  Berikut adalah contoh tugas di mana HTTP callback diimplementasikan. <br><br>  Hasil dari buku pedoman yang kami dapat menggunakan callaback (s).  Ada dua jenis: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plugin callback yang memungkinkan</a> , ini menyediakan data hasil playbook.  Ini menjelaskan tugas yang diluncurkan, dilakukan dengan sukses atau tidak berhasil.  Callback ini disebut di akhir buku pedoman. </li><li>  Callback HTTP untuk mendapatkan informasi saat memainkan buku pedoman.  Dalam Ansible, kami melakukan permintaan POST / GET ke sisi aplikasi kami. </li></ul><br>  Melalui HTTP callback, variabel yang ditentukan selama eksekusi playbook dan yang ingin kita simpan dan gunakan dalam menjalankan selanjutnya ditransmisikan.  Kami menulis data ini dalam sqlite. <br><br>  Juga melalui HTTP callback kami meninggalkan komentar dan mengubah status tiket. <br><br><div class="spoiler">  <b class="spoiler_title">Panggilan balik HTTP</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># Make callback to Diskobot App # Variables: # callback_post_body: # A dict with follow keys. All keys are optional # msg: If exist it would be posted to Jira as comment # data: If exist it would be saved in Incident.variables # desire_state: Set desire_state for incident # status: If exist Proceed issue to that status - name: Callback to Diskobot app (jira comment/status) uri: url: "{{ callback_url }}/{{ devname }}" user: "{{ diskobot_user }}" password: "{{ diskobot_pass }}" force_basic_auth: True method: POST body: "{{ callback_post_body | to_json }}" body_format: json delegate_to: 127.0.0.1</code> </pre><br></div></div><br>  Seperti banyak jenis tugas yang sama, kami meletakkannya di file umum yang terpisah dan memasukkannya jika perlu, agar tidak berulang di buku pedoman.  Callback_ url muncul di sini, di mana kunci masalah dan nama host dilindungi.  Ketika Ansible mengeksekusi permintaan POST ini, bot menyadari bahwa itu datang sebagai bagian dari insiden semacam itu. <br><br>  Dan berikut ini adalah contoh dari buku pedoman, di mana kami menampilkan disk dari perangkat MD: <br><br><pre> <code class="plaintext hljs"> # Save mdadm configuration - include: common/callback.yml vars: callback_post_body: status: 'Ready to change' msg: "Removed disk from mdraid {{ mdadm_remove_disk.msg | comment_jira }}" data: mdadm_data: "{{ mdadm_remove_disk.removed }}" parted_info: "{{ parted_info | default() }}" when: - mdadm_remove_disk | changed - mdadm_remove_disk.removed</code> </pre><br>  Tugas ini menempatkan tiket Jira dalam status "Siap untuk berubah" dan menambahkan komentar.  Juga, variabel mdam_data menyimpan daftar perangkat md dari mana disk dihapus, dan dump parted dari parted di parted_info. <br><br>  Ketika insinyur memasukkan disk baru, kami akan dapat menggunakan variabel-variabel ini untuk mengembalikan dump partisi, serta memasukkan disk ke perangkat md dari mana itu dihapus. <br><br><h3>  Mode pemeriksaan yang dimungkinkan </h3><br>  Mengaktifkan otomatisasi menakutkan.  Karena itu, kami memutuskan untuk menjalankan semua playbook dalam mode <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dry run</a> , di mana Ansible tidak melakukan tindakan apa pun di server, tetapi hanya meniru mereka. <br><br>  Peluncuran semacam itu dijalankan melalui modul callback terpisah, dan hasil dari playbook disimpan di Jira sebagai komentar. <br><br><img src="https://habrastorage.org/webt/aa/rz/0s/aarz0srsrqqxbru88guob9spjqm.png"><br><br>  Pertama, itu diizinkan untuk memvalidasi karya bot dan buku pedoman.  Kedua, itu meningkatkan kepercayaan administrator di bot. <br><br>  Ketika kami melewati validasi dan menyadari bahwa Anda dapat menjalankan Ansible tidak hanya dalam mode dry run, kami membuat tombol Jalankan Diskobot di Jira untuk memulai buku pedoman yang sama dengan variabel yang sama pada host yang sama, tetapi dalam mode normal. <br><br>  Selain itu, tombol ini digunakan untuk me-restart playbook jika terjadi kegagalan. <br><br><h3>  Struktur Playbook </h3><br>  Saya sudah menyebutkan bahwa tergantung pada status tiket Jira, bot meluncurkan buku pedoman yang berbeda. <br><br>  Pertama, jauh lebih mudah untuk mengatur entri. <br>  Kedua, dalam beberapa kasus itu hanya perlu. <br><br>  Misalnya, saat mengganti disk sistem, pertama-tama Anda harus pergi ke sistem penyebaran, membuat tugas, dan setelah penyebaran yang benar, server akan dapat diakses melalui ssh, dan Anda dapat memasukkan aplikasi ke dalamnya.  Jika kita melakukan semua ini dalam satu buku pedoman, Ansible tidak akan dapat menjalankannya karena tidak dapat diaksesnya host. <br><br>  Kami menggunakan peran yang dimungkinkan untuk setiap grup server.  Di sini Anda dapat melihat bagaimana buku pedoman disusun di salah satunya. <br><br><img src="https://habrastorage.org/webt/ef/0o/hu/ef0ohuo0obwa1htij7o4at6dvus.png"><br><br>  Ini nyaman, karena segera jelas di mana tugas-tugas apa yang berada.  Di main.yml, yang merupakan input untuk peran Ansible, kami hanya dapat memasukkan berdasarkan status tiket atau tugas umum yang diperlukan untuk semua orang, misalnya, melewati identifikasi atau menerima token. <br><br><h4>  Investigasi.yml </h4><br>  Berlari untuk mendapatkan tiket dalam status Investigasi dan Terbuka.  Yang paling penting untuk buku pedoman ini adalah nama perangkat blok.  Informasi ini tidak selalu tersedia. <br><br>  Untuk mendapatkannya, kami menganalisis ringkasan Jira, nilai terakhir dari pemicu Zabbix.  Ini mungkin berisi nama perangkat blok - beruntung.  Atau mungkin mengandung titik mount, - maka Anda harus pergi ke server, parsing dan hitung drive yang diinginkan.  Juga, pemicu dapat mengirimkan alamat scsi atau informasi lainnya.  Tetapi itu juga terjadi bahwa tidak ada petunjuk, dan Anda harus menganalisis. <br><br>  Setelah menemukan nama perangkat blok, kami mengumpulkan informasi tentang jenis dan ukuran disk untuk mengisi kolom di Jira.  Kami juga menghapus informasi tentang vendor, model, firmware, ID, SMART, dan memasukkan semua ini ke dalam komentar di tiket Jira.  Administrator dan insinyur tidak perlu lagi mencari data ini.  :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m6/64/kr/m664krcgyi4vkc-rq0almmqv6uy.png"></div><br><br><h4>  prep2change.yml </h4><br>  Keluaran disk dari rotasi, persiapan untuk penggantian.  Tahap yang paling sulit, sangat penting.  Di sinilah Anda dapat menghentikan aplikasi saat tidak dapat dihentikan.  Atau mengeluarkan disk yang tidak memiliki cukup replika, dan dengan demikian berpengaruh pada pengguna, kehilangan beberapa data.  Di sini kami memiliki cek dan pemberitahuan terbanyak dalam obrolan. <br><br>  Dalam kasus paling sederhana, kita berbicara tentang menghapus drive dari HW / MD RAID. <br><br>  Dalam situasi yang lebih kompleks (dalam sistem penyimpanan kami), ketika cadangan dilakukan pada tingkat aplikasi, Anda harus pergi ke aplikasi menggunakan API, melaporkan output disk, menonaktifkannya dan memulai pemulihan. <br><br>  Kami sekarang secara besar-besaran bermigrasi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud</a> , dan jika server berawan, maka Diskobot mengakses cloud API, mengatakan bahwa ia akan bekerja dengan antek ini - server tempat wadah berjalan - dan meminta "migrasi semua wadah dari antek ini".  Dan pada saat yang sama itu menyalakan lampu latar sehingga insinyur segera melihat mana yang harus ditarik. <br><br><h4>  berubah.yml </h4><br>  Setelah mengganti disk, pertama-tama kami memeriksa ketersediaannya. <br><br>  Insinyur tidak selalu memasukkan disk baru, jadi kami menambahkan tanda centang untuk nilai-nilai SMART yang memuaskan kami. <br><br><div class="spoiler">  <b class="spoiler_title">Atribut apa yang kita lihat</b> <div class="spoiler_text">  Jumlah Sektor yang Direalokasi (5) &lt;100 <br>  Hitungan Sektor Tertunda Saat Ini (107) == 0 <br></div></div><br>  Jika drive gagal dalam tes, insinyur akan diberitahu tentang penggantian.  Jika semuanya beres, lampu latar mati, markup diterapkan dan disk dimasukkan ke dalam rotasi. <br><br><h4>  ready.yml </h4><br>  Kasus paling sederhana: memeriksa sinkronisasi serangan HW / SW atau mengakhiri sinkronisasi data dalam aplikasi. <br><br><h3>  API aplikasi </h3><br>  Saya menyebutkan beberapa kali bahwa bot sering mengakses API aplikasi.  Tentu saja, tidak semua aplikasi memiliki metode yang diperlukan, jadi saya harus memperbaikinya.  Berikut adalah metode paling penting yang kami gunakan: <br><ul><li>  Status  Status gugus atau disk untuk memahami apakah mungkin untuk bekerja dengannya; <br></li><li>  Mulai / hentikan.  Aktivasi-penonaktifan disk; <br></li><li>  Bermigrasi / mengembalikan.  Migrasi dan pemulihan data selama dan setelah penggantian. <br></li></ul><br><h3>  Pelajaran dari Ansible </h3><br>  Saya sangat suka Ansible.  Tetapi seringkali, ketika saya melihat berbagai proyek open source dan melihat bagaimana orang menulis buku pedoman, saya merasa sedikit takut.  Tenunan logis yang kompleks dari saat / loop, kurangnya fleksibilitas dan idempotensi karena sering menggunakan shell / perintah. <br><br>  Kami memutuskan untuk menyederhanakan semuanya sebanyak mungkin, mengambil keuntungan dari Ansible - modularity.  Pada tingkat tertinggi adalah buku pedoman, mereka dapat ditulis oleh administrator mana pun, pengembang pihak ketiga yang tahu sedikit mungkin. <br><br><pre> <code class="plaintext hljs">- name: Blink disk become: True register: locate_action disk_locate: locate: '{{ locate }}' devname: '{{ devname }}' ids: '{{ locate_ids | default(pd_id) | default(omit) }}'</code> </pre><br><br>  Jika ada logika yang sulit diimplementasikan dalam buku pedoman, kami menempatkannya dalam modul atau filter Ansible.  Skrip dapat ditulis dalam Python dan bahasa lain apa pun. <br><br>  Mereka mudah dan cepat untuk ditulis.  Sebagai contoh, modul highlight disk, contoh penggunaan yang diberikan di atas, terdiri dari 265 baris. <br><br><img width="400" height="400" src="https://habrastorage.org/webt/c4/ma/bp/c4mabpsyezbjbfp2likixvta24k.png"><br><br>  Pada tingkat terendah adalah perpustakaan.  Untuk proyek ini, kami menulis aplikasi terpisah, semacam abstraksi atas perangkat keras dan perangkat lunak RAID yang melakukan permintaan yang sesuai. <br><br><img width="400" height="400" src="https://habrastorage.org/webt/qf/vt/pr/qfvtprdi9jw2vxserynmxbrmdg8.png"><br><br>  Kekuatan terbesar Ansible adalah kesederhanaan dan buku pedoman yang dapat dipahami.  Saya percaya bahwa Anda perlu menggunakan ini dan tidak menghasilkan file yaml yang menakutkan dan sejumlah besar kondisi, kode shell dan loop. <br><br>  Jika Anda ingin mengulangi pengalaman kami dengan Ansible API, ingatlah dua hal: <br><br><ul><li>  Playbook_executor dan umumnya playbook tidak dapat habis waktu.  Ada batas waktu pada sesi ssh, tetapi tidak ada batas waktu di playbook.  Jika kami mencoba meng-unmount drive yang belum ada di sistem, playbook akan berjalan tanpa batas waktu, jadi kami harus membungkusnya dalam pembungkus terpisah dan mematikannya dengan timeout. <br></li><li>  Kemungkinan bercabang, jadi API-nya tidak aman.  Kami meluncurkan semua buku pedoman kami dan single-threaded. <br></li></ul><br>  Hasilnya, kami dapat mengotomatiskan penggantian sekitar 80% dari drive.  Secara umum, tingkat penggantian meningkat dua kali lipat.  Hari ini, administrator hanya melihat kejadian itu dan memutuskan apakah akan mengganti disk atau tidak, dan kemudian membuat satu klik. <br><br>  Tetapi sekarang kita mulai menghadapi masalah lain: beberapa administrator baru tidak tahu cara mengganti drive.  :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452110/">https://habr.com/ru/post/id452110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452094/index.html">.NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 1</a></li>
<li><a href="../id452098/index.html">Log Habr pengembang front-end: refactor dan reflex</a></li>
<li><a href="../id452102/index.html">Permainan foto untuk mereka yang menyukai drone: secara singkat tentang AirSelfie 2</a></li>
<li><a href="../id452106/index.html">Kami mengundang pembicara ke pertemuan DIY musim panas pada 16 Juni 2019</a></li>
<li><a href="../id452108/index.html">Docker: saran tidak berbahaya</a></li>
<li><a href="../id452112/index.html">CRM ++</a></li>
<li><a href="../id452114/index.html">HolyJS 2019: Pembekalan dari SEMrush (Bagian 1)</a></li>
<li><a href="../id452116/index.html">Indeks dalam PostgreSQL - 8 (RUM)</a></li>
<li><a href="../id452118/index.html">Ilmuwan memecahkan kode naskah misterius Voynich</a></li>
<li><a href="../id452122/index.html">"Pil dari iblis" bergerak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>