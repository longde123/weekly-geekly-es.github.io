<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍫 ☄️ 🤾🏼 Keamanan Aplikasi Klien: Kiat Praktis untuk Pengembang Front-End 🌊 🙋🏾 🚶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seperti yang Anda ketahui, sebagian besar serangan peretas BlackHat ditujukan untuk mengkompromikan data server aplikasi dan layanan web. Pada saat ya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keamanan Aplikasi Klien: Kiat Praktis untuk Pengembang Front-End</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445932/"><p>  Seperti yang Anda ketahui, sebagian besar serangan peretas BlackHat ditujukan untuk mengkompromikan data server aplikasi dan layanan web.  Pada saat yang sama, bagian klien diserang setidaknya hari ini.  Menurut definisi kering, setiap serangan adalah seperangkat tindakan pada bagian dari peretas yang ditujukan pada jaringan dan transfer data, data dan substitusi, infrastruktur dan fitur teknis dari penerapan aplikasi web.  Oleh karena itu, perusahaan internasional memerlukan insinyur pengembangan untuk mengambil pendekatan yang lebih bertanggung jawab dan menyeluruh terhadap keamanan aplikasi klien. </p><br><p>  Pada contoh proyek saya, saya akan berbicara tentang bagaimana aplikasi klien menyerang hari ini dan bagaimana Anda dapat menghindari ancaman ini. </p><a name="habracut"></a><br><img alt="10 Ancaman Top dari 2013 - 2017" src="https://habrastorage.org/webt/ys/zg/d7/yszgd7tqw75npl5bx9pliitikte.jpeg"><br>  <i>10 ancaman teratas untuk 2013 - 2017.</i> <br><br><p>  Seperti yang Anda lihat, di antara ancaman utama, injeksi, pemicu kesalahan, otentikasi bypass, dan data rahasia yang tidak aman menjadi yang utama.  Ancaman menggunakan komponen dengan kerentanan yang diketahui masih relevan.  Ancaman baru juga muncul: peretasan mekanisme kontrol akses, deserialisasi yang tidak aman, dan serialisasi data, pencatatan dan pemantauan yang kurang rinci. </p><br><p>  Pada tahun 2001, Mark Curfy dan Dennis Groves mendirikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OWASP</a> (Open Security Application Project Project).  Ini adalah proyek OpenSource internasional untuk bertukar pengalaman dalam memerangi kerentanan dalam aplikasi klien, di mana sejumlah besar insinyur keamanan aplikasi ikut serta.  Komunitas OWASP mengisi portal dengan banyak artikel dengan informasi kerentanan, materi pelatihan, alat untuk menguji dan memukul mundur serangan.  Serangan nyata dijelaskan, aspek mereka terungkap dan apa yang perlu dilakukan untuk mencegah ancaman dijelaskan. </p><br><p>  Untuk memahami ancaman apa yang berbahaya bagi suatu proyek, Anda perlu mengujinya secara menyeluruh.  Untuk melakukan ini, jaringan memiliki aplikasi, kerangka kerja dan layanan online yang secara otomatis mengidentifikasi kerentanan tertentu.  Untuk pengujian lokal, saya sarankan menggunakan aplikasi dan kerangka kerja, dan untuk menguji proyek dalam operasi, sangat berguna untuk menambahkan layanan online juga. </p><br><img src="https://habrastorage.org/webt/zh/c7/ll/zhc7lln_b43msp-lkz7ah0iapmw.jpeg"><br><br><p>  Tetapi bahkan jika alat pengujian tidak memberi tahu Anda dalam laporan tentang kerentanan signifikan (yang tidak mungkin), masih memperhatikan penyimpanan data sensitif dalam sistem kontrol versi, perakitan aplikasi, mekanisme otentikasi, algoritma hash kata sandi, fungsi enkripsi data rahasia, serta sistem logging dan memonitor seluruh aplikasi web.  Dalam hal ini, lebih baik memainkannya dengan aman dan tidak mempercayai otomatisasi yang membabi buta. </p><br><h2>  Git </h2><br><p>  Pertama, mari kita bicara tentang data sensitif di Git.  Idealnya, repositori rahasia yang terpisah dialokasikan untuk menyimpan data sensitif.  Dari itu, selama pertemuan untuk commissioning, data rahasia ditarik dan dijahit ke dalam aplikasi.  Saat ini, Hashicorp Vault, Keywhiz, rahasia Docker, Azure Key Vault, dan sejumlah lainnya populer. </p><br><p>  Tetapi bagaimana jika Anda tidak memiliki penyimpanan seperti itu?  Anda dapat menggunakan alat untuk menyandikan dan menyembunyikan file dengan rahasia yang akan memperluas kemampuan sistem kontrol versi. </p><br><p> Hal pertama yang terlintas dalam pikiran adalah solusi BlackBox universal.  Ini dapat digunakan dengan sistem kontrol versi apa pun, misalnya, Mercurial, Git, dll.  Selain itu, ada dua ekstensi untuk Git: git-crypt dan git-secret.  Saya sarankan menggunakan yang kedua, karena menurut saya yang paling nyaman untuk digunakan dan lebih dimengerti dalam hal deskripsi dalam dokumentasi resmi.  Setelah menginstal git-secret, Anda perlu menginisialisasi dalam repositori Git.  Ingatlah untuk menentukan ekstensi yang akan digunakan dalam file <b>.gitattributes</b> .  Selanjutnya, konfigurasikan aksesibilitas rahasia: identifikasi pengguna yang ingin Anda akses ke data sensitif.  Kemudian tambahkan file dengan data sensitif dan <code>git-secret-hide</code> melalui <code>git-secret-hide</code> .  Anda bisa mendapatkan file tersembunyi melalui <code>git-secret-reveal.</code> </p><br> <code>brew install git-secret              //  <br> git secret init                      //  <br> git secret tell your@gpg.email       &amp;nbsp//   <br> git secret add &lt;files...&gt;             //   <br> git secret hide                      &amp;nbsp//   <br> git secret reveal                    &amp;nbsp//    <br></code> <br><h2>  Paket web </h2><br><p>  Cara lain untuk menghilangkan ancaman adalah dengan mengkonfigurasi webpack dengan benar.  Untuk melindungi dari XSS, XEE, dan serangan serupa, Anda harus mempertimbangkan mematuhi kebijakan CORS (cross-origin resource sharing) dan CSP (Kebijakan Keamanan Konten).  Dalam kedua kasus, penting untuk mengikuti tajuk untuk memeriksa keaslian skrip tertentu yang digunakan dalam proyek.  Peramban memiliki mekanisme untuk memeriksa keandalan sumber tertentu, misalnya, Safari akan mengeluarkan peringatan di setiap langkah jika CORS dan CSP tidak dikonfigurasi dengan benar. </p><br><p>  Ada dua cara untuk mematuhi CORS dan CSP.  Yang pertama adalah mengonfigurasi tajuk untuk menanggapi permintaan di sisi server.  Yang kedua adalah mendaftarkan kedua kebijakan melalui meta tag dan atribut.  Metode yang terakhir direkomendasikan jika Anda memiliki pengembang back-end yang malas, mereka selalu sibuk dan mereka tidak tertarik dengan kebijakan keamanan.  Tag meta dapat didaftarkan segera saat membangun aplikasi.  Plugin seperti html-webpack-plugin, html-webpack-exclude-assets-plugin, script-ext-html-webpack-plugin, csp-html-webpack-plugin dan crypto akan membantu kami dalam hal ini.  Selain itu, jika Anda memiliki sumber daya pihak ketiga dalam proyek Anda (misalnya, tautan ke font eksternal yang digunakan dalam CSS; sumber daya yang dimuat dari CDN, dan sebagainya), maka saya sarankan untuk menggunakan plugin webpack-subresource-integrity-plugin juga.  Dengan demikian, Anda akan memberi tahu peramban bahwa sumber daya yang dimuat dalam skrip dapat diandalkan, tidak ada suntikan di dalamnya, semuanya utuh dan tidak rusak.  Dan bahkan jika seseorang menyuntikkan data berbahaya ke sumber daya, dan Anda mengunggahnya, Anda harus siap untuk ini dan melindungi proyek Anda dari ancaman tersebut. </p><br><p>  Saya ingin memberi <b>perhatian khusus</b> pada urutan di mana instance kelas untuk plugin dibuat.  Urutannya harus seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SHA256 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> CRYPTO.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update( str, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>).digest(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sha256Str = SHA256( <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() ); […] <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackPlugin({   <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'public/index.html'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptExtHtmlWebpackPlugin({    <span class="hljs-attr"><span class="hljs-attr">custom</span></span>: [{           <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>,           <span class="hljs-attr"><span class="hljs-attr">attribute</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce'</span></span>,           <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce-'</span></span> + sha256Str    }] }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackExcludeAssetsPlugin(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CspHtmlWebpackPlugin({    <span class="hljs-string"><span class="hljs-string">'base-uri'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'object-src'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'none\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'script-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'unsafe-eval\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'nonce-'</span></span> + sha256Str + <span class="hljs-string"><span class="hljs-string">'\''</span></span>],    <span class="hljs-string"><span class="hljs-string">'style-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'unsafe-inline\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>] }, {    <span class="hljs-attr"><span class="hljs-attr">devAllowUnsafe</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,    <span class="hljs-attr"><span class="hljs-attr">hashingMethod</span></span>: <span class="hljs-string"><span class="hljs-string">'sha256'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SriPlugin({    <span class="hljs-attr"><span class="hljs-attr">hashFuncNames</span></span>: [<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>, <span class="hljs-string"><span class="hljs-string">'sha384'</span></span>],    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }), […]</code> </pre><br><p>  Kemudian, selama perakitan, <code>&lt;hed&gt;</code> akan menampilkan tag meta <code>http-equiv=content-security-policy</code> .  Arahan akan ditulis dalam atribut <code>content</code> , yang mengatakan skrip dan sumber daya mana yang dapat dipercaya. </p><br><p>  Arahan <code>base-uri</code> menunjukkan URL dasar mana yang digunakan untuk memuat skrip, CSS, gambar, dan lainnya. </p><br><p>  Objek biasanya tidak memuat, jadi setel <code>none</code> ke direktif <code>object-sr</code> c. </p><br><p>  Arahan <code>script-src</code> berlaku untuk skrip JS. </p><br><p>  Jangan lupa mendaftarkan atribut bertipe <code>nnce-&lt;hshVlue&gt;</code> setiap kali.  Selain itu, hash harus dihitung menggunakan algoritma SHA256 atau SHA512. </p><br><p>  Mengenai arahan <code>style-src</code> , proyek kami memiliki kekhasan: kami menggunakan komponen-komponen gaya untuk menulis CSS untuk setiap komponen dan mengisolasinya satu sama lain.  Dan karena itu perlu untuk menentukan bahwa di dalam kita <code>style-src</code> <code>unsafe-inline</code> dan <code>self</code> digunakan dalam <code>style-src</code> , jika tidak, komponen-komponen yang ditata akan jatuh. </p><br><br><img src="https://habrastorage.org/webt/9x/di/ny/9xdinyh5msrmdszkkdayka1tqya.jpeg"><br><br><p>  Tag <code>script</code> akan secara otomatis disetel ke <code>nnce-&lt;hshVlue&gt;</code> , <code>integrity</code> dan <code>cross-origin</code> .  Mereka memberi tahu browser bahwa sumber daya diambil dari sumber yang dapat diandalkan.  Kalau tidak, jika browser melihat bahwa sumber daya tidak cocok dengan CSP atau CORS, maka itu tidak akan memuat skrip ini atau file CSS, dan itu akan menulis sesuatu di konsol seperti: <i>"Perhatikan skrip ini, ke baris ini di mana Anda menginisialisasi dia.</i>  <i>Lihat, ada yang salah! ”</i>  . </p><br><p>  Dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN</a> , OWASP, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">W3C</a> menyediakan panduan untuk menegakkan kebijakan CSP dan CORS.  Selain itu, alat pengujian penetrasi apa pun akan melaporkan kepatuhan terhadap aturan CORS dan CSP di proyek.  Kerangka kerja atau alat apa pun yang akan melakukan pengujian otomatis terhadap suatu proyek akan menunjukkan kelemahannya. </p><br><h2>  Otentikasi pengguna </h2><br><p>  Kami menggunakan OpenID Connect dan protokol Kerberos.  Standar OpenID yang cukup umum digunakan untuk mengotentikasi pengguna eksternal. </p><br><p>  Kerberos lebih cocok untuk jaringan internal, di bank itu digunakan untuk otentikasi otomatis karyawan.  Misalkan ada mesin lokal di mana seorang karyawan organisasi bekerja.  Dia mengotentikasi sekali pada mesin ini, dan kemudian dia tidak perlu memasukkan login dan kata sandi lagi di mana saja: karyawan login ke aplikasi apa pun dan sistem segera mengautentikasi itu.  Kerberos memiliki pengaturan yang halus untuk mesin lokal, dan ini sulit karena harus dikonfigurasi untuk <b>setiap komputer dan setiap browser.</b>  Jika Internet Explorer biasanya menarik pengaturan default, dan Chrome menarik pengaturan IE, maka Firefox harus mengonfigurasinya secara terpisah.  Safari di MacOS X akan menemukan pengaturan itu sendiri, tetapi untuk Safari di Windows Anda harus menentukannya secara manual. </p><br><p>  Anda perlu memeriksa aplikasi Anda di semua browser, apakah di mana-mana ia berfungsi sebagaimana mestinya.  Misalnya, jika saya bekerja di Windows, saya menginstal Safari secara lokal dan menguji proyek saya di dalamnya, dan jika saya bekerja di Mac, saya meningkatkan Windows di mesin virtual untuk menjalankan aplikasi pada versi browser yang sesuai. </p><br><p>  Otentikasi dapat diimplementasikan dalam aplikasi modern menggunakan Passport.js dan paket sesi ekspres, serta Auth0 SDK. </p><br><p>  Jika Anda tidak dapat mengembangkan layanan otentikasi melalui OpenID Connect atau protokol lain, maka gunakan lapisan proxy, seperti Auth0 dan sejenisnya, sehingga otentikasi terjadi melalui perusahaan pihak ketiga yang berspesialisasi dalam menyediakan pengguna dengan akses yang aman ke sumber daya Internet. </p><br><p>  Ketika kami memutakhirkan beberapa aplikasi ke Node.js, kami menyarankan untuk menggunakan paket Passport.js, sesi ekspres, dll. Di server.  Untuk memastikan keamanan pada klien, kami secara independen meningkatkan komponen untuk otentikasi.  Jangan lupa untuk menentukan atribut pelengkapan otomatis pada formulir otentikasi untuk mengecualikan pelengkapan otomatis bidang formulir. </p><br><h2>  Kata sandi hashing </h2><br><p>  Situs web OWASP merekomendasikan agar Anda tidak menggunakan mekanisme hashing kata sandi yang dibangun ke dalam basis data.  Untuk ini, lebih baik menggunakan paket seperti Argon2, PBKDF2, ccrypt dan bcrypt.  Dalam praktik saya, saya menggunakan Argon2 - ini adalah pembungkus untuk algoritma GCC, PGP / GPG, dll., Tetapi mengharuskan Anda untuk menginstal paket GCC terlebih dahulu.  Skema penggunaan Argon2: </p><br><br><pre> <code class="bash hljs">1.  GCC &gt;= 4.8 install $ brew install gcc</code> </pre> <br><pre> <code class="bash hljs">2.     - $ npm install -g node-gyp</code> </pre> <br><pre> <code class="bash hljs">3.   Argon2 $ npm install argon2</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ARGON <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; ARGON.generateSalt().then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">salt: string</span></span></span><span class="hljs-function">) =&gt;</span></span> {  ARGON.hash(<span class="hljs-string"><span class="hljs-string">'some-user-password'</span></span>, salt)    .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash : string</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Successfully created Argon2 hash:'</span></span>, hash);       <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> store the hash in the user database  }); }); argon2.verify( 'previously-created-argon-hash-here', 'some-user-password').then(() =&gt; {  console.log('Successful password supplied!');  // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> log the user in }).catch(() =&gt; {  console.log('Invalid password supplied!'); });</span></span></code> </pre> <br><h2>  Kebingungan </h2><br><p>  Kebingungan memungkinkan Anda untuk mengubah kode sehingga tidak dapat diuraikan menjadi komponen.  Bagaimanapun, penyerang - dan bukan hanya mereka - sangat sering menggunakan teknik reverse: programmer mengambil beberapa file JS dan mulai menganalisis sumber.  Dengan demikian, ia dapat mempelajari metode yang digunakan atau memahami mekanisme kerja skrip tertentu untuk menerapkan kode berbahaya.  Atau gunakan mekanisme ini untuk meretas aplikasi web dan melakukan serangan sembunyi-sembunyi. </p><br><p>  Peretas tidak mendapat masalah.  Pertama, mereka melakukan eksplorasi sumber daya, menentukan kerentanan dan menyerang vektor.  Misalnya, mereka memanipulasi data atau mengeksploitasi kerentanan yang terkandung dalam protokol transportasi.  Vektor serangan dapat ditujukan pada kerentanan sistem operasi tertentu, ada banyak di sistem UNIX.  Tetapi kerentanan hanya dapat digunakan jika administrator memiliki kebijakan keamanan yang dikonfigurasi dengan buruk, misalnya, salah mengatur URL yang keluar. </p><br><p>  Jadi, untuk pengintaian, reverse engineering digunakan.  Tidak mungkin untuk sepenuhnya mengecualikannya, tetapi itu bisa sangat sulit.  Untuk ini, berbagai obfuscator digunakan, dalam kasus saya - javascript-obfuscator.  Berdasarkan itu, sebuah plugin untuk webpack dibuat - webpack-obfuscator.  Juga untuk webpack dibuat obfuscator-loader.  Paket ini merekomendasikan pengaturan untuk tingkat paranoid yang berbeda: rendah, sedang dan tinggi, mereka dapat ditemukan di situs web resmi.  Jika Anda menggunakan obfuscator ini, maka ingatlah bahwa ia berfungsi sangat buruk dengan mekanisme minifikasi yang dibangun ke dalam webpack.  Jangan menggunakan minifikasi dan kebingungan bersama-sama, jika tidak obfuscator dapat sepenuhnya memecahkan kode skrip. </p><br><p>  Selain itu, obfuscator meningkatkan volume skrip dan pemuatannya.  Di sini Anda perlu memutuskan sendiri: apakah Anda meningkatkan keamanan, stabilitas dan keandalan, tetapi kehilangan kenyamanan dan kecepatan;  peduli tentang kecepatan, tetapi lupakan keselamatan, tentang mengikuti pedoman apa pun. </p><br><h2>  Logging dan Pemantauan Ancaman </h2><br><p>  Ada ancaman seperti penggunaan paket dengan kerentanan yang sudah diketahui.  Analis ancaman seperti audit npm, Snyk, dan LGTM akan membantu dalam situasi seperti itu.  Audit NPM adalah utilitas standar yang dibangun ke dalam NPM, tetapi Anda harus terus-menerus memanggil perintah ini atau datang dengan kruk.  Karena itu, saya menyarankan Anda untuk menggunakan Snyk.  Proyek ini memiliki database sendiri dengan kerentanan.  Ketika Anda memulai tes, Snyk mengakses database ini dan secara rahasia mengunggah laporan ke proyek Snyk Anda, yang tidak dapat diakses oleh orang luar.  Benar, Anda dapat memeriksa proyek Anda secara gratis hanya 300 kali, dan ketika Anda memeriksa setiap pra-komitmen, 300 upaya gratis ini berakhir dengan sangat cepat.  Oleh karena itu, lebih baik untuk menjalankan tes untuk pre-push atau pre-merge hooks. </p><br><p>  Manusia adalah kerentanan paling penting dari sistem apa pun.  Oleh karena itu, pastikan untuk memeriksa proyek sebelum mulai membangun aplikasi, karena bahkan kode sumbernya mungkin mengandung sesuatu yang berbahaya.  Adalah baik ketika hanya satu orang yang memiliki akses ke proyek, tetapi biasanya kami bekerja sebagai tim.  Bagaimana jika muncul semacam "penolong yang baik" yang memutuskan untuk meninggalkan perusahaan "dengan indah" dan meninggalkan bekas?  Ini juga harus diingat. </p><br><p>  Saya merekomendasikan menggunakan paket Snyk dari awal proyek, dan memulai pemindaian dari konsol.  Semuanya sederhana di sini: setelah instalasi, atur login dan kata sandi untuk akun, dan pengujian itu sendiri dapat dilakukan seperti ini: </p><br><ul><li>  Setelah menginstal npm i snyk —D dependensi dan menentukan “snyk”: true di package.json, jalankan: </li></ul><br><pre> <code class="bash hljs">./node_modules/.bin/snyk wizard --dev</code> </pre> <br><ul><li>  Dalam package.json tambahkan skrip dan pengaturan: </li></ul><br><pre> <code class="javascript hljs">{ ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {  ...  <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run test:jest"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"test:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk test --dev"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"prepare"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run prepare:snyk"</span></span>,  <span class="hljs-string"><span class="hljs-string">"prepare:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk protect"</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {  <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"commit-msg"</span></span>: <span class="hljs-string"><span class="hljs-string">"commitlint -E HUSKY_GIT_PARAMS"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-commit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run lint &amp;&amp; npm run test:jest"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-push"</span></span>: [    <span class="hljs-string"><span class="hljs-string">"npm run test:snyk"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run lint"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run test:jest"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run build:production"</span></span>   ],   ...  } }, <span class="hljs-string"><span class="hljs-string">"snyk"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Di atas, kami melihat cek lokal untuk ancaman keamanan.  Untuk memeriksa paket untuk ancaman yang diketahui, saya juga merekomendasikan menggunakan LGTM.  Gunakan proyek ini dalam hubungannya dengan GitHub atau Bitbucket (sampai Anda mencobanya, itu tidak perlu), dan kode akan segera diperiksa dengan setiap dorongan. </p><br><h2>  Pemantauan aplikasi </h2><br><p>  Di bidang Front-end, alat sudah mapan, alat untuk setiap selera tersedia untuk mencatat dan memantau bagian klien.  Yang paling terkenal adalah Sentry, TrackJS, dan InsightOps.  Server Sentry dapat digunakan untuk server fisiknya.  Misalnya, dalam dua proyek kami, kami menggunakan server terpisah, yang sepenuhnya dikonfigurasikan untuk mencatat operasi aplikasi.  Kami pergi ke URL dan menjatuhkan semua log di sana.  Jika kesalahan terjadi dalam aplikasi, itu dibungkus dengan blok uji coba dan dikirim ke server Sentry melalui metode paket gagak.  Semuanya sederhana dan nyaman.  Jika Anda melihat URL yang tidak jelas di Sentry yang tidak Anda daftarkan, jika Anda melihat pesan embed atau tidak jelas, maka mereka mencoba untuk memecahkan Anda.  Dalam latihan saya, ini terjadi secara teratur.  Misalnya, salah satu proyek - layanan untuk mem-bypass pemblokir iklan dan antivirus - terus-menerus mencoba untuk menangkal, memecahkannya. </p><br><p>  Untuk pemantauan, saya juga merekomendasikan menggunakan Grafana.  Penting untuk mempertimbangkan sistem kriteria dan indikator yang akan dipantau oleh sistem.  Kami mendengarkan lalu lintas, kembalinya iklan, pada tingkat rendering iklan, pada jumlah spanduk yang berasal dari Yandex, dll.  (proyek di Rambler Group).  Kami perlu memahami cara kerja Yandex dengan permintaan kami, karena ini adalah layanan pihak ketiga, yang berarti perlu dipantau, karena jika gagal, maka seluruh proyek dapat sepenuhnya runtuh. </p><br><p>  Jika Anda memantau semua komunikasi dengan layanan pihak ketiga, maka Anda akan dengan cepat menemukan kesalahan.  Ceritanya dari tempat praktik saya: kami melihat itu dari Yandex, respons iklan dengan tajam berhenti datang.  Ternyata mereka mengalami kerusakan teknis dan seluruh jaringan periklanan turun dengan ketat.  Dan bukan Yandex yang memberi tahu kami terlebih dahulu, tetapi kami memanggil mereka dan meminta mereka untuk melihat apa yang terjadi dengan layanan mereka. </p><br><p>  Apa cara terbaik untuk memonitor?  Ambil beberapa URL kecil, tulis parameter GET dan kirim permintaan GET ke URL ini.  Di sisi server, proses URL ini, tulis log ke database dan tingkatkan pemantauan ke Grafana.  Semuanya sederhana. </p><br><p>  Itu saja.  Di masa depan saya akan mencoba untuk terus menulis tentang topik melindungi aplikasi web dari ancaman.  Untuk semua orang yang telah membaca sampai akhir - Saya berharap keselamatan untuk proyek Anda))) </p><br><h3>  Daftar sumber untuk membaca topik: </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.owasp.org/index.php/Main_Page</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tproger.ru/translations/webapp-security</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">S. Hawks.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi Halaman Bahkan Lebih Cepat: keamanan</a> </p><br><p>  Seacord, Robert C. Standar pengkodean aman CERT C / Robert C. Seacord.  - 2008 </p><br><p>  Chetan Karande.  Mengamankan Aplikasi Node - 2017 </p><br><p>  Steven Palmer.  Kerentanan Aplikasi Web Mendeteksi, Mengeksploitasi, Mencegah - 2011 </p><br><p>  Robert Shimonski, Sean-Philip Oriyano.  Serangan dan Pertahanan Sisi Klien - 2012 </p><br><p>  Marcus Pinto, Dafydd Stuttard.  Buku Pegangan Peretas Aplikasi Web: Menemukan dan Memanfaatkan Kelemahan Keamanan, Edisi ke-2 - 2011 </p><br><p>  Karl Duuna.  Amankan Aplikasi Web Node.js Anda - 2015 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445932/">https://habr.com/ru/post/id445932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445920/index.html">Langsung: cara mengekang pengembangan iOS di tim besar</a></li>
<li><a href="../id445922/index.html">Mengapa menonton siaran online jika Anda dapat membaca Habr</a></li>
<li><a href="../id445924/index.html">TREASURES: ketika jam tangan pintar menjadi aneh</a></li>
<li><a href="../id445926/index.html">Program Rahasia UFO AS juga telah meneliti lubang cacing dan dimensi ekstra.</a></li>
<li><a href="../id445928/index.html">Bagaimana Kami Meningkatkan Tensorflow Melayani Produktivitas hingga 70%</a></li>
<li><a href="../id445936/index.html">Pengembangan elektronik. Tentang mikrokontroler di jari</a></li>
<li><a href="../id445940/index.html">AMA dengan Habr, v 7.0. Lemon, Donat, dan Berita</a></li>
<li><a href="../id445946/index.html">MWC: petunjuk penggunaan</a></li>
<li><a href="../id445948/index.html">Warisan dalam C ++: pemula, menengah, lanjutan</a></li>
<li><a href="../id445952/index.html">Satu triliun lajang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>