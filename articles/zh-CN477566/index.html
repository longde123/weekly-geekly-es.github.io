<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐓 🗻 👃🏻 华为云：今天PVS-Studio多云 👨🏻‍🎤 👋🏾 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本世纪，每个人都听说过云服务。 许多公司已经掌握了这一细分市场，并在各个方向上创建了他们的云服务。 我们的团队最近对将PVS-Studio代码分析器与其集成在一起也对这些服务感兴趣。 我们认为我们的普通读者已经猜到这次我们将检查哪种类型的项目。 选择取决于华为的云服务代码。 

 引言 
 如果您...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>华为云：今天PVS-Studio多云</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/477566/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ac/bd2/47b/2acbd247b999e7f8e9e45f77181e2f06.png" alt="图片2"></div><br> 在本世纪，每个人都听说过云服务。 许多公司已经掌握了这一细分市场，并在各个方向上创建了他们的云服务。 我们的团队最近对将PVS-Studio代码分析器与其集成在一起也对这些服务感兴趣。 我们认为我们的普通读者已经猜到这次我们将检查哪种类型的项目。 选择取决于华为的云服务代码。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 如果您跟随PVS-Studio团队，您可能会注意到，最近我们对云技术非常感兴趣。 我们已经发表了与该主题相关的几篇文章： <br><br><ul><li>  <a href="https://www.viva64.com/ru/b/0670/">PVS-Studio走向云端：Azure DevOps</a> </li><li>  <a href="https://www.viva64.com/ru/b/0636/">PVS-Studio走向乌云：Travis CI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0676/">PVS-Studio走向云端：CircleCI</a> </li><li>  <a href="https://www.viva64.com/ru/b/0686/">PVS-Studio走向云端：GitLab CI / CD</a> </li></ul><br> 因此，当我为下一篇文章选择另一个有趣的项目时，我收到了一封来自<a href="https://www.huawei.com/en/">华为</a>的工作邀请<a href="https://www.huawei.com/en/">函</a> 。 当收集有关该公司的信息时，事实证明它们拥有自己的云服务，但主要的是这些服务的源代码可在GitHub上免费获得。 这是本文选择该公司的主要原因。 正如一位中国圣贤所说：“事故并非偶然。” <br><br> 现在介绍一下我们的分析仪。  PVS-Studio是静态代码分析器，用于识别用C，C ++，C＃和Java编写的程序的源代码中的错误和漏洞。 该分析仪可在Windows，Linux和macOS平台上运行。 除了用于诸如Visual Studio或IntelliJ IDEA这样的经典开发环境的插件之外，该分析仪还可以与SonarQube和Jenkins集成： <br><br><ul><li>  <a href="https://www.viva64.com/ru/m/0037/">将PVS-Studio分析结果集成到SonarQube中</a> </li><li>  <a href="https://www.viva64.com/ru/m/0048/">在詹金斯推出PVS-Studio</a> </li></ul><br><h2> 项目分析 </h2><br> 在搜索文章的过程中，我发现华为有一个<a href="https://developer.huaweicloud.com/en-us">开发人员中心</a> ，您可以在该<a href="https://developer.huaweicloud.com/en-us">中心</a>获取有关其云服务的信息，指南和源代码。 各种各样的编程语言被用来创建这些服务，但是诸如Go，Java和Python之类的语言却是最受欢迎的。 <br><br> 由于我专门研究Java，因此相应地选择了项目。 本文分析的项目的来源可以在GitHub存储库<a href="https://github.com/huaweicloud/">huaweicloud中获得</a> 。 <br><br> 为了分析项目，我只需要执行一些操作： <br><br><ul><li> 从资源库中获取项目； </li><li> 使用<a href="https://www.viva64.com/ru/m/0044/">说明</a>启动Java分析器，并在每个项目上启动分析。 </li></ul><br> 在分析了项目之后，我们仅选择了我要注意的三个项目。 这是由于剩余Java项目的大小太小所致。 <br><br> 项目分析结果（警告数量和文件数量）： <br><br><ul><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java">huaweicloud-sdk-java</a> ：31-高，2-中和16-低，2700 +个文件。 </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-dis-agent">huaweicloud-dis-agent</a> ：7-高，6-中和6-低，100多个文件。 </li><li>  <a href="https://github.com/huaweicloud/huaweicloud-sdk-java-dis">huaweicloud-sdk-java-dis</a> ：15-高，6-中和1​​6-低，270 +个文件。 </li></ul><br> 几乎没有警告，因此一般来说我们可以说代码的质量很好。 此外，并非所有操作都是有效的错误。 这是由于以下事实：分析器有时没有足够的信息来区分正确的代码和错误的代码。 因此，借助从用户那里收到的信息，分析仪的诊断每天都在改进。 另请参阅文章“ <a href="https://www.viva64.com/ru/b/0488/">静态分析器如何以及为什么与误报作斗争</a> ”。 <br><br> 在分析项目的过程中，我选择了最有趣的警告，本文将对此进行讨论。 <br><br><h2> 字段初始化顺序 </h2><br>  <a href="https://www.viva64.com/ru/w/v6050/">V6050存在</a>类初始化周期。 在初始化“ LOG”之前出现“ INSTANCE”的初始化。  UntrustedSSL.java（32），UntrustedSSL.java（59），UntrustedSSL.java（33） <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br> 如果<i>UntrustedSSL</i>类的构造函数中发生任何异常，则使用<i>LOG</i>记录器将有关此异常的信息记录在<i>catch块中</i> 。 但是，由于静态字段的初始化顺序，初始化<i>INSTANCE</i>字段时的<i>LOG</i>尚未初始化。 因此，在构造函数中记录异常信息时，将引发<i>NullPointerException</i> 。 此异常是导致另一个<i>ExceptionInInitializerError异常</i>的原因，如果在初始化静态字段时发生<i>异常</i> ，则会引发该异常。 解决上述问题所需要做的就是将<i>LOG</i>初始化放在<i>INSTANCE</i>初始化之前。 <br><br><h2> 看不见的错字 </h2><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a>变量'this.metricSchema'被分配给它自己。  OpenTSDBSchema.java（72） <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenTSDBSchema</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JsonProperty</span></span>(<span class="hljs-string"><span class="hljs-string">"metric"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SchemaField&gt; metricSchema; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMetricsSchema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;SchemaField&gt; metricsSchema)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.metricSchema = metricSchema; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } public void setMetricSchema(List&lt;SchemaField&gt; metricSchema) { this.metricSchema = metricSchema; } .... }</span></span></code> </pre> <br> 两种方法都设置<i>metricSchema</i>字段，但是方法名称的不同之处在于一个's'字符。 程序员根据方法的名称来命名这些方法的参数。 结果，在分析器所指向的行中， <i>向其</i>自身分配了<i>metricSchema</i>字段，并且未使用<i>metricsSchema</i>方法的参数。 <br><br>  <a href="https://www.viva64.com/ru/w/v6005/">V6005</a>变量“挂起”已分配给自身。  SuspendTransferTaskRequest.java（77） <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuspendTransferTaskRequest</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> suspend; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ suspend = suspend; } .... }</code> </pre> <br> 这是一个与粗心大意有关的平庸错误，由于该错误会导致将参数<i>挂起</i>分配给自身。 结果，隐含地，到达的参数的值将不会分配给<i>suspend</i>字段。 正确地： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setSuspend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> suspend)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.suspend = suspend; }</code> </pre> <br><h2> 预定条件 </h2><br> 经常发生的是， <a href="https://www.viva64.com/ru/w/v6007/">V6007</a>规则在警告数量方面处于领先地位。 <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a>表达式“ firewallPolicyId == null”始终为false。  FirewallPolicyServiceImpl.java（125） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FirewallPolicy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeFirewallRuleFromPolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String firewallPolicyId, String firewallRuleId)</span></span></span><span class="hljs-function"> </span></span>{ checkNotNull(firewallPolicyId); checkNotNull(firewallRuleId); checkState(!(firewallPolicyId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; firewallRuleId == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-string"><span class="hljs-string">"Either a Firewall Policy or Firewall Rule identifier must be set"</span></span>); .... }</code> </pre> <br> 在此方法中，用<i>checkNotNull</i>方法检查参数是否为<i>空</i> ： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@CanIgnoreReturnValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkNotNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T reference)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reference == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference; } }</code> </pre> <br> 使用<i>checkNotNull</i>方法检查参数后，可以100％确保传递给此方法的参数不为<i>null</i> 。 由于<i>removeFirewallRuleFromPolicy</i>方法的两个参数都由<i>checkNotNull</i>方法<i>检查</i> ，因此再次检查参数是否为<i>空</i> <i>值</i>是没有意义的。 但是，将表达式作为第一个参数传递到<i>checkState</i>方法，其中将重新检查<i>firewallPolicyId</i>和<i>firewallRuleId</i>参数是否为<i>null</i> 。 <br><br> 对<i>firewallRuleId</i>发出类似的警告： <br><br><ul><li>  V6007表达式“ firewallRuleId == null”始终为false。  FirewallPolicyServiceImpl.java（125） </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a>表达式'filteringParams！= Null'始终为true。  NetworkPolicyServiceImpl.java（60） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Invocation&lt;NetworkServicePolicies&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildInvocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; filteringParams)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> servicePoliciesInvocation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filteringParams != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return servicePoliciesInvocation; }</span></span></code> </pre> <br> 在此方法中，如果参数<i>filterParams</i>为<i>null</i> ，则该方法将退出并返回一个值。 因此，分析仪所指向的测试将始终是正确的，这意味着该测试没有意义。 <br><br> 类似的情况发生在13个类中： <br><br><ul><li>  V6007表达式'filteringParams！= Null'始终为true。  PolicyRuleServiceImpl.java（58） </li><li>  V6007表达式'filteringParams！= Null'始终为true。  GroupServiceImpl.java（58） </li><li>  V6007表达式'filteringParams！= Null'始终为true。  ExternalSegmentServiceImpl.java（57） </li><li>  V6007表达式'filteringParams！= Null'始终为true。  L3policyServiceImpl.java（57） </li><li>  V6007表达式'filteringParams！= Null'始终为true。  PolicyRuleSetServiceImpl.java（58） </li><li> 等等... </li></ul><br><h2> 空参考 </h2><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a>可能会取消引用'm.blockDeviceMapping'。  NovaServerCreate.java（390） <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ServerCreateBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BlockDeviceMappingCreate blockDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blockDevice != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; m.blockDeviceMapping == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m.blockDeviceMapping = Lists.newArrayList(); } m.blockDeviceMapping.add(blockDevice); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return this; }</span></span></code> </pre> <br> 在此方法中，如果<i>blockDevice</i>参数为<i>null，</i> <i>则</i>不会发生<i>m.blockDeviceMapping</i>参考字段的初始化。 仅在此方法中初始化此字段，因此，在调用<i>add</i>方法时， <i>m.blockDeviceMapping</i>字段将引发<i>NullPointerException</i> 。 <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a>函数'&lt;init&gt;'中'FileId.get（path）'的潜在空引用。  TrackedFile.java（140），TrackedFile.java（115） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileFlow&lt;?&gt; flow, Path path)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(flow, path, FileId.get(path), ....); }</code> </pre> <br> 静态方法<i>FileId.get（路径）</i>的结果作为第三个参数传递给<i>TrackedFile</i>类的构造函数。 但是此方法可以返回<i>null</i> ： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FileId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Files.exists(file)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } .... }</code> </pre> <br> 在通过<i>this</i>调用的构造函数中， <i>id</i>参数在第一次使用之前不会改变： <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., ...., FileId id, ....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... FileId newId = FileId.get(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!id.equals(newId)) { .... } }</code> </pre> <br> 因此，如果将<i>null</i>作为第三个参数传递给该方法，则将发生异常。 <br><br> 在另一种情况下，也会发生类似的情况： <br><br><ul><li>  V6008可能会取消引用“缓冲区”。  PublishingQueue.java（518） </li></ul><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008</a>可能会取消引用“ dataTmpFile”。  CacheManager.java（91） <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return ; } } .... }</span></span></code> </pre> <br> 再次是NPE。 条件语句中的许多检查允许<i>dataTmpFile</i>对象为null以便进一步取消引用。 我认为这里有两种错别字，检查实际上应该是这样的： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2> 子字符串和负数 </h2><br>  <a href="https://www.viva64.com/ru/w/v6009/">V6009</a> “子字符串”功能可以接收“ -1”值，而预期为非负值。 检查参数：2. RemoveVersionProjectIdFromURL.java（37） <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String url)</span></span></span><span class="hljs-function"> </span></span>{ String urlRmovePojectId = url.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, url.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urlRmovePojectId.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, urlRmovePojectId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)); }</code> </pre> <br> 可以理解，URL是作为字符串传递给此方法的，未经任何方式验证。 使用<i>lastIndexOf</i>方法将该字符串修剪几次之后。 如果<i>lastIndexOf</i>在字符串中找不到匹配项，则将返回-1。 这将抛出<i>StringIndexOutOfBoundsException</i> ，因为<i>substring</i>方法的参数必须为非负数。 为了使该方法正常工作，必须添加输入参数的验证或验证<i>lastIndexOf</i>方法的结果不是负数。 <br><br> 这是发生此情况的其他一些地方： <br><br><ul><li>  V6009“子字符串”功能可以接收“ -1”值，而预期为非负值。 检查参数：2. RemoveProjectIdFromURL.java（37） </li><li>  V6009“子字符串”功能可以接收“ -1”值，而预期为非负值。 检查参数：2. RemoveVersionProjectIdFromURL.java（38） </li></ul><br><h2> 被遗忘的结果 </h2><br>  <a href="https://www.viva64.com/ru/w/v6010/">V6010</a>需要使用功能“ concat”的返回值。  AKSK.java（278） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildCanonicalHost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(URL url)</span></span></span><span class="hljs-function"> </span></span>{ String host = url.getHost(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = url.getPort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> host; }</code> </pre> <br> 在编写此代码时，没有考虑到调用<i>concat</i>方法不会更改<i>主机</i>字符串，这是因为<i>String</i>类型的对象是不可变性的。 为了使该方法正常工作，必须将<i>concat</i>方法的结果分配给<i>if</i>块中的<i>主机</i>变量。 正确地： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (port &gt; -<span class="hljs-number"><span class="hljs-number">1</span></span>) { host = host.concat(<span class="hljs-string"><span class="hljs-string">":"</span></span> + Integer.toString(port)); }</code> </pre> <br><h2> 未使用的变量 </h2><br>  <a href="https://www.viva64.com/ru/w/v6021/">V6021</a>不使用变量“ url”。  TriggerV2Service.java（95） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ActionResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAllTriggersForFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String functionUrn)</span></span></span><span class="hljs-function"> </span></span>{ checkArgument(!Strings.isNullOrEmpty(functionUrn), ....); String url = ClientConstants.FGS_TRIGGERS_V2 + ClientConstants.URI_SEP + functionUrn; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deleteWithResponse(uri(triggersUrlFmt, functionUrn)).execute(); }</code> </pre> <br> 在此方法中，初始化后不使用<i>url</i>变量。 很有可能，应该将<i>url</i>变量作为第二个参数而不是<i>functionUrn</i>传递给<i>uri</i>方法，因为变量<i>functionUrn</i>涉及<i>url</i>变量的初始化。 <br><br><h2> 构造函数中未使用的参数 </h2><br>  <a href="https://www.viva64.com/ru/w/v6022/">V6022</a>在构造函数主体内部未使用参数'returnType'。  HttpRequest.java（68） <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HttpReQuest</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ .... Class&lt;R&gt; returnType; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HttpRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., Class&lt;R&gt; returnType)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// &lt;= { this.endpoint = endpoint; this.path = path; this.method = method; this.entity = entity; } .... public Class&lt;R&gt; getReturnType() { return returnType; } .... }</span></span></span></span></code> </pre> <br> 在此构造函数中，他们忘记了使用<i>returnType</i>参数，并将其值分配给<i>returnType</i>字段。 因此，在调用<i>getReturnType</i>方法时，此构造方法创建的对象将返回默认值<i>null</i> ，尽管它最有可能旨在获取先前传递给构造方法的对象。 <br><br><h2> 相同的功能 </h2><br>  <a href="https://www.viva64.com/ru/w/v6032/">V6032</a>方法“启用”的主体完全等同于另一种方法“禁用”的主体，这很奇怪。  ServiceAction.java（32），ServiceAction.java（36） <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String binary; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String host; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServiceAction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.binary = binary; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.host = host; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ServiceAction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String binary, String host)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// &lt;= return new ServiceAction(binary, host); } public static ServiceAction disable(String binary, String host) { // &lt;= return new ServiceAction(binary, host); } .... }</span></span></code> </pre> <br> 存在两个相同的方法不是一个错误，但是两个方法执行相同操作的事实至少很奇怪。 查看上述方法的名称，我们可以假定它们执行相反的操作。 实际上，这两种方法都做同样的事情-它们创建并返回一个<i>ServiceAction</i>对象。 最有可能的是， <i>disable</i>方法是通过复制<i>enable</i>方法的代码创建的，但是却忘记了更改方法主体。 <br><br><h2> 忘了检查主要的东西 </h2><br>  <a href="https://www.viva64.com/ru/w/v6060/">V6060</a>在对null进行验证之前，已使用“ params”参考。  DomainService.java（49），DomainService.java（46） <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Domains </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Map&lt;String, String&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_size"</span></span>), ....); Preconditions.checkNotNull(params.get(<span class="hljs-string"><span class="hljs-string">"page_number"</span></span>), ....); Invocation&lt;Domains&gt; domainInvocation = get(Domains.class, uri(<span class="hljs-string"><span class="hljs-string">"/domains"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (params != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... } return domainInvocation.execute(this.buildExecutionOptions(Domains.class)); }</span></span></code> </pre> <br> 在这种方法中，我们决定检查<i>Map</i>类型结构的内容是否存在<i>空</i>不等式。 为此， <i>params</i>参数调用<i>get</i>方法两次，其结果传递到<i>checkNotNull</i>方法。 一切似乎合乎逻辑，但无论如何！ 在<i>if中</i> ，检查<i>params</i>参数是否为<i>null</i> 。 之后，可以假定输入参数可以为<i>null</i> ，但是在此检查之前，已经对<i>params</i>调用了<i>get</i>方法两次。 如果将<i>null</i>作为参数传递给此方法，则第一次调用<i>get</i>方法时，将引发异常。 <br><br> 在另外三个地方也会发生类似的情况： <br><br><ul><li>  V6060在对null进行验证之前，已使用“ params”参考。  DomainService.java（389），DomainService.java（387） </li><li>  V6060在对null进行验证之前，已使用“ params”参考。  DomainService.java（372），DomainService.java（369） </li><li>  V6060在对null进行验证之前，已使用“ params”参考。  DomainService.java（353），DomainService.java（350） </li></ul><br><h2> 结论 </h2><br> 如今，现代大型公司离不开使用云服务。 大量的人使用这些服务，因此，即使是服务中的最轻微的错误也可能导致许多人的问题，以及导致公司更正此错误后果的额外费用。 在开发过程中，始终必须考虑人为因素，因为任何人迟早都会犯错误，本文就是一个例子。 这就是为什么您应该使用所有可能的工具来提高代码质量的原因。 <br><br>  PVS-Studio一定会通知华为其云服务检查结果，以便该公司的开发人员可以更详细地研究它们。 <br><br> 本文中演示的一次性使用静态代码分析不能显示其所有优点。 有关如何正确使用静态分析的更多详细信息，请参见<a href="https://www.viva64.com/ru/b/0594/">此处</a>和<a href="https://www.viva64.com/ru/b/0639/">此处</a> 。 您可以在<a href="https://www.viva64.com/ru/pvs-studio-download/">此处</a>下载PVS-Studio分析仪。 <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/477558/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Valery Komarov。  <a href="https://habr.com/en/company/pvs-studio/blog/477558/">华为云：如今PVS-Studio多云</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477566/">https://habr.com/ru/post/zh-CN477566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477554/index.html">.ORG域名区域出售给一家私人公司。 公众呼吁ICANN终止合同</a></li>
<li><a href="../zh-CN477558/index.html">华为云：今天PVS-Studio多云</a></li>
<li><a href="../zh-CN477560/index.html">使用SwiftUI改变心态</a></li>
<li><a href="../zh-CN477562/index.html">游戏界面设计，画一包图标</a></li>
<li><a href="../zh-CN477564/index.html">复杂的客户：如何保护您的团队免受他们的侵害</a></li>
<li><a href="../zh-CN477568/index.html">该服务很容易无条件退货。 俄罗斯邮政</a></li>
<li><a href="../zh-CN477578/index.html">如何选择编程语言来创建Android应用程序</a></li>
<li><a href="../zh-CN477580/index.html">Web开发的最佳PHP框架</a></li>
<li><a href="../zh-CN477584/index.html">永恒的经典：现代动作游戏应该向DOOM学习什么</a></li>
<li><a href="../zh-CN477590/index.html">嵌入代码和盗版软件的危险</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>