<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•à üôà üöù Laufende Teams bei der Bereitstellung einer neuen Anwendungsversion f√ºr Kubernetes üçó ü§æüèΩ üë©üèº‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In unserer Praxis stehen wir h√§ufig vor der Aufgabe, Client-Anwendungen f√ºr die Ausf√ºhrung auf Kubernetes anzupassen. Bei der Ausf√ºhrung dieser Arbeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laufende Teams bei der Bereitstellung einer neuen Anwendungsversion f√ºr Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476320/"><img src="https://habrastorage.org/webt/bl/a1/wq/bla1wqhxnafiftfwcg0s3vsyvxe.png"><br><br>  In unserer Praxis stehen wir h√§ufig vor der Aufgabe, Client-Anwendungen f√ºr die Ausf√ºhrung auf Kubernetes anzupassen.  Bei der Ausf√ºhrung dieser Arbeiten treten einige typische Probleme auf.  Wir haben k√ºrzlich eine davon im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lokale Dateien beim √úbertragen einer Anwendung auf Kubernetes behandelt</a> , und die andere, die bereits mit CI / CD-Prozessen verkn√ºpft ist, wird in diesem Artikel beschrieben. <br><br><h2>  Beliebige Befehle mit Helm und werf </h2><br>  Eine Anwendung besteht nicht nur aus Gesch√§ftslogik und Daten, sondern auch aus einer Reihe beliebiger Befehle, die f√ºr eine erfolgreiche Aktualisierung ausgef√ºhrt werden m√ºssen.  Dies k√∂nnen zum Beispiel Migrationen f√ºr Datenbanken, "Kellner" f√ºr die Verf√ºgbarkeit externer Ressourcen, einige Transcoder oder Entpacker, Registrare in der externen Dienstermittlung sein - Sie k√∂nnen verschiedene Aufgaben in verschiedenen Projekten erf√ºllen. <br><br>  Was bietet Kubernetes, um solche Probleme zu l√∂sen? <a name="habracut"></a>  Kubernetes kann Container als Pods ausf√ºhren. Daher besteht die Standardl√∂sung darin, einen Befehl von einem Image aus auszuf√ºhren.  Zu diesem Zweck verf√ºgt Kubernetes √ºber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Job-Grundelement</b></a> , mit dem Sie Pods mit Anwendungscontainern ausf√ºhren und den Abschluss dieses Pods √ºberwachen k√∂nnen. <br><br>  <b>Helm</b> geht noch einen Schritt weiter und schl√§gt vor, Job's in verschiedenen Phasen des Bereitstellungsprozesses zu starten.  Es handelt sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm-Hooks,</a> mit denen Sie Job vor oder nach dem Aktualisieren von Ressourcenmanifesten ausf√ºhren k√∂nnen.  Nach unserer Erfahrung ist dies eine hervorragende Helm-Funktion, mit der Bereitstellungsaufgaben gel√∂st werden k√∂nnen. <br><br>  Es ist jedoch nicht m√∂glich, aktuelle Informationen zum Status von Objekten w√§hrend des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Rollouts</b></a> in Helm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>abzurufen.</b></a> Daher verwenden wir das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>werf</b></a> , mit dem Sie den Status von Ressourcen w√§hrend des Rollouts direkt vom CI-System aus √ºberwachen und, falls dies nicht erfolgreich ist, schnell einen Ausfall diagnostizieren k√∂nnen. <br><br>  Wie sich herausstellte, schlie√üen sich diese n√ºtzlichen Features Helm und werf manchmal gegenseitig aus, aber es gibt immer einen Ausweg.  √úberlegen Sie, wie Sie den Status von Ressourcen √ºberwachen und beliebige Befehle am Beispiel von Migrationen ausf√ºhren k√∂nnen. <cut></cut><br><br><h2>  Ausf√ºhren von Migrationen vor der Ver√∂ffentlichung </h2><br>  Ein wesentlicher Bestandteil der Version einer Datenbankanwendung ist die Aktualisierung des Datenschemas.  Die Standardbereitstellung f√ºr Anwendungen, die Migrationen durch Ausf√ºhren eines separaten Befehls anwenden, umfasst die folgenden Schritte: <br><br><ol><li>  Aktualisierung der Codebasis; </li><li>  Beginn der Migration; </li><li>  Umschalten des Datenverkehrs auf die neue Version der Anwendung. </li></ol><br>  Innerhalb von Kubernetes sollte der Prozess derselbe sein, aber angepasst an das, was wir brauchen: <br><br><ol><li>  Starten Sie einen Container mit einem neuen Code, der m√∂glicherweise eine neue Gruppe von Migrationen enth√§lt. </li><li>  Starten Sie den Migrationsprozess, bevor Sie die Version der Anwendung aktualisieren. </li></ol><br>  Ziehen Sie die Option in Betracht, wenn <b>die Datenbank f√ºr die Anwendung bereits ausgef√ºhrt wird</b> und wir sie nicht als Teil der Version bereitstellen m√ºssen, mit der die Anwendung bereitgestellt wird.  Zwei Haken eignen sich zum Anwenden von Migrationen: <br><br><ul><li>  <code>pre-install</code> - Funktioniert beim ersten Helm-Release der Anwendung, nachdem alle Vorlagen verarbeitet wurden, jedoch bevor Ressourcen in Kubernetes erstellt werden. </li><li>  <code>pre-upgrade</code> - Funktioniert bei der Aktualisierung der Helm-Version und wird wie bei der <code>pre-install</code> , nachdem die Vorlagen verarbeitet wurden, jedoch bevor Ressourcen in Kubernetes erstellt werden. </li></ul><br>  Jobbeispiel mit Helm und den beiden genannten Haken: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ .Chart.Name }}-apply-migrations annotations: "helm.sh/hook": pre-install,pre-upgrade spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ .Chart.Name }}-apply-migrations spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>Hinweis</b> : Die obige YAML-Vorlage wurde unter Ber√ºcksichtigung der Besonderheiten von werf erstellt.</i>  <i>Um es an einen "sauberen" Helm anzupassen, reicht es aus:</i> <br><br><ul><li>  <i>Ersetze <code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code> in das <code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code> Container-Image ein.</i> </li><li>  <i>l√∂sche die Zeile <code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code> , der im <code>env</code> Schl√ºssel angegeben ist.</i> </li></ul><br>  Daher muss diese Helm-Vorlage zum Verzeichnis <code>.helm/templates</code> hinzugef√ºgt werden, das bereits die restlichen Release-Ressourcen enth√§lt.  Wenn <code>werf deploy --stages-storage :local</code> aufgerufen wird, werden zuerst alle Vorlagen verarbeitet und dann in den Kubernetes-Cluster geladen. <br><br><h2>  Starten von Migrationen w√§hrend des Freigabeprozesses </h2><br>  Die obige Option impliziert die Verwendung von Migrationen f√ºr den Fall, dass die Datenbank bereits ausgef√ºhrt wird.  Aber was ist, wenn wir die Zweig√ºberpr√ºfung f√ºr die Anwendung einf√ºhren m√ºssen und die <b>Datenbank mit der Anwendung</b> in einer Version eingef√ºhrt wird? <br><br>  <i><b>NB</b> : Beim Rollout in die Produktionsumgebung kann ein √§hnliches Problem auftreten, wenn Sie Service mit einem Endpunkt verwenden, der die IP-Adresse der Datenbank enth√§lt, um eine Verbindung zur Datenbank herzustellen.</i> <br><br>  In diesem Fall sind die Hooks <code>pre-install</code> und <code>pre-upgrade</code> f√ºr uns nicht geeignet, da die Anwendung versucht, Migrationen auf die Datenbank anzuwenden, die <i>noch nicht vorhanden ist</i> .  Daher m√ºssen <i>nach</i> der Ver√∂ffentlichung Migrationen durchgef√ºhrt werden. <br><br>  Mit Helm ist eine solche Aufgabe m√∂glich, da <i>der</i> Status von Anwendungen <i>nicht √ºberwacht wird</i> .  Nach dem Laden von Ressourcen in Kubernetes werden Post-Hooks <i>immer</i> ausgel√∂st: <br><br><ul><li>  <code>post-install</code> - nach dem Laden aller Ressourcen in K8s beim ersten Release; </li><li>  <code>post-upgrade</code> - nach dem Aktualisieren aller Ressourcen in K8s beim Aktualisieren der Version. </li></ul><br>  Wie bereits erw√§hnt, <b>verf√ºgt werf</b> w√§hrend der Ver√∂ffentlichung <b>√ºber ein Ressourcenverfolgungssystem</b> .  Ich werde darauf noch etwas n√§her eingehen: <br><br><ul><li>  F√ºr das Tracking nutzt werf die Funktionen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubedog-</a> Bibliothek, √ºber die wir bereits im Blog gesprochen haben. </li><li>  Mit dieser Funktion in werf k√∂nnen wir den Status der Freigabe eindeutig bestimmen und Informationen zum erfolgreichen oder nicht erfolgreichen Abschluss der Bereitstellung in der Schnittstelle des CI / CD-Systems anzeigen. </li><li>  Ohne diese Informationen kann nicht √ºber eine Automatisierung des Freigabeprozesses gesprochen werden, da die erfolgreiche Erstellung von Ressourcen im Kubernetes-Cluster nur eine der Phasen ist.  Beispielsweise kann es sein, dass die Anwendung aufgrund einer falschen Konfiguration oder eines Netzwerkproblems nicht gestartet wird. Um dies jedoch nach dem <code>helm upgrade</code> , m√ºssen Sie zus√§tzliche Schritte ausf√ºhren. </li></ul><br>  Nun zur√ºck zur Anwendung von Migrationen auf Helm-Post-Hooks.  Die Probleme, auf die wir gesto√üen sind: <br><br><ul><li>  Viele Anwendungen pr√ºfen den Status der Schaltung in der Datenbank, bevor sie auf die eine oder andere Weise gestartet werden.  Ohne neue Migrationen kann die Anwendung daher m√∂glicherweise nicht gestartet werden. </li><li>  Da werf standardm√§√üig sicherstellt, dass sich alle Objekte im Status <code>Ready</code> , funktionieren Post-Hooks nicht und Migrationen schlagen fehl. </li><li>  Das Verfolgen von Objekten kann durch zus√§tzliche Anmerkungen deaktiviert werden. In diesem Fall k√∂nnen jedoch keine zuverl√§ssigen Informationen √ºber die Ergebnisse der Bereitstellung abgerufen werden. </li></ul><br>  Als Ergebnis kamen wir zu folgendem: <br><br><ul><li>  Jobs werden vor den Hauptressourcen erstellt, sodass <b>f√ºr Migrationen keine Helm-Hooks verwendet werden m√ºssen</b> . </li><li>  Ein Job mit Migrationen muss jedoch bei jeder Bereitstellung ausgef√ºhrt werden.  Zu diesem <b>Zweck muss Job einen eindeutigen Namen</b> (zuf√§llig) haben. In diesem Fall ist dies f√ºr Helm jedes Mal ein neues Objekt in der Version, das in Kubernetes erstellt wird. </li><li>  Bei einem solchen Start macht es keinen Sinn, sich Sorgen zu machen, dass sich Job mit Migrationen ansammelt, da alle von ihnen eindeutige Namen haben und der vorherige Job mit einer neuen Version gel√∂scht wird. </li><li>  <b>Ein Job mit Migrationen muss √ºber einen Init-Container verf√ºgen</b> , der die Verf√ºgbarkeit der Datenbank √ºberpr√ºft. Andernfalls wird die Bereitstellung gel√∂scht (Job f√§llt auf den Init-Container). </li></ul><br>  Die resultierende Konfiguration sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>NB</b> : Genau genommen werden Init-Container zur √úberpr√ºfung der Datenbankverf√ºgbarkeit sowieso am besten verwendet.</i> <br><br><h2>  Ein Beispiel f√ºr eine universelle Vorlage f√ºr alle Bereitstellungsvorg√§nge </h2><br>  Die Vorg√§nge, die w√§hrend des Releases ausgef√ºhrt werden m√ºssen, k√∂nnen jedoch l√§nger dauern als der Start der bereits erw√§hnten Migrationen.  Sie k√∂nnen die Ausf√ºhrungsreihenfolge von Job nicht nur √ºber die Arten von Hooks steuern, sondern auch, <b>indem Sie jedem von ihnen eine Gewichtung zuweisen</b> - √ºber die Annotation <code>helm.sh/hook-weight</code> .  Hooks werden nach Gewicht in aufsteigender Reihenfolge und bei gleichem Gewicht nach Ressourcennamen sortiert. <br><br>  Bei einer gro√üen Anzahl von Jobs ist es praktisch, eine universelle Vorlage f√ºr Jobs zu <code>values.yaml</code> und die Konfiguration in die <code>values.yaml</code> .  Letzteres k√∂nnte so aussehen: <br><br><pre> <code class="plaintext hljs">deploy_jobs: - name: migrate command: '["/usr/bin/php7.2", "artisan", "migrate", "--force"]' activeDeadlineSeconds: 120 when: production: 'pre-install,pre-upgrade' staging: 'pre-install,pre-upgrade' _default: '' - name: cache-clear command: '["/usr/bin/php7.2", "artisan", "responsecache:clear"]' activeDeadlineSeconds: 60 when: _default: 'post-install,post-upgrade'</code> </pre> <br>  ... und die Vorlage selbst sieht so aus: <br><br><pre> <code class="plaintext hljs">{{- range $index, $job := .Values.deploy_jobs }} --- apiVersion: batch/v1 kind: Job metadata: name: {{ $.Chart.Name }}-{{ $job.name }} annotations: "helm.sh/hook": {{ pluck $.Values.global.env $job.when | first | default $job.when._default }} "helm.sh/hook-weight": "1{{ $index }}" spec: activeDeadlineSeconds: {{ $job.activeDeadlineSeconds }} backoffLimit: 0 template: metadata: name: {{ $.Chart.Name }}-{{ $job.name }} spec: imagePullSecrets: - name: {{ required "$.Values.registry.secret_name required" $.Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: {{ $job.command }} {{ tuple "backend" $ | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" $ | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never {{- end }}</code> </pre> <br>  Mit diesem Ansatz k√∂nnen Sie dem Freigabeprozess schnell neue Befehle hinzuf√ºgen und die Liste der ausgef√ºhrten Befehle √ºbersichtlicher gestalten. <br><br><h2>  Fazit </h2><br>  Der Artikel enth√§lt Beispiele f√ºr Vorlagen, mit denen Sie allgemeine Vorg√§nge beschreiben k√∂nnen, die Sie beim Freigeben einer neuen Version der Anwendung ausf√ºhren m√ºssen.  Obwohl sie das Ergebnis von Erfahrungen bei der Implementierung von CI / CD-Prozessen in Dutzenden von Projekten waren, bestehen wir nicht darauf, dass es f√ºr alle Aufgaben nur eine richtige L√∂sung gibt.  Wenn die im Artikel beschriebenen Beispiele nicht die Anforderungen Ihres Projekts abdecken, freuen wir uns √ºber Situationen in den Kommentaren, die zur Erg√§nzung dieses Materials beitragen k√∂nnten. <br><br>  Kommentar von Werf-Entwicklern: <br><blockquote>  <i>In Zukunft plant werf die Einf√ºhrung benutzerkonfigurierbarer Bereitstellungsphasen von Ressourcen.</i>  <i>Mit Hilfe solcher Stadien k√∂nnen nicht nur beide F√§lle beschrieben werden.</i> </blockquote><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit werf komplexe Helm-Charts ausrollen</a> "; </li><li>  "Zusammenbau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und Bereitstellung der gleichen Art von Microservices mit werf und GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3-Wege-Fusion in Werf: Einsatz in Kubernetes mit Helm" auf Steroiden</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes Tips &amp; Tricks: Beschleunigen Sie den Bootstrap gro√üer Datenbanken.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476320/">https://habr.com/ru/post/de476320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476308/index.html">Die f√ºnf wichtigsten Methoden zur Softwareentwicklung, die im Jahr 2020 befolgt werden m√ºssen</a></li>
<li><a href="../de476310/index.html">Menschliches Gesicht CRM</a></li>
<li><a href="../de476312/index.html">Reagieren oder Angular oder Vue.js - was soll man w√§hlen?</a></li>
<li><a href="../de476316/index.html">Vue Storefront: F√ºllen Sie Daten in ES</a></li>
<li><a href="../de476318/index.html">Wir greifen Joker 2019 komplett an: Wie verlief die gr√∂√üte Java-Konferenz in Russland?</a></li>
<li><a href="../de476322/index.html">Schl√ºsselverteilungsschemata mit einem vertrauensw√ºrdigen Zentrum: Giraud- und Bloma-Schemata</a></li>
<li><a href="../de476324/index.html">Oktober Product Management Digest</a></li>
<li><a href="../de476328/index.html">Starlink ist eine gro√üe Sache</a></li>
<li><a href="../de476330/index.html">Warum bin ich aus St. Petersburg nach Pensa gefahren?</a></li>
<li><a href="../de476332/index.html">Verbesserung des Quantencomputers durch klassisches maschinelles Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>