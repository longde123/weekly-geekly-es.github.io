<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥈 🙈 🚝 Laufende Teams bei der Bereitstellung einer neuen Anwendungsversion für Kubernetes 🍗 🤾🏽 👩🏼‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In unserer Praxis stehen wir häufig vor der Aufgabe, Client-Anwendungen für die Ausführung auf Kubernetes anzupassen. Bei der Ausführung dieser Arbeit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laufende Teams bei der Bereitstellung einer neuen Anwendungsversion für Kubernetes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/476320/"><img src="https://habrastorage.org/webt/bl/a1/wq/bla1wqhxnafiftfwcg0s3vsyvxe.png"><br><br>  In unserer Praxis stehen wir häufig vor der Aufgabe, Client-Anwendungen für die Ausführung auf Kubernetes anzupassen.  Bei der Ausführung dieser Arbeiten treten einige typische Probleme auf.  Wir haben kürzlich eine davon im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lokale Dateien beim Übertragen einer Anwendung auf Kubernetes behandelt</a> , und die andere, die bereits mit CI / CD-Prozessen verknüpft ist, wird in diesem Artikel beschrieben. <br><br><h2>  Beliebige Befehle mit Helm und werf </h2><br>  Eine Anwendung besteht nicht nur aus Geschäftslogik und Daten, sondern auch aus einer Reihe beliebiger Befehle, die für eine erfolgreiche Aktualisierung ausgeführt werden müssen.  Dies können zum Beispiel Migrationen für Datenbanken, "Kellner" für die Verfügbarkeit externer Ressourcen, einige Transcoder oder Entpacker, Registrare in der externen Dienstermittlung sein - Sie können verschiedene Aufgaben in verschiedenen Projekten erfüllen. <br><br>  Was bietet Kubernetes, um solche Probleme zu lösen? <a name="habracut"></a>  Kubernetes kann Container als Pods ausführen. Daher besteht die Standardlösung darin, einen Befehl von einem Image aus auszuführen.  Zu diesem Zweck verfügt Kubernetes über ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Job-Grundelement</b></a> , mit dem Sie Pods mit Anwendungscontainern ausführen und den Abschluss dieses Pods überwachen können. <br><br>  <b>Helm</b> geht noch einen Schritt weiter und schlägt vor, Job's in verschiedenen Phasen des Bereitstellungsprozesses zu starten.  Es handelt sich um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Helm-Hooks,</a> mit denen Sie Job vor oder nach dem Aktualisieren von Ressourcenmanifesten ausführen können.  Nach unserer Erfahrung ist dies eine hervorragende Helm-Funktion, mit der Bereitstellungsaufgaben gelöst werden können. <br><br>  Es ist jedoch nicht möglich, aktuelle Informationen zum Status von Objekten während des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Rollouts</b></a> in Helm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>abzurufen.</b></a> Daher verwenden wir das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>werf</b></a> , mit dem Sie den Status von Ressourcen während des Rollouts direkt vom CI-System aus überwachen und, falls dies nicht erfolgreich ist, schnell einen Ausfall diagnostizieren können. <br><br>  Wie sich herausstellte, schließen sich diese nützlichen Features Helm und werf manchmal gegenseitig aus, aber es gibt immer einen Ausweg.  Überlegen Sie, wie Sie den Status von Ressourcen überwachen und beliebige Befehle am Beispiel von Migrationen ausführen können. <cut></cut><br><br><h2>  Ausführen von Migrationen vor der Veröffentlichung </h2><br>  Ein wesentlicher Bestandteil der Version einer Datenbankanwendung ist die Aktualisierung des Datenschemas.  Die Standardbereitstellung für Anwendungen, die Migrationen durch Ausführen eines separaten Befehls anwenden, umfasst die folgenden Schritte: <br><br><ol><li>  Aktualisierung der Codebasis; </li><li>  Beginn der Migration; </li><li>  Umschalten des Datenverkehrs auf die neue Version der Anwendung. </li></ol><br>  Innerhalb von Kubernetes sollte der Prozess derselbe sein, aber angepasst an das, was wir brauchen: <br><br><ol><li>  Starten Sie einen Container mit einem neuen Code, der möglicherweise eine neue Gruppe von Migrationen enthält. </li><li>  Starten Sie den Migrationsprozess, bevor Sie die Version der Anwendung aktualisieren. </li></ol><br>  Ziehen Sie die Option in Betracht, wenn <b>die Datenbank für die Anwendung bereits ausgeführt wird</b> und wir sie nicht als Teil der Version bereitstellen müssen, mit der die Anwendung bereitgestellt wird.  Zwei Haken eignen sich zum Anwenden von Migrationen: <br><br><ul><li>  <code>pre-install</code> - Funktioniert beim ersten Helm-Release der Anwendung, nachdem alle Vorlagen verarbeitet wurden, jedoch bevor Ressourcen in Kubernetes erstellt werden. </li><li>  <code>pre-upgrade</code> - Funktioniert bei der Aktualisierung der Helm-Version und wird wie bei der <code>pre-install</code> , nachdem die Vorlagen verarbeitet wurden, jedoch bevor Ressourcen in Kubernetes erstellt werden. </li></ul><br>  Jobbeispiel mit Helm und den beiden genannten Haken: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ .Chart.Name }}-apply-migrations annotations: "helm.sh/hook": pre-install,pre-upgrade spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ .Chart.Name }}-apply-migrations spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>Hinweis</b> : Die obige YAML-Vorlage wurde unter Berücksichtigung der Besonderheiten von werf erstellt.</i>  <i>Um es an einen "sauberen" Helm anzupassen, reicht es aus:</i> <br><br><ul><li>  <i>Ersetze <code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code> in das <code>{{ tuple "backend" . | include "werf_container_image" | indent 8 }}</code> Container-Image ein.</i> </li><li>  <i>lösche die Zeile <code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i> <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code></i>  <i><code>{{ tuple "backend" . | include "werf_container_env" | indent 8 }}</code> , der im <code>env</code> Schlüssel angegeben ist.</i> </li></ul><br>  Daher muss diese Helm-Vorlage zum Verzeichnis <code>.helm/templates</code> hinzugefügt werden, das bereits die restlichen Release-Ressourcen enthält.  Wenn <code>werf deploy --stages-storage :local</code> aufgerufen wird, werden zuerst alle Vorlagen verarbeitet und dann in den Kubernetes-Cluster geladen. <br><br><h2>  Starten von Migrationen während des Freigabeprozesses </h2><br>  Die obige Option impliziert die Verwendung von Migrationen für den Fall, dass die Datenbank bereits ausgeführt wird.  Aber was ist, wenn wir die Zweigüberprüfung für die Anwendung einführen müssen und die <b>Datenbank mit der Anwendung</b> in einer Version eingeführt wird? <br><br>  <i><b>NB</b> : Beim Rollout in die Produktionsumgebung kann ein ähnliches Problem auftreten, wenn Sie Service mit einem Endpunkt verwenden, der die IP-Adresse der Datenbank enthält, um eine Verbindung zur Datenbank herzustellen.</i> <br><br>  In diesem Fall sind die Hooks <code>pre-install</code> und <code>pre-upgrade</code> für uns nicht geeignet, da die Anwendung versucht, Migrationen auf die Datenbank anzuwenden, die <i>noch nicht vorhanden ist</i> .  Daher müssen <i>nach</i> der Veröffentlichung Migrationen durchgeführt werden. <br><br>  Mit Helm ist eine solche Aufgabe möglich, da <i>der</i> Status von Anwendungen <i>nicht überwacht wird</i> .  Nach dem Laden von Ressourcen in Kubernetes werden Post-Hooks <i>immer</i> ausgelöst: <br><br><ul><li>  <code>post-install</code> - nach dem Laden aller Ressourcen in K8s beim ersten Release; </li><li>  <code>post-upgrade</code> - nach dem Aktualisieren aller Ressourcen in K8s beim Aktualisieren der Version. </li></ul><br>  Wie bereits erwähnt, <b>verfügt werf</b> während der Veröffentlichung <b>über ein Ressourcenverfolgungssystem</b> .  Ich werde darauf noch etwas näher eingehen: <br><br><ul><li>  Für das Tracking nutzt werf die Funktionen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubedog-</a> Bibliothek, über die wir bereits im Blog gesprochen haben. </li><li>  Mit dieser Funktion in werf können wir den Status der Freigabe eindeutig bestimmen und Informationen zum erfolgreichen oder nicht erfolgreichen Abschluss der Bereitstellung in der Schnittstelle des CI / CD-Systems anzeigen. </li><li>  Ohne diese Informationen kann nicht über eine Automatisierung des Freigabeprozesses gesprochen werden, da die erfolgreiche Erstellung von Ressourcen im Kubernetes-Cluster nur eine der Phasen ist.  Beispielsweise kann es sein, dass die Anwendung aufgrund einer falschen Konfiguration oder eines Netzwerkproblems nicht gestartet wird. Um dies jedoch nach dem <code>helm upgrade</code> , müssen Sie zusätzliche Schritte ausführen. </li></ul><br>  Nun zurück zur Anwendung von Migrationen auf Helm-Post-Hooks.  Die Probleme, auf die wir gestoßen sind: <br><br><ul><li>  Viele Anwendungen prüfen den Status der Schaltung in der Datenbank, bevor sie auf die eine oder andere Weise gestartet werden.  Ohne neue Migrationen kann die Anwendung daher möglicherweise nicht gestartet werden. </li><li>  Da werf standardmäßig sicherstellt, dass sich alle Objekte im Status <code>Ready</code> , funktionieren Post-Hooks nicht und Migrationen schlagen fehl. </li><li>  Das Verfolgen von Objekten kann durch zusätzliche Anmerkungen deaktiviert werden. In diesem Fall können jedoch keine zuverlässigen Informationen über die Ergebnisse der Bereitstellung abgerufen werden. </li></ul><br>  Als Ergebnis kamen wir zu folgendem: <br><br><ul><li>  Jobs werden vor den Hauptressourcen erstellt, sodass <b>für Migrationen keine Helm-Hooks verwendet werden müssen</b> . </li><li>  Ein Job mit Migrationen muss jedoch bei jeder Bereitstellung ausgeführt werden.  Zu diesem <b>Zweck muss Job einen eindeutigen Namen</b> (zufällig) haben. In diesem Fall ist dies für Helm jedes Mal ein neues Objekt in der Version, das in Kubernetes erstellt wird. </li><li>  Bei einem solchen Start macht es keinen Sinn, sich Sorgen zu machen, dass sich Job mit Migrationen ansammelt, da alle von ihnen eindeutige Namen haben und der vorherige Job mit einer neuen Version gelöscht wird. </li><li>  <b>Ein Job mit Migrationen muss über einen Init-Container verfügen</b> , der die Verfügbarkeit der Datenbank überprüft. Andernfalls wird die Bereitstellung gelöscht (Job fällt auf den Init-Container). </li></ul><br>  Die resultierende Konfiguration sieht ungefähr so ​​aus: <br><br><pre> <code class="plaintext hljs">--- apiVersion: batch/v1 kind: Job metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: activeDeadlineSeconds: 60 backoffLimit: 0 template: metadata: name: {{ printf "%s-apply-migrations-%s" .Chart.Name (now | date "2006-01-02-15-04-05") }} spec: imagePullSecrets: - name: {{ required ".Values.registry.secret_name required" .Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: ["/usr/bin/php7.2", "artisan", "migrate", "--force"] {{ tuple "backend" . | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" . | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never</code> </pre> <br>  <i><b>NB</b> : Genau genommen werden Init-Container zur Überprüfung der Datenbankverfügbarkeit sowieso am besten verwendet.</i> <br><br><h2>  Ein Beispiel für eine universelle Vorlage für alle Bereitstellungsvorgänge </h2><br>  Die Vorgänge, die während des Releases ausgeführt werden müssen, können jedoch länger dauern als der Start der bereits erwähnten Migrationen.  Sie können die Ausführungsreihenfolge von Job nicht nur über die Arten von Hooks steuern, sondern auch, <b>indem Sie jedem von ihnen eine Gewichtung zuweisen</b> - über die Annotation <code>helm.sh/hook-weight</code> .  Hooks werden nach Gewicht in aufsteigender Reihenfolge und bei gleichem Gewicht nach Ressourcennamen sortiert. <br><br>  Bei einer großen Anzahl von Jobs ist es praktisch, eine universelle Vorlage für Jobs zu <code>values.yaml</code> und die Konfiguration in die <code>values.yaml</code> .  Letzteres könnte so aussehen: <br><br><pre> <code class="plaintext hljs">deploy_jobs: - name: migrate command: '["/usr/bin/php7.2", "artisan", "migrate", "--force"]' activeDeadlineSeconds: 120 when: production: 'pre-install,pre-upgrade' staging: 'pre-install,pre-upgrade' _default: '' - name: cache-clear command: '["/usr/bin/php7.2", "artisan", "responsecache:clear"]' activeDeadlineSeconds: 60 when: _default: 'post-install,post-upgrade'</code> </pre> <br>  ... und die Vorlage selbst sieht so aus: <br><br><pre> <code class="plaintext hljs">{{- range $index, $job := .Values.deploy_jobs }} --- apiVersion: batch/v1 kind: Job metadata: name: {{ $.Chart.Name }}-{{ $job.name }} annotations: "helm.sh/hook": {{ pluck $.Values.global.env $job.when | first | default $job.when._default }} "helm.sh/hook-weight": "1{{ $index }}" spec: activeDeadlineSeconds: {{ $job.activeDeadlineSeconds }} backoffLimit: 0 template: metadata: name: {{ $.Chart.Name }}-{{ $job.name }} spec: imagePullSecrets: - name: {{ required "$.Values.registry.secret_name required" $.Values.registry.secret_name }} initContainers: - name: wait-db image: alpine:3.6 ommand: ["/bin/sh", "-c", "while ! nc -z postgres 5432; do sleep 1; done;"] containers: - name: job command: {{ $job.command }} {{ tuple "backend" $ | include "werf_container_image" | indent 8 }} env: {{ tuple "backend" $ | include "werf_container_env" | indent 8 }} - name: DB_HOST value: postgres restartPolicy: Never {{- end }}</code> </pre> <br>  Mit diesem Ansatz können Sie dem Freigabeprozess schnell neue Befehle hinzufügen und die Liste der ausgeführten Befehle übersichtlicher gestalten. <br><br><h2>  Fazit </h2><br>  Der Artikel enthält Beispiele für Vorlagen, mit denen Sie allgemeine Vorgänge beschreiben können, die Sie beim Freigeben einer neuen Version der Anwendung ausführen müssen.  Obwohl sie das Ergebnis von Erfahrungen bei der Implementierung von CI / CD-Prozessen in Dutzenden von Projekten waren, bestehen wir nicht darauf, dass es für alle Aufgaben nur eine richtige Lösung gibt.  Wenn die im Artikel beschriebenen Beispiele nicht die Anforderungen Ihres Projekts abdecken, freuen wir uns über Situationen in den Kommentaren, die zur Ergänzung dieses Materials beitragen könnten. <br><br>  Kommentar von Werf-Entwicklern: <br><blockquote>  <i>In Zukunft plant werf die Einführung benutzerkonfigurierbarer Bereitstellungsphasen von Ressourcen.</i>  <i>Mit Hilfe solcher Stadien können nicht nur beide Fälle beschrieben werden.</i> </blockquote><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit werf komplexe Helm-Charts ausrollen</a> "; </li><li>  "Zusammenbau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und Bereitstellung der gleichen Art von Microservices mit werf und GitLab CI</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3-Wege-Fusion in Werf: Einsatz in Kubernetes mit Helm" auf Steroiden</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes Tips &amp; Tricks: Beschleunigen Sie den Bootstrap großer Datenbanken.</a> " </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476320/">https://habr.com/ru/post/de476320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476308/index.html">Die fünf wichtigsten Methoden zur Softwareentwicklung, die im Jahr 2020 befolgt werden müssen</a></li>
<li><a href="../de476310/index.html">Menschliches Gesicht CRM</a></li>
<li><a href="../de476312/index.html">Reagieren oder Angular oder Vue.js - was soll man wählen?</a></li>
<li><a href="../de476316/index.html">Vue Storefront: Füllen Sie Daten in ES</a></li>
<li><a href="../de476318/index.html">Wir greifen Joker 2019 komplett an: Wie verlief die größte Java-Konferenz in Russland?</a></li>
<li><a href="../de476322/index.html">Schlüsselverteilungsschemata mit einem vertrauenswürdigen Zentrum: Giraud- und Bloma-Schemata</a></li>
<li><a href="../de476324/index.html">Oktober Product Management Digest</a></li>
<li><a href="../de476328/index.html">Starlink ist eine große Sache</a></li>
<li><a href="../de476330/index.html">Warum bin ich aus St. Petersburg nach Pensa gefahren?</a></li>
<li><a href="../de476332/index.html">Verbesserung des Quantencomputers durch klassisches maschinelles Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>