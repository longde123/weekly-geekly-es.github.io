<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèª üö¥üèø üë©üèø‚Äç‚öïÔ∏è AI y 2048. Parte 2: recorte de Minimax + alfa beta üë©üèø‚Äç‚úàÔ∏è üê¶ üíØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Examinamos el m√©todo de Monte Carlo , hoy veremos c√≥mo juega la mente de la computadora en 2048 usando el viejo minimax con recorte alfa-beta. 

  
 E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>AI y 2048. Parte 2: recorte de Minimax + alfa beta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474680/"><div style="text-align:center;"><img width="690" height="314" src="https://habrastorage.org/webt/9t/ym/10/9tym105d327kylbfpejz4inkdxu.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Examinamos el m√©todo de Monte Carlo</a> , hoy veremos c√≥mo juega la mente de la computadora en 2048 usando el viejo minimax con recorte alfa-beta. <a name="habracut"></a><br><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" title="Software EDISON - desarrollo web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Software EDISON - desarrollo web"></a> <br clear="right">  Este art√≠culo fue escrito con el apoyo de EDISON, una compa√±√≠a que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrolla aplicaciones m√≥viles</a> y brinda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servicios de prueba de software</a> . </blockquote><br>  Soluci√≥n espiada por el usuario stackoverflow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img width="14" height="14" src="https://habrastorage.org/webt/7c/q2/x_/7cq2x_1w7otpr1ksh4yryg83h4c.jpeg"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ovolve</a> , quien se√±al√≥ en la discusi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mo ense√±ar a AI el juego 2048</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Traducci√≥n de comentarios de ovolve</b> <div class="spoiler_text">  Soy el autor del programa mencionado en este hilo.  Puedes ver la IA <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en acci√≥n</a> o ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el c√≥digo</a> . <br><br>  Actualmente, el programa gana en aproximadamente el 90% de los casos al ejecutar java-scripts en un navegador en mi computadora port√°til, gastando 100 milisegundos para pensar en el curso, trabajando, aunque no perfectamente, pero bastante bien. <br><br>  Dado que el juego es un espacio de estado discreto con informaci√≥n completa, de hecho es un juego por turnos como el ajedrez y las damas, utilic√© los mismos m√©todos que mostraron su rendimiento en estos juegos, es decir, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda de minimax</a> con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">recorte alfa-beta</a> .  Como los enlaces proporcionan mucha informaci√≥n sobre este algoritmo, solo hablar√© sobre las dos heur√≠sticas principales que utilic√© en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la funci√≥n de estimaci√≥n est√°tica</a> y formalizar√© muchas de las suposiciones intuitivas hechas por otras personas aqu√≠. <br><br><img align="right" width="344" height="343" src="https://habrastorage.org/webt/hm/s0/cu/hms0cuvsvpeyvyvozxm-3f88xui.png"><br clear="left"><h3>  Monoton√≠a </h3><br>  Esta heur√≠stica trata de garantizar que todos los valores de mosaico aumenten o disminuyan tanto hacia la izquierda / derecha como hacia arriba / abajo.  Esta heur√≠stica por s√≠ sola refleja la conjetura de que muchos otros han mencionado que los mosaicos m√°s valiosos deber√≠an agruparse en una esquina.  Esto, por regla general, evita la acumulaci√≥n de fichas menos valiosas y mantiene el tablero organizado, ya que las fichas m√°s peque√±as caen en cascada en las m√°s grandes. <br><br>  Aqu√≠ hay una captura de pantalla de una cuadr√≠cula completamente mon√≥tona.  Obtuve esta situaci√≥n ejecutando un algoritmo con la funci√≥n eval instalada para ignorar otras heur√≠sticas y tener en cuenta solo la monoton√≠a. <br><br><img align="right" width="342" height="343" src="https://habrastorage.org/webt/iq/wp/4p/iqwp4pn8rsoynb1u6eknm99gmt8.png"><br clear="left"><h3>  Suavidad (suavidad, uniformidad) </h3><br>  La heur√≠stica anterior en s√≠ misma tiende a crear estructuras en las cuales las celdas vecinas tienen un valor reducido, sin embargo, por supuesto, las vecinas deben tener el mismo significado para combinar.  Por lo tanto, la heur√≠stica de suavidad simplemente mide la diferencia de valores entre las fichas adyacentes, tratando de minimizar su n√∫mero. <br><br>  Un comentarista de Hacker News proporcion√≥ una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interesante formalizaci√≥n de</a> esta idea en t√©rminos de teor√≠a de grafos. <br><br><div class="spoiler">  <b class="spoiler_title">Traducci√≥n de formalizaci√≥n con Hacker News</b> <div class="spoiler_text"><blockquote>  Ayer le mostr√© este juego a un colega, un amante de la teor√≠a de gr√°ficos, y tambi√©n decidimos pensar en c√≥mo resolver este juego usando IA. <br><br>  La soluci√≥n m√°s simple es minimax, que, seg√∫n lo veo, se implementa bastante bien.  Si alguien aqu√≠ no est√° familiarizado con minimax, OP escribi√≥ un c√≥digo muy elegante y bien comentado que ser√≠a un gran tutorial. <br><br>  El enfoque menos computacionalmente intensivo que propusimos fue modelar el estado del juego en forma de un gr√°fico <b>G (V, E)</b> , donde <b>V</b> es un conjunto de fichas activas y <b>E</b> es un conjunto de bordes que conectan fichas adyacentes ponderadas por la funci√≥n <b>c (v1, v2)</b> , que devuelve el valor absoluto de la diferencia entre los dos mosaicos.  Para cada soluci√≥n, la IA elige un movimiento que minimiza la suma de los pesos de todos los bordes en el nuevo estado del juego. <br><br>  La raz√≥n de esto es que la √∫nica forma de progresar en el juego es tener fichas con los mismos valores uno al lado del otro, para lo cual el peso en <b>G</b> ser√° 0. Por lo tanto, la IA deber√≠a tratar de minimizar el peso total.  Al final, habr√° un gran n√∫mero en los tableros con un gran peso de bordes a las fichas adyacentes, por lo que la IA intentar√° mantener estas fichas junto a otras fichas grandes para minimizar la diferencia. <br><br>  Como el juego es estoc√°stico, el enfoque que describ√≠ puede no funcionar en el peor de los casos, pero tambi√©n se puede aplicar a la soluci√≥n minimax existente como una funci√≥n de peso para cada nodo en el √°rbol. </blockquote></div></div><br><br>  Aqu√≠ hay una captura de pantalla de una malla perfectamente lisa, amablemente proporcionada por este excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20140315093348/">tenedor simulado</a> .  <i>(enlace al archivo web, mientras que los scripts de Java en la p√°gina funcionan y puede usar el teclado para moverse en cualquier direcci√≥n - nota del traductor).</i> <br><br><h3>  Azulejos sueltos </h3><br>  Y finalmente, hay una penalizaci√≥n por tener muy pocas fichas libres, ya que las opciones pueden terminar r√°pidamente cuando el campo de juego se vuelve demasiado estrecho. <br><br>  ¬°Y eso es todo!  Buscar en el espacio del juego mientras se optimizan estos criterios ofrece un rendimiento sorprendentemente bueno.  Uno de los beneficios de utilizar un enfoque gen√©rico como este en lugar de una estrategia de movimiento codificada expl√≠citamente es que el algoritmo a menudo puede encontrar soluciones interesantes e inesperadas.  Si observa su progreso, a menudo realiza movimientos sorprendentes pero efectivos, como el cambio repentino de muros o esquinas, cerca de los cuales construye su juego. <br><br><img align="right" width="345" height="499" src="https://habrastorage.org/webt/tc/oi/hz/tcoihzahmdqlw9cxthywpapiwsa.png"><br clear="left"><h3>  Peque√±o cambio </h3><br>  La captura de pantalla demuestra el poder de este enfoque.  Elimin√© el l√≠mite de mosaico (para que contin√∫en creciendo despu√©s de llegar a 2048), y aqu√≠ est√° el mejor resultado despu√©s de ocho pruebas. <br><br>  S√≠, esto es 4096 junto con 2048. =) Esto significa que ha alcanzado la esquiva ficha 2048 en un tablero. </div></div><br><hr><hr><hr><hr><hr><br>  El c√≥digo Java-Script para minimax con recorte alfa-beta y funci√≥n de evaluaci√≥n est√°tica del usuario ovolve stackoverflow se detalla a continuaci√≥n en el art√≠culo. <br><br>  El m√©todo minimax est√° dedicado a varios excelentes art√≠culos habr, por lo que omitimos la explicaci√≥n acad√©mica detallada de en qu√© consiste.  Para aquellos que se <strike>unieron a la comunidad de TI, recientemente</strike> escuch√© los hermosos t√©rminos "minimax" y "recorte alfa-beta", pero no s√© lo que esto significa, intentemos, literalmente en un par de p√°rrafos, explicar el significado m√°s general. <br><br><h2>  Minimax </h2><br>  En algunos juegos, el proceso de un juego entre dos jugadores (que hacen un movimiento a su vez) puede representarse como un llamado √°rbol de opciones.  En cada posici√≥n espec√≠fica, cada jugador generalmente puede elegir entre diferentes opciones para su movimiento.  Y en respuesta a cada una de estas opciones, un oponente tambi√©n puede ser de muchas maneras. <br><br><div style="text-align:center;"><img width="690" height="525" src="https://habrastorage.org/webt/xi/ye/j2/xiyej2z5e4n-kigoscjrgfpf2i8.png"></div><br>  <sup><em>Fragmento de un √°rbol de opciones.</em></sup> <br><br>  Dado que en cualquier momento del juego hay informaci√≥n completa sobre el estado del campo de juego, el estado actual de la posici√≥n siempre se puede estimar con precisi√≥n.  Dicha funci√≥n se denomina <strong>funci√≥n de evaluaci√≥n est√°tica</strong> o <strong>SFO</strong> abreviada.  Adem√°s, cuanto m√°s importante es esta funci√≥n al evaluar una posici√≥n espec√≠fica, m√°s ventajosa es la posici√≥n para un jugador (llam√©mosle <strong>jugador maximizador</strong> ).  Cuanto m√°s peque√±o es el valor num√©rico de esta funci√≥n al evaluar una posici√≥n, m√°s ventajosa es la posici√≥n para el segundo jugador (llam√©moslo el <strong>jugador que minimiza</strong> ). <br><br>  Despu√©s de cada movimiento, la posici√≥n cambia y, por lo tanto, su puntaje cambia.  Al considerar el √°rbol de opciones, cada jugador necesita no solo preferir aquellas ramas en las que la calificaci√≥n es m√°s favorable para √©l.  Tambi√©n debes evitar aquellas ramas en las que la evaluaci√≥n de la posici√≥n es favorable para el oponente. <br><br>  Se supone que el oponente tambi√©n se gu√≠a por el racionalismo y tambi√©n evita opciones que podr√≠an llevarlo a perder.  Es decir, cada jugador, al elegir una opci√≥n, procede a maximizar su propio beneficio y al mismo tiempo minimizar el beneficio del oponente. <br><br>  Esto es minimax. <br><br><h2>  Recorte alfa beta </h2><br>  Es bastante obvio: quien calcula un √°rbol desde una posici√≥n dada a una mayor profundidad, tiene m√°s posibilidades de ganar.  Pero hay una molestia: el √°rbol de opciones en los juegos tiene el desagradable h√°bito de ramificarse y crecer exponencialmente con cada nivel de anidaci√≥n.  Las habilidades de conteo de los programas, y a√∫n m√°s por lo que las personas son limitadas, el conteo "hasta el tapete" est√° lejos de ser siempre posible.  Puede resultar f√°cilmente que un jugador ha contado hasta una posici√≥n en la que tiene una buena evaluaci√≥n del campo de juego, pero literalmente en el siguiente nivel (ilegible) el oponente tiene la oportunidad de hacer un movimiento que cambie radicalmente la estimaci√≥n de la posici√≥n al contrario. <br><br>  ¬øQui√©n tiene la culpa y qu√© hacer?  La complejidad computacional es la responsable del recorrido completo del √°rbol; se propone luchar cortando ramas innecesarias.  Si el jugador que eval√∫a la posici√≥n ve que alguna rama del √°rbol de opciones: <br><br>  o menos rentable para √©l que otras ramas que ya han sido analizadas, <br>  o m√°s beneficioso para el oponente que otras ramas que ya han sido analizadas, <br><br>  entonces el jugador descarta esta rama, no pierde tiempo y recursos al considerar las subopciones de esta rama obviamente peor para √©l. <br><br>  Esto le permite asignar m√°s recursos inform√°ticos para calcular ramas m√°s favorables a una mayor profundidad de representaci√≥n en el √°rbol de opciones.  En el proceso de evaluar el campo de juego en diferentes niveles del √°rbol de opciones, el jugador opera con dos coeficientes que cambian din√°micamente: <strong>alfa</strong> (el valor del SFD que se encuentra m√≠nimamente en la rama, es decir, m√°s favorable para el jugador que minimiza) y <strong>beta</strong> (el valor del SFD que se encuentra m√°s en la rama, es decir, m√°s favorable para el jugador maximizador).  En cada nivel, comparar el SFD de la posici√≥n actual con <em>los</em> coeficientes <em>alfa</em> y <em>beta le</em> permite barrer (sin calcularlos completamente) ramas que son <em>menos beneficiosas</em> para el jugador que eval√∫a la posici√≥n y / o <em>m√°s beneficioso</em> para su oponente. <br><br>  Este es el recorte alfa beta. <br><br><h3>  Funci√≥n minimax recursiva con recorte alfa beta </h3><br><div class="spoiler">  <b class="spoiler_title">2048 con AI se implementa como una aplicaci√≥n de Excel con macros VBA, as√≠ es como el algoritmo minimax con recorte alfa beta parece un b√°sico visual despreciable.</b> <div class="spoiler_text"><pre><code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''( - )''''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '       -- 'Position -  4  4     'Depth - ,    'Alpha, Beta -         'MaximisingPlayer -      ? Private Function MiniMaxAlpaBeta_Evaluation(Position As Variant, Depth As Long, _ Alpha As Double, Beta As Double, _ MaximisingPlayer As Boolean, _ Optional MainLevel As Boolean = False) As Double Dim MaxEval As Double '  Dim MinEval As Double '  Dim PositionNext As Variant '     Dim PositionTemp As Variant '     Dim Eval As Double '   Dim Way As Long '   -      Dim Row As Long '     Dim Col As Long '     Dim TileNew As Long '      '   (  ,  '     ) If GameOverPosition(Position) Then '    ? '     MiniMaxAlpaBeta_Evaluation = -1000000 + TileMax(Position) '         ElseIf Depth = 0 Then '     MiniMaxAlpaBeta_Evaluation = StaticEvaluation(Position) '  ,    '     () ElseIf MaximisingPlayer Then MaxEval = -1000000 '      For Way = 1 To 4 ' 4   - (, , , ) ChangeCount = 0 ' ,      ',       PositionNext = StepHuman(Position, Way) If ChangeCount &gt; 0 Then '     '      , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, False) If Eval &gt; MaxEval Then MaxEval = Eval '  '     If Eval &gt; Alpha Then Alpha = Eval '    ,   '   -    If Beta &gt; Alpha Then Exit For End If Next '          MiniMaxAlpaBeta_Evaluation = MaxEval '  ,    '     () Else 'Not MaximisingPlayer MinEval = 1000000 '      For Row = 1 To 4 '     For Col = 1 To 4 '     If Position(Row, Col) = 0 Then '   For TileNew = 2 To 4 Step 2 '    2  4 ',       '    PositionNext = StepComp(Position, Row, Col, TileNew) '     , '    () Eval = MiniMaxAlpaBeta_Evaluation(PositionNext, Depth - 1, _ Alpha, Beta, True) If Eval &lt; MinEval Then MinEval = Eval '  '     If Eval &lt; Beta Then Beta = Eval '    ,   '   -    If Alpha &lt; Beta Then Exit For Next End If Next Next '          MiniMaxAlpaBeta_Evaluation = MinEval End If End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C√≥digo Ovolve en java-script</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grid</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.grid = grid; } <span class="hljs-comment"><span class="hljs-comment">//   () AI.prototype.eval = function() { var emptyCells = this.grid.availableCells().length; var smoothWeight = 0.1, //monoWeight = 0.0, //islandWeight = 0.0, mono2Weight = 1.0, emptyWeight = 2.7, maxWeight = 1.0; return this.grid.smoothness() * smoothWeight //+ this.grid.monotonicity() * monoWeight //- this.grid.islands() * islandWeight + this.grid.monotonicity2() * mono2Weight + Math.log(emptyCells) * emptyWeight + this.grid.maxValue() * maxWeight; }; // alpha-beta depth first search AI.prototype.search = function(depth, alpha, beta, positions, cutoffs) { var bestScore; var bestMove = -1; var result; // the maxing player if (this.grid.playerTurn) { bestScore = alpha; for (var direction in [0, 1, 2, 3]) { var newGrid = this.grid.clone(); if (newGrid.move(direction).moved) { positions++; if (newGrid.isWin()) { return { move: direction, score: 10000, positions: positions, cutoffs: cutoffs }; } var newAI = new AI(newGrid); if (depth == 0) { result = { move: direction, score: newAI.eval() }; } else { result = newAI.search(depth-1, bestScore, beta, positions, cutoffs); if (result.score &gt; 9900) { // win result.score--; // to slightly penalize higher depth from win } positions = result.positions; cutoffs = result.cutoffs; } if (result.score &gt; bestScore) { bestScore = result.score; bestMove = direction; } if (bestScore &gt; beta) { cutoffs++ return { move: bestMove, score: beta, positions: positions, cutoffs: cutoffs }; } } } } else { // computer's turn, we'll do heavy pruning to keep the branching factor low bestScore = beta; // try a 2 and 4 in each cell and measure how annoying it is // with metrics from eval var candidates = []; var cells = this.grid.availableCells(); var scores = { 2: [], 4: [] }; for (var value in scores) { for (var i in cells) { scores[value].push(null); var cell = cells[i]; var tile = new Tile(cell, parseInt(value, 10)); this.grid.insertTile(tile); scores[value][i] = -this.grid.smoothness() + this.grid.islands(); this.grid.removeTile(cell); } } // now just pick out the most annoying moves var maxScore = Math.max(Math.max.apply(null, scores[2]), Math.max.apply(null, scores[4])); for (var value in scores) { // 2 and 4 for (var i=0; i&lt;scores[value].length; i++) { if (scores[value][i] == maxScore) { candidates.push( { position: cells[i], value: parseInt(value, 10) } ); } } } // search on each candidate for (var i=0; i&lt;candidates.length; i++) { var position = candidates[i].position; var value = candidates[i].value; var newGrid = this.grid.clone(); var tile = new Tile(position, value); newGrid.insertTile(tile); newGrid.playerTurn = true; positions++; newAI = new AI(newGrid); result = newAI.search(depth, alpha, bestScore, positions, cutoffs); positions = result.positions; cutoffs = result.cutoffs; if (result.score &lt; bestScore) { bestScore = result.score; } if (bestScore &lt; alpha) { cutoffs++; return { move: null, score: alpha, positions: positions, cutoffs: cutoffs }; } } } return { move: bestMove, score: bestScore, positions: positions, cutoffs: cutoffs }; } // performs a search and returns the best move AI.prototype.getBest = function() { return this.iterativeDeep(); } // performs iterative deepening over the alpha-beta search AI.prototype.iterativeDeep = function() { var start = (new Date()).getTime(); var depth = 0; var best; do { var newBest = this.search(depth, -10000, 10000, 0 ,0); if (newBest.move == -1) { break; } else { best = newBest; } depth++; } while ( (new Date()).getTime() - start &lt; minSearchTime); return best } AI.prototype.translate = function(move) { return { 0: 'up', 1: 'right', 2: 'down', 3: 'left' }[move]; }</span></span></code> </pre> </div></div><br><h2>  Funci√≥n de evaluaci√≥n est√°tica </h2><br>  Dado que en cada nivel del √°rbol de opciones tienes que evaluar el campo de juego (para decidir cu√°l de los jugadores, la posici√≥n estimada es realmente m√°s ventajosa), debes decidir con qu√© criterios distinguir una buena posici√≥n de una mala. <br><br>  Suponemos que el jugador maximizador es la persona (o IA) que decide en cu√°l de las 4 direcciones (arriba, izquierda, derecha, abajo) mover todas las fichas.  Un jugador que minimiza es esa subrutina insidiosa que genera aleatoriamente 2 o 4 en los lugares m√°s inapropiados. <br><br>  La OFS se compila desde la perspectiva de un jugador maximizador.  Cuanto mayor sea la calificaci√≥n SFD para el campo de juego, mejor ser√° la posici√≥n para el "maximalista".  Cuanto m√°s bajo, m√°s agradable es la posici√≥n en el tablero para el "minimalista". <br><br>  En el caso de 2048, ¬øqu√© factores se consideran favorables para quien mueve las fichas? <br><br><h3>  Monoton√≠a </h3><img align="right" width="388" height="189" src="https://habrastorage.org/webt/r8/jc/qt/r8jcqtbvrsyvrfwwsmeedgfrzrg.png"><br clear="left">  En primer lugar, es deseable que las fichas est√©n dispuestas en orden ascendente / descendente en algunas direcciones.  Si esto no se hace, cuando se generen nuevas fichas, el campo de juego se obstruir√° r√°pidamente con fichas ordenadas al azar de diferentes tama√±os, que no pueden conectarse inmediatamente entre s√≠ normalmente. <br><br>  En el Distrito Federal de Siberia, debe mirar en las 4 direcciones (de arriba hacia abajo, de izquierda a derecha, de derecha a izquierda, de abajo hacia arriba) y calcular d√≥nde est√°n los progresos decrecientes o decrecientes.  Si en progresi√≥n hay fichas que no encajan en la serie general, esto reduce el coeficiente num√©rico de la monoton√≠a.  Luego, de los 4 coeficientes para todas las direcciones, se selecciona el mejor, que se tiene en cuenta en el valor total del Distrito Federal de Siberia. <br><br><h3>  Suavidad </h3><img align="right" width="387" height="189" src="https://habrastorage.org/webt/uw/mq/wh/uwmqwht6dm82fc_zptwwdqdar2c.png"><br clear="left">  Adem√°s, ser√≠a m√°s preferible que la progresi√≥n de estar parado en una fila de fichas no solo aumentara, sino que no disminuyera (o en lugar de disminuirla, es preferible que no aumentara), es decir, es bueno cuando las mismas fichas est√°n cerca, lo que les permite colapsar en una, ganando puntos y aumentando el espacio libre en el campo de juego. <br><br>  Por lo tanto, el Distrito Federal de Siberia est√° buscando en el campo de juego fichas adyacentes id√©nticas y tiene en cuenta el n√∫mero de tales pares en un coeficiente especial. <br><br><h3>  Celdas vac√≠as </h3><img align="right" width="387" height="193" src="https://habrastorage.org/webt/qj/as/ay/qjasayisfgowdqcciifm0igt3ru.png"><br clear="left">  Obviamente, cuanto m√°s espacio libre, m√°s espacio para maniobrar y menos posibilidades de perder r√°pidamente. <br><br>  La OFS considera celdas vac√≠as en el campo y, cuanto m√°s, la posici√≥n se considera m√°s rentable para el jugador maximizador. <br><br><h3>  Azulejo m√°ximo </h3><br>  Dado que lo principal en este juego es obtener un gran mosaico en el campo, cuanto m√°s mejor, 2048, 4096, 8192 (o lo que sea que tenga la fuerza y ‚Äã‚Äãla paciencia para), las opciones en las que el valor m√°ximo del mosaico es m√°s deben considerarse como el SFD m√°s rentable. <br><br><h3>  Distrito Federal de Siberia para 2048 </h3><br><div class="spoiler">  <b class="spoiler_title">Implementaci√≥n del Distrito Federal de Siberia como macro VBA</b> <div class="spoiler_text"><pre> <code class="vbscript hljs"><span class="hljs-comment"><span class="hljs-comment">''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '''''''''''''''''''''''  '''''''''''''''''''''''' ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' '     'Position -  4  4     Private Function StaticEvaluation(Position As Variant) As Double Dim Smoothness As Double ' Dim Monotonicity As Double ' Dim EmptyCount As Double '  Dim MaxValue As Long '  '   Const SmoothWeight = 0.1 Const MonoWeight = 1 Const EmptyWeight = 2.7 Const MaxWeight = 1 Dim k As Long '   Dim i As Long '  Dim j As Long '  Dim x As Long '  Dim y As Long '  ' Dim Value As Double '       '         Dim TargetValue As Double Smoothness = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) &gt; 0 Then '   Value = Log(Position(i, j)) / Log(2) If i &lt; 4 Then '       For x = i + 1 To 4 '    If Position(x, j) &gt; 0 Then '    '    TargetValue = Log(Position(x, j)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '       Exit For End If Next End If If j &lt; 4 Then '       For y = j + 1 To 4 '    If Position(i, y) &gt; 0 Then '    '    TargetValue = Log(Position(i, y)) / Log(2) ',   Smoothness = Abs(Value - TargetValue) '        Exit For End If Next End If End If Next Next ' Dim arrTotals(1 To 4) As Double '     Dim Current As Long '   Dim Next_ As Long '      Dim CurrentValue As Double '      Dim NextValue As Double '        Monotonicity = 0 '    '      For k = 1 To 4 arrTotals(k) = 0 Next ' -  - For x = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(x, Next_) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(x, Current) &gt; 0 Then CurrentValue = Log(Position(x, Current)) / Log(2) Else CurrentValue = 0 End If ' MsgBox "Position[" &amp; x &amp; ", " &amp; Next_ &amp; "]=" &amp; Position(x, Next_) If Position(x, Next_) &gt; 0 Then NextValue = Log(Position(x, Next_)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Up) = arrTotals(Up) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Down) = arrTotals(Down) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Up) &gt;= arrTotals(Down), _ Monotonicity + arrTotals(Up), _ Monotonicity + arrTotals(Down)) ' -  - For y = 1 To 4 '   Current = 1 '      '   (     )  Next_ = Current + 1 Do While Next_ &lt;= 4 '       '      '(       ) Do While Next_ &lt;= 4 '       If Position(Next_, y) = 0 Then '     Next_ = Next_ + 1 '   Else ' -    Exit Do ' ,  ,   End If Loop '         If Next_ &gt; 4 Then Next_ = 4 '          If Position(Current, y) &gt; 0 Then CurrentValue = Log(Position(Current, y)) / Log(2) Else CurrentValue = 0 End If If Position(Next_, y) &gt; 0 Then NextValue = Log(Position(Next_, y)) / Log(2) Else NextValue = 0 End If If CurrentValue &gt; NextValue Then '   ? arrTotals(Left) = arrTotals(Left) + NextValue - CurrentValue ElseIf NextValue &gt; CurrentValue Then '   ? arrTotals(Right) = arrTotals(Right) + CurrentValue - NextValue End If Current = Next_ '       Next_ = Next_ + 1 '    Loop Next '      -  - Monotonicity = IIf(arrTotals(Left) &gt;= arrTotals(Right), _ Monotonicity + arrTotals(Left), _ Monotonicity + arrTotals(Right)) '     EmptyCount = 0 '      MaxValue = 0 '    For i = 1 To 4 '     For j = 1 To 4 '     If Position(i, j) = 0 Then '  ... '...     EmptyCount = EmptyCount + 1 '     ... ElseIf Position(i, j) &gt; MaxValue Then MaxValue = Position(i, j) '...    End If Next Next '   StaticEvaluation = Smoothness * SmoothWeight + _ Monotonicity * MonoWeight + _ Log_Base_Arg(EmptyCount) * EmptyWeight + _ MaxValue * MaxWeight End Function</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C√≥digo Ovolve en java-script</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size = size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.startTiles = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cells = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.build(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.playerTurn = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// pre-allocate these objects (for speed) Grid.prototype.indexes = []; for (var x=0; x&lt;4; x++) { Grid.prototype.indexes.push([]); for (var y=0; y&lt;4; y++) { Grid.prototype.indexes[x].push( {x:x, y:y} ); } } // Build a grid of the specified size Grid.prototype.build = function () { for (var x = 0; x &lt; this.size; x++) { var row = this.cells[x] = []; for (var y = 0; y &lt; this.size; y++) { row.push(null); } } }; // Find the first available random position Grid.prototype.randomAvailableCell = function () { var cells = this.availableCells(); if (cells.length) { return cells[Math.floor(Math.random() * cells.length)]; } }; Grid.prototype.availableCells = function () { var cells = []; var self = this; this.eachCell(function (x, y, tile) { if (!tile) { //cells.push(self.indexes[x][y]); cells.push( {x:x, y:y} ); } }); return cells; }; // Call callback for every cell Grid.prototype.eachCell = function (callback) { for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { callback(x, y, this.cells[x][y]); } } }; // Check if there are any cells available Grid.prototype.cellsAvailable = function () { return !!this.availableCells().length; }; // Check if the specified cell is taken Grid.prototype.cellAvailable = function (cell) { return !this.cellOccupied(cell); }; Grid.prototype.cellOccupied = function (cell) { return !!this.cellContent(cell); }; Grid.prototype.cellContent = function (cell) { if (this.withinBounds(cell)) { return this.cells[cell.x][cell.y]; } else { return null; } }; // Inserts a tile at its position Grid.prototype.insertTile = function (tile) { this.cells[tile.x][tile.y] = tile; }; Grid.prototype.removeTile = function (tile) { this.cells[tile.x][tile.y] = null; }; Grid.prototype.withinBounds = function (position) { return position.x &gt;= 0 &amp;&amp; position.x &lt; this.size &amp;&amp; position.y &gt;= 0 &amp;&amp; position.y &lt; this.size; }; Grid.prototype.clone = function() { newGrid = new Grid(this.size); newGrid.playerTurn = this.playerTurn; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { if (this.cells[x][y]) { newGrid.insertTile(this.cells[x][y].clone()); } } } return newGrid; }; // Set up the initial tiles to start the game with Grid.prototype.addStartTiles = function () { for (var i=0; i&lt;this.startTiles; i++) { this.addRandomTile(); } }; // Adds a tile in a random position Grid.prototype.addRandomTile = function () { if (this.cellsAvailable()) { var value = Math.random() &lt; 0.9 ? 2 : 4; //var value = Math.random() &lt; 0.9 ? 256 : 512; var tile = new Tile(this.randomAvailableCell(), value); this.insertTile(tile); } }; // Save all tile positions and remove merger info Grid.prototype.prepareTiles = function () { this.eachCell(function (x, y, tile) { if (tile) { tile.mergedFrom = null; tile.savePosition(); } }); }; // Move a tile and its representation Grid.prototype.moveTile = function (tile, cell) { this.cells[tile.x][tile.y] = null; this.cells[cell.x][cell.y] = tile; tile.updatePosition(cell); }; Grid.prototype.vectors = { 0: { x: 0, y: -1 }, // up 1: { x: 1, y: 0 }, // right 2: { x: 0, y: 1 }, // down 3: { x: -1, y: 0 } // left } // Get the vector representing the chosen direction Grid.prototype.getVector = function (direction) { // Vectors representing tile movement return this.vectors[direction]; }; // Move tiles on the grid in the specified direction // returns true if move was successful Grid.prototype.move = function (direction) { // 0: up, 1: right, 2:down, 3: left var self = this; var cell, tile; var vector = this.getVector(direction); var traversals = this.buildTraversals(vector); var moved = false; var score = 0; var won = false; // Save the current tile positions and remove merger information this.prepareTiles(); // Traverse the grid in the right direction and move tiles traversals.x.forEach(function (x) { traversals.y.forEach(function (y) { cell = self.indexes[x][y]; tile = self.cellContent(cell); if (tile) { //if (debug) { //console.log('tile @', x, y); //} var positions = self.findFarthestPosition(cell, vector); var next = self.cellContent(positions.next); // Only one merger per row traversal? if (next &amp;&amp; next.value === tile.value &amp;&amp; !next.mergedFrom) { var merged = new Tile(positions.next, tile.value * 2); merged.mergedFrom = [tile, next]; self.insertTile(merged); self.removeTile(tile); // Converge the two tiles' positions tile.updatePosition(positions.next); // Update the score score += merged.value; // The mighty 2048 tile if (merged.value === 2048) { won = true; } } else { //if (debug) { //console.log(cell); //console.log(tile); //} self.moveTile(tile, positions.farthest); } if (!self.positionsEqual(cell, tile)) { self.playerTurn = false; //console.log('setting player turn to ', self.playerTurn); moved = true; // The tile moved from its original cell! } } }); }); //console.log('returning, playerturn is', self.playerTurn); //if (!moved) { //console.log('cell', cell); //console.log('tile', tile); //console.log('direction', direction); //console.log(this.toString()); //} return {moved: moved, score: score, won: won}; }; Grid.prototype.computerMove = function() { this.addRandomTile(); this.playerTurn = true; } // Build a list of positions to traverse in the right order Grid.prototype.buildTraversals = function (vector) { var traversals = { x: [], y: [] }; for (var pos = 0; pos &lt; this.size; pos++) { traversals.x.push(pos); traversals.y.push(pos); } // Always traverse from the farthest cell in the chosen direction if (vector.x === 1) traversals.x = traversals.x.reverse(); if (vector.y === 1) traversals.y = traversals.y.reverse(); return traversals; }; Grid.prototype.findFarthestPosition = function (cell, vector) { var previous; // Progress towards the vector direction until an obstacle is found do { previous = cell; cell = { x: previous.x + vector.x, y: previous.y + vector.y }; } while (this.withinBounds(cell) &amp;&amp; this.cellAvailable(cell)); return { farthest: previous, next: cell // Used to check if a merge is required }; }; Grid.prototype.movesAvailable = function () { return this.cellsAvailable() || this.tileMatchesAvailable(); }; // Check for available matches between tiles (more expensive check) // returns the number of matches Grid.prototype.tileMatchesAvailable = function () { var self = this; //var matches = 0; var tile; for (var x = 0; x &lt; this.size; x++) { for (var y = 0; y &lt; this.size; y++) { tile = this.cellContent({ x: x, y: y }); if (tile) { for (var direction = 0; direction &lt; 4; direction++) { var vector = self.getVector(direction); var cell = { x: x + vector.x, y: y + vector.y }; var other = self.cellContent(cell); if (other &amp;&amp; other.value === tile.value) { return true; //matches++; // These two tiles can be merged } } } } } //console.log(matches); return false; //matches; }; Grid.prototype.positionsEqual = function (first, second) { return first.x === second.x &amp;&amp; first.y === second.y; }; Grid.prototype.toString = function() { string = ''; for (var i=0; i&lt;4; i++) { for (var j=0; j&lt;4; j++) { if (this.cells[j][i]) { string += this.cells[j][i].value + ' '; } else { string += '_ '; } } string += '\n'; } return string; } // counts the number of isolated groups. Grid.prototype.islands = function() { var self = this; var mark = function(x, y, value) { if (x &gt;= 0 &amp;&amp; x &lt;= 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 3 &amp;&amp; self.cells[x][y] &amp;&amp; self.cells[x][y].value == value &amp;&amp; !self.cells[x][y].marked ) { self.cells[x][y].marked = true; for (direction in [0,1,2,3]) { var vector = self.getVector(direction); mark(x + vector.x, y + vector.y, value); } } } var islands = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y]) { this.cells[x][y].marked = false } } } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cells[x][y] &amp;&amp; !this.cells[x][y].marked) { islands++; mark(x, y , this.cells[x][y].value); } } } return islands; } // measures how smooth the grid is (as if the values of the pieces // were interpreted as elevations). Sums of the pairwise difference // between neighboring tiles (in log space, so it represents the // number of merges that need to happen before they can merge). // Note that the pieces can be distant Grid.prototype.smoothness = function() { var smoothness = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if ( this.cellOccupied( this.indexes[x][y] )) { var value = Math.log(this.cellContent( this.indexes[x][y] ).value) / Math.log(2); for (var direction=1; direction&lt;=2; direction++) { var vector = this.getVector(direction); var targetCell = this.findFarthestPosition(this.indexes[x][y], vector).next; if (this.cellOccupied(targetCell)) { var target = this.cellContent(targetCell); var targetValue = Math.log(target.value) / Math.log(2); smoothness -= Math.abs(value - targetValue); } } } } } return smoothness; } Grid.prototype.monotonicity = function() { var self = this; var marked = []; var queued = []; var highestValue = 0; var highestCell = {x:0, y:0}; for (var x=0; x&lt;4; x++) { marked.push([]); queued.push([]); for (var y=0; y&lt;4; y++) { marked[x].push(false); queued[x].push(false); if (this.cells[x][y] &amp;&amp; this.cells[x][y].value &gt; highestValue) { highestValue = this.cells[x][y].value; highestCell.x = x; highestCell.y = y; } } } increases = 0; cellQueue = [highestCell]; queued[highestCell.x][highestCell.y] = true; markList = [highestCell]; markAfter = 1; // only mark after all queued moves are done, as if searching in parallel var markAndScore = function(cell) { markList.push(cell); var value; if (self.cellOccupied(cell)) { value = Math.log(self.cellContent(cell).value) / Math.log(2); } else { value = 0; } for (direction in [0,1,2,3]) { var vector = self.getVector(direction); var target = { x: cell.x + vector.x, y: cell.y+vector.y } if (self.withinBounds(target) &amp;&amp; !marked[target.x][target.y]) { if ( self.cellOccupied(target) ) { targetValue = Math.log(self.cellContent(target).value ) / Math.log(2); if ( targetValue &gt; value ) { //console.log(cell, value, target, targetValue); increases += targetValue - value; } } if (!queued[target.x][target.y]) { cellQueue.push(target); queued[target.x][target.y] = true; } } } if (markAfter == 0) { while (markList.length &gt; 0) { var cel = markList.pop(); marked[cel.x][cel.y] = true; } markAfter = cellQueue.length; } } while (cellQueue.length &gt; 0) { markAfter--; markAndScore(cellQueue.shift()) } return -increases; } // measures how monotonic the grid is. This means the values of the tiles are strictly increasing // or decreasing in both the left/right and up/down directions Grid.prototype.monotonicity2 = function() { // scores for all four directions var totals = [0, 0, 0, 0]; // up/down direction for (var x=0; x&lt;4; x++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[x][next] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:x, y:current}) ? Math.log(this.cellContent( this.indexes[x][current] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:x, y:next}) ? Math.log(this.cellContent( this.indexes[x][next] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[0] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[1] += currentValue - nextValue; } current = next; next++; } } // left/right direction for (var y=0; y&lt;4; y++) { var current = 0; var next = current+1; while ( next&lt;4 ) { while ( next&lt;4 &amp;&amp; !this.cellOccupied( this.indexes[next][y] )) { next++; } if (next&gt;=4) { next--; } var currentValue = this.cellOccupied({x:current, y:y}) ? Math.log(this.cellContent( this.indexes[current][y] ).value) / Math.log(2) : 0; var nextValue = this.cellOccupied({x:next, y:y}) ? Math.log(this.cellContent( this.indexes[next][y] ).value) / Math.log(2) : 0; if (currentValue &gt; nextValue) { totals[2] += nextValue - currentValue; } else if (nextValue &gt; currentValue) { totals[3] += currentValue - nextValue; } current = next; next++; } } return Math.max(totals[0], totals[1]) + Math.max(totals[2], totals[3]); } Grid.prototype.maxValue = function() { var max = 0; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { var value = this.cellContent(this.indexes[x][y]).value; if (value &gt; max) { max = value; } } } } return Math.log(max) / Math.log(2); } // WIP. trying to favor top-heavy distributions (force consolidation of higher value tiles) /* Grid.prototype.valueSum = function() { var valueCount = []; for (var i=0; i&lt;11; i++) { valueCount.push(0); } for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (this.cellOccupied(this.indexes[x][y])) { valueCount[Math.log(this.cellContent(this.indexes[x][y]).value) / Math.log(2)]++; } } } var sum = 0; for (var i=1; i&lt;11; i++) { sum += valueCount[i] * Math.pow(2, i) + i; } return sum; } */ // check for win Grid.prototype.isWin = function() { var self = this; for (var x=0; x&lt;4; x++) { for (var y=0; y&lt;4; y++) { if (self.cellOccupied(this.indexes[x][y])) { if (self.cellContent(this.indexes[x][y]).value == 2048) { return true; } } } } return false; } //Grid.prototype.zobristTable = {} //for //Grid.prototype.hash = function() { //}</span></span></code> </pre> </div></div><br><h2>  2048.xlsm </h2><br>  La propia aplicaci√≥n Excel se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puede descargar de Google</a> . <br><br>  La funcionalidad de la aplicaci√≥n se describe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en un art√≠culo anterior, donde AI juega usando el m√©todo Monte Carlo</a> .  La soluci√≥n de hoy se ha agregado al Monte Carlo existente. <br><br><h3>  Todos los art√≠culos de la serie AI y 2048. </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Montecarlo</a> </li><li>  <strong>Recorte de minimax + alfa beta</strong> </li><li>  Esperando el m√°ximo </li><li>  Red neuronal </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474680/">https://habr.com/ru/post/474680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474668/index.html">Acciones de GitHub como CI / CD para un sitio en un generador est√°tico y p√°ginas de GitHub</a></li>
<li><a href="../474672/index.html">React, JSX, importaci√≥n de m√≥dulos ES (incluido din√°mico) en un navegador sin Webpack</a></li>
<li><a href="../474674/index.html">Visi√≥n artificial y medicina</a></li>
<li><a href="../474676/index.html">El algoritmo de interacci√≥n de cientos de miles de part√≠culas √∫nicas en la GPU, en GLES3 y WebGL2</a></li>
<li><a href="../474678/index.html">Khronos Group ha creado un repositorio unificado con ejemplos de Vulkan</a></li>
<li><a href="../474686/index.html">Fant√°stica historia "Salvaci√≥n" (10 min.)</a></li>
<li><a href="../474688/index.html">Tren retro con una locomotora de vapor</a></li>
<li><a href="../474690/index.html">Crear una consola con una altura variable para un trabajo m√°s conveniente en una computadora</a></li>
<li><a href="../474692/index.html">Revisi√≥n de Skaffold para el desarrollo de Kubernetes</a></li>
<li><a href="../474694/index.html">C√≥mo seleccionamos y torcimos el marco para las pruebas de rendimiento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>