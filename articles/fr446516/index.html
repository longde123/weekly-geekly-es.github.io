<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗯️ 🧑🏽‍🤝‍🧑🏻 🚵🏽 Visualisation du temps de renaissance de Roshan 🌑 👰 📺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article traite de l'interception de fonctions API graphiques à l'aide de l'exemple de DirectX 9 pour x64 par rapport au jeu Dota 2 . 

 Il sera dé...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Visualisation du temps de renaissance de Roshan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446516/">  Cet article traite de l'interception de fonctions API graphiques à l'aide de l'exemple de DirectX 9 pour x64 par rapport au jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dota 2</a> . <br><br>  Il sera décrit en détail comment infiltrer le processus de jeu, comment changer le flux d'exécution, une brève description de la logique implémentée est donnée.  Au final, nous parlerons des autres fonctionnalités de rendu fournies par le moteur. <br><br><img src="https://habrastorage.org/webt/b0/rp/kn/b0rpknk7iobhh3darfcrte8ncmo.jpeg"><br><br><blockquote>  <b>Avertissement: L'auteur n'est pas responsable de votre utilisation des connaissances acquises dans cet article ou des dommages résultant de leur utilisation.</b>  <b>Toutes les informations présentées ici sont uniquement à des fins éducatives.</b>  <b>Surtout pour les entreprises développant MOBA pour les aider à faire face aux tricheurs.</b>  <b>Et, bien sûr, l'auteur de l'article est un pilote de bot, un tricheur, et il l'a toujours été.</b> </blockquote><a name="habracut"></a>  La dernière phrase mérite d'être expliquée - je suis pour une concurrence loyale.  J'utilise les tricheurs uniquement par intérêt sportif, améliore les compétences inverses, étudie le travail des anti-tricheurs et uniquement en dehors des compétitions de classement. <br><br><h2>  1. Introduction </h2><br>  Cet article est prévu comme le premier d'une série et donne une idée de la façon dont vous pouvez utiliser l'API graphique à vos propres fins, décrit les fonctionnalités requises pour comprendre la partie suivante.  Je prévois de consacrer le deuxième article à la recherche d'un pointeur sur la liste des entités dans Source 2 (en utilisant également Dota 2 comme exemple) et à l'utiliser en conjonction avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Source2Gen</a> pour écrire une logique «supplémentaire» (quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ça</a> affichera très probablement «pirater la carte» (vérifier attention aux citations, ce qui est en jeu peut être vu dans la vidéo), ou automatisation du premier article).  Le troisième article est prévu sous la forme d'écrire un pilote, de communiquer avec lui (IOCTL), de l'utiliser pour contourner la protection VAC (quelque chose de similaire à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cela</a> ). <br><br><h2>  2. Pourquoi en ai-je besoin </h2><br>  J'avais besoin de l'utilisation de l'API graphique pour déboguer visuellement mon bot, que j'ai écrit pour Dota 2 (les informations visualisées en temps réel sont très pratiques).  Je suis un étudiant diplômé et je suis engagé dans la reconstruction de têtes 3D et le morphing à l'aide d'images et d'une caméra de profondeur - le sujet est assez intéressant, mais pas mon préféré.  Depuis que je fais ça depuis la cinquième année (en commençant par le programme de maîtrise), j'ai compris une chose - oui, j'ai bien étudié ce domaine, j'étudie facilement des articles avec des méthodes et des approches, et je les mets en œuvre.  Mais c’est tout, je ne peux moi-même qu’optimiser le prochain algorithme appris, le comparer avec ceux déjà étudiés et mis en œuvre et décider de l’utiliser dans une tâche particulière.  C'est la fin de l'optimisation, il n'est pas possible de trouver quelque chose de nouveau moi-même, ce qui est très important pour les études supérieures (la nouveauté de l'étude).  J'ai commencé à penser - alors qu'il reste du temps, vous pouvez trouver un nouveau sujet.  Vous devez déjà bien comprendre le sujet (au niveau actuel) ou vous pouvez le retirer rapidement. <br><br>  En même temps, j'ai travaillé dans le développement de jeux, et c'est probablement le plus intéressant de ce qu'un programmeur peut faire (opinion personnelle) et j'étais très intéressé par le sujet de l'IA, les bots.  À cette époque, il y avait deux sujets que je comprenais très bien - puis je construisais un maillage de navigation dynamique (client-serveur) et j'étudiais la partie réseau d'un jeu de tir dynamique.  Un sujet avec un navigateur dynamique ne cadrait pas tout de suite - je l'ai fait pendant les heures de travail, j'ai dû demander à la direction l'autorisation de l'utiliser dans mon diplôme, d'ailleurs, le sujet de nouveauté était ouvert - j'ai également étudié et mis en œuvre les approches existantes bien par article, mais ce n'était pas nouveau.  Le sujet avec la partie réseau du jeu de tir dynamique (je prévoyais de l'utiliser pour l'interaction en réalité virtuelle) est à nouveau tombé en panne à la fois sur le fait que je le faisais pendant les heures de travail, et sur la nouveauté, vous pouvez lire une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">série d'articles</a> de Pixonic, où l'auteur lui-même dit que le sujet c'est intéressant, seules les approches ont été inventées il y a 30 ans et n'ont pas beaucoup changé. <br><br>  A cette époque, OpenAI a sorti son bot.  Ce n'est certainement pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5 par 5</a> , mais c'était génial!  Je ne pouvais pas jeter des idées pour essayer de faire un bot et tout d'abord j'ai commencé à réfléchir à la façon de l'utiliser comme dissertation, à la nouveauté et à la présenter à un leader.  Avec la nouveauté à cet égard, tout allait beaucoup mieux - c'était sûr qu'il était possible de trouver quelque chose pour les deux sujets précédents, mais apparemment, le bot m'a fait réfléchir, m'accrocher, développer et rechercher des idées beaucoup plus fortes.  J'ai donc décidé de créer un bot 1 contre 1 (une bataille au milieu, comme OpenAI), de le présenter au leader, de dire à quel point c'est cool, combien d'approches différentes, les mathématiques et, surtout, la nouvelle. <br><br>  La chose la plus nécessaire dont le bot a besoin à la première étape est la connaissance de l'environnement dans lequel il se trouve - j'avais l'intention de prendre l'état du monde de la mémoire du jeu et j'ai passé la première étape à chercher un pointeur vers la liste des entités et à l'intégrer avec l'idée originale de la prière Dog2 Source2Gen - cette chose génère la structure du moteur Source2, qu'elle prend des circuits.  L'idée principale et la condition préalable à l'émergence de schémas est la réplication de l'état entre le client et le serveur, mais apparemment les développeurs ont vraiment aimé l'idée et ils l'ont distribuée beaucoup plus largement, je vous conseille de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  J'ai eu une expérience d'ingénierie inverse: j'ai fait des tricheurs pour Silent Storm, fait des générateurs de clés (le plus intéressant était pour Black &amp; White) - ce qui est keygen peut être lu à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">DrMefistO</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , l'exécution de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combo</a> dans Cabal Online (tout était compliqué par le fait que ce jeu était protégé par Game Guard , l'a gardé de ring0 (sous le pilote en mode noyau), cachant le processus (ce qui au moins ne facilite pas l'infiltration) - plus de détails peuvent être lus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ). <br>  En conséquence, j'ai eu des développements dans ce domaine, le bot a eu accès à l'environnement pour la durée prévue.  Il est étonnant de voir combien d'informations le serveur de bunker réplique via le delta au client, par exemple, le client a des informations sur les téléporteurs, la santé et ses changements parmi les agents (sauf Roshan, il ne réplique pas) - tout cela est dans le brouillard de la guerre.  Bien que j'aie rencontré quelques difficultés, c'est ce dont je vais parler dans le prochain article. <br>  Si vous avez une question pourquoi je n'ai pas utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dota Bot Scripting</a> , je répondrai avec un extrait de la documentation: <br><blockquote>  L'API est restreinte de sorte que les scripts ne peuvent pas tricher - les unités dans FoW ne peuvent pas être interrogées, les commandes ne peuvent pas être émises vers les unités que le script ne contrôle pas, etc. </blockquote>  Cette série d'articles s'adresse aux débutants intéressés par le sujet de la rétro-ingénierie. <br><br><h2>  3. Pourquoi j'écris à ce sujet </h2><br>  En conséquence, j'ai rencontré beaucoup de problèmes dans la mise en œuvre du bot de ml, sur lequel j'ai passé suffisamment de temps pour comprendre que deux ans avant la fin de la formation, je ne pouvais pas dépasser mes connaissances et mon expérience dans le sujet actuel.  Dans Dota 2, je ne joue pas depuis la sortie de la coutume Dota Auto Chess, je passe maintenant mon temps libre sur le diplôme et l'inverse d'Apex Legend (dont la structure est assez similaire à Dota 2, comme il me semble).  En conséquence, le seul avantage du travail réalisé est la publication d'un article technique sur ce sujet. <br><br><h2>  4. Dota 2 </h2><br>  Je prévois de montrer ces principes sur un vrai jeu - Dota 2. Le jeu utilise l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">anti-</a> triche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Valve Anti Cheat</a> .  J'aime vraiment Valve en tant qu'entreprise: produits très cool, réalisateur, attitude envers les joueurs, Steam, Source Engine 2, ... VAC.  VAC fonctionne en mode utilisateur (ring3), il ne scanne pas tout et est inoffensif par rapport aux autres anti-tricheurs (de ce que fait l'easea (en particulier leur anti-triche), tout désir d'utiliser cette plateforme disparaît).  Je suis sûr que VAC fait son travail avec parcimonie - il ne surveille pas le mode noyau, il n'interdit pas le matériel (uniquement un compte), il n'insère pas de filigrane dans les captures d'écran - grâce à l'attitude de Valve envers les joueurs, ils n'installent pas pour vous un antivirus à part entière, comme ils le font Game Guard, BattlEye, Warden et autres, car tout est piraté et dépense des ressources processeur que le jeu pourrait prendre (même si cela est fait périodiquement), il y a des faux positifs (en particulier pour les joueurs sur les ordinateurs portables).  N'y a-t-il pas un hack de mur, aimbot, speed hack, ESP dans PUBG, Apex, Fortnite? <br><br>  En fait à propos de Dota 2. Le jeu fonctionne à une fréquence de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">40 Hz</a> (25 ms), le client interpole l'état du jeu, la prédiction d'entrée n'est pas utilisée - si vous avez un décalage, un jeu - il est important même pas un jeu, les unités contrôlées - sont complètement gelés.  Le serveur de mécanique de jeu échange des messages cryptés avec le client via RUDP (UDP fiable), le client envoie essentiellement des entrées (si vous hébergez le lobby, des commandes peuvent être envoyées), le serveur envoie une réplique du monde du jeu et des équipes.  La navigation s'effectue sur une grille 3D, chaque cellule a son propre type de perméabilité.  Le mouvement s'effectue par la navigation et la physique (impossibilité de traverser la fissure d'un shaker, kogi clokverka, etc.). <br><br>  L'état du monde avec toutes les entités est en mémoire dans sa forme la plus pure sans cryptage - vous pouvez étudier la mémoire du jeu en utilisant le Cheat Engine.  L'obfuscation ne s'applique pas aux chaînes et au code. <br><br><div class="spoiler">  <b class="spoiler_title">DirectX9, DirectX11, Vulkan, OpenGL sont disponibles à partir de l'API graphique.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/xc/xq/kl/xcxqkl2qpwy3gved7_jblzsqumo.png"><br></div></div><br><h2>  5. Énoncé du problème </h2><br>  Dans le jeu Dota 2, il y a un "ancien" neutre, dont le meurtre donne une bonne récompense: l'expérience, l'or, la possibilité de faire reculer les temps de recharge des compétences et des objets, Aegis (seconde vie), son nom est Roshan.  Obtenir Aegis peut fondamentalement changer la donne ou donner un avantage encore plus grand à la partie la plus forte, respectivement, les joueurs essaient de se souvenir / d'enregistrer l'heure de sa mort afin de planifier quand se réunir et l'attaquer, ou être à proximité pour sa protection.  Les dix joueurs sont informés de la mort de Roshan, qu'il soit ou non caché dans le brouillard de la guerre.  Le temps de réapparition a huit minutes obligatoires, après quoi Roshan peut apparaître au hasard dans l'intervalle de trois minutes. <br><br>  <i>La tâche est la suivante</i> : fournir au joueur des informations sur l'état actuel de Roshan (vivant-vivant, ressurect_base-revives temps de base, ressurect_extra-revives temps supplémentaire). <br><br> <a href=""><img src="https://habrastorage.org/webt/qf/ef/3s/qfef3s2h4a6l_pfageiblxwqhd8.png"></a> <br>  <i>Figure 1 - Conditions de transition entre les états et actions pendant la transition</i> <br><br>  Pour les conditions dans lesquelles Roshan est mort, affichez l'heure de fin du séjour dans cet état.  La transition de l'état vivant à ressurect_base doit être effectuée par le joueur en mode manuel par le bouton.  En cas de détection / mort de Roshan dans l'état ressurect_extra (par exemple, une équipe ennemie s'est faufilée secrètement dans la tanière et l'a tué), la transition vers l'état vivant / ressurect_base est également effectuée manuellement à l'aide du bouton.  Le statut de Roshan (et l'heure de fin d'être dans un état de réveil) doit être affiché sous forme de texte, l'entrée nécessaire (destruction et interruption de l'état de ressurect_extra) doit être fournie avec un bouton. <br><br><img src="https://habrastorage.org/webt/cb/xw/ne/cbxwneudadwlvbx4ch2gwumlona.png"><br>  <i>Figure 2 - Éléments d'interface - étiquette, bouton et canevas</i> <br><br>  C'est la seule tâche que je pouvais imaginer pour ne pas avoir à travailler avec la mémoire du jeu et il y avait au moins une certaine valeur pour le joueur - même pour dériver des caractéristiques élémentaires, telles que la santé, le mana et les positions des entités, vous devez soit les trouver à l'avance aider le Cheat Engine dans la mémoire du jeu, qui doit en outre être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expliqué pendant</a> assez longtemps, ou avec l'aide de Source2Gen, qui sera discuté dans le prochain article.  L'énoncé du problème oblige le joueur à suivre Roshan, déplaçant beaucoup d'actions vers lui, ce qui est plutôt gênant - mais il y aura quelque chose sur lequel s'appuyer dans la deuxième partie. <br><br>  Nous allons écrire notre injected.dll, qui contiendra la logique métier basée sur MVC et l'implémenter dans le processus Dota 2. La DLL utilisera notre bibliothèque silk_way.lib, qui contiendra la logique d'interruption pour modifier le flux d'exécution, l'enregistreur, le scanner de mémoire et les structures de données . <br><br><h2>  6. Injecteur </h2><br>  Créez un projet C ++ vide, appelez NativeInjector.  Le code principal se trouve dans la fonction Inject. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; dllPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; processName)</span></span></span><span class="hljs-function"> </span></span>{ DWORD processId = GetProcessIdentificator(processName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (processId == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> invalid_argument(<span class="hljs-string"><span class="hljs-string">"Process dont existed"</span></span>); HANDLE hProcess = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, processId); HMODULE hModule = GetModuleHandle(<span class="hljs-string"><span class="hljs-string">"kernel32.dll"</span></span>); FARPROC address = GetProcAddress(hModule, <span class="hljs-string"><span class="hljs-string">"LoadLibraryA"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> payloadSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) * dllPath.length() + <span class="hljs-number"><span class="hljs-number">1</span></span>; LPVOID allocAddress = VirtualAllocEx( hProcess, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, payloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); SIZE_T written; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> writeResult = WriteProcessMemory(hProcess, allocAddress, dllPath.c_str(), payloadSize, &amp; written); DWORD treadId; CreateRemoteThread(hProcess, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, (LPTHREAD_START_ROUTINE) address, allocAddress, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp; treadId); CloseHandle(hProcess); }</code> </pre> <br>  La fonction obtient le chemin et le nom du processus, recherche son ID par le nom du processus à l'aide de GetProcessIdentificator. <br><br><div class="spoiler">  <b class="spoiler_title">fonction GetProcessIdentificator</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProcessIdentificator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; processName)</span></span></span><span class="hljs-function"> </span></span>{ PROCESSENTRY32 processEntry; processEntry.dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(PROCESSENTRY32); HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); DWORD processId = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Process32First(snapshot, &amp; processEntry)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Process32Next(snapshot, &amp; processEntry)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_stricmp(processEntry.szExeFile, processName.c_str())) { processId = processEntry.th32ProcessID; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } CloseHandle(snapshot); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> processId; }</code> </pre> <br></div></div><br>  En bref, GetProcessIdentificator parcourt tous les processus en cours d'exécution et recherche un processus avec le nom approprié. <br><br><img src="https://habrastorage.org/webt/du/za/p1/duzap1ptnhys_gyk_e1zrjm436e.png"><br>  <i>Figure 3 - l'état initial du processus</i> <br><br>  Ensuite, l'implémentation directe de la bibliothèque en créant un flux distant. <br><br><div class="spoiler">  <b class="spoiler_title">Explication détaillée de la fonction d'injection</b> <div class="spoiler_text">  Sur la base de l'ID trouvé, le processus est ouvert à l'aide de la fonction OpenProcess avec les droits pour créer un thread, recevoir des informations sur le processus, écrire et lire des capacités.  La fonction GetModuleHandle récupère le module de bibliothèque kernel32, cela est fait pour obtenir l'adresse de la fonction LoadLibraryA contenue dans celle-ci par la fonction GetProcAddress.  Le but de LoadLibrary est de charger notre injected.dll dans le processus spécifié.  Autrement dit, nous devons appeler LoadLibrary à partir du processus qui nous intéresse («Dota2.exe»), pour cela, nous créons à distance un nouveau thread à l'aide de CreateRemoteThread.  En tant que pointeur sur la fonction à partir de laquelle le nouveau thread démarre, nous transmettons l'adresse de la fonction LoadLibraryA.  Si vous regardez la signature de la fonction LoadLibraryA, elle requiert le chemin d'accès à la bibliothèque chargée comme argument - HMODULE LoadLibraryA (LPCSTR lpLibFileName).  Nous livrons cet argument comme suit: CreateRemoteThread dans les paramètres après que l'adresse de la fonction de démarrage a pris un pointeur sur ses paramètres, nous formons un pointeur sur lpLibFileName en écrivant la valeur dans la mémoire de processus à l'aide de la fonction WriteProcessMemory (après avoir alloué de la mémoire à l'aide de VirtualAllocEx). <br></div></div><br><img src="https://habrastorage.org/webt/wx/8r/5v/wx8r5viycrlhjarivk-02dgh124.png"><br>  <i>Figure 4 - Création d'un flux distant</i> <br><br>  Assurez-vous de fermer le gestionnaire de processus à la fin avec la fonction CloseHandle, vous pouvez également libérer la mémoire allouée.  Notre injecteur est prêt et attend que nous écrivions la logique métier dans injected.dll avec la bibliothèque silk_way.lib. <br><br><img src="https://habrastorage.org/webt/no/8c/tr/no8ctrxtn_vz31nad0uj25tb8zs.png"><br>  <i>Figure 5 - Fin de l'implémentation de la bibliothèque</i> <br><br>  Pour une meilleure compréhension du principe, vous pouvez regarder la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo</a> .  En conclusion, je dirai que c'est une approche plus sûre avec l'implémentation directe de code dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thread principal du</a> processus. <br><br><h2>  7. Silk Way </h2><br>  Commençons à implémenter silk_way.lib, une bibliothèque statique qui contient des structures de données, un enregistreur, un scanner de mémoire et des interruptions.  En fait, j'ai pris une petite partie de mon travail, quelque chose qui s'explique le plus simplement, qui n'est pas trop lié au reste, mais qui résout en même temps le problème. <br><br><h3>  7.1.  Structures de données. </h3><br>  En bref sur les structures de données: vecteur - liste classique, temps d'insertion et de suppression O (N), recherche O (N), mémoire O (N);  File d'attente - une file d'attente circulaire, le temps d'insertion et de suppression de O (1), pas de recherche, la mémoire O (N);  RBTree - arbre rouge-noir, temps d'insertion et de suppression O (logN), recherche O (logN), mémoire O (N).  Je préfère le hachage utilisé pour implémenter les dictionnaires en C # et Python, les arbres rouge-noir que la bibliothèque C ++ standard utilise.  La raison en est qu'un hachage est plus difficile à mettre en œuvre correctement par rapport à un arbre (je trouve et essaie des variétés de hachage environ tous les six mois), et généralement un hachage prend plus de mémoire (bien qu'il fonctionne plus rapidement).  Ces structures sont utilisées pour créer des collections à la fois dans la logique métier et dans les traps. <br><br>  J'essaie de ne pas utiliser les structures de la bibliothèque standard et de les implémenter moi-même, en particulier, cela n'a pas d'importance dans notre cas, mais il est important si votre DLL est déboguée ou que l'assembly est en clair (c'est plus probable pour les tricheurs commerciaux, que nous condamnons )  Je vous conseille d'écrire vous-même toutes les structures, cela vous donne plus d'opportunités. <br>  Par exemple, si vous créez un jeu et que vous ne voulez pas que les «écoliers» le scannent à l'aide du Cheat Engine, vous pouvez créer des wrappers pour les types primitifs et stocker la valeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chiffrée</a> en mémoire.  En fait, ce n'est pas un salut, mais cela peut éliminer certains de ceux qui essaient de lire et de changer la mémoire du jeu. <br><br><h3>  7.2.  Enregistreur </h3><br>  Sortie implémentée sur la console et écriture dans un fichier.  Interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ILogger</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ILogger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * _path) { path = path; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ILogger() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * format, ...)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * path; };</code> </pre> <br>  Implémentation pour sortie dans un fichier: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemoryLogger</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ILogger { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MemoryLogger(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * _path): ILogger(_path) { fopen_s( &amp; fptr, _path, <span class="hljs-string"><span class="hljs-string">"w+"</span></span>); } ~MemoryLogger() { fclose(fptr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * format, ...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>[MAX_LOG_SIZE]; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>[MAX_LOG_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; va_list args; va_start(args, format); vsprintf_s(<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>, MAX_LOG_SIZE, format, args); va_end(args); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: FILE * fptr; };</code> </pre> <br>  L'implémentation pour la sortie vers la console est la même.  Si nous voulons utiliser la journalisation, il est nécessaire de définir l'interface ILogger *, de déclarer le logger nécessaire, d'appeler la fonction Log au format requis, par exemple: <br><br><pre> <code class="cpp hljs">ILogger* logger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryLogger(filename); logger-&gt;Log(<span class="hljs-string"><span class="hljs-string">"(%llu)%s: %d\n"</span></span>, GetCurrentThreadId(), <span class="hljs-string"><span class="hljs-string">"EnumerateThread result"</span></span>, result);</code> </pre> <br><h3>  7.3.  Scanner </h3><br>  Le scanner est engagé dans le fait qu'il affiche la valeur de mémoire pointée par le pointeur transféré et la compare avec l'échantillon en mémoire.  La comparaison fonctionnelle avec le modèle sera examinée plus loin. <br><br>  Interface: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IScanner() {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IScanner() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * memPointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  Implémentation du fichier d'en-tête: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileScanner</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IScanner { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FileScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* _path) : IScanner() { fopen_s(&amp;fptr, _path, <span class="hljs-string"><span class="hljs-string">"w+"</span></span>); } ~FileScanner() { fclose(fptr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* memPointer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: FILE* fptr; };</code> </pre> <br>  Implémentation du fichier source: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FileScanner::PrintMemory(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* title, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* memPointer, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-string"><span class="hljs-string">"%s:\n"</span></span>, title); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-string"><span class="hljs-string">"%x "</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(*(memPointer + i))); <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fptr, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>, title); }</code> </pre> <br>  Pour l'utiliser, vous devez définir l'interface IScanner *, déclarer le scanner souhaité et appeler la fonction PrintMemory, où vous pouvez définir le titre, le pointeur et la longueur, par exemple: <br><br><pre> <code class="cpp hljs">IScanner* scan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleScanner(); scan-&gt;PrintMemory(<span class="hljs-string"><span class="hljs-string">"source orig"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)source, <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><h3>  7.4.  Pièges </h3><br>  La partie la plus intéressante de la bibliothèque silk_way.lib.  Les crochets sont utilisés pour modifier le flux d'exécution du programme.  Créez un projet exécutable appelé Sandbox. <br><br><div class="spoiler">  <b class="spoiler_title">La classe Device sera notre mannequin pour enquêter sur le fonctionnement des pièges.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unknown</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: Unknown() {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~Unknown() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Device</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Unknown { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Device() : Unknown() {} ~Device() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QueryInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ULONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Present</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Present()"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndScene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndScene()"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Dispose()"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; };</code> </pre> <br></div></div><br>  La classe Device est héritée de l'interface IUnknown, notre tâche est d'intercepter l'appel des fonctions Present et EndScene de toute instance de Device, et d'appeler les fonctions d'origine dans le récepteur.  Nous ne savons pas où dans le code où et pourquoi ces fonctions sont appelées, dans quel thread. <br><br>  En regardant les fonctions Present et EndScene, nous voyons qu'elles sont virtuelles.  Des fonctions virtuelles sont nécessaires pour remplacer le comportement de la classe parente.  Les fonctions virtuelles, ainsi que les fonctions non virtuelles, sont un pointeur vers une mémoire dans laquelle les opcodes et les valeurs des arguments sont écrits.  Étant donné que les fonctions virtuelles diffèrent entre les héritiers et les parents, elles ont des pointeurs différents (ce sont des fonctions complètement différentes) et sont stockées dans la table de méthode virtuelle (VMT).  Cette table est stockée en mémoire et est un pointeur vers un pointeur de classe, nous le trouvons pour Device: <br><br><pre> <code class="cpp hljs">Device* device = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Device(); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vmt = **(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>**)&amp;device;</code> </pre> <br>  VMT stocke des pointeurs vers des fonctions virtuelles, si nous voulons hériter de Device, l'héritier contiendra son VMT.  VMT stocke les pointeurs de fonction séquentiellement avec un pas égal à la taille du pointeur (pour x86, il est de 4 octets, pour x64, il est de 8), correspondant à l'ordre dans lequel la fonction est définie dans la classe.  Trouvez les pointeurs vers les fonctions Present et EndScene, qui se trouvent aux troisième et quatrième endroits: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pPresent)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pEndScene)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span></span>; pPresent ptrPresent = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; pEndScene ptrEndScene = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//declare Device and find pointer vmt ptrPresent = (pPresent)(*(unsigned long long*)(vmt + 8 * 3)); ptrEndScene = (pEndScene)(*(unsigned long long*)(vmt + 8 * 4)); }</span></span></code> </pre> <br>  Il est également important que le pointeur vers la méthode de classe contienne le premier argument comme référence à l'instance de classe.  En C ++, C #, cela nous est caché, et le compilateur le sait - en Python, self est explicitement indiqué par le premier paramètre de la méthode de classe.  Plus d'informations sur la convention d'appel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , vous devez rechercher cet appel. <br><br>  Considérez l'instruction e9 ff 3a fd ff - ici e9 est un opcode (avec des mnémoniques JMP) qui indique au processeur de changer le pointeur sur l'instruction (EIP pour x86, RIP pour x64), passez de l'adresse actuelle à FFFD3AFF (4294785791).  Il convient également de noter que les numéros de mémoire sont stockés «vice versa».  Les fonctions ont un prologue et un épilogue et sont stockées dans la section .code.  Voyons ce qui est stocké avec le pointeur sur la fonction Present à l'aide du scanner: <br><br><pre> <code class="cpp hljs">IScanner* scan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleScanner(); scan-&gt;PrintMemory(<span class="hljs-string"><span class="hljs-string">"Present"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptrPresent, <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br>  Dans la console, nous voyons: <br><br><pre> <code class="plaintext hljs">Present: 48 89 4c 24 8 48 83 ec 28 48 8d 15 40 4a 0 0 48 8b d 71 47 0 0 e8 64 10 0 0 48 8d</code> </pre> <br>  Pour comprendre l'ensemble de ces codes, vous pouvez consulter le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tableau</a> ou utiliser les démonteurs disponibles.  Nous prendrons un démonteur prêt à l'emploi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hde</a> (hacker disassembler engine).  Vous pouvez également regarder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">distorm</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">capstone</a> pour comparaison.  Passez un pointeur sur une fonction à n'importe quel désassembleur et il dira quels opcodes il utilise, les valeurs des arguments, etc. <br><br><h4>  7.4.1 Crochet Opcode </h4><br>  Maintenant, nous sommes prêts à aller directement aux pièges.  Nous allons examiner le crochet Opcode et le point d'arrêt matériel.  Les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pièges les</a> plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">courants</a> que je recommande de mettre en œuvre et d'explorer. <br><br>  Le piège le plus utilisé et le plus simple est probablement le crochet Opcode (dans l'article répertoriant les pièges, il est appelé correction d'octets) - notez qu'il est facilement reconnu par l'anti-triche lorsqu'il est mal utilisé (sans comprendre comment fonctionne l'anti-triche, sans savoir dans quelle zone et section de mémoire il scanne le moment actuel et d'autres choses que l'interdiction ne ralentira pas pour attendre).  Lorsqu'il est utilisé avec talent, c'est un grand piège, rapide et facile à comprendre. <br>  Si, pendant la lecture d'un article, vous lisez simultanément du code et êtes en mode débogage, passez en version - c'est important. <br><br>  Donc, permettez-moi de vous rappeler que nous devons intercepter l'exécution des fonctions Present et EndScene. <br>  Nous implémentons des intercepteurs - des fonctions où nous voulons transférer le contrôle: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PresentHook"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndSceneHook"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Réfléchissons aux abstractions dont nous avons besoin.  Nous avons besoin d'une interface qui nous permettra de définir un piège, de le supprimer et de fournir des informations à ce sujet.  Les informations sur le piège doivent contenir un pointeur sur la fonction interceptée, le récepteur et les fonctions de tremplin (le fait que nous ayons intercepté la fonction ne signifie pas qu'elle n'est plus nécessaire, nous voulons également pouvoir l'utiliser - le tremplin aidera à appeler la fonction interceptée d'origine). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) struct HookRecord { HookRecord() { reservationLen = 0; sourceReservation = new void*[RESERV_SIZE](); } ~HookRecord() { reservationLen = 0; delete[] sourceReservation; } void* source; void* destination; void* pTrampoline; int reservationLen; void* sourceReservation; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(pop) class IHook { protected: IHook() {} public: virtual ~IHook() {} virtual void SetExceptionHandler( PVECTORED_EXCEPTION_HANDLER pVecExcHandler) = 0; virtual int SetHook(void* source, void* destination) = 0; virtual int UnsetHook(void* source) = 0; virtual silk_data::Vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;HookRecord*&gt;* GetInfo() = 0; virtual HookRecord* GetRecordBySource(void* source) = 0; };</span></span></span></span></code> </pre> <br>  L'interface IHook nous offre de telles capacités.  Nous voulons que lorsqu'une instance de la classe Device appelle les fonctions Present et EndScene (c'est-à-dire que le pointeur RIP va vers ces adresses), nos fonctions PresentHook et EndSceneHook sont exécutées en conséquence. <br><br>  Imaginez visuellement comment la fonction interceptée, le récepteur et le tremplin sont situés dans la mémoire (section .code) au moment où la commande entre dans la fonction interceptée: <br><br><img src="https://habrastorage.org/webt/rc/sz/dw/rcszdw_mh77t0jlxithbmseq5i8.png"><br>  <i>Figure 6 - L'état initial de la mémoire, l'exécution passe dans la fonction interceptée</i> <br><br>  Maintenant, nous voulons que le RIP (flèche rouge) passe de la source au début de la destination.  Comment faire  Comme déjà indiqué ci-dessus, la mémoire source contient un opcode que le processeur exécutera lorsque l'exécution atteindra la source.  Essentiellement, nous devons passer d'une partie à l'autre, rediriger le pointeur RIP.  Comme vous l'avez peut-être deviné, il existe un opcode qui vous permet de transférer le contrôle de l'adresse actuelle à l'adresse souhaitée, cette mnémonique JMP est appelée. <br><br>  Vous pouvez sauter directement à l'adresse souhaitée, ou par rapport à l'adresse actuelle, ces sauts peuvent être trouvés dans la plaque - ff et e9, respectivement.  Créez des structures pour ces instructions: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> pack(push, 1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 32-bit relative jump. typedef struct { unsigned char opcode; unsigned int delta; } JMP_REL; // 64-bit absolute jump. typedef struct { unsigned char opcode1; unsigned char opcode2; unsigned int dummy; unsigned long long address; } JMP_ABS; #pragma pack(pop)</span></span></span></span></code> </pre> <br>  L'instruction de saut relatif est plus courte, mais il y a une limitation - un entier non signé indique que vous pouvez sauter dans 4 294 967 295, ce qui n'est pas suffisant pour x64. <br>  En conséquence, l'adresse de la fonction de destination du récepteur de destination peut facilement dépasser cette valeur et être en dehors de l'int entier non signé, ce qui est tout à fait possible pour le processus x64 (pour x86, tout est beaucoup plus simple et vous pouvez vous limiter à ce saut très relatif pour la mise en œuvre du crochet Opcode).  Un saut direct prend 14 octets, à titre de comparaison, un saut relatif n'est que de 5 (nous avons compressé les structures, faites attention au pack #pragma (push, 1)). <br><br>  Nous devons réécrire la valeur à la source dans l'une de ces instructions de saut. <br>  Avant d'attraper une fonction, vous devez l'étudier - la façon la plus simple de le faire est avec un débogueur (je vais vous montrer comment le faire avec x64dbg plus tard), ou avec un désassembleur.  Pour Present, nous avons déjà sorti 30 octets depuis son début, l'instruction 48 89 4c 24 8 occupe 5 octets. <br>  Implémentons un saut relatif.  J'aime plus cette option en raison de la longueur de l'instruction.  L'idée est la suivante: nous remplaçons les 5 premiers octets de la fonction d'origine, en préservant les octets modifiés, les remplaçons par un saut relatif à l'adresse d'instruction, qui se trouve dans l'int entier non signé. <br><br><img src="https://habrastorage.org/webt/sp/vm/gs/spvmgsf5iymwkeyncackpgaldty.png"><br>  <i>Figure 7 - Les 5 octets source de la fonction source sont remplacés par un saut relatif</i> <br><br>  Qu'est-ce qui nous fait sauter dans la mémoire allouée (région violette), comment nous sommes-nous rapprochés du transfert du contrôle vers la destination avec cette action?  Dans la mémoire allouée par nous, il y a un saut direct, qui déplacera RIP vers la destination. <br><br><img src="https://habrastorage.org/webt/nl/-c/u2/nl-cu2sfhlsg-7nvfdmkzmlz8fq.png"><br>  <i>Figure 8 - Passer du RIP à la fonction de récepteur</i> <br><br>  Il reste à comprendre comment appeler la fonction interceptée.  Nous devons exécuter les instructions bloquées et commencer l'exécution à partir de la partie intacte de la source.  Nous procédons comme suit - enregistrez les instructions endommagées au début du trampoline, rappelez-vous combien d'octets ont été endommagés et passez directement à source + corruptLen, aux instructions «saines». <br><br>  Exécution des instructions enregistrées effacées par un saut relatif: <br><br><img src="https://habrastorage.org/webt/ea/yt/yc/eaytyckn1czk5ud3iid3fagbey0.png"><br>  <i>Figure 9 - Utilisation d'un tremplin pour appeler une fonction interceptée</i> <br><br>  Poursuite de l'exécution des instructions qui n'ont pas affecté le brassage: <br><br><img src="https://habrastorage.org/webt/mh/7f/-w/mh7f-wck4tzh20cj7jefie3yl3q.png"><br>  <i>Figure 10 - Poursuite de l'exécution des instructions de la fonction interceptée</i> <br><br><div class="spoiler">  <b class="spoiler_title">Code mettant en œuvre l'idée décrite ci-dessus</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OpcodeHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HookRecord(); record-&gt;source = source; record-&gt;destination = destination; info-&gt;PushBack(record); JMP_ABS pattern = {<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// JMP[RIP + 6] empty 0x0000000000000000 }; // absolute address pattern.address = (ULONG_PTR)source; int currentLen = 0; int redLine = sizeof(JMP_REL); while (currentLen &lt; redLine) { hde64s context; const void* pSource = (void*)((unsigned char*)source + currentLen); hde64_disasm(pSource, &amp;context); memcpy((unsigned char*)record-&gt;sourceReservation + currentLen, pSource, context.len); record-&gt;reservationLen += context.len; currentLen += context.len; } int trampolineMemorySize = 2 * sizeof(JMP_ABS) + record-&gt;reservationLen; record-&gt;pTrampoline = AllocateMemory(source, trampolineMemorySize); pattern.address = (unsigned long long)(unsigned char*)source + record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline, record-&gt;sourceReservation, record-&gt;reservationLen); int offset = record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline + offset, &amp;pattern, sizeof(JMP_ABS)); pattern.address = (ULONG_PTR)destination; ULONG_PTR relay = (ULONG_PTR)record-&gt;pTrampoline + sizeof(pattern) + record-&gt;reservationLen; memcpy((void*)relay, &amp;pattern, sizeof(pattern)); DWORD oldProtect = 0; VirtualProtect(source, sizeof(JMP_REL), PAGE_EXECUTE_READWRITE, &amp;oldProtect); JMP_REL* pJmpRelPattern = (JMP_REL*)source; pJmpRelPattern-&gt;opcode = 0xE9; pJmpRelPattern-&gt;delta = (unsigned int)((LPBYTE)relay - ((LPBYTE)source + sizeof(JMP_REL))); VirtualProtect(source, sizeof(JMP_REL), oldProtect, &amp;oldProtect); return SUCCESS_CODE; }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Explication de la fonction SetHook</b> <div class="spoiler_text">  Un enregistrement est créé qui stocke des informations sur l'interruption, après quoi l'enregistrement est ajouté à la collection.  Les instructions sont analysées depuis le début de l'adresse source jusqu'à ce que l'instruction de saut relative puisse être complètement entrée (5 octets), les instructions bloquées sont copiées dans la réservation, leur longueur est mémorisée. <br><blockquote>  Un point très important est que nous devons allouer de la mémoire pour le tremplin et le relais, dans lesquels nous stockons des instructions pour rediriger le flux de la source vers la destination et l'adresse de cette mémoire doit être dans les limites qu'un saut relatif peut se permettre de sauter vers (non signé int). </blockquote><br>  Cette fonctionnalité implémente la fonction AllocateMemory. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* OpcodeHook::AllocateMemory(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* origin, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MEMORY_RANGE = <span class="hljs-number"><span class="hljs-number">0x40000000</span></span>; SYSTEM_INFO sysInfo; GetSystemInfo(&amp;sysInfo); ULONG_PTR minAddr = (ULONG_PTR)sysInfo.lpMinimumApplicationAddress; ULONG_PTR maxAddr = (ULONG_PTR)sysInfo.lpMaximumApplicationAddress; ULONG_PTR castedOrigin = (ULONG_PTR)origin; ULONG_PTR minDesired = castedOrigin - MEMORY_RANGE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minDesired &gt; minAddr &amp;&amp; minDesired &lt; castedOrigin) minAddr = minDesired; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> test = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ULONG_PTR); ULONG_PTR maxDesired = castedOrigin + MEMORY_RANGE - size; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxDesired &lt; maxAddr &amp;&amp; maxDesired &gt; castedOrigin) maxAddr = maxDesired; DWORD granularity = sysInfo.dwAllocationGranularity; ULONG_PTR freeMemory = <span class="hljs-number"><span class="hljs-number">0</span></span>; ULONG_PTR ptr = castedOrigin; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ptr &gt;= minAddr) { ptr = FindPrev(ptr, minAddr, granularity, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; LPVOID pAlloc = VirtualAlloc((LPVOID)ptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAlloc != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAlloc; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ptr &lt; maxAddr) { ptr = FindNext(ptr, maxAddr, granularity, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; LPVOID pAlloc = VirtualAlloc((LPVOID)ptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAlloc != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pAlloc; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  L'idée est simple - nous irons de la mémoire, en partant d'une certaine adresse (dans notre cas, un pointeur vers la source) de haut en bas jusqu'à ce que nous trouvions une pièce de taille libre appropriée. <br><br>  Retour à la fonction SetHook.  Copiez les octets usés de la source dans la mémoire allouée et insérez immédiatement un saut direct vers la source + corrompu pour continuer l'exécution avec des instructions intactes. <br><br>  Vient ensuite l'installation du pointeur de relais, qui est responsable de la redirection du thread d'exécution vers la destination en sautant directement à l'adresse du récepteur.  À la fin, nous changeons la source - nous définissons des autorisations d'écriture à l'endroit de la mémoire où se trouve la fonction et remplaçons les 5 premiers octets par un saut relatif menant à l'adresse du relais. <br></div></div><br>  Nous avons installé un piège, mais il doit également pouvoir être nettoyé.  Briser - pas construire, l'idée est simple - nous retournerons les octets minables de la source, supprimerons l'enregistrement de l'interruption de la collection et libérerons la mémoire allouée: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OpcodeHook::UnsetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = GetRecordBySource(source); DWORD oldProtect = <span class="hljs-number"><span class="hljs-number">0</span></span>; VirtualProtect(source, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(JMP_REL), PAGE_EXECUTE_READWRITE, &amp;oldProtect); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(source, record-&gt;sourceReservation, record-&gt;reservationLen); VirtualProtect(source, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(JMP_REL), oldProtect, &amp;oldProtect); info-&gt;Erase(record); FreeMemory(record); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br>  Test du travail.  Changez immédiatement nos récepteurs afin qu'ils puissent appeler les fonctions interceptées à l'aide du tremplin: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrPresent); pPresent pTrampoline = (pPresent)record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(device); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PresentHook"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrEndScene); pEndScene pTrampoline = (pEndScene)record-&gt;pTrampoline; pTrampoline(device, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndSceneHook"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous testons si nous avons tout fait correctement, si la mémoire coule, si tout est correctement exécuté.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Device* device = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Device(); device-&gt;i = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vmt = **(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>**)&amp;device; ptrPresent = (pPresent)(*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(vmt + <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>)); ptrEndScene = (pEndScene)(*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>*)(vmt + <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>)); IScanner* scan = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleScanner(); scan-&gt;PrintMemory(<span class="hljs-string"><span class="hljs-string">"Present"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)ptrPresent, <span class="hljs-number"><span class="hljs-number">30</span></span>); hook = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpcodeHook(); hook-&gt;SetHook(ptrPresent, &amp;PresentHook); hook-&gt;SetHook(ptrEndScene, &amp;EndSceneHook); device-&gt;Present(); device-&gt;EndScene(<span class="hljs-number"><span class="hljs-number">7</span></span>); device-&gt;Present(); device-&gt;EndScene(<span class="hljs-number"><span class="hljs-number">7</span></span>); device-&gt;i = <span class="hljs-number"><span class="hljs-number">5</span></span>; ptrPresent(device); ptrEndScene(device, <span class="hljs-number"><span class="hljs-number">9</span></span>); hook-&gt;UnsetHook(ptrPresent); hook-&gt;UnsetHook(ptrEndScene); ptrPresent(device); ptrEndScene(device, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> hook; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> device; } }</code> </pre> <br></div></div><br>  Ça marche.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez également archiver x64dgb. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelez-vous, au début, je vous ai demandé de travailler dans la version Release? </font><font style="vertical-align: inherit;">Allez maintenant dans Debug et exécutez le programme. </font><font style="vertical-align: inherit;">Le programme se bloque ... Le piège est déclenché, mais une tentative d'appeler le tremplin lève une exception, qui dit que l'adresse à laquelle nous appelons le tremplin n'est pas du tout pour l'exécution. </font><font style="vertical-align: inherit;">Qu'avons-nous manqué? </font><font style="vertical-align: inherit;">Quel est le problème de la construction du débogage? </font><font style="vertical-align: inherit;">Nous commençons et regardons l'opcode de la fonction Present:</font></font><br><br><pre> <code class="plaintext hljs">Present: e9 f4 36 0 0 e9 df 8d 0 0 e9 aa b0 0 0 e9 75 3e 0 0 e9 80 38 0 0 e9 da 81 0 0</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'exécution dans x64dbg, vous pouvez voir ce qui suit. </font><i><font style="vertical-align: inherit;">Figure 11 - Instructions d'assemblage de débogage</font></i><font style="vertical-align: inherit;"> Dans Debug, l'opcode a changé, maintenant le compilateur ajoute le saut relatif e9 f4 36 0. Toutes les fonctions sont encapsulées dans le saut, y compris principal et le point d'entrée à mainCRTStartup. Un autre opcode, eh bien, ok, il a dû être copié sur le tremplin, lorsque le tremplin a été appelé, ce saut relatif devrait être appelé, puis un saut direct sur la partie intacte de la source. </font><font style="vertical-align: inherit;">Ici, il devient clair que tout est fait comme nous l'avons mis en œuvre, seul le saut relatif à cela et le relatif, que son exécution à partir d'adresses différentes, de la source et du trampoline, expose RIP à des valeurs complètement différentes.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/sq/ql/ea/sqqlealqgipytxtvqo65agm9ky8.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans mon humble expérience, la mise en œuvre de l'étui de saut relatif couvre 99% de l'utilisation. Il existe plusieurs autres opcodes qui doivent être traités séparément. N'oubliez pas qu'avant de poser un piège sur une fonction, vous ne devriez pas être trop paresseux et l'étudier. Je ne vais pas vous déranger et ajouter des fonctionnalités à la version 100% (encore une fois, dans mon humble expérience), si vous en avez besoin ou êtes intéressé, vous pouvez voir comment ces bibliothèques sont organisées et quels autres cas elles vérifient spécifiquement - ce sera facile à faire si vous avez compris de quoi il s'agit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un saut relatif est en effet assez courant, je propose donc de le mettre en œuvre. </font><font style="vertical-align: inherit;">Un saut relatif se compose de l'opcode e9 et de la valeur à laquelle vous devez passer par rapport à l'adresse actuelle. </font><font style="vertical-align: inherit;">En conséquence, vous pouvez simplement savoir où sauter et sauter directement du tremplin avec un saut direct. </font><font style="vertical-align: inherit;">Même si nous y rencontrons un nouveau saut relatif, ce sera déjà à partir de la bonne adresse.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en place de l'installation du piège en tenant compte du saut relatif</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OpcodeHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HookRecord(); record-&gt;source = source; record-&gt;destination = destination; info-&gt;PushBack(record); JMP_ABS pattern = {<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x25</span></span>, <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// JMP[RIP + 6] empty 0x0000000000000000 }; // address pattern.address = (ULONG_PTR)source; int currentLen = 0; bool isJmpOpcode = false; int redLine = sizeof(JMP_REL); while (currentLen &lt; redLine &amp;&amp; !isJmpOpcode) { hde64s context; const void* pSource = (void*)((unsigned char*)source + currentLen); hde64_disasm(pSource, &amp;context); if (context.opcode == 0xE9) { ULONG_PTR ripPtr = (ULONG_PTR)pSource + context.len + (INT32)context.imm.imm32; pattern.address = ripPtr; isJmpOpcode = true; } memcpy((unsigned char*)record-&gt;sourceReservation + currentLen, pSource, context.len); record-&gt;reservationLen += context.len; currentLen += context.len; } int trampolineMemorySize = isJmpOpcode ? 2 * sizeof(JMP_ABS) : 2 * sizeof(JMP_ABS) + record-&gt;reservationLen; record-&gt;pTrampoline = AllocateMemory(source, trampolineMemorySize); if (!isJmpOpcode) { pattern.address = (unsigned long long)(unsigned char*)source + record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline, record-&gt;sourceReservation, record-&gt;reservationLen); } int offset = isJmpOpcode ? 0 : record-&gt;reservationLen; memcpy((unsigned char*)record-&gt;pTrampoline + offset, &amp;pattern, sizeof(JMP_ABS)); pattern.address = (ULONG_PTR)destination; ULONG_PTR relay = (ULONG_PTR)record-&gt;pTrampoline + sizeof(pattern) + record-&gt;reservationLen; memcpy((void*)relay, &amp;pattern, sizeof(pattern)); DWORD oldProtect = 0; VirtualProtect(source, sizeof(JMP_REL), PAGE_EXECUTE_READWRITE, &amp;oldProtect); JMP_REL* pJmpRelPattern = (JMP_REL*)source; pJmpRelPattern-&gt;opcode = 0xE9; pJmpRelPattern-&gt;delta = (unsigned int)((LPBYTE)relay - ((LPBYTE)source + sizeof(JMP_REL))); VirtualProtect(source, sizeof(JMP_REL), oldProtect, &amp;oldProtect); return SUCCESS_CODE; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le désassembleur renvoie des informations indiquant que l'opcode de cette commande est e9, nous calculons l'adresse vers laquelle sauter (ULONG_PTR ripPtr = (ULONG_PTR) pSource + context.len + (INT32) context.imm.imm32), et écrivons l'adresse dans le tremplin comme valeur de l'argument de saut direct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je note également que dans un environnement multi-thread, une situation peut se produire lorsque, au moment de l'installation / du retrait d'un crochet, l'un des threads peut commencer à exécuter la fonction que nous interceptons - en conséquence, le processus tombera. Une partie de la façon de gérer cela sera décrite dans Hardware Breakpoint.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez besoin d'un outil éprouvé, vous voulez être sûr que votre piège fonctionnera, vous n'avez pas vos propres idées et vous ne voulez pas étudier la fonction prologue - utilisez des solutions prêtes à l'emploi, par exemple, Microsoft propose sa propre bibliothèque Detour. </font><font style="vertical-align: inherit;">Je n'utilise pas de telles bibliothèques et utilise une solution propriétaire pour un certain nombre de raisons, donc je ne peux pas conseiller quelque chose, je ne peux nommer que les bibliothèques que j'ai étudiées afin de découvrir quelque chose de nouveau et de l'utiliser: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PolyHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MinHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EasyHook</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (en particulier si vous avez besoin de crochets en C #).</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.4.2. </font><font style="vertical-align: inherit;">Point d'arrêt matériel</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opcode Hook est un piège simple et rapide, mais pas le plus efficace. Un anti-triche peut facilement suivre un changement dans un morceau de mémoire, mais le crochet Opcode peut être utilisé par rapport à l'anti-triche lui-même ou pour intercepter les appels système (par exemple, NtSetInformationThread) qu'il utilise. Le point d'arrêt matériel est un piège qui ne modifie pas la mémoire du processus. J'ai vu des discussions sur des forums demandant si ACC suivait ce piège - les réponses sont généralement mitigées. Personnellement, ACC ne m'a pas interdit de les utiliser et n'a pas réinitialisé les registres (c'était il y a un peu moins de six mois, peut-être que quelque chose a changé).</font></font><br><blockquote>    ,   ,  VAC   DR      /,  -      ,    .    HWBP  ,  -  ,     ,   ,        DR0-DR7    . </blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWBP utilise des registres de processeur spéciaux pour interrompre l'exécution du thread. Si le contexte de flux contient les registres DR0-DR7 définis d'une certaine manière et que RIP va à l'une des quatre adresses stockées dans DR0-DR3, une exception est levée qui peut être interceptée, par le type d'exception et l'état du contexte, déterminez à quelle adresse le contrôle a levé l'exception et concluez - un piège ou pas. Une limitation importante de cette approche est que vous ne pouvez utiliser que quatre fonctions à la fois et les définir séparément pour chaque thread, ce qui entraîne des inconvénients si l'interruption est définie et qu'une nouvelle est créée / l'ancien thread est recréé, ce qui provoque l'interruption. Ce n'est pas un obstacle particulier et est régi par l'interception de la fonction BaseThreadInitThunk; la restriction sur l'utilisation de 4 pièges ne m'a pas vraiment dérangé personnellement.Si le nombre de crochets est critique pour vous, regardez l'approche PageGuard.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, la tâche est la même - nous sommes dans le sandbox (projet Sandbox), il est nécessaire d'intercepter les méthodes de la classe Device Present et EndScene dans lesquelles appeler les méthodes originales. </font><font style="vertical-align: inherit;">Nous avons déjà une interface prête à l'emploi pour les pièges - IHook, traitons le travail des points d'arrêt "de fer". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le principe est le suivant: il y a quatre registres DR0-DR3 «fonctionnels» dans lesquels l'adresse peut être écrite, selon le réglage du registre de contrôle DR7 lors de la tentative d'écriture, de lecture ou d'exécution à l'adresse spécifiée, une exception avec le type EXCEPTION_SINGLE_STEP se produira, qui doit être traitée dans un gestionnaire précédemment enregistré . </font><font style="vertical-align: inherit;">Vous pouvez utiliser à la fois le gestionnaire SEH et VEH - nous utiliserons ce dernier, car il a une priorité plus élevée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous réalisons cette idée:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HardwareBPHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination, HANDLE* hThread, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* reg) { CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_CONTEXT; *(&amp;context.Dr0 + *reg) = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)source; context.Dr7 |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * (*reg)); context.Dr7 |= HW_EXECUTE &lt;&lt; ((*reg) * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>); context.Dr7 |= HW_LENGTH &lt;&lt; ((*reg) * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">18</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_SET_CONTEXT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il dans le code</font></font></b> <div class="spoiler_text">      ,          ,    DR7.     . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus en détail sur ce que sont DR6 et DR7, ainsi que sur l'approche PageGuard, je peux conseiller Gray Hat Python: Programmation Python pour les pirates et les ingénieurs inversés. En bref, DR7 active / désactive l'utilisation d'un registre «de travail» - même si l'un des registres DR0-DR3 contient une adresse, mais dans DR7 le drapeau du registre correspondant est désactivé, le point d'arrêt ne fonctionnera pas. DR7 définit également le type de travail avec l'adresse à laquelle il est nécessaire de lever une exception - si l'adresse a été lue, si l'enregistrement a été effectué ou si l'adresse est utilisée pour exécuter l'instruction (nous sommes intéressés par la dernière option). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La suppression d'un piège est également assez simple et se fait via le registre de contrôle DR7.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HardwareBPHook::UnsetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, HANDLE* hThread) { CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_CONTEXT; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)source == *(&amp;context.Dr0 + i)) { info-&gt;GetItem(i)-&gt;source = <span class="hljs-number"><span class="hljs-number">0</span></span>; *(&amp;context.Dr0 + i) = <span class="hljs-number"><span class="hljs-number">0</span></span>; context.Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * i)); context.Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">3</span></span> &lt;&lt; (i * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>)); context.Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">3</span></span> &lt;&lt; (i * <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">18</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_SET_CONTEXT; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste à gérer les threads - le piège doit être défini pour les threads qui appellent la fonction interceptée. </font><font style="vertical-align: inherit;">Nous ne nous en préoccuperons pas.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons mis un piège pour tous les threads du processus.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HardwareBPHook::SetHook(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* source, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* destination) { THREADENTRY32 te32; HANDLE hThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hThread == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; te32.dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(THREADENTRY32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Thread32First(hThread, &amp;te32)) { CloseHandle(hThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; } DWORD dwOwnerPID = GetCurrentProcessId(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRegDefined = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> freeReg = <span class="hljs-number"><span class="hljs-number">-1</span></span>; Freeze(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (te32.th32OwnerProcessID == dwOwnerPID) { HANDLE openThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isRegDefined) { CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(openThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_CONTEXT; freeReg = GetFreeReg(&amp;context.Dr7); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (freeReg == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_GET_FREE_REG; isRegDefined = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } SetHook(source, destination, &amp;openThread, &amp;freeReg); CloseHandle(openThread); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Thread32Next(hThread, &amp;te32)); CloseHandle(hThread); Unfreeze(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = info-&gt;GetItem(freeReg); record-&gt;source = source; record-&gt;destination = destination; record-&gt;pTrampoline = source; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le code ci-dessus contourne tous les processus visibles et recherche le processus en cours. </font><font style="vertical-align: inherit;">Dans le processus trouvé pour le thread suivant, nous obtenons le gestionnaire de flux, trouvons l'un des quatre registres libres et définissons une interruption. </font><font style="vertical-align: inherit;">Il convient de prêter attention aux fonctions Freeze et Unfreeze - c'est ce que Opcode Hook a parlé de multithreading - elles arrêtent complètement l'exécution des threads de ce processus (sauf le processus actuel) afin qu'il n'y ait pas de situation lorsqu'un des threads entre dans la fonction interceptée.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protection des threads contre l'appel d'une fonction hook</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IHook::Freeze() { THREADENTRY32 te32; HANDLE hThread = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hThread == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; te32.dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(THREADENTRY32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Thread32First(hThread, &amp;te32)) { CloseHandle(hThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_ENUM_THREAD_START; } DWORD dwOwnerPID = GetCurrentProcessId(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (te32.th32OwnerProcessID == dwOwnerPID &amp;&amp; te32.th32ThreadID != GetCurrentThreadId()) { HANDLE openThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openThread != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { SuspendThread(openThread); CloseHandle(openThread); } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Thread32Next(hThread, &amp;te32)); CloseHandle(hThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS_CODE; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IHook::Unfreeze() { <span class="hljs-comment"><span class="hljs-comment">// equal { HANDLE openThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); if (openThread != NULL) { ResumeThread(openThread); CloseHandle(openThread); } } // equal return 0; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des besoins similaires doivent être mis en œuvre dans la fonction de suppression du piège. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste à ajouter un gestionnaire d'exceptions VEH. </font><font style="vertical-align: inherit;">L'ajout et la suppression sont effectués par les fonctions AddVectoredExceptionHandler et RemoveVectoredExceptionHandler de n'importe quel flux.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> HardwareBPHook::SetExceptionHandler(PVECTORED_EXCEPTION_HANDLER pVecExcHandler) { pException = AddVectoredExceptionHandler(<span class="hljs-number"><span class="hljs-number">1</span></span>, pVecExcHandler); } ~HardwareBPHook() { info-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> info; RemoveVectoredExceptionHandler(pException); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le gestionnaire doit vérifier le type d'exception (EXCEPTION_SINGLE_STEP est nécessaire), vérifier la correspondance de l'adresse à laquelle l'exception s'est produite avec ce qui se trouve dans les registres et, si une telle adresse est trouvée, réorganise le pointeur RIP sur l'adresse du destinataire. </font><font style="vertical-align: inherit;">L'état de la pile est conservé, de sorte que lors de l'exécution ultérieure du récepteur, tous les paramètres de la pile seront intacts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous implémentons le gestionnaire décrit dans le bac à sable:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">LONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExceptionHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( EXCEPTION_POINTERS* exceptionPointers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_SINGLE_STEP) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ContextRecord-&gt;Rip == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;source) { exceptionPointers-&gt;ContextRecord-&gt;Rip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;destination; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En théorie, tout est prêt, nous exécutons le programme, en attendant exactement le même travail que OpcodeHook. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela ne se produit pas, notre programme se bloque - plus précisément, il va constamment dans PresentHook et au moment où le tremplin doit être appelé, la fonction est à nouveau appelée. Le fait est que le point d'arrêt «fer» n'a pas disparu, car lorsque vous appelez le tremplin (qui, dans le cas des points d'arrêt «fer», indique la fonction d'origine), nous alarmons à nouveau la même adresse et levons une exception. La solution est la suivante: nous supprimerons le point d'arrêt lorsqu'il sera trouvé dans le gestionnaire pour un thread spécifique, et au bon moment nous le redéfinirons. Le lieu de mise à jour choisira le moment où la fonction du récepteur se terminera.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est implémenté comme suit - dans le gestionnaire, en plus de supprimer le point d'arrêt, une commande en attente est ajoutée, ce qui signifie mettre à jour le point d'arrêt dans le flux spécifié. </font><font style="vertical-align: inherit;">La commande s'exécute à la fin de la fonction de réception.</font></font><br><br><pre> <code class="cpp hljs">IDeferredCommands* hookCommands; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrPresent); pPresent pTrampoline = (pPresent)record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(device); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"PresentHook"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; hookCommands-&gt;Run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Device* device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(ptrEndScene); pEndScene pTrampoline = (pEndScene)record-&gt;pTrampoline; pTrampoline(device, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EndSceneHook"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; j &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; hookCommands-&gt;Run(); } <span class="hljs-function"><span class="hljs-function">LONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExceptionHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EXCEPTION_POINTERS* exceptionPointers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_SINGLE_STEP) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ContextRecord-&gt;Rip == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;source) { exceptionPointers-&gt;ContextRecord-&gt;Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * i)); exceptionPointers-&gt;ContextRecord-&gt;Rip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;destination; IDeferredCommand* cmd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SetD7Command(hook, GetCurrentThreadId(), i); hookCommands-&gt;Enqueue(cmd); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en œuvre de la commande en attente</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> silk_way { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDeferredCommand</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IDeferredCommand(silk_way::IHook* _hook) { hook = _hook; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDeferredCommand() { hook = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: silk_way::IHook* hook; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetD7Command</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDeferredCommand { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SetD7Command(silk_way::IHook* _hook, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> _threadId, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _reg) : IDeferredCommand(_hook) { threadId = _threadId; reg = _reg; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, threadId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hThread != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = SetD7(&amp;hThread); CloseHandle(hThread); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetD7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE* hThread)</span></span></span><span class="hljs-function"> </span></span>{ CONTEXT context; ZeroMemory(&amp;context, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(context)); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; *(&amp;context.Dr0 + reg) = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)hook-&gt;GetInfo()-&gt;GetItem(reg)-&gt;source; context.Dr7 |= <span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * reg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!SetThreadContext(*hThread, &amp;context)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> threadId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reg; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDeferredCommands</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> silk_data::Queue&lt;IDeferredCommand*&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDeferredCommand { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IDeferredCommands() : Queue(), IDeferredCommand(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IDeferredCommands() {} }; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imaginez visuellement le travail des points d'arrêt "de fer". </font></font><br><br><img src="https://habrastorage.org/webt/jv/p-/zz/jvp-zzjqnzwyp2ykl_99ujnhw0y.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 12 - État initial</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous définissons un piège, ajoutons un gestionnaire VEH, attendons que le contrôle atteigne la fonction source: </font></font><br><br><img src="https://habrastorage.org/webt/5q/-e/eu/5q-eeucl59ysseiioktygfzl9bc.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 13 - Étape de préparation de l'interception</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une exception est levée, un gestionnaire est appelé qui redirige le RIP vers le récepteur et réinitialise le point d'arrêt: </font></font><br><br><img src="https://habrastorage.org/webt/te/rv/iw/terviwiealxn6xn1xvylzvfuhfe.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 14 - Redirige le thread d'exécution sur le récepteur de fonction</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sur ce sujet, les interruptions peuvent être terminées, la bibliothèque statique silk_way.lib est prête. </font><font style="vertical-align: inherit;">D'après ma propre expérience, je peux dire que j'utilise souvent OpcodeHook, VMT Hook, Forced Exception Hook (probablement le piège le plus «hémorroïdal»), HardwareBreakpoint et PageGuard (lorsque le temps d'exécution n'est pas critique, interceptions ponctuelles).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Architecture de la logique </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La base de la logique est présentée sous forme de MVC (model-view-controller). Toutes les entités principales héritent de l'interface ISilkObject.</font></font><br><br><h3>  8.1.  Modèle </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du développement d'un bot dans la bibliothèque, j'ai d'abord implémenté ECS (vous pouvez en savoir plus sur cette approche </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Quand j'ai réalisé que lancer un bot avec de vrais joueurs était une tâche assez longue, j'ai écrit une simulation où nous avons testé des bibliothèques ml (avec une grille tridimensionnelle pour la navigation (Dota 2 utilise simplement une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grille 3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour la navigation) et une physique 2D simplifiée pour un bloc de corps). Lorsque le besoin de simulation a disparu et j'ai compris comment et quoi enregistrer, quelles informations collecter pendant la bataille, ECS n'était plus nécessaire et les modèles ont simplement commencé à contenir un dictionnaire de composants (pour représenter quelque chose comme les gars de SkyForge, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">section «Avatars et foules</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), qui contenait, en fait, des wrappers sur des structures de Source2Gen. </font><font style="vertical-align: inherit;">Pour cet article, je n'ai pas transféré cette implémentation afin de simplifier le matériel. </font><font style="vertical-align: inherit;">Le modèle contient un schéma, dans lequel sa description est stockée (ce point est simplifié et dans cette implémentation le modèle n'est pas créé selon le schéma, le schéma le décrit uniquement (stocke les valeurs prédéfinies qui peuvent être codées en dur) - cela peut être comparé au stockage du contenu du jeu dans xml / json ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schématiquement, le modèle d'appareil peut être représenté comme suit: </font><i><font style="vertical-align: inherit;">Figure 15 - Représentation schématique de l'</font></i><font style="vertical-align: inherit;"> implémentation </font><i><font style="vertical-align: inherit;">du modèle</font></i><font style="vertical-align: inherit;"> dans le code:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ci/of/ip/ciofipyg9fa-rcm0bavzy4ninb0.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SILK_OBJ</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IModel</span></span></span><span class="hljs-class">) {</span></span> ACCESSOR(IIdentity, Id) ACCESSOR(S, Schema) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IModel(IIdentity * id, ISchema * schema) { Id = id; Schema = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;S*&gt;(schema); components = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_data::RBTree&lt;SILK_STRING*, IComponent&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringCompareStrategy()); } ~IModel() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Id; Schema = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; components-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> components; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Get</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SILK_STRING</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T*)components-&gt;Find(key); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: silk_data::RBTree&lt;SILK_STRING*, IComponent&gt;* components; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le schéma comprend une description d'un modèle spécifique et contient le contexte que le modèle peut utiliser. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IModelSchema</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BaseSchema { ACCESSOR(ModelContext, Context) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IModelSchema(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* type, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name, IContext* context) : BaseSchema(type, name) { Context = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;ModelContext*&gt;(context); } ~IModelSchema() { Context = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelContext</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SilkContext { ACCESSOR(ILogger, Logger) ACCESSOR(IChrono, Clock) ACCESSOR(GigaFactory, Factory) ACCESSOR(IGameModel*, Model) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ModelContext(SILK_GUID* guid, ILogger* logger, IChrono* clock, GigaFactory* factory, IGameModel** model) : SilkContext(guid) { Logger = logger; Clock = clock; Factory = factory; Model = model; } ~ModelContext() { Logger = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Clock = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Factory = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; Model = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } };</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collection de modèles et collection de schémas</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IModelCollection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> silk_data::Vector&lt;T*&gt;, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IModel&lt;S&gt; { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IModelCollection(IIdentity* id, ISchema* schema) : Vector(), IModel(id, schema) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> factory = Schema-&gt;GetContext()-&gt;GetFactory(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> guid = Schema-&gt;GetContext()-&gt;GetGuid(); foreach (Schema-&gt;Length()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> itemSchema = Schema-&gt;GetItem(i); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item = factory-&gt;Build&lt;T&gt;(itemSchema-&gt;GetType()-&gt;GetValue(), guid-&gt;Get(), itemSchema); PushBack(item); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~IModelCollection() { Clear(); } <span class="hljs-function"><span class="hljs-function">T* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* name)</span></span></span><span class="hljs-function"> </span></span>{ foreach (Length()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetItem(i)-&gt;GetSchema()-&gt;CheckName(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetItem(i); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } };</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, par exemple, l'interface et l'implémentation d'un modèle qui stocke le statut de Roshan ressemble à</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">DEFINE_IMODEL(IRoshanStatusModel, IRoshanStatusSchema) { VIRTUAL_COMPONENT(IStatesModel, States) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IRoshanStatusModel(IIdentity * id, ISchema * schema) : IModel(id, schema) {} }; DEFINE_MODEL(RoshanStatusModel, IRoshanStatusModel) { COMPONENT(IStatesModel, States) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : RoshanStatusModel(IIdentity * id, ISchema* schema) : IRoshanStatusModel( id, schema) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> factory = Schema-&gt;GetContext()-&gt;GetFactory(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> guid = Schema -&gt; GetContext() -&gt; GetGuid(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> statesSchema = Schema -&gt; GetStates(); States = factory-&gt;Build&lt;IStatesModel&gt;( statesSchema-&gt;GetType()-&gt;GetValue(), guid-&gt;Get(), statesSchema); } ~RoshanStatusModel() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> States; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Resolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> currentStateSchema = States-&gt;GetCurrent()-&gt;GetSchema(); Schema-&gt;GetContext()-&gt;GetLogger()-&gt;Log(<span class="hljs-string"><span class="hljs-string">"RESOLVE\n"</span></span>); foreach (currentStateSchema-&gt;GetTransitions()-&gt;Length()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> transition = currentStateSchema-&gt;GetTransitions()-&gt;GetItem(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transition-&gt;GetRequirement()-&gt;Check()) { transition-&gt;GetAction()-&gt;Make(); States-&gt;SetCurrent(States-&gt;GetByName( transition-&gt;GetTo()-&gt;GetValue())); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } };</code> </pre> <br></div></div><br><h3>  8.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Afficher, afficher l'état et le contrôleur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a rien à dire sur la présentation, l'état de la présentation et le contrôleur, l'implémentation est similaire aux modèles. </font><font style="vertical-align: inherit;">Ils se composent également de schéma et de contexte. </font><font style="vertical-align: inherit;">Pour résoudre le problème pour la vue, le canevas, la ViewCollection, l'étiquette et le bouton sont implémentés, pour les deux derniers, des états correspondant aux états dans lesquels Roshan est situé sont également implémentés.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vue schématique</font></font></b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/webt/an/l2/_n/anl2_n7qxsihaoohxu4oa-kq2jm.png"></a> <br> <i> 16 —   </i> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Représentation schématique de l'état d'affichage</font></font></b> <div class="spoiler_text"> <a href=""><img src="https://habrastorage.org/webt/zi/mz/pi/zimzpip_arq-gwgl87-lwriknmq.png"></a> <br> <i> 17 —    </i> <br></div></div><br><h3>  8.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'usine </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets sont créés à l'aide de l'usine. </font><font style="vertical-align: inherit;">Les usines utilisent un type d'interface comme clé, le traduisant en une chaîne en utilisant typeid (T) .raw_name (). </font><font style="vertical-align: inherit;">En général, cela est mauvais, pourquoi et comment lire correctement chez Andrei Alexandrescu, Design C ++ moderne: programmation générique. </font><font style="vertical-align: inherit;">Mise en œuvre en usine:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilkFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SilkFactory() { items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_data::RBTree&lt;SILK_STRING*, IImplementator&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringCompareStrategy()); } ~SilkFactory() { items-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> items; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISILK_WAY_OBJECT</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Build</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(type); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> impl = items-&gt;Find(key)-&gt;payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> impl-&gt;Build(args...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* type, IImplementator* impl)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(type); items-&gt;Insert(*items-&gt;MakeNode(key, impl)); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: silk_data::RBTree&lt;SILK_STRING*, IImplementator&gt;* items; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GigaFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GigaFactory() { items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_data::RBTree&lt;SILK_STRING*, SilkFactory&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringCompareStrategy()); } ~GigaFactory() { items-&gt;Clear(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> items; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Build</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">char</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">concreteType</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).raw_name()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> factory = items-&gt;Find(key)-&gt;payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T*)factory-&gt;Build(concreteType, args...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SilkFactory</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">factory</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-keyword"><span class="hljs-keyword">typeid</span></span>(T).raw_name()); items-&gt;Insert(*items-&gt;MakeNode(key, factory)); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: silk_data::RBTree&lt;SILK_STRING*, SilkFactory&gt;* items; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avant d'utiliser l'usine pour construire des objets, vous devez vous inscrire. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemple d'enregistrement de modèle</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ModelRegistrator::Register( GigaFactory* factory) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> requirement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TrueRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"false"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;FalseRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_killed"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanKilledRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_alive_manual"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanAliveManualRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TimeRequirement&gt;); requirement-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_state"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanStateRequirement&gt;); factory-&gt;Register&lt;IRequirement&gt;(requirement); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> action = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); action-&gt;Register(<span class="hljs-string"><span class="hljs-string">"action"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;EmptyAction&gt;); action-&gt;Register(<span class="hljs-string"><span class="hljs-string">"set_current_time"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;SetCurrentTimeAction&gt;); factory-&gt;Register&lt;IAction&gt;(action); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> transition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); transition-&gt;Register(<span class="hljs-string"><span class="hljs-string">"transition"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TransitionSchema&gt;); factory-&gt;Register&lt;ITransitionSchema&gt;(transition); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> transitions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); transitions-&gt;Register(<span class="hljs-string"><span class="hljs-string">"transitions"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TransitionsSchema&gt;); factory-&gt;Register&lt;ITransitionsSchema&gt;(transitions); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> stateSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); stateSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"state"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;StateSchema&gt;); factory-&gt;Register&lt;IStateSchema&gt;(stateSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> statesSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); statesSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"states"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;StatesSchema&gt;); factory-&gt;Register&lt;IStatesSchema&gt;(statesSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> roshanStatusSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); roshanStatusSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_status"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;RoshanStatusSchema&gt;); factory-&gt;Register&lt;IRoshanStatusSchema&gt;(roshanStatusSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> triggerSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); triggerSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"trigger"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TriggerSchema&gt;); factory-&gt;Register&lt;ITriggerSchema&gt;(triggerSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> triggersSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); triggersSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"triggers"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;TriggersSchema&gt;); factory-&gt;Register&lt;ITriggersSchema&gt;(triggersSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resourceSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resourceSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resource"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;ResourceSchema&gt;); factory-&gt;Register&lt;IResourceSchema&gt;(resourceSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resourcesSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resourcesSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resources"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;ResourcesSchema&gt;); factory-&gt;Register&lt;IResourcesSchema&gt;(resourcesSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gameSchema = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); gameSchema-&gt;Register(<span class="hljs-string"><span class="hljs-string">"game"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SchemaImplementator&lt;GameSchema&gt;); factory-&gt;Register&lt;IGameSchema&gt;(gameSchema); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> gameModel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); gameModel-&gt;Register(<span class="hljs-string"><span class="hljs-string">"game"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;GameModel&gt;); factory-&gt;Register&lt;IGameModel&gt;(gameModel); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resources = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resources-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resources"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;ResourceCollection&gt;); factory-&gt;Register&lt;IResourceCollection&gt;(resources); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); resource-&gt;Register(<span class="hljs-string"><span class="hljs-string">"resource"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;Resource&gt;); factory-&gt;Register&lt;IResource&gt;(resource); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> triggers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); triggers-&gt;Register(<span class="hljs-string"><span class="hljs-string">"triggers"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;TriggerCollection&gt;); factory-&gt;Register&lt;ITriggerCollection&gt;(triggers); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> trigger = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); trigger-&gt;Register(<span class="hljs-string"><span class="hljs-string">"trigger"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;Trigger&gt;); factory-&gt;Register&lt;ITrigger&gt;(trigger); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> roshanStatus = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); roshanStatus-&gt;Register(<span class="hljs-string"><span class="hljs-string">"roshan_status"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;RoshanStatusModel&gt;); factory-&gt;Register&lt;IRoshanStatusModel&gt;(roshanStatus); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> states = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); states-&gt;Register(<span class="hljs-string"><span class="hljs-string">"states"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;StatesModel&gt;); factory-&gt;Register&lt;IStatesModel&gt;(states); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> state = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SilkFactory(); state-&gt;Register(<span class="hljs-string"><span class="hljs-string">"state"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcreteImplementator&lt;StateModel&gt;); factory-&gt;Register&lt;IStateModel&gt;(state); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le schéma peut être rempli de n'importe quelle manière - vous pouvez utiliser json, vous pouvez directement dans le code. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option pour remplir le schéma des modèles dans json</font></font></b> <div class="spoiler_text"><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"game"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roshan_status"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"states"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"transitions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_base"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"set_current_time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed_ts"</span></span> } } } ] }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_base"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"transitions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_base"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed_ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-number"><span class="hljs-number">480</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"action"</span></span> } } ] }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"transitions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"resource"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_killed_ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-number"><span class="hljs-number">660</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"action"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"ressurect_extra"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"to"</span></span>: <span class="hljs-string"><span class="hljs-string">"alive"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"requirement"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"roshan_alive_manual"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"typename"</span></span>: <span class="hljs-string"><span class="hljs-string">"action"</span></span> } } ] } ] }, <span class="hljs-attr"><span class="hljs-attr">"triggers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roshan_killed"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"roshan_alive_manual"</span></span>: {} }, <span class="hljs-attr"><span class="hljs-attr">"resources"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"roshan_killed_ts"</span></span>: {} } } }</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option pour remplir un schéma pour la soumission de code</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> GameController::InitViewSchema(ICanvasSchema** schema) { *schema = factory-&gt;Build&lt;ICanvasSchema&gt;(<span class="hljs-string"><span class="hljs-string">"canvas_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"canvas_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"canvas_d9"</span></span>, viewContext); IViewCollectionSchema* elements = factory-&gt;Build&lt;IViewCollectionSchema&gt;( <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, <span class="hljs-string"><span class="hljs-string">"elements"</span></span>, viewContext); (*schema)-&gt;SetElements(elements); ILabelSchema* labelSchema = factory-&gt;Build&lt;ILabelSchema&gt;( <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"roshan_status_label"</span></span>, viewContext); labelSchema-&gt;SetRecLeft(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">30</span></span>)); labelSchema-&gt;SetRecTop(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">100</span></span>)); labelSchema-&gt;SetRecRight(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">230</span></span>)); labelSchema-&gt;SetRecDown(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">250</span></span>)); labelSchema-&gt;SetColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); labelSchema-&gt;SetText(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-string"><span class="hljs-string">"Roshan status: alive\0"</span></span>)); elements-&gt;PushBack((IViewSchema*&amp;)labelSchema); IButtonSchema* buttonSchema = factory-&gt;Build&lt;IButtonSchema&gt;( <span class="hljs-string"><span class="hljs-string">"button_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"button_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"roshan_kill_button"</span></span>, viewContext); ILabelSchema* buttonLabelSchema = factory-&gt;Build&lt;ILabelSchema&gt;( <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"label_d9"</span></span>, <span class="hljs-string"><span class="hljs-string">"button_text"</span></span>, viewContext); buttonLabelSchema-&gt;SetRecLeft(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">30</span></span>)); buttonLabelSchema-&gt;SetRecTop(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">115</span></span>)); buttonLabelSchema-&gt;SetRecRight(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">110</span></span>)); buttonLabelSchema-&gt;SetRecDown(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">130</span></span>)); buttonLabelSchema-&gt;SetColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); buttonLabelSchema-&gt;SetColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); buttonLabelSchema-&gt;SetColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); buttonLabelSchema-&gt;SetColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); buttonLabelSchema-&gt;SetText(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_STRING(<span class="hljs-string"><span class="hljs-string">"Kill Roshan\0"</span></span>)); buttonSchema-&gt;SetLabel(buttonLabelSchema); buttonSchema-&gt;SetBorderColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetBorderColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetBorderColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetBorderColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">70</span></span>)); buttonSchema-&gt;SetFillColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">255</span></span>)); buttonSchema-&gt;SetFillColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">119</span></span>)); buttonSchema-&gt;SetFillColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetFillColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">150</span></span>)); buttonSchema-&gt;SetPushColorR(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetPushColorG(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetPushColorB(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">0</span></span>)); buttonSchema-&gt;SetPushColorA(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_INT(<span class="hljs-number"><span class="hljs-number">70</span></span>)); buttonSchema-&gt;SetBorder(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SILK_FLOAT(<span class="hljs-number"><span class="hljs-number">5</span></span>)); elements-&gt;PushBack((IViewSchema*&amp;)buttonSchema); }</code> </pre> <br></div></div><br><h3>  8.4.  Les événements </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La vue apprend les modifications apportées au modèle par le biais d'événements. </font><font style="vertical-align: inherit;">Vous pouvez obtenir des commentaires sur les méthodes de classe et les fonctions ordinaires.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VIRTUAL_EVENT(e) public: virtual IEvent* Get##e() = 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EVENT(e) private: IEvent* e; public: IEvent* Get##e() { return e; } const int MAX_EVENT_CALLBACKS = 1024; class IEventArgs {}; class ICallback { public: virtual void Invoke(IEventArgs* args) = 0; }; template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class A&gt; class Callback : public ICallback { typedef void (*f)(A*); public: Callback(f _pFunc) { ptr = _pFunc; } ~Callback() { delete ptr; } void Invoke(IEventArgs* args) { ptr((A*)args); } private: f ptr = nullptr; }; template &lt;typename T, class A&gt; class MemberCallback : public ICallback { typedef void (T::*f)(A*); public: MemberCallback(f _pFunc, T* _obj) { ptr = _pFunc; obj = _obj; } ~MemberCallback() { delete ptr; obj = nullptr; } void Invoke(IEventArgs* args) { (obj-&gt;*(ptr))((A*)args); } private: f ptr = nullptr; T* obj; }; class IEvent { public: virtual void Invoke(IEventArgs* args) = 0; virtual void Add(ICallback* callback) = 0; virtual bool Remove(ICallback* callback) = 0; virtual ~IEvent() {} };</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si un objet souhaite signaler des événements se produisant à l'intérieur, vous devez ajouter IEvent * pour chaque événement. </font><font style="vertical-align: inherit;">Un autre objet qui s'intéresse aux événements se produisant à l'intérieur de cet objet doit créer ICallback * et le passer dans IEvent * (s'abonner à l'événement).</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemples d'abonnements survenant dans le contrôleur</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Attach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ statesChangedCallback = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberCallback&lt;GameController, IEventArgs&gt;( &amp;GameController::OnStatesChanged, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Model-&gt;GetRoshanStatus()-&gt;GetStates()-&gt;GetCurrentChanged()-&gt;Add( statesChangedCallback); buttonClickedCallback = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemberCallback&lt;GameController, IEventArgs&gt;( &amp;GameController::OnKillRoshanClicked, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); killButton-&gt;GetClickedEvent()-&gt;Add(buttonClickedCallback); }</code> </pre> <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de déclaration d'un événement à l'intérieur d'une classe - à chaque coup de l'horloge (appel de la méthode Tick), un événement StruckEvent est déclenché</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IChrono</span></span></span><span class="hljs-class"> {</span></span> VIRTUAL_EVENT(Struck) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStamp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDiffS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ts)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chrono</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IChrono { EVENT(Struck) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Chrono() { start = time(<span class="hljs-number"><span class="hljs-number">0</span></span>); Struck = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(); } ~Chrono() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> Struck; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Tick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cur = clock(); worked += cur - savepoint; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isStriking = savepoint &lt; cur; savepoint = cur; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isStriking) Struck-&gt;Invoke(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStamp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start * CLOCKS_PER_SEC + worked; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDiffS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ts)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (GetStamp() - ts) / CLOCKS_PER_SEC; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> worked = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span> savepoint; };</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les types primitifs de base (SILK_INT, SILT_FLOAT, SILK_STRING, ...) sont implémentés dans Core.h. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. DirectX 9 </font></font></h2><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectX 9</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est l'une des API graphiques prises en charge par Dota 2. Device est une classe héritée d'IUnknown et contient des fonctions virtuelles. Par conséquent, après avoir reçu un pointeur vers une table de méthode virtuelle, nous pouvons obtenir des pointeurs vers les fonctions dont nous avons besoin. Les fonctions de classe non virtuelles ne sont pas incluses dans la table et se trouvent dans le segment .code, car ce sont les seules qui ne peuvent pas être remplacées. Soit dit en passant, dans OpenGL et Vulkan, l'interception des fonctions de périphérique est beaucoup plus facile, car elles ne sont pas virtuelles et vous pouvez obtenir un pointeur à l'aide de GetProcAddress (). L'architecture de DirectX 11 est plus complexe que 9, mais pas beaucoup.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour intercepter la méthode de classe virtuelle (ainsi que la méthode non virtuelle), nous avons besoin d'une instance de cette classe, n'importe quelle instance. En utilisant l'instance, nous obtenons la table des méthodes virtuelles et obtenons les pointeurs nécessaires vers les fonctions. La façon la plus simple de trouver une instance d'une classe est de la créer vous-même. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, nous devons créer un objet avec l'interface IDirect3D9 à l'aide de la fonction Direct3DCreate9, et nous créerons le périphérique à l'aide de cet objet en appelant la méthode CreateDevice. Nous pouvons appeler ces fonctions directement à partir de la bibliothèque DirectX, mais afin de consolider le matériel, nous les appellerons via des pointeurs. Comme on peut le voir dans d3d9.h, Direct3DCreate9 est une fonction régulière et un pointeur vers celle-ci peut être obtenu via GetProcAddress (tout comme nous l'avons fait dans NativeInjector pour obtenir un pointeur vers LoadLibrary).</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/nr/fq/ai/nrfqai6vps7fc9lx_crerpvsbhq.png"></a> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 18 - Description de CreateDevice dans d3d9.h</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créez une instance d'IDirect3D9:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> IDirect3D9* (WINAPI *SILK_Direct3DCreate9) (UINT SDKVersion); <span class="hljs-comment"><span class="hljs-comment">//IDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION); SILK_Direct3DCreate9 Silk_Direct3DCreate9 = (SILK_Direct3DCreate9)GetProcAddress(GetModuleHandle("d3d9.dll"), "Direct3DCreate9"); IDirect3D9* pD3D = Silk_Direct3DCreate9(D3D_SDK_VERSION);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant IDirect3D9, nous pouvons créer un périphérique en appelant pD3D-&gt; CreateDevice (...). </font><font style="vertical-align: inherit;">Pour obtenir un pointeur sur les fonctions nécessaires de VMT, nous devons découvrir la procédure pour déterminer ces méthodes. </font><i><font style="vertical-align: inherit;">Figure 19 - Recherche d'index pour la méthode CreateDevice de l'interface IDirect3D9 Obtenez le</font></i><font style="vertical-align: inherit;"> 16e index. </font><font style="vertical-align: inherit;">En plus de CreateDevice, nous avons également besoin des méthodes Release et GetAdapterDisplayMode.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ro/ap/ug/roapuggoav9xtztltqu8gs6zqiw.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous implémentons la création de l'appareil en code</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINAPI *SILK_GetAdapterDisplayMode)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9* direct3D9, UINT Adapter, D3DDISPLAYMODE* pMode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINAPI *SILK_CreateDevice)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9* direct3D9, UINT Adapter, D3DDEVTYPE DeviceType, HWND hFocusWindow, DWORD BehaviorFlags, D3DPRESENT_PARAMETERS* pPresentationParameters, IDirect3DDevice9** ppReturnedDeviceInterface)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ULONG</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINAPI *SILK_Release)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9* direct3D9)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RELEASE_INDEX = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GET_ADAPTER_DISPLAY_MODE_INDEX = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CREATE_DEVICE_INDEX = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSearchDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3D9** d3d, IDirect3DDevice9** device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d3d || !device) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; *d3d = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; *device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">//IDirect3D9* pD3D = Direct3DCreate9(D3D_SDK_VERSION); SILK_Direct3DCreate9 Silk_Direct3DCreate9 = (SILK_Direct3DCreate9)GetProcAddress(GetModuleHandle("d3d9.dll"), "Direct3DCreate9"); IDirect3D9* pD3D = Silk_Direct3DCreate9(D3D_SDK_VERSION); if (!pD3D) return FALSE; D3DDISPLAYMODE displayMode; int pointerSize = sizeof(unsigned long long); unsigned long long vmt = **(unsigned long long **)&amp;pD3D; SILK_GetAdapterDisplayMode pGetAdapderDisplayMode = (SILK_GetAdapterDisplayMode)((*(unsigned long long *) (vmt + pointerSize * GET_ADAPTER_DISPLAY_MODE_INDEX))); pGetAdapderDisplayMode(pD3D, D3DADAPTER_DEFAULT, &amp;displayMode); //pD3D-&gt;GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &amp;displayMode); HWND hWindow = GetDesktopWindow(); D3DPRESENT_PARAMETERS pp; ZeroMemory(&amp;pp, sizeof(pp)); pp.Windowed = TRUE; pp.hDeviceWindow = hWindow; pp.BackBufferCount = 0; pp.BackBufferWidth = 0; pp.BackBufferHeight = 0; pp.BackBufferFormat = displayMode.Format; pp.SwapEffect = D3DSWAPEFFECT_DISCARD; IDirect3DDevice9* pDevice = NULL; SILK_CreateDevice pCreateDevice = (SILK_CreateDevice) ((*(unsigned long long *)(vmt + pointerSize * CREATE_DEVICE_INDEX))); if(SUCCEEDED(pCreateDevice(pD3D, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &amp;pp, &amp;pDevice))) { //if (SUCCEEDED(pD3D-&gt;CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWindow, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &amp;pp, &amp;pDevice))) { if (pDevice != NULL) { *d3d = pD3D; *device = pDevice; } } BOOL result = (*d3d != NULL); if (result == FALSE) if (pD3D) { SILK_Release pRelease= (SILK_Release)((*(unsigned long long *)(vmt + pointerSize * RELEASE_INDEX))); pRelease(pD3D); //pD3D-&gt;Release(); } return result; }</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, nous avons créé le périphérique DirectX 9, maintenant nous devons comprendre quelles fonctions sont utilisées pour rendre la scène, ce que nous devons intercepter. Nous devons répondre à la question: "Comment DirectX 9 nous montre-t-il la scène?" La fonction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Présent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est utilisée pour afficher la scène </font><font style="vertical-align: inherit;">. Il vaut également la peine d'introduire des concepts tels que le tampon avant (un tampon qui stocke ce qui est affiché (action à long terme) à l'écran), le tampon arrière - contient ce qui est prêt à être affiché et se prépare à devenir un tampon avant, une chaîne d'échange - en fait un ensemble de tampons qui basculement d'avant en arrière (DirectX 9 n'a qu'une seule chaîne de permutation). Avant d'appeler Present, deux fonctions BeginScene et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EndScene</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">appelées</font></a><font style="vertical-align: inherit;"> , où vous pouvez modifier le tampon arrière.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interceptons deux fonctions (en fait, pour exécuter la logique métier, une nous suffit): EndScene et Present. </font><font style="vertical-align: inherit;">Pour ce faire, examinez l'emplacement de ces fonctions dans la classe IDirect3DDevice9 </font><i><font style="vertical-align: inherit;">Figure 20 - Déclaration de l'interface IDirect3DDevice9 Déclarez des</font></i><font style="vertical-align: inherit;"> pointeurs avec les signatures de fonction suivantes:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/xa/ev/tk/xaevtkzg4h4whv7aejsfp025yr0.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*VirtualOverloadPresent)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion)</span></span></span></span>; VirtualOverloadPresent oOverload = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HRESULT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*VirtualOverloadEndScene)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span></span>; VirtualOverloadEndScene oOverloadEndScene = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PRESENT_INDEX = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> END_SCENE_INDEX = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous déclarerons immédiatement un piège avec un gestionnaire d'erreurs, car HardwareBreakpoint est en fait notre seule option d'interception sécurisée implémentée qui ne suit pas VAC (vous pouvez également tester avec Opcode Hook, mais votre compte s'envolera très probablement dans une interdiction): </font></font><br><br><pre> <code class="cpp hljs">silk_way::IDeferredCommands* deferredCommands; silk_way::IHook* hook; <span class="hljs-function"><span class="hljs-function">LONG </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExceptionHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EXCEPTION_POINTERS* exceptionPointers)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ExceptionRecord-&gt;ExceptionCode != EXCEPTION_SINGLE_STEP) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_EXIT_UNWIND; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; silk_way::DEBUG_REG_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exceptionPointers-&gt;ContextRecord-&gt;Rip == (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;source) { exceptionPointers-&gt;ContextRecord-&gt;Dr7 &amp;= ~(<span class="hljs-number"><span class="hljs-number">1U</span></span>LL &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * i)); exceptionPointers-&gt;ContextRecord-&gt;Rip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) hook-&gt;GetInfo()-&gt;GetItem(i)-&gt;destination; silk_way::IDeferredCommand* cmd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_way::SetD7Command(hook, GetCurrentThreadId(), i); deferredCommands-&gt;Enqueue(cmd); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EXCEPTION_CONTINUE_EXECUTION; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sonnez les fonctions désignées de l'un de nos deux pièges: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HookDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vmt = **(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> **)&amp;pDevice; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointerSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); VirtualOverloadPresent pointerPresent= (VirtualOverloadPresent) ((*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)(vmt + pointerSize * PRESENT_INDEX))); VirtualOverloadEndScene pointerEndScene = (VirtualOverloadEndScene) ((*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)(vmt + pointerSize * END_SCENE_INDEX))); oOverload = pointerPresent; oOverloadEndScene = pointerEndScene; deferredCommands = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> silk_way::DeferredCommands(); <span class="hljs-comment"><span class="hljs-comment">//hook = new silk_way::HardwareBPHook(); hook = new silk_way::OpcodeHook(); hook-&gt;SetExceptionHandler(OnExceptionHandler); hook-&gt;SetHook(pointerPresent, &amp;PresentHook); hook-&gt;SetHook(pointerEndScene, &amp;EndSceneHook); return TRUE; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Récepteurs de fonction: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PresentHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice, CONST RECT* pSourceRect, CONST RECT* pDestRect, HWND hDestWindowOverride, CONST RGNDATA* pDirtyRegion)</span></span></span><span class="hljs-function"> </span></span>{ Capture(pd3dDevice); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(oOverload); VirtualOverloadPresent pTrampoline = (VirtualOverloadPresent) record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(pd3dDevice, pSourceRect, pDestRect, hDestWindowOverride, pDirtyRegion); deferredCommands-&gt;Run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (controller == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameController(); controller-&gt;SetDevice(pd3dDevice); } controller-&gt;Update(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> record = hook-&gt;GetRecordBySource(oOverloadEndScene); VirtualOverloadEndScene pTrampoline = (VirtualOverloadEndScene) record-&gt;pTrampoline; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = pTrampoline(pd3dDevice); deferredCommands-&gt;Run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Present, chaque appel prend une capture d'écran du tampon de la carte vidéo (pour vérification) à l'aide de la fonction Capture</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">VOID WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Capture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span><span class="hljs-function"> </span></span>{ IDirect3DSurface9 *renderTarget = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; IDirect3DSurface9 *destTarget = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; HRESULT res1 = pd3dDevice-&gt;GetRenderTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;renderTarget); D3DSURFACE_DESC descr; HRESULT res2 = renderTarget-&gt;GetDesc(&amp;descr); HRESULT res3 = pd3dDevice-&gt;CreateOffscreenPlainSurface( descr.Width, descr.Height, <span class="hljs-comment"><span class="hljs-comment">/*D3DFMT_A8R8G8B8*/</span></span>descr.Format, D3DPOOL_SYSTEMMEM, &amp;destTarget, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); HRESULT res4 = pd3dDevice-&gt;GetRenderTargetData(renderTarget, destTarget); D3DLOCKED_RECT lockedRect; ZeroMemory(&amp;lockedRect, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(lockedRect)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destTarget == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; HRESULT res5 = destTarget-&gt;LockRect(&amp;lockedRect, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, D3DLOCK_READONLY); HRESULT res7 = destTarget-&gt;UnlockRect(); HRESULT res6 = D3DXSaveSurfaceToFile(screenshootPath, D3DXIFF_BMP, destTarget, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); renderTarget-&gt;Release(); destTarget-&gt;Release(); }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EndScene crée un contrôleur de logique métier. </font><font style="vertical-align: inherit;">Après la création, la mise à jour du contrôleur est appelée, où toute la logique est mise à jour. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je note que nous avons maintenant implémenté le travail avec DirectX 9. Si nous voulons créer une sorte de mod, de triche, etc., les quatre API doivent être prises en charge. </font><font style="vertical-align: inherit;">Cela est justifié si l'arsenal a déjà vos bibliothèques préférées, des blancs pour l'interface utilisateur, sinon vous pouvez utiliser une autre façon - la fonctionnalité qui utilise le moteur pour rendre le jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est également utile de dire que l'appel aux mises à jour logiques à partir d'EndScene () n'est pas la meilleure option - vous pouvez trouver des appels périodiques aux fonctions du moteur ou la logique d'appel dans votre flux. </font><font style="vertical-align: inherit;">Si, toutefois, vous êtes satisfait de l'appel de EndScene, il est préférable de le faire avec lockstep. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons mis en œuvre tout ce que nous avions prévu.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recommandations de test</font></font></b> <div class="spoiler_text">       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DirectX SDK</a> ,    ,  DirectX 9  DirectX 11.           DirectX 11,    -      SDK,     (  ,         )   ,     ,     DXUT,      ,      —   ,   FPS   . <br><br> <a href=""><img src="https://habrastorage.org/webt/o-/hq/zg/o-hqzgthdamhzrum5h8upaenqly.png"></a> <br> <i> 21 —     DirectX SDK   StateManager.exe</i> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez maintenant créer un faux compte dans Steam et injecter injected.dll dans le processus Dota 2. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je dirai tout de suite, je ne sais pas comment est la situation actuelle avec les points d'arrêt «de fer» - en utilisant le crochet Opcode (la façon dont nous le faisons dans le courant forme) vous obtiendrez certainement une interdiction. Je l'ai fait il y a environ six mois - il n'y avait pas d'interdiction pour le Hardware Breakpoint, je ne peux pas dire quelle est la situation en ce moment. Avant de préparer l'article, j'ai pris deux comptes et j'ai essayé Opcode Hook et HWBP, le premier s'est envolé pour l'interdiction (environ 2 semaines se sont écoulées), le second non (3 semaines se sont écoulées). Mais il n'y a toujours aucune garantie que l'interdiction ne sera pas à l'avenir. Alors ne soyez pas offensé si vous faites accidentellement une introduction à partir de votre compte principal ou oubliez de vous connecter au faux compte - alors prenez déjà soin de vous et faites attention.</font></font></b> <br><br><div class="spoiler"> <b class="spoiler_title">    ( )</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/tw/44/d9tw44gqefmz8pvwr1c7y-ppbhq.png"><br> <i> 22 —  </i> <br></div></div><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nk/v4/za/nkv4zafl57fjog_vqnsf5k1q-va.png"><br> <i> 23 —    </i> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implémentation en mode 1x1. </font><i><font style="vertical-align: inherit;">Figure 24 - Injection dans une correspondance</font></i><font style="vertical-align: inherit;"> Il convient également de mentionner qu'il existe un autre moyen de rendu - le rendu de surface en créant une deuxième fenêtre avec la taille appropriée. Malheureusement, je ne pouvais pas réaliser la possibilité d'utiliser une approche de surface pour le cas du mode plein écran, mais l'approche décrite dans l'article vous permet d'implémenter le rendu en mode plein écran et en mode fenêtre sans aucun problème. </font><font style="vertical-align: inherit;">Notre interface utilisateur intégrée ne contient qu'une étiquette de texte et un bouton implémenté sur DirectX 9 pur - c'est tout ce qui est nécessaire pour résoudre la tâche. Vous pouvez implémenter des tableaux complexes, de beaux menus et des diagrammes - en général, une interface utilisateur de toute complexité, à la fois sur une API pure et à l'aide de bibliothèques prêtes à l'emploi. Bien sûr, pas seulement en 2D.</font></font><br> <a href=""><img src="https://habrastorage.org/webt/r2/6v/ix/r26vixlwxtaspaykchnffmpwexm.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Utilisation des fonctions du moteur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'implémentation de la même fonctionnalité pour chaque API est plutôt morne; les développeurs créent des wrappers pratiques en fournissant des fonctions de dessin, d'interface utilisateur, etc., que le jeu utilise directement. </font><font style="vertical-align: inherit;">Valve fournit également des API Dota 2 pour </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ceci est fait afin de faciliter la vie des modérateurs et des concepteurs de jeux pour qui le C ++ est compliqué (pas même le C ++ lui-même, mais une utilisation appropriée dans le contexte du moteur). </font><font style="vertical-align: inherit;">Ici, il y a des fonctions pour le rendu et pour la logique du jeu - vous pouvez prescrire le comportement de l'unité, par exemple, sélectionner des éléments, utiliser des compétences, etc. </font><font style="vertical-align: inherit;">En fait, avec l'aide de cela, des lettres personnalisées sont écrites.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous serons intéressés par la fonction DoIncludeScript, qui vous permet d'exécuter vos scripts sur Lua et d'y utiliser l'API de script. Je ne l'ai pas utilisé dans mon projet, car je n'y voyais pas de valeur, en utilisant des fonctions directement depuis C ++, j'ai vu l'idée de l'utiliser avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or_75</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">j'ai</font></a><font style="vertical-align: inherit;"> décidé de l'inclure dans l'article. Cela vous présentera ce qui se trouvera dans la deuxième partie et économisera de l’espace; vous n’avez pas à expliquer certains aspects du débogueur.</font></font><br><br>  Commençons.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tâche est la suivante: vous devez rechercher un pointeur vers la fonction DoIncludeScript, qui prend le nom du script et du gestionnaire, pour l'étudier. Nous rechercherons la fonction à l'aide du scanner de notre bibliothèque silk_way.lib. Les fonctions, comme nous l'avons déjà découvert, sont encodées en mémoire à l'aide de la table d'opcode - examinons cette fonction et essayons d'identifier son modèle de stockage en mémoire. Maintenant, le scanner n'a pas les fonctionnalités nécessaires, nous devons pouvoir rechercher un modèle dans la mémoire de processus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour accélérer la recherche, nous ne rechercherons pas un modèle dans la mémoire du processus, mais dans un module spécifique (notre fonction réside dans client.dll, cela sera vu dans le débogueur et sera discuté ci-dessous). Nous rechercherons le module en utilisant tlHelp32 par nom en énumérant tous les modules du processus, pour lesquels nous créerons une fonction pour trouver le module dans le processus GetModuleInfo en cours.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de fonction GetModuleInfo</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IScanner::GetModuleInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name, MODULEENTRY32* entry) { HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE32 | TH32CS_SNAPMODULE, GetCurrentProcessId()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (snapshot == INVALID_HANDLE_VALUE) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; entry-&gt;dwSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MODULEENTRY32); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Module32First(snapshot, entry)) { CloseHandle(snapshot); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_stricmp(entry-&gt;szModule, name)) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Module32Next(snapshot, entry)); CloseHandle(snapshot); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le modèle est une chaîne avec une valeur d'octets, sauter un octet est indiqué par le symbole "??" </font><font style="vertical-align: inherit;">- par exemple, "j9 ??</font></font> ??  ??  ??<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48 03 08 ?? </font><font style="vertical-align: inherit;">f1 ff ”. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En analysant la chaîne, pour plus de commodité, nous transférerons le modèle de la représentation de la chaîne vers la liste des valeurs de caractères non signées, définissons les indicateurs d'octets à ignorer.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* IScanner::Parse(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; len, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* strPattern, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* skipByteMask) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> strPatternLen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(strPattern); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* pattern = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[strPatternLen]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; strPatternLen; i++) pattern[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; strPatternLen; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> code = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strPattern[i] == SKIP_SYMBOL) skipByteMask[len] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> code = Parse(strPattern[i]) * <span class="hljs-number"><span class="hljs-number">16</span></span> + Parse(strPattern[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]); i++; pattern[len++] = code; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pattern; } <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> IScanner::Parse(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> byte) { <span class="hljs-comment"><span class="hljs-comment">// some magic values if (byte &gt;= '0' &amp;&amp; byte &lt;= '9') return byte - '0'; else if (byte &gt;= 'a' &amp;&amp; byte &lt;= 'f') return byte - 'a' + 10; else if (byte &gt;= 'A' &amp;&amp; byte &lt;= 'F') return byte - 'A' + 10; return 0; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le noyau de recherche est implémenté dans la fonction FindPattern, où, en fonction des informations reçues sur le module, les adresses de début et de fin de la recherche sont définies. </font><font style="vertical-align: inherit;">Les informations sur la mémoire qui sera recherchée sont demandées par la fonction VirtualQuery, il y a un certain nombre d'exigences pour la mémoire - elle doit être occupée (ce sera une erreur de rechercher dans la mémoire libre), la mémoire doit être lisible, exécutable et ne pas contenir l'indicateur PageGuard:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pStart = moduleEntry.modBaseAddr; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pFinish = moduleEntry.modBaseAddr + moduleEntry.modBaseSize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* current = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)pStart; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; current &lt; pFinish &amp;&amp; j &lt; patternLen; current++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!VirtualQuery((LPCVOID)current, &amp;info, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(info))) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> protectMask = PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE | PAGE_EXECUTE_READ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.State == MEM_COMMIT &amp;&amp; info.Protect &amp; protectMask &amp;&amp; !(info.Protect &amp; PAGE_GUARD)) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> finish = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)pFinish &lt; (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)info.BaseAddress + info.RegionSize ? (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)pFinish : (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) info.BaseAddress + info.RegionSize; current = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)info.BaseAddress; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* rip = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> k = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)info.BaseAddress; k &lt; finish &amp;&amp; j &lt; patternLen; k++, current++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skipByteMask[j] || pattern[j] == *current) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) rip = current; j++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pattern[<span class="hljs-number"><span class="hljs-number">0</span></span>] == *current) { rip = current; j = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == patternLen) { current = rip; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> current += sysInfo.dwPageSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons rechercher le modèle souhaité dans la mémoire de processus, mais nous ne savons pas encore quoi rechercher. Exécutez Steam sous le faux compte et ouvrez votre débogueur préféré (convenons que pour le moment de lire l'article x64dbg est aussi pour vous - je n'ai pas de licence payante pour IDA Pro), exécutez dota2.exe dedans depuis le répertoire ... \ Steam \ steamapps \ common \ dota 2 beta \ game \ bin \ win64. En principe, je n'ai pas remarqué que VAC n'était pas indifférent à Cheat Engine et x64dbg, je ne me souviens pas qu'en utilisant ces outils, le compte était interdit. Par ailleurs, le débogueur possède un plugin </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ScyllaHide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui intercepte les fonctions système comme NtCreateThreadEx, NtSetInformationThread, etc., cachant le fait de son travail, vous pouvez installer ce plugin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À chaque arrêt (il y aura 10-15), nous continuons à exécuter en utilisant Run (F9). Lorsque le jeu commencera, nous verrons le menu et nous pourrons commencer la recherche. Après avoir démarré le jeu, effectuez une recherche sur les lignes (Rechercher-&gt; Tous les modules-&gt; Références de chaînes), définissez le filtre «DoIncludeScript». </font><i><font style="vertical-align: inherit;">Figure 25 - Recherche des lignes dans la mémoire du processus de jeu</font></i><font style="vertical-align: inherit;"> Passons au désassembleur (onglet CPU) en double-cliquant sur le premier résultat. Ce sera notre adresse de départ, car il s'agit de client.dll, le reste des résultats se trouve dans server.dll et animationsystem.dll. </font><font style="vertical-align: inherit;">Nous construisons un graphe d'appels à partir de l'adresse reçue. </font><i><font style="vertical-align: inherit;">Figure 26 - Graphique d'appel</font></i><font style="vertical-align: inherit;"> Après la décompilation, nous trouvons le point d'entrée où DoIncludeScript est utilisé - le quatrième nœud du graphique. En fait, la fonction elle-même.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/nl/t2/x7/nlt2x7qovaunasqqpd6hqojgclw.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/om/os/zo/omoszo_tqtleqsulp5c97sp7iwo.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ja/pp/zo/jappzokowbi-si2zm8zchka3pjk.png"></a> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 27 - La fonction</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> graphique </font><i><font style="vertical-align: inherit;">DoIncludeScript</font></i><font style="vertical-align: inherit;"> . </font><i><font style="vertical-align: inherit;">Figure 28 - Le graphe d'appel de DoIncludeScript Décompiler</font></i><font style="vertical-align: inherit;"> l'utilisation de la fonction montre le code suivant et le lieu de son appel (la décompilation se fait depuis le graphe, pas depuis le désassembleur). </font><i><font style="vertical-align: inherit;">Figure 29 - Décompilation d'un appel à la fonction DoIncludeScript Composons</font></i><font style="vertical-align: inherit;"> un modèle à partir des instructions de la figure 27 de l'appel à la fonction DoIncludeScript. </font><font style="vertical-align: inherit;">Les arguments peuvent changer, respectivement, nous voulons ignorer les arguments dans le modèle lors de la recherche, nous les désignons par «??». </font><font style="vertical-align: inherit;">J'ai obtenu ce qui suit: 40 57 48 81 EC ??</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/ji/q0/w9/jiq0w96b8mmvbuh7un7iyiffq_8.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><br><br> <a href=""><img src="https://habrastorage.org/webt/pb/rl/8h/pbrl8hdsnnowxoyfq-lz1xbq3xg.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font> ??  ??  ??<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 48 83 3D ?? </font></font> ??  ??  ??  ??<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48 8B F9 0F 84. Pour compiler le modèle, nous avons utilisé le premier nœud du graphique de la figure 28, dont les instructions se trouvent dans la figure 27. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un script sur Lua silk_way.lua, mettez-le dans "... \ Steam \ steamapps \ common \ dota 2 beta \ game \ dota \ scripts \ vscripts ".</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"SILK_WAY START"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> first = Entities:First() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (first ~= <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> position = first:GetAbsOrigin() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> strInfo = <span class="hljs-string"><span class="hljs-string">"["</span></span> .. <span class="hljs-string"><span class="hljs-string">"pos:"</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(position.x) .. <span class="hljs-string"><span class="hljs-string">","</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(position.y) .. <span class="hljs-string"><span class="hljs-string">","</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">tostring</span></span>(position.z) .. <span class="hljs-string"><span class="hljs-string">"]"</span></span> DebugDrawText(position, strInfo, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-number"><span class="hljs-number">300.0</span></span>) first = Entities:Next(first) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"SILK_WAY FINISH"</span></span>) <span class="hljs-comment"><span class="hljs-comment">--[[ListenToGameEvent("dota_roshan_kill",roshan_kill,nil)]]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce script contourne toutes les entités et affiche les coordonnées en fonction de sa position. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déclarez la fonction à l'aide de la documentation ci-dessus et du code décompilé de la figure 29.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*fDoIncludeScript)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Appel de fonction. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">HRESULT WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndSceneHook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IDirect3DDevice9* pd3dDevice)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (controller == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameController(); controller-&gt;SetDevice(pd3dDevice); fDoIncludeScript DoIncludeScript = (fDoIncludeScript) scanner-&gt;FindPattern(<span class="hljs-string"><span class="hljs-string">"client.dll"</span></span>, <span class="hljs-string"><span class="hljs-string">"40 57 48 81 EC ?? ?? ?? ?? 48 83 3D ?? ?? ?? ?? ?? 48 8B F9 0F 84"</span></span>); DoIncludeScript(<span class="hljs-string"><span class="hljs-string">"silk_way"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après la mise en œuvre, nous verrons des informations sur la position des entités du jeu. </font><i><font style="vertical-align: inherit;">Figure 30 - Résultat de l'implémentation</font></i><font style="vertical-align: inherit;"> Nous pouvons maintenant exécuter nos scripts. </font><font style="vertical-align: inherit;">Mais ils sont exécutés dans Lua, et disons que l'événement où Roshan est mort est nécessaire pour nous dans le code C ++ (puisque nous avons la logique principale écrite dessus), que devons-nous faire? </font><font style="vertical-align: inherit;">Nous devrons trouver des pointeurs vers les fonctions nécessaires de la même manière (comme nous l'avons fait pour DoIncludeScript), les fonctions du moteur et d'autres fonctionnalités qui nous intéressent en utilisant le SDK Source et Source2Gen. </font><font style="vertical-align: inherit;">Mais plus à ce sujet dans la partie suivante, où nous trouverons un pointeur vers une liste d'entités et rédigerons une logique plus proche de la mécanique du jeu. </font><font style="vertical-align: inherit;">Si vous voulez tout à la fois, vous pouvez essayer, je joins </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">ceci</font></a><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">ceci</font></a><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">ceci</font></a><font style="vertical-align: inherit;"> et </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">cela</font></a><font style="vertical-align: inherit;"> comme votre aide</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/en/x2/4l/enx24lrbff5j_6l0v4ydxhecm84.png"></a> <br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> liens. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Conclusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conclusion, je voudrais remercier tous ceux qui partagent leurs meilleures pratiques et connaissances dans le domaine du reverse, partageant leur expérience avec les autres. En ne parlant que de Dota 2 sans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chien de prière,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'aurais tué beaucoup de temps pour obtenir la structure de données du jeu en utilisant le Cheat Engine, et les réalisations réalisées pourraient rompre avec toute mise à jour de Valve. Les mises à jour cassent les deux pointeurs statiques trouvés et changent parfois la structure des entités. À </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or75,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai vu l'utilisation de la fonction DoIncludeScript et avec son aide, j'ai montré un exemple de sortie de texte à l'aide du moteur de jeu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans un souci de simplicité de présentation, je pourrais manquer quelque chose, omettre divers cas que je jugeais indignes d'attention, ou vice versa, gonfler l'explication - si un lecteur attentif trouve de telles erreurs, je serai heureux de les corriger et d'écouter les commentaires. </font><font style="vertical-align: inherit;">Le code source se trouve sur le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merci à tous ceux qui ont pris le temps de lire l'article.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446516/">https://habr.com/ru/post/fr446516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446506/index.html">Cinq questions clés pour le commerce de détail lors de la migration vers nos clouds</a></li>
<li><a href="../fr446508/index.html">Travailleurs .NET Core en tant que services Windows</a></li>
<li><a href="../fr446510/index.html">CLRium # 5: Garbage Collector. Le plus grand atelier .NET</a></li>
<li><a href="../fr446512/index.html">Travailleurs .NET Core en tant que services Windows</a></li>
<li><a href="../fr446514/index.html">Gmail a 15 ans</a></li>
<li><a href="../fr446518/index.html">Pare-feu d'applications Web</a></li>
<li><a href="../fr446520/index.html">Comment tout a commencé: l'histoire des drones volants</a></li>
<li><a href="../fr446522/index.html">Swift 5.1 - quoi de neuf?</a></li>
<li><a href="../fr446530/index.html">Word2vec en images</a></li>
<li><a href="../fr446532/index.html">Upwork introduit des frais pour le droit d'écrire à un client potentiel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>