<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏽 ♍️ 🛎️ Redis Stream - Fiabilité et évolutivité de vos systèmes de messagerie 🚓 🕵🏼 💄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Redis Stream - un nouveau type de données abstrait introduit dans Redis avec la sortie de la version 5.0 
 Conceptuellement, Redis Stream est une list...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redis Stream - Fiabilité et évolutivité de vos systèmes de messagerie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456270/"><img src="https://habrastorage.org/webt/4z/my/lg/4zmylgmptsa7q0dqxbekaq4gvai.png" alt="image"><br><br>  Redis Stream - un nouveau type de données abstrait introduit dans Redis avec la sortie de la version 5.0 <br>  Conceptuellement, Redis Stream est une liste à laquelle vous pouvez ajouter des entrées.  Chaque entrée a un identifiant unique.  Par défaut, un identifiant est généré automatiquement et inclut un horodatage.  Par conséquent, vous pouvez demander des plages d'enregistrement par heure ou recevoir de nouvelles données à mesure qu'elles arrivent dans le flux, car la commande Unix tail -f lit le fichier journal et se fige en prévision de nouvelles données.  Veuillez noter que plusieurs clients peuvent écouter le flux en même temps, car de nombreux processus «tail -f» peuvent lire un fichier en même temps sans entrer en conflit les uns avec les autres. <br><br>  Pour comprendre tous les avantages du nouveau type de données, rappelons brièvement les structures Redis existantes qui répètent partiellement les fonctionnalités de Redis Stream. <br><a name="habracut"></a><br><h1>  Excursion historique </h1><br><h4>  Redis pub / sub </h4><br>  Redis Pub / Sub est un système de messagerie simple déjà intégré à votre stockage de valeurs-clés.  Cependant, pour plus de simplicité, vous devez payer: <br><br><ul><li>  Si l'éditeur pour une raison quelconque échoue, il perd tous ses abonnés </li><li>  L'éditeur doit connaître l'adresse exacte de tous ses abonnés. </li><li>  Un éditeur peut surcharger ses abonnés si les données sont publiées plus rapidement qu'elles ne sont traitées </li><li>  Le message est supprimé du tampon de l'éditeur immédiatement après sa publication, quel que soit le nombre d'abonnés qu'il a transmis et la rapidité avec laquelle ils ont réussi à traiter ce message. </li><li>  Tous les abonnés recevront le message en même temps.  Les abonnés eux-mêmes doivent en quelque sorte s'entendre sur la façon de traiter le même message. </li><li>  Il n'y a pas de mécanisme intégré pour confirmer le succès du traitement d'un message par un abonné  Si l'abonné a reçu un message et est tombé pendant le traitement, l'éditeur n'en sera pas informé. </li></ul><br><h4>  Liste Redis </h4><br>  Redis List est une structure de données qui prend en charge les commandes de lecture de verrouillage.  Vous pouvez ajouter et lire des messages depuis le début ou la fin de la liste.  Sur la base de cette structure, vous pouvez créer une bonne pile ou file d'attente pour votre système distribué et cela suffira dans la plupart des cas.  Les principales différences avec Redis Pub / Sub: <br><br><ul><li>  Le message est remis à un client.  Le premier client bloqué par la lecture recevra d'abord les données. </li><li>  Clint doit lancer une opération de lecture pour chaque message.  List ne sait rien des clients. </li><li>  Les messages sont stockés jusqu'à ce que quelqu'un les compte ou les supprime explicitement.  Si vous configurez un serveur Redis pour vider les données sur le disque, la fiabilité du système augmente considérablement. </li></ul><br><h1>  Introduction à Stream </h1><br><h4>  Ajout d'un enregistrement à un flux </h4><br>  La commande <b>XADD</b> ajoute un nouvel enregistrement au flux.  Un enregistrement n'est pas seulement une chaîne, il se compose d'une ou plusieurs paires clé-valeur.  Ainsi, chaque enregistrement est déjà structuré et ressemble à la structure d'un fichier CSV. <br><br><pre><code class="go hljs">&gt; XADD mystream * sensor-id <span class="hljs-number"><span class="hljs-number">1234</span></span> temperature <span class="hljs-number"><span class="hljs-number">19.8</span></span> <span class="hljs-number"><span class="hljs-number">1518951480106</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span></code> </pre> <br>  Dans l'exemple ci-dessus, nous ajoutons deux champs au flux avec le nom (clé) "mystream": "sensor-id" et "temperature" avec les valeurs "1234" et "19.8", respectivement.  Comme deuxième argument, la commande accepte l'identifiant qui sera affecté à l'enregistrement - cet identifiant identifie de manière unique chaque enregistrement du flux.  Cependant, dans ce cas, nous avons passé * car nous voulons que Redis génère un nouvel identifiant pour nous.  Chaque nouvel identifiant augmentera.  Par conséquent, chaque nouvel enregistrement aura un identifiant plus grand par rapport aux enregistrements précédents. <br><br><h4>  Format d'ID </h4><br>  L'identifiant d'enregistrement renvoyé par la commande <b>XADD se</b> compose de deux parties: <br><br> <code>{millisecondsTime}-{sequenceNumber} <br></code> <br>  <i>millisecondsTime</i> - Temps Unix en millisecondes (temps du serveur Redis).  Toutefois, si l'heure actuelle est identique ou inférieure à l'heure de l'enregistrement précédent, l'horodatage de l'enregistrement précédent est utilisé.  Par conséquent, si l'heure du serveur est revenue au passé, le nouvel identifiant conservera toujours la propriété d'augmentation. <br><br>  <i>sequenceNumber est</i> utilisé pour les enregistrements créés dans la même milliseconde.  <i>sequenceNumber</i> sera augmenté de 1 par rapport à l'enregistrement précédent.  Étant donné que <i>sequenceNumber a une</i> taille de 64 bits, en pratique, vous ne devez pas rencontrer de limite sur le nombre d'enregistrements pouvant être générés en une milliseconde. <br><br>  Le format de ces identifiants à première vue peut sembler étrange.  Un lecteur incrédule peut se demander pourquoi le temps fait partie d'un identifiant.  La raison en est que les flux Redis prennent en charge les demandes de plage par des identifiants.  L'identifiant étant associé à l'heure de création de l'enregistrement, cela permet de demander des plages horaires.  Nous examinerons un exemple concret lorsque nous passerons à l'étude de la <b>commande XRANGE</b> . <br><br>  Si, pour une raison quelconque, l'utilisateur doit spécifier son propre identifiant, qui, par exemple, est associé à un système externe, nous pouvons le transmettre à la <b>commande XADD</b> au lieu du signe * comme indiqué ci-dessous: <br><br><pre> <code class="go hljs">&gt; XADD somestream <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> field value <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> &gt; XADD somestream <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span> foo bar <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span></code> </pre><br>  Veuillez noter que dans ce cas, vous devez surveiller vous-même l'augmentation de l'identifiant.  Dans notre exemple, l'identifiant minimum est «0-1», donc l'équipe n'acceptera pas un autre identifiant égal ou inférieur à «0-1». <br><br><pre> <code class="go hljs">&gt; XADD somestream <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> foo bar (error) ERR The ID specified in XADD is equal or smaller than the target stream top item</code> </pre><br><h4>  Le nombre d'enregistrements dans le flux </h4><br>  Vous pouvez obtenir le nombre d'enregistrements dans un flux simplement en utilisant la commande <b>XLEN</b> .  Pour notre exemple, cette commande renverra la valeur suivante: <br><br><pre> <code class="go hljs">&gt; XLEN somestream (integer) <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br><h4>  Demandes de plage - XRANGE et XREVRANGE </h4><br>  Pour demander des données pour une plage, nous devons spécifier deux identifiants - le début et la fin de la plage.  La plage renvoyée comprendra tous les éléments, y compris les bordures.  Il y a également deux identificateurs spéciaux "-" et "+", respectivement, ce qui signifie le plus petit (premier enregistrement) et le plus grand (dernier enregistrement) identificateur dans le flux.  L'exemple ci-dessous affiche toutes les entrées de flux. <br><br><pre> <code class="go hljs">&gt; XRANGE mystream - + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1518951480106</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"sensor-id"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1234"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"temperature"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"19.8"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1518951482479</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"sensor-id"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"9999"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"temperature"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"18.2"</span></span></code> </pre><br>  Chaque enregistrement renvoyé est un tableau de deux éléments: un identifiant et une liste de paires clé-valeur.  Nous avons déjà dit que les identifiants d'enregistrement sont liés au temps.  Par conséquent, nous pouvons demander la plage d'une période de temps spécifique.  Cependant, nous pouvons spécifier dans la requête non pas l'identifiant complet, mais uniquement le temps Unix, en omettant la partie liée à <i>sequenceNumber</i> .  La partie omise de l'identifiant est automatiquement égale à zéro au début de la plage et à la valeur maximale possible à la fin de la plage.  Voici un exemple de la façon de demander une plage de deux millisecondes. <br><br><pre> <code class="go hljs">&gt; XRANGE mystream <span class="hljs-number"><span class="hljs-number">1518951480106</span></span> <span class="hljs-number"><span class="hljs-number">1518951480107</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1518951480106</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"sensor-id"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1234"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"temperature"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"19.8"</span></span></code> </pre><br>  Nous n'avons qu'un seul enregistrement dans cette plage, mais dans les ensembles de données réels, le résultat renvoyé peut être énorme.  Pour cette raison, <b>XRANGE</b> prend en charge l'option COUNT.  En spécifiant la quantité, nous pouvons simplement obtenir les N premiers enregistrements.  Si nous devons obtenir les N entrées suivantes (pagination), nous pouvons utiliser le dernier identifiant reçu, augmenter son <i>numéro</i> de <i>séquence</i> de un et demander à nouveau.  Voyons cela dans l'exemple suivant.  Nous commençons à ajouter 10 éléments en utilisant <b>XADD</b> (supposons que le flux mystream a déjà été rempli avec 10 éléments).  Pour commencer l'itération, en obtenant 2 éléments par commande, nous commençons avec la plage complète, mais avec COUNT égal à 2. <br><br><pre> <code class="go hljs">&gt; XRANGE mystream - + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073278252</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_1"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073279157</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_2"</span></span></code> </pre><br>  Pour continuer l'itération avec les deux éléments suivants, nous devons sélectionner le dernier identifiant reçu, c'est-à-dire 1519073279157-0, et ajouter 1 à <i>sequenceNumber</i> . <br>  L'identifiant résultant, dans ce cas 1519073279157-1, peut maintenant être utilisé comme un nouvel argument au début de la plage pour le prochain appel <b>XRANGE</b> : <br><br><pre> <code class="go hljs">&gt; XRANGE mystream <span class="hljs-number"><span class="hljs-number">1519073279157</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span> + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073280281</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_3"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073281432</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_4"</span></span></code> </pre><br>  Et ainsi de suite.  Puisque la complexité de <b>XRANGE</b> est O (log (N)) pour rechercher, puis O (M) pour renvoyer M éléments, chaque étape d'itération est rapide.  Ainsi, en utilisant <b>XRANGE,</b> il est possible d' <b>itérer</b> efficacement les flux. <br><br>  La commande <b>XREVRANGE</b> est l'équivalent de <b>XRANGE</b> , mais renvoie les éléments dans l'ordre inverse: <br><br><pre> <code class="go hljs">&gt; XREVRANGE mystream + - COUNT <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073287312</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_10"</span></span></code> </pre><br>  Notez que la commande <b>XREVRANGE</b> prend les arguments de la plage de début et de fin dans l'ordre inverse. <br><br><h4>  Lecture de nouveaux enregistrements avec XREAD </h4><br>  Il est souvent nécessaire de s'abonner au flux et de ne recevoir que de nouveaux messages.  Ce concept peut sembler être un Redis Pub / Sub ou bloquer une liste Redis, mais il existe des différences fondamentales dans la façon d'utiliser Redis Stream: <br><br><ol><li>  Chaque nouveau message est remis par défaut à chaque abonné.  Ce comportement est différent du blocage de la liste Redis, où un nouveau message sera lu par un seul abonné. </li><li>  Alors que dans Redis Pub / Sub tous les messages sont oubliés et jamais enregistrés, dans Stream tous les messages sont stockés indéfiniment (sauf si le client provoque explicitement la suppression). </li><li>  Redis Stream vous permet de différencier l'accès aux messages au sein d'un même flux.  Un abonné spécifique ne peut voir que l'historique de ses messages personnels. </li></ol><br>  Vous pouvez vous abonner au flux et recevoir de nouveaux messages à l'aide de la commande <b>XREAD</b> .  C'est un peu plus compliqué que <b>XRANGE</b> , nous allons donc commencer par des exemples plus simples. <br><br><pre> <code class="go hljs">&gt; XREAD COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> STREAMS mystream <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073278252</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_1"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1519073279157</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"value_2"</span></span></code> </pre><br>  Dans l'exemple ci-dessus, un formulaire <b>XREAD</b> non bloquant est <b>spécifié</b> .  Veuillez noter que l'option COUNT est facultative.  En fait, la seule option de commande requise est l'option STREAMS, qui définit la liste des flux avec l'identifiant maximal correspondant.  Nous avons écrit «STREAMS mystream 0» - nous voulons obtenir tous les enregistrements du flux mystream avec un identifiant supérieur à «0-0».  Comme vous pouvez le voir dans l'exemple, la commande renvoie le nom du flux, car nous pouvons nous abonner à plusieurs flux en même temps.  Nous pourrions écrire, par exemple, «STREAMS mystream otherstream 0 0».  Veuillez noter qu'après l'option STREAMS, nous devons d'abord fournir les noms de tous les flux nécessaires, puis seulement une liste d'identifiants. <br><br>  Sous cette forme simple, la commande n'a rien de spécial par rapport à <b>XRANGE</b> .  Cependant, la chose intéressante est que nous pouvons facilement transformer <b>XREAD</b> en une commande de blocage en spécifiant l'argument BLOCK: <br><br> <code>&gt; XREAD BLOCK 0 STREAMS mystream $ <br></code> <br>  Dans l'exemple ci-dessus, une nouvelle option BLOCK est spécifiée avec un délai d'expiration de 0 millisecondes (cela signifie une attente sans fin).  De plus, au lieu de passer l'identifiant habituel pour le flux mystream, l'identifiant spécial $ a été passé.  Cet identifiant spécial signifie que <b>XREAD</b> doit utiliser l'identifiant maximum dans le flux mystream comme identifiant.  Nous ne recevrons donc que de nouveaux messages, à partir du moment où nous avons commencé à écouter.  D'une certaine manière, cela est similaire à la commande Unix tail -f. <br><br>  Veuillez noter que lorsque vous utilisez l'option BLOC, nous n'avons pas besoin d'utiliser l'identifiant spécial $.  Nous pouvons utiliser n'importe quel identifiant existant dans le flux.  Si l'équipe peut répondre immédiatement à notre demande, sans bloquer, elle le fera, sinon elle sera bloquée. <br><br>  Le blocage de <b>XREAD</b> peut également écouter plusieurs flux à la fois, il vous suffit de spécifier leurs noms.  Dans ce cas, la commande renverra un enregistrement du premier flux dans lequel les données sont arrivées.  Le premier abonné bloqué pour ce flux recevra d'abord les données. <br><br><h3>  Groupes de consommateurs </h3><br>  Dans certaines tâches, nous voulons différencier l'accès des abonnés aux messages dans le même fil.  Un exemple où cela peut être utile est une file d'attente de messages avec des travailleurs qui recevront différents messages du flux, vous permettant de faire évoluer le traitement des messages. <br><br>  Si nous imaginons que nous avons trois abonnés C1, C2, C3 et un flux qui contient les messages 1, 2, 3, 4, 5, 6, 7, alors le service de messagerie se produira comme dans le diagramme ci-dessous: <br><br> <code>1 -&gt; C1 <br> 2 -&gt; C2 <br> 3 -&gt; C3 <br> 4 -&gt; C1 <br> 5 -&gt; C2 <br> 6 -&gt; C3 <br> 7 -&gt; C1 <br></code> <br>  Pour obtenir cet effet, Redis Stream utilise un concept appelé Consumer Group.  Ce concept est similaire à un pseudo-abonné qui reçoit des données d'un flux, mais est en fait servi par plusieurs abonnés au sein d'un groupe, offrant certaines garanties: <br><br><ol><li>  Chaque message est remis à différents abonnés du groupe. </li><li>  Au sein d'un groupe, les abonnés sont identifiés par leur nom, qui est une chaîne sensible à la casse.  Si un abonné abandonne temporairement le groupe, il peut être restauré dans le groupe par son propre nom unique. </li><li>  Chaque groupe de consommateurs suit le concept de «premier message non lu».  Lorsqu'un abonné demande de nouveaux messages, il ne peut recevoir que des messages qui n'ont jamais été remis à aucun abonné d'un groupe. </li><li>  Il existe une commande pour confirmer explicitement le succès du traitement du message par l'abonné.  Jusqu'à ce que cette commande soit appelée, le message demandé restera dans l'état "en attente". </li><li>  Au sein du Consumer Group, chaque abonné peut demander un historique des messages qui lui ont été remis, mais qui n'ont pas encore été traités (dans l'état "en attente") </li></ol><br>  En un sens, l'état d'un groupe peut être représenté comme suit: <br><br><pre> <code class="go hljs">+----------------------------------------+ | consumer_group_name: mygroup | consumer_group_stream: somekey | last_delivered_id: <span class="hljs-number"><span class="hljs-number">1292309234234</span></span><span class="hljs-number"><span class="hljs-number">-92</span></span> | | consumers: | <span class="hljs-string"><span class="hljs-string">"consumer-1"</span></span> with pending messages | <span class="hljs-number"><span class="hljs-number">1292309234234</span></span><span class="hljs-number"><span class="hljs-number">-4</span></span> | <span class="hljs-number"><span class="hljs-number">1292309234232</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> | <span class="hljs-string"><span class="hljs-string">"consumer-42"</span></span> with pending messages | ... (and so forth) +----------------------------------------+</code> </pre><br>  Il est maintenant temps de se familiariser avec les principales équipes du Consumer Group, à savoir: <br><br><ul><li>  <b>XGROUP est</b> utilisé pour créer, détruire et gérer des groupes. </li><li>  <b>XREADGROUP est</b> utilisé pour lire un flux à travers un groupe. </li><li>  <b>XACK</b> - cette commande permet à l'abonné de marquer le message comme traité avec succès </li></ul><br><h4>  Création d'un groupe de consommateurs </h4><br>  Supposons qu'un flux mystream existe déjà.  La commande de création de groupe ressemblera alors à: <br><br> <code>&gt; XGROUP CREATE mystream mygroup $ <br> OK <br></code> <br>  Lors de la création d'un groupe, nous devons transmettre un identifiant commençant par lequel le groupe recevra les messages.  Si nous voulons simplement recevoir tous les nouveaux messages, nous pouvons utiliser l'identifiant spécial $ (comme dans notre exemple ci-dessus).  Si vous spécifiez 0 au lieu d'un identifiant spécial, tous les messages du flux seront disponibles pour le groupe. <br><br>  Maintenant que le groupe est créé, nous pouvons immédiatement commencer à lire les messages à l'aide de la <b>commande XREADGROUP</b> .  Cette commande est très similaire à <b>XREAD</b> et prend en charge l'option BLOC facultative.  Cependant, il existe une option GROUP obligatoire, qui doit toujours être spécifiée avec deux arguments: le nom du groupe et le nom de l'abonné.  L'option COUNT est également prise en charge. <br><br>  Avant de lire le flux, mettons-y quelques messages: <br><br><pre> <code class="go hljs">&gt; XADD mystream * message apple <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message orange <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message strawberry <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message apricot <span class="hljs-number"><span class="hljs-number">1526569535168</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream * message banana <span class="hljs-number"><span class="hljs-number">1526569544280</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span></code> </pre><br>  Essayons maintenant de lire ce flux à travers le groupe: <br><br><pre> <code class="go hljs">&gt; XREADGROUP GROUP mygroup Alice COUNT <span class="hljs-number"><span class="hljs-number">1</span></span> STREAMS mystream &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"apple"</span></span></code> </pre><br>  La commande ci-dessus textuellement se lit comme suit: <br><br>  "Moi, abonné d'Alice, membre de mon groupe, je veux lire un message du mystream qui n'a jamais été livré à personne auparavant." <br><br>  Chaque fois qu'un abonné effectue une opération avec un groupe, il doit indiquer son nom, s'identifiant de manière unique au sein du groupe.  Il y a un autre détail très important dans la commande ci-dessus - l'identifiant spécial "&gt;".  Cet identifiant spécial filtre les messages, ne laissant que ceux qui n'ont jusqu'à présent jamais été remis. <br><br>  De plus, dans des cas particuliers, vous pouvez spécifier un identifiant réel, tel que 0 ou tout autre identifiant valide.  Dans ce cas, la commande <b>XREADGROUP</b> vous renverra l'historique des messages avec le statut «en attente», qui ont été remis à l'abonné spécifié (Alice), mais qui n'ont pas encore été confirmés à l'aide de la <b>commande XACK</b> . <br><br>  Nous pouvons vérifier ce comportement en spécifiant immédiatement l'identifiant 0, sans l'option <b>COUNT</b> .  Nous voyons juste le seul message en attente, c'est-à-dire le message avec la pomme: <br><br><pre> <code class="go hljs">&gt; XREADGROUP GROUP mygroup Alice STREAMS mystream <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"apple"</span></span></code> </pre><br>  Cependant, si nous confirmons que le message a été traité avec succès, il ne s'affichera plus: <br><br><pre> <code class="go hljs">&gt; XACK mystream mygroup <span class="hljs-number"><span class="hljs-number">1526569495631</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; XREADGROUP GROUP mygroup Alice STREAMS mystream <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) (empty list or set)</code> </pre><br>  Maintenant, c'est au tour de Bob de lire quelque chose: <br><br><pre> <code class="go hljs">&gt; XREADGROUP GROUP mygroup Bob COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> STREAMS mystream &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"mystream"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"orange"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"strawberry"</span></span></code> </pre><br>  Bob, membre de mon groupe, n'a pas demandé plus de deux messages.  La commande signale uniquement les messages non livrés en raison de l'identifiant spécial "&gt;".  Comme vous pouvez le voir, le message «pomme» ne s'affiche pas, car il a déjà été livré à Alice, donc Bob reçoit «orange» et «fraise». <br><br>  Ainsi, Alice, Bob et tout autre abonné du groupe peuvent lire différents messages du même flux.  Ils peuvent également lire l'historique de leurs messages bruts ou marquer les messages comme traités. <br><br>  Il y a quelques points à garder à l'esprit: <br><br><ul><li>  Dès que l'abonné considère que le message est la commande <b>XREADGROUP</b> , ce message passe à l'état «en attente» et est attribué à cet abonné particulier.  Les autres abonnés du groupe ne pourront pas lire ce message. </li><li>  Les abonnés sont automatiquement créés à la première mention, il n'y a pas besoin de leur création explicite. </li><li>  Avec <b>XREADGROUP,</b> vous pouvez lire les messages de plusieurs flux différents en même temps, cependant, pour que cela fonctionne, vous devez d'abord créer des groupes avec le même nom pour chaque flux à l'aide de <b>XGROUP</b> </li></ul><br><h4>  Récupération après incident </h4><br>  L'abonné peut récupérer de l'échec et relire sa liste de messages avec le statut "en attente".  Cependant, dans le monde réel, les abonnés peuvent finalement échouer.  Qu'arrive-t-il au message suspendu d'un abonné s'il ne peut pas récupérer après un échec? <br>  Le Consumer Group propose une fonctionnalité qui est utilisée spécifiquement pour de tels cas - lorsque vous devez changer le propriétaire des messages. <br><br>  Tout d'abord, vous devez appeler la commande <b>XPENDING</b> , qui affiche tous les messages du groupe avec le statut "en attente".  Dans sa forme la plus simple, une commande est appelée avec seulement deux arguments: le nom du flux et le nom du groupe: <br><br><pre> <code class="go hljs">&gt; XPENDING mystream mygroup <span class="hljs-number"><span class="hljs-number">1</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span></code> </pre><br>  L'équipe a imprimé le nombre de messages non traités pour l'ensemble du groupe et pour chaque abonné.  Nous n'avons que Bob avec deux messages non traités, car le seul message demandé par Alice a été confirmé avec <b>XACK</b> . <br><br>  Nous pouvons demander des informations supplémentaires en utilisant plus d'arguments: <br><br> <code>XPENDING {key} {groupname} [{start-id} {end-id} {count} [{consumer-name}]] <br></code> <br>  {start-id} {end-id} - plage d'identifiants (vous pouvez utiliser "-" et "+") <br>  {count} - le nombre de tentatives de livraison <br>  {consumer-name} - nom du groupe <br><br><pre> <code class="go hljs">&gt; XPENDING mystream mygroup - + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">74170458</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569506935</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">74170458</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Nous avons maintenant les détails de chaque message: identifiant, nom de l'abonné, temps d'arrêt en millisecondes, et enfin, le nombre de tentatives de livraison.  Nous avons deux messages de Bob et ils sont inactifs pendant 74170458 millisecondes, environ 20 heures. <br><br>  Veuillez noter que personne ne nous empêche de vérifier le contenu du message simplement en utilisant <b>XRANGE</b> . <br><br><pre> <code class="go hljs">&gt; XRANGE mystream <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"orange"</span></span></code> </pre><br>  Il suffit de répéter deux fois le même identifiant dans les arguments.  Maintenant que nous avons une idée, Alice peut décider que Bob ne se remettra probablement pas après 20 heures d'inactivité, et il est temps de demander ces messages et de reprendre leur traitement à la place de Bob.  Pour ce faire, nous utilisons la commande <b>XCLAIM</b> : <br><br> <code>XCLAIM {key} {group} {consumer} {min-idle-time} {ID-1} {ID-2} ... {ID-N} <br></code> <br>  En utilisant cette commande, nous pouvons obtenir un message «étranger» qui n'a pas encore été traité en changeant le propriétaire en {consommateur}.  Cependant, nous pouvons également fournir un temps d'arrêt minimum {min-idle-time}.  Cela permet d'éviter une situation où deux clients essaient de changer simultanément le propriétaire des mêmes messages: <br><br> <code>Client 1: XCLAIM mystream mygroup Alice 3600000 1526569498055-0 <br> Clinet 2: XCLAIM mystream mygroup Lora 3600000 1526569498055-0 <br></code> <br>  Le premier client réinitialisera les temps d'arrêt et augmentera le compteur du nombre de livraisons.  Le deuxième client ne pourra donc pas le demander. <br><br><pre> <code class="go hljs">&gt; XCLAIM mystream mygroup Alice <span class="hljs-number"><span class="hljs-number">3600000</span></span> <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569498055</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"orange"</span></span></code> </pre><br>  Le message a été revendiqué avec succès par Alice, qui peut maintenant traiter le message et le reconnaître. <br><br>  D'après l'exemple ci-dessus, il est clair qu'une exécution réussie de la demande renvoie le contenu du message lui-même.  Cependant, ce n'est pas nécessaire.  L'option JUSTID peut être utilisée pour renvoyer uniquement des identificateurs de message.  Ceci est utile si vous n'êtes pas intéressé par les détails du message et souhaitez augmenter les performances du système. <br><br><h3>  Comptoir de livraison </h3><br>  Le compteur que vous observez dans la sortie <b>XPENDING</b> est le nombre de livraisons de chaque message.  Un tel compteur est incrémenté de deux manières: lorsque le message est correctement demandé via <b>XCLAIM</b> ou lorsque l'appel <b>XREADGROUP</b> est <b>utilisé</b> . <br><br>  Il est normal que certains messages soient remis plusieurs fois.  L'essentiel est qu'en conséquence, tous les messages soient traités.  Parfois, lors du traitement d'un message, il y a des problèmes dus à des dommages au message lui-même ou le traitement du message provoque une erreur dans le code du gestionnaire.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, il se peut que personne ne puisse traiter ce message. </font><font style="vertical-align: inherit;">Comme nous avons un compteur de tentatives de livraison, nous pouvons utiliser ce compteur pour détecter de telles situations. </font><font style="vertical-align: inherit;">Par conséquent, dès que le compteur de remise atteint un grand nombre spécifié par vous, il sera probablement plus raisonnable de placer un tel message dans un autre flux et d'envoyer une notification à l'administrateur système.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Statut du fil </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XINFO est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisée pour demander diverses informations sur un flux et ses groupes. </font><font style="vertical-align: inherit;">Par exemple, la forme de base de la commande est la suivante:</font></font><br><br><pre> <code class="go hljs">&gt; XINFO STREAM mystream <span class="hljs-number"><span class="hljs-number">1</span></span>) length <span class="hljs-number"><span class="hljs-number">2</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) radix-tree-keys <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) radix-tree-nodes <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>) groups <span class="hljs-number"><span class="hljs-number">8</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>) first-entry <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1524494395530</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"a"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-string"><span class="hljs-string">"b"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>) last-entry <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526569544280</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"message"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"banana"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La commande ci-dessus affiche des informations générales sur le flux spécifié. </font><font style="vertical-align: inherit;">Maintenant un exemple un peu plus complexe:</font></font><br><br><pre> <code class="go hljs">&gt; XINFO GROUPS mystream <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"mygroup"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) consumers <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) pending <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"some-other-group"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) consumers <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) pending <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La commande ci-dessus affiche des informations générales pour tous les groupes du flux spécifié </font></font><br><br><pre> <code class="go hljs">&gt; XINFO CONSUMERS mystream mygroup <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Alice"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) pending <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) idle <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">9104628</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) name <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) pending <span class="hljs-number"><span class="hljs-number">4</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>) idle <span class="hljs-number"><span class="hljs-number">6</span></span>) (integer) <span class="hljs-number"><span class="hljs-number">83841983</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La commande ci-dessus affiche des informations sur tous les abonnés du flux et du groupe spécifiés. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous oubliez la syntaxe de la commande, contactez simplement la commande pour obtenir de l'aide:</font></font><br><br><pre> <code class="go hljs">&gt; XINFO HELP <span class="hljs-number"><span class="hljs-number">1</span></span>) XINFO {subcommand} arg arg ... arg. Subcommands are: <span class="hljs-number"><span class="hljs-number">2</span></span>) CONSUMERS {key} {groupname} -- Show consumer groups of group {groupname}. <span class="hljs-number"><span class="hljs-number">3</span></span>) GROUPS {key} -- Show the stream consumer groups. <span class="hljs-number"><span class="hljs-number">4</span></span>) STREAM {key} -- Show information about the stream. <span class="hljs-number"><span class="hljs-number">5</span></span>) HELP -- Print this help.</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Limite de taille de flux </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De nombreuses applications ne souhaitent pas collecter des données dans le flux pour toujours. </font><font style="vertical-align: inherit;">Il est souvent utile d'avoir le nombre maximum de messages dans le flux. </font><font style="vertical-align: inherit;">Dans d'autres cas, il est utile de transférer tous les messages du flux vers un autre stockage persistant lorsque la taille de flux spécifiée est atteinte. </font><font style="vertical-align: inherit;">Vous pouvez limiter la taille du flux à l'aide du paramètre MAXLEN dans la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commande XADD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="go hljs">&gt; XADD mystream MAXLEN <span class="hljs-number"><span class="hljs-number">2</span></span> * value <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1526654998691</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream MAXLEN <span class="hljs-number"><span class="hljs-number">2</span></span> * value <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XADD mystream MAXLEN <span class="hljs-number"><span class="hljs-number">2</span></span> * value <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> &gt; XLEN mystream (integer) <span class="hljs-number"><span class="hljs-number">2</span></span> &gt; XRANGE mystream - + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"3"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous utilisez MAXLEN, les anciens enregistrements sont automatiquement supprimés lorsque la longueur spécifiée est atteinte, de sorte que le flux a une taille constante. </font><font style="vertical-align: inherit;">Cependant, le découpage dans ce cas ne se produit pas de la manière la plus productive dans la mémoire Redis. </font><font style="vertical-align: inherit;">La situation peut être </font><font style="vertical-align: inherit;">améliorée </font><font style="vertical-align: inherit;">comme suit: L' </font><font style="vertical-align: inherit;">argument ~ dans l'exemple ci-dessus signifie que nous n'avons pas besoin de limiter la longueur du flux à une valeur spécifique. </font><font style="vertical-align: inherit;">Dans notre exemple, cela peut être n'importe quel nombre supérieur ou égal à 1000 (par exemple, 1000, 1010 ou 1030). </font><font style="vertical-align: inherit;">Nous avons simplement indiqué explicitement que nous souhaitons que notre flux stocke au moins 1 000 enregistrements. </font><font style="vertical-align: inherit;">Cela rend le travail avec la mémoire beaucoup plus efficace dans Redis. </font><font style="vertical-align: inherit;">Il existe également une commande </font><b><font style="vertical-align: inherit;">XTRIM</font></b><font style="vertical-align: inherit;"> distincte </font><font style="vertical-align: inherit;">qui fait la même chose:</font></font><br><br> <code>XADD mystream MAXLEN ~ 1000 * ... entry fields here ... <br></code> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br> <code>&gt; XTRIM mystream MAXLEN 10 <br> <br> &gt; XTRIM mystream MAXLEN ~ 10 <br></code> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stockage et réplication persistants </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Stream est répliqué de manière asynchrone sur les nœuds esclaves et enregistré dans des fichiers tels que AOF (instantané de toutes les données) et RDB (journal de toutes les opérations d'écriture). </font><font style="vertical-align: inherit;">La réplication d'état des groupes de consommateurs est également prise en charge. </font><font style="vertical-align: inherit;">Par conséquent, si le message est dans l'état "en attente" sur le nœud maître, alors sur les nœuds esclaves, ce message aura le même état.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppression d'éléments individuels d'un flux </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour supprimer les messages, il existe une commande </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XDEL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> spéciale </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La commande obtient le nom du flux, suivi des identifiants du message à supprimer:</font></font><br><br><pre> <code class="go hljs">&gt; XRANGE mystream - + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"3"</span></span> &gt; XDEL mystream <span class="hljs-number"><span class="hljs-number">1526654999635</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> (integer) <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; XRANGE mystream - + COUNT <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-number"><span class="hljs-number">1526655000369</span></span><span class="hljs-number"><span class="hljs-number">-0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-string"><span class="hljs-string">"value"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-string"><span class="hljs-string">"3"</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque vous utilisez cette commande, vous devez tenir compte du fait qu'en fait, la mémoire ne sera pas libérée immédiatement. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flux de longueur nulle </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La différence entre les flux et les autres structures de données Redis est que lorsque d'autres structures de données n'ont plus d'éléments en elles-mêmes, comme effet secondaire, la structure de données elle-même sera supprimée de la mémoire. </font><font style="vertical-align: inherit;">Ainsi, par exemple, l'ensemble trié sera complètement supprimé lorsque l'appel ZREM supprime le dernier élément. </font><font style="vertical-align: inherit;">Au lieu de cela, les threads sont autorisés à rester en mémoire sans même avoir un seul élément à l'intérieur.</font></font><br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis Stream est idéal pour créer des courtiers de messages, des files d'attente de messages, des journaux unifiés et des systèmes de discussion qui stockent l'historique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme l'a dit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nicklaus Wirth</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , les programmes sont des algorithmes et des structures de données, et Redis vous offre déjà les deux.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456270/">https://habr.com/ru/post/fr456270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456258/index.html">Free as a wind et free as a beer traduction de «Free as in Freedom» en russe sous la licence GNU FDL 1.3</a></li>
<li><a href="../fr456260/index.html">Discussion sur l'économie équitable</a></li>
<li><a href="../fr456262/index.html">Radio définie par logiciel - comment ça marche? Partie 9</a></li>
<li><a href="../fr456264/index.html">Créez des fichiers binaires Android à l'aide de la source et d'Android NDK. Nous pompons l'utilitaire screencap</a></li>
<li><a href="../fr456266/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 302 (du 10 au 16 juin)</a></li>
<li><a href="../fr456272/index.html">Qu'est-ce qu'Android Lint et comment vous aide-t-il à écrire du code pris en charge?</a></li>
<li><a href="../fr456274/index.html">Psychologues: les robots sexuels entraîneront une augmentation du nombre de personnes sans couple qui n'ont pas besoin de relations avec d'autres personnes</a></li>
<li><a href="../fr456276/index.html">Qu'est-ce que l'information?</a></li>
<li><a href="../fr456280/index.html">Débuter avec stm32 ou ne pas répéter mes erreurs</a></li>
<li><a href="../fr456282/index.html">Graphiques multidimensionnels en Python - de trois dimensions à six dimensions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>