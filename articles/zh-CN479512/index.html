<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚼 🙍🏿 🎁 PostgreSQL-4中的MVCC。 快照 ✍️ 💷 👩🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在讨论了隔离问题并对低级数据结构进行了论述之后，上次我们探索行版本并观察了不同的操作如何更改元组标头字段。 

 现在，我们将研究如何从元组中获取一致的数据快照。 

 什么是数据快照？ 
 数据页实际上可以包含同一行的多个版本。 但是每笔交易都只能看到每一行的一个（或没有）版本，以便所有交易在特定...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL-4中的MVCC。 快照</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479512/"> 在讨论了<a href="https://habr.com/ru/company/postgrespro/blog/467437/">隔离</a>问题并对<a href="https://habr.com/ru/company/postgrespro/blog/469087/">低级数据结构</a>进行了论述之后，上次我们探索<a href="https://habr.com/ru/company/postgrespro/blog/477648/">行版本</a>并观察了不同的操作如何更改元组标头字段。 <br><br> 现在，我们将研究如何从元组中获取一致的数据快照。 <br><br><h1> 什么是数据快照？ </h1><br> 数据页实际上可以包含同一行的多个版本。 但是每笔交易都只能看到每一行的一个（或没有）版本，以便所有交易在特定时间点上构成数据的一致图片（按照ACID的意义）。 <br><br>  PosgreSQL中的隔离基于快照：每个事务都使用其自己的数据快照，该快照“包含”在创建快照之前提交的数据，并且不“包含”在该时刻尚未提交的数据。 我们<a href="https://habr.com/ru/company/postgrespro/blog/467437/">已经看到</a> ，尽管最终的隔离看起来比标准要求的严格，但仍然存在异常。 <br><a name="habracut"></a><br> 在“读取已提交”隔离级别，将在每个事务语句的开头创建一个快照。 在执行语句时，此快照处于活动状态。 在图中，快照创建的时刻（我们记得，它由事务ID决定）以蓝色显示。 <br><br><img src="https://habrastorage.org/webt/jy/i7/bt/jyi7btkmmha--gyzq7giozodsze.png"><br><br> 在“可重复读取”和“可序列化”级别上，快照在第一个事务语句的开始处创建一次。 这样的快照在事务结束之前一直保持活动状态。 <br><br><img src="https://habrastorage.org/webt/i5/gq/lt/i5gqltpae5nzbrwjree45wfl8_a.png"><br><br><h1> 快照中元组的可见性 </h1><br><h2> 可见性规则 </h2><br> 快照当然不是所有必要元组的物理副本。 快照实际上由多个数字指定，并且快照中元组的可见性由规则确定。 <br><br> 元组在快照中是否可见取决于标头中的两个字段，即<code>xmin</code>和<code>xmax</code> ，即创建和删除该元组的事务的ID。 这样的间隔不会重叠，因此，每个快照中的一行代表的版本不超过一个。 <br><br> 确切的可见性规则非常复杂，并考虑了许多不同的情况和极端情况。 <br><blockquote> 您可以通过查看src / backend / utils / time / tqual.c（在版本12中，将检查移至src / backend / access / heap / heapam_visibility.c）轻松地确保这一点。 <br></blockquote><br> 为简化起见，我们可以说一个元组在快照中可见，而<code>xmin</code>事务所做的更改是可见的，而<code>xmax</code>事务所做的更改则不可见（换句话说，已经创建了元组，但是尚不清楚是否已删除它）。 <br><br> 关于事务，无论是创建快照的事务（它确实看到自己尚未提交的更改）还是在快照创建之前就提交了事务，快照中的更改都是可见的。 <br><br> 我们可以按段（从开始时间到提交时间）以图形方式表示事务： <br><br><img src="https://habrastorage.org/webt/or/nv/ir/ornvirvfxjcpp0djg6-1e03vffw.png"><br><br> 在这里： <br><br><ul><li> 事务2的更改将在创建快照之前完成，因此将可见。 </li><li> 事务1的更改将不可见，因为它在创建快照时处于活动状态。 </li><li> 事务3的更改将不可见，因为它是在创建快照后开始的（无论它是否完成）。 </li></ul><br> 不幸的是，系统没有意识到事务的提交时间。 仅知道其开始时间（由事务ID确定并在上图中用虚线标记），但是完成的事件未写入任何地方。 <br><br> 我们所能做的就是在创建快照时找出事务的<em>当前</em>状态。 该信息在服务器的共享内存中的ProcArray结构中可用，该结构包含所有活动会话及其事务的列表。 <br><br> 但是我们将无法确定事后快照创建时某个事务是否处于活动状态。 因此，快照必须存储所有当前活动事务的列表。 <br><br> 从上面可以看出，在PostgreSQL中， <em>即使</em>表页面中所有必需的元组都可用， <em>也</em>无法创建快照来显示在特定时间后向一致的数据。 经常会引起一个问题，为什么PostgreSQL缺乏追溯（或时间；或闪回，如Oracle称呼它们）查询-这就是原因之一。 <br><blockquote> 有点可笑的是，此功能最初可用，但随后已从DBMS中删除。 您可以在<a href="https://arxiv.org/pdf/1901.01973.pdf">Joseph M. Hellerstein</a>的<a href="https://arxiv.org/pdf/1901.01973.pdf">文章中</a>阅读有关此<a href="https://arxiv.org/pdf/1901.01973.pdf">内容的信息</a> 。 <br></blockquote><br> 因此，快照由几个参数确定： <br><br><ul><li> 创建快照后，更确切地说，是下一个事务的ID，但在系统中不可用（ <code>snapshot.xmax</code> ）。 </li><li> 创建<code>snapshot.xip</code>的活动（进行中）事务列表（ <code>snapshot.xip</code> ）。 </li></ul><br> 为了方便和优化，还将存储最早活动事务的ID（ <code>snapshot.xmin</code> ）。 该值具有重要意义，下面将进行讨论。 <br><br> 快照还存储了一些其他参数，但是这些参数对我们来说并不重要。 <br><br><img src="https://habrastorage.org/webt/5z/dx/cf/5zdxcfxgsqzukzjqgyetvvahzru.png"><br><br><h2> 例子 </h2><br> 为了了解快照如何确定可见性，让我们通过三个事务重现上面的示例。 该表将具有三行，其中： <br><br><ul><li> 第一个是由在快照创建之前开始但在快照创建之后完成的事务添加的。 </li><li> 第二个是通过在快照创建之前开始并完成的事务添加的。 </li><li> 第三个是在创建快照后添加的。 </li></ul><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts;</code> </pre><br> 第一笔交易（尚未完成）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">=&gt; SELECT txid_current(); txid_current -------------- 3695 (1 row)</code> </pre><br> 第二笔交易（在创建快照之前完成）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3696 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 在另一个会话的事务中创建快照。 <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br> 创建快照后提交第一个事务： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 第三笔交易（在创建快照后出现）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>); | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs">| txid_current | -------------- | 3697 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 显然，快照中仅可见一行： <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">|| xmin | xmax | id | number | client | amount || ------+------+----+--------+--------+-------- || 3696 | 0 | 2 | 2001 | bob | 100.00 || (1 row)</code> </pre><br> 问题是Postgres如何理解这一点。 <br><br> 全部由快照确定。 让我们看一下： <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_snapshot();</code> </pre><pre> <code class="plaintext hljs">|| txid_current_snapshot || ----------------------- || 3695:3697:3695 || (1 row)</code> </pre><br> 这里列出了<code>snapshot.xmin</code> ， <code>snapshot.xmax</code>和<code>snapshot.xip</code> ，以冒号分隔（在这种情况下， <code>snapshot.xip</code>是一个数字，但通常是一个列表）。 <br><br> 根据上述规则，在快照中，那些ID为<code>xid</code>的事务所做的更改必须是可见的，使得<code>snapshot.xmin &lt;= xid &lt; snapshot.xmax</code>除外。 让我们看一下所有表行（在新快照中）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | number | client | amount ------+------+----+--------+--------+--------- 3695 | 0 | 1 | 1001 | alice | 1000.00 3696 | 0 | 2 | 2001 | bob | 100.00 3697 | 0 | 3 | 2002 | bob | 900.00 (3 rows)</code> </pre><br> 第一行不可见：它是由活动事务（ <code>xip</code> ）列表上的事务创建的。 <br> 第二行可见：它是由快照范围内的事务创建的。 <br> 第三行不可见：它是由快照范围之外的事务创建的。 <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1> 交易本身的变化 </h1><br> 确定交易本身变更的可见性会使情况复杂化。 在这种情况下，可能仅需要查看部分此类更改。 例如：在任何隔离级别，在某个时间点打开的游标一定不能看到以后所做的更改。 <br><br> 为此，元组标头具有一个特殊字段（在<code>cmin</code>和<code>cmax</code>伪列中表示），该字段显示事务内部的订单号。  <code>cmin</code>是要插入的数字， <code>cmin</code>是要删除的数字，但是为了节省元组头中的空间，这实际上是一个字段，而不是两个不同的字段。 假定事务很少插入和删除同一行。 <br><br> 但是，如果确实发生这种情况， <code>combocid</code>在同一字段中插入一个特殊的组合命令id（ <code>combocid</code> ），并且后端进程会记住该<code>cmin</code>的实际<code>cmin</code>和<code>combocid</code> 。 但这完全是异国情调。 <br><br> 这是一个简单的例子。 让我们开始一个事务并在表中添加一行： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3698 (1 row)</code> </pre><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3001</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>);</code> </pre><br> 让我们输出表的内容以及<code>cmin</code>字段（但仅适用于事务添加的行-对于其他行则没有意义）： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br> 现在，我们为查询打开一个游标，该查询返回表中的行数。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><br> 然后，我们添加另一行： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts(id, number, client, amount) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3002</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>);</code> </pre><br> 查询返回4-打开游标后添加的行未进入数据快照： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> count ------- 4 (1 row)</code> </pre><br> 怎么了 因为快照仅考虑<code>cmin &lt; 1</code>元组。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> xmin = <span class="hljs-number"><span class="hljs-number">3698</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> cmin <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> cmin, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs"> xmin | cmin | id | number | client | amount ------+------+----+--------+---------+--------- 3695 | | 1 | 1001 | alice | 1000.00 3696 | | 2 | 2001 | bob | 100.00 3697 | | 3 | 2002 | bob | 900.00 3698 | 0 | 4 | 3001 | charlie | 100.00 3698 | 1 | 5 | 3002 | charlie | 200.00 (5 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h1> 活动范围 </h1><br> 最早的活动事务的ID（ <code>snapshot.xmin</code> ）具有重要意义：它确定事务的“事件范围”。 也就是说，超出其范围，该事务始终只能看到最新的行版本。 <br><br> 实际上，仅当尚未完成的事务创建了最新的（死）行版本时，才需要看到该行版本，因此尚不可见。 但是，毫无疑问，所有“超越地平线”的交易都已经完成。 <br><br><img src="https://habrastorage.org/webt/a6/la/gb/a6lagbu1ycmf-5poirlhd0cpyt8.png"><br><br> 您可以在系统目录中看到事务范围： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br> 我们还可以在数据库级别定义范围。 为此，我们需要获取所有活动快照并在其中找到最旧的<code>xmin</code> 。 它将定义范围，超过该范围，数据库中的死元组将永远对任何事务都不可见。  <em>这样的元组可以被抽走</em> -这就是为什么从实际的角度来看，地平线的概念如此重要的原因。 <br><br> 如果某个事务长时间保存快照，那么它也将保存数据库范围。 此外，即使事务本身不保存快照，仅存在未完成的事务也将保留视野。 <br><br> 这意味着无法清除DB中的死元组。 此外，“长期”事务有可能根本不会与其他事务相交，但是这并不重要，因为所有事务共享一个数据库范围。 <br><br> 如果现在我们使一个段代表快照（从<code>snapshot.xmin</code>到<code>snapshot.xmax</code> ）而不是事务，则可以将情况可视化如下： <br><br><img src="https://habrastorage.org/webt/lf/-k/3a/lf-k3azujmyjrddg-6whmoktujc.png"><br><br> 在此图中，最低的快照与未完成的事务有关，在其他快照中， <code>snapshot.xmin</code>不能大于事务ID。 <br><br> 在我们的示例中，事务是从“读取已提交”隔离级别开始的。 即使它没有任何活动的数据快照，它也会继续保持发展： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">1.00</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3699 (1 row)</code> </pre><br> 并且仅在事务完成之后，地平线才向前移动，这可以清除死元组： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> backend_xmin -------------- 3700 (1 row)</code> </pre><br> 如果所描述的情况确实导致问题，并且无法在应用程序级别上解决，则从9.6版开始可以使用两个参数： <br><br><ul><li>  <em><code>old_snapshot_threshold</code></em>确定快照的最大生存期。 这段时间过后，服务器将有资格清理死元组，并且如果“长期播放”事务仍然需要它们，它将收到“快照太旧”错误。 </li><li>  <em><code>idle_in_transaction_session_timeout</code></em>确定空闲事务的最大生存期。 经过这段时间后，事务中止。 </li></ul><br><h1> 快照导出 </h1><br> 有时会出现必须保证多个并发事务才能看到相同数据的情况。 一个示例是<code>pg_dump</code>实用程序，它可以在并行模式下工作：所有工作进程都必须以相同的状态查看数据库，以使备份副本保持一致。 <br><br> 当然，我们不能依靠这样的信念，即仅仅因为交易是“同时”开始的，它们就能看到相同的数据。 为此，可以导出和导入快照。 <br><br>  <code>pg_export_snapshot</code>函数返回快照ID，可以将其传递给另一个事务（使用DBMS外部的工具）。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; <span class="hljs-comment"><span class="hljs-comment">-- any query</span></span></code> </pre><pre> <code class="plaintext hljs"> count ------- 3 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_export_snapshot();</code> </pre><pre> <code class="plaintext hljs"> pg_export_snapshot --------------------- 00000004-00000E7B-1 (1 row)</code> </pre><br> 另一个事务可以在执行第一个查询之前使用SET TRANSACTION SNAPSHOT命令导入快照。 由于在“读取已提交”级别，语句将使用其自己的快照，因此还应该在指定“可重复读取”或“可序列化”隔离级别之前。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SNAPSHOT</span></span> <span class="hljs-string"><span class="hljs-string">'00000004-00000E7B-1'</span></span>;</code> </pre><br> 现在，第二个事务将与第一个事务的快照配合使用，因此，请参见三行（而不是零行）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><br> 导出快照的生存期与导出事务的生存期相同。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">继续阅读</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479512/">https://habr.com/ru/post/zh-CN479512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479498/index.html">线性时间如何以O（n²）变为Windows</a></li>
<li><a href="../zh-CN479502/index.html">如何度过地球历史上最严峻的冰河时代？</a></li>
<li><a href="../zh-CN479504/index.html">构建基于Raspberry Pi的RDP瘦客户端</a></li>
<li><a href="../zh-CN479508/index.html">PostgreSQL反模式：有害的JOIN和OR</a></li>
<li><a href="../zh-CN479510/index.html">PocketBook X评论-配备E Ink Carta Mobius屏幕和金属外壳的10.3英寸巨大阅读器</a></li>
<li><a href="../zh-CN479514/index.html">设计隐私和默认隐私（设计数据保护和GDPR默认隐私）</a></li>
<li><a href="../zh-CN479516/index.html">软件中的熵是什么以及如何对其进行管理？</a></li>
<li><a href="../zh-CN479518/index.html">远程团队之间的交流是我们的经验</a></li>
<li><a href="../zh-CN479522/index.html">出版者彼得。 冬季特卖</a></li>
<li><a href="../zh-CN479524/index.html">主动恢复服务或Innopolis一项工业项目的历史</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>