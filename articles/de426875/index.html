<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👳🏿 🌟 🤾🏿 Tacticool Mobile Online Shooter Meta Server-Architektur ✊ 🙇 📖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein weiteres Gespräch mit Pixonic DevGAMM Talks - diesmal von unseren Kollegen bei PanzerDog. Der leitende Software-Ingenieur des Unternehmens, Pavel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tacticool Mobile Online Shooter Meta Server-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/426875/">  Ein weiteres Gespräch mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixonic DevGAMM Talks</a> - diesmal von unseren Kollegen bei PanzerDog.  Der leitende Software-Ingenieur des Unternehmens, Pavel Platto, zerlegte den Metaserver des Spiels mit einer serviceorientierten Architektur und erklärte, welche Lösungen und Technologien ausgewählt wurden, welche und wie sie skaliert wurden und mit welchen Schwierigkeiten sie konfrontiert waren.  Der Text des Berichts, Folien und Links zu anderen Reden aus dem Mitap, wie immer, unter dem Schnitt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JcuOHUzXXHw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Zunächst möchte ich einen kleinen Trailer für unser Spiel demonstrieren: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yIpGvbbMCn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>  Der Bericht besteht aus 3 Teilen.  Im ersten werde ich darüber sprechen, welche Technologien wir ausgewählt haben und warum, im zweiten - wie unser Metaserver angeordnet ist, und im dritten werde ich über die verschiedenen unterstützenden Infrastrukturen sprechen, die wir verwenden, und wie wir das Update ohne Ausfallzeiten implementiert haben . <br><br><img src="https://habrastorage.org/webt/-s/fg/tz/-sfgtzhre4ij6b0n9-b_r0cako4.png"><br>  <i>Technologischer Stapel</i> <br><br>  Der Metaserver wird auf Amazon gehostet und in Elixir geschrieben.  Es ist eine funktionale Programmiersprache mit einem Akteurmodell der Berechnung.  Da wir keine Ops haben, sind Programmierer an der Operation beteiligt, und der größte Teil der Infrastruktur wird mithilfe der HashiCorp Terraform als Code beschrieben. <br><br>  Tacticool befindet sich derzeit in der offenen Beta, der Metaserver befindet sich seit etwas mehr als einem Jahr in der Entwicklung und ist seit fast einem Jahr in Betrieb.  Mal sehen, wie alles begann. <br><br><img src="https://habrastorage.org/webt/zs/a0/fa/zsa0favmdahf0gdsnt0-goxhrnq.png"><br><br>  Als ich in das Unternehmen eintrat, hatten wir bereits grundlegende Funktionen als Monolith auf einem C / C ++ - Mix und PostageSQL-Speicher implementiert.  Diese Implementierung hatte bestimmte Probleme. <br><br>  Erstens gab es aufgrund des niedrigen C-Spiegels einige schwer fassbare Fehler.  Bei einigen Spielern hängt das Matchmaking beispielsweise aufgrund einer falschen Nullstellung des Arrays vor seiner Wiederverwendung fest.  Natürlich war es ziemlich schwierig, die Beziehung zwischen diesen beiden Ereignissen zu finden.  Und da der Status mehrerer Threads im Code allgemein geändert wurde, waren die Race-Bedingungen nicht ohne. <br><br>  Die parallele Verarbeitung einer großen Anzahl von Aufgaben kam ebenfalls nicht in Frage, da der Server zu Beginn von etwa 10 Arbeitsprozessen gestartet wurde, die durch Abfragen an Amazon oder die Datenbank blockiert wurden.  Und selbst wenn wir diese Blockierungsanforderungen vergessen, begann der Dienst bei ein paar Hundert Verbindungen zusammenzubrechen, die außer Ping keine Operationen ausführten.  Außerdem konnte der Dienst nicht horizontal skaliert werden. <br><br>  Nachdem wir einige Wochen damit verbracht hatten, die kritischsten Fehler zu finden und zu beheben, entschieden wir, dass es einfacher war, alles von Grund auf neu zu schreiben, als zu versuchen, alle Mängel der aktuellen Lösung zu beheben. <br><br>  Wenn Sie bei Null anfangen, ist es sinnvoll, eine Sprache auszuwählen, mit der Sie einige der vorherigen Probleme vermeiden können.  Wir hatten drei Kandidaten: <br><br><ul><li>  C #; </li><li>  Geh; </li><li>  Elixier. </li></ul><br><img src="https://habrastorage.org/webt/_f/vt/q5/_fvtq51jwvlo2uuquqy-4vwsnhw.png"><br><br>  C # war auf der Bekanntschaftsliste, as  Der Client und der Spieleserver sind in Unity geschrieben, und die meiste Erfahrung im Team wurde mit dieser Programmiersprache gemacht.  Go und Elixir wurden in Betracht gezogen, da dies moderne und recht beliebte Sprachen sind, die für die Entwicklung von Serveranwendungen entwickelt wurden. <br><br>  Die Probleme der vorherigen Iteration haben uns geholfen, die Kriterien für die Bewertung von Kandidaten zu bestimmen. <br><br>  Das erste Kriterium war die Bequemlichkeit der Arbeit mit asynchronen Operationen.  In C # wurde beim ersten Versuch keine bequeme Arbeit mit asynchronen Operationen angezeigt.  Dies führte dazu, dass wir einen „Zoo“ von Lösungen haben, die meiner Meinung nach immer noch ein wenig auf der Seite stehen.  In Go und Elixir wurde dieses Problem beim Entwerfen dieser Sprachen berücksichtigt. Beide verwenden leichtgewichtige Threads (in Go sind sie Goroutinen, in Elixir Prozesse).  Diese Streams haben einen viel geringeren Overhead als System-Threads, und da wir sie in Zehntausenden und Hunderttausenden erstellen können, tut es uns nicht leid, sie zu blockieren. <br><br>  Das zweite Kriterium war die Fähigkeit, mit wettbewerbsfähigen Prozessen zu arbeiten.  C # out of the box bietet nichts anderes als Thread-Pools und gemeinsam genutzten Speicher, auf den der Zugriff mithilfe verschiedener Synchronisationsprimitive geschützt werden muss.  Go hat ein weniger fehleranfälliges Modell in Form von Goroutinen und Kanälen.  Elixir hingegen bietet ein Schauspieler-Modell ohne Shared Memory mit Messaging.  Der Mangel an gemeinsam genutztem Speicher ermöglichte es uns, Technologien zu implementieren, die für eine wettbewerbsfähige Ausführungsumgebung zur Laufzeit nützlich sind, wie z. B. ehrliches Push-out-Multitasking und Garbage Collection ohne Unterbrechungen in der Welt. <br><br>  Das dritte Kriterium war die Verfügbarkeit von Tools für die Arbeit mit unveränderlichen Datentypen.  Alle meine Entwicklungserfahrungen haben gezeigt, dass ein ziemlich großer Teil der Fehler mit falschen Datenänderungen verbunden ist.  Eine Lösung dafür gibt es schon vor langer Zeit - unveränderliche Datentypen.  In C # können diese Datentypen erstellt werden, jedoch auf Kosten einer Tonne Boilerplate.  In Go ist dies überhaupt nicht möglich.  Und in Elixir sind alle Datentypen unveränderlich. <br><br>  Und das letzte Kriterium war die Anzahl der Spezialisten.  Hier sind die Ergebnisse offensichtlich.  Am Ende haben wir uns für Elixir entschieden. <br><br>  Mit der Wahl des Hostings war alles viel einfacher.  Wir haben bereits Spieleserver in Amazon GameLift gehostet. Darüber hinaus bietet Amazon eine große Anzahl von Diensten an, mit denen wir die Entwicklungszeit verkürzen können. <br><br><img src="https://habrastorage.org/webt/f2/zm/jn/f2zmjnyjejb3ffw0vhs69hvqjoi.png"><br><br>  Wir haben uns vollständig der Cloud ergeben und stellen selbst keine Lösungen von Drittanbietern bereit - Datenbanken, Nachrichtenwarteschlangen - all dies wird von Amazon für uns verwaltet.  Meiner Meinung nach ist dies die einzige Lösung für ein kleines Team, das ein Online-Spiel entwickeln möchte, und nicht die Infrastruktur dafür. <br><br>  Wir haben die Auswahl der Technologien herausgefunden. Kommen wir zur Funktionsweise des Metaservers. <br><br><img src="https://habrastorage.org/webt/q1/jy/m8/q1jym8itnftw6e3tqyvsbqh-uva.png"><br><br>  Im Allgemeinen: Clients stellen über Web-Socket-Verbindungen eine Verbindung zum Load Balancer von Amazon her.  Der Balancer streut diese Verbindungen zwischen mehreren Front-End-Instanzen, das Front-End sendet Client-Anforderungen an Back-Ends.  Das Front-End und das Back-End kommunizieren jedoch indirekt über Nachrichtenwarteschlangen.  Für jeden Nachrichtentyp gibt es eine separate Warteschlange, und das Frontend bestimmt anhand des Nachrichtentyps, wo es geschrieben werden soll, und die Backends hören diese Warteschlangen ab. <br><br>  Damit das Backend eine Antwort auf die Anfrage an den Client oder eine Art Ereignis senden kann, verfügt jedes Frontend über eine separate Warteschlange (speziell dafür zugewiesen).  Bei jeder Anforderung erhält das Backend eine Frontend-ID, um zu bestimmen, in welche Warteschlange die Antwort geschrieben werden soll.  Wenn er ein Ereignis senden muss, ruft er die Datenbank auf, um herauszufinden, mit welcher Frontend-Instanz der Client verbunden ist. <br><br>  Kommen wir mit dem allgemeinen Schema zu den Details. <br><br><img src="https://habrastorage.org/webt/xe/rr/u-/xerru-5vn3tx-dwqbylflu18mrm.png"><br><br>  Zunächst werde ich auf einige Funktionen der Client-Server-Interaktion eingehen.  Wir verwenden unser Binärprotokoll, weil es sehr effizient ist und es ermöglicht, Verkehr zu sparen.  Zweitens sendet der Server bei Vorgängen mit einem Konto, das es ändert, diese Änderungen nicht an den Client, sondern an die vollständige (aktualisierte) Version dieses Kontos.  Dies ist etwas weniger effizient, nimmt aber ohnehin nicht viel Platz ein und vereinfacht unser Leben sowohl auf dem Client als auch auf dem Server erheblich.  Außerdem stellt das Frontend sicher, dass der Client nicht mehr als eine Anforderung gleichzeitig ausführt.  Auf diese Weise können Sie Fehler auf dem Client erkennen, wenn er beispielsweise zu einem anderen Bildschirm wechselt, bevor der Player das Ergebnis der vorherigen Operation sieht. <br><br>  Nun ein wenig darüber, wie das Frontend angeordnet ist. <br><br><img src="https://habrastorage.org/webt/te/-k/ff/te-kffgzvatzj_3tjwcus5lvpdk.png"><br><br>  Ein Frontend ist im Wesentlichen ein Webserver, der auf Web-Socket-Verbindungen wartet.  Für jede Sitzung werden zwei Prozesse erstellt.  Der erste Prozess dient der Web-Socket-Verbindung selbst, und der zweite ist eine Zustandsmaschine, die den aktuellen Status des Clients beschreibt.  Basierend auf diesem Status wird die Gültigkeit von Anforderungen vom Client bestimmt.  Beispielsweise können fast alle Anforderungen erst abgeschlossen werden, wenn die Autorisierung abgeschlossen ist.  Da es neben diesen Sitzungen keinen Status im Frontend gibt, ist es sehr einfach, neue Frontend-Instanzen hinzuzufügen, aber es ist etwas schwieriger, die alten zu löschen.  Vor der Deinstallation müssen Sie alle Clients ihre aktuellen Anforderungen ausführen lassen und sie bitten, die Verbindung zu einer anderen Instanz wiederherzustellen. <br><br>  Nun dazu, wie das Backend aussieht.  Derzeit besteht es aus fünf Diensten. <br><br><img src="https://habrastorage.org/webt/qh/cj/x4/qhcjx4ckmzg8lcqpriouhi8rnee.png"><br><br>  Der erste befasst sich mit allem, was mit Konten zu tun hat - von Einkäufen für Spielwährung bis zum Abschluss von Quests.  Der zweite funktioniert mit allem, was mit Spielen zu tun hat - er interagiert direkt mit GameLift und Spieleservern.  Der dritte Service ist das Einkaufen für echtes Geld.  Der vierte und fünfte sind für soziale Interaktionen verantwortlich - einer für Freunde, der andere für ein Partyspiel. <br><br>  Jeder der Backend-Services sieht aus architektonischer Sicht absolut identisch aus.  Sie sind eine Reihe von Pipelines, von denen jede einen Nachrichtentyp verarbeitet.  Die Pipeline besteht aus zwei Elementen: Produzent und Konsument. <br><br><img src="https://habrastorage.org/webt/ym/di/eh/ymdiehrcngon3im1my2d8nbbgsk.png"><br><br>  Die einzige Aufgabe des Produzenten besteht darin, Nachrichten aus der Warteschlange zu lesen.  Daher wird es in einer vollständig allgemeinen Form implementiert, und für jede Pipeline müssen wir nur angeben, wie viele Hersteller vorhanden sind, aus welcher Warteschlange gelesen werden soll und wie viele Verbraucher jeder Hersteller bedienen wird.  Consumer hingegen wird für jede Pipeline separat implementiert und ist ein Modul mit der einzigen obligatorischen Funktion, die eine Nachricht akzeptiert, alle erforderlichen Arbeiten ausführt und eine Liste von Nachrichten zurückgibt, die an andere Dienste an den Client oder an den Spieleserver gesendet werden müssen.  Der Produzent setzt auch Gegendruck ein, so dass bei einem starken Anstieg der Anzahl der Nachrichten keine Überlastung auftritt, und fordert nicht mehr Nachrichten an, als er freie Verbraucher hat. <br><br>  Backend-Services enthalten keinen Status, daher können wir alte Instanzen problemlos hinzufügen und entfernen.  Vor dem Löschen müssen Sie die Produzenten lediglich auffordern, keine neuen Nachrichten mehr zu lesen, und den Verbrauchern ein wenig Zeit geben, um die Verarbeitung aktiver Nachrichten abzuschließen. <br><br>  Wie erfolgt die Interaktion mit GameLift?  GameLift besteht aus mehreren Komponenten.  Von denen, die wir verwenden, ist dies ein FlexMatch-Matchmaker, eine Platzierungswarteschlange, die bestimmt, in welcher bestimmten Region eine Spielsitzung mit diesen Spielern stattfinden soll, und die Flotten selbst, die aus Spielservern bestehen. <br><br><img src="https://habrastorage.org/webt/c8/ge/5h/c8ge5huiowlmu5q7b9izd4sew4y.png"><br><br>  Wie läuft diese Interaktion?  Meta kommuniziert nur direkt mit dem Matchmaker und sendet ihm Anfragen, um das Match zu finden.  Und er benachrichtigt das Meta aller Ereignisse während des Matchmaking über dieselben Nachrichtenwarteschlangen.  Und sobald er eine geeignete Gruppe von Spielern findet, um das Spiel zu starten, sendet er eine Anfrage an die Platzierungswarteschlange, die wiederum einen Server für sie auswählt. <br><br>  Die Interaktion von Meta mit dem Spieleserver ist äußerst einfach.  Der Spielserver benötigt Informationen zu Konten, Bots und einer Karte, und das Meta sendet alle diese Informationen in einer einzigen Nachricht an die Warteschlange, die speziell für dieses Spiel erstellt wurde. <br><br><img src="https://habrastorage.org/webt/vv/zo/y5/vvzoy5ycub5em-qiovlo911pg0k.png"><br><br>  Nach der Aktivierung hört der Spieleserver diese Warteschlange ab und empfängt alle benötigten Daten.  Am Ende des Spiels sendet er seine Ergebnisse an die allgemeine Warteschlange, die das Meta abhört. <br><br>  Kommen wir nun zu der zusätzlichen Infrastruktur, die wir verwenden. <br><br><img src="https://habrastorage.org/webt/l-/st/nu/l-stnuybsqrbk_be4fhlgrsdgpa.png"><br><br>  Das Bereitstellen von Diensten ist recht einfach.  Sie arbeiten alle in Docker-Containern, und wir verwenden Amazon ECS für die Orchestrierung.  Es ist viel einfacher als Kubernetes, natürlich weniger ausgefeilt, aber es führt die Aufgaben aus, die wir von ihm benötigen.  Nämlich: Skalierungsdienste und fortlaufende Releases, wenn wir eine Art Bugfix eingeben müssen. <br><br>  Und der letzte Service, den wir auch nutzen, ist AWS Fargate.  Dies erspart uns die unabhängige Verwaltung des Maschinenclusters, auf dem unsere Docker-Container ausgeführt werden. <br><br><img src="https://habrastorage.org/webt/q1/xl/8m/q1xl8mppdukmbjoezzm6pzlbl9k.png"><br><br>  Als Hauptspeicher verwenden wir DynamoDB.  Zunächst haben wir uns dafür entschieden, weil es sehr einfach zu bedienen und zu skalieren ist.  Wir verwenden Redis auch als zusätzlichen Speicher über den von Amazon ElasiCache verwalteten Dienst.  Wir verwenden es für die globale Spielerbewertungsaufgabe und zum Zwischenspeichern grundlegender Kontoinformationen in Situationen, in denen wir Daten zu Hunderten von Spielkonten sofort an den Client zurückgeben müssen (z. B. in derselben Bewertungstabelle oder in der Freundesliste). <br><br>  Zum Speichern von Konfigurationen, Metaspielmechaniken, Beschreibungen von Waffen, Helden usw.  Wir verwenden eine JSON-Datei, die wir an die Images der Dienste anhängen, die sie benötigen.  Weil es für uns viel einfacher ist, eine neue Version des Dienstes mit aktualisierten Daten bereitzustellen (wenn ein Fehler festgestellt wird), als eine Entscheidung zu treffen, die diese Daten zur Laufzeit dynamisch von einem externen Speicher aktualisiert. <br><br>  Für die Protokollierung und Überwachung verwenden wir einige Dienste. <br><br><img src="https://habrastorage.org/webt/lh/ub/3u/lhub3urulc1urcn8omuxprcn0rg.png"><br><br>  Beginnen wir mit CloudWatch.  Dies ist ein Überwachungsdienst, bei dem sich Metriken aller Amazon-Dienste versammeln.  Aus diesem Grund haben wir uns entschlossen, die Metriken auch von unserem Metaserver dorthin zu senden.  Für die Protokollierung verwenden wir einen gemeinsamen Ansatz sowohl auf dem Client als auch auf dem Spieleserver und auf dem Metaserver.  Wir senden alle Protokolle an den Amazonas-Dienst Kinesis Firehose, der sie wiederum an Elasticseach und S3 überträgt. <br><br>  In Elasticseach speichern wir nur relativ aktuelle Daten und suchen mithilfe von Kibana nach Fehlern, lösen einige der Aufgaben der Spielanalyse und erstellen betriebliche Dashboards, beispielsweise mit einem CCU-Zeitplan und der Anzahl neuer Installationen.  S3 enthält alle historischen Daten und wir verwenden sie über den Athena-Dienst, der zusätzlich zu den Daten in S3 eine SQL-Schnittstelle bereitstellt. <br><br>  Nun ein wenig darüber, wie wir Terraform verwenden. <br><br><img src="https://habrastorage.org/webt/o8/jj/-q/o8jj-qfa1hsyq1qposebwbof4dc.png"><br><br>  Terraform ist ein Tool, mit dem Sie die Infrastruktur deklarativ beschreiben können. Wenn sich die Beschreibung ändert, werden automatisch die Maßnahmen festgelegt, die Sie ergreifen müssen, um Ihre Infrastruktur auf ein aktualisiertes Erscheinungsbild zu bringen.  Mit einer einzigen Beschreibung erhalten wir eine nahezu identische Umgebung für Inszenierung und Produktion.  Außerdem sind diese Umgebungen vollständig isoliert, da sie unter verschiedenen Konten bereitgestellt werden.  Der einzige wesentliche Nachteil von Terraform ist für uns die unvollständige Unterstützung von GameLift. <br><br>  Ich werde auch darüber sprechen, wie wir das Update ohne Ausfallzeiten implementiert haben. <br><br><img src="https://habrastorage.org/webt/_l/ge/va/_lgevakn50wndn5tvfipi1_ujam.png"><br><br>  Wenn wir Updates veröffentlichen, erstellen wir eine Kopie der meisten Ressourcen: Dienste, Nachrichtenwarteschlangen, einige Bezeichnungen in der Datenbank.  Und diejenigen Spieler, die die neue Version des Spiels herunterladen, werden eine Verbindung zu diesem aktualisierten Cluster herstellen.  Spieler, die noch nicht aktualisiert wurden, können jedoch noch einige Zeit mit der alten Version des Spiels spielen und eine Verbindung zum alten Cluster herstellen. <br><br>  Wie wir es umgesetzt haben.  Verwenden Sie zunächst die Modul-Engine in Terraform.  Wir haben ein Modul zugewiesen, in dem wir alle versionierten Ressourcen beschrieben haben.  Und diese Module können mehrmals mit unterschiedlichen Parametern importiert werden.  Dementsprechend importieren wir für jede Version dieses Modul unter Angabe der Nummer dieser Version.  Das Fehlen eines Schemas in DynamoDB hat uns auch geholfen, wodurch es möglich ist, Datenmigrationen nicht während des Updates durchzuführen, sondern sie für jedes Konto zu verschieben, bis sich sein Besitzer bei der neuen Version des Spiels anmeldet.  Und im Balancer geben wir einfach für jede Version der Regel an, damit sie weiß, wohin Spieler mit unterschiedlichen Versionen weitergeleitet werden sollen. <br><br>  Zum Schluss noch ein paar Dinge, die wir gelernt haben.  Zunächst muss die Konfiguration der gesamten Infrastruktur automatisiert werden.  Das heißt,  Wir haben einige Dinge mit unseren Händen für eine Weile eingerichtet, aber früher oder später haben wir einen Fehler in den Einstellungen gemacht, aufgrund dessen es Fakaps gab. <br><br><img src="https://habrastorage.org/webt/5i/3n/7f/5i3n7fuurk18kiak_krk6jy8w8s.png"><br><br>  Und das Letzte: Sie benötigen entweder ein Replikat oder eine Sicherungskopie für jedes Element Ihrer Infrastruktur.  Und wenn Sie es nicht für etwas tun, wird uns diese besondere Sache jemals im Stich lassen. <br><br><h3>  Fragen aus dem Publikum </h3><br>  <b>- Aber stört es Sie nicht, dass die automatische Skalierung aufgrund eines Fehlers zu stark anhält und Sie viel Geld bekommen?</b> <br><br>  - Für die automatische Skalierung sind noch Grenzwerte festgelegt.  Wir werden kein zu großes Limit setzen, um nicht auf viel Geld hereinzufallen.  Dies ist die Hauptlösung + Überwachung.  Sie können Warnungen festlegen, wenn etwas zu stark ist. <br><br>  <b>- Was sind Ihre aktuellen Grenzen?</b>  <b>Relativ zur aktuellen Infrastruktur in Prozent.</b> <br><br>  - Jetzt haben wir eine offene Beta-Testphase in 11 Ländern, daher ist es keine so große CCU, zumindest irgendwie zu bewerten.  Jetzt ist die Infrastruktur für die Anzahl der Menschen, die wir haben, zu überprovisioniert. <br><br>  <b>- Und es gibt noch keine Grenzen?</b> <br><br>  - Ja, es ist nur so, dass sie 10-100 Mal höher sind als unsere CCU.  Mach nicht weniger. <br><br>  <b>- Sie sagten, dass Sie Linien zwischen Front- und Backend haben - das ist sehr ungewöhnlich.</b>  <b>Warum nicht direkt?</b> <br><br>  - Wir wollten, dass zustandslose Dienste den Sicherungsmechanismus einfach implementieren, damit der Dienst nicht mehr Nachrichten anfordert als freie Handler.  Wenn beispielsweise ein Handler ausfällt, gibt die Warteschlange dieselbe Nachricht an einen anderen Handler weiter - möglicherweise ist dies erfolgreich. <br><br>  <b>- Bleibt die Warteschlange irgendwie bestehen?</b> <br><br>  - Ja.  Dies ist ein Amazonian SQS-Dienst. <br><br>  <b>- In Bezug auf die Warteschlangen: Wie viele Kanäle werden während des Spiels erstellt?</b>  <b>Haben Sie eine bestimmte Anzahl von Kanälen für jedes Spiel?</b> <br><br>  - Es schafft relativ wenig.  Die meisten Warteschlangen, z. B. Anforderungswarteschlangen, sind statisch.  Es gibt eine Warteschlange mit Autorisierungsanforderungen, es gibt eine Warteschlange für den Beginn des Spiels.  Von den dynamisch erstellten Warteschlangen haben wir nur Warteschlangen für jedes Frontend (es erstellt für eingehende Nachrichten für Clients beim Start) und für jede Übereinstimmung erstellen wir eine Warteschlange.  Bei diesem Service kostet es fast nichts, sie haben jede Anfrage auf die gleiche Weise in Rechnung gestellt.  Das heißt,  Jede Anfrage an SQS (eine Warteschlange erstellen, etwas daraus lesen) kostet dasselbe und gleichzeitig löschen wir diese Warteschlangen nicht, um sie zu speichern. Sie werden später gelöscht.  Und die Tatsache, dass sie existieren, kostet uns nichts. <br><br>  <b>- In dieser Architektur ist dies keine Grenze für Sie?</b> <br><br>  - Nein. <br><br><h3>  Weitere Gespräche mit Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung des Konsuls zur Skalierung staatlicher Dienste</a> (Ivan Bubnov, DevOps bei BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CICD: nahtlose Bereitstellung auf verteilten Clustersystemen ohne Ausfallzeiten</a> (Egor Panov, Pixonic-Systemadministrator); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform des Quake Champions-Spiels</a> (Roman Rogozin, Backend-Entwickler Sabre Interactive); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ECS, C # Job System und SRP den Architekturansatz ändern</a> (Valentin Simonov, Field Engineer bei Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KISS-Prinzip in der Entwicklung</a> (Konstantin Gladyshev, Lead Game Programmer bei 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Spielelogik auf Client und Server</a> (Anton Grigoriev, stellvertretender technischer Mitarbeiter bei Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurke in der Cloud: Verwenden von BDD-Skripten für Produktstresstests</a> (Anton Kosyakin, Technischer Produktmanager auf der ALICE-Plattform). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426875/">https://habr.com/ru/post/de426875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426861/index.html">Unter dem Berg findet eine neue Jagd nach dunkler Materie statt</a></li>
<li><a href="../de426863/index.html">Verfügbar über Quaternionen und ihre Vorteile</a></li>
<li><a href="../de426865/index.html">Ein klares Dashboard-Design für ein ausgeklügeltes Anzeigenverwaltungssystem</a></li>
<li><a href="../de426869/index.html">So führen Sie Videokonferenzen mit ausländischen Kunden effektiv durch</a></li>
<li><a href="../de426873/index.html">Automatische Steuerung über den Fernzugriff auf die Windows-Registrierung</a></li>
<li><a href="../de426879/index.html">Einrichtung eines elektrischen Begrenzungssystems für Projekte mit Hochgeschwindigkeitsschnittstellen</a></li>
<li><a href="../de426881/index.html">Starten von Online-Entwicklerprogrammen</a></li>
<li><a href="../de426889/index.html">Teilnahme an maschinellen Lernwettbewerben. Vortrag in Yandex</a></li>
<li><a href="../de426891/index.html">SAP Process Mining oder wie Sie Ihre Geschäftsprozesse verstehen</a></li>
<li><a href="../de426893/index.html">So starten Sie eine iOS-Anwendung über React Native</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>