<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≥üèø üåü ü§æüèø Tacticool Mobile Online Shooter Meta Server-Architektur ‚úä üôá üìñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein weiteres Gespr√§ch mit Pixonic DevGAMM Talks - diesmal von unseren Kollegen bei PanzerDog. Der leitende Software-Ingenieur des Unternehmens, Pavel ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tacticool Mobile Online Shooter Meta Server-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/426875/">  Ein weiteres Gespr√§ch mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixonic DevGAMM Talks</a> - diesmal von unseren Kollegen bei PanzerDog.  Der leitende Software-Ingenieur des Unternehmens, Pavel Platto, zerlegte den Metaserver des Spiels mit einer serviceorientierten Architektur und erkl√§rte, welche L√∂sungen und Technologien ausgew√§hlt wurden, welche und wie sie skaliert wurden und mit welchen Schwierigkeiten sie konfrontiert waren.  Der Text des Berichts, Folien und Links zu anderen Reden aus dem Mitap, wie immer, unter dem Schnitt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JcuOHUzXXHw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Zun√§chst m√∂chte ich einen kleinen Trailer f√ºr unser Spiel demonstrieren: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yIpGvbbMCn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>  Der Bericht besteht aus 3 Teilen.  Im ersten werde ich dar√ºber sprechen, welche Technologien wir ausgew√§hlt haben und warum, im zweiten - wie unser Metaserver angeordnet ist, und im dritten werde ich √ºber die verschiedenen unterst√ºtzenden Infrastrukturen sprechen, die wir verwenden, und wie wir das Update ohne Ausfallzeiten implementiert haben . <br><br><img src="https://habrastorage.org/webt/-s/fg/tz/-sfgtzhre4ij6b0n9-b_r0cako4.png"><br>  <i>Technologischer Stapel</i> <br><br>  Der Metaserver wird auf Amazon gehostet und in Elixir geschrieben.  Es ist eine funktionale Programmiersprache mit einem Akteurmodell der Berechnung.  Da wir keine Ops haben, sind Programmierer an der Operation beteiligt, und der gr√∂√üte Teil der Infrastruktur wird mithilfe der HashiCorp Terraform als Code beschrieben. <br><br>  Tacticool befindet sich derzeit in der offenen Beta, der Metaserver befindet sich seit etwas mehr als einem Jahr in der Entwicklung und ist seit fast einem Jahr in Betrieb.  Mal sehen, wie alles begann. <br><br><img src="https://habrastorage.org/webt/zs/a0/fa/zsa0favmdahf0gdsnt0-goxhrnq.png"><br><br>  Als ich in das Unternehmen eintrat, hatten wir bereits grundlegende Funktionen als Monolith auf einem C / C ++ - Mix und PostageSQL-Speicher implementiert.  Diese Implementierung hatte bestimmte Probleme. <br><br>  Erstens gab es aufgrund des niedrigen C-Spiegels einige schwer fassbare Fehler.  Bei einigen Spielern h√§ngt das Matchmaking beispielsweise aufgrund einer falschen Nullstellung des Arrays vor seiner Wiederverwendung fest.  Nat√ºrlich war es ziemlich schwierig, die Beziehung zwischen diesen beiden Ereignissen zu finden.  Und da der Status mehrerer Threads im Code allgemein ge√§ndert wurde, waren die Race-Bedingungen nicht ohne. <br><br>  Die parallele Verarbeitung einer gro√üen Anzahl von Aufgaben kam ebenfalls nicht in Frage, da der Server zu Beginn von etwa 10 Arbeitsprozessen gestartet wurde, die durch Abfragen an Amazon oder die Datenbank blockiert wurden.  Und selbst wenn wir diese Blockierungsanforderungen vergessen, begann der Dienst bei ein paar Hundert Verbindungen zusammenzubrechen, die au√üer Ping keine Operationen ausf√ºhrten.  Au√üerdem konnte der Dienst nicht horizontal skaliert werden. <br><br>  Nachdem wir einige Wochen damit verbracht hatten, die kritischsten Fehler zu finden und zu beheben, entschieden wir, dass es einfacher war, alles von Grund auf neu zu schreiben, als zu versuchen, alle M√§ngel der aktuellen L√∂sung zu beheben. <br><br>  Wenn Sie bei Null anfangen, ist es sinnvoll, eine Sprache auszuw√§hlen, mit der Sie einige der vorherigen Probleme vermeiden k√∂nnen.  Wir hatten drei Kandidaten: <br><br><ul><li>  C #; </li><li>  Geh; </li><li>  Elixier. </li></ul><br><img src="https://habrastorage.org/webt/_f/vt/q5/_fvtq51jwvlo2uuquqy-4vwsnhw.png"><br><br>  C # war auf der Bekanntschaftsliste, as  Der Client und der Spieleserver sind in Unity geschrieben, und die meiste Erfahrung im Team wurde mit dieser Programmiersprache gemacht.  Go und Elixir wurden in Betracht gezogen, da dies moderne und recht beliebte Sprachen sind, die f√ºr die Entwicklung von Serveranwendungen entwickelt wurden. <br><br>  Die Probleme der vorherigen Iteration haben uns geholfen, die Kriterien f√ºr die Bewertung von Kandidaten zu bestimmen. <br><br>  Das erste Kriterium war die Bequemlichkeit der Arbeit mit asynchronen Operationen.  In C # wurde beim ersten Versuch keine bequeme Arbeit mit asynchronen Operationen angezeigt.  Dies f√ºhrte dazu, dass wir einen ‚ÄûZoo‚Äú von L√∂sungen haben, die meiner Meinung nach immer noch ein wenig auf der Seite stehen.  In Go und Elixir wurde dieses Problem beim Entwerfen dieser Sprachen ber√ºcksichtigt. Beide verwenden leichtgewichtige Threads (in Go sind sie Goroutinen, in Elixir Prozesse).  Diese Streams haben einen viel geringeren Overhead als System-Threads, und da wir sie in Zehntausenden und Hunderttausenden erstellen k√∂nnen, tut es uns nicht leid, sie zu blockieren. <br><br>  Das zweite Kriterium war die F√§higkeit, mit wettbewerbsf√§higen Prozessen zu arbeiten.  C # out of the box bietet nichts anderes als Thread-Pools und gemeinsam genutzten Speicher, auf den der Zugriff mithilfe verschiedener Synchronisationsprimitive gesch√ºtzt werden muss.  Go hat ein weniger fehleranf√§lliges Modell in Form von Goroutinen und Kan√§len.  Elixir hingegen bietet ein Schauspieler-Modell ohne Shared Memory mit Messaging.  Der Mangel an gemeinsam genutztem Speicher erm√∂glichte es uns, Technologien zu implementieren, die f√ºr eine wettbewerbsf√§hige Ausf√ºhrungsumgebung zur Laufzeit n√ºtzlich sind, wie z. B. ehrliches Push-out-Multitasking und Garbage Collection ohne Unterbrechungen in der Welt. <br><br>  Das dritte Kriterium war die Verf√ºgbarkeit von Tools f√ºr die Arbeit mit unver√§nderlichen Datentypen.  Alle meine Entwicklungserfahrungen haben gezeigt, dass ein ziemlich gro√üer Teil der Fehler mit falschen Daten√§nderungen verbunden ist.  Eine L√∂sung daf√ºr gibt es schon vor langer Zeit - unver√§nderliche Datentypen.  In C # k√∂nnen diese Datentypen erstellt werden, jedoch auf Kosten einer Tonne Boilerplate.  In Go ist dies √ºberhaupt nicht m√∂glich.  Und in Elixir sind alle Datentypen unver√§nderlich. <br><br>  Und das letzte Kriterium war die Anzahl der Spezialisten.  Hier sind die Ergebnisse offensichtlich.  Am Ende haben wir uns f√ºr Elixir entschieden. <br><br>  Mit der Wahl des Hostings war alles viel einfacher.  Wir haben bereits Spieleserver in Amazon GameLift gehostet. Dar√ºber hinaus bietet Amazon eine gro√üe Anzahl von Diensten an, mit denen wir die Entwicklungszeit verk√ºrzen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/f2/zm/jn/f2zmjnyjejb3ffw0vhs69hvqjoi.png"><br><br>  Wir haben uns vollst√§ndig der Cloud ergeben und stellen selbst keine L√∂sungen von Drittanbietern bereit - Datenbanken, Nachrichtenwarteschlangen - all dies wird von Amazon f√ºr uns verwaltet.  Meiner Meinung nach ist dies die einzige L√∂sung f√ºr ein kleines Team, das ein Online-Spiel entwickeln m√∂chte, und nicht die Infrastruktur daf√ºr. <br><br>  Wir haben die Auswahl der Technologien herausgefunden. Kommen wir zur Funktionsweise des Metaservers. <br><br><img src="https://habrastorage.org/webt/q1/jy/m8/q1jym8itnftw6e3tqyvsbqh-uva.png"><br><br>  Im Allgemeinen: Clients stellen √ºber Web-Socket-Verbindungen eine Verbindung zum Load Balancer von Amazon her.  Der Balancer streut diese Verbindungen zwischen mehreren Front-End-Instanzen, das Front-End sendet Client-Anforderungen an Back-Ends.  Das Front-End und das Back-End kommunizieren jedoch indirekt √ºber Nachrichtenwarteschlangen.  F√ºr jeden Nachrichtentyp gibt es eine separate Warteschlange, und das Frontend bestimmt anhand des Nachrichtentyps, wo es geschrieben werden soll, und die Backends h√∂ren diese Warteschlangen ab. <br><br>  Damit das Backend eine Antwort auf die Anfrage an den Client oder eine Art Ereignis senden kann, verf√ºgt jedes Frontend √ºber eine separate Warteschlange (speziell daf√ºr zugewiesen).  Bei jeder Anforderung erh√§lt das Backend eine Frontend-ID, um zu bestimmen, in welche Warteschlange die Antwort geschrieben werden soll.  Wenn er ein Ereignis senden muss, ruft er die Datenbank auf, um herauszufinden, mit welcher Frontend-Instanz der Client verbunden ist. <br><br>  Kommen wir mit dem allgemeinen Schema zu den Details. <br><br><img src="https://habrastorage.org/webt/xe/rr/u-/xerru-5vn3tx-dwqbylflu18mrm.png"><br><br>  Zun√§chst werde ich auf einige Funktionen der Client-Server-Interaktion eingehen.  Wir verwenden unser Bin√§rprotokoll, weil es sehr effizient ist und es erm√∂glicht, Verkehr zu sparen.  Zweitens sendet der Server bei Vorg√§ngen mit einem Konto, das es √§ndert, diese √Ñnderungen nicht an den Client, sondern an die vollst√§ndige (aktualisierte) Version dieses Kontos.  Dies ist etwas weniger effizient, nimmt aber ohnehin nicht viel Platz ein und vereinfacht unser Leben sowohl auf dem Client als auch auf dem Server erheblich.  Au√üerdem stellt das Frontend sicher, dass der Client nicht mehr als eine Anforderung gleichzeitig ausf√ºhrt.  Auf diese Weise k√∂nnen Sie Fehler auf dem Client erkennen, wenn er beispielsweise zu einem anderen Bildschirm wechselt, bevor der Player das Ergebnis der vorherigen Operation sieht. <br><br>  Nun ein wenig dar√ºber, wie das Frontend angeordnet ist. <br><br><img src="https://habrastorage.org/webt/te/-k/ff/te-kffgzvatzj_3tjwcus5lvpdk.png"><br><br>  Ein Frontend ist im Wesentlichen ein Webserver, der auf Web-Socket-Verbindungen wartet.  F√ºr jede Sitzung werden zwei Prozesse erstellt.  Der erste Prozess dient der Web-Socket-Verbindung selbst, und der zweite ist eine Zustandsmaschine, die den aktuellen Status des Clients beschreibt.  Basierend auf diesem Status wird die G√ºltigkeit von Anforderungen vom Client bestimmt.  Beispielsweise k√∂nnen fast alle Anforderungen erst abgeschlossen werden, wenn die Autorisierung abgeschlossen ist.  Da es neben diesen Sitzungen keinen Status im Frontend gibt, ist es sehr einfach, neue Frontend-Instanzen hinzuzuf√ºgen, aber es ist etwas schwieriger, die alten zu l√∂schen.  Vor der Deinstallation m√ºssen Sie alle Clients ihre aktuellen Anforderungen ausf√ºhren lassen und sie bitten, die Verbindung zu einer anderen Instanz wiederherzustellen. <br><br>  Nun dazu, wie das Backend aussieht.  Derzeit besteht es aus f√ºnf Diensten. <br><br><img src="https://habrastorage.org/webt/qh/cj/x4/qhcjx4ckmzg8lcqpriouhi8rnee.png"><br><br>  Der erste befasst sich mit allem, was mit Konten zu tun hat - von Eink√§ufen f√ºr Spielw√§hrung bis zum Abschluss von Quests.  Der zweite funktioniert mit allem, was mit Spielen zu tun hat - er interagiert direkt mit GameLift und Spieleservern.  Der dritte Service ist das Einkaufen f√ºr echtes Geld.  Der vierte und f√ºnfte sind f√ºr soziale Interaktionen verantwortlich - einer f√ºr Freunde, der andere f√ºr ein Partyspiel. <br><br>  Jeder der Backend-Services sieht aus architektonischer Sicht absolut identisch aus.  Sie sind eine Reihe von Pipelines, von denen jede einen Nachrichtentyp verarbeitet.  Die Pipeline besteht aus zwei Elementen: Produzent und Konsument. <br><br><img src="https://habrastorage.org/webt/ym/di/eh/ymdiehrcngon3im1my2d8nbbgsk.png"><br><br>  Die einzige Aufgabe des Produzenten besteht darin, Nachrichten aus der Warteschlange zu lesen.  Daher wird es in einer vollst√§ndig allgemeinen Form implementiert, und f√ºr jede Pipeline m√ºssen wir nur angeben, wie viele Hersteller vorhanden sind, aus welcher Warteschlange gelesen werden soll und wie viele Verbraucher jeder Hersteller bedienen wird.  Consumer hingegen wird f√ºr jede Pipeline separat implementiert und ist ein Modul mit der einzigen obligatorischen Funktion, die eine Nachricht akzeptiert, alle erforderlichen Arbeiten ausf√ºhrt und eine Liste von Nachrichten zur√ºckgibt, die an andere Dienste an den Client oder an den Spieleserver gesendet werden m√ºssen.  Der Produzent setzt auch Gegendruck ein, so dass bei einem starken Anstieg der Anzahl der Nachrichten keine √úberlastung auftritt, und fordert nicht mehr Nachrichten an, als er freie Verbraucher hat. <br><br>  Backend-Services enthalten keinen Status, daher k√∂nnen wir alte Instanzen problemlos hinzuf√ºgen und entfernen.  Vor dem L√∂schen m√ºssen Sie die Produzenten lediglich auffordern, keine neuen Nachrichten mehr zu lesen, und den Verbrauchern ein wenig Zeit geben, um die Verarbeitung aktiver Nachrichten abzuschlie√üen. <br><br>  Wie erfolgt die Interaktion mit GameLift?  GameLift besteht aus mehreren Komponenten.  Von denen, die wir verwenden, ist dies ein FlexMatch-Matchmaker, eine Platzierungswarteschlange, die bestimmt, in welcher bestimmten Region eine Spielsitzung mit diesen Spielern stattfinden soll, und die Flotten selbst, die aus Spielservern bestehen. <br><br><img src="https://habrastorage.org/webt/c8/ge/5h/c8ge5huiowlmu5q7b9izd4sew4y.png"><br><br>  Wie l√§uft diese Interaktion?  Meta kommuniziert nur direkt mit dem Matchmaker und sendet ihm Anfragen, um das Match zu finden.  Und er benachrichtigt das Meta aller Ereignisse w√§hrend des Matchmaking √ºber dieselben Nachrichtenwarteschlangen.  Und sobald er eine geeignete Gruppe von Spielern findet, um das Spiel zu starten, sendet er eine Anfrage an die Platzierungswarteschlange, die wiederum einen Server f√ºr sie ausw√§hlt. <br><br>  Die Interaktion von Meta mit dem Spieleserver ist √§u√üerst einfach.  Der Spielserver ben√∂tigt Informationen zu Konten, Bots und einer Karte, und das Meta sendet alle diese Informationen in einer einzigen Nachricht an die Warteschlange, die speziell f√ºr dieses Spiel erstellt wurde. <br><br><img src="https://habrastorage.org/webt/vv/zo/y5/vvzoy5ycub5em-qiovlo911pg0k.png"><br><br>  Nach der Aktivierung h√∂rt der Spieleserver diese Warteschlange ab und empf√§ngt alle ben√∂tigten Daten.  Am Ende des Spiels sendet er seine Ergebnisse an die allgemeine Warteschlange, die das Meta abh√∂rt. <br><br>  Kommen wir nun zu der zus√§tzlichen Infrastruktur, die wir verwenden. <br><br><img src="https://habrastorage.org/webt/l-/st/nu/l-stnuybsqrbk_be4fhlgrsdgpa.png"><br><br>  Das Bereitstellen von Diensten ist recht einfach.  Sie arbeiten alle in Docker-Containern, und wir verwenden Amazon ECS f√ºr die Orchestrierung.  Es ist viel einfacher als Kubernetes, nat√ºrlich weniger ausgefeilt, aber es f√ºhrt die Aufgaben aus, die wir von ihm ben√∂tigen.  N√§mlich: Skalierungsdienste und fortlaufende Releases, wenn wir eine Art Bugfix eingeben m√ºssen. <br><br>  Und der letzte Service, den wir auch nutzen, ist AWS Fargate.  Dies erspart uns die unabh√§ngige Verwaltung des Maschinenclusters, auf dem unsere Docker-Container ausgef√ºhrt werden. <br><br><img src="https://habrastorage.org/webt/q1/xl/8m/q1xl8mppdukmbjoezzm6pzlbl9k.png"><br><br>  Als Hauptspeicher verwenden wir DynamoDB.  Zun√§chst haben wir uns daf√ºr entschieden, weil es sehr einfach zu bedienen und zu skalieren ist.  Wir verwenden Redis auch als zus√§tzlichen Speicher √ºber den von Amazon ElasiCache verwalteten Dienst.  Wir verwenden es f√ºr die globale Spielerbewertungsaufgabe und zum Zwischenspeichern grundlegender Kontoinformationen in Situationen, in denen wir Daten zu Hunderten von Spielkonten sofort an den Client zur√ºckgeben m√ºssen (z. B. in derselben Bewertungstabelle oder in der Freundesliste). <br><br>  Zum Speichern von Konfigurationen, Metaspielmechaniken, Beschreibungen von Waffen, Helden usw.  Wir verwenden eine JSON-Datei, die wir an die Images der Dienste anh√§ngen, die sie ben√∂tigen.  Weil es f√ºr uns viel einfacher ist, eine neue Version des Dienstes mit aktualisierten Daten bereitzustellen (wenn ein Fehler festgestellt wird), als eine Entscheidung zu treffen, die diese Daten zur Laufzeit dynamisch von einem externen Speicher aktualisiert. <br><br>  F√ºr die Protokollierung und √úberwachung verwenden wir einige Dienste. <br><br><img src="https://habrastorage.org/webt/lh/ub/3u/lhub3urulc1urcn8omuxprcn0rg.png"><br><br>  Beginnen wir mit CloudWatch.  Dies ist ein √úberwachungsdienst, bei dem sich Metriken aller Amazon-Dienste versammeln.  Aus diesem Grund haben wir uns entschlossen, die Metriken auch von unserem Metaserver dorthin zu senden.  F√ºr die Protokollierung verwenden wir einen gemeinsamen Ansatz sowohl auf dem Client als auch auf dem Spieleserver und auf dem Metaserver.  Wir senden alle Protokolle an den Amazonas-Dienst Kinesis Firehose, der sie wiederum an Elasticseach und S3 √ºbertr√§gt. <br><br>  In Elasticseach speichern wir nur relativ aktuelle Daten und suchen mithilfe von Kibana nach Fehlern, l√∂sen einige der Aufgaben der Spielanalyse und erstellen betriebliche Dashboards, beispielsweise mit einem CCU-Zeitplan und der Anzahl neuer Installationen.  S3 enth√§lt alle historischen Daten und wir verwenden sie √ºber den Athena-Dienst, der zus√§tzlich zu den Daten in S3 eine SQL-Schnittstelle bereitstellt. <br><br>  Nun ein wenig dar√ºber, wie wir Terraform verwenden. <br><br><img src="https://habrastorage.org/webt/o8/jj/-q/o8jj-qfa1hsyq1qposebwbof4dc.png"><br><br>  Terraform ist ein Tool, mit dem Sie die Infrastruktur deklarativ beschreiben k√∂nnen. Wenn sich die Beschreibung √§ndert, werden automatisch die Ma√ünahmen festgelegt, die Sie ergreifen m√ºssen, um Ihre Infrastruktur auf ein aktualisiertes Erscheinungsbild zu bringen.  Mit einer einzigen Beschreibung erhalten wir eine nahezu identische Umgebung f√ºr Inszenierung und Produktion.  Au√üerdem sind diese Umgebungen vollst√§ndig isoliert, da sie unter verschiedenen Konten bereitgestellt werden.  Der einzige wesentliche Nachteil von Terraform ist f√ºr uns die unvollst√§ndige Unterst√ºtzung von GameLift. <br><br>  Ich werde auch dar√ºber sprechen, wie wir das Update ohne Ausfallzeiten implementiert haben. <br><br><img src="https://habrastorage.org/webt/_l/ge/va/_lgevakn50wndn5tvfipi1_ujam.png"><br><br>  Wenn wir Updates ver√∂ffentlichen, erstellen wir eine Kopie der meisten Ressourcen: Dienste, Nachrichtenwarteschlangen, einige Bezeichnungen in der Datenbank.  Und diejenigen Spieler, die die neue Version des Spiels herunterladen, werden eine Verbindung zu diesem aktualisierten Cluster herstellen.  Spieler, die noch nicht aktualisiert wurden, k√∂nnen jedoch noch einige Zeit mit der alten Version des Spiels spielen und eine Verbindung zum alten Cluster herstellen. <br><br>  Wie wir es umgesetzt haben.  Verwenden Sie zun√§chst die Modul-Engine in Terraform.  Wir haben ein Modul zugewiesen, in dem wir alle versionierten Ressourcen beschrieben haben.  Und diese Module k√∂nnen mehrmals mit unterschiedlichen Parametern importiert werden.  Dementsprechend importieren wir f√ºr jede Version dieses Modul unter Angabe der Nummer dieser Version.  Das Fehlen eines Schemas in DynamoDB hat uns auch geholfen, wodurch es m√∂glich ist, Datenmigrationen nicht w√§hrend des Updates durchzuf√ºhren, sondern sie f√ºr jedes Konto zu verschieben, bis sich sein Besitzer bei der neuen Version des Spiels anmeldet.  Und im Balancer geben wir einfach f√ºr jede Version der Regel an, damit sie wei√ü, wohin Spieler mit unterschiedlichen Versionen weitergeleitet werden sollen. <br><br>  Zum Schluss noch ein paar Dinge, die wir gelernt haben.  Zun√§chst muss die Konfiguration der gesamten Infrastruktur automatisiert werden.  Das hei√üt,  Wir haben einige Dinge mit unseren H√§nden f√ºr eine Weile eingerichtet, aber fr√ºher oder sp√§ter haben wir einen Fehler in den Einstellungen gemacht, aufgrund dessen es Fakaps gab. <br><br><img src="https://habrastorage.org/webt/5i/3n/7f/5i3n7fuurk18kiak_krk6jy8w8s.png"><br><br>  Und das Letzte: Sie ben√∂tigen entweder ein Replikat oder eine Sicherungskopie f√ºr jedes Element Ihrer Infrastruktur.  Und wenn Sie es nicht f√ºr etwas tun, wird uns diese besondere Sache jemals im Stich lassen. <br><br><h3>  Fragen aus dem Publikum </h3><br>  <b>- Aber st√∂rt es Sie nicht, dass die automatische Skalierung aufgrund eines Fehlers zu stark anh√§lt und Sie viel Geld bekommen?</b> <br><br>  - F√ºr die automatische Skalierung sind noch Grenzwerte festgelegt.  Wir werden kein zu gro√ües Limit setzen, um nicht auf viel Geld hereinzufallen.  Dies ist die Hauptl√∂sung + √úberwachung.  Sie k√∂nnen Warnungen festlegen, wenn etwas zu stark ist. <br><br>  <b>- Was sind Ihre aktuellen Grenzen?</b>  <b>Relativ zur aktuellen Infrastruktur in Prozent.</b> <br><br>  - Jetzt haben wir eine offene Beta-Testphase in 11 L√§ndern, daher ist es keine so gro√üe CCU, zumindest irgendwie zu bewerten.  Jetzt ist die Infrastruktur f√ºr die Anzahl der Menschen, die wir haben, zu √ºberprovisioniert. <br><br>  <b>- Und es gibt noch keine Grenzen?</b> <br><br>  - Ja, es ist nur so, dass sie 10-100 Mal h√∂her sind als unsere CCU.  Mach nicht weniger. <br><br>  <b>- Sie sagten, dass Sie Linien zwischen Front- und Backend haben - das ist sehr ungew√∂hnlich.</b>  <b>Warum nicht direkt?</b> <br><br>  - Wir wollten, dass zustandslose Dienste den Sicherungsmechanismus einfach implementieren, damit der Dienst nicht mehr Nachrichten anfordert als freie Handler.  Wenn beispielsweise ein Handler ausf√§llt, gibt die Warteschlange dieselbe Nachricht an einen anderen Handler weiter - m√∂glicherweise ist dies erfolgreich. <br><br>  <b>- Bleibt die Warteschlange irgendwie bestehen?</b> <br><br>  - Ja.  Dies ist ein Amazonian SQS-Dienst. <br><br>  <b>- In Bezug auf die Warteschlangen: Wie viele Kan√§le werden w√§hrend des Spiels erstellt?</b>  <b>Haben Sie eine bestimmte Anzahl von Kan√§len f√ºr jedes Spiel?</b> <br><br>  - Es schafft relativ wenig.  Die meisten Warteschlangen, z. B. Anforderungswarteschlangen, sind statisch.  Es gibt eine Warteschlange mit Autorisierungsanforderungen, es gibt eine Warteschlange f√ºr den Beginn des Spiels.  Von den dynamisch erstellten Warteschlangen haben wir nur Warteschlangen f√ºr jedes Frontend (es erstellt f√ºr eingehende Nachrichten f√ºr Clients beim Start) und f√ºr jede √úbereinstimmung erstellen wir eine Warteschlange.  Bei diesem Service kostet es fast nichts, sie haben jede Anfrage auf die gleiche Weise in Rechnung gestellt.  Das hei√üt,  Jede Anfrage an SQS (eine Warteschlange erstellen, etwas daraus lesen) kostet dasselbe und gleichzeitig l√∂schen wir diese Warteschlangen nicht, um sie zu speichern. Sie werden sp√§ter gel√∂scht.  Und die Tatsache, dass sie existieren, kostet uns nichts. <br><br>  <b>- In dieser Architektur ist dies keine Grenze f√ºr Sie?</b> <br><br>  - Nein. <br><br><h3>  Weitere Gespr√§che mit Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung des Konsuls zur Skalierung staatlicher Dienste</a> (Ivan Bubnov, DevOps bei BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CICD: nahtlose Bereitstellung auf verteilten Clustersystemen ohne Ausfallzeiten</a> (Egor Panov, Pixonic-Systemadministrator); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Praxis der Verwendung des Schauspielermodells in der Backend-Plattform des Quake Champions-Spiels</a> (Roman Rogozin, Backend-Entwickler Sabre Interactive); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie ECS, C # Job System und SRP den Architekturansatz √§ndern</a> (Valentin Simonov, Field Engineer bei Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">KISS-Prinzip in der Entwicklung</a> (Konstantin Gladyshev, Lead Game Programmer bei 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Spielelogik auf Client und Server</a> (Anton Grigoriev, stellvertretender technischer Mitarbeiter bei Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gurke in der Cloud: Verwenden von BDD-Skripten f√ºr Produktstresstests</a> (Anton Kosyakin, Technischer Produktmanager auf der ALICE-Plattform). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426875/">https://habr.com/ru/post/de426875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426861/index.html">Unter dem Berg findet eine neue Jagd nach dunkler Materie statt</a></li>
<li><a href="../de426863/index.html">Verf√ºgbar √ºber Quaternionen und ihre Vorteile</a></li>
<li><a href="../de426865/index.html">Ein klares Dashboard-Design f√ºr ein ausgekl√ºgeltes Anzeigenverwaltungssystem</a></li>
<li><a href="../de426869/index.html">So f√ºhren Sie Videokonferenzen mit ausl√§ndischen Kunden effektiv durch</a></li>
<li><a href="../de426873/index.html">Automatische Steuerung √ºber den Fernzugriff auf die Windows-Registrierung</a></li>
<li><a href="../de426879/index.html">Einrichtung eines elektrischen Begrenzungssystems f√ºr Projekte mit Hochgeschwindigkeitsschnittstellen</a></li>
<li><a href="../de426881/index.html">Starten von Online-Entwicklerprogrammen</a></li>
<li><a href="../de426889/index.html">Teilnahme an maschinellen Lernwettbewerben. Vortrag in Yandex</a></li>
<li><a href="../de426891/index.html">SAP Process Mining oder wie Sie Ihre Gesch√§ftsprozesse verstehen</a></li>
<li><a href="../de426893/index.html">So starten Sie eine iOS-Anwendung √ºber React Native</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>