<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèø ‚õ∞Ô∏è üíö V√©rification du code source de Roslyn üåú ü§π üïµüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De temps en temps, nous revenons √† des projets que nous avions pr√©c√©demment test√©s avec PVS-Studio et avons √©crit des articles √† ce sujet. Il y a deux...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>V√©rification du code source de Roslyn</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/446592/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/833/abb/d94/833abbd94d6e48526a175b89fffc9dd5.png" alt="PVS-Studio vs Roslyn"></div><br>  De temps en temps, nous revenons √† des projets que nous avions pr√©c√©demment test√©s avec PVS-Studio et avons √©crit des articles √† ce sujet.  Il y a deux raisons √† cela.  Tout d'abord, pour comprendre √† quel point notre analyseur est devenu meilleur.  Deuxi√®mement, pour v√©rifier si les auteurs du projet ont pr√™t√© attention √† notre article, ainsi qu'au rapport d'erreur que nous leur fournissons habituellement.  Bien s√ªr, les erreurs peuvent √™tre corrig√©es sans notre participation.  Mais c'est toujours agr√©able quand exactement nos efforts contribuent √† am√©liorer un projet.  Roslyn ne faisait pas exception.  Un pr√©c√©dent article de synth√®se sur ce projet remonte au 23 d√©cembre 2015.  C'est assez long, compte tenu du chemin parcouru par notre analyseur dans son d√©veloppement pendant cette p√©riode.  Pour nous personnellement, Roslyn pr√©sente √©galement un int√©r√™t suppl√©mentaire du fait que le c≈ìur de l'analyseur C # PVS-Studio est bas√© sur celui-ci.  Par cons√©quent, nous sommes tr√®s int√©ress√©s par la qualit√© du code de ce projet.  Nous organiserons un deuxi√®me contr√¥le et d√©couvrirons ce qui est nouveau et int√©ressant (mais esp√©rons que rien d'important) PVS-Studio puisse y trouver. <br><a name="habracut"></a><br>  Roslyn (ou la plate-forme du compilateur .NET) est probablement familier √† beaucoup de nos lecteurs.  En bref, il s'agit d'un ensemble de compilateurs open source et d'API pour l'analyse de code pour les langages C # et Visual Basic .NET de Microsoft.  Le code source du projet est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . <br><br>  Je ne donnerai pas une description d√©taill√©e de cette plate-forme, mais je recommanderais √† tous ceux qui sont int√©ress√©s un article de mon coll√®gue Sergey Vasiliev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction √† Roslyn. Utiliser des outils d'analyse statique pour d√©velopper</a> ".  √Ä partir de cet article, vous pouvez en apprendre non seulement sur les fonctionnalit√©s de l'architecture Roslyn, mais √©galement sur la fa√ßon dont nous utilisons exactement cette plate-forme. <br><br>  Comme je l'ai mentionn√© plus t√¥t, plus de trois ans se sont √©coul√©s depuis la r√©daction du dernier article de mon coll√®gue Andrei Karpov sur le ch√®que de Roslyn " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sortie du Nouvel An de PVS-Studio 6.00: v√©rification de Roslyn</a> ".  Pendant ce temps, l'analyseur C # PVS-Studio a acquis de nombreuses nouvelles fonctionnalit√©s.  En g√©n√©ral, l'article d'Andrey √©tait une sorte de ¬´test ball¬ª, car l'analyseur C # n'√©tait alors ajout√© qu'√† PVS-Studio.  Malgr√© cela, m√™me alors, dans un projet de qualit√© inconditionnelle, Roslyn a r√©ussi √† trouver des erreurs int√©ressantes.  Qu'est-ce qui a chang√© dans l'analyseur pour le code C # jusqu'√† pr√©sent, ce qui permettra potentiellement une analyse plus approfondie? <br><br>  Au cours des derni√®res ann√©es, le c≈ìur de l'analyseur et l'infrastructure se sont d√©velopp√©s.  Un support a √©t√© ajout√© pour Visual Studio 2017 et Roslyn 2.0, ainsi qu'une int√©gration approfondie avec MSBuild.  Vous pouvez en savoir plus sur notre approche de l'int√©gration avec MSBuild et sur les raisons qui nous ont amen√©s √† l'accepter dans l'article de mon coll√®gue Pavel Yeremeyev, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prise en charge de Visual Studio 2017 et Roslyn 2.0 dans PVS-Studio: parfois, l'utilisation de solutions toutes faites n'est pas aussi simple qu'il n'y para√Æt en un coup d'≈ìil</a> . " <br><br>  Maintenant, nous travaillons activement sur la transition vers Roslyn 3.0 selon le m√™me sch√©ma que nous avons initialement pris en charge Visual Studio 2017, c'est-√†-dire via notre propre ensemble d'outils, qui est fourni dans le kit de distribution PVS-Studio avec un ¬´stub¬ª sous la forme d'un fichier MSBuild.exe vide.  Malgr√© le fait qu'elle ressemble √† une "b√©quille" (l'API MSBuild n'est pas tr√®s conviviale pour une r√©utilisation dans des projets de troisi√®me g√©n√©ration en raison de la faible portabilit√© des biblioth√®ques), cette approche nous a d√©j√† aid√© √† revivre plusieurs mises √† jour de Roslyn relativement sans douleur pendant la dur√©e de Visual Studio 2017. et maintenant, bien qu'avec de nombreuses superpositions, survivez √† la mise √† niveau vers Visual Studio 2019, tout en conservant une compatibilit√© descendante et des performances compl√®tes sur les syst√®mes avec des versions plus anciennes de MSBuild. <br><br>  Le c≈ìur de l'analyseur a √©galement subi un certain nombre d'am√©liorations.  L'une des principales innovations est une analyse interproc√©durale √† part enti√®re, prenant en compte les valeurs d'entr√©e et de sortie des m√©thodes, prenant en compte, en fonction de ces param√®tres, l'accessibilit√© des branches d'ex√©cution et des points de retour. <br><br>  La t√¢che de suivi des param√®tres √† l'int√©rieur des m√©thodes est d√©j√† presque termin√©e, tout en pr√©servant les annotations automatiques de ce qui se passe avec ces param√®tres (par exemple, un d√©r√©f√©rencement potentiellement dangereux).  Cela permettra √† tout diagnostic utilisant le m√©canisme de flux de donn√©es de prendre en compte les situations dangereuses qui se produisent lors du passage d'un param√®tre √† une m√©thode.  Auparavant, lors de l'analyse de ces endroits dangereux, aucun avertissement n'√©tait g√©n√©r√©, car nous ne pouvions pas conna√Ætre toutes les valeurs d'entr√©e possibles pour une telle m√©thode.  Nous pouvons maintenant d√©tecter le danger, car dans tous les endroits o√π cette m√©thode est appel√©e, ces param√®tres d'entr√©e seront pris en compte. <br><br>  Remarque: vous pouvez vous familiariser avec les principaux m√©canismes de l'analyseur, tels que le flux de donn√©es et autres, √† partir de l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technologies utilis√©es dans l'analyseur de code PVS-Studio pour trouver les erreurs et les vuln√©rabilit√©s potentielles</a> ". <br><br>  L'analyse interproc√©durale dans PVS-Studio C # n'est pas limit√©e par les param√®tres d'entr√©e ou la profondeur.  La seule limitation est les m√©thodes virtuelles dans les classes qui n'ont pas √©t√© ferm√©es pour l'h√©ritage et qui tombent dans la r√©cursivit√© (arr√™tons quand nous avons vu sur la pile un appel r√©p√©t√© √† une m√©thode d√©j√† calcul√©e).  De plus, la m√©thode r√©cursive elle-m√™me sera finalement calcul√©e en supposant que la valeur de retour de son auto-r√©cursivit√© est inconnue. <br><br>  Une autre grande innovation dans l'analyseur C # est la possibilit√© de d√©r√©f√©rencer un pointeur potentiellement nul.  Auparavant, l'analyseur jurait √† une √©ventuelle exception de r√©f√©rence nulle s'il √©tait s√ªr que dans toutes les branches d'ex√©cution, la valeur de la variable serait nulle.  Bien s√ªr, il se trompait parfois, de sorte que le diagnostic du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> √©tait auparavant appel√© r√©f√©rence nulle potentielle. <br><br>  L'analyseur se souvient maintenant que la variable peut √™tre nulle dans l'une des branches d'ex√©cution (par exemple, sous une certaine condition dans if).  S'il voit l'acc√®s √† une telle variable sans v√©rification, il recevra un message V3080, mais √† un niveau d'importance moindre que s'il voit null dans toutes les branches.  En combinaison avec une analyse interproc√©durale am√©lior√©e, un tel m√©canisme permet de trouver des erreurs tr√®s difficiles √† d√©tecter.  Un exemple est une longue cha√Æne d'appels de m√©thode, dont le dernier n'est pas familier et qui, par exemple, renvoie null dans certaines circonstances, mais vous ne vous en √™tes pas prot√©g√© car vous ne le saviez tout simplement pas.  Dans ce cas, l'analyseur ne jure que lorsqu'il voit pr√©cis√©ment l'affectation de null.  √Ä notre avis, cela distingue qualitativement notre approche d'une telle innovation de C # 8.0 en tant que type de r√©f√©rence nullable, qui, en fait, se r√©sume √† d√©finir des contr√¥les nuls dans chaque m√©thode.  Nous offrons une alternative - pour faire des v√©rifications uniquement l√† o√π la valeur nulle peut vraiment arriver, et notre analyseur est maintenant capable de rechercher de telles situations. <br><br>  Alors, sans plus tarder, passons au ¬´d√©briefing¬ª - analysant les r√©sultats du contr√¥le Roslyn.  Voyons d'abord les erreurs trouv√©es gr√¢ce aux innovations d√©crites ci-dessus.  En g√©n√©ral, plusieurs avertissements ont √©t√© √©mis pour le code Roslyn cette fois.  Je pense que cela est d√ª au fait que la plate-forme se d√©veloppe tr√®s activement (la base de code s'√©l√®ve actuellement √† environ 2 770 000 lignes de code, √† l'exclusion des lignes vides), et nous n'avons pas fait d'analyse de ce projet depuis longtemps.  Cependant, il n'y a pas autant d'erreurs critiques, √† savoir qu'elles int√©ressent l'article.  Et oui, il y a pas mal de tests √† Roslyn que j'ai, comme d'habitude, exclus des tests. <br><br>  Je vais commencer par les erreurs V3080, avec un niveau de criticit√© moyen, dans lequel l'analyseur a d√©tect√© un acc√®s possible via une liaison nulle, mais pas dans tous les cas possibles (branches de code). <br><br>  <b>D√©r√©f√©rence nulle possible - Moyenne</b> <br><br>  V3080 D√©r√©f√©rence nulle possible.  Envisagez d'inspecter ¬´actuel¬ª.  CSharpSyntaxTreeFactoryService.PositionalSyntaxReference.cs 70 <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SyntaxNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SyntaxNode root)</span></span></span><span class="hljs-function"> </span></span>{ var current = root; .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current.FullSpan.Contains(....)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... var nodeOrToken = current.ChildThatContainsPosition(....); .... current = nodeOrToken.AsNode(); // &lt;= } .... } public SyntaxNode AsNode() { if (_token != null) { return null; } return _nodeOrParent; }</span></span></code> </pre> <br>  Consid√©rez la m√©thode <i>GetNode</i> .  L'analyseur consid√®re que l'acc√®s par r√©f√©rence nulle est possible dans l'√©tat du bloc <i>while</i> .  Dans le corps du bloc <i>while</i> , la variable <i>courante se</i> verra attribuer une valeur - le r√©sultat de l'ex√©cution de la m√©thode <i>AsNode</i> .  Et cette valeur dans certains cas sera <i>nulle</i> .  Un bon exemple d'analyse interproc√©durale en action. <br><br>  Consid√©rons maintenant un cas similaire dans lequel l'analyse interproc√©durale a √©t√© effectu√©e via deux appels de m√©thode. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter le ¬´r√©pertoire¬ª.  CommonCommandLineParser.cs 911 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IEnumerable&lt;CommandLineSourceFile&gt; ExpandFileNamePattern(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> baseDirectory, ....) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> directory = PathUtilities.GetDirectoryName(path); .... var resolvedDirectoryPath = (directory.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-comment"><span class="hljs-comment">// &lt;= baseDirectory : FileUtilities.ResolveRelativePath(directory, baseDirectory); .... } public static string GetDirectoryName(string path) { return GetDirectoryName(path, IsUnixLikePlatform); } internal static string GetDirectoryName(string path, bool isUnixLike) { if (path != null) { .... } return null; }</span></span></code> </pre> <br>  La variable de <i>r√©pertoire</i> dans le corps de la m√©thode <i>ExpandFileNamePattern</i> obtient la valeur de la <i>m√©thode GetDirectoryName (cha√Æne)</i> .  Cela, √† son tour, renverra le r√©sultat de la <i>m√©thode GetDirectoryName</i> surcharg√©e <i>(cha√Æne, bool)</i> , dont la valeur peut √™tre <i>nulle</i> .  √âtant donn√© que plus loin dans le corps de la m√©thode <i>ExpandFileNamePattern</i> , la variable de <i>r√©pertoire</i> est utilis√©e sans v√©rifier d'abord <i>l'</i> √©galit√© <i>nulle</i> , nous pouvons parler de la l√©gitimit√© de l'avertissement par l'analyseur.  Il s'agit d'une conception potentiellement dangereuse. <br><br>  Un autre morceau de code avec l'erreur V3080, plus pr√©cis√©ment, imm√©diatement avec deux erreurs √©mises pour une ligne de code.  Ici, l'analyse interproc√©durale n'√©tait pas n√©cessaire. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter ¬´spanStartLocation¬ª.  TestWorkspace.cs 574 <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter ¬´spanEndLocationExclusive¬ª.  TestWorkspace.cs 574 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapMarkupSpans</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { .... foreach (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanStartLocation = null; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>? spanEndLocationExclusive = null; foreach (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanStartLocation == null &amp;&amp; positionInMarkup &lt;= markupSpanStart &amp;&amp; ....) { .... spanStartLocation = ....; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spanEndLocationExclusive == null &amp;&amp; positionInMarkup &lt;= markupSpanEndExclusive &amp;&amp; ....) { .... spanEndLocationExclusive = ....; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... } .... } tempMappedMarkupSpans[key]. Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextSpan( spanStartLocation.Value, <span class="hljs-comment"><span class="hljs-comment">// &lt;= spanEndLocationExclusive.Value - // &lt;= spanStartLocation.Value)); } } .... }</span></span></code> </pre> <br>  Les <i>variables</i> <i>spanStartLocation</i> et <i>spanEndLocationExclusive</i> sont de type <i>nullable int</i> et sont initialis√©es √† <i>null</i> .  Plus loin dans le code, des valeurs peuvent leur √™tre attribu√©es, mais uniquement si certaines conditions sont remplies.  Dans certains cas, leur valeur restera √©gale √† <i>null</i> .  Plus loin dans le code, ces variables sont accessibles par r√©f√©rence sans d'abord v√©rifier <i>l'</i> √©galit√© <i>nulle</i> , comme l'indique l'analyseur. <br><br>  Le code Roslyn contient un certain nombre de ces erreurs, plus de 100. Souvent, le mod√®le de ces erreurs est le m√™me.  Il existe une m√©thode g√©n√©rale qui retourne potentiellement <i>null</i> .  Le r√©sultat de cette m√©thode est utilis√© dans un grand nombre d'endroits, parfois via des dizaines d'appels de m√©thodes interm√©diaires ou des v√©rifications suppl√©mentaires.  Il est important de comprendre que ces erreurs ne sont pas fatales, mais elles peuvent potentiellement conduire √† un acc√®s via un lien nul.  Et d√©tecter de telles erreurs est tr√®s difficile.  Par cons√©quent, dans certains cas, vous devez envisager de refactoriser le code, dans lequel une exception serait lev√©e si la m√©thode retournait <i>null</i> .  Sinon, vous ne pouvez s√©curiser votre code qu'avec des contr√¥les totaux, ce qui est assez fastidieux et peu fiable.  Bien entendu, dans chaque cas, la d√©cision doit √™tre prise en fonction des caract√©ristiques du projet. <br><br>  Remarque  Il arrive qu'√† l'heure actuelle il n'y a pas de situations (donn√©es d'entr√©e) dans lesquelles la m√©thode retourne <i>null</i> et il n'y a pas de v√©ritable erreur.  Cependant, un tel code n'est toujours pas fiable, car tout peut changer lorsque des modifications sont apport√©es au code. <br><br>  Pour fermer le sujet avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3080</a> , jetons un coup d'≈ìil aux erreurs √©videntes avec le niveau de confiance √©lev√©, lorsque l'acc√®s via un lien nul est plus probable ou m√™me in√©vitable. <br><br>  <b>D√©r√©f√©rence nulle possible - √âlev√©e</b> <br><br>  V3080 D√©r√©f√©rence nulle possible.  Pensez √† inspecter 'collectionType.Type'.  AbstractConvertForToForEachCodeRefactoringProvider.cs 137 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override async Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputeRefactoringsAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeRefactoringContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... var collectionType = semanticModel.GetTypeInfo(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  En raison d'une faute de frappe dans la condition (au lieu de l'op√©rateur <i>|| que</i> nous avons utilis√© <i>&amp;&amp;</i> ), le code ne fonctionne pas du tout comme pr√©vu, et la variable <i>collectionType.Type</i> sera accessible si elle est <i>nulle</i> .  La condition doit √™tre corrig√©e comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type == null || collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Soit dit en passant, la deuxi√®me variante du d√©veloppement des √©v√©nements est √©galement possible: dans la premi√®re partie, les conditions sont m√©lang√©es par les op√©rateurs <i>==</i> et <i>! =</i> .  Le code corrig√© serait alors: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collectionType.Type != null &amp;&amp; collectionType.Type.TypeKind == TypeKind.Error) ....</code> </pre> <br>  Cette version du code est moins logique, mais corrige √©galement l'erreur.  La d√©cision finale appartient aux auteurs du projet. <br><br>  Une autre erreur similaire. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Envisagez d'inspecter ¬´l'action¬ª.  TextViewWindow_InProc.cs 372 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;IWpfTextView, Task&gt; GetLightBulbApplicationAction(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( $<span class="hljs-string"><span class="hljs-string">"Unable to find FixAll in {fixAllScope.ToString()} code fix for suggested action '{action.DisplayText}'."</span></span>); } .... }</code> </pre> <br>  Une erreur a √©t√© commise lors de la r√©daction d'un message pour une exception.  Dans le m√™me temps, une tentative d'acc√®s √† la propri√©t√© <i>action.DisplayText</i> est effectu√©e via la variable d' <i>action</i> , qui est √©videmment <i>nulle</i> . <br><br>  Et la derni√®re erreur est le V3080 High Level. <br><br>  V3080 D√©r√©f√©rence nulle possible.  Envisagez d'inspecter le ¬´type¬ª.  ObjectFormatterHelpers.cs 91 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsApplicableAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeInfo type, TypeInfo targetType, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetTypeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName; }</code> </pre> <br>  La m√©thode est petite, donc je donne tout son code.  La condition dans le bloc de <i>retour</i> est incorrecte.  Dans certains cas, il est possible de <i>lever</i> une <i>NullReferenceException</i> lors de l'acc√®s √† <i>type.FullName</i> .  J'utilise des crochets (ils ne changeront pas de comportement ici) pour clarifier la situation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type != null &amp;&amp; AreEquivalent(targetType, type)) || (targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  C'est ainsi que, selon la priorit√© des op√©rations, ce code fonctionnera.  Si la variable de <i>type</i> est <i>null</i> , nous entrons dans une v√©rification else, o√π, en nous assurant que la variable <i>targetTypeName</i> est <i>null</i> , nous utilisons la r√©f√©rence de <i>type</i> null.  Vous pouvez corriger le code, par exemple, comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type != null &amp;&amp; (AreEquivalent(targetType, type) || targetTypeName != null &amp;&amp; type.FullName == targetTypeName);</code> </pre> <br>  Je pense que c'est l√† que vous pouvez terminer l'√©tude des erreurs V3080 et voir ce que l'analyseur PVS-Studio int√©ressant a r√©ussi √† trouver dans le code Roslyn. <br><br>  <b>Typo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3005</a> La variable 'SourceCodeKind' est assign√©e √† elle-m√™me.  DynamicFileInfo.cs 17 <br><br><pre> <code class="cpp hljs">internal sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, IDocumentServiceProvider documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = filePath; SourceCodeKind = SourceCodeKind; <span class="hljs-comment"><span class="hljs-comment">// &lt;= TextLoader = textLoader; DocumentServiceProvider = documentServiceProvider; } .... }</span></span></code> </pre> <br>  En raison d'un nom de variable non r√©ussi, une faute de frappe a √©t√© effectu√©e dans le constructeur de la classe <i>DynamicFileInfo</i> .  Le <i>champ SourceCodeKind se voit</i> attribuer sa propre valeur, au lieu d'utiliser le param√®tre <i>sourceCodeKind</i> .  Pour minimiser la probabilit√© de telles erreurs, il est recommand√© d'utiliser le pr√©fixe de soulignement pour les noms de param√®tres dans de tels cas.  Je vais donner un exemple d'une version corrig√©e du code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicFileInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _filePath, SourceCodeKind _sourceCodeKind, TextLoader _textLoader, IDocumentServiceProvider _documentServiceProvider)</span></span></span><span class="hljs-function"> </span></span>{ FilePath = _filePath; SourceCodeKind = _sourceCodeKind; TextLoader = _textLoader; DocumentServiceProvider = _documentServiceProvider; }</code> </pre> <br>  <b>Insouciance</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3006</a> L'objet a √©t√© cr√©√© mais il n'est pas utilis√©.  Le mot cl√© 'throw' peut √™tre manquant: lancez une nouvelle exception InvalidOperationException (FOO).  ProjectBuildManager.cs 61 <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  Sous une certaine condition, le destructeur doit lever une exception, mais cela ne se produit pas et l'objet exception est simplement cr√©√©.  Le mot cl√© <i>throw a</i> √©t√© omis.  Version corrig√©e du code: <br><br><pre> <code class="cpp hljs">~ProjectBuildManager() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_batchBuildStarted) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"ProjectBuilderManager.Stop() not called."</span></span>); } }</code> </pre> <br>  La question de travailler avec des destructeurs en C # et d'en lever des exceptions est un sujet pour une discussion s√©par√©e, qui d√©passe le cadre de cet article. <br><br>  <b>Quand le r√©sultat n'est pas important</b> <br><br>  Un certain nombre d'avertissements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3009 ont</a> √©t√© re√ßus pour les m√©thodes qui retournent la m√™me valeur dans tous les cas.  Parfois, cela n'est pas critique, ou le code retour n'est tout simplement pas v√©rifi√© dans le code appelant.  J'ai rat√© de tels avertissements.  Mais quelques morceaux de code me semblaient suspects.  Je citerai l'un d'eux: <br><br>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  GoToDefinitionCommandHandler.cs 62 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (context.OperationContext.AddScope(....)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  La m√©thode <i>TryExecuteCommand</i> renvoie uniquement <i>true</i> et rien que <i>true</i> .  Dans le m√™me temps, la valeur de retour est impliqu√©e dans certaines v√©rifications du code appelant: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (caretPos.HasValue &amp;&amp; TryExecuteCommand(....)) { .... } .... }</code> </pre> <br>  Il est difficile de dire √† quel point ce comportement est dangereux.  Mais si le r√©sultat n'est pas n√©cessaire, il peut √™tre utile de remplacer le type de retour par void et d'apporter des modifications minimales √† la m√©thode d'appel.  Cela rendra le code plus compr√©hensible et plus s√ªr. <br><br>  Autres avertissements similaires: <br><br><ul><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  CommentUncommentSelectionCommandHandler.cs 86 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  RenameTrackingTaggerProvider.RenameTrackingCommitter.cs 99 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  JsonRpcClient.cs 138 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  AbstractFormatEngine.OperationApplier.cs 164 </li><li>  V3009 Il est √©trange que cette m√©thode retourne toujours une seule et m√™me valeur de 'false'.  TriviaDataFactory.CodeShapeAnalyzer.cs 254 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  ObjectList.cs 173 </li><li>  V3009 Il est √©trange que cette m√©thode renvoie toujours une seule et m√™me valeur de 'true'.  ObjectList.cs 249 </li></ul><br>  <b>Non v√©rifi√©</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3019 Il est</a> possible qu'une variable incorrecte soit compar√©e √† null apr√®s la conversion de type √† l'aide du mot cl√© 'as'.  V√©rifiez les variables 'value', 'valueToSerialize'.  RoamingVisualStudioProfileOptionPersister.cs 277 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryPersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptionKey optionKey, object value)</span></span></span><span class="hljs-function"> </span></span>{ .... var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != null) { value = valueToSerialize.CreateXElement().ToString(); } .... }</code> </pre> <br>  La <i>valeur de la</i> variable est de type <i>NamingStylePreferences</i> .  Le probl√®me vient de cette v√©rification.  M√™me si la variable de <i>valeur</i> n'est pas nulle, cela ne garantit pas que la conversion de type a r√©ussi et que <i>valueToSerialize</i> ne contient pas <i>null</i> .  Une <i>exception NullReferenceException peut √™tre lev√©e</i> .  Le code doit √™tre corrig√© comme suit: <br><br><pre> <code class="cpp hljs">var valueToSerialize = value as NamingStylePreferences; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valueToSerialize != null) { value = valueToSerialize.CreateXElement().ToString(); }</code> </pre> <br>  Et encore une erreur similaire. <br><br>  V3019 Il est possible qu'une variable incorrecte soit compar√©e √† null apr√®s la conversion de type √† l'aide du mot cl√© 'as'.  V√©rifiez les variables 'columnState', 'columnState2'.  StreamingFindUsagesPresenter.cs 181 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDefinitionGroupingPriority</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (var columnState in ....) { var columnState2 = columnState as ColumnState2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (columnState?.Name == <span class="hljs-comment"><span class="hljs-comment">// &lt;= StandardTableColumnDefinitions2.Definition) { newColumns.Add(new ColumnState2( columnState2.Name, // &lt;= ....)); } .... } .... }</span></span></code> </pre> <br>  La variable <i>columnState</i> est de type <i>ColumnState2</i> .  Toutefois, le r√©sultat de l'op√©ration, la variable <i>columnState2</i> , n'est pas davantage v√©rifi√© pour <i>null</i> .  Au lieu de cela, la variable <i>columnState est</i> v√©rifi√©e √† l'aide de l'instruction <i>null</i> conditionnelle.  Quel est le danger de ce code?  Comme dans l'exemple pr√©c√©dent, la <i>conversion de</i> type √† l'aide de l'op√©rateur <i>as</i> peut √©chouer et la variable <i>columnState2</i> sera <i>nulle</i> , ce qui <i>g√©n√©rera</i> une exception.  Soit dit en passant, une faute de frappe peut √™tre √† bl√¢mer.  Notez la condition dans le bloc <i>if</i> .  Peut-√™tre qu'au lieu de <i>columnState? .Name,</i> ils voulaient √©crire <i>columnState2? .Name</i> .  Cela est tr√®s probable compte tenu des noms de variables plut√¥t malheureux <i>columnState et columnState2.</i> <br><br>  <b>Contr√¥les redondants</b> <br><br>  Un nombre assez √©lev√© d'avertissements (plus de 100) ont √©t√© √©mis pour des constructions non critiques, mais potentiellement dangereuses associ√©es √† des contr√¥les redondants.  Par exemple, je vais en donner un. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3022 L'</a> expression 'navInfo == null' est toujours fausse.  AbstractSyncClassViewCommandHandler.cs 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... IVsNavInfo navInfo = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol != null) { navInfo = libraryService.NavInfoFactory.CreateForSymbol(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) { navInfo = libraryService.NavInfoFactory.CreateForProject(....); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (navInfo == null) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { return true; } .... } public IVsNavInfo CreateForSymbol(....) { .... return null; } public IVsNavInfo CreateForProject(....) { return new NavInfo(....); }</span></span></code> </pre> <br>  Il n'y a peut-√™tre pas de v√©ritable erreur ici.  Juste une bonne raison de d√©montrer la combinaison des technologies ¬´analyse interproc√©durale + analyse de flux de donn√©es¬ª en action.  L'analyseur consid√®re que la deuxi√®me v√©rification <i>navInfo == null est</i> redondante.  En effet, avant cela, la valeur d'affectation de <i>navInfo</i> sera obtenue √† partir de la m√©thode <i>libraryService.NavInfoFactory.CreateForProject</i> , qui va construire et retourner un nouvel objet de la classe <i>NavInfo</i> .  Mais pas <i>nul</i> en aucune fa√ßon.  La question est, pourquoi l'analyseur n'a-t-il pas <i>g√©n√©r√© d'</i> avertissement pour la premi√®re v√©rification <i>navInfo == null</i> ?  Il y a une explication √† cela.  Premi√®rement, si la variable de <i>symbole</i> s'av√®re <i>nulle</i> , la valeur de <i>navInfo</i> restera une r√©f√©rence nulle.  Deuxi√®mement, m√™me si <i>navInfo</i> obtient la valeur de la m√©thode <i>libraryService.NavInfoFactory.CreateForSymbol</i> , cette valeur peut √™tre <i>nulle</i> .  La premi√®re v√©rification de <i>navInfo == null est donc</i> vraiment n√©cessaire. <br><br>  <b>Pas assez de contr√¥les</b> <br><br>  Et maintenant, la situation est l'inverse de ce qui pr√©c√®de.  Plusieurs avertissements <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3042</a> ont √©t√© re√ßus pour le code accessible par une r√©f√©rence nulle.  De plus, seulement un ou deux petits ch√®ques pouvaient tout r√©parer. <br><br>  Consid√©rez un morceau de code int√©ressant qui contient deux de ces erreurs. <br><br>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'r√©cepteur' Binder_Expressions.cs 7770 <br><br>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'r√©cepteur' Binder_Expressions.cs 7776 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != <span class="hljs-comment"><span class="hljs-comment">// &lt;= GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver.Type; // &lt;= if (receiverType?.IsNullableType() == true) { .... } receiver = new BoundConditionalReceiver(receiver.Syntax, 0, // &lt;= receiverType ?? CreateErrorType(), hasErrors: receiver.HasErrors) // &lt;= { WasCompilerGenerated = true }; return receiver; }</span></span></code> </pre> <br>  La variable <i>r√©cepteur</i> peut √™tre <i>nulle</i> .  L'auteur du code le sait car il utilise l'op√©rateur <i>nul</i> conditionnel dans la condition du bloc <i>if</i> pour acc√©der au <i>r√©cepteur? .Syntax</i> .  Plus loin dans le code, le <i>r√©cepteur</i> variable <i>est</i> utilis√© sans aucun contr√¥le pour acc√©der √† <i>receiver.Type</i> , <i>receiver.Syntax</i> et <i>receiver.HasErrors</i> .  Ces erreurs doivent √™tre corrig√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BoundExpression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceiverForConditionalBinding</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ExpressionSyntax binding, DiagnosticBag diagnostics)</span></span></span><span class="hljs-function"> </span></span>{ .... BoundExpression receiver = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ConditionalReceiverExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiver?.Syntax != GetConditionalReceiverSyntax(conditionalAccessNode)) { receiver = BindConditionalAccessReceiver(conditionalAccessNode, diagnostics); } var receiverType = receiver?.Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (receiverType?.IsNullableType() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { .... } receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BoundConditionalReceiver(receiver?.Syntax, <span class="hljs-number"><span class="hljs-number">0</span></span>, receiverType ?? CreateErrorType(), hasErrors: receiver?.HasErrors) { WasCompilerGenerated = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> receiver; }</code> </pre> <br>  Vous devez √©galement vous assurer que le constructeur <i>BoundConditionalReceiver</i> prend en charge l'obtention de valeurs <i>nulles</i> pour ses param√®tres, ou effectuer un refactoring suppl√©mentaire. <br><br>  Autres erreurs similaires: <br><br><ul><li>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'containerType' SyntaxGeneratorExtensions_Negate.cs 240 </li><li>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'expression' ExpressionSyntaxExtensions.cs 349 </li><li>  V3042 Exception NullReferenceException possible.  Le '?.'  et '.'  les op√©rateurs sont utilis√©s pour acc√©der aux membres de l'objet 'expression' ExpressionSyntaxExtensions.cs 349 </li></ul><br>  <b>Erreur de condition</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3057</a> La fonction 'Sous-cha√Æne' pourrait recevoir la valeur '-1' alors qu'une valeur non n√©gative est attendue.  Inspectez le deuxi√®me argument.  CommonCommandLineParser.cs 109 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryParseOption</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = arg.Substring(<span class="hljs-number"><span class="hljs-number">1</span></span>, colon - <span class="hljs-number"><span class="hljs-number">1</span></span>); value = arg.Substring(colon + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Si la variable <i>deux</i> - <i>points</i> est 0, ce qui autorise une condition dans le code, la m√©thode <i>Substring l√®vera</i> une <i>ArgumentOutOfRangeException</i> .  Correction requise: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (colon &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  <b>La faute de frappe est possible</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3065 Le</a> param√®tre 't2' n'est pas utilis√© dans le corps de la m√©thode.  CSharpCodeGenerationHelpers.cs 84 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeDeclarationSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceUnterminatedConstructs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var updatedToken = lastToken.ReplaceTrivia(lastToken.TrailingTrivia, (t1, t2) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.MultiLineCommentTrivia) { var text = t1.ToString(); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t1.Kind() == SyntaxKind.SkippedTokensTrivia) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReplaceUnterminatedConstructs(t1); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1; }); .... }</code> </pre> <br>  Deux param√®tres sont pass√©s √† l'expression lambda: t1 et t2.  Cependant, seul t1 est utilis√©.  Cela semble suspect, compte tenu de la facilit√© avec laquelle il est possible de se tromper lors de l'utilisation de variables portant ces noms. <br><br>  <b>Insouciance</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3083 Invocation</a> non <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">s√ªre</a> de l'√©v√©nement 'TagsChanged', NullReferenceException est possible.  Pensez √† affecter un √©v√©nement √† une variable locale avant de l'invoquer.  PreviewUpdater.Tagger.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTextBufferChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PreviewUpdater.SpanToShow != <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TagsChanged != null) { var span = _textBuffer.CurrentSnapshot.GetFullSpan(); TagsChanged(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(span)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  L'√©v√©nement <i>TagsChanged est</i> d√©clench√© de mani√®re non s√©curis√©e.  Entre la v√©rification de <i>l'</i> √©galit√© <i>nulle</i> et l'appel d'un √©v√©nement, ils peuvent avoir le temps de se d√©sinscrire, puis une exception sera lev√©e.  De plus, dans le corps du bloc <i>if</i> , juste avant l'appel de l'√©v√©nement, d'autres op√©rations sont effectu√©es.  J'ai appel√© cette erreur ¬´inattention¬ª, car √† d'autres endroits du code, ils fonctionnent avec plus de pr√©cision avec cet √©v√©nement, par exemple, comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnTrackingSpansChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leafChanged)</span></span></span><span class="hljs-function"> </span></span>{ var handler = TagsChanged; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != null) { var snapshot = _buffer.CurrentSnapshot; handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SnapshotSpanEventArgs(snapshot.GetFullSpan())); } }</code> </pre> <br>  L'utilisation de la variable de <i>gestionnaire</i> facultative √©limine le probl√®me.  Dans la m√©thode <i>OnTextBufferChanged</i> , <i>vous</i> devez apporter des modifications pour la m√™me op√©ration s√ªre avec l'√©v√©nement. <br><br>  <b>Gammes d'intersection</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3092 Les</a> intersections de plage sont possibles dans les expressions conditionnelles.  Exemple: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  ILBuilderEmit.cs 677 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue &amp;&amp; value &lt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= uint.MinValue &amp;&amp; value &lt;= uint.MaxValue) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Pour une meilleure compr√©hension, je vais r√©√©crire ce fragment de code, en rempla√ßant les noms constants par leurs valeurs r√©elles: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EmitLongConstant</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">-2147483648</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">2147483648</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; value &lt;= <span class="hljs-number"><span class="hljs-number">4294967295</span></span>) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  Probablement, il n'y a pas de v√©ritable erreur, mais la condition semble √©trange.  La deuxi√®me partie ( <i>sinon si</i> ) sera effectu√©e uniquement pour la plage de valeurs de 2147483648 + 1 √† 4294967295. <br><br>  Quelques avertissements suppl√©mentaires: <br><br><ul><li>  V3092 Les intersections de plage sont possibles dans les expressions conditionnelles.  Exemple: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 109 </li><li>  V3092 Les intersections de plage sont possibles dans les expressions conditionnelles.  Exemple: if (A&gt; 0 &amp;&amp; A &lt;5) {...} else if (A&gt; 3 &amp;&amp; A &lt;9) {...}.  LocalRewriter_Literal.cs 66 </li></ul><br>  <b>En savoir plus sur les contr√¥les d'√©galit√© nulle (ou leur absence)</b> <br><br>  Quelques erreurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V3095</a> sur la v√©rification de la <i>null d'</i> une variable apr√®s <i>l'</i> avoir utilis√©e.  Le premier est ambigu, consid√©rez le code. <br><br>  V3095 L'objet 'displayName' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 498, 503. FusionAssemblyIdentity.cs 498 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IAssemblyName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToAssemblyNameObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> displayName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (displayName.IndexOf(<span class="hljs-string"><span class="hljs-string">'\0'</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } Debug.Assert(displayName != null); .... }</code> </pre> <br>  Il est suppos√© que la r√©f√©rence <i>displayName</i> peut √™tre nulle.  Pour ce faire, v√©rifiez <i>Debug.Assert</i> .  On ne sait pas pourquoi il va apr√®s avoir utilis√© la cha√Æne.  Il convient √©galement de <i>noter</i> que pour d'autres configurations autres que Debug, le compilateur <i>supprimera Debug.Assert</i> du code.  Est-ce √† dire que ce n'est que pour le d√©bogage qu'il est possible d'obtenir une r√©f√©rence nulle?  Et si ce n'est pas le cas, alors pourquoi ne pas v√©rifier <i>string.IsNullOrEmpty (string)</i> , par exemple.  Ce sont des questions pour les auteurs du code. <br><br>  L'erreur suivante est plus √©vidente. <br><br>  V3095 L'objet 'scriptArgsOpt' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 321, 325. CommonCommandLineParser.cs 321 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt.Add(arg); <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; } if (scriptArgsOpt != null) { .... } .... } }</span></span></code> </pre> <br>  Je pense que ce morceau de code ne n√©cessite aucune explication.  Je vais donner la version corrig√©e: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FlattenArgs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., List&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; scriptArgsOpt, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (args.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parsingScriptArgs) { scriptArgsOpt?.Add(arg); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scriptArgsOpt != null) { .... } .... } }</code> </pre> <br>  Le code Roslyn a trouv√© 15 autres erreurs de ce type: <br><br><ul><li>  V3095 L'objet 'LocalFunctions' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 289, 317. ControlFlowGraphBuilder.RegionBuilder.cs 289 </li><li>  V3095 L'objet 'resolution.OverloadResolutionResult' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 579, 588. Binder_Invocation.cs 579 </li><li>  V3095 L'objet 'resolution.MethodGroup' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 592, 621. Binder_Invocation.cs 592 </li><li>  V3095 L'objet 'touchedFilesLogger' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 111, 126. CSharpCompiler.cs 111 </li><li>  V3095 L'objet 'newExceptionRegionsOpt' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 736, 743. AbstractEditAndContinueAnalyzer.cs 736 </li><li>  V3095 L'objet 'symbole' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 422, 427. AbstractGenerateConstructorService.Editor.cs 422 </li><li>  V3095 L'objet '_state.BaseTypeOrInterfaceOpt' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 132, 140. AbstractGenerateTypeService.GenerateNamedType.cs 132 </li><li>  V3095 L'objet 'element' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 232, 233. ProjectUtil.cs 232 </li><li>  V3095 L'objet 'languages' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 22, 28. ExportCodeCleanupProvider.cs 22 </li><li>  V3095 L'objet 'memberType' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null.  V√©rifiez les lignes: 183, 184. SyntaxGeneratorExtensions_CreateGetHashCodeMethod.cs 183 </li><li>  V3095 L'objet 'validTypeDeclarations' a √©t√© utilis√© avant d'√™tre v√©rifi√© par rapport √† null. Check lines: 223, 228. SyntaxTreeExtensions.cs 223 </li><li> V3095 The 'text' object was used before it was verified against null. Check lines: 376, 385. MSBuildWorkspace.cs 376 </li><li> V3095 The 'nameOrMemberAccessExpression' object was used before it was verified against null. Check lines: 206, 223. CSharpGenerateTypeService.cs 206 </li><li> V3095 The 'simpleName' object was used before it was verified against null. Check lines: 83, 85. CSharpGenerateMethodService.cs 83 </li><li> V3095 The 'option' object was used before it was verified against null. Check lines: 23, 28. OptionKey.cs 23 </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rez les erreurs de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ici, nous utilisons l'op√©rateur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nul</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conditionnel </font><font style="vertical-align: inherit;">lors de l'initialisation de la variable, et ci-apr√®s dans le code, la variable est utilis√©e sans v√©rifier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √©galit√© </font><i><font style="vertical-align: inherit;">nulle</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'erreur suivante est signal√©e imm√©diatement par deux avertissements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 'documentId' a √©t√© utilis√©e apr√®s son affectation via un op√©rateur conditionnel nul. NullReferenceException est possible. CodeLensReferencesService.cs 138 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 'documentId' a √©t√© utilis√©e apr√®s avoir √©t√© affect√©e via l'op√©rateur de condition nulle. NullReferenceException est possible. CodeLensReferencesService.cs 139</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;ReferenceLocationDescriptor&gt; GetDescriptorOfEnclosingSymbolAsync(....) { .... var documentId = solution.GetDocument(location.SourceTree)?.Id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId.ProjectId.Id, documentId.Id, ....); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentId</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut √™tre initialis√©e √† </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par cons√©quent, la cr√©ation du </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReferenceLocationDescriptor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finira par lever une exception. </font><font style="vertical-align: inherit;">Le code doit √™tre corrig√©:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReferenceLocationDescriptor( .... documentId?.ProjectId.Id, documentId?.Id, ....);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, plus loin dans le code, il est n√©cessaire de pr√©voir la possibilit√© d'√©galit√© des </font><font style="vertical-align: inherit;">variables </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulles</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pass√©es au constructeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autres erreurs similaires dans le code:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 'symbol' a √©t√© utilis√©e apr√®s avoir √©t√© affect√©e via un op√©rateur conditionnel nul. </font><font style="vertical-align: inherit;">NullReferenceException est possible. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 44</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3105 La variable 'symbol' a √©t√© utilis√©e apr√®s avoir √©t√© affect√©e via un op√©rateur conditionnel nul. </font><font style="vertical-align: inherit;">NullReferenceException est possible. </font><font style="vertical-align: inherit;">SymbolFinder_Hierarchy.cs 51</font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Priorit√©s et crochets </font></font></b> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3123</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'op√©rateur ¬´?:¬ª </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Fonctionne</font></a><font style="vertical-align: inherit;"> peut-√™tre d'une mani√®re diff√©rente de celle attendue. Sa priorit√© est inf√©rieure √† la priorit√© des autres op√©rateurs dans son √©tat. Edit.cs 70</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edit&lt;TNode&gt; other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; (_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode) &amp;&amp; (_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La condition dans le bloc de retour n'est pas du tout calcul√©e comme le pensait le d√©veloppeur. </font><font style="vertical-align: inherit;">Il a √©t√© suppos√© que la premi√®re condition serait </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d (par cons√©quent, l'habillage de ligne a √©t√© effectu√© apr√®s cette condition), puis les blocs de condition avec l'op√©rateur " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">Seraient calcul√©s s√©quentiellement </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En fait, la premi√®re condition sera </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_kind == other._kind &amp;&amp; (_oldNode == null)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela est d√ª au fait que l'op√©rateur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a une priorit√© plus √©lev√©e que l'op√©rateur " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font><font style="vertical-align: inherit;">Pour corriger l'erreur, il est n√©cessaire de mettre entre crochets toutes les expressions de l'op√©rateur " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ":</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _kind == other._kind &amp;&amp; ((_oldNode == null) ? other._oldNode == null : _oldNode.Equals(other._oldNode)) &amp;&amp; ((_newNode == null) ? other._newNode == null : _newNode.Equals(other._newNode));</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ceci conclut la description des erreurs trouv√©es. </font></font><br><br>  <b>Conclusions</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© le nombre important d'erreurs que j'ai pu d√©tecter, en termes de taille du code du projet Roslyn (2 770 000 lignes), ce sera un montant assez faible. Comme Andrei dans l'article pr√©c√©dent, je suis √©galement pr√™t √† reconna√Ætre la haute qualit√© de ce projet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je tiens √† noter que ces v√©rifications de code occasionnelles n'ont rien √† voir avec la m√©thodologie de l'analyse statique et n'apportent pratiquement aucun avantage. L'analyse statique doit √™tre appliqu√©e r√©guli√®rement, et non au cas par cas. Ensuite, de nombreuses erreurs seront corrig√©es d√®s les premi√®res √©tapes et, par cons√©quent, le co√ªt de leur correction sera dix fois moins √©lev√©. Cette id√©e est d√©crite plus en d√©tail dans ce petit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que je vous demande de vous familiariser avec.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez rechercher ind√©pendamment d'autres erreurs √† la fois dans le projet consid√©r√© et dans tout autre. </font><font style="vertical-align: inherit;">Pour ce faire, il vous suffit de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√©l√©charger</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et d'essayer notre analyseur.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Sergey Khrenov. </font></font> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V√©rification du code source de Roslyn</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446592/">https://habr.com/ru/post/fr446592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446578/index.html">Langage de programmation bas√© sur une carte postale</a></li>
<li><a href="../fr446582/index.html">R√©flexions sur l'h√©bergement solaire pour les abeilles</a></li>
<li><a href="../fr446586/index.html">Param√®tres r√©seau de FreeRadius via DHCP</a></li>
<li><a href="../fr446588/index.html">V√©rification du code source de Roslyn</a></li>
<li><a href="../fr446590/index.html">39 nouvelles fonctionnalit√©s disponibles dans Java 12</a></li>
<li><a href="../fr446598/index.html">Recr√©ation de polices CRT</a></li>
<li><a href="../fr446602/index.html">Transistor √† effet de champ √† courant continu maximal</a></li>
<li><a href="../fr446604/index.html">ESET: Nouveaux sch√©mas de livraison de porte d√©rob√©e OceanLotus Cybergroup</a></li>
<li><a href="../fr446606/index.html">V√©rifiez √† quel point vous √™tes bon en technologie additive</a></li>
<li><a href="../fr446608/index.html">Surmonter la troisi√®me loi de la gravit√© organisationnelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>