<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõãÔ∏è üë®üèø‚Äç‚öïÔ∏è üîµ Escribimos un traductor simple en Lisp - III üöÖ üßîüèΩ ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Art√≠culo anterior 

 Errores, errores, errores ... 
 Un buen programa debe estar protegido de los errores del usuario. Esto es absolutamente cierto. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos un traductor simple en Lisp - III</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423663/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art√≠culo anterior</a> <br><br><h3>  Errores, errores, errores ... </h3><br>  Un buen programa debe estar protegido de los errores del usuario.  Esto es absolutamente cierto.  Los errores deben ser manejados e incluso mejor advertidos (¬°prevenir es siempre mejor que curar!).  Acrobacias a√©reas: construya un di√°logo con el usuario para que este √∫ltimo simplemente no pueda cometer un error. <br><a name="habracut"></a><br>  Por ejemplo, si el usuario necesita ingresar un n√∫mero entero positivo en el campo de entrada, entonces, por supuesto, puede analizar la respuesta y, si encuentra caracteres no num√©ricos, dar una advertencia y pedirle al usuario que repita la entrada.  ¬°Pero es mucho mejor simplemente prohibir caracteres no num√©ricos! <br><br>  Desafortunadamente, tal t√©cnica no siempre se puede aplicar.  En particular, la variedad de dise√±os que ingresan la entrada del traductor es demasiado grande para simplemente "cortar los incorrectos" configurando la m√°scara de entrada. <br><br>  Una persona tiene el privilegio de cometer errores, y el traductor debe, en el caso de ingresar construcciones de lenguaje incorrectas, dar un diagn√≥stico claro y, si es posible, continuar analizando el texto fuente para identificar todos los errores.  Probablemente al usuario no le gustar√° realmente si el traductor detecta los errores "uno a la vez".  Y es absolutamente inaceptable reconocer una situaci√≥n en la que un programa "falla" con un mensaje de error del sistema. <br>  En este art√≠culo, revisaremos cr√≠ticamente el c√≥digo previamente desarrollado e intentaremos evitar (procesar) posibles errores. <br><br>  Comencemos con la primera funci√≥n de inicio.  Que esta haciendo ella  Toma el nombre del archivo de entrada, lo abre y procesa l√≠nea por l√≠nea.  Para tales programas, el escenario de interacci√≥n del usuario ya se ha "establecido"; puede considerarse can√≥nico: <br><br><ul><li>  Si no se especifica el nombre del archivo, llame al cuadro de di√°logo est√°ndar "Abrir"; </li><li>  Si el usuario hizo clic en el bot√≥n "rechazar" en el cuadro de di√°logo "Abrir", cierre; </li><li>  Verifique si el archivo con el nombre dado / ingresado existe.  Si no existe, emita un mensaje y salga; </li><li>  Si el archivo especificado existe, procesarlo. </li></ul><br>  Nuestra versi√≥n del procedimiento de inicio no satisface este escenario.  De hecho, mira el siguiente c√≥digo: <br><br><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶) <span class="hljs-comment"><span class="hljs-comment">;;      (when (zerop (strLen fname)) (setq fname (sysGetOpenName (sysHome) "-|*.mbs"))) (let ((fi (gensym 'fi))) (filOpen fi fname _INPUT) (loop (let ((curr-proc (action-proc fi))) (when *flagerr* (return t)) (when (filEOF fi) (return t)) (eval curr-proc))) (filClose fi)) (when *flagerr* (printsline "****   ")))</span></span></code> </pre> <br>  La respuesta negativa del usuario no se analiza, por lo que si se presiona el bot√≥n "rechazar", el programa se "bloquear√°".  La existencia del archivo tampoco se analiza.  Lamentablemente, este defecto no se limita a las deficiencias.  Obviamente, si el procedimiento mini-b√°sico es el √∫ltimo en el archivo de entrada, el an√°lisis del final del archivo har√° que el ciclo se rompa antes de que la funci√≥n generada se cargue en el entorno Lisp. <br><br>  Corrija estos defectos: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶ ) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">when</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*))</code> </pre><br>  Si se especifica el nombre del archivo y el archivo existe, se realiza el procesamiento.  De lo contrario, se imprime uno de los mensajes: "El archivo no existe" o "Nombre de archivo omitido". <br>  Las siguientes acciones se realizan secuencialmente en el cuerpo del bucle principal: <br><br><ul><li>  La funci√≥n action-proc se cumple.  El resultado de su trabajo se almacena en la variable local curr-proc; </li><li>  Si se levanta la bandera * flagerr *, el bucle se rompe; </li><li>  Si la funci√≥n action-proc devolvi√≥ un resultado no vac√≠o, la funci√≥n generada se carga en el entorno Lisp; </li><li>  Si se alcanza el final del archivo, el ciclo tambi√©n se rompe. </li></ul><br>  El c√≥digo parec√≠a ser mejor ... Pero otra falla grave permaneci√≥ sin resolver: despu√©s de que se complete el procesamiento del procedimiento que contiene uno o m√°s errores, el bucle principal se interrumpir√° y el programa finalizar√° sin mirar la parte del a√±o original ubicada detr√°s del procedimiento con errores.  Esto es malo: me gustar√≠a que el traductor produzca todos los errores que se pueden detectar en cada inicio. <br><br>  Para corregir este defecto, introduzcamos la variable global "contador de errores", mientras procesamos el procedimiento con errores, aumentaremos este contador.  Y el indicador de error se restablecer√° despu√©s de procesar cada procedimiento: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start (<span class="hljs-name"><span class="hljs-name">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">fname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* ‚Ä¶) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">zerop</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> fname (<span class="hljs-name"><span class="hljs-name">sysGetOpenName</span></span> (<span class="hljs-name"><span class="hljs-name">sysHome</span></span>) <span class="hljs-string"><span class="hljs-string">"-|*.mbs"</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> fname (<span class="hljs-name"><span class="hljs-name">filExistp</span></span> fname)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">fi</span></span> (<span class="hljs-name"><span class="hljs-name">gensym</span></span> 'fi))) (<span class="hljs-name"><span class="hljs-name">filCloseAll</span></span>) (<span class="hljs-name"><span class="hljs-name">filOpen</span></span> fi fname _INPUT) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">curr-proc</span></span> (<span class="hljs-name"><span class="hljs-name">action-proc</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> *flagerr* (<span class="hljs-name"><span class="hljs-name">setq</span></span> *errcount* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *errcount*))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> curr-proc (<span class="hljs-name"><span class="hljs-name">not</span></span> *flagerr*)) (<span class="hljs-name"><span class="hljs-name">eval</span></span> curr-proc)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEOF</span></span> fi) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">filClose</span></span> fi) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> *errcount* <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> fname (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> fname <span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-string"><span class="hljs-string">"****   "</span></span>))) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*numline*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*flagerr*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*oplist*) (<span class="hljs-name"><span class="hljs-name">unset</span></span> '*errcount*))</code> </pre><br>  Ahora, la funci√≥n de inicio funcionar√° aceptable.  Asegur√©monos de esto.  Cree el siguiente archivo fuente: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> bla-bla end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> bla-bla-bla print x end_proc</code> </pre><br>  Y "d√©jalo pasar" a trav√©s de nuestro traductor.  Obtenemos: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=x^<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0007</span></span> bla-bla ****  (BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0008</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-number"><span class="hljs-number">0010</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0011 * 0012 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0013</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0014</span></span> input x <span class="hljs-number"><span class="hljs-number">0015</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0016</span></span> print y <span class="hljs-number"><span class="hljs-number">0017</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-number"><span class="hljs-number">0019</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0020 * 0021 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0022</span></span> bla-bla-bla ****  (BLA - BLA - BLA) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0023</span></span> print x <span class="hljs-number"><span class="hljs-number">0024</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0025</span></span> ****   </code> </pre><br>  Asumimos que nos enfrentamos con la funci√≥n de inicio.  Pero el "trabajo sobre los errores" acaba de comenzar.  Veamos la sintaxis de esa parte del lenguaje que ya hemos implementado. <br><br>  Probablemente, el error de sintaxis m√°s com√∫n que las personas hacen con mayor frecuencia es una estructura de par√©ntesis incorrecta (par√©ntesis desequilibrados o en el orden incorrecto).  Recuerde lo que le sucede a una l√≠nea de c√≥digo fuente para un programa mini-b√°sico despu√©s de leerlo.  La cadena se analiza (se divide en tokens) y luego la lista de tokens se traduce en un formulario de lista interna.  En la lista de tokens, los par√©ntesis son tokens separados y no verificamos su saldo.  Esto podr√≠a hacerse como una funci√≥n separada, pero la lista de tokens se transmite a la entrada de la funci√≥n de entrada, que traduce la lista de l√≠neas en la lista Lisp.  Si se pasa una expresi√≥n de cadena incorrecta a la entrada de la funci√≥n de entrada, la funci√≥n devolver√° un error. <br><br>  Manejemos este error. <br><br>  En HomeLisp, se utiliza una construcci√≥n para manejar errores (pruebe Expression-1 excepto Expression-1).  Funciona de la siguiente manera: <br><br><ul><li>  Se intenta calcular la Expresi√≥n-1.  Si el intento es exitoso, el resultado del c√°lculo se devuelve como el resultado del formulario de prueba completo; </li><li>  Si se produce un error, se calcula la Expresi√≥n-2.  Al mismo tiempo, est√° disponible una funci√≥n del sistema sin par√°metros (mensaje de error), que devuelve el texto del mensaje de error. </li></ul><br>  Con base en lo anterior, la transferencia al formulario de lista se puede emitir de la siguiente manera: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> txt <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>)) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  En caso de un error de conversi√≥n, se emitir√° un mensaje del sistema y, como resultado, se devolver√° una lista de un elemento: la l√≠nea de c√≥digo original.  Adem√°s, esta lista caer√° (como la siguiente declaraci√≥n) en el procedimiento action-proc.  Y, por supuesto, no ser√° reconocido.  Esto generar√° otro mensaje de error y el compilador continuar√° funcionando.  Prepararemos el siguiente c√≥digo fuente e intentaremos traducirlo: <br><br><pre> <code class="hljs 1c">* * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> local y y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> local x,y input x y=test1(x) print y end_proc * * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> print x end_proc</code> </pre><br>  Obtenemos el resultado esperado: <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0001</span></span> * <span class="hljs-number"><span class="hljs-number">0002</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0003 * 0004 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test1</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0005</span></span> local y <span class="hljs-number"><span class="hljs-number">0006</span></span> y=(x^<span class="hljs-number"><span class="hljs-number">2</span></span>)) ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"y=(x^2))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0007</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0008</span></span> * <span class="hljs-number"><span class="hljs-number">0009</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0010 * 0011 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-function">()</span></span> <span class="hljs-number"><span class="hljs-number">0012</span></span> local x,y <span class="hljs-number"><span class="hljs-number">0013</span></span> input x <span class="hljs-number"><span class="hljs-number">0014</span></span> y=test1(x) <span class="hljs-number"><span class="hljs-number">0015</span></span> print y <span class="hljs-number"><span class="hljs-number">0016</span></span> end_proc <span class="hljs-number"><span class="hljs-number">0017</span></span> * <span class="hljs-number"><span class="hljs-number">0018</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword"></span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title"></span></span></span><span class="hljs-function"> 0019 * 0020 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test3</span></span></span><span class="hljs-function">(x)</span></span> <span class="hljs-number"><span class="hljs-number">0021</span></span> x=<span class="hljs-number"><span class="hljs-number">3</span></span>+)x^<span class="hljs-number"><span class="hljs-number">2</span></span> ****    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-type"><span class="hljs-type"></span></span> ****  (<span class="hljs-string"><span class="hljs-string">"x=3+)x^2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">0022</span></span> print x <span class="hljs-number"><span class="hljs-number">0023</span></span> end_proc ****   </code> </pre><br>  Ahora echemos un vistazo cr√≠tico al c√≥digo que convierte las expresiones aritm√©ticas en una notaci√≥n de prefijo.  Este c√≥digo no contiene ning√∫n medio para corregir los errores del usuario.  Desafortunadamente, estos errores pueden ser bastante.  Arreglemos este error.  Para comenzar, intentemos traducir un c√≥digo completamente inocente (en apariencia): <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=6 y=-x <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> y end_proc</code> </pre><br>  ¬°La transmisi√≥n terminar√° con la "ca√≠da" del traductor!  Una ca√≠da causar√° el operador y = -x.  Cual es el problema  En un unario menos!  Al convertir una f√≥rmula de una forma de infijo a una de prefijo, de alguna manera no pensamos que menos "dos caras" - hay un binario menos (un signo de operaci√≥n), y hay un menos unario (un signo de un n√∫mero).  Nuestro analizador no conoce esta diferencia: considera que todos los inconvenientes son binarios ... ¬øQu√© hacer ahora?  Para no destruir el c√≥digo que ya funciona, vamos a convertir todos los inconvenientes unarios en binarios.  Como?  Pero muy simple.  Es bastante obvio que el unario menos "vive" solo en tales construcciones: <br><br>  "(-Algo" <br>  "&gt; -Algo" <br>  "&lt;-Algo" <br>  "= Algo" <br>  Bueno, al comienzo de la f√≥rmula, tambi√©n puede encontrarse.  Por lo tanto, si, antes de dividir en tokens, realizamos los siguientes reemplazos: <br><br>  "(-Algo" =&gt; "(0-algo" <br>  "&gt; -Algo" =&gt; "&gt; 0-algo" <br>  "&lt;-Algo" =&gt; "&lt;0-algo" <br>  ‚Äú= Algo‚Äù =&gt; ‚Äú= 0 algo‚Äù <br><br>  y si la f√≥rmula comienza con un signo menos, asignamos cero al comienzo de la f√≥rmula, entonces todas las desventajas se volver√°n binarias y el error se eliminar√° radicalmente.  Llamemos a la funci√≥n que realizar√° la conversi√≥n sobre el nombre prepro.  As√≠ es como podr√≠a verse: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> prepro (<span class="hljs-name"><span class="hljs-name">s</span></span>) (<span class="hljs-name"><span class="hljs-name">let*</span></span> ((<span class="hljs-name"><span class="hljs-name">s0</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> s <span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> s) s)) (<span class="hljs-name"><span class="hljs-name">s1</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s0 <span class="hljs-string"><span class="hljs-string">"(-"</span></span> <span class="hljs-string"><span class="hljs-string">"(0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s2</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s1 <span class="hljs-string"><span class="hljs-string">"=-"</span></span> <span class="hljs-string"><span class="hljs-string">"=0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s3</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s2 <span class="hljs-string"><span class="hljs-string">"&gt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;0-"</span></span>)) (<span class="hljs-name"><span class="hljs-name">s4</span></span> (<span class="hljs-name"><span class="hljs-name">strRep</span></span> s3 <span class="hljs-string"><span class="hljs-string">"&lt;-"</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;0-"</span></span>))) s4))</code> </pre><br>  No se requieren comentarios especiales aqu√≠.  Pero nuestro analizador simple tiene otro problema que no es del todo evidente a primera vista: dos signos de operaciones.  Cuando se trabaja con f√≥rmulas, los signos "&gt;" y "=" parados uno al lado del otro significan una operaci√≥n "&gt; =" (¬°y debe ser una ficha!).  El analizador no quiere saber esto, har√° que cada uno de los signos sea una ficha separada.  Puede hacer frente a este problema mirando la lista de tokens recibidos, y si los caracteres correspondientes est√°n uno al lado del otro, combin√°ndolos.  Nombramos la funci√≥n que realizar√° la uni√≥n con el nombre "postpro".  Aqu√≠ est√° el c√≥digo para una posible implementaci√≥n: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> postpro (<span class="hljs-name"><span class="hljs-name">lex-list</span></span>) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)) lex-list) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">c1</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> lex-list)) (<span class="hljs-name"><span class="hljs-name">c2</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> lex-list))) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"="</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"!"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) ((<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> c1 <span class="hljs-string"><span class="hljs-string">"/"</span></span>) (<span class="hljs-name"><span class="hljs-name">eq</span></span> c2 <span class="hljs-string"><span class="hljs-string">"="</span></span>)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-string"><span class="hljs-string">"/="</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> lex-list)))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> c1 (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> lex-list)))))))))</code> </pre><br>  Adem√°s, como vemos, nada especial.  Pero ahora la funci√≥n final de traducir el operador al formulario de lista interna se ver√° as√≠: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> mk-intf (<span class="hljs-name"><span class="hljs-name">txt</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">lex</span></span> (<span class="hljs-name"><span class="hljs-name">postpro</span></span> (<span class="hljs-name"><span class="hljs-name">parser</span></span> (<span class="hljs-name"><span class="hljs-name">prepro</span></span> txt) <span class="hljs-string"><span class="hljs-string">" ,"</span></span> <span class="hljs-string"><span class="hljs-string">"()+-*/\^=&lt;&gt;%"</span></span>))) (<span class="hljs-name"><span class="hljs-name">intf</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in lex) (<span class="hljs-name"><span class="hljs-name">setq</span></span> intf (<span class="hljs-name"><span class="hljs-name">strCat</span></span> intf a <span class="hljs-string"><span class="hljs-string">" "</span></span>))) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">input</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> intf <span class="hljs-string"><span class="hljs-string">")"</span></span>)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) `(,txt) ))))</code> </pre><br>  Ahora echemos un vistazo cr√≠tico a la funci√≥n inf2ipn.  ¬øQu√© errores del usuario pueden "culparlo"?  Ya hemos cortado el desequilibrio de los corchetes de arriba.  ¬øQu√© podr√≠a ser m√°s?  Dos signos de operaci√≥n o dos operandos, de pie en una fila.  Uno podr√≠a analizar esto en el c√≥digo inf2ipn (y aquellos que lo deseen pueden hacerlo por su cuenta).  "Capturamos" estos errores en la etapa de convertir la f√≥rmula del SCR al prefijo uno.  Y vamos (por si acaso) detectaremos todos los errores que puedan surgir en el proceso de convertir la f√≥rmula de infijo a prefijo.  El mejor lugar para esto es la funci√≥n de envoltura i2p.  Ahora podr√≠a verse as√≠: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> i2p (<span class="hljs-name"><span class="hljs-name">f</span></span>) (<span class="hljs-name"><span class="hljs-name">try</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> f)) except (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"**** "</span></span> (<span class="hljs-name"><span class="hljs-name">errormessage</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  Y ahora evitaremos la aparici√≥n en las f√≥rmulas de dos signos de operaci√≥n o dos operandos seguidos.  El art√≠culo anterior describi√≥ un algoritmo para traducir una f√≥rmula de un SCR a una forma de prefijo.  Una se√±al de la finalizaci√≥n correcta de este algoritmo es que en el √∫ltimo paso la pila debe contener un solo valor.  Si esto no es as√≠, entonces se ha cometido un error.  Y surge otra situaci√≥n err√≥nea en el caso cuando la funci√≥n se llama con el n√∫mero incorrecto (m√°s o menos) de par√°metros.  Estas situaciones deben ser "atrapadas": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> ipn2pref (<span class="hljs-name"><span class="hljs-name">f</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> f) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s)) (<span class="hljs-name"><span class="hljs-name">car</span></span> s) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>))) ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) ((<span class="hljs-name"><span class="hljs-name">is-op</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">ar</span></span> (<span class="hljs-name"><span class="hljs-name">arity</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&lt;</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> s) ar) (<span class="hljs-name"><span class="hljs-name">progn</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> <span class="hljs-string"><span class="hljs-string">"****    "</span></span>) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))))) ((<span class="hljs-name"><span class="hljs-name">atom</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">car</span></span> s)) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s))))))</code> </pre><br>  Ahora echemos un "vistazo cr√≠tico" al manejador de declaraciones de proceso.  Claramente perdimos dos puntos.  Lo primero que debe hacer es no olvidar cuando procesa el procedimiento para calcular su aridad (el n√∫mero de argumentos) y modificar la variable global * oplist * en consecuencia.  ¬°Y el segundo es que las funciones que generamos no devuelven el valor correcto!  M√°s precisamente, como resultado de las funciones generadas por nuestro traductor, se devolver√° el valor de la √∫ltima forma calculada antes de regresar.  Para garantizar el retorno del valor deseado, propongo transferir la variable de resultado de Pascal.  Ahora, si es necesario, devuelva el valor deseado, es suficiente para que el usuario asigne el valor deseado a esta variable antes de salir de la funci√≥n, y al generar el cuerpo de la funci√≥n, necesitamos insertar el resultado del nombre en el cuerpo de la funci√≥n con la √∫ltima expresi√≥n.  Todo esto lleva la funci√≥n action-proc a: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> '((result <span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">length</span></span> proc-parm)) *oplist*))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) '=) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">action-set</span></span> stmt))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) (<span class="hljs-name"><span class="hljs-name">if</span></span> proc-name `(defun ,proc-name ,proc-parm (let ,lv ,@body result)) <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)))</code> </pre><br>  Nos detendremos aqu√≠ por ahora (aunque todav√≠a encontraremos problemas, y el c√≥digo tendr√° que ser finalizado; pero tal es la tarea del programador ...) Y ahora consideraremos dos mejoras en nuestro lenguaje que son apropiadas para hacer en este momento. <br><br><h3>  Peque√±as mejoras ... </h3><br>  En un art√≠culo anterior, escrib√≠ que es inconveniente para un programador si en un idioma un operador ocupa exactamente una l√≠nea.  Es necesario proporcionar la capacidad de escribir declaraciones voluminosas en varias l√≠neas.  Implementemos esto.  Esto no es del todo dif√≠cil de hacer.  En el procedimiento getLine, crearemos una variable local en la que acumularemos el texto le√≠do (siempre que no sea un comentario y termine con un par de caracteres "_". Tan pronto como se arregle una l√≠nea significativa con un final diferente, devolveremos el valor acumulado como un valor. Aqu√≠ est√° el c√≥digo: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> getLine (<span class="hljs-name"><span class="hljs-name">fil</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stri</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>) (<span class="hljs-name"><span class="hljs-name">res</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">filEof</span></span> fil) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *numline* (<span class="hljs-name"><span class="hljs-name">add1</span></span> *numline*)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">filGetline</span></span> fil)) (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> (<span class="hljs-name"><span class="hljs-name">format</span></span> *numline* <span class="hljs-string"><span class="hljs-string">"0000"</span></span>) <span class="hljs-string"><span class="hljs-string">" "</span></span> (<span class="hljs-name"><span class="hljs-name">strRTrim</span></span> stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> stri) (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri <span class="hljs-number"><span class="hljs-number">1</span></span>))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> stri (<span class="hljs-name"><span class="hljs-name">strATrim</span></span> stri)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res (<span class="hljs-name"><span class="hljs-name">strLeft</span></span> stri (<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">strLen</span></span> stri) <span class="hljs-number"><span class="hljs-number">2</span></span>)))) (<span class="hljs-name"><span class="hljs-name">setq</span></span> res (<span class="hljs-name"><span class="hljs-name">strCat</span></span> res stri))) (<span class="hljs-name"><span class="hljs-name">unless</span></span> (<span class="hljs-name"><span class="hljs-name">eq</span></span> <span class="hljs-string"><span class="hljs-string">" _"</span></span>(<span class="hljs-name"><span class="hljs-name">strRight</span></span> stri <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-name"><span class="hljs-name">return</span></span> res))))))</code> </pre><br>  Y la √∫ltima mejora.  En muchos lenguajes de programaci√≥n, puede usar operandos l√≥gicos en expresiones aritm√©ticas (que en este caso se calculan a cero o uno).  Esto le da al lenguaje una expresividad adicional y, por cierto, es bastante consistente con el esp√≠ritu b√°sico.  En nuestro mini-BASIC, un intento de calcular esta expresi√≥n, por ejemplo, es: <br><br><pre> <code class="hljs lisp">z=(<span class="hljs-name"><span class="hljs-name">x&gt;y</span></span>)*5+(<span class="hljs-name"><span class="hljs-name">x&lt;=y</span></span>)*10</code> </pre><br>  provocar√° un error de tiempo de ejecuci√≥n.  Y esto es comprensible: en Lisp, la expresi√≥n (&gt; xy) se calcula como Nil o T. Pero Nil / T no se puede multiplicar por 5 ... Sin embargo, este problema es f√°cil de ayudar.  Escribamos algunas macros simples que reemplacen el resultado de las expresiones de comparaci√≥n con 0/1 (en lugar de Nil / T): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $== (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt; ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $/= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;&gt; (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (/= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&lt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&lt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> $&gt;= (<span class="hljs-name"><span class="hljs-name">xy</span></span>) `(if (&gt;= ,x ,y) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre><br>  Ahora, eche un vistazo a la l√≠nea en la funci√≥n ipn2pref que realiza el procesamiento de la operaci√≥n.  Aqu√≠ est√° la l√≠nea: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  Aqu√≠ (carro f) es el nombre de la operaci√≥n.  Escribamos una peque√±a funci√≥n para reemplazar los c√≥digos de comparaci√≥n: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> chng-comp (<span class="hljs-name"><span class="hljs-name">op</span></span>) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">member</span></span> op '(= == /= &lt;&gt; &gt; &lt; &gt;= &lt;=)) (<span class="hljs-name"><span class="hljs-name">implode</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> '$ (<span class="hljs-name"><span class="hljs-name">explode</span></span> op))) op))</code> </pre><br>  La funci√≥n verifica si su argumento es una operaci√≥n de comparaci√≥n y, si es necesario, agrega el car√°cter "$" al principio.  Ahora ll√°melo en el lugar correcto de la funci√≥n ipn2pref: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">ipn2pref</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">chng-comp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s <span class="hljs-number"><span class="hljs-number">0</span></span> ar))) (<span class="hljs-name"><span class="hljs-name">subseq</span></span> s ar)))</code> </pre><br>  ¬øCu√°l ser√° el resultado?  Las operaciones de comparaci√≥n ser√°n reemplazadas por llamadas a la macro correspondiente, y todas las dem√°s operaciones no cambiar√°n.  Si traduces esta funci√≥n: <br><br><pre> <code class="hljs bash">proc <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> x,y x=1 y=2 result=(x&gt;y)*5+(x&lt;=y)*10 end_proc</code> </pre><br>  y luego lo llamamos, obtenemos el resultado esperado. <br><br>  Eso es todo por hoy. <br><br>  El c√≥digo para este art√≠culo se encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>aqu√≠.</b></a> <br>  Continuar√° </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423663/">https://habr.com/ru/post/es423663/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423645/index.html">C√≥mo servimos a la infraestructura de TI de Luzhniki durante la Copa del Mundo</a></li>
<li><a href="../es423647/index.html">Crea una red neuronal simple</a></li>
<li><a href="../es423649/index.html">"Kubernetes a todos los campos!" - Entrevista con el comit√© del programa de la conferencia DevOops</a></li>
<li><a href="../es423653/index.html">PsRealVehicle, o complemento de f√≠sica de tanques de c√≥digo abierto en Armored Warfare: Assault</a></li>
<li><a href="../es423657/index.html">No respeto la encapsulaci√≥n o el uso de un tipo diferente de tabla de m√©todos para llamar r√°pidamente a m√©todos privados</a></li>
<li><a href="../es423667/index.html">La historia de los primeros videojuegos con microprocesador</a></li>
<li><a href="../es423677/index.html">Pilotos de Jetpack: Frankie West</a></li>
<li><a href="../es423679/index.html">Una tarea con un rascacielos y huevos, ¬øno el contenedor de Newton?</a></li>
<li><a href="../es423683/index.html">Basado en el sentido com√∫n: desarrollar DevOps desde cero</a></li>
<li><a href="../es423685/index.html">Concurrencia PostgreSQL: no esf√©rica, no caballo, no en el vac√≠o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>