<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏼 👓 👩🏼‍🏫 Comment passer d'ESXi à KVM / LXD et ne pas perdre la tête 🙆🏼 🧑🏻 👨‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant longtemps, la société Maxnet Systems a utilisé la version gratuite de VMware - ESXi, à partir de la version 5.0, comme hyperviseur. La version...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment passer d'ESXi à KVM / LXD et ne pas perdre la tête</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/458922/">  Pendant longtemps, la société Maxnet Systems a utilisé la version gratuite de VMware - ESXi, à partir de la version 5.0, comme hyperviseur.  La version payante de vSphere a effrayé le modèle de licence, tandis que la version gratuite avait un certain nombre d'inconvénients qui n'étaient pas disponibles dans la version payante, mais vous pouviez les supporter.  Mais lorsque dans les nouvelles versions d'ESXi la nouvelle interface Web a refusé de fonctionner avec l'ancienne et que la surveillance des matrices RAID a cessé de montrer des signes de vie, la société a décidé de rechercher une solution plus universelle et ouverte.  L'entreprise avait déjà une bonne expérience et une bonne impression de LXC - Linux Containers.  Par conséquent, il est devenu évident que l'hyperviseur de rêve sera hybride et combinera KVM et LXD pour différentes charges - une continuation évolutive de LXC.  À la recherche d'informations sur KVM, l'entreprise était confrontée à des idées fausses, des râteaux et des pratiques néfastes, mais les tests et le temps ont tout mis en place. <br><br><img src="https://habrastorage.org/webt/s-/vc/6s/s-vc6shq5cfia5bjjcuhixbgukq.jpeg"><br><br>  À propos de comment gérer le passage d'ESXi à KVM et de ne pas conduire une roue sur un râteau, dira <strong>Lev Nikolaev</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">maniaque</a> ) - administrateur et développeur de systèmes très chargés, formateur en technologies de l'information.  Parlons du réseau, des référentiels, des conteneurs, du KVM, du LXD, du LXC, du provisionnement et des machines virtuelles pratiques. <br><a name="habracut"></a><br><h2>  Prologue </h2><br>  Nous identifierons immédiatement les pensées clés, puis nous les analyserons plus en détail. <br><br>  <strong>Réseau.</strong>  Alors que les vitesses de vos interfaces ne dépassent pas 1 Gb / s, le bridge vous suffit.  Dès que vous voulez en serrer plus, cela vous limitera. <br><br>  <strong>Dépôt.</strong>  Créez un stockage réseau partagé.  Même si vous n'êtes pas prêt à utiliser 10 Gbit / s à l'intérieur du réseau, même 1 Gbit / s vous donnera 125 Mo / s de stockage.  Pour un certain nombre de charges, cela suffira avec une marge, et la migration des machines virtuelles sera une question élémentaire. <br><br>  <strong>Conteneur ou KVM?</strong>  Avantages, inconvénients, pièges.  Quels types de charges sont les mieux placés dans un conteneur et lesquels sont les mieux placés dans un KVM? <br><br>  <strong>LXD ou LXC</strong> .  Est-ce que LXD LXC?  Ou une autre version?  Ou un module complémentaire?  De quoi s'agit-il?  Dissipons les mythes et comprenons les différences entre LXD et LXC. <br><br>  <strong>Provisionnement pratique</strong> .  Quel est le plus pratique: prendre la même image ou installer le système à partir de zéro à chaque fois?  Comment le faire rapidement et avec précision à chaque fois? <br><br>  <strong>Machine virtuelle pratique.</strong>  Il y aura des histoires effrayantes sur les chargeurs de démarrage, les partitions, LVM. <br><br>  <strong>Divers</strong> .  Beaucoup de petites questions: comment faire glisser rapidement une machine virtuelle d'ESXi vers KVM, comment bien migrer, comment virtualiser correctement les disques? <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HqsxBkxGxqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Raison de la réinstallation </h2><br>  D'où nous est venue l'idée folle de passer d'ESXi à KVM / LXD?  ESXi est populaire parmi les petites et moyennes entreprises.  C'est un bon hyperviseur bon marché.  Mais il y a des nuances. <br><br>  Nous avons commencé avec la version 5.0 - commodément, tout fonctionne!  La prochaine version 5.5 est la même. <br><br>  Depuis la version 6.0, c'est déjà plus difficile.  Sur ESXi, l'interface Web n'est pas devenue immédiatement gratuite, uniquement à partir de la version 6.5, avant qu'un utilitaire pour Windows ne soit requis.  Nous avons supporté cela.  Qui exécute OS X achète Parallels et installe cet utilitaire.  C'est une douleur bien connue. <br><br>  La surveillance clignote périodiquement.  Il était nécessaire de redémarrer les services de gestion dans la console du serveur - puis CIM Heartbeat est réapparu.  Nous avons enduré, car il ne tombait pas toujours. <br><br>  Version ESXi 6.5 - poubelles, déchets et atrocités.  Hyperviseur horrible.  Et voici pourquoi. <br><br><ul><li>  <strong>Angular tombe avec une exception à l'entrée de l'interface Web.</strong>  Dès que vous entrez votre nom d'utilisateur et votre mot de passe - immédiatement une exception! </li><li>  <strong>La possibilité de surveiller à distance l'état de la matrice RAID</strong> ne <strong>fonctionne pas</strong> car cela nous convient.  Avant, c'était pratique, mais dans la version 6.5, tout va mal. </li><li>  <strong>Prise en charge faible des cartes réseau modernes d'Intel</strong> .  Les cartes réseau Intel et ESXi causent de la douleur.  Il y a un fil de discussion sur le forum de support ESXi à ce sujet.  VMware et Intel ne sont pas amis et les relations ne s'amélioreront pas dans un avenir proche.  Le plus triste est que même les clients des solutions payantes rencontrent des problèmes. </li><li>  <strong>Aucune migration dans ESXi</strong> .  Sauf si la migration est considérée comme une procédure de pause, de copie et de démarrage.  Nous mettons la voiture en pause, la copions rapidement et la démarrons à un autre endroit.  Mais il est impossible de l'appeler migration - il y en a toujours une simple. </li></ul><br>  Après avoir regardé tout cela, nous avons eu l'idée folle de bouger avec ESXi 6.5. <br><br><h2>  Liste de souhaits </h2><br>  Pour commencer, nous avons écrit une liste de souhaits pour un avenir idéal que nous allons. <br><br>  <strong>Gestion sous SSH</strong> et Web et plus en option.  L'interface Web est géniale, mais lors d'un voyage d'affaires avec l'iPhone, aller à l'interface Web ESXi et faire quelque chose est gênant et difficile.  Par conséquent, la seule façon de tout gérer est SSH, il n'y en aura pas d'autre. <br><br>  <strong>Virtualisation Windows.</strong>  Parfois, les clients demandent des choses étranges, et notre mission est de les aider. <br><br>  <strong>Toujours de nouveaux pilotes et la possibilité de configurer une carte réseau</strong> .  Désir suffisant, mais non réalisé sous ESXi pur. <br><br>  <strong>Migration en direct, pas de clustering</strong> .  Nous voulons pouvoir faire glisser les machines d'un hyperviseur à un autre sans ressentir de retard, d'arrêt ou d'inconvénient. <br><br>  La liste de souhaits est prête, puis une recherche difficile a commencé. <br><br><h2>  Farine de choix </h2><br>  Le marché tourne autour du KVM ou du LXC avec différentes sauces.  Parfois, il semble que Kubernetes est quelque part au-dessus, où tout va bien, le soleil et le paradis, et au niveau inférieur, il y a Morlocks - KVM, Xen ou quelque chose comme ça ... <br><br>  Par exemple, Proxmox VE est Debian, qui a été tiré par le noyau d'Ubuntu.  Ça a l'air bizarre, mais est-ce que ça l'amène à la production? <br><br>  Nos voisins en bas sont Alt Linux.  Ils ont trouvé une belle solution: ils ont assemblé Proxmox VE sous forme de package.  Ils ont simplement mis le package dans une seule commande.  C'est pratique, mais nous ne mettons pas Alt Linux en production, donc cela ne nous convenait pas. <br><br><h3>  Prenez KVM </h3><br>  Au final, nous avons choisi KVM.  Ils ne l'ont pas accepté, Xen, par exemple, à cause de la communauté - KVM en a beaucoup plus.  Il semblait que nous trouverions toujours la réponse à notre question.  Nous avons découvert plus tard que la taille d'une communauté n'affecte pas sa qualité. <br><br>  Initialement, nous avons calculé que nous prendrions une machine Bare Metal, ajouterions l'Ubuntu avec lequel nous travaillons et lancerions KVM / LXD par le haut.  Nous comptions sur la capacité de gérer des conteneurs.  Ubuntu est un système bien connu et il n'y a pas de surprise en termes de résolution de problèmes de démarrage / récupération pour nous.  Nous savons où donner un coup de pied si l'hyperviseur ne démarre pas.  Tout est clair et pratique pour nous. <br><br><h2>  Cours intensif KVM </h2><br>  Si vous êtes du monde d'ESXi, vous trouverez beaucoup de choses intéressantes.  Apprenez trois mots: QEMU, KVM et libvirt. <br><br>  <strong>QEMU</strong> traduit les souhaits d'un OS virtualisé en défis d'un processus régulier.  Fonctionne très bien presque partout, mais lentement.  QEMU lui-même est un produit autonome qui virtualise un tas d'autres appareils. <br><br>  Plus loin sur la scène vient un tas de <strong>QEMU-KVM</strong> .  Il s'agit du module du noyau Linux pour QEMU.  La virtualisation de toutes les instructions coûte cher, nous avons donc un module de noyau KVM qui <strong>ne traduit que quelques instructions</strong> .  En conséquence, cela est beaucoup plus rapide, car seuls quelques pour cent des instructions de l'ensemble général sont traitées.  C'est tous les coûts de la virtualisation. <br><br>  Si vous venez d'avoir QEMU, le démarrage de la machine virtuelle sans liaison ressemble à ceci: <br><br><pre><code class="plaintext hljs">$ qemu &lt; &gt;</code> </pre> <br>  Dans les paramètres que vous décrivez, bloquez les périphériques.  Tout est merveilleux, mais peu pratique.  Il y a donc libvirt. <br><br>  <strong>Le but de libvirt est d'être un outil unique pour tous les hyperviseurs</strong> .  Il peut fonctionner avec n'importe quoi: avec KVM, avec LXD.  Il semble qu'il ne reste plus qu'à apprendre la syntaxe de libvirt, mais en réalité cela fonctionne moins bien qu'en théorie. <br><br>  Ces trois mots suffisent pour faire monter la première machine virtuelle dans KVM.  Mais encore une fois, il y a des nuances ... <br><br>  Libvirt a une configuration où les machines virtuelles et autres paramètres sont stockés.  Il stocke la configuration dans des fichiers xml - élégant, à la mode et directement des années 90.  Si vous le souhaitez, ils peuvent être modifiés à la main, mais pourquoi, s'il existe des commandes pratiques.  Il est également pratique que les modifications apportées aux fichiers xml soient merveilleusement versionnées.  Nous utilisons <strong>etckeeper</strong> - version du répertoire, etc.  Il est déjà possible d'utiliser etckeeper et il est grand temps. <br><br><h2>  Cours intensif LXC </h2><br>  Il existe de nombreuses idées fausses sur LXC et LXD. <br><br><blockquote>  LXC est la capacité du noyau moderne à utiliser des espaces de noms - pour prétendre que ce n'est pas du tout le noyau qu'il était à l'origine. </blockquote><br>  Vous pouvez créer autant d'espaces de noms que vous le souhaitez pour chaque conteneur.  Formellement, le noyau est un, mais il se comporte comme de nombreux cœurs identiques.  LXC vous permet d'exécuter des conteneurs, mais ne fournit que des outils de base. <br><br>  Canonical, qui est derrière Ubuntu et fait avancer les conteneurs de manière agressive, a publié <strong>LXD, un analogue de libvirt</strong> .  Il s'agit d'une liaison qui facilite l'exécution des conteneurs, mais à l'intérieur, il s'agit toujours de LXC. <br><br><blockquote>  LXD est un hyperviseur de conteneur basé sur LXC. </blockquote><br>  L'entreprise règne en LXD.  LXD stocke la configuration dans sa base de données - dans le répertoire <code>/var/lib/lxd</code> .  Là, LXD mène sa configuration à la configuration dans SQlite.  La copier n'a pas de sens, mais vous pouvez écrire les commandes que vous avez utilisées pour créer la configuration du conteneur. <br><br>  Il n'y a pas de déchargement en tant que tel, mais la plupart des changements sont automatisés par les équipes.  Il s'agit d'un analogue du fichier Docker, uniquement avec un contrôle manuel. <br><br><h2>  La production </h2><br>  Ce à quoi nous étions confrontés lorsque nous sommes tous entrés en service. <br><br><h3>  Réseau </h3><br>  Combien de poubelles infernales et d'agitation sur Internet à propos du réseau dans KVM!  90% des matériaux disent utiliser un pont. <br><br><blockquote>  Arrêtez d'utiliser le pont! </blockquote><br>  Qu'est-ce qui ne va pas avec lui?  Dernièrement, j'ai le sentiment que la folie se produit avec les conteneurs: placez Docker au-dessus de Docker pour pouvoir exécuter Docker dans Docker tout en regardant Docker.  La plupart ne comprennent pas ce que fait le pont. <br><br>  Il met votre contrôleur réseau en <strong>mode promiscuité</strong> et reçoit tout le trafic car il ne sait pas lequel et lequel.  En conséquence, tout le trafic du pont passe par une merveilleuse pile Linux réseau rapide et il y a beaucoup de copies.  Au final, tout est lent et mauvais.  Par conséquent, n'utilisez pas de bridge en production. <br><br><h3>  SR-IOV </h3><br>  <strong>SR-IOV est la possibilité de virtualiser au sein d'une carte réseau</strong> .  La carte réseau elle-même est capable d'allouer une partie d'elle-même aux machines virtuelles, ce qui nécessite une prise en charge matérielle.  C'est ce qui empêchera la migration.  La migration d'une machine virtuelle où SR-IOV est manquant est pénible. <br><br>  SR-IOV doit être utilisé lorsqu'il est pris en charge par tous les hyperviseurs dans le cadre de la migration.  Sinon, macvtap est fait pour vous. <br><br><h3>  macvtap </h3><br>  C'est pour ceux dont la carte réseau ne prend pas en charge SR-IOV.  Il s'agit de la version allégée du pont: différentes adresses MAC sont accrochées sur une carte réseau, et un <strong>filtrage unicast est utilisé</strong> : la carte réseau n'accepte pas tout, mais strictement selon la liste des adresses MAC. <br><br>  Plus de détails sanglants peuvent être trouvés dans l'excellent discours de Toshiaki Makita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, Virtual Switching Technologies et Linux Bridge</a> .  Il est plein de douleur et de souffrance. <br><br><blockquote>  90% des matériaux sur la façon de construire un réseau en KVM sont inutiles. </blockquote><br>  Si quelqu'un dit que le pont est génial, ne parlez plus à cette personne. <br><br>  Avec macvtap, le <strong>CPU économise environ 30%</strong> grâce à moins de copies.  Mais le mode promiscuité a ses propres nuances.  Vous ne pouvez pas vous connecter à l'interface réseau de la machine invitée à partir de l'hyperviseur lui-même - à partir de l'hôte.  Un rapport Toshiaki détaille cela.  Mais en bref - cela ne fonctionnera pas. <br><br>  De l'hyperviseur même aller rarement sur SSH.  Il est plus pratique d'y démarrer une console, par exemple une console Win.  Il est possible de «surveiller» le trafic sur l'interface - vous ne pouvez pas vous connecter via TCP, mais le trafic sur l'hyperviseur est visible. <br><br><blockquote>  Si vos vitesses sont supérieures à 1 Gigabit - choisissez macvtap. </blockquote><br>  À des vitesses d'interface allant jusqu'à ou environ 1 Gigabit par seconde, le pont peut également être utilisé.  Mais si vous avez une carte réseau de 10 Go et que vous souhaitez vous en débarrasser, il ne reste que macvtap.  Il n'y a pas d'autre option.  Sauf SR-IOV. <br><br><h3>  systemd-networkd </h3><br>  <strong>C'est un excellent moyen de stocker la configuration réseau sur l'hyperviseur lui-même</strong> .  Dans notre cas, c'est Ubuntu, mais pour d'autres systèmes, systemd fonctionne. <br><br>  Nous avions un fichier <code>/etc/network/interfaces</code> dans lequel nous conservions tous.  Un fichier n'est pas pratique à modifier à chaque fois - systemd-networkd vous permet de diviser la configuration en une dispersion de petits fichiers.  C'est pratique car il fonctionne avec n'importe quel système de version: il a été envoyé à Git et vous voyez quand et quel changement s'est produit. <br><br>  Il y a une faille que nos networkers ont découverte.  Lorsque vous devez ajouter un nouveau VLAN dans l'hyperviseur, je vais configurer.  Ensuite, je dis: "systemctl restart systemd-networkd".  En ce moment, tout va bien pour moi, mais si les sessions BGP de cette machine sont augmentées, elles se cassent.  Nos networkers ne l'approuvent pas. <br><br>  Pour l'hyperviseur, il ne se passe rien de mal.  Systemd-networkd ne convient pas aux frontières, aux serveurs avec BGP élevé et aux hyperviseurs - excellent. <br><br>  Systemd-networkd est loin d'être définitif et ne sera jamais terminé.  Mais c'est plus pratique que d'éditer un énorme fichier.  Une alternative à systemd-networkd dans Ubuntu 18.04 est Netplan.  C'est une façon «cool» de configurer le réseau et de monter sur le râteau. <br><br><h3>  Périphérique réseau </h3><br>  Après avoir installé KVM et LXD sur l'hyperviseur, la première chose que vous verrez est deux ponts.  L'un a fait KVM pour lui-même, et le second - LXD. <br><br><blockquote>  LXD et KVM tentent de déployer leur réseau. </blockquote><br>  Si vous avez encore besoin d'un pont - pour les machines de test ou pour jouer, tuez le pont, qui est activé par défaut et créez le vôtre - celui que vous voulez.  KVM ou LXD le font terriblement - glissez dnsmasq, et l'horreur commence. <br><br><h3>  Stockage </h3><br><blockquote>  Peu importe les implémentations que vous aimez - utilisez le stockage partagé. </blockquote><br>  Par exemple, iSCSI pour les machines virtuelles.  Vous ne vous débarrasserez pas du «point de défaillance», mais vous pouvez <strong>consolider le stockage à un moment donné</strong> .  Cela ouvre de nouvelles opportunités intéressantes. <br><br>  Pour ce faire, vous devez disposer d'au moins 10 Gb / s d'interfaces dans le centre de données.  Mais même si vous n'avez que 1 Gbit / s - ne vous inquiétez pas.  Cela représente environ 125 Mo / s, ce qui est assez bon pour les hyperviseurs qui ne nécessitent pas une charge de disque élevée. <br><br>  KVM peut migrer et faire glisser le stockage.  Mais, par exemple, en mode charge de travail, le transfert d'une machine virtuelle vers quelques téraoctets est une tâche difficile.  Pour la migration avec un stockage commun, seule la RAM est suffisante, ce qui est élémentaire.  Cela <strong>réduit le temps de migration</strong> . <br><br><h3>  Au final, LXD ou KVM? </h3><br>  Initialement, nous avons supposé que pour toutes les machines virtuelles où le noyau correspond au système hôte, nous prendrons LXD.  Et là où nous devons prendre un autre noyau - prenez KVM. <br><br>  En réalité, les plans n'ont pas décollé.  Pour comprendre pourquoi, examinez de plus près LXD. <br><br><h3>  Lxd </h3><br>  Le principal avantage est d'économiser de la mémoire sur le cœur.  Le noyau est le même et lorsque nous lançons de nouveaux conteneurs, le noyau est le même.  Sur ce, les avantages ont pris fin et les inconvénients ont commencé. <br><br>  <strong>Le périphérique de bloc avec rootfs doit être monté.</strong>  C'est plus difficile qu'il n'y paraît. <br><br>  <strong>Il n'y a vraiment pas de migration</strong> .  Il est et est basé sur le merveilleux instrument sombre et criu que nos compatriotes ont vu.  Je suis fier d'eux, mais dans des cas simples, criu ne fonctionne pas. <br><br>  <strong>zabbix-agent se comporte étrangement dans un récipient</strong> .  Si vous l'exécutez à l'intérieur du conteneur, vous verrez une série de données du système hôte et non du conteneur.  Jusqu'à présent, rien ne peut être fait. <br><br>  <strong>Lorsque vous consultez la liste des processus sur l'hyperviseur, il est impossible de comprendre rapidement à partir de quel conteneur un processus particulier se développe</strong> .  Il faut du temps pour comprendre quel espace de noms est là, quoi et où.  Si la charge quelque part a sauté plus que d'habitude, alors ne comprends pas rapidement.  C'est le principal problème - la limitation des capacités de réponse.  Une mini enquête est menée pour chaque cas. <br><br><blockquote>  Le seul avantage de LXD est d'économiser la mémoire centrale et de réduire les frais généraux. </blockquote><br>  Mais la mémoire partagée du noyau dans KVM économise déjà la mémoire. <br><br>  Jusqu'à présent, je ne vois aucune raison d'introduire une production sérieuse et LXD.  Malgré les meilleurs efforts de Canonical dans ce domaine, la production de LXD pose plus de problèmes que de solutions.  Dans un avenir proche, la situation ne changera pas. <br><br>  Mais, on ne peut pas dire que LXD est mauvais.  Il est bon, mais dans des cas limités, dont je parlerai un peu plus tard. <br><br><h3>  Criu </h3><br>  Criu est un utilitaire sombre. <br><br>  Créez un conteneur vide, il arrivera avec un client DHCP et lui dira: "Suspend!"  Obtenez l'erreur car il y a un client DHCP: «Horreur, horreur!  Il ouvre la prise avec le signe "raw" - quel cauchemar! "  Pire nulle part. <br><br><blockquote>  Impressions de conteneurs: pas de migration, Criu fonctionne à chaque fois. </blockquote><br>  J'aime «la» recommandation de l'équipe LXD que faire de Criu pour qu'il n'y ait aucun problème: <br><br>  - <em>Prenez une version plus fraîche du référentiel!</em> <br><br>  Et puis-je en quelque sorte le mettre à partir du package afin de ne pas courir dans le référentiel? <br><br><h3>  Conclusions </h3><br>  <strong>LXD est merveilleux si vous voulez créer une infrastructure CI / CD.</strong>  Nous prenons LVM - Logical Volume Manager, en faisons un instantané et démarrons le conteneur dessus.  Tout fonctionne très bien!  En une seconde, un nouveau conteneur propre est créé, qui est configuré pour tester et rouler le chef - nous l'utilisons activement. <br><br>  <strong>LXD est faible pour une production sérieuse</strong> .  Nous ne pouvons pas savoir quoi faire avec LXD en production si cela ne fonctionne pas bien. <br><br>  <strong>Choisissez KVM et seulement KVM!</strong> <br><br><h3>  La migration </h3><br>  Je vais le dire brièvement.  Pour nous, la migration s'est avérée être un nouveau monde merveilleux que nous aimons.  Tout y est simple - il y a une équipe de migration et deux options importantes: <br><br><pre> <code class="plaintext hljs">virsh migrate &lt;vm&gt; qemu+ssh://&lt;hypervisor&gt;/system --undefinesource -persistent</code> </pre> <br>  Si vous tapez «Migration KVM» dans Google et ouvrez le premier document, vous verrez une commande de migration, mais sans les deux dernières clés.  Vous ne verrez aucune mention de leur importance: «Exécutez simplement cette commande!»  Exécutez la commande - et elle migre vraiment, mais seulement comment? <br><br>  Options de migration importantes. <br><br>  <strong>undefinesource - supprimez la machine virtuelle de l'hyperviseur à partir duquel nous migrons.</strong>  Si vous redémarrez après une telle migration, l'hyperviseur que vous avez quitté redémarrera cette machine.  Vous serez surpris, mais c'est normal. <br><br>  <strong>Sans le deuxième paramètre - persistant - l'hyperviseur où vous avez déménagé ne considère pas du tout qu'il s'agit d'une migration permanente.</strong>  Après le redémarrage, l'hyperviseur ne se souviendra de rien. <br><br><pre> <code class="plaintext hljs">- virsh dominfo &lt;vm&gt; | grep persistent</code> </pre> <br>  Sans ce paramètre, la machine virtuelle fait des cercles sur l'eau.  Si le premier paramètre est spécifié sans le second, alors devinez ce qui se passera. <br><br>  Il y a beaucoup de tels moments avec KVM. <br><br><ul><li>  Réseau: ils vous parlent toujours de bridge - c'est un cauchemar!  Vous lisez et pensez - comment cela?! </li><li>  Migration: ils ne diront rien d'intelligible non plus, jusqu'à ce que vous vous frappiez la tête contre ce mur. </li></ul><br><h2>  Par où commencer? </h2><br>  Pour commencer tard - je parle d'autre chose. <br><br><h3>  Provisioning: comment le déployer </h3><br><blockquote>  Si vous êtes satisfait des options d'installation standard, le mécanisme préconfiguré est parfait. </blockquote><br>  Sous ESXi, nous avons utilisé virt-install.  Il s'agit d'un moyen régulier de déployer une machine virtuelle.  Il est pratique de créer un fichier prédéfini dans lequel vous décrivez l'image de votre Debian / Ubuntu.  Démarrez une nouvelle machine en lui fournissant un kit de distribution ISO et un fichier prédéfini.  Ensuite, la voiture se roule.  Vous vous connectez via SSH, connectez-le à un chef, lancez des cookies - c'est tout, précipitez-vous vers la prod! <br><br>  Mais si vous avez assez de virt-install, j'ai de mauvaises nouvelles.  Cela signifie que vous n'avez pas atteint le stade où vous voulez faire autre chose.  Nous nous sommes remis et avons réalisé que virt-install ne suffisait pas.  Nous sommes arrivés à une «image dorée», que nous clonons puis lançons des machines virtuelles. <br><br><h3>  Et comment organiser une machine virtuelle? </h3><br>  Pourquoi en sommes-nous arrivés à cette image et pourquoi le provisionnement est-il important?  Parce que la communauté comprend encore mal qu'il existe de grandes différences entre une machine virtuelle et une machine normale. <br><br>  <strong>Une machine virtuelle n'a pas besoin d'un processus de démarrage compliqué et d'un chargeur de démarrage intelligent</strong> .  Il est beaucoup plus facile d'attacher les disques d'une machine virtuelle à une machine qui a un ensemble complet d'outils qu'en mode de récupération en essayant de sortir quelque part. <br><br>  <strong>Une machine virtuelle a besoin de la simplicité d'un appareil</strong> .  Pourquoi ai-je besoin de partitions sur un disque virtuel?  Pourquoi les gens prennent-ils un disque virtuel et y mettent des partitions, pas LVM? <br><br>  <strong>Une machine virtuelle a besoin d'une extensibilité maximale</strong> .  Habituellement, les machines virtuelles se développent.  Il s'agit d'un processus «cool» - l'augmentation de la partition dans le MBR.  Vous le supprimez, à ce moment-là, essuyez la sueur de votre front et pensez: "N'écrivez pas maintenant, n'écrivez pas!"  - et recréer avec les nouveaux paramètres. <br><br><h3>  LVM @ lilo </h3><br>  En conséquence, nous sommes arrivés à LVM @ lilo.  Il s'agit d'un chargeur de démarrage qui vous permet de configurer à partir d'un seul fichier.  Si pour éditer la configuration GRUB vous éditez un fichier spécial qui contrôle le moteur de modèle et construit le monstrueux boot.cfg, alors avec Lilo - un fichier, et rien de plus. <br><br>  LVM sans partition rend le système parfait et facile.  Le problème est que GRUB ne peut pas vivre sans MBR ou GPT et il gèle.  Nous lui disons: «GRUB s'installe ici», mais il ne peut pas, car il n'y a pas de partitions. <br><br>  LVM vous permet d'étendre rapidement et de faire des sauvegardes.  Boîte de dialogue standard: <br><br>  <em>- Les gars, comment faites-vous la sauvegarde virtuelle?</em> <br><br>  <em>- ... nous prenons un périphérique bloc et copions.</em> <br><br>  <em>- Avez-vous essayé de vous déployer en arrière?</em> <br><br>  <em>- Eh bien, non, tout fonctionne pour nous!</em> <br><br>  Vous pouvez lécher un périphérique de bloc dans une machine virtuelle à tout moment, mais s'il existe un système de fichiers, tout enregistrement qu'il contient nécessite trois mouvements - cette procédure n'est pas atomique. <br><br>  Si vous effectuez un instantané de la machine virtuelle de l'intérieur, elle peut alors communiquer avec le système de fichiers afin qu'elle atteigne l'état cohérent souhaité.  Mais cela ne convient pas à tout. <br><br><h2>  Comment construire un conteneur? </h2><br>  Pour démarrer et créer un conteneur, il existe des outils réguliers à partir des modèles.  LXD propose le modèle Ubuntu 16.04 ou 18.04.  Mais si vous êtes un combattant avancé et que vous ne voulez pas de modèle standard, mais vos rootfs personnalisés, que vous pouvez personnaliser vous-même, la question se pose: comment créer un conteneur à partir de zéro dans LXD? <br><br><h3>  Conteneur à partir de zéro </h3><br>  <strong>Préparation de rootfs</strong> .  Debootstrap vous y aidera: nous expliquons quels packages sont nécessaires, lesquels ne le sont pas et installons. <br><br>  <strong>Expliquez à LXD que nous voulons créer un conteneur à partir de rootfs spécifiques</strong> .  Mais d'abord, créez un conteneur vide avec une commande courte: <br><br><pre> <code class="plaintext hljs">curl --unix-socket /var/lib/lxd/unix.socket -X POST -d '{"name": "my-container", "source": {"type": "none"}}' lxd/1.0/containers</code> </pre> <br>  Il peut même être automatisé. <br><br>  Un lecteur réfléchi dira: où est rootfs my-container?  Où est-il indiqué à quel endroit?  Mais je n'ai pas dit que c'était tout! <br><br>  <strong>Nous montons les rootfs du conteneur</strong> où il vivra.  Ensuite, nous indiquons que le conteneur rootfs vivra ici: <br><br><pre> <code class="plaintext hljs">lxc config set my-container raw.lxc "lxc.rootfs=/containers/my-container/rootfs"</code> </pre> <br>  Encore une fois, cela est automatisé. <br><br><h3>  Durée de vie du conteneur </h3><br>  <strong>Le conteneur n'a pas son propre noyau</strong> , donc le chargement est plus facile <strong>:</strong> systemd, init et volé! <br><br>  Si vous n'utilisez pas d'outils standard pour travailler avec LVM, dans la plupart des cas, pour démarrer le conteneur, vous devrez monter les rootfs du conteneur dans l'hyperviseur. <br><br>  Je trouve parfois des articles conseillant autofs.  Ne le faites pas.  Systemd a des unités de montage automatique qui fonctionnent, mais pas autofs.  Par conséquent, les unités de montage automatique systemd peuvent et doivent être utilisées, mais autofs n'en vaut pas la peine. <br><br><h2>  Conclusions </h2><br>  <strong>Nous aimons KVM avec migration</strong> .  Avec LXD, ce n'est pas encore le chemin, bien que pour tester et construire l'infrastructure, nous l'utilisons là où il n'y a pas de charge de production. <br><br>  <strong>Nous adorons les performances de KVM</strong> .  Il est plus courant de regarder en haut, de voir un processus pertinent pour cette machine virtuelle et de comprendre qui et ce que nous faisons.  C'est mieux que d'utiliser un ensemble d'utilitaires étranges avec des conteneurs pour savoir quel genre de coups sous-marins il y a. <br><br>  <strong>Nous sommes ravis de la migration.</strong>  Cela est largement dû au stockage partagé.  Si nous migrions en faisant glisser des disques, nous ne serions pas si heureux. <br><br><blockquote>  Si vous, comme Leo, êtes prêt à parler de surmonter les difficultés de fonctionnement, d'intégration ou de support, alors il est temps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de soumettre un rapport</a> à la conférence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DevOpsConf d'</a> automne.  Et nous, au comité du programme, nous aiderons à préparer la même présentation inspirante et utile que celle-ci. <br><br>  Nous n'attendons pas la date limite de l'appel à communications et avons déjà accepté plusieurs rapports au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">programme</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la</a> conférence.  Abonnez-vous à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">newsletter</a> et à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chaîne de télégrammes</a> et restez au courant des nouvelles concernant les préparatifs de DevOpsConf 2019 et ne manquez pas de nouveaux articles et vidéos. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458922/">https://habr.com/ru/post/fr458922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458912/index.html">Migration vers Zimbra avec imapsync</a></li>
<li><a href="../fr458914/index.html">Ce que vous devez savoir (pas) pour créer des jeux sur Unity</a></li>
<li><a href="../fr458916/index.html">Sous le capot de React. Nous écrivons notre implémentation à partir de zéro</a></li>
<li><a href="../fr458918/index.html">Ce que vous pouvez apprendre de la conception de jeux hyper-occasionnels</a></li>
<li><a href="../fr458920/index.html">Conférence pour les fans de DevOps</a></li>
<li><a href="../fr458924/index.html">Les accidents vous aident à apprendre</a></li>
<li><a href="../fr458926/index.html">La tragédie ne vient pas seule</a></li>
<li><a href="../fr458928/index.html">XLNet vs BERT</a></li>
<li><a href="../fr458930/index.html">Comment les étudiants de Perm se sont rendus en finale du championnat international d'analyse de données Data Mining Cup 2019</a></li>
<li><a href="../fr458932/index.html">Yota - ou comment tout savoir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>