<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍋 👆🏿 🎭 我们将Lua解释器嵌入到微控制器（stm32）的项目中 🎿 🏧 🧕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在相当大的应用程序中，项目的重要部分是业务逻辑。 在计算机上调试程序的这一部分，然后将其嵌入到微控制器的项目中是很方便的，因为期望这部分将完全按预期执行，而无需任何调试（理想情况）。 

 由于大多数用于微控制器的程序都是用C / C ++编写的，因此，出于这些目的，它们通常使用提供低级实体接口的抽...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们将Lua解释器嵌入到微控制器（stm32）的项目中</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459602/"><img src="https://habrastorage.org/webt/p6/9j/kz/p69jkzome873c4rbil8fftedrxs.png"><br><br> 在相当大的应用程序中，项目的重要部分是业务逻辑。 在计算机上调试程序的这一部分，然后将其嵌入到微控制器的项目中是很方便的，因为期望这部分将完全按预期执行，而无需任何调试（理想情况）。 <br><br> 由于大多数用于微控制器的程序都是用C / C ++编写的，因此，出于这些目的，它们通常使用提供低级实体接口的抽象类（如果仅使用C编写项目，则通常使用函数指针结构）。 这种方法提供了所需的抽象级别，但是需要不断地重新编译项目，然后再使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大型</a>二进制<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">固件</a>文件对微控制器的非易失性存储器进行编程，这是一种困扰。 <br><br> 但是，还有另一种方法-使用脚本语言，您可以在设备本身上实时调试业务逻辑，或者直接从外部存储器加载工作脚本，而无需将此代码包含在微控制器固件中。 <br><br> 我选择Lua作为脚本语言。 <a name="habracut"></a><br><br><h2> 为什么是卢阿？ </h2><br> 您可以在微控制器的项目中嵌入多种脚本语言。 一些简单的类似于BASIC的PyMite，Pawn ...每个都有其优缺点，本文所讨论的问题列表中未包含对其的讨论。 <br><br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ 60分钟内的Lua”</a>一文中简要了解lua的优点。 这篇文章给了我很多启发，对于这个问题的更详细的研究，我阅读了罗伯特·杰鲁扎林斯基（Robert Jeruzalimsky）语言“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编程在Lua中</a> ”的作者的官方指南（官方俄语版中提供）。 <br><br> 我还要提及eLua项目。 就我而言，我已经有一个现成的软件底层层，可以与微控制器的外围设备和位于设备板上的其他所需外围设备进行交互。 因此，我没有考虑过这个项目（因为它被认为提供了将Lua内核与微控制器的外围设备连接在一起的各个层）。 <br><br><h2> 关于将嵌入Lua的项目 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">按照传统</a> ，我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">沙盒项目</a>将用作实验领域的质量（链接到已集成lua的提交，并具有以下所述的所有必要改进）。 <br><br> 该项目基于具有1 MB非易失性和192 KB RAM的stm32f405rgt6微控制器（当前使用总容量为128 KB的较旧的2个块）。 <br><br> 该项目具有FreeRTOS实时操作系统，以支持硬件外围基础设施。 用于任务，信号量和其他FreeRTOS对象的所有内存在链接阶段（位于RAM的.bss区域）静态分配。 所有FreeRTOS实体（信号量，队列，任务堆栈等）都是其类的私有区域中全局对象的一部分。 但是，仍然分配了FreeRTOS堆以支持<i>malloc</i> ， <i>free</i> ， <i>calloc</i>函数（对于诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">printf之</a>类的函数是必需的），这些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">函数</a>已重新定义以与其一起使用。 有一个改进的API可用于MicroSD（FatFS）卡以及调试UART（115200，8N1）。 <br><br><h2> 关于将Lua用作项目一部分的逻辑 </h2><br> 为了调试业务逻辑，假定命令将由UART发送，打包（作为单独的对象）到完成的行中（以字符“ \ n” + 0终止符结束），然后发送到lua机器。 如果执行不成功，则通过printf进行输出（因为该输出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先前已包含</a>在项目中）。 调试逻辑后，可以从microSD卡的文件中下载最终的业务逻辑文件（本文材料中未提供）。 同样，出于调试Lua的目的，计算机将在单独的FreeRTOS线程内执行（将来，将为每个调试的业务逻辑脚本分配一个单独的线程，并在其中与环境一起执行该脚本）。 <br><br><h2> 将lua子模块包含在项目中 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上项目</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方镜像</a>将用作lua库的源代码（因为我的项目也发布在该库中。您可以直接从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方站点</a>使用源代码）。 由于项目有一个已建立的系统，用于将子模块作为项目的一部分进行组装，因此每个子模块都有单独的CMakeLists，因此我创建了一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单独的子模块</a> ，其中包含了此fork和CMakeLists以维护单个构建样式。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMakeLists</a>使用以下子模块编译标志（取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自主</a>项目中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的子模块配置文件</a> ）将lua存储库的源构建为静态库： <br><br><pre><code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(C_COMPILER_FLAGS <span class="hljs-string"><span class="hljs-string">"-std=gnu99;-fshort-enums;-fno-exceptions;-Wno-type-limits;-ffunction-sections;-fdata-sections;"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(MODULE_LUA_COMP_FLAGS <span class="hljs-string"><span class="hljs-string">"-O0;-g3;${C_COMPILER_FLAGS}"</span></span></code> </pre> <br> 以及所使用处理器的规范标志（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMakeLists根目录中</a>设置）： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;)</code> </pre> <br> 重要的是要注意需要根CMakeLists指定一个不允许使用双精度值的定义（因为微控制器不支持双精度，只有浮点型）： <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">add_definitions</span></span>(-DLUA_32BITS)</code> </pre> <br> 好吧，仅是要通知链接器有关需要汇编此库并将结果包括在最终项目的布局中的信息： <br><br><div class="spoiler">  <b class="spoiler_title">CMakeLists图，用于将项目与lua库链接</b> <div class="spoiler_text"><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">add_subdirectory</span></span>(<span class="hljs-variable"><span class="hljs-variable">${CMAKE_SOURCE_DIR}</span></span>/bsp/submodules/module_lua) ... <span class="hljs-keyword"><span class="hljs-keyword">target_link_libraries</span></span>(<span class="hljs-variable"><span class="hljs-variable">${PROJECT_NAME}</span></span>.elf PUBLIC <span class="hljs-comment"><span class="hljs-comment"># -Wl,--start-group       #      . #  Lua    ,      #  . "-Wl,--start-group" ..._... MODULE_LUA ..._... "-Wl,--end-group")</span></span></code> </pre> </div></div><br><h2> 定义用于内存的功能 </h2><br> 由于Lua本身不处理内存，因此此责任已转移给用户。 但是，当使用捆绑的<i>lauxlib</i>库和来自其中的<i>luaL_newstate</i>函数时， <i>l_alloc</i>函数将<i>绑定</i>为一个内存系统。 定义如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l_alloc</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ud, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nsize)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)ud; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)osize; <span class="hljs-comment"><span class="hljs-comment">/* not used */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nsize == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(ptr, nsize); }</code> </pre> <br> 如本文开头所提到的，该项目已经覆盖了<i>malloc</i>和<i>free</i>函数，但是没有<i>realloc</i>函数。 我们需要修复它。 <br><br> 在用于FreeRTOS堆的标准机制中，在项目中使用的heap_4.c文件中，没有用于调整先前分配的内存块大小的功能。 在这方面，有必要在<i>malloc</i>和<i>free</i>的基础上实现它。 <br><br> 由于将来可以更改内存分配方案（使用另一个heap_x.c文件），因此决定不使用当前方案的内部空间（heap_4.c），而是进行更高级别的加载。 虽然效果较差。 <br><br> 重要的是要注意， <i>realloc</i>方法不仅删除旧块（如果存在）并创建一个新块，还将数据从旧块移到新块。 此外，如果旧块中的数据比新块中的数据多，则将新块中的旧块填充到极限，然后丢弃其余数据。 <br><br> 如果不考虑这一事实，那么您的机器将能够从“ <i>a = 3 \ n</i> ”行执行三次这样的脚本，之后它将陷入严重故障。 通过研究硬故障处理程序中寄存器的残像，可以解决该问题，从中可以发现在尝试扩展解释器代码及其库的肠道中的表后发生崩溃。 如果您调用诸如“ <i>print'test'”之</i>类的脚本，则该行为将根据固件文件的组装方式而改变（换句话说，该行为未定义）。 <br><br> 为了将数据从旧块复制到新块，我们需要找出旧块的大小。  FreeRTOS heap_4.c（像其他提供堆处理方法的文件一样）没有为此提供API。 因此，您必须完成自己的工作。 作为基础，我采用了<i>vPortFree</i>函数并将其功能切割为以下形式： <br><br><div class="spoiler">  <b class="spoiler_title">VPortGetSizeBlock功能代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vPortGetSizeBlock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *puc = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *)pv; BlockLink_t *pxLink; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pv != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { puc -= xHeapStructSize; pxLink = (BlockLink_t *)puc; configASSERT((pxLink-&gt;xBlockSize &amp; xBlockAllocatedBit) != <span class="hljs-number"><span class="hljs-number">0</span></span>); configASSERT(pxLink-&gt;pxNextFreeBlock == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pxLink-&gt;xBlockSize &amp; ~xBlockAllocatedBit; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> </div></div><br> 现在很小了，根据<i>malloc</i> ， <i>free</i>和<i>vPortGetSizeBlock</i>编写<i>realloc</i> ： <br><br><div class="spoiler">  <b class="spoiler_title">基于malloc，free和vPortGetSizeBlock重新分配实现代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">realloc</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(new_size); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(new_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> old_size = vPortGetSizeBlock(ptr); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> cpy_len = (new_size &lt; old_size)?new_size:old_size; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(p, ptr, cpy_len); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(ptr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> </div></div><br><h2> 添加对使用stdout的支持 </h2><br> 从官方描述中可以知道，lua解释器本身无法使用I / O。 为此，连接了一个标准库。 对于输出，它使用<i>stdout</i>流。 标准库中的<i>luaopen_io</i>函数负责连接到流。 为了支持使用<i>stdout</i> （与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">printf</a>不同），您将需要覆盖<i>fwrite</i>函数。 我根据上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇文章中</a>描述的功能重新定义了它。 <br><br><div class="spoiler">  <b class="spoiler_title">Fwrite功能</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fwrite(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, FILE *stream) { stream = stream; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len = size * count; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*&gt;(buf); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_write_char((s[i])) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> len; }</code> </pre> </div></div><br> 如果没有定义，lua中的<i>打印</i>功能将成功执行，但是将没有输出。 此外，机器的Lua堆栈上不会有任何错误（因为该函数已正式成功执行）。 <br><br> 除了此功能外，我们还将需要<i>fflush</i>功能（ <i>要使</i>交互模式起作用，将在后面<i>讨论</i> ）。 由于无法覆盖此功能，因此您将不得不对其稍加命名。 该函数是<i>fwrite</i>函数的精简版本，旨在发送缓冲区中现在包含的内容并进行后续清理（无需额外的回车）。 <br><br><div class="spoiler">  <b class="spoiler_title">Mc_fflush函数</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mc_fflush</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> len = buf_p; buf_p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uart_1.tx(tx_buf, len, <span class="hljs-number"><span class="hljs-number">100</span></span>) != mc_interfaces::res::ok) { errno = EIO; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><h2> 从串行端口检索字符串 </h2><br> 为了获得lua机器的字符串，我决定编写一个简单的uart-terminal类，该类： <br><br><ul><li> 在串行端口上逐字节接收数据（在中断中）； </li><li> 将接收到的字节添加到队列中，流从该队列中接收它； </li><li> 如果不是换行，则以字节流的形式发送回它到达的形式； </li><li> 如果换行已到达（' <i>\ r</i> '），则发送2个字节的终端回车（“ <i>\ n \ r</i> ”）; </li><li> 发送响应后，将调用到达的字节的处理程序（行布局对象）； </li><li> 控制按下删除字符键（以避免从终端窗口删除服务字符）； </li></ul><br> 链接到资源： <br><br><ul><li>  UART类接口在<a href="">这里</a> ； </li><li>  UART基类在<a href="">这里</a>和<a href="">这里</a> ； </li><li>  <a href="">在这里</a>和<a href="">这里</a> uart_terminal类; </li><li> 在<a href="">此处</a>创建类对象作为项目的一部分。 </li></ul><br> 另外，我注意到，为了使该对象正常工作，您需要在允许的范围内为UART中断分配优先级，以便使用来自中断的FreeRTOS功能。 否则，您会得到有趣的难以调试的错误。 在当前示例中，在<a href="">FreeRTOSConfig.h</a>文件中设置了以下用于中断的选项。 <br><br><div class="spoiler">  <b class="spoiler_title">FreeRTOSConfig.h中的设置</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configPRIO_BITS 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configKERNEL_INTERRUPT_PRIORITY 0XF0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   FreeRTOS API   //   0x8 - 0xF. #define configMAX_SYSCALL_INTERRUPT_PRIORITY 0x80</span></span></span></span></code> </pre> </div></div><br> 在项目本身中，类<i>nvic</i>的对象设置了中断0x9的优先级，该优先级包含在有效范围内（类nvic <a href="">在此处</a>和<a href="">此处</a>描述）。 <br><br><h2>  Lua机器的弦形成 </h2><br> 从uart_terminal对象收到的字节被传输到简单类serial_cli的实例，该类提供了用于编辑字符串并将其直接传输到执行lua机器的线程的最小接口（通过调用回调函数）。 接受字符“ \ r”后，将调用回调函数。 此函数应向其自身复制一条线并“释放”控制权（因为在调用过程中阻止了新字节的接收。这对于正确区分优先级的流和足够低的UART速度而言不是问题）。 <br><br> 链接到资源： <br><br><ul><li>  serial_cli描述文件<a href="">在这里</a>和<a href="">这里</a> ； </li><li> 在<a href="">此处</a>创建类对象作为项目的一部分。 </li></ul><br> 重要的是要注意，此类认为长度超过255个字符的字符串无效，并将其丢弃。 这是有意的，因为lua解释器允许您逐行输入构造，等待块的结尾。 <br><br><h2> 将字符串传递给Lua解释器及其执行 </h2><br>  Lua解释器本身不知道如何逐行接受块代码，然后自己执行整个块。 但是，如果在计算机上安装Lua并以交互方式运行解释器，我们可以看到执行过程是逐行的，键入时带有相应的符号，表示该块尚未完成。 由于交互模式是标准软件包中提供的，因此我们可以看到其代码。 它位于<a href="">lua.c</a>文件中。 我们对<i>doREPL</i>函数及其使用的一切感兴趣。 为了不拿自行车，要在项目中获得交互模式功能，我在单独的类中创建了此代码的端口，我用原始函数的名称命名为<i>lua_repl</i> ，该函数使用printf将信息打印到控制台，并具有公共方法<i>add_lua_string</i>来添加从类对象接收的行上述的serial_cli。 <br><br> 参考文献： <br><br><ul><li> 类描述lua_repl <a href="">在这里</a> ; </li><li>  <a href="">在这里</a> ， <a href="">这里</a>和<a href="">这里</a>编码; </li></ul><br> 该类根据单例Myers模式进行，因为不需要在同一设备内提供几种交互模式。  lua_repl类的对象在<a href="">此处</a>从serial_cli类的对象接收数据。 <br><br> 由于项目已经具有用于初始化和服务全局对象的统一系统，因此将指向lua_repl类的对象的指针传递给全局类<a href="">player :: base</a>的对象。 在class <a href="">player :: base</a>类的对象的<i>start</i>方法中（ <a href="">在此</a>声明。也从main中调用），以FreeRTOS 3任务的优先级调用lua_repl类的对象的<i>init</i>方法（在项目中，您可以将任务的优先级从1分配到4。其中1是最低的优先级，而4是最高的）。 成功初始化之后，全局类将启动FreeRTOS调度程序，并且交互模式将开始其工作。 <br><br><h2> 移植问题 </h2><br> 下面是在机器的Lua端口期间遇到的问题的列表。 <br><br><h4> 执行2-3个变量分配的单行脚本，然后一切都会陷入严重故障 </h4><br> 问题出在realloc方法上。 不仅需要重新选择块，而且还需要复制旧块的内容（如上所述）。 <br><br><h4> 尝试打印值时，解释器会陷入严重错误 </h4><br> 发现问题已经更加困难，但是最后我设法找出snprintf用于打印。 由于lua将值存储为double（在我们的情况下为float），所以需要带浮点支持的printf（及其派生类）（我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>写过printf的复杂性）。 <br><br><h2> 非易失性（闪存）存储器的要求 </h2><br> 这是我进行的一些测量，目的是判断将Lua机器集成到项目中需要分配多少非易失性（闪存）内存。 使用gcc-arm-none-eabi-8-2018-q4-major进行编译。 使用了Lua 5.4版本。 在下面的测量中，短语“无Lua”表示不包括解释器及其与其库的交互方法以及该项目中lua_repl类的对象。 所有低级实体（包括<i>printf</i>和<i>fwrite</i>函数的替代）都保留在项目中。  FreeRTOS堆大小为1024 * 25字节。 其余的则由全球项目实体占用。 <br><br> 结果汇总表如下（所有大小以字节为单位）： <br><table border="1"><tbody><tr><th> 构建选项 </th><th> 没有lua </th><th> 仅核心 </th><th> 带有基础库的Lua </th><th> 带有库库，协程，表，字符串的Lua </th><th>  luaL_openlibs </th></tr><tr><td>  -O0 -g3 </td><td>  103028 </td><td>  220924 </td><td>  236124 </td><td>  262652 </td><td>  308372 </td></tr><tr><td>  -O1 -g3 </td><td>  74940 </td><td>  144732 </td><td>  156916 </td><td>  174452 </td><td>  213068 </td></tr><tr><td>  -Os -g0 </td><td>  71172 </td><td>  134228 </td><td>  145756 </td><td>  161428 </td><td>  198400 </td></tr></tbody></table><br><h2>  RAM要求 </h2><br> 由于RAM的消耗完全取决于任务，因此在打开具有不同库集的计算机后，我将立即给出消耗的内存的摘要表（它通过<i>print</i>显示<i>（collect（垃圾（“ count”）* 1024）</i>命令））。 <br><table border="1"><tbody><tr><td> 组成 </td><td> 使用的RAM </td></tr><tr><td> 带有基础库的Lua </td><td>  4809 </td></tr><tr><td> 带有库库，协程，表，字符串的Lua </td><td>  6407 </td></tr><tr><td>  luaL_openlibs </td><td>  12769 </td></tr></tbody></table><br> 在使用所有库的情况下，与以前的库相比，所需RAM的大小显着增加。 但是，没有必要在相当一部分应用程序中使用它。 <br><br> 另外，还将4 kb分配给执行Lua机器的任务堆栈。 <br><br><h2> 进一步使用 </h2><br> 为了在项目中充分利用机器，您将需要进一步描述项目的硬件或服务对象的业务逻辑代码所需的所有接口。 但是，这是另一篇文章的主题。 <br><br><h2> 总结 </h2><br> 本文介绍了如何将Lua机器连接到用于微控制器的项目，以及如何启动功能全面的交互式解释器，使您可以直接从终端的命令行尝试业务逻辑。 此外，针对Lua机器的不同配置，考虑了对微控制器硬件的要求。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459602/">https://habr.com/ru/post/zh-CN459602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459590/index.html">Waves区块链上的去中心化开源会员计划</a></li>
<li><a href="../zh-CN459592/index.html">尝试一切的人的三个时间管理技巧。</a></li>
<li><a href="../zh-CN459594/index.html">阅读笔记之间：音乐内部的数据传输系统</a></li>
<li><a href="../zh-CN459596/index.html">iOS摘要9（6月28日-7月11日）</a></li>
<li><a href="../zh-CN459598/index.html">SELinux常见问题（FAQ）</a></li>
<li><a href="../zh-CN459604/index.html">电报-机器人| 全菜单</a></li>
<li><a href="../zh-CN459606/index.html">分布式社交网络</a></li>
<li><a href="../zh-CN459610/index.html">这些危险的路由器：近期网络设备中最大规模的黑客入侵和防护方法</a></li>
<li><a href="../zh-CN459612/index.html">高通连续近20年如何脱颖而出</a></li>
<li><a href="../zh-CN459614/index.html">机器人鸭激起稻田</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>