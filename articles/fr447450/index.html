<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔏 👨🏼‍🚒 ⛴️ Briser une simple «fissure» avec Ghidra - Partie 1 👽 🙈 👩🏿‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beaucoup de gens savent probablement déjà de quel genre de bête il s'agit - Ghidra ("Hydra") et ce qu'il mange avec le programme de première main, bie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Briser une simple «fissure» avec Ghidra - Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447450/">  Beaucoup de gens savent probablement déjà de quel genre de bête il s'agit - <b>Ghidra</b> ("Hydra") et ce qu'il mange avec le programme de première main, bien que cet outil n'ait été rendu public que récemment - en mars de cette année.  Je ne dérangerai pas les lecteurs avec une description d'Hydra, de ses fonctionnalités, etc.  Ceux qui sont dans le sujet, j'en suis sûr, ont déjà étudié tout cela eux-mêmes, et ceux qui ne sont pas encore dans le sujet - ils peuvent le faire à tout moment, car maintenant il est facile de trouver des informations détaillées sur Internet.  Soit dit en passant, l'un des aspects d'Hydra (le développement de plugins pour celui-ci) a déjà été <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">couvert</a> sur Habré (excellent article!) Je ne donnerai que les liens principaux: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Page officielle sur le site de la NSA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Première critique dans Hacker Magazine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grande chaîne YouTube avec des programmes d'analyse dans Ghidra</a> </li></ul><br>  Hydra est donc un <em>désassembleur et décompilateur interactif multiplateforme gratuit avec une structure modulaire, avec la prise en charge de presque toutes les principales architectures CPU et une interface graphique flexible pour travailler avec du code désassemblé, de la mémoire, du code récupéré (décompilé), des symboles de débogage, et bien plus encore</em> . <br><br>  Essayons de casser quelque chose avec cette Hydra! <br><a name="habracut"></a><br><h2>  Étape 1. Trouvez et étudiez la fissure </h2><br>  En tant que «victime», nous trouvons un simple programme «crackme».  Je suis juste allé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crackmes.one</a> , indiqué dans la recherche le niveau de difficulté = 2-3 ("simple" et "moyen"), la langue source du programme = "C / C ++" et la plateforme = "Multiplateforme", comme dans la capture d'écran ci-dessous: <br><br><img src="https://habrastorage.org/webt/oz/hh/4w/ozhh4w-nraygltspefvjnyrvpjk.png"><br><br>  La recherche a donné 2 résultats (en vert ci-dessous).  La première fissure s'est avérée être 16 bits et n'a pas démarré sur mon Win10 64 bits, mais la seconde ( <b>level_2 by seveb</b> ) est apparue.  Vous pouvez le télécharger à partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce lien</a> . <br><br>  Téléchargez et décompressez la fissure;  Le mot de passe pour l'archive, tel qu'indiqué sur le site, est <b>crackmes.de</b> .  Dans l'archive, nous trouvons deux répertoires correspondant à Linux et Windows.  Sur ma machine, je vais dans le répertoire Windows et j'y rencontre le seul "exécutable" - <b>level_2.exe</b> .  Courons et voyons ce qu'elle veut: <br><br><img src="https://habrastorage.org/webt/qx/mu/yj/qxmuyjfvnatrgoggnmet17egii8.png"><br><br>  Cela ressemble à une déception!  Au démarrage, le programme n'affiche rien.  Nous essayons de l'exécuter à nouveau, en lui passant une chaîne arbitraire comme paramètre (tout d'un coup, attend-il une clé?) - et encore rien ... Mais ne désespérez pas.  Supposons que nous devions également trouver les paramètres de lancement en tant que tâche!  Il est temps de découvrir notre "couteau suisse" - Hydra. <br><br><h2>  Étape 2. Création d'un projet dans Hydra et analyse préliminaire </h2><br>  Supposons que Hydra soit déjà installé.  Sinon, tout est simple. <br><br><div class="spoiler">  <b class="spoiler_title">Installer Ghidra</b> <div class="spoiler_text">  1) installez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JDK</a> version 11 ou supérieure (j'en ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">12</a> ) <br><br>  2) téléchargez Hydra (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> ) et installez-le (au moment de la rédaction, la dernière version d'Hydra est 9.0.2, j'ai 9.0.1) <br></div></div><br>  Nous lançons Hydra et dans le gestionnaire de projet ouvert, créons immédiatement un nouveau projet;  Je lui ai donné le nom de <b>crackme3</b> (c'est-à-dire que des projets crackme et crackme2 ont déjà été créés pour moi).  Le projet est, en fait, un répertoire de fichiers, vous pouvez y ajouter tous les fichiers à étudier (exe, dll, etc.).  Nous ajouterons immédiatement notre level_2.exe ( <b>Fichier | Importer</b> ou simplement la clé <b>I</b> ): <br><br><img src="https://habrastorage.org/webt/sb/gl/_e/sbgl_e0acdolgbxtvjnuohiscua.png"><br><br>  Nous voyons qu'avant l'importation, Hydra a identifié notre charlatan expérimental comme un PE 32 bits (exécutable portable) pour le système d'exploitation Win32 et la plate-forme x86.  Après l'importation, nous attendons encore plus d'informations: <br><br><img src="https://habrastorage.org/webt/zb/v0/ga/zbv0gatojwqtmbdejhe6zclenac.png"><br><br>  Ici, en plus de la profondeur de bits susmentionnée, nous pouvons toujours être intéressés par l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ordre d'endianness</a> , qui dans notre cas est <b>peu</b> (de bas à élevé), qui était attendu pour la plate-forme Intel 86e. <br><br>  Avec une analyse préliminaire, nous avons terminé. <br><br><h2>  Étape 3. Effectuez une analyse automatique </h2><br>  Il est temps de commencer une analyse entièrement automatique du programme dans Hydra.  Cela se fait en double-cliquant sur le fichier correspondant (level_2.exe).  Ayant une structure modulaire, Hydra fournit toutes ses fonctionnalités de base avec un système de plug-in qui peut être ajouté / désactivé ou développé indépendamment.  Il en va de même pour l'analyse - chaque plugin est responsable de son type d'analyse.  Par conséquent, tout d'abord, nous sommes confrontés à cette fenêtre où vous pouvez sélectionner les types d'analyse d'intérêt: <br><br><div class="spoiler">  <b class="spoiler_title">Fenêtre Paramètres d'analyse</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/p2/aw/sa/p2awsa9slwl8tkbjo0mtcbkgnh8.png"></div></div><br>  Pour nos besoins, il est logique de laisser les paramètres par défaut et d'exécuter l'analyse.  L'analyse elle-même est effectuée assez rapidement (cela m'a pris environ 7 secondes), bien que les utilisateurs des forums se plaignent que pour les grands projets, Hydra perd de la vitesse par rapport à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDA Pro</a> .  Cela peut être vrai, mais pour les petits fichiers, cette différence n'est pas significative. <br><br>  Ainsi, l'analyse est terminée.  Ses résultats sont affichés dans la fenêtre du navigateur de code: <br><br><img src="https://habrastorage.org/webt/lh/dy/e5/lhdye5faqmse8w2evahggln5bge.png"><br><br>  Cette fenêtre est la principale pour travailler dans Hydra, vous devez donc l'étudier plus attentivement. <br><br><div class="spoiler">  <b class="spoiler_title">Présentation de l'interface du navigateur de code</b> <div class="spoiler_text">  Les paramètres d'interface par défaut divisent la fenêtre en trois parties. <br><br>  Dans la <b>partie centrale se</b> trouve la fenêtre principale - une liste du désassembleur, qui est plus ou moins similaire à ses "frères" dans IDA, OllyDbg, etc.  Par défaut, les colonnes de cette liste sont (de gauche à droite): adresse mémoire, opcode de la commande, commande ASM, paramètres de la commande ASM, référence croisée (le cas échéant).  Naturellement, l'affichage peut être modifié en cliquant sur le bouton sous la forme d'un mur de briques dans la barre d'outils de cette fenêtre.  Pour être honnête, je n'ai jamais vu une telle configuration flexible de la sortie du démonteur nulle part, c'est extrêmement pratique. <br><br>  Dans la <b>partie gauche du</b> panneau 3: <br><br><ol><li>  Sections du programme (cliquez sur la souris pour parcourir les sections) </li><li>  Arbre de caractères (importations, exportations, fonctions, en-têtes, etc.) </li><li>  Arbre de type des variables utilisées </li></ol><br>  Pour nous, la fenêtre la plus utile ici est une arborescence de symboles, qui vous permet de trouver rapidement, par exemple, une fonction par son nom et d'aller à l'adresse correspondante. <br><br>  Sur le <b>côté droit</b> est une liste du code décompilé (dans notre cas, en C). <br><br>  En plus des fenêtres par défaut, dans le menu <b>Fenêtre</b> , vous pouvez sélectionner et placer des dizaines d'autres fenêtres et affichages n'importe où dans le navigateur.  Pour plus de commodité, j'ai ajouté une fenêtre d'octets et une fenêtre avec un graphique de fonction au centre, et à droite, des variables de chaîne (chaînes) et un tableau de fonctions (fonctions).  Ces fenêtres sont désormais disponibles dans des onglets séparés.  De plus, toutes les fenêtres peuvent être détachées et rendues "flottantes", en les plaçant et en les redimensionnant à votre discrétion - c'est aussi une solution très réfléchie, à mon avis. <br></div></div><br><h2>  Étape 4. Apprentissage de l'algorithme du programme - fonction main () </h2><br>  Eh bien, procédons à une analyse directe de nos programmes de crack.  Dans la plupart des cas, vous devez commencer par rechercher le point d'entrée du programme, c'est-à-dire  La fonction principale qui est appelée au démarrage.  Sachant que notre crack a été écrit en C / C ++, nous supposons que le nom de la fonction principale sera <b>main ()</b> ou quelque chose comme ça :) C'est dit et fait.  Entrez "main" dans le filtre de l'Arbre des Symboles (dans le panneau de gauche) et voyez la fonction <b>_main ()</b> dans la section <b>Fonctions</b> .  Allez-y avec un clic de souris. <br><br><h3>  Présentation de la fonction main () et changement de nom des fonctions obscures </h3><br>  Dans la liste des désassembleurs, la section de code correspondante est immédiatement affichée et à droite, nous voyons le code C décompilé de cette fonction.  Il convient de noter une autre caractéristique pratique de la synchronisation Hydra - sélection: lorsqu'une souris sélectionne une plage de commandes ASM, la section de code correspondante dans le décompilateur est mise en surbrillance et vice versa.  De plus, si la fenêtre d'affichage de la mémoire est ouverte, l'allocation est synchronisée avec la mémoire.  Comme on dit, tout ingénieux est simple! <br><br>  Immédiatement, je note une caractéristique importante du travail chez Hydra (contrairement, par exemple, au travail chez IDA).  <em>Le travail dans Hydra est principalement axé sur l'analyse de code décompilé</em> .  Pour cette raison, les créateurs d'Hydra (nous nous souvenons - nous parlons d'espions de la NSA :)) ont accordé une grande attention à la qualité de la décompilation et à la commodité de travailler avec du code.  En particulier, on peut simplement aller à la définition des fonctions, des variables et des sections de mémoire en double-cliquant dans le code.  De plus, n'importe quelle variable et fonction peut être immédiatement renommée, ce qui est très pratique, car les noms par défaut n'ont pas de sens et peuvent prêter à confusion.  Comme vous le verrez plus loin, nous utiliserons souvent ce mécanisme. <br><br>  Voici donc la fonction <b>main ()</b> qu'Hydra a «disséquée» comme suit: <br><br><div class="spoiler">  <b class="spoiler_title">Liste main ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __cdecl _main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _Argc,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Argv,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **_Env) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bVar1; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar2; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar3; FILE *_File; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **ppcVar4; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_18; ___main(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); local_18 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_18 &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { _text(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); _text(_Dest,_Argv[local_18],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } sVar3 = _text(_Argv[local_18]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((sVar3 == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[local_18] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[local_18][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } local_18 = local_18 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { _File = _text(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ppcVar4 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar4 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { _text(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _text(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar4 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar4); } _text(_File); } _text(_Dest); iVar2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { iVar2 = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> iVar2; }</code> </pre> <br></div></div><br>  Il semble que tout semble normal - définitions des variables, types C standard, conditions, boucles, appels de fonction.  Mais en regardant de plus près le code, nous remarquons que pour une raison quelconque, les noms de certaines fonctions n'ont pas été définis et remplacés par la pseudo- <b>fonction _text ()</b> (dans la fenêtre du décompilateur - <b>.text ()</b> ).  Commençons par définir quelles sont ces fonctions. <br><br>  Double-cliquer sur le corps du premier appel <br><br><pre> <code class="cpp hljs"> _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)_text(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  nous voyons que c'est juste une fonction wrapper autour de la fonction standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">calloc ()</a> , qui est utilisée pour allouer de la mémoire pour les données.  <b>Renommons donc</b> cette fonction en <b>calloc2 ()</b> .  Positionnez le curseur sur l'en-tête de la fonction, appelez le menu contextuel et sélectionnez <b>Renommer la fonction</b> (touche de raccourci - <b>L</b> ) et entrez un nouveau nom dans le champ qui s'ouvre: <br><br><img src="https://habrastorage.org/webt/nz/q1/3z/nzq13zx8ddn0vsbvni8mkpencyc.png"><br><br>  On voit que la fonction a été immédiatement renommée.  Nous revenons au corps <b>principal ()</b> (le bouton <b>Retour</b> dans la barre d'outils ou <b>Alt + &lt;-</b> ) et nous voyons qu'ici au lieu du mystérieux <b>_text () calloc2 ()</b> se trouve déjà.  Super! <br><br>  Nous faisons de même avec toutes les autres fonctions wrapper: nous entrons dans leur définition une par une, voyons ce qu'elles font, renommons (j'ai ajouté l'index 2 aux noms standard des fonctions C) et revenons à la fonction principale. <br><br><h3>  Nous comprenons le code de la fonction main () </h3><br>  D'accord, nous avons découvert des fonctions étranges.  Nous commençons à étudier le code de la fonction principale.  En sautant les déclarations de variables, nous voyons que la fonction renvoie la valeur de la variable iVar2, qui est zéro (signe de succès de la fonction) uniquement si la condition spécifiée par la chaîne est remplie <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_Argc == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ... }</code> </pre><br>  <b>_Argc</b> est le nombre de paramètres de ligne de commande (arguments) passés à <b>main ()</b> .  Autrement dit, notre programme «mange» 2 arguments (le premier argument, nous nous en souvenons, est toujours le chemin d'accès au fichier exécutable). <br><br>  OK, passons.  Ici, nous créons une chaîne C (tableau de caractères) de 256 caractères: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *_Dest; _Dest = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)calloc2(<span class="hljs-number"><span class="hljs-number">0x100</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  new char[256]  C++</span></span></code> </pre><br>  Ensuite, nous avons une boucle de 3 itérations.  Dans ce document, nous vérifions d'abord si l'indicateur <b>bVar1</b> est <b>défini,</b> et si c'est le cas, copiez l'argument (chaîne) de ligne de commande suivant dans <b>_Dest</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    .  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bVar1) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> memset2(_Dest,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    _Dest    */</span></span> strncpy2(_Dest,_Argv[i],<span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ... }</code> </pre><br>  Cet indicateur est défini lors de l'analyse de l'argument suivant: <br><br><pre> <code class="cpp hljs">n_strlen = strlen2(_Argv[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((n_strlen == <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*_Argv[i] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x2d</span></span>)) &amp;&amp; (((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)_Argv[i][<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x7fffffff</span></span>U) == <span class="hljs-number"><span class="hljs-number">0x66</span></span>)) { bVar1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  La première ligne calcule la longueur de cet argument.  De plus, la condition vérifie que la longueur de l'argument doit être 2, l'avant-dernier caractère == "-" et le dernier caractère == "f".  Notez comment le décompilateur a "traduit" l'extraction des caractères de la chaîne à l'aide d'un masque d'octets. <br><blockquote>  Les valeurs décimales des nombres, et en même temps les caractères ASCII correspondants, peuvent être espionnés en maintenant le curseur sur le littéral hexadécimal correspondant.  Le mappage ASCII ne fonctionne pas toujours (?), Je recommande donc de consulter la table ASCII sur Internet.  Vous pouvez également directement dans Hydra convertir des scalaires de n'importe quel système numérique vers un autre (via le menu contextuel -&gt; <b>Convertir</b> ), dans ce cas, ce nombre sera affiché partout dans le système numérique sélectionné (dans le désassembleur et dans le décompilateur);  mais personnellement, je préfère laisser des hexagones dans le code pour l'harmonie du travail, car  adresses mémoire, décalages, etc.  les hexs sont placés partout. <br></blockquote>  Après la boucle vient ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((bVar1) &amp;&amp; (*_Dest != <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    1) "-f"  2)  -         */</span></span> _File = fopen2(_Dest,<span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_File == (FILE *)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  1    */</span></span> perror2(<span class="hljs-string"><span class="hljs-string">"Failed to open file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... }</code> </pre><br>  Ici, j'ai immédiatement ajouté des commentaires.  Nous vérifions la validité des arguments ("-f path_to_file") et ouvrons le fichier correspondant (le 2ème argument passé, que nous avons copié dans _Dest).  Le fichier sera lu au format binaire, comme indiqué par le paramètre "rb" de la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fopen ()</a> .  Si la lecture échoue (par exemple, le fichier n'est pas disponible), un message d'erreur s'affiche dans le flux stderror et le programme se ferme avec le code 1. <br><br>  Le suivant est le plus intéressant: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* !!!     !!! */</span></span> ppcVar3 = _construct_key(_File); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppcVar3 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*    ,  "Nope" */</span></span> puts2(<span class="hljs-string"><span class="hljs-string">"Nope."</span></span>); _free_key((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    -      */</span></span> printf2(<span class="hljs-string"><span class="hljs-string">"%s%s%s%s\n"</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x10d</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x219</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x325</span></span>,*ppcVar3 + <span class="hljs-number"><span class="hljs-number">0x431</span></span>); _free_key(ppcVar3); } fclose2(_File);</code> </pre><br>  Le descripteur de fichier ouvert ( <b>_File</b> ) est transmis à la fonction <b>_construct_key ()</b> , qui, évidemment, effectue la vérification de la clé recherchée.  Cette fonction renvoie un tableau d'octets à deux dimensions ( <b>char **</b> ), qui est stocké dans la variable <b>ppcVar3</b> .  Si le tableau est vide, le «Nope» concis est affiché sur la console (c'est-à-dire, à notre avis, «Nope!») Et la mémoire est libérée.  Sinon (si le tableau n'est pas vide), la clé apparemment correcte s'affiche et la mémoire est également libérée.  À la fin de la fonction, le descripteur de fichier se ferme, la mémoire est libérée et la valeur de <b>iVar2 est renvoyée</b> . <br><br>  Donc, maintenant nous avons réalisé que nous avons besoin de: <br><br>  <i>1) créez un fichier binaire avec la bonne clé;</i> <i><br></i>  <i>2) passer son chemin dans la fissure après l'argument "-f"</i> <br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxième partie de l'article,</a> nous analyserons la fonction <b>_construct_key ()</b> qui, comme nous l'avons découvert, est chargée de vérifier la clé souhaitée dans le fichier. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447450/">https://habr.com/ru/post/fr447450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447438/index.html">Tests les plus simples et abstraits</a></li>
<li><a href="../fr447440/index.html">RBKmoney Payments sous le capot - la logique de la plateforme de paiement</a></li>
<li><a href="../fr447442/index.html">Présentation de l'opérateur shell: faciliter encore plus les opérateurs pour Kubernetes</a></li>
<li><a href="../fr447446/index.html">Ateliers IBM: printemps-été 2019 - intelligence artificielle, développement cloud, chat bots, blockchain et autres technologies</a></li>
<li><a href="../fr447448/index.html">Evolution de l'intelligence: le début</a></li>
<li><a href="../fr447452/index.html">Sécurité de la chaîne d'approvisionnement: "Si j'étais un État-nation ..."</a></li>
<li><a href="../fr447454/index.html">Contrôle d'affichage FPGA à sept segments</a></li>
<li><a href="../fr447456/index.html">Avec quelle précision Yandex prévoit-il les précipitations en hiver? Nous analysons la précision des services prédictifs</a></li>
<li><a href="../fr447458/index.html">Comment de nouveaux mots sont créés en anglais moderne</a></li>
<li><a href="../fr447460/index.html">Piratez votre aspirateur XiaoMi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>