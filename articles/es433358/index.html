<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèæ ‚öôÔ∏è üëÇ Familiaridad con las pruebas en Python. Parte 1 üöò ü•• üë®‚Äçüë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen dia a todos! 

 De nuestra mesa a la suya ... Es decir, de nuestro curso de Desarrollador de Python, a pesar del a√±o nuevo que se acerca r√°pidame...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Familiaridad con las pruebas en Python. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/433358/"> Buen dia a todos! <br><br>  <s>De nuestra mesa a la suya ...</s> Es decir, de nuestro curso de Desarrollador de Python, a pesar del a√±o nuevo que se acerca r√°pidamente, hemos preparado una traducci√≥n interesante para usted sobre varios m√©todos de prueba en Python. <br><br>  Esta gu√≠a es para aquellos que ya han escrito una aplicaci√≥n genial de Python pero a√∫n no han escrito para <br>  ellos pruebas. <br><br>  Las pruebas en Python son un tema extenso con muchas sutilezas, pero no es necesario complicar las cosas.  En unos pocos pasos simples, puede crear pruebas simples para la aplicaci√≥n, aumentando gradualmente la complejidad en funci√≥n de ellas. <br><br>  En esta gu√≠a, aprender√° c√≥mo crear una prueba b√°sica, ejecutarla y encontrar todos los errores antes de que los usuarios lo hagan.  Aprender√° sobre las herramientas disponibles para escribir y ejecutar pruebas, verificar el rendimiento de la aplicaci√≥n e incluso ver los problemas de seguridad. <br><br><img src="https://habrastorage.org/webt/kh/va/x5/khvax5ew8tluy6c9muhw-oei7cm.png"><br><a name="habracut"></a><br>  <b>Prueba de c√≥digo</b> <br><br>  Puede probar el c√≥digo de muchas maneras.  En esta gu√≠a, aprender√° acerca de los m√©todos, desde el m√°s simple hasta el m√°s avanzado. <br><br>  <i><b>Automatizado vs.</b></i>  <i><b>Prueba manual</b></i> <i><br></i> <br>  Buenas noticias!  Lo m√°s probable es que ya haya realizado la prueba, pero a√∫n no se haya dado cuenta.  ¬øRecuerdas c√≥mo empezaste la aplicaci√≥n y la usaste?  ¬øHas probado las funciones y experimentado con ellas?  Este proceso se llama prueba exploratoria, y es una forma de prueba manual. <br><br>  Pruebas de investigaci√≥n: pruebas que se realizan sin un plan.  Durante las pruebas de investigaci√≥n, investigas la aplicaci√≥n. <br><br>  Para crear una lista completa de pruebas manuales, es suficiente hacer una lista de todas las funciones de la aplicaci√≥n, varios tipos de entrada que acepta y los resultados esperados.  Ahora, cada vez que cambie algo en el c√≥digo, debe volver a verificar cada uno de los elementos de esta lista. <br><br>  Suena sombr√≠o, ¬øverdad? <br><br>  Por lo tanto, se necesitan pruebas autom√°ticas.  Pruebas autom√°ticas: ejecuci√≥n del plan de pruebas (partes de la aplicaci√≥n que requieren pruebas, el orden de las pruebas y los resultados esperados) utilizando un script y no por manos humanas.  Python ya tiene un conjunto de herramientas y bibliotecas para ayudarlo a crear pruebas automatizadas para su aplicaci√≥n.  Veamos estas herramientas y bibliotecas en nuestro tutorial. <br><br>  <i><b>Pruebas unitarias VS.</b></i>  <i><b>Pruebas de integraci√≥n</b></i> <br><br>  El mundo de las pruebas est√° lleno de t√©rminos, y ahora, conociendo la diferencia entre las pruebas manuales y automatizadas, profundizaremos. <br><br>  ¬øPiensa en c√≥mo puede probar los faros de un autom√≥vil?  Enciende los faros (llam√©moslo el paso de prueba), salga del autom√≥vil usted mismo o p√≠dale a un amigo que verifique que los faros est√©n encendidos (y esta es una propuesta de prueba).  La prueba de m√∫ltiples componentes se llama prueba de integraci√≥n. <br><br>  Piense en todas las cosas que deber√≠an funcionar correctamente para que una tarea simple produzca el resultado correcto.  Estos componentes son similares a partes de su aplicaci√≥n: todas esas clases, funciones, m√≥dulos que escribi√≥. <br><br>  La principal dificultad de las pruebas de integraci√≥n surge cuando la prueba de integraci√≥n no da el resultado correcto.  Es dif√≠cil evaluar el problema, no poder aislar la parte rota del sistema.  Si los faros no est√°n encendidos, las bombillas pueden estar rotas.  ¬øO tal vez la bater√≠a est√° baja?  ¬øO tal vez el problema est√° en el generador?  ¬øO incluso un choque en la computadora de la m√°quina? <br><br>  Los autos modernos le notificar√°n sobre una bombilla rota.  Esto se determina usando una prueba unitaria. <br><br>  La prueba unitaria (prueba unitaria) es una prueba peque√±a que verifica el funcionamiento correcto de un componente individual.  La prueba de la unidad ayuda a aislar el desglose y arreglarlo m√°s r√°pido. <br><br>  Hablamos de dos tipos de pruebas: <br><br><ol><li>  Una prueba de integraci√≥n que verifica los componentes del sistema y su interacci√≥n entre ellos; </li><li>  Una prueba unitaria que prueba un solo componente de una aplicaci√≥n. </li><li>  Puede crear ambas pruebas en Python.  Para escribir una prueba para la funci√≥n sum () incorporada, debe comparar la salida de sum () con valores conocidos. </li></ol><br>  Por ejemplo, de esta manera puede verificar que la suma de los n√∫meros (1, 2, 3) es 6: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Los valores son correctos, por lo que no se enviar√° nada a REPL.  Si el resultado de <code>sum()</code> incorrecto, se lanzar√° un <code>AssertionError</code> con el mensaje "Deber√≠a ser 6".  Verifique la declaraci√≥n de la declaraci√≥n nuevamente, pero ahora con valores no v√°lidos para obtener un <code>AssertionError</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  En REPL, ver√° <code>AssertionError</code> ya que el valor <code>sum()</code> no es 6. <br><br>  En lugar de REPL, coloque esto en un nuevo archivo de Python llamado <code>test_sum.py</code> y ejec√∫telo nuevamente: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre> <br>  Ahora tiene un caso de prueba escrito (caso de prueba), declaraci√≥n y punto de entrada (l√≠nea de comando).  Ahora esto se puede hacer en la l√≠nea de comando: <br><br><pre> <code class="python hljs">$ python test_sum.py Everything passed</code> </pre> <br>  Usted ve el resultado exitoso, "Todo pas√≥". <br><br>  <code>sum()</code> en Python acepta cualquier iterable como primer argumento.  Has revisado la lista.  Intentemos probar la tupla.  Cree un nuevo archivo llamado <code>test_sum_2.py</code> con el siguiente c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() test_sum_tuple() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre><br>  <code>test_sum_2.py</code> , el script <code>test_sum_2.py</code> error, ya que s <code>um() (1, 2, 2)</code> debe ser 5, no 6. Como resultado, el script muestra un mensaje de error, una l√≠nea de c√≥digo y un rastreo: <br><br><pre> <code class="python hljs">$ python test_sum_2.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; test_sum_tuple() File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Puede ver c√≥mo un error en el c√≥digo causa un error en la consola con informaci√≥n sobre d√≥nde ocurri√≥ y cu√°l fue el resultado esperado. <br><br>  Tales pruebas son adecuadas para una verificaci√≥n simple, pero ¬øqu√© pasa si hay m√°s errores que en uno?  Los corredores de prueba vienen al rescate.  Test Executor es una aplicaci√≥n especial dise√±ada para realizar pruebas, verificar datos de salida y proporcionar herramientas para depurar y diagnosticar pruebas y aplicaciones. <br><br>  <i><b>Elegir un ejecutor de prueba</b></i> <br><br>  Hay muchos corredores de prueba disponibles para Python.  Por ejemplo, unittest est√° integrado en la biblioteca est√°ndar de Python.  En esta gu√≠a, utilizaremos casos de prueba y ejecutores de pruebas unitarias.  Los principios operativos de Unittest se adaptan f√°cilmente a otros marcos.  Enumeramos los ejecutores de prueba m√°s populares: <br><br><ul><li>  prueba de unidad; </li><li>  nariz o nariz2; </li><li>  Pytest. </li></ul><br>  Es importante elegir un contratista de prueba que cumpla con sus requisitos y experiencia. <br><br>  <b>prueba de unidad</b> <br><br>  unittest se ha integrado en la biblioteca est√°ndar de Python desde la versi√≥n 2.1.  Probablemente lo encontrar√° en aplicaciones comerciales de Python y proyectos de c√≥digo abierto. <br>  Unittest tiene un marco de prueba y un corredor de prueba.  Al escribir y ejecutar pruebas, debe seguir algunos requisitos importantes. <br><br>  unittest requiere: <br><br><ul><li>  Poner pruebas en clases como m√©todos; </li><li>  Use m√©todos de aprobaci√≥n especiales.  La clase TestCase en lugar de la expresi√≥n de aserci√≥n incorporada habitual. </li></ul><br><br>  Para convertir un ejemplo escrito anteriormente en un caso de prueba de prueba de unidad, debe: <br><br><ol><li>  Importar unittest desde la biblioteca est√°ndar; </li><li>  Cree una clase llamada <code>TestSum</code> que heredar√° la clase <code>TestCase</code> ; </li><li>  Convierta las funciones de prueba en m√©todos agregando <code>self</code> como primer argumento; </li><li>  Modifique las declaraciones agregando el uso del m√©todo <code>self.assertEqual()</code> en la clase <code>TestCase</code> ; </li><li>  Cambie el punto de entrada en la l√≠nea de comando para llamar a <code>unittest.main()</code> . </li></ol><br>  Siguiendo estos pasos, cree un nuevo archivo test_sum_unittest.py con este c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Al hacer esto en la l√≠nea de comando, obtendr√° una finalizaci√≥n exitosa (indicada por.) Y una incorrecta (indicada por F): <br><br><pre> <code class="python hljs">$ python test_sum_unittest.py .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Por lo tanto, realiz√≥ dos pruebas con el corredor de prueba unittest. <br><br>  <i>Nota: Si est√° escribiendo casos de prueba para Python 2 y 3, tenga cuidado.</i>  <i>En las versiones de Python 2.7 y posteriores, unittest se llama unittest 2. Cuando importe desde unittest, obtendr√° diferentes versiones con diferentes funciones en Python 2 y Python 3.</i> <br><br>  Para obtener m√°s informaci√≥n sobre unittest, lea la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de unittest</a> . <br><br>  <b>nariz</b> <br><br>  Con el tiempo, despu√©s de escribir cientos o incluso miles de pruebas para una aplicaci√≥n, se vuelve cada vez m√°s dif√≠cil de entender y usar los datos de salida de la prueba unitaria. <br><br>  nose es compatible con todas las pruebas escritas con unittest framework y puede reemplazar a su ejecutor de pruebas.  El desarrollo de nose, como una aplicaci√≥n de c√≥digo abierto, comenz√≥ a disminuir, y se cre√≥ nose2.  Si est√° comenzando desde cero, se recomienda que use nose2. <br><br>  Para comenzar con nose2 necesita instalarlo desde PyPl y ejecutarlo en la l√≠nea de comando.  nose2 intentar√° encontrar todos los scripts de <code>test*.py</code> con <code>test*.py</code> en el nombre y todos los casos de prueba heredados de unittest.TestCase en su directorio actual: <br><br><pre> <code class="python hljs">$ pip install nose2 $ python -m nose2 .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  As√≠ es como <code>test_sum_unittest.py</code> la prueba creada en <code>test_sum_unittest.py</code> desde el corredor de prueba nose2.  nose2 proporciona muchos indicadores de l√≠nea de comando para filtrar pruebas ejecutables.  Para obtener m√°s informaci√≥n, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de Nose 2</a> . <br><br>  <b>pytest</b> <br><br>  pytest admite casos de prueba unittest.  Pero la verdadera ventaja de pytest son sus casos de prueba.  Los casos de prueba de pytest son una serie de funciones en un archivo de Python con test_ al comienzo del nombre. <br><br>  Hay otras caracter√≠sticas √∫tiles en √©l: <br><br><ul><li>  Soporte para expresiones de aserci√≥n incorporadas en lugar de usar m√©todos especiales self.assert * (); </li><li>  Soporte para filtrar casos de prueba; </li><li>  La capacidad de reiniciar desde la √∫ltima prueba fallida; </li><li>  Un ecosistema de cientos de complementos que ampl√≠an la funcionalidad. </li></ul><br>  Un ejemplo de caso de prueba TestSum para pytest se ver√° as√≠: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Se deshizo de TestCase, utilizando clases y puntos de entrada de l√≠nea de comando. <br>  Se puede encontrar m√°s informaci√≥n en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio de documentaci√≥n de Pytest</a> . <br><br>  <b>Escribir la primera prueba</b> <br><br>  Combina todo lo que ya aprendimos y, en lugar de la funci√≥n incorporada <code>sum()</code> , probamos una implementaci√≥n simple con los mismos requisitos. <br><br>  Cree una nueva carpeta para el proyecto, dentro de la cual cree una nueva carpeta llamada my_sum.  Dentro de my_sum, cree un archivo vac√≠o llamado <code>_init_.py</code> .  La presencia de este archivo significa que la carpeta my_sum se puede importar como un m√≥dulo desde el directorio principal. <br><br>  La estructura de la carpeta se ver√° as√≠: <br><br> <code>project/ <br> ‚îÇ <br> ‚îî‚îÄ‚îÄ my_sum/ <br> ‚îî‚îÄ‚îÄ __init__.py</code> <br> <br>  Abra <code>my_sum/__init__.py</code> y cree una nueva funci√≥n llamada <code>sum()</code> , que toma entradas <code>my_sum/__init__.py</code> (list, tuple, set) y agrega los valores. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arg: total += val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total</code> </pre> <br>  Este ejemplo crea una variable llamada <code>total</code> , itera sobre todos los valores en <code>arg</code> y agrega al <code>total</code> .  Luego, al finalizar la iteraci√≥n, se devuelve el resultado. <br><br>  <b>D√≥nde escribir una prueba</b> <br><br>  Puede comenzar a escribir una prueba creando un archivo <code>test.py</code> que contendr√° su primer caso de prueba.  Para las pruebas, el archivo debe poder importar su aplicaci√≥n, por lo tanto, coloque <code>test.py</code> en la carpeta que se encuentra sobre el paquete.  El √°rbol de directorios se ver√° as√≠: <br><br> <code>project/ <br> ‚îÇ <br> ‚îú‚îÄ‚îÄ my_sum/ <br> ‚îÇ ‚îî‚îÄ‚îÄ __init__.py <br> | <br> ‚îî‚îÄ‚îÄ test.py</code> <br> <br>  Notar√° que a medida que agrega nuevas pruebas, su archivo se vuelve m√°s engorroso y dif√≠cil de mantener, por lo que recomendamos crear las <code>tests/</code> carpetas y dividir las pruebas en varios archivos.  Aseg√∫rese de que los nombres de todos los archivos comiencen con <code>test_</code> , para que los <code>test_</code> prueba entiendan que los archivos de Python contienen pruebas que deben ejecutarse.  En proyectos grandes, las pruebas se dividen en varios directorios, seg√∫n su prop√≥sito o uso. <br><br>  <i>Nota: ¬øY cu√°l es su aplicaci√≥n es un script √∫nico?</i> <i><br></i>  <i>Puede importar cualquier atributo de script: clases, funciones o variables, utilizando la funci√≥n incorporada <code>__import__()</code> .</i>  <i>En lugar de <code>from my_sum import sum</code> escriba lo siguiente:</i> <br><br><pre> <code class="python hljs">target = __import__(<span class="hljs-string"><span class="hljs-string">"my_sum.py"</span></span>) sum = target.sum</code> </pre> <br>  <i>Al usar <code>__import__()</code> no tiene que convertir la carpeta del proyecto en un paquete, y puede especificar el nombre del archivo.</i>  <i>Esto es √∫til si el nombre del archivo entra en conflicto con los nombres de las bibliotecas de paquetes est√°ndar.</i>  <i>Por ejemplo, si <code>math.py</code> entra en conflicto con el m√≥dulo matem√°tico.</i> <br><br>  <b>C√≥mo estructurar una prueba simple</b> <br><br>  Antes de escribir pruebas, debe resolver algunas preguntas: <br><br><ol><li>  ¬øQu√© quieres probar? </li><li>  ¬øEst√°s escribiendo una prueba unitaria o una prueba de integraci√≥n? </li></ol><br>  Actualmente est√°s probando <code>sum()</code> .  Puede probar diferentes comportamientos para ello, por ejemplo: <br><br><ul><li>  ¬øEs posible resumir una lista de enteros? </li><li>  ¬øEs posible resumir una tupla o un conjunto? </li><li>  ¬øPuedo resumir una lista de n√∫meros de coma flotante? </li><li>  ¬øQu√© sucede si le das un valor incorrecto a la entrada: un solo entero o una cadena? </li><li>  ¬øQu√© sucede si uno de los valores es negativo? </li></ul><br>  La forma m√°s f√°cil de probar es una lista de enteros.  Cree un archivo <code>test.py</code> con el siguiente c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  El c√≥digo en este ejemplo: <br><br><ul><li>  Importa <code>sum()</code> del paquete <code>my_sum()</code> que cre√≥; </li><li>  Define una nueva clase de caso de prueba llamada TestSum que hereda <code>unittest.TestCase</code> ; </li><li>  Define un <code>.test_list_int()</code> prueba <code>.test_list_int()</code> para probar una lista entera.  El m√©todo <code>.test_list_int()</code> har√° lo siguiente </li></ul>  : <br><ol><li>  Declara una variable de <code>data</code> con una lista de valores <code>(1, 2, 3)</code> ; </li><li>  <code>my_sum.sum(data)</code> valor <code>my_sum.sum(data)</code> <code>result</code> variable; </li><li>  Determina que el valor del resultado es 6 utilizando el m√©todo <code>.assertEqual()</code> en la clase <code>unittest.TestCase</code> . </li></ol><br><ul><li>  Define un punto de entrada de l√≠nea de comando que inicia el corredor de prueba unittest <code>.main()</code> . </li></ul><br>  Si no sabe qu√© es self o c√≥mo se define <code>.assertEqual()</code> , puede actualizar sus conocimientos de programaci√≥n orientada a objetos con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Python 3 Object-Oriented Programming</a> . <br><br>  <b>C√≥mo escribir declaraciones</b> <br><br>  El √∫ltimo paso para escribir una prueba es verificar que la salida coincida con los valores conocidos.  Esto se llama una afirmaci√≥n.  Existen varias pautas generales para escribir declaraciones: <br><br><ul><li>  Verifique que las pruebas sean repetibles y ejec√∫telas varias veces para asegurarse de que den los mismos resultados cada vez; </li><li>  Verifique y confirme los resultados que se aplican a su entrada; verifique que el resultado sea realmente la suma de los valores en el ejemplo <code>sum()</code> . </li></ul><br>  Unittest tiene muchos m√©todos para confirmar los valores, los tipos y la existencia de variables.  Estos son algunos de los m√©todos m√°s utilizados: <br><br><table><tbody><tr><th>  M√©todo </th><th>  Equivalente </th></tr><tr><td>  .assertEqual (a, b) </td><td>  a == b </td></tr><tr><td>  .assertTrue (x) </td><td>  bool (x) es verdadero </td></tr><tr><td>  .assertFalse (x) </td><td>  bool (x) es falso </td></tr><tr><td>  .assertIs (a, b) </td><td>  a es b </td></tr><tr><td>  .assertIsNone (x) </td><td>  x es Ninguno </td></tr><tr><td>  .assertIn (a, b) </td><td>  a en b </td></tr><tr><td>  .assertIsInstance (a, b) </td><td>  isinstance (a, b) </td></tr></tbody></table><br><br>  <code>.assertIs()</code> , <code>.assertIsNone()</code> , <code>.assertIn()</code> y <code>.assertIsInstance()</code> tienen m√©todos opuestos llamados <code>.assertIsNot()</code> y as√≠ sucesivamente. <br><br>  <b>Efectos secundarios</b> <br><br>  Escribir pruebas es m√°s dif√≠cil que solo mirar el valor de retorno de una funci√≥n.  A menudo, la ejecuci√≥n del c√≥digo cambia otras partes del entorno: atributos de clase, archivos del sistema de archivos, valores en la base de datos.  Esta es una parte importante de las pruebas llamadas efectos secundarios.  Decida si est√° probando un efecto secundario antes de incluirlo en su lista de reclamos. <br><br>  Si encuentra que hay muchos efectos secundarios en el bloque de c√≥digo que desea probar, est√° violando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Principio de responsabilidad exclusiva</a> .  La violaci√≥n del principio de responsabilidad exclusiva significa que un c√≥digo hace demasiadas cosas y requiere una refactorizaci√≥n.  Seguir el principio de responsabilidad exclusiva es una excelente manera de dise√±ar c√≥digo para el cual no ser√° dif√≠cil escribir pruebas unitarias simples y repetibles y, en √∫ltima instancia, crear aplicaciones confiables. <br><br>  <b>Lanzamiento de la primera prueba</b> <br><br>  Cre√≥ la primera prueba y ahora debe intentar ejecutarla.  Est√° claro que se aprobar√°, pero antes de crear pruebas m√°s complejas, debe asegurarse de que incluso dichas pruebas sean exitosas. <br><br>  <b>Ejecuci√≥n de ejecutores de prueba</b> <br><br>  Test Executor: una aplicaci√≥n de Python que ejecuta c√≥digo de prueba, valida aserciones y muestra los resultados de la prueba en la consola.  Al final de test.py agregue este peque√±o fragmento de c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Este es el punto de entrada de la l√≠nea de comando.  Si ejecuta este script ejecutando python <code>test.py</code> en la l√≠nea de comando, llamar√° <code>unittest.main()</code> .  Esto inicia el <code>unittest.TestCase</code> prueba <code>unittest.TestCase</code> detectar todas las clases en este archivo que heredan de <code>unittest.TestCase</code> . <br><br>  Esta es una de las muchas formas de ejecutar el corredor de prueba unittest.  Si tiene un √∫nico archivo de prueba llamado <code>test.py</code> , llamar a python test.py es una excelente manera de comenzar. <br><br>  Otra forma es usar la l√≠nea de comando unittest.  Probemos <br><br><pre> <code class="python hljs">$ python -m unittest test</code> </pre> <br>  Esto ejecutar√° el mismo m√≥dulo de prueba (llamado <code>test</code> ) a trav√©s de la l√≠nea de comando.  Puede agregar par√°metros adicionales para cambiar la salida.  Uno de ellos es -v para verbose.  Probemos lo siguiente: <br><br><pre> <code class="bash hljs">$ python -m unittest -v <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test_list_int (test.TestSum) ... ok ---------------------------------------------------------------------- Ran 1 tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.000s</code> </pre><br>  Ejecutamos una prueba desde test.py y enviamos los resultados a la consola.  El modo detallado enumer√≥ los nombres de las pruebas realizadas y los resultados de cada una de ellas. <br><br>  En lugar de proporcionar el nombre del m√≥dulo que contiene las pruebas, puede solicitar el descubrimiento autom√°tico utilizando lo siguiente: <br><br><pre> <code class="python hljs">$ python -m unittest discover</code> </pre> <br>  Este comando buscar√° en el directorio actual archivos con <code>test*.py</code> en el nombre para probarlos. <br><br>  Si tiene varios archivos de prueba y sigue el patr√≥n de nomenclatura de <code>test*.py</code> , puede pasar el nombre del directorio utilizando la bandera -s y el nombre de la carpeta. <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests</code> </pre> <br>  unittest ejecutar√° todas las pruebas en un solo plan de prueba y producir√° los resultados. <br>  Finalmente, si su c√≥digo fuente no est√° en el directorio ra√≠z, sino en un subdirectorio, por ejemplo, en una carpeta llamada src /, puede decirle a unittest d√≥nde ejecutar las pruebas usando el indicador -t para importar correctamente los m√≥dulos: <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests -t src</code> </pre> <br>  unittest encontrar√° todos <code>test*.py</code> archivos <code>test*.py</code> en el directorio <code>src/</code> dentro de las <code>tests</code> y luego los ejecutar√°. <br><br>  <b>Comprender los resultados de la prueba</b> <b><br></b> <br>  Este fue un ejemplo muy simple en el que todo sali√≥ bien, as√≠ que intentemos comprender el resultado de una prueba fallida. <br><br>  <code>sum()</code> debe aceptar otras listas de tipo num√©rico, por ejemplo fracciones. <br><br>  Al comienzo del c√≥digo en <code>test.py</code> agregue una expresi√≥n para importar el tipo de <code>fractions</code> m√≥dulo de <code>fractions</code> de la biblioteca est√°ndar. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fractions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fraction</code> </pre> <br>  Ahora agregue una prueba con una declaraci√≥n, esperando un valor incorrecto.  En nuestro caso, esperamos que la suma de ¬º, ¬º y ‚Öñ sea igual a 1: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_fraction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of fractions """</span></span> data = [Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre><br>  Si vuelve a ejecutar las pruebas con la prueba de prueba de unidad python -m, obtenga lo siguiente: <br><br><pre> <code class="python hljs">$ python -m unittest test F. ====================================================================== FAIL: test_list_fraction (test.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_list_fraction self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) AssertionError: Fraction(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  En esta salida, ver√° lo siguiente: <br><br><ul><li>  La primera l√≠nea muestra los resultados de todas las pruebas: una fall√≥ (F), una pas√≥ (.); </li><li>  FAIL muestra algunos detalles de la prueba fallida: </li></ul><br><ol><li>  El nombre del m√©todo de prueba ( <code>test_list_fraction</code> ); </li><li>  M√≥dulo de <code>test</code> ( <code>test</code> ) y caso de prueba ( <code>TestSum</code> ); </li><li>  Rastreo de cadenas con un error; </li><li>  Detalles de la declaraci√≥n con el resultado esperado (1) y el resultado real (Fracci√≥n (9, 10)) </li></ol><br>  Recuerde, puede agregar informaci√≥n adicional a la salida de prueba usando el indicador -v al <code>python -m unittest</code> . <br><br>  <b>Ejecuci√≥n de pruebas desde PyCharm</b> <br><br>  Si est√° utilizando PyCharm IDE, puede ejecutar unittest o pytest siguiendo estos pasos: <br><br><ol><li>  En la ventana de la herramienta Proyecto, seleccione el directorio de pruebas. </li><li>  En el men√∫ contextual, seleccione el comando de ejecuci√≥n unittest.  Por ejemplo, 'Pruebas unitarias en mis pruebas ...'. </li></ol><br>  Esto ejecutar√° unittest en la ventana de prueba y devolver√° los resultados en PyCharm: <br><br><img src="https://habrastorage.org/webt/i0/5e/xv/i05exvqd-ph8-jisw2a1ejgop_c.png"><br><br>  Hay m√°s informaci√≥n disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web de PyCharm</a> . <br><br>  <b>Ejecuci√≥n de pruebas desde el c√≥digo de Visual Studio</b> <br><br>  Si usa el IDE de Microsoft Visual Studio Code, la compatibilidad con unittest, nose y pytest ya est√° integrada en el complemento de Python. <br><br>  Si lo tiene instalado, puede configurar la configuraci√≥n de prueba abriendo Command Palette con Ctrl + Shift + P y escribiendo "Prueba de Python".  Ver√° una lista de opciones: <br><br><img src="https://habrastorage.org/webt/b1/zs/10/b1zs10n-ydybrqz62ywpknjp89q.png"><br><br>  Seleccione Debug All Unit Tests, despu√©s de lo cual VSCode enviar√° una solicitud para configurar el marco de prueba.  Haga clic en el engranaje para seleccionar el corredor de prueba (unittest) y el directorio de inicio (.). <br><br>  Al finalizar la configuraci√≥n, ver√° el estado de las pruebas en la parte inferior de la pantalla y podr√° acceder r√°pidamente a los registros de prueba y reiniciar las pruebas haciendo clic en los iconos: <br><br><img src="https://habrastorage.org/webt/rk/k6/cm/rkk6cmqzjwmtc-4upzozzurcjh4.png"><br><br>  Vemos que las pruebas se est√°n realizando, pero algunas de ellas han fallado. <br><br>  El fin <br><br>  En la siguiente parte del art√≠culo, examinaremos las pruebas para marcos como Django y Flask. <br><br>  Estamos esperando sus preguntas y comentarios aqu√≠ y, como siempre, puede ir a Stanislav en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">d√≠a abierto</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433358/">https://habr.com/ru/post/es433358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433348/index.html">DSL mecanografiado en TypeScript de JSX</a></li>
<li><a href="../es433350/index.html">Eventos digitales en Mosc√∫ del 17 al 23 de diciembre.</a></li>
<li><a href="../es433352/index.html">El resumen de materiales frescos del mundo de la interfaz para la √∫ltima semana No. 343 (10-16 de diciembre de 2018)</a></li>
<li><a href="../es433354/index.html">Noticias del mundo de OpenStreetMap No. 438 (04/12/2018 - 12/10/2018)</a></li>
<li><a href="../es433356/index.html">Los atacantes aprendieron a evitar la autenticaci√≥n de dos factores Yahoo Mail y Gmail</a></li>
<li><a href="../es433360/index.html">Los cient√≠ficos han intentado predecir cu√°ndo los aviones el√©ctricos se har√°n realidad</a></li>
<li><a href="../es433362/index.html">9 principios de belleza, simplicidad y cuidado en UX</a></li>
<li><a href="../es433364/index.html">LDraw + Unidad. C√≥mo gener√© Lego</a></li>
<li><a href="../es433366/index.html">Trabajando con recursos externos en Unity3D</a></li>
<li><a href="../es433368/index.html">C√≥mo aplicar el pensamiento de comestibles al mundo: un ejemplo de una sudadera</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>