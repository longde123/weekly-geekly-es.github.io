<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìè ü§∞ üßõ Reconnaissance des gestes avec APDS-9960 üíπ üîí üë©üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En lisant les commentaires sur mon article pr√©c√©dent sur APDS-9960, o√π il √©tait question de reconnaissance des couleurs et du niveau de lumi√®re, deux ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reconnaissance des gestes avec APDS-9960</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424947/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/bk/bh/oxbkbhl6uwlr0-1dynm5tppscw0.jpeg" alt="image"></div><br>  En lisant les commentaires sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> pr√©c√©dent sur APDS-9960, o√π il √©tait question de reconnaissance des couleurs et du niveau de lumi√®re, deux choses sont devenues √©videntes pour moi: 1) le sujet de la reconnaissance des gestes est int√©ressant et 2) ce sujet n'est pas divulgu√©. <br><br>  En effet, si j'ai repris la description de l'APDS-9960, alors sans consid√©rer les gestes, la description semble quelque peu incompl√®te.  J'ai donc trouv√© du temps libre pour explorer ce sujet aussi. <br><br>  Dans cet article, j'attire votre attention sur un aper√ßu des capacit√©s de reconnaissance gestuelle fournies par le capteur APDS-9960. <br><a name="habracut"></a><br>  L'article examinera le m√©canisme de configuration du capteur, la collecte, le traitement et la pr√©sentation des donn√©es.  Vous voyez vous-m√™me combien il est facile de travailler avec des gestes √† l'aide de l'APDS-9960. <br><br>  Comme la derni√®re fois, l'article sera accompagn√© d'un code, tout ce qui se passe dans lequel sera d√©crit en d√©tail.  La version compl√®te du code est disponible √† la fin de l'article. <br><br>  Imm√©diatement une petite remarque: APDS-9960 n'a pas de m√©canisme de d√©tection automatique de gestes int√©gr√©;  c'est-√†-dire que, ici, je lis, cela signifie, le registre, et l√† se trouve d√©j√† le geste trait√© - ce n'est pas dans APDS-9960;  et cela signifie que vous devez √©crire votre propre algorithme d'interpr√©tation des gestes, ce que nous ferons plus tard. <br><br>  En g√©n√©ral, c'est √† la fois bon et pas tr√®s bon.  Pas vraiment - car cela peut compliquer l'√©tude de ce capteur pour un d√©butant, mais bon, car, avec les donn√©es sur l'approximation, vous pouvez, par raffinement, m√™me imaginer vos propres gestes de diff√©rentes sortes. <br><br>  Mais, puisque cet article n'a qu'une fonction de vue d'ensemble, nous nous limitons aux gestes de base HAUT-BAS-GAUCHE-DROITE. <br><br>  Eh bien, commen√ßons. <br><br><h3>  Th√©orie </h3><br>  Je vais me permettre un peu de mat√©riel. <br><br>  Pour obtenir les informations n√©cessaires sur le mouvement et la direction du mouvement, l'APDS-9960 utilise une LED IR et quatre photodiodes qui, comme illustr√© dans la figure ci-dessous, d√©tectent les signaux dans le proche infrarouge (NIR). <br><br><img src="https://habrastorage.org/webt/__/k4/vq/__k4vqf3yty6sjcshtq77znw_v0.jpeg" alt="image"><br><br>  La LED IR (LED) a la fonction de r√©tro-√©clairage et les photodiodes (UDLR) enregistrent la lumi√®re r√©fl√©chie par "l'obstacle". <br><br>  Les photodiodes sont situ√©es sur le capteur de telle mani√®re que, selon le sens de d√©placement de ¬´l'obstacle¬ª, la photodiode correspondante recevra la plus grande partie du signal IR r√©fl√©chi √† l'entr√©e et une plus petite partie √† la sortie.  Dans le m√™me temps, la documentation sur l'APDS-9960 nous dit sans √©quivoque que vous pouvez interpr√©ter la direction du mouvement en mesurant et en comparant l'amplitude et la diff√©rence de phase des signaux des photodiodes UDLR. <br><br><img src="https://habrastorage.org/webt/aj/ts/ok/ajtsok_p-tpsaa1cyx5uoy2uonm.jpeg" alt="image"><br><br><h3>  Pratique </h3><br>  Pour travailler avec APDS-9960, ainsi que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">derni√®re fois</a> , nous utiliserons STM32VLDISCOVERY.  La connexion n'a pas non plus chang√©. <br><br>  <u>Configurer APDS-9960</u> <br><br>  Nous faisons la configuration initiale du capteur. <br><br>  Comme √ßa: <br><br><div class="spoiler">  <b class="spoiler_title">APDS9960_init</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">APDS9960_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN); i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH); i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN); i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH); }</code> </pre> </div></div><br>  Que se passe-t-il ici?  Faisons les choses correctement. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN);</code> </pre> <br>  PGAIN (Proximity Gain Control) est un param√®tre qui contr√¥le le gain de sensibilit√© de proximit√©.  Attribuez-lui une valeur de 2, ce qui correspond √† quatre fois le gain. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH);</code> </pre> <br>  GPENTH (Gesture Proximity Enter Threshold Register) - ce param√®tre d√©finit la valeur de seuil de proximit√© pour d√©terminer le d√©but de la reconnaissance des gestes. <br><br>  GEXTH (Gesture Exit Threshold Register), respectivement, d√©finit une valeur de seuil pour d√©terminer la fin de la reconnaissance des gestes. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN);</code> </pre> <br>  Dans le registre GCONF2 (Gesture configuration two), nous d√©finissons explicitement uniquement le param√®tre GGAIN (Gesture Gain Control) √† quatre fois la valeur de gain. <br><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH);</code> </pre> <br>  R√©tro√©clairage  Par d√©faut, la valeur de la source de courant de la LED de r√©tro√©clairage IR est r√©gl√©e sur 0, ce qui correspond √† un courant de 100 mA, cela nous conviendra parfaitement - nous ne la changerons pas. <br><br>  L'√©clairage IR de l'APDS-9960 est une s√©quence d'impulsions et est caract√©ris√© par les param√®tres de registre correspondants pour les gestes GPULSE (nombre et longueur d'impulsions de geste): GPLEN (longueur d'impulsion de geste) et GPULSE (nombre d'impulsions de geste), ainsi que l'approximation PPULSE (registre de comptage d'impulsions de proximit√©) ): PPLEN (Proximity Pulse Length) et PPULSE (Proximity Pulse Count) d√©finissant le nombre d'impulsions et la p√©riode de chaque impulsion individuelle. <br><br>  D√©finissez que GPLEN et PPLEN prendront une valeur de 2 √©gale √† 16 Œºs, et GPULSE et PPULSE une valeur de 9, ce qui correspond √† 10 impulsions. <br><br>  Comme vous pouvez le voir, la configuration s'est av√©r√©e l√©g√®rement plus compliqu√©e que la similaire pour la reconnaissance des couleurs et l'√©clairage de la pr√©c√©dente revue APDS-9960. <br><br>  <u>Lecture des donn√©es</u> <br><br>  Nous passons maintenant au cycle de programme principal, dans lequel nous commen√ßons de temps √† autre √† enregistrer et interpr√©ter les donn√©es des photodiodes, et √† apprendre √©galement √† distinguer un geste d'un autre. <br><br>  Tout d'abord, commen√ßons l'APDS-9960 avec des fonctions pour travailler avec les gestes et le zoom. <br><br><pre> <code class="cpp hljs">GesturesSet(GESTURES_START);</code> </pre> <br>  Et imm√©diatement, nous commen√ßons √† suivre le param√®tre GVALID.  GVALID (Gesture FIFO Data) est un param√®tre du registre GSTATUS (Gesture Status Register) qui, √©tant dans un √©tat non nul, nous informe que le capteur poss√®de des donn√©es gestuelles utilisables. <br><br>  La documentation nous apprend que les informations sur les gestes sont dans le tampon, dans le domaine de la RAM, qui est en g√©n√©ral de 32 x 4 octets. <br><br>  En pratique, la taille r√©elle de ce tampon peut √™tre trouv√©e en lisant la valeur du registre GFLVL (Gesture FIFO level), c'est-√†-dire  selon mes observations exp√©rimentales purement empiriques, GFLVL * 4 est obtenu.  Quelque chose comme √ßa: <br><br><img src="https://habrastorage.org/webt/oy/57/ry/oy57ryfaagi3qqrur9htiefckx0.jpeg" alt="image"><br><br>  Eh bien, comme il ressort du nom du tampon, les donn√©es qu'il contient sont organis√©es dans l'ordre First In - First Out.  Autrement dit, plus le signal de chacune des photodiodes est arriv√© ¬´t√¥t¬ª, plus il est ¬´√©lev√©¬ª dans le GFLVL. <br><br>  Les donn√©es des photodiodes (UDLR) peuvent √™tre lues √† partir du registre FIFO de geste correspondant: <br><br>  - GFIFO_U (donn√©es FIFO de geste, UP) <br>  - GFIFO_D (Gesture FIFO Data, DOWN) <br>  - GFIFO_L (Gesture FIFO Data, LEFT) <br>  - GFIFO_R (Gesture FIFO Data, RIGHT) <br><br>  Apr√®s chaque lecture des valeurs de ces registres, GFLVL est d√©cr√©ment√©;  ainsi, dans le bon sens, il est n√©cessaire de lire la totalit√© du tampon jusqu'√† ce que le GFLVL atteigne z√©ro. <br><br>  Pour d√©finir les gestes, nous n'avons besoin que des quatre premiers octets de ce tampon, pas plus.  Par cons√©quent, nous ne les lirons que. <br><br><pre> <code class="cpp hljs">GestureUp = i2c1_read(APDS9960_GFIFO_U); GestureDown = i2c1_read(APDS9960_GFIFO_D); GestureLeft = i2c1_read(APDS9960_GFIFO_L); GestureRight = i2c1_read(APDS9960_GFIFO_R);</code> </pre><br>  <u>Reconnaissance des gestes</u> <br><br>  Pour interpr√©ter quel genre de geste s'est produit, nous allons faire des calculs simples: <br><br><pre> <code class="cpp hljs">GestUpDown = GestureUp-GestureDown; GestLeftRight = GestureLeft-GestureRight;</code> </pre> <br>  Pour d√©terminer lequel des gestes s'est produit en ce moment, ce ne sont pas les valeurs de GestUpDown et GestLeftRight qui sont importantes pour nous, mais seulement le signe, pour ainsi dire, d'un nombre r√©el. <br><br>  En d'autres termes, en prenant les valeurs n√©gatives et positives des variables GestUpDown et GestLeftRight en entr√©e, nous d√©terminons quel geste est parfait. <br><br>  La table de v√©rit√© pour les variables GestUpDown et GestLeftRight est illustr√©e dans la figure ci-dessous. <br><br><img src="https://habrastorage.org/webt/xx/ts/g-/xxtsg-0zw2h7ralowsgsd_8tmoc.jpeg" alt="image"><br><br>  Maintenant, r√©initialisez le GFLVL: <br><br><pre> <code class="cpp hljs">GesturesSet(GESTURES_STOP);</code> </pre> <br>  ... et retour au d√©but du cycle de programme principal. <br><br>  Et maintenant tout le code: <br><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_I2C_ADDR 0x39 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_ENABLE 0x80 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GSTATUS 0xAF #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GFLVL 0xAE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Gesture FIFO Register (0xFC ‚Äì 0xFF): #define APDS9960_GFIFO_U 0xFC #define APDS9960_GFIFO_D 0xFD #define APDS9960_GFIFO_L 0xFE #define APDS9960_GFIFO_R 0xFF #define APDS9960_CONTROL 0x8F #define APDS9960_GPENTH 0xA0 #define APDS9960_GEXTH 0xA1 #define APDS9960_GCONF2 0xA3 #define APDS9960_GPULSE 0xA6 #define APDS9960_PPULSE 0x8E #define GESTURES_START 0x01 #define GESTURES_STOP 0x02 #define DEFAULT_GPENTH 40 // Threshold for entering gesture mode #define DEFAULT_GEXTH 30 // Threshold for exiting gesture mode #define DEFAULT_PGAIN 8 // Proximity Gain Control: 4X #define DEFAULT_GGAIN 0x40 // Gesture Gain Control: 4X #define DEFAULT_PULSE_LENGTH 0x89 // 16us, 10 pulses /* Bit fields */ #define APDS9960_PON 0x01 #define APDS9960_AEN 0x02 #define APDS9960_PEN 0x04 #define APDS9960_WEN 0x08 #define APSD9960_AIEN 0x10 #define APDS9960_PIEN 0x20 #define APDS9960_GEN 0x40 #define APDS9960_GVALID 0x01 int GestUpDown = 0; int GestLeftRight = 0; //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr); void i2c1_write(uint8_t addr, uint8_t data); void I2C1_init(void) { I2C_InitTypeDef I2C_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB| RCC_APB2Periph_AFIO , ENABLE); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); I2C_StructInit(&amp;I2C_InitStructure); I2C_InitStructure.I2C_ClockSpeed = 100000; I2C_InitStructure.I2C_OwnAddress1 = 0x01; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_Init(I2C1, &amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); } //----------------------------------------------------------------------- void APDS9960_init(void) { i2c1_write(APDS9960_CONTROL, DEFAULT_PGAIN); i2c1_write(APDS9960_GPENTH, DEFAULT_GPENTH); i2c1_write(APDS9960_GEXTH, DEFAULT_GEXTH); i2c1_write(APDS9960_GCONF2, DEFAULT_GGAIN); i2c1_write(APDS9960_GPULSE, DEFAULT_PULSE_LENGTH); i2c1_write(APDS9960_PPULSE, DEFAULT_PULSE_LENGTH); } //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr) { uint8_t data; while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Receiver); while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)); data = I2C_ReceiveData(I2C1); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); I2C_AcknowledgeConfig(I2C1, DISABLE); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); return data; } //----------------------------------------------------------------------- void i2c1_write(uint8_t addr, uint8_t data) { I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_SendData(I2C1, data); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {}; } //----------------------------------------------------------------------- void GesturesSet(uint8_t GestSel) { switch (GestSel) { case GESTURES_START: i2c1_write(APDS9960_ENABLE, APDS9960_GEN | APDS9960_PEN | APDS9960_PON); break; case GESTURES_STOP: i2c1_write(APDS9960_ENABLE, APDS9960_PEN | APDS9960_PON); break; default: i2c1_write(APDS9960_ENABLE, APDS9960_GEN | APDS9960_PEN | APDS9960_PON); } } //----------------------------------------------------------------------- int main() { uint8_t GFLVL_buf = 0; uint8_t GSTATUS_buf = 0; uint8_t GestureUp = 0; uint8_t GestureDown = 0; uint8_t GestureLeft = 0; uint8_t GestureRight = 0; I2C1_init(); APDS9960_init(); while (1) { GFLVL_buf = 0; GSTATUS_buf = 0; GestureUp = 0; GestureDown = 0; GestureLeft = 0; GestureRight = 0; GestUpDown = 0; GestLeftRight = 0; GesturesSet(GESTURES_START); GSTATUS_buf = i2c1_read(APDS9960_GSTATUS); if(GSTATUS_buf &amp; APDS9960_GVALID) { GFLVL_buf = i2c1_read(APDS9960_GFLVL); if(GFLVL_buf) { GestureUp = i2c1_read(APDS9960_GFIFO_U); GestureDown = i2c1_read(APDS9960_GFIFO_D); GestureLeft = i2c1_read(APDS9960_GFIFO_L); GestureRight = i2c1_read(APDS9960_GFIFO_R); //Truth table: //UP: GestUpDown(+) | GestLeftRight(+) //DOWN: GestUpDown(-) | GestLeftRight(-) //LEFT: GestUpDown(+) | GestLeftRight(-) //RIGHT: GestUpDown(-) | GestLeftRight(+) GestUpDown = GestureUp-GestureDown; GestLeftRight = GestureLeft-GestureRight; GesturesSet(GESTURES_STOP); } } } }</span></span></span></span></code> </pre><br></div></div><br>  Je tiens √† noter que le m√©canisme gestuel de l'APDS-9960 fonctionne tr√®s bien.  La reconnaissance est stable, les filtres int√©gr√©s aux APDS-9960 UV et IR fonctionnent bien. <br><br>  J'esp√®re que ce mat√©riel est utile √† quelqu'un.  Merci de votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424947/">https://habr.com/ru/post/fr424947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424935/index.html">Food Design Digest, septembre 2018</a></li>
<li><a href="../fr424937/index.html">√âv√©nements num√©riques √† Moscou du 1er au 7 octobre</a></li>
<li><a href="../fr424939/index.html">Polymorphic Quine</a></li>
<li><a href="../fr424941/index.html">Streaming de donn√©es d'un service REST vers une file d'attente MQ</a></li>
<li><a href="../fr424945/index.html">Le smartphone conduit une petite voiture.</a></li>
<li><a href="../fr424949/index.html">PHP Digest n ¬∞ 140 (17-30 septembre 2018)</a></li>
<li><a href="../fr424951/index.html">Hourra! Ce n'√©tait pas de la parano√Øa</a></li>
<li><a href="../fr424955/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 332 (24-30 septembre 2018)</a></li>
<li><a href="../fr424957/index.html">G√©n√©ration d'images √† partir de texte √† l'aide d'AttnGAN</a></li>
<li><a href="../fr424961/index.html">MTA-STS pour Postfix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>