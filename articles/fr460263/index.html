<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛒 👴🏿 🐩 Faire une recherche vraiment intelligente: guide étape par étape ✍️ 🧑🏽‍🤝‍🧑🏼 🗄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recherche dans le système d'information de l'entreprise - déjà à partir de cette phrase elle-même reste coincée dans la bouche. C'est bien si vous en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire une recherche vraiment intelligente: guide étape par étape</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/460263/"><p>  <em>Recherche dans le système d'information de l'entreprise</em> - déjà à partir de cette phrase elle-même reste coincée dans la bouche.  C'est bien si vous en avez un, vous n'avez même pas à penser à une expérience utilisateur positive.  Comment inverser l'attitude des utilisateurs gâtés par les moteurs de recherche et créer un produit rapide, précis et parfaitement compréhensible?  Nous devons prendre un bon morceau d'Elasticsearch, une poignée de services intelligents et les pétrir sur ce guide. </p><br><p>  Il existe de nombreux articles sur la façon d'attacher la recherche de texte intégral basée sur Elasticsearch à la base de données existante.  Mais il n'y a clairement pas assez d'articles sur la façon de faire une recherche vraiment intelligente. </p><br><blockquote>  Dans le même temps, l'expression "Smart Search" elle-même est déjà devenue un mot à la mode et est utilisée pour le lieu et non.  Alors, que doit faire un moteur de recherche pour être considéré comme intelligent?  En fin de compte, cela peut être décrit comme donnant le résultat dont l'utilisateur a réellement besoin, même si ce résultat ne correspond pas tout à fait au texte de la demande.  Les moteurs de recherche populaires comme Google et Yandex vont plus loin et ne trouvent pas seulement les informations dont ils ont besoin, mais répondent directement aux questions des utilisateurs. </blockquote><p>  D'accord, nous ne nous attaquerons pas tout de suite à la solution ultime, mais que peut-on faire pour rapprocher une recherche plein texte <em>régulière d'</em> une recherche <em>intelligente</em> ? </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti">  Éléments d'intelligence </h2><br><p>  Recherche intelligente - c'est juste le cas lorsque la quantité peut entrer dans la qualité et que de nombreuses fonctionnalités petites et assez simples peuvent former un sentiment de magie. </p><br><ul><li>  Correction d'erreurs utilisateur - qu'il s'agisse d'une faute de frappe, d'une mise en page incorrecte ou, peut-être, d'une demande avec un nombre étrangement faible de résultats, mais similaire à une demande pour laquelle il existe beaucoup plus d'informations. </li><li>  Pour <del>  e </del>  Discussions en PNL (traitement du langage naturel, pas ce que vous pensiez) - si l'utilisateur a saisi <em><strong>des offres commerciales pour l'année dernière</strong></em> , voulait-il vraiment rechercher ces mots dans le texte de tous les documents ou avait-il vraiment besoin uniquement d'offres commerciales et seulement l'année dernière ? </li><li>  Prédisez la saisie en fonction des requêtes précédentes ou des documents populaires. </li><li> La présentation du résultat est le point fort habituel du fragment trouvé, des informations supplémentaires en fonction de ce que vous cherchiez.  Étant donné que des propositions commerciales étaient nécessaires dans le paragraphe précédent, peut-être est-il logique de montrer immédiatement le sujet de la proposition et de quelle organisation elle provient? </li><li>  Exploration facile - la possibilité d'affiner la requête de recherche à l'aide de filtres et de facettes supplémentaires. </li></ul><br><h2 id="vvodnaya">  Introduction </h2><br><p>  Il existe un ECM DIRECTUM contenant de nombreux documents.  Le document se compose d'une carte avec des méta-informations et d'un corps, qui peut avoir plusieurs versions. </p><br><p>  L'objectif est de rechercher rapidement et facilement des informations dans ces documents de la manière habituelle pour un utilisateur de moteurs de recherche. </p><br><h2 id="indeksirovanie">  Indexation </h2><br><blockquote>  Pour bien rechercher quelque chose, vous devez d'abord bien l'indexer. </blockquote><p>  Les documents dans ECM ne sont pas statiques, les utilisateurs modifient le texte, créent de nouvelles versions, changent les données dans les cartes;  de nouveaux documents sont constamment créés et les anciens sont parfois supprimés. <br>  Pour conserver des informations à jour dans Elasticsearch, les documents doivent être constamment réindexés.  Heureusement, ECM a déjà sa propre file d'attente d'événements asynchrones, donc lorsque vous modifiez un document, ajoutez-le simplement à la file d'attente pour l'indexation. </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch">  Mappage de documents ECM à des documents Elasticsearch </h3><br><p>  Un corps de document dans ECM peut avoir plusieurs versions.  Dans Elasticsearch, cela pourrait être considéré comme un tableau d'objets imbriqués, mais il devient alors difficile de travailler avec eux - il devient plus difficile d'écrire des requêtes, lorsque vous changez l'une des versions, vous devez tout réindexer, différentes versions du même document ne peuvent pas être stockées dans différents index (pourquoi cela pourrait-il être nécessaire - dans la section suivante).  Par conséquent, nous dénormalisons un document d'ECM en plusieurs documents Elasticsearch avec la même carte mais des corps différents. </p><br><p>  En plus de la carte et du corps, diverses informations de service sont ajoutées au document Elasticsearch, qui mérite d'être mentionné séparément: </p><br><ul><li>  une liste des identifiants des groupes et des utilisateurs qui ont des droits sur le document - pour les recherches avec des droits; </li><li>  le nombre d'appels au document - pour régler la pertinence; </li><li>  heure de la dernière indexation. </li></ul><br><h3 id="sostav-indeksov">  Composition de l'indice </h3><br><p>  Oui, plusieurs indices.  Habituellement, plusieurs index pour stocker des informations de signification similaire dans Elasticsearch ne sont utilisés que si ces informations sont immuables et liées à une certaine période, par exemple, les journaux.  Ensuite, les indices sont créés chaque mois / jour ou plus souvent en fonction de l'intensité de la charge.  Dans notre cas, tout document peut être modifié et il serait possible de tout stocker dans un seul index. </p><br><p>  Mais - les documents dans le système peuvent être dans différentes langues, et le stockage de données multilingues dans Elasticsearch pose 2 problèmes: </p><br><ul><li>  Mauvaise racine.  Pour certains mots, la base sera trouvée correctement, pour certains - incorrectement (il y aura un autre mot dans l'index), pour certains - ne sera pas trouvée du tout (l'index sera obstrué par des formes de mots).  Pour certains mots de différentes langues et ayant des significations différentes, la base coïncidera, puis le sens du mot sera perdu.  L'utilisation de plusieurs stemmers consécutifs peut conduire à un calcul supplémentaire de la base pour une base déjà calculée. </li></ul><br><blockquote>  Stamming - trouver la base du mot.  La tige ne doit pas être la racine du mot ou sa forme normale.  En général, il suffit que les mots associés soient projetés dans un seul cadre. <br>  La lemmatisation est un type de radical dans lequel la forme normale (vocabulaire) d'un mot est considérée comme la base. </blockquote><br><ul><li>  Fréquence de mot incorrecte.  Certains mécanismes de détermination de la pertinence dans ES prennent en compte la fréquence des mots recherchés dans le document (plus souvent, plus la pertinence est élevée) et la fréquence des mots recherchés dans l'index (plus souvent, plus la pertinence est faible).  Ainsi, une petite diffusion de la langue russe dans un document anglais, lorsque les documents anglais sont principalement dans l'index, aura un poids élevé, mais cela vaut la peine de mélanger les documents anglais et russes dans l'index, et le poids diminuera. </li></ul><br><p>  Le premier problème peut être résolu dans le cas où différentes langues utilisent différents jeux de caractères (les documents russe-anglais utilisent des lettres cyrilliques et latines) - les stemmers de langue ne traiteront que "leurs" caractères. </p><br><p>  Pour résoudre le deuxième problème, nous avons utilisé l'approche avec un index séparé pour chaque langue. </p><br><p>  En combinant les deux approches, nous obtenons des indices de langue, qui contiennent néanmoins des analyseurs pour plusieurs langues qui ne se croisent pas dans des ensembles de caractères: russe-anglais (et séparément anglais-russe), polonais-russe, allemand-russe, ukrainien-anglais, etc. . </p><br><p>  Afin de ne pas créer tous les index possibles à l'avance, nous avons utilisé des modèles d'index - Elasticsearch vous permet de spécifier un modèle contenant des paramètres et des mappages, et de spécifier un modèle de nom d'index.  Lorsque vous essayez d'indexer un document dans un index inexistant, dont le nom correspond à l'un des modèles du modèle, non seulement un nouvel index sera créé, mais également des paramètres et des mappages du modèle correspondant lui seront appliqués. </p><br><h3 id="struktura-indeksov">  Structure de l'index </h3><br><p>  Pour l'indexation, nous utilisons deux analyseurs à la fois (via plusieurs champs): par défaut pour la recherche par phrase exacte et personnalisé pour tout le reste: </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p>  Avec le filtre en minuscules, tout est clair, je vais vous parler du reste. </p><br><p>  Les filtres russian_morphology et english_morphology sont destinés à l'analyse morphologique du texte russe et anglais, respectivement.  Ils ne font pas partie d'Elasticsearch et sont inclus dans le cadre d'un plugin d'analyse-morphologie distinct.  Ce sont des lemmatiseurs qui utilisent l'approche du vocabulaire en combinaison avec certaines heuristiques et fonctionnent de manière significative, BEAUCOUP, mieux que les filtres intégrés pour les langues correspondantes. </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Et: </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Filtre word_delimiter très curieux.  Cela aide, par exemple, à éliminer les fautes de frappe lorsqu'il n'y a pas d'espace après le point.  Nous utilisons la configuration suivante: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  yo_filter vous permet d'ignorer la différence entre E et E: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  ru_en_stopwords filter type stop - notre dictionnaire de mots vides. </p><br><h3 id="process-indeksirovaniya">  Processus d'indexation </h3><br><p>  Les corps de documents dans ECM sont, en règle générale, des fichiers de formats bureautiques: .docx, .pdf, etc.  Pour extraire le texte, le plugin ingest-attachment est utilisé avec le pipeline suivant: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p>  De l'inhabituel dans le pipeline, en ignorant les erreurs d'absence du corps (cela se produit pour les documents cryptés) et en déterminant l'index cible en fonction de la langue du texte.  Ce dernier se fait dans un script indolore, dont je donnerai le corps séparément, car  en raison des restrictions JSON, il doit être écrit sur une seule ligne.  Associé à des difficultés de débogage (la méthode recommandée consiste à lever des exceptions ici et là), cela devient complètement douloureux. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p>  Ainsi, nous envoyons toujours le document à <em>index_name</em> .  Si la langue n'est pas définie ou n'est pas prise en charge, le document s'installe dans cet index, sinon il tombe dans <em>index_name_language</em> . </p><br><p>  Nous ne stockons pas le corps d'origine du fichier, mais le champ _source est activé, car  il est nécessaire de mettre à jour partiellement le document et de mettre en évidence le trouvé. </p><br><p>  Si seule la carte a changé depuis la dernière indexation, nous utilisons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API Update By Query</a> sans pipeline pour la mettre à jour.  Cela permet, d'une part, de ne pas extraire des corps de document potentiellement lourds d'ECM, et d'autre part, cela accélère considérablement la mise à jour du côté Elasticsearch - vous n'avez pas à extraire le texte des documents des formats bureautiques, ce qui est très gourmand en ressources. </p><br><blockquote>  En tant que tel, il n'y a aucune mise à jour du document dans Elasticsearch, techniquement, lors de la mise à jour à partir de l'index, l'ancien document est retiré, modifié et complètement indexé à nouveau. </blockquote><p>  Mais si le corps a changé, l'ancien document est généralement supprimé et indexé à partir de zéro.  Cela permet aux documents de <em>passer</em> d'un index de langue à un autre. </p><br><h2 id="poisk">  Chercher </h2><br><p>  Pour faciliter la description, je vais donner une capture d'écran du résultat final </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst">  Texte intégral </h3><br><p>  Le type de requête principal que nous avons est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">requête de chaîne de requête simple</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p>  où <em>.exact</em> sont les champs indexés par l'analyseur par <em>défaut</em> .  L'importance du nom du document est deux fois plus élevée que le reste des champs.  La combinaison de <code>"default_operator": "or"</code> et <code>"minimum_should_match": "-35%"</code> vous permet de trouver des documents qui ne contiennent pas jusqu'à 35% des mots recherchés. </p><br><h3 id="sinonimy">  Synonymes </h3><br><p>  En général, différents analyseurs sont utilisés pour l'indexation et la recherche, mais la seule différence entre eux est l'ajout d'un filtre pour ajouter des synonymes à la requête de recherche: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav">  Droits comptables </h3><br><p>  Pour les recherches basées sur les droits, la requête principale est intégrée dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bool Query</a> , avec l'ajout d'un filtre: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p>  Comme nous nous en souvenons de la section sur l'indexation, l'index a un champ avec l'ID des utilisateurs et des groupes qui ont des droits sur le document.  S'il y a une intersection de ce champ avec le tableau transmis, alors il y a des droits. </p><br><h3 id="tyuning-relevantnosti">  Réglage de la pertinence </h3><br><p>  Par défaut, Elasticsearch évalue la pertinence des résultats à l'aide de l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BM25</a> à l'aide de la requête et du texte du document.  Nous avons décidé que trois autres facteurs devraient influencer l'évaluation de la conformité avec le résultat souhaité et réel: </p><br><ul><li>  le moment de la dernière édition du document - plus il était loin dans le passé, moins il est probable que ce document soit nécessaire </li><li>  le nombre d'appels au document - plus il est probable que ce document est nécessaire; </li><li><p>  Les versions de corps ECM ont plusieurs états possibles: en cours de développement, opérationnel et obsolète.  Il est logique que le jeu soit plus important que les autres. </p><br><p>  Vous pouvez obtenir cet effet à l'aide de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction Function Score Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p>  Par conséquent, toutes choses égales par ailleurs, nous obtenons approximativement la dépendance suivante du modificateur d'évaluation des résultats à la date de son dernier changement X et au nombre de résultats Y: </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt">  Intelligence externe </h3><br><p>  Pour une partie des fonctionnalités de la recherche intelligente, nous devons extraire divers <em>faits</em> de la requête de recherche: dates avec leur application (création, modification, approbation, etc.), noms des organisations, types de documents recherchés, etc. </p><br><p>  Il est également souhaitable de classer la demande dans une certaine catégorie, par exemple, les documents par organisation, par employé, réglementaire, etc. </p><br><p>  Ces deux opérations sont effectuées par le module intelligent ECM - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DIRECTUM Ario</a> . </p><br><h3 id="process-umnogo-poiska">  Processus de recherche intelligent </h3><br><p>  Il est temps d'examiner plus en détail quels mécanismes sont mis en œuvre les éléments du renseignement. </p><br><h4 id="ispravlenie-oshibok-polzovatelya">  Correction d'erreurs utilisateur </h4><br><p>  La justesse de la mise en page est déterminée sur la base du modèle de langue du trigramme - pour une ligne, on calcule sa probabilité de respecter ses séquences de trois caractères dans des textes en anglais et en russe.  Si la mise en page actuelle est considérée comme moins probable, alors, tout d'abord, un indice avec une mise en page correcte s'affiche: </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p>  et deuxièmement, les autres étapes de la recherche sont effectuées avec la mise en page correcte: </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p>  Et si rien ne peut être trouvé avec la mise en page corrigée, la recherche commence par la ligne d'origine. </p><br><p>  La correction des fautes de frappe est implémentée à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Phrase Suggester</a> .  Il y a un problème - si vous exécutez une requête sur plusieurs index en même temps, alors suggest peut ne rien retourner, tandis que si vous exécutez sur un seul index, il y a des résultats.  Ceci <em>est traité en</em> définissant la confiance = 0, mais suggère ensuite de remplacer les mots par leur forme normale.  D'accord, il sera étrange lorsque vous rechercherez "lettre <strong>a</strong> " d'obtenir une réponse dans l'esprit: <em>Peut</em> - <em>être cherchiez-vous une lettre <strong>sur</strong> ?</em> </p><br><p>  Cela peut être contourné en utilisant deux invites dans la demande: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p>  Des paramètres communs utilisés </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Si le premier opposant a renvoyé le résultat, mais pas le second, alors ce résultat est la chaîne d'origine elle-même, éventuellement avec des mots sous d'autres formes, et il n'est pas nécessaire d'afficher un indice.  Si l'indice est toujours requis, la phrase de recherche d'origine fusionne avec l'indice.  Cela se produit en remplaçant uniquement les mots corrigés et uniquement ceux que le correcteur orthographique (utilisant Hunspell) considère comme incorrects. </p><br><p>  Si la recherche sur la chaîne source a renvoyé 0 résultats, elle est remplacée par la chaîne obtenue par la fusion et la recherche est à nouveau effectuée: </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p>  Sinon, la chaîne d'invite résultante est renvoyée uniquement en tant qu'invite pour la recherche: </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov">  Classification des requêtes et extraction des faits </h4><br><p>  Comme je l'ai mentionné, nous utilisons DIRECTUM Ario, à savoir le service de classification de texte et le service d'extraction de faits.  Pour ce faire, nous avons donné aux analystes des requêtes de recherche anonymes et une liste de faits qui nous intéressent.  Sur la base de requêtes et de connaissances sur les documents présents dans le système, les analystes ont identifié plusieurs catégories et formé le service de classification pour déterminer la catégorie en fonction du texte de la requête.  Sur la base des catégories et de la liste de faits résultants, nous avons formulé les règles d'utilisation de ces faits.  Par exemple, l'expression <em><strong>pour la dernière année</strong></em> dans la catégorie <strong>Tout</strong> le <strong>monde</strong> est considérée comme la date de création du document, et dans la catégorie <strong>Par organisation</strong> - la date d'enregistrement.  Dans le même temps, ceux <em><strong>créés l'année dernière</strong></em> devraient dans n'importe quelle catégorie tomber à la date de création. </p><br><p>  Du côté de la recherche - ils ont fait une configuration dans laquelle ils ont enregistré les catégories, quels faits sont appliqués à quels filtres de facettes. </p><br><h4 id="avtodopolnenie-vvoda">  Achèvement de la saisie </h4><br><p>  En plus des corrections de mise en page déjà mentionnées, les recherches antérieures de l'utilisateur et des documents publics tombent en auto-complétion. </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p>  Ils sont implémentés à l'aide d'un autre type de Suggestion - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suggestion d'achèvement</a> , mais chacun a ses propres nuances. </p><br><h5 id="avtodopolnenie-istoriya-poiskov">  Saisie semi-automatique: historique des recherches </h5><br><p>  Il y a beaucoup moins d'utilisateurs dans ECM que les moteurs de recherche et allouez suffisamment de requêtes communes pour eux <del>  pourquoi champignon lénine </del>  pas possible.  Tout afficher à la suite n'en vaut pas la peine pour des raisons de confidentialité.  Le Suggestion de complétion habituel ne peut rechercher que l'ensemble des documents dans l'index, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suggestion de contexte</a> vient à la rescousse - un moyen de définir un contexte pour chaque indice et de filtrer par ces contextes.  Si les noms d'utilisateur sont utilisés comme contextes, alors seul son historique peut être montré à tout le monde. </p><br><p>  Vous devez également donner à l'utilisateur la possibilité de supprimer l'invite pour laquelle il a honte.  Comme clé de suppression, nous avons utilisé le nom d'utilisateur et le texte de l'infobulle.  En conséquence, pour l'index avec des conseils, nous avons obtenu un mappage légèrement dupliqué: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p>  Le poids de chaque nouvel indice est défini sur un et augmente chaque fois que vous le saisissez à nouveau à l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API Update By Query</a> avec un script <code>ctx._source.suggest.weight++</code> très simple. </p><br><h5 id="avtodopolnenie-dokumenty">  Saisie semi-automatique: documents </h5><br><p>  Mais il peut y avoir beaucoup de documents et des combinaisons possibles de droits.  Par conséquent, ici, au contraire, nous avons décidé de ne pas filtrer par droits lors de l'auto-complétion, mais uniquement d'indexer les documents publics.  Oui, et vous n'avez pas besoin de supprimer les conseils individuels de cet index.  Il semblerait que la mise en œuvre en tout soit plus facile que la précédente, sinon pour deux points: </p><br><p>  Le premier - Completion Suggester ne prend en charge que la recherche de préfixe, et les clients adorent attribuer des numéros d'article à tout, et certaines <code>.01.01   </code> lorsque vous tapez une requête Il n'y a <code>.01.01   </code> .  Ici, avec le nom complet, vous pouvez également indexer les n-grammes qui en dérivent: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p>  Ce n'était pas si critique avec l'histoire, mais le même utilisateur entre approximativement la même ligne s'il recherche à nouveau quelque chose.  <em>Probablement</em> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p>  La seconde - par défaut, tous les conseils sont égaux, mais nous aimerions rendre certains d'entre eux plus égaux et de préférence afin que cela soit cohérent avec le classement des résultats de recherche.  Pour ce faire, répétez grossièrement les fonctions gauss et field_value_factor utilisées dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction Function Score Query</a> . </p><br><p>  Il s'avère que c'est un tel pipeline: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p>  avec le script suivant: </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p>  Pourquoi s'embêter avec un pipeline indolore au lieu de l'écrire dans une langue plus pratique?  Parce que maintenant, à l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API Reindex</a> , vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">remplacer</a> le contenu des index de recherche en index pour les conseils (en spécifiant uniquement les champs nécessaires, bien sûr) en une seule commande. </p><br><p>  La composition des documents publics vraiment nécessaires n'est pas souvent mise à jour, donc cette commande peut être laissée sur un démarrage manuel. </p><br><h3 id="otobrazhenie-rezultatov">  Afficher les résultats </h3><br><h4 id="kategorii">  Les catégories </h4><br><p>  La catégorie détermine quelles facettes seront disponibles et à quoi ressemblera l'extrait.  Il peut être détecté automatiquement par <em>une intelligence externe</em> ou sélectionné manuellement au-dessus de la barre de recherche. </p><br><h4 id="fasety">  Facettes </h4><br><p>  Les facettes sont une chose tellement intuitive pour tous ceux dont le comportement est cependant décrit par des règles très simples.  En voici quelques uns: </p><br><ol><li><p>  Les valeurs des facettes dépendent des résultats de la recherche, MAIS et les résultats de la recherche dépendent des facettes sélectionnées.  Comment éviter la récursivité? </p><br></li><li><p>  La sélection de valeurs dans une facette n'affecte pas les autres valeurs de cette facette, mais elle affecte les valeurs dans d'autres facettes: </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li>  Les valeurs de facette sélectionnées par l'utilisateur ne doivent pas disparaître, même si un choix dans une autre facette les <em>annule</em> à 0 ou si elles ne sont plus en haut: </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p>  En élasticité, les facettes sont réalisées à travers le mécanisme d'agrégation, mais pour respecter les règles décrites, ces agrégations doivent être investies les unes dans les autres et filtrées les unes par les autres. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p>  Considérez les fragments de requête responsables de cela: </p><br><div class="spoiler">  <b class="spoiler_title">Code trop grand</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p>  Qu'est-ce que c'est que: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">post_filter vous</a> permet d'imposer une condition supplémentaire aux résultats d'une requête déjà terminée et n'affecte pas les résultats des agrégations.  Ce même écart de récursivité.  Inclut toutes les valeurs sélectionnées de toutes les facettes. </li><li>  agrégations de niveau supérieur, dans les exemples <em>card.author_value_id</em> et <em>editor_value_id</em> .  Chacun a: <br><ul><li>  filtrer par les valeurs de toutes les autres facettes, sauf la vôtre; </li><li>  agrégation imbriquée pour des valeurs de facettes sélectionnées - <em>protection contre l'annihilation</em> ; </li><li>  agrégation imbriquée pour d'autres valeurs de facette.  Nous affichons le top 10 et demandons le top 11 - pour déterminer s'il faut afficher le bouton <strong>Afficher tout</strong> . </li></ul></li></ul><br><h4 id="snippety">  Extraits </h4><br><p>  Selon la catégorie sélectionnée, l'extrait peut sembler différent, par exemple, le même document lors de la recherche dans une catégorie </p><br><p>  <strong>Tous</strong> : </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p>  et <strong>employés</strong> : </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p>  Ou souvenez-vous, nous voulions voir le sujet d'une offre commerciale et de qui venait-elle? </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p>  Afin de ne pas faire glisser la carte entière de l'élastique (cela ralentit la recherche), le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">filtrage source est utilisé</a> : </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p>  Pour mettre en évidence les mots trouvés dans le texte du document, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">surligneur Fast Vector</a> est utilisé - comme générant les extraits de code les plus appropriés pour les gros textes, et pour le nom - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surligneur unifié</a> - comme le moins exigeant en termes de ressources et de structure d'index: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p>  Dans ce cas, le nom est mis en évidence dans son intégralité, et du texte nous obtenons jusqu'à 3 fragments de 300 caractères.  Le texte renvoyé par le surligneur Fast Vector est ensuite compressé par un algorithme de fortune pour obtenir un état d'extrait minimisé. </p><br><h3 id="kollaps">  Réduire </h3><br><p>  Historiquement, les utilisateurs de cet ECM sont habitués au fait que la recherche leur renvoie des <em>documents</em> , mais en fait Elasticsearch recherche parmi les <em>versions des documents</em> .  Il peut s'avérer que plusieurs versions presque identiques se trouvent sur la même requête.  Cela encombrera les résultats et confondra l'utilisateur.  Heureusement, ce comportement peut être évité en utilisant le mécanisme de regroupement de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">champs</a> - une version légère d'agrégations qui fonctionne déjà sur les résultats finis (en cela, il ressemble à post_filter, <em>deux béquilles sont une paire</em> ).  L' <em>effondrement</em> entraînera le plus pertinent des objets qui s'effondrent. </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p>  Malheureusement, l'effondrement a un certain nombre d'effets désagréables, par exemple, diverses caractéristiques numériques du résultat de la recherche continuent de revenir comme s'il n'y avait pas d'effondrement.  Autrement dit, le nombre de résultats, le nombre de valeurs de facette - tout sera <em>légèrement</em> incorrect, mais l'utilisateur ne le remarque généralement pas, tout comme le lecteur fatigué, qui a peu de chances d'avoir lu cette proposition auparavant. </p><br><p>  La fin. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460263/">https://habr.com/ru/post/fr460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460253/index.html">10 raisons de faire vos compétences d'assistant vocal</a></li>
<li><a href="../fr460255/index.html">Backdoor sur Node.js: pourquoi, pourquoi et comment cela fonctionne</a></li>
<li><a href="../fr460257/index.html">Bonjour tout le monde! Immersion profonde dans les terminaux</a></li>
<li><a href="../fr460259/index.html">Qu'est-ce que la conception UI et UX? Qu'est-ce qui est commun et différent?</a></li>
<li><a href="../fr460261/index.html">Amazon: 25 ans de succès dans le commerce électronique</a></li>
<li><a href="../fr460265/index.html">Créer un modèle de projet Xcode</a></li>
<li><a href="../fr460273/index.html">Autorisation dans Apple Pay pour le plus petit</a></li>
<li><a href="../fr460275/index.html">Pourquoi n'avez-vous pas besoin de la solution parfaite</a></li>
<li><a href="../fr460279/index.html">Contrat de 10 milliards: qui s'occupera du cloud pour le Pentagone</a></li>
<li><a href="../fr460281/index.html">Comment UX Writer aide à améliorer le produit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>