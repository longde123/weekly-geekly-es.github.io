<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÆ üöí üöü Wie sieht dein Text aus? ü§ê ü§∑üèΩ üë©‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Freunde, den ganzen Freitag gro√üartig. Wir m√∂chten Ihnen eine √úbersetzung eines Artikels mitteilen, der speziell f√ºr Studenten des Kurses ‚ÄûAndroid-Ent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie sieht dein Text aus?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/456110/"> Freunde, den ganzen Freitag gro√üartig.  Wir m√∂chten Ihnen eine √úbersetzung eines Artikels mitteilen, der speziell f√ºr Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûAndroid-Entwickler.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortgeschrittenenkurs</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚Äú</a>  Gute Lekt√ºre. <br><br><img src="https://habrastorage.org/webt/vd/zx/ym/vdzxymfn0nm1ys_j8zkmlxz3w1m.png"><br><br>  So deklarieren Sie Text unter Android deklarativ. <br><br><img src="https://habrastorage.org/webt/5e/l9/cw/5el9cwaiwzb5lyueyebodvghtmk.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virginia Poltrack</a> Illustration</i> <br><br>  <code>TextView</code> in Android-Anwendungen bietet verschiedene Attribute zum Stylen von Text und verschiedene M√∂glichkeiten, sie anzuwenden.  Diese Attribute k√∂nnen direkt im Layout festgelegt werden, einen Stil auf die Ansicht oder das Thema auf das Layout anwenden oder, wenn Sie m√∂chten, textAppearance festlegen.  Aber was davon sollte verwendet werden?  Und was passiert, wenn Sie sie kombinieren? <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/dq/uq/he/dquqher19iptbqt1qxilp4ohcyc.png"><br>  <i>Was und wann verwenden?</i> <br><br>  In diesem Artikel werden verschiedene Ans√§tze zur deklarativen Stilisierung von Text beschrieben (dh wenn Sie Stile in einer XML-Datei definieren). Au√üerdem werden Umfang und Priorit√§t der einzelnen Methoden erl√§utert. <br><br><h2>  tl; dr; </h2><br>  Sie <i>sollten</i> den gesamten Beitrag lesen, aber hier ist eine Zusammenfassung. <br><br>  Denken Sie an die Priorit√§tsreihenfolge verschiedener Stilmethoden. Wenn Sie versuchen, Text zu stilisieren und die erwarteten Ergebnisse nicht sehen, werden Ihre √Ñnderungen h√∂chstwahrscheinlich von etwas mit einer h√∂heren Priorit√§t in dieser Hierarchie √ºberschrieben: <br><br><img src="https://habrastorage.org/webt/f2/zr/lw/f2zrlwisr9g_nupki56f4fcv6g0.png"><br>  <i>Hierarchie der Textstilmethoden</i> <br><br>  Ich w√ºrde das folgende Verfahren f√ºr das Styling vorschlagen: <br><br><ol><li>  <code>textViewStyle</code> Sie einen beliebigen Anwendungsstil in <code>textViewStyle</code> als Standardstil f√ºr Ihr Thema fest. </li><li>  Installieren Sie den (kleinen) Satz von <code>TextAppearance</code> , den Ihre Anwendung verwendet (oder von MaterialComponent- <a href="">Stilen</a> verwendet / erbt), und verweisen Sie direkt aus Ihrer Ansicht darauf </li><li>  Erstellen Sie einen <code>style</code> indem Sie Attribute <code>TextAppearance</code> die von <code>TextAppearance</code> nicht unterst√ºtzt werden (die selbst einen Ihrer <code>TextAppearance</code> ). </li><li>  F√ºhren Sie ein einzigartiges Styling direkt im Layout durch. </li></ol><br><h2>  Zeigen Sie etwas Stil </h2><br>  Sie k√∂nnen die <code>TextView</code> Attribute direkt im Layout <code>TextView</code> , dieser Ansatz kann jedoch langwieriger und unsicherer sein.  Stellen Sie sich vor, Sie versuchen auf diese Weise, die Farbe aller TextViews in der Anwendung zu aktualisieren.  Wie bei allen anderen Ansichten k√∂nnen (und sollten!) Sie stattdessen Stile verwenden, um Konsistenz, Wiederverwendung und einfache Aktualisierung sicherzustellen.  Zu diesem Zweck empfehle ich, Stile f√ºr Text zu erstellen, wenn Sie wahrscheinlich denselben Stil auf mehrere Ansichten anwenden m√∂chten.  Dies ist √§u√üerst einfach und wird weitgehend vom Android-Ansichtssystem unterst√ºtzt. <br><br>  Was passiert unter der Haube, wenn Sie die Ansicht stylen?  Wenn Sie jemals Ihre benutzerdefinierte Ansicht geschrieben haben, haben Sie wahrscheinlich den Aufruf von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">context.obtainStyledAttributes (AttributeSet, int [], int, int) gesehen</a> .  Somit √ºbergibt das Ansichtssystem in Android die im Layout angegebenen Attribute an die Ansicht.  Der <code>AttributeSet</code> Parameter kann tats√§chlich als Zuordnung der XML-Parameter betrachtet werden, die Sie in Ihrem Layout angeben.  Wenn das AttributeSet den Stil festlegt, wird der <b>Stil zuerst gelesen</b> und dann werden die direkt in der Ansicht angegebenen Attribute darauf angewendet.  Damit kommen wir zur ersten Priorit√§tsregel. <br><br>  <b><i>Ansicht ‚Üí Stil</i></b> <br><br>  Direkt in der Ansicht definierte Attribute "√ºberwiegen" immer und √ºberschreiben die im Stil definierten Attribute.  Beachten Sie, dass eine <b>Kombination</b> aus Stil- und Ansichtsattributen angewendet wird.  Durch das Definieren eines Attributs in der Ansicht, das auch im Stil angegeben ist, <b>wird nicht der</b> gesamte Stil abgebrochen.  Es sollte auch beachtet werden, dass es Ihrer Ansicht nach keine wirkliche M√∂glichkeit gibt, festzustellen, woher die Stilisierung kommt.  Dies wird vom Ansichtssystem f√ºr Sie einmal in einem √§hnlichen Anruf entschieden.  Sie k√∂nnen nicht beide Optionen erhalten und ausw√§hlen. <br><br>  Obwohl Stile √§u√üerst n√ºtzlich sind, haben sie ihre Grenzen.  Eine davon ist, dass Sie nur einen Stil auf die Ansicht anwenden k√∂nnen (im Gegensatz zu CSS, bei dem Sie mehrere Klassen anwenden k√∂nnen).  <code>TextView</code> hat jedoch einen Trick: Es stellt das <code>TextAppearance</code> Attribut <code>TextAppearance</code> , das √§hnlich wie der <code>style</code> funktioniert.  Wenn Sie Text √ºber <code>TextAppearance</code> , lassen Sie das <code>TextAppearance</code> f√ºr andere Stile frei, was praktisch aussieht.  Schauen wir uns genauer an, was <code>TextAppearance</code> und wie es funktioniert. <br><br><h2>  Textauftritt </h2><br>  <code>TextAppearance</code> nichts Magisches (zum Beispiel einen geheimen Modus zum Anwenden mehrerer Stile, √ºber die Sie nichts wissen sollten !!!!). <code>TextView</code> erspart Ihnen unn√∂tige Arbeit.  Schauen wir uns den <code>TextView</code> Konstruktor an, um zu verstehen, was passiert. <br><br><pre> <code class="kotlin hljs">TypedArray a = theme.obtainStyledAttributes(attrs, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes); TypedArray appearance = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; int ap = a.getResourceId(com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextViewAppearance_textAppearance, -<span class="hljs-number"><span class="hljs-number">1</span></span>); a.recycle(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ap != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { appearance = theme.obtainStyledAttributes(ap, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.styleable.TextAppearance); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (appearance != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { readTextAppearance(context, appearance, attributes, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); appearance.recycle(); } <span class="hljs-comment"><span class="hljs-comment">// a little later a = theme.obtainStyledAttributes(attrs, com.android.internal.R.styleable.TextView, defStyleAttr, defStyleRes); readTextAppearance(context, a, attributes, true);</span></span></code> </pre> <br>  Also, was ist hier los?  Im Wesentlichen <code>TextView</code> die <code>TextView</code> zun√§chst, ob Sie <code>android:textAppearance</code> angegeben haben. In diesem <code>android:textAppearance</code> wird dieser Stil <code>android:textAppearance</code> und alle dort aufgef√ºhrten Eigenschaften werden <code>android:textAppearance</code> .  Sp√§ter l√§dt er alle Attribute aus der Ansicht (an die er sich erinnert, einschlie√ülich des Stils) und wendet sie an.  Wir kommen also zur Regel der zweiten Priorit√§t: <br><br>  <i><b>Ansicht ‚Üí Stil ‚Üí Textdarstellung</b></i> <br><br>  Da das Erscheinungsbild des Texts zuerst √ºberpr√ºft wird, werden alle Attribute, die entweder direkt in der Ansicht oder im Stil definiert sind, √ºberschrieben. <br><br>  Bei <code>TextAppearance</code> ist noch eine weitere <code>TextAppearance</code> zu beachten: Es unterst√ºtzt eine <b>Teilmenge</b> der <code>TextView</code> , die <code>TextView</code> bietet.  Um besser zu verstehen, was ich meine, gehen wir zur√ºck zu dieser Zeile: <br><br> <code>obtainStyledAttributes(ap, android.R.styleable.TextAppearance);</code> <br> <br>  Wir haben uns die Version <code>receiveStyledAttributes</code> mit 4 Argumenten angesehen. Diese Version mit 2 Argumenten unterscheidet sich geringf√ºgig davon.  Sie betrachtet den angegebenen Stil (wie durch die erste Parameter- <code>id</code> ) und filtert ihn nur nach den Attributen im Stil, die im zweiten Parameter, dem <code>attrs</code> Array, <code>attrs</code> .  So definiert styleable <code>android.R.styleable.TextAppearance</code> den Umfang der <code>TextAppearance</code> .  Wenn wir uns diese Definition ansehen, <code>TextAppearance</code> wir, dass <code>TextAppearance</code> viele, <b>aber nicht alle</b> Attribute <a href="">unterst√ºtzt</a> , die <code>TextView</code> <a href="">unterst√ºtzt</a> . <br><br><pre> <code class="kotlin hljs">&lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColor"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textSize"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textStyle"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"typeface"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"fontFamily"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorHighlight"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorHint"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textColorLink"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"textAllCaps"</span></span> format=<span class="hljs-string"><span class="hljs-string">"boolean"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowColor"</span></span> format=<span class="hljs-string"><span class="hljs-string">"color"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowDx"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowDy"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"shadowRadius"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"elegantTextHeight"</span></span> format=<span class="hljs-string"><span class="hljs-string">"boolean"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"letterSpacing"</span></span> format=<span class="hljs-string"><span class="hljs-string">"float"</span></span> /&gt; &lt;attr name=<span class="hljs-string"><span class="hljs-string">"fontFeatureSettings"</span></span> format=<span class="hljs-string"><span class="hljs-string">"string"</span></span> /&gt;</code> </pre> <br>  <i><b>Von <code>TextAppearance</code> unterst√ºtzte Styling-Attribute</b></i> <br><br>  Hier sind einige <code>TextView</code> Attribute, die nicht in <code>TextAppearance</code> : <code>lineHeight[Multiplier|Extra]</code> , <code>lines</code> , <code>breakStrategy</code> und <code>breakStrategy</code> .  <code>TextAppearance</code> funktioniert auf Zeichenebene und nicht auf <code>TextAppearance</code> , sodass Attribute, die sich auf das gesamte Layout auswirken, nicht unterst√ºtzt werden. <br><br>  Daher ist <code>TextAppearance</code> sehr n√ºtzlich. Es erm√∂glicht uns, einen Stil zu definieren, der sich an den <code>TextAppearance</code> orientiert, und l√§sst den <code>style</code> f√ºr andere Zwecke frei.  Es hat jedoch einen begrenzten Umfang und befindet sich am Ende der Priorit√§tskette. Vergessen Sie also nicht die Einschr√§nkungen. <br><br><h2>  Angemessene Standardeinstellungen </h2><br>  Als wir uns angesehen haben, wie die Android-Ansicht Attribute aufl√∂st ( <code>context.obtainStyledAttributes</code> ), haben wir es tats√§chlich ein wenig vereinfacht.  Sie ruft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">theme.obtainStyledAttributes auf</a> (unter Verwendung des aktuellen <code>Theme Context</code> 'a).  Beim √úberpr√ºfen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Links</a> wird die zuvor untersuchte Priorit√§tsreihenfolge angezeigt, und es werden zwei weitere Stellen angezeigt, nach denen er sucht, um Attribute aufzul√∂sen: der Standardstil f√ºr die Ansicht und das Thema. <br><br>  <i>Bei der Bestimmung des Endwerts eines bestimmten Attributs kommen vier Eingabeparameter ins Spiel:</i> <i><br><br></i> <ol><li>  <i>Alle Attributwerte in diesem AttributeSet.</i> </li><li>  <i>Die im AttributeSet angegebene Stilressource (mit dem Namen "style").</i> </li><li>  <i>Der von defStyleAttr und defstyleres angegebene Standardstil</i> </li><li>  <i>Grundwerte in diesem Thread.</i> </li></ol><br>  <i>Styling Priority Order aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Themendokumentation</a></i> <br><br>  Wir werden auf die Themen zur√ºckkommen, aber schauen wir uns zuerst die Standardstile an.  Was ist dieser Standardstil?  Um diese Frage zu beantworten, halte ich es f√ºr n√ºtzlich, das <code>TextView</code> Thema ein wenig zu verlassen und einen einfachen <code>Button</code> .  Wenn Sie <code><code>&lt;</code> <code>Button</code> <code>&gt;</code></code> in Ihr Layout einf√ºgen, sieht es ungef√§hr so ‚Äã‚Äãaus. <br><br><img src="https://habrastorage.org/webt/qn/da/wn/qndawn5dk_gwfj3h7wki2xzee8u.png"><br>  <i>Standardknopf</i> <br><br>  Warum?  Wenn Sie sich den Quellcode von <code>Button</code> ansehen, werden Sie feststellen, dass er eher d√ºrftig ist: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, attrs, com.android.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.R.attr.buttonStyle); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs, int defStyleAttr) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(context, attrs, defStyleAttr, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Button(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(context, attrs, defStyleAttr, defStyleRes); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CharSequence getAccessibilityClassName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Button.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>.getName(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getPointerIcon() == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isClickable() &amp;&amp; isEnabled()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PointerIcon.getSystemIcon(getContext(), PointerIcon.TYPE_HAND); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onResolvePointerIcon(event, pointerIndex); } }</code> </pre> <br>  Das ist alles!  Hier ist die ganze Klasse (kein Kommentar).  Sie k√∂nnen <a href="">es hier</a> selbst √ºberpr√ºfen.  Ich warte.  Woher kommen also Hintergrund, Gro√übuchstaben, Welligkeit usw.?  M√∂glicherweise haben Sie etwas verpasst, aber alles wird im Konstruktor mit zwei Argumenten definiert.  Eine, die aufgerufen wird, wenn das Layout aus XML √ºbernommen wird.  Dies ist der letzte Parameter, der <code>defaultStyleAttr</code> in <code>com.android.internal.R.attr.buttonStyle</code> definiert.  Dies ist der Standardstil, bei dem es sich im Wesentlichen um einen indirekten Referenzpunkt handelt, mit dem Sie den Standardstil angeben k√∂nnen.  Es zeigt nicht direkt auf den Stil, sondern erm√∂glicht es Ihnen, auf einen der in Ihrem Thema angegebenen Stile zu verweisen, die beim Aufl√∂sen von Attributen √ºberpr√ºft werden.  Und genau das tun alle Themen, von denen Sie normalerweise erben, um das Erscheinungsbild von Standard-Widgets zu erhalten.  Wenn Sie sich beispielsweise das Thema Material ansehen, definiert es <code>@style/Widget.Material.Light.Button</code> , und dieser Stil bietet alle Attribute, die <code>theme.obtainStyledAttributes</code> wenn Sie nichts anderes angegeben haben. <br><br>  Zur√ºck zu <code>TextView</code> bietet es auch einen Standardstil: <code>textViewStyle</code> .  Dies kann sehr praktisch sein, wenn Sie einige Stile auf jede Textansicht in Ihrer Anwendung anwenden m√∂chten.  Angenommen, Sie m√∂chten den Standardzeilenabstand auf 1,2 festlegen.  Sie k√∂nnen dies mit <code>style/TextAppearance</code> und versuchen, es w√§hrend einer <code>style/TextAppearance</code> (oder vielleicht sogar mit einer eleganten benutzerdefinierten Regel in Lint) anzuwenden. Sie m√ºssen jedoch wachsam sein und sicherstellen, dass Sie neue Teammitglieder einstellen , seien Sie vorsichtig beim Refactoring usw. <br><br>  Ein besserer Ansatz w√§re, Ihren eigenen Standardstil f√ºr alle <code>TextView</code> in der Anwendung anzugeben und das gew√ºnschte Verhalten <code>TextView</code> .  Sie k√∂nnen dies tun, indem Sie Ihren eigenen Stil f√ºr <code>textViewStyle</code> , der standardm√§√üig von der Plattform oder von <code>MaterialComponents/AppCompat</code> wird. <br><br><pre> <code class="kotlin hljs">&lt;style name=<span class="hljs-string"><span class="hljs-string">"Theme.MyApp"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@style/Theme.MaterialComponents.Light"</span></span>&gt; ... &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:textViewStyle"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@style</span></span>/Widget.MyApp.TextView&lt;/item&gt;&lt;/style&gt; &lt;style name=<span class="hljs-string"><span class="hljs-string">"Widget.MyApp.TextView"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@android:style/Widget.Material.TextView"</span></span>&gt; &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:textAppearance"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@style</span></span>/TextAppearance.MyApp.Body&lt;/item&gt; &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:lineSpacingMultiplier"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@dimen</span></span>/text_line_spacing&lt;/item&gt; &lt;/style&gt;</code> </pre> <br>  In diesem Sinne hat unsere Priorit√§tsregel die Form: <br><br>  <i><b>Ansicht -&gt; Stil -&gt; Standardstil -&gt; Textdarstellung</b></i> <br><br>  Im Rahmen der Aufl√∂sung der Attribute des Ansichtssystems wird dieser Slot nach den Stilen ausgef√ºllt (sodass standardm√§√üig alles im Stil durch den angewendeten Stil oder die Ansichtsattribute gel√∂scht wird), √ºberschreibt jedoch weiterhin das Erscheinungsbild des Texts.  Standardstile k√∂nnen sehr praktisch sein.  Wenn Sie sich jemals dazu entschlie√üen, eine eigene benutzerdefinierte Ansicht zu schreiben, k√∂nnen diese eine leistungsstarke Methode zum Implementieren des Standardverhaltens sein und das Anpassen vereinfachen. <br><br>  Wenn Sie das Widget erben und keinen eigenen Standardstil angeben, m√ºssen Sie den Standardstil der √ºbergeordneten Klasse in den Konstruktoren verwenden (√ºbergeben Sie nicht nur 0).  Wenn Sie beispielsweise von <code>AppCompatTextView</code> erben und Ihren eigenen Konstruktor mit 2 Argumenten schreiben, m√ºssen Sie <code>android.R.attr.textViewStyle  defaultStyleAttr</code> ( <a href="">wie hier</a> ) √ºbergeben, da Sie sonst das Verhalten der √ºbergeordneten Klasse verlieren. <br><br><h2>  Themen </h2><br>  Wie bereits erw√§hnt, gibt es eine andere (ich verspreche es letzte) M√∂glichkeit, Styling-Informationen bereitzustellen.  Ein anderer Ort <code>theme.obtainStyledAttributes</code> wird direkt in das Thema selbst schauen.  Das hei√üt, wenn Sie Ihrem Thema ein <code>android:textColor</code> hinzuf√ºgen, z. B. <code>android:textColor</code> , <code>android:textColor</code> das Ansichtssystem es als letzten Ausweg aus.  In der Regel ist es eine schlechte Idee, Themenattribute und Stilattribute zu mischen. Das hei√üt, was Sie direkt auf die Ansicht anwenden, sollte in der Regel niemals f√ºr das Thema festgelegt werden (und umgekehrt), aber es gibt einige seltene Ausnahmen. <br><br>  Ein Beispiel w√§re, wenn Sie versuchen, die Schriftart in der gesamten Anwendung zu √§ndern.  Sie k√∂nnen eine der oben beschriebenen Methoden verwenden, aber das manuelle Anpassen der Stile / des Erscheinungsbilds des Texts √ºberall ist eint√∂nig und unsicher, und die Standardstile funktionieren nur auf Widget-Ebene.  Unterklassen k√∂nnen dieses Verhalten √ºberschreiben. Beispielsweise definieren Schaltfl√§chen ihren eigenen <code>android:buttonStyle</code> , den Ihr <code>android:textViewStyle</code> nicht <code>android:textViewStyle</code> .  Stattdessen k√∂nnen Sie die Schriftart in Ihrem Thema angeben: <br><br><pre> <code class="kotlin hljs">&lt;style name=<span class="hljs-string"><span class="hljs-string">"Theme.MyApp"</span></span> parent=<span class="hljs-string"><span class="hljs-string">"@style/Theme.MaterialComponents.Light"</span></span>&gt; ... &lt;item name=<span class="hljs-string"><span class="hljs-string">"android:fontFamily"</span></span>&gt;<span class="hljs-meta"><span class="hljs-meta">@font</span></span>/space_mono&lt;/item&gt; &lt;/style&gt;</code> </pre> <br>  Jetzt nimmt jede Ansicht, die dieses Attribut unterst√ºtzt, es auf, wenn es nicht von etwas mit einer h√∂heren Priorit√§t √ºberschrieben wird: <br><br>  <i><b>Ansicht ‚Üí Stil ‚Üí Standardstil ‚Üí Thema ‚Üí Textdarstellung</b></i> <br><br>  Da dies wiederum Teil des Ansichtsstilsystems ist, √ºberschreibt es alles, was in Textform bereitgestellt wird, wird jedoch durch spezifischere Attribute √ºberschrieben. <br><br>  Denken Sie an diese Priorit√§t.  In unserem Beispiel mit einer Schriftart f√ºr die gesamte Anwendung k√∂nnen Sie erwarten, dass die <code>Toolbar</code> diese Schriftart <code>TextView</code> , da sie den Titel enth√§lt, bei dem es sich um eine <code>TextView</code> .  Die Toolbar-Klasse selbst definiert jedoch einen Standardstil mit <code>titleTextAppearance</code> , der <code>android:fontFamily</code> definiert, und legt ihn direkt im <code>TextView</code> Header fest, wobei der Wert auf <code>TextView</code> √ºberschrieben wird.  Stile auf Themenebene k√∂nnen n√ºtzlich sein, lassen sich jedoch leicht √ºberschreiben. Stellen Sie daher sicher, dass sie ordnungsgem√§√ü angewendet werden. <br><br><h2>  Bonus: Ungel√∂ste Probleme </h2><br>  Dieser gesamte Artikel widmete sich der deklarativen Gestaltung von Text auf Ansichtsebene, <code>TextView</code> dem Stil der gesamten <code>TextView</code> w√§hrend des F√ºllens.  Jeder nach dem F√ºllen angewendete Stil (z. B. <code>textView.setTextColor(‚Ä¶)</code> ) √ºberschreibt das deklarative Styling.  <code>TextView</code> unterst√ºtzt auch kleinere Stile √ºber <code>Span</code> .  Ich werde nicht auf dieses Thema eingehen, da es in Artikeln von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Florina Muntenescu</a> ausf√ºhrlich beschrieben wird. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spantastisches Textstyling mit Spans</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberspannende Bereiche</a> <br><br>  Ich werde dies der Vollst√§ndigkeit halber erw√§hnen, um zu ber√ºcksichtigen, dass Programmstil und -spannen ganz oben auf der Priorit√§tsreihenfolge stehen: <br><br>  <i><b>Bereich ‚Üí Setter ‚Üí Ansicht ‚Üí Stil ‚Üí Standardstil ‚Üí Thema ‚Üí Textdarstellung</b></i> <br><br><h2>  W√§hlen Sie Ihren Stil </h2><br>  Obwohl es verschiedene M√∂glichkeiten gibt, Ihren Text zu formatieren, hilft Ihnen das Verst√§ndnis der Unterschiede zwischen Methoden und ihrer Einschr√§nkungen, das richtige Werkzeug f√ºr eine bestimmte Aufgabe zu finden oder zu verstehen, warum eine Methode Vorrang vor einer anderen hat. <br><br>  Habt einen sch√∂nen Text Styling! <br><br>  Wir laden alle zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen Webinar ein,</a> in dessen Rahmen wir uns mit dem DI-Framework Dagger 2 vertraut machen werden: Wir werden untersuchen, wie Dagger2 Code generiert, wir werden mit JSR 330-Annotationen und Dagger2-Konstrukten umgehen, wir werden lernen, wie Dagger2 in einer Multimodul-Anwendung verwendet wird, und den Dagger Android Injector in Betracht ziehen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456110/">https://habr.com/ru/post/de456110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456094/index.html">Wir lesen Datenbl√§tter 2: SPI auf STM32; PWM-Timer und Interrupts auf dem STM8</a></li>
<li><a href="../de456096/index.html">Was der durchschnittliche Geektimes-Leser tut, w√§hrend er in den Wolken schwebt</a></li>
<li><a href="../de456100/index.html">Jetzt in der neuen Verpackung - Kingston A400 im M.2-Format eilt auf den Markt</a></li>
<li><a href="../de456104/index.html">Ezblock Pi - Programmieren ohne Programmieren, diesmal f√ºr Raspberry Pi-Fans</a></li>
<li><a href="../de456106/index.html">Wir teilen Features schneller. Android-Entwicklungserfahrung bei Badoo</a></li>
<li><a href="../de456112/index.html">√úberwindung des Mooreschen Gesetzes: Wie man traditionelle planare Transistoren ersetzt</a></li>
<li><a href="../de456114/index.html">Was ist neu in der Mamba-Entwicklung?</a></li>
<li><a href="../de456116/index.html">So erstellen Sie ein sch√∂nes Datenbankschema in yEd Graph Editor</a></li>
<li><a href="../de456118/index.html">Marvin Minskys ‚ÄûThe Emotion Machine‚Äú: Kapitel 8.1-2 ‚ÄûKreativit√§t‚Äú</a></li>
<li><a href="../de456122/index.html">Contours gr√∂√üter Hackathon: Beseitigung von Ghul und Liebe zur Umwelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>