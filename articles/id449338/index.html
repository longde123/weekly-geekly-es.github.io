<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏻 👩🏽‍🔧 🚄 Julia. Layanan Web 🏜️ 🗞️ 🐜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus mempertimbangkan teknologi Julia. Dan hari ini kita akan berbicara tentang paket yang dirancang untuk membangun layanan web. Bukan rahasia ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia. Layanan Web</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449338/"><p><img src="https://habrastorage.org/webt/ez/8k/mw/ez8kmwwtsavwdve31oj9__-kj6e.png"></p><br><p>  Kami terus mempertimbangkan teknologi Julia.  Dan hari ini kita akan berbicara tentang paket yang dirancang untuk membangun layanan web.  Bukan rahasia lagi bahwa niche utama bahasa Julia adalah komputasi berkinerja tinggi.  Oleh karena itu, langkah yang cukup logis adalah secara langsung membuat layanan web yang mampu melakukan perhitungan sesuai permintaan.  Tentu saja, layanan web bukan satu-satunya cara untuk berkomunikasi dalam lingkungan jaringan.  Tapi, karena mereka sekarang paling banyak digunakan dalam sistem terdistribusi, maka kami akan mempertimbangkan pembuatan layanan yang melayani permintaan HTTP. </p><br><p>  Perhatikan bahwa karena pemuda Julia, ada satu set paket yang bersaing.  Karena itu, kami akan mencoba mencari tahu bagaimana dan mengapa menggunakannya.  Sepanjang jalan, kami membandingkan implementasi layanan web JSON yang sama dengan bantuan mereka. </p><a name="habracut"></a><br><p>  Infrastruktur Julia telah aktif berkembang dalam satu atau dua tahun terakhir.  Dan, dalam hal ini, ini bukan hanya frase on-line yang ditulis untuk awal teks yang indah, tetapi penekanan pada kenyataan bahwa semuanya berubah secara intensif, dan apa yang relevan beberapa tahun yang lalu sekarang sudah ketinggalan zaman.  Namun, kami akan mencoba menyoroti paket-paket stabil dan memberikan rekomendasi tentang bagaimana mengimplementasikan layanan web dengan bantuan mereka.  Untuk lebih jelasnya, kami akan membuat layanan web yang menerima permintaan POST dengan data JSON dalam format berikut: </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">"something"</span></span> }</code> </pre> <br><p>  Kami berasumsi bahwa layanan yang kami buat tidak TENANG.  Tugas utama kami adalah untuk mempertimbangkan dengan tepat metode untuk menggambarkan rute dan meminta penangan. </p><br><h2 id="paket-httpjl">  Paket HTTP.jl </h2><br><p>  Paket ini adalah implementasi utama protokol HTTP di Julia dan secara bertahap mendapatkan fitur baru.  Selain menerapkan struktur dan fungsi khas untuk mengeksekusi permintaan klien HTTP, paket ini juga mengimplementasikan fungsi untuk membuat server HTTP.  Pada saat yang sama, seiring dengan perkembangannya, paket tersebut telah menerima fungsi-fungsi yang membuatnya cukup nyaman bagi programmer untuk mendaftarkan penangan dan, dengan demikian, membangun layanan yang khas.  Juga, dalam versi terbaru, ada dukungan built-in untuk protokol WebSocket, implementasi yang sebelumnya dibuat sebagai bagian dari paket WebSocket.jl terpisah.  Artinya, HTTP.jl, saat ini, dapat memenuhi sebagian besar kebutuhan seorang programmer.  Mari kita lihat beberapa contoh secara lebih rinci. </p><br><h3 id="klient-http">  Klien HTTP </h3><br><p>  Kami memulai implementasi dengan kode klien, yang akan kami gunakan untuk memverifikasi operabilitas. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import HTTP import JSON.json const PORT = "8080" const HOST = "127.0.0.1" const NAME = "Jemand" #    struct Document title::String body::String end #         Base.show(r::HTTP.Messages.Response) = println(r.status == 200 ? String(r.body) : "Error: " * r.status) #    r = HTTP.get("http://$(HOST):$(PORT)") show(r) #   /user/:name r = HTTP.get("http://$(HOST):$(PORT)/user/$(NAME)"; verbose=1) show(r) #  JSON- POST- doc = Document("Some document", "Test document with some content.") r = HTTP.post( "http://$(HOST):$(PORT)/resource/process", [("Content-Type" =&gt; "application/json")], json(doc); verbose=3) show(r)</span></span></code> </pre> <br><p>  Paket HTTP menyediakan metode yang cocok dengan nama-nama perintah protokol HTTP.  Dalam hal ini, kami menggunakan <code>get</code> dan <code>post</code> .  Argumen opsional bernama <code>verbose</code> memungkinkan Anda untuk mengatur jumlah informasi debug yang akan dikeluarkan.  Jadi, misalnya, <code>verbose=1</code> akan menghasilkan: </p><br><pre> <code class="plaintext hljs">GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1)</code> </pre> <br><p>  Dan dalam kasus <code>verbose=3</code> kami sudah mendapatkan set lengkap data yang dikirim dan diterima: </p><br><pre> <code class="plaintext hljs">DEBUG: 2019-04-21T22:40:40.961 eb4f ️-&gt; "POST /resource/process HTTP/1.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f ️-&gt; "Content-Type: application/json\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f ️-&gt; "Host: 127.0.0.1\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f ️-&gt; "Content-Length: 67\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 eb4f ️-&gt; "\r\n" (write) DEBUG: 2019-04-21T22:40:40.961 e1c6 ️-&gt; "{\"title\":\"Some document\",\"body\":\"Test document with some content.\"}" (unsafe_write) DEBUG: 2019-04-21T22:40:40.963 eb4f ️&lt;- "HTTP/1.1 200 OK\r\n" (readuntil) DEBUG: "Content-Type: application/json\r\n" DEBUG: "Transfer-Encoding: chunked\r\n" DEBUG: "\r\n" DEBUG: 2019-04-21T22:40:40.963 eb4f ️&lt;- "5d\r\n" (readuntil) DEBUG: 2019-04-21T22:40:40.963 eb4f ️&lt;- "{\"body\":\"Test document with some content.\",\"server_mark\":\"confirmed\",\"title\":\"Some document\"}" (unsafe_read) DEBUG: 2019-04-21T22:40:40.968 eb4f ️&lt;- "\r\n" (readuntil) DEBUG: "0\r\n" DEBUG: 2019-04-21T22:40:40.968 eb4f ️&lt;- "\r\n" (readuntil)</code> </pre> <br><p>  Di masa mendatang, kami hanya akan menggunakan <code>verbose=1</code> untuk hanya melihat informasi minimal tentang apa yang terjadi. </p><br><p>  Beberapa komentar mengenai kode. </p><br><pre> <code class="julia hljs">doc = Document(<span class="hljs-string"><span class="hljs-string">"Some document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Test document with some content."</span></span>)</code> </pre> <br><p>  Karena kita sebelumnya mendeklarasikan struktur Dokumen (lebih lanjut, tidak dapat diubah), sebuah konstruktor tersedia untuknya secara default, argumen yang sesuai dengan bidang struktur yang dinyatakan.  Untuk mengonversinya menjadi JSON, kami menggunakan paket <code>JSON.jl</code> dan metode <code>json(doc)</code> . <br>  Perhatikan fragmen: </p><br><pre> <code class="julia hljs">r = HTTP.post( <span class="hljs-string"><span class="hljs-string">"http://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(HOST)</span></span></span><span class="hljs-string">:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(PORT)</span></span></span><span class="hljs-string">/resource/process"</span></span>, [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)], json(doc); verbose=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Karena kami melewati JSON, Anda harus secara eksplisit menentukan jenis <code>application/json</code> di header <code>Content-Type</code> .  Header diteruskan ke metode <code>HTTP.post</code> (namun, seperti semua yang lain) menggunakan array (bertipe Vector, tetapi bukan Dict) yang berisi pasangan header nama - nilai. </p><br><p>  Untuk tes kesehatan, kami akan melakukan tiga pertanyaan: </p><br><ul><li>  DAPATKAN permintaan ke rute root; </li><li>  DAPATKAN permintaan dalam format / pengguna / nama, di mana nama adalah nama yang dikirimkan; </li><li>  Permintaan POST / sumber daya / proses dengan objek JSON berlalu.  Kami berharap untuk menerima dokumen yang sama, tetapi dengan bidang <code>server_mark</code> ditambahkan. </li></ul><br><p>  Kami akan menggunakan kode klien ini untuk menguji semua opsi implementasi server. </p><br><h3 id="server-http">  Server HTTP </h3><br><p>  Setelah Anda mengetahui klien, saatnya untuk mulai mengimplementasikan server.  Untuk memulainya, kami akan membuat layanan hanya dengan bantuan <code>HTTP.jl</code> agar tetap sebagai opsi dasar, yang tidak memerlukan instalasi paket lain.  Kami mengingatkan Anda bahwa semua paket lain <code>HTTP.jl</code> menggunakan <code>HTTP.jl</code> </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. import Sockets import HTTP import JSON #    #    index(req::HTTP.Request) = HTTP.Response(200, "Hello World") #     function welcome_user(req::HTTP.Request) # dump(req) user = "" if (m = match( r".*/user/([[:alpha:]]+)", req.target)) != nothing user = m[1] end return HTTP.Response(200, "Hello " * user) end #  JSON function process_resource(req::HTTP.Request) # dump(req) message = JSON.parse(String(req.body)) @info message message["server_mark"] = "confirmed" return HTTP.Response(200, JSON.json(message)) end #      const ROUTER = HTTP.Router() HTTP.@register(ROUTER, "GET", "/", index) HTTP.@register(ROUTER, "GET", "/user/*", welcome_user) HTTP.@register(ROUTER, "POST", "/resource/process", process_resource) HTTP.serve(ROUTER, Sockets.localhost, 8080)</span></span></code> </pre> <br><p>  Dalam contoh, Anda harus memperhatikan kode berikut: </p><br><pre> <code class="julia hljs">dump(req)</code> </pre> <br><p>  mencetak ke konsol segala sesuatu yang diketahui oleh objek.  Termasuk tipe data, nilai, serta semua bidang bersarang dan nilainya.  Metode ini berguna untuk penelitian pustaka dan debugging. </p><br><p>  Tali </p><br><pre> <code class="julia hljs">(m = match( <span class="hljs-string"><span class="hljs-string">r".*/user/([[:alpha:]]+)"</span></span>, req.target))</code> </pre> <br><p>  adalah ekspresi reguler yang mem-parsing rute yang didaftarkan pawang.  Paket <code>HTTP.jl</code> tidak menyediakan cara otomatis untuk mengidentifikasi pola dalam rute. </p><br><p>  Di dalam <code>process_resource</code> handler, kami mengurai JSON yang diterima oleh layanan. </p><br><pre> <code class="julia hljs">message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req.body))</code> </pre> <br><p>  Data diakses melalui bidang <code>req.body</code> .  Perhatikan bahwa data datang dalam format array byte.  Oleh karena itu, untuk bekerja dengan mereka sebagai string, konversi eksplisit ke string dilakukan.  Metode <code>JSON.parse</code> adalah metode paket <code>JSON.jl</code> yang deserializes data dan membangun objek.  Karena objek dalam kasus ini adalah array asosiatif (Dict), kita dapat dengan mudah menambahkan kunci baru ke dalamnya.  Tali </p><br><pre> <code class="julia hljs">message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span></code> </pre> <br><p>  menambahkan kunci <code>server_mark</code> dengan nilai <code>confirmed</code> . </p><br><p>  Layanan <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> ketika garis <code>HTTP.serve(ROUTER, Sockets.localhost, 8080)</code> . </p><br><p>  Respons kontrol untuk layanan berdasarkan HTTP.jl (diperoleh saat menjalankan kode klien dengan <code>verbose=1</code> ): </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Terhadap latar belakang informasi debug dengan <code>verbose=1</code> , kita dapat dengan jelas melihat baris: <code>Hello World</code> , <code>Hello Jemand</code> , <code>"server_mark":"confirmed"</code> . </p><br><p>  Setelah melihat kode layanan, muncul pertanyaan alami - mengapa kita membutuhkan semua paket lain, jika semuanya sangat sederhana dalam HTTP.  Ada jawaban yang sangat sederhana untuk ini.  HTTP - memungkinkan mendaftar penangan dinamis, tetapi bahkan implementasi dasar membaca file gambar statis dari direktori memerlukan implementasi terpisah.  Oleh karena itu, kami juga mempertimbangkan paket yang berfokus pada pembuatan aplikasi web. </p><br><h2 id="paket-muxjl">  Paket Mux.jl </h2><br><p>  Paket ini diposisikan sebagai lapisan menengah untuk aplikasi web yang diimplementasikan pada Julia.  Implementasinya sangat ringan.  Tujuan utamanya adalah untuk menyediakan cara mudah untuk menggambarkan penangan.  Ini bukan untuk mengatakan bahwa proyek ini tidak berkembang, tetapi berkembang perlahan.  Namun, lihat kode untuk layanan kami yang melayani rute yang sama. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Mux using JSON @app test = ( Mux.defaults, page(respond("&lt;h1&gt;Hello World!&lt;/h1&gt;")), page("/user/:user", req -&gt; "&lt;h1&gt;Hello, $(req[:params][:user])!&lt;/h1&gt;"), route("/resource/process", req -&gt; begin message = JSON.parse(String(req[:data])) @info message message["server_mark"] = "confirmed" return Dict( :body =&gt; JSON.json(message), :headers =&gt; [("Content-Type" =&gt; "application/json")] ) end), Mux.notfound() ) serve(test, 8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Di sini rute dijelaskan menggunakan metode <code>page</code> .  Aplikasi web dinyatakan menggunakan makro <code>@app</code> .  Argumen untuk metode <code>page</code> adalah rute dan pawang.  Pawang dapat ditentukan sebagai fungsi yang menerima permintaan sebagai input, atau dapat ditentukan sebagai fungsi lambda.  Dari fungsi-fungsi tambahan yang bermanfaat, <code>Mux.notfound()</code> hadir untuk mengirim respons <code>Not found</code> ditentukan.  Dan hasil yang harus dikirim ke klien tidak perlu dikemas dalam <code>HTTP.Response</code> , seperti yang kita lakukan pada contoh sebelumnya, karena Mux akan melakukannya sendiri.  Namun, Anda masih harus melakukan JSON parsing sendiri, seperti halnya serialisasi objek untuk respons - <code>JSON.json(message)</code> . </p><br><pre> <code class="julia hljs"> message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(req[:data])) message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>( :body =&gt; JSON.json(message), :headers =&gt; [(<span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)] )</code> </pre> <br><p>  Respons dikirim sebagai array asosiatif dengan bidang <code>:body</code> <code>:headers</code> . </p><br><p>  Memulai server dengan metode <code>serve(test, 8080)</code> adalah asinkron, jadi salah satu opsi di Julia untuk mengatur menunggu penyelesaian adalah dengan memanggil kode: </p><br><pre> <code class="julia hljs">Base.JLOptions().isinteractive == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; wait()</code> </pre> <br><p>  Jika tidak, layanan ini melakukan hal yang sama dengan versi sebelumnya di <code>HTTP.jl</code> </p><br><p>  Kontrol respons untuk layanan: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) &lt;h1&gt;Hello World!&lt;/h1&gt; GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) &lt;h1&gt;Hello, Jemand!&lt;/h1&gt; POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><h2 id="paket-bukdujl">  Paket Bukdu.jl </h2><br><p>  Paket ini dikembangkan di bawah pengaruh kerangka Phoenix, yang, pada gilirannya, diimplementasikan pada Elixir dan merupakan implementasi ide membangun web dari komunitas Ruby dalam proyeksi pada Elixir.  Proyek ini berkembang cukup aktif dan diposisikan sebagai alat untuk membuat API tenang dan aplikasi web ringan.  Ada beberapa fungsi untuk menyederhanakan serialisasi dan deserialisasi JSON.  Ini tidak ada dalam <code>HTTP.jl</code> dan <code>Mux.jl</code>  Mari kita lihat implementasi dari layanan web kami. </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. using Bukdu using JSON #   struct WelcomeController &lt;: ApplicationController conn::Conn end #   index(c::WelcomeController) = render(JSON, "Hello World") welcome_user(c::WelcomeController) = render(JSON, "Hello " * c.params.user) function process_resource(c::WelcomeController) message = JSON.parse(String(c.conn.request.body)) @info message message["server_mark"] = "confirmed" render(JSON, message) end #   routes() do get("/", WelcomeController, index) get("/user/:user", WelcomeController, welcome_user, :user =&gt; String) post("/resource/process", WelcomeController, process_resource) end #   Bukdu.start(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Hal pertama yang harus Anda perhatikan adalah deklarasi struktur untuk menyimpan status pengontrol. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> WelcomeController &lt;: ApplicationController conn::Conn <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Dalam hal ini, ini adalah tipe konkret yang dibuat sebagai turunan dari <code>ApplicationController</code> tipe abstrak. </p><br><p>  Metode untuk pengontrol dideklarasikan dengan cara yang sama sehubungan dengan implementasi sebelumnya.  Ada sedikit perbedaan dalam penangan objek JSON kami. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> process_resource(c::WelcomeController) message = JSON.parse(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(c.conn.request.body)) <span class="hljs-meta"><span class="hljs-meta">@info</span></span> message message[<span class="hljs-string"><span class="hljs-string">"server_mark"</span></span>] = <span class="hljs-string"><span class="hljs-string">"confirmed"</span></span> render(JSON, message) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Seperti yang Anda lihat, deserialisasi juga dilakukan secara independen menggunakan metode <code>JSON.parse</code> , tetapi metode <code>render(JSON, message)</code> yang <code>JSON.parse</code> digunakan untuk membuat serialisasi respons. </p><br><p>  Deklarasi rute dilakukan dengan gaya tradisional untuk para rubis, termasuk penggunaan blok <code>do...end</code> . </p><br><pre> <code class="julia hljs">routes() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, WelcomeController, index) get(<span class="hljs-string"><span class="hljs-string">"/user/:user"</span></span>, WelcomeController, welcome_user, :user =&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) post(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, WelcomeController, process_resource) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Juga, dengan cara tradisional untuk rubis, segmen dideklarasikan di jalur rute <code>/user/:user</code> .  Dengan kata lain, bagian variabel dari ekspresi, akses yang dapat dilakukan oleh nama yang ditentukan dalam templat.  Secara sintaksis ditunjuk sebagai perwakilan dari <code>Symbol</code> tipe.  Ngomong-ngomong, bagi Julia, jenis <code>Symbol</code> berarti, pada intinya, sama seperti untuk Ruby - ini adalah string yang tidak dapat diubah, direpresentasikan dalam memori dengan satu instance. </p><br><p>  Dengan demikian, setelah kami menyatakan rute dengan bagian variabel, dan juga menunjukkan jenis bagian variabel ini, kami dapat merujuk ke data yang sudah diuraikan oleh nama yang diberikan.  Dalam metode yang memproses permintaan, kami cukup mengakses bidang melalui titik di formulir <code>c.params.user</code> . </p><br><pre> <code class="julia hljs">welcome_user(c::WelcomeController) = render(JSON, <span class="hljs-string"><span class="hljs-string">"Hello "</span></span> * c.params.user)</code> </pre> <br><p>  Kontrol respons untuk layanan: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) "Hello World" GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) "Hello Jemand" POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Kesimpulan layanan ke konsol: </p><br><pre> <code class="plaintext hljs">&gt;./bukdu_json.jl INFO: Bukdu Listening on 127.0.0.1:8080 INFO: GET WelcomeController index 200 / INFO: GET WelcomeController welcome_user 200 /user/Jemand INFO: Dict{String,Any}("body"=&gt;"Test document with some content.","title"=&gt;"Some document") INFO: POST WelcomeController process_resource200 /resource/process</code> </pre> <br><h2 id="paket-geniejl">  Paket Genie.jl </h2><br><p>  Proyek ambisius yang diposisikan sebagai kerangka kerja MVC.  Dalam pendekatannya, "Rails" pada Julia cukup jelas terlihat, termasuk struktur direktori yang dibuat oleh generator.  Proyek ini sedang berkembang, namun, untuk alasan yang tidak diketahui, paket ini tidak termasuk dalam repositori paket Julia.  Yaitu, instalasinya hanya dimungkinkan dari repositori git dengan perintah: </p><br><pre> <code class="julia hljs">julia&gt;] <span class="hljs-comment"><span class="hljs-comment"># switch to pkg&gt; mode pkg&gt; add https://github.com/essenciary/Genie.jl</span></span></code> </pre> <br><p>  Kode layanan kami di Genie adalah sebagai berikut (kami tidak menggunakan generator): </p><br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env julia --project=@. #     import Genie import Genie.Router: route, @params, POST import Genie.Requests: jsonpayload, rawpayload import Genie.Renderer: json! #      route("/") do "Hello World!" end route("/user/:user") do "Hello " * @params(:user) end route("/resource/process", method = POST) do message = jsonpayload() # if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end #   Genie.AppServer.startup(8080) Base.JLOptions().isinteractive == 0 &amp;&amp; wait()</span></span></code> </pre> <br><p>  Di sini Anda harus memperhatikan format deklarasi. </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Kode ini sangat akrab bagi programmer Ruby.  Blok <code>do...end</code> sebagai penangan dan rute sebagai argumen ke metode.  Perhatikan bahwa untuk Julia kode ini dapat ditulis ulang dalam bentuk: </p><br><pre> <code class="julia hljs">route(req -&gt; <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>)</code> </pre> <br><p>  Artinya, fungsi pawang ada di tempat pertama, rute ada di tempat kedua.  Tapi untuk kasus kami, mari kita tinggalkan gaya ruby. </p><br><p>  Genie secara otomatis mengemas hasil eksekusi menjadi respons HTTP.  Dalam kasus minimum, kita hanya perlu mengembalikan hasil dari tipe yang benar, misalnya String.  Dari fasilitas tambahan, verifikasi otomatis format input dan analisisnya dilaksanakan.  Misalnya, untuk JSON, Anda hanya perlu memanggil metode <code>jsonpayload()</code> . </p><br><pre> <code class="julia hljs">route(<span class="hljs-string"><span class="hljs-string">"/resource/process"</span></span>, method = POST) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> message = jsonpayload() <span class="hljs-comment"><span class="hljs-comment"># if message == nothing # dump(Genie.Requests.rawpayload()) # end message["server_mark"] = "confirmed" return message |&gt; json! end</span></span></code> </pre> <br><p>  Perhatikan fragmen kode yang dikomentari di sini.  Metode <code>jsonpayload()</code> <code>nothing</code> mengembalikan <code>nothing</code> jika karena alasan tertentu format input tidak dikenali sebagai JSON.  Perhatikan bahwa hanya untuk ini, tajuk <code>[("Content-Type" =&gt; "application/json")]</code> ditambahkan ke klien HTTP kami, karena jika tidak, Genie bahkan tidak akan mulai mem-parsing data sebagai JSON.  Jika sesuatu yang tidak dapat dipahami telah datang, akan berguna untuk melihat <code>rawpayload()</code> untuk apa itu.  Namun, karena ini hanya fase debugging, Anda tidak boleh meninggalkannya dalam kode. </p><br><p>  Juga, Anda harus memperhatikan mengembalikan hasil dalam <code>message |&gt; json!</code> format <code>message |&gt; json!</code>  .  Metode <code>json!(str)</code> diletakkan terakhir di dalam pipa di sini.  Ini memberikan serialisasi data dalam format JSON, dan juga memastikan bahwa Genie menambahkan <code>Content-Type</code> benar.  Juga, perhatikan fakta bahwa kata <code>return</code> dalam kebanyakan kasus dalam contoh di atas berlebihan.  Julia, seperti Ruby, misalnya, selalu mengembalikan hasil operasi terakhir atau nilai dari ekspresi yang ditentukan terakhir.  Artinya, kata <code>return</code> adalah opsional. </p><br><p>  Kemampuan Genie tidak berakhir di sana, tetapi kami tidak membutuhkannya untuk mengimplementasikan layanan web. </p><br><p>  Kontrol respons untuk layanan: </p><br><pre> <code class="plaintext hljs">GET / HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET / HTTP/1.1) Hello World! GET /user/Jemand HTTP/1.1 HTTP/1.1 200 OK &lt;= (GET /user/Jemand HTTP/1.1) Hello Jemand POST /resource/process HTTP/1.1 HTTP/1.1 200 OK &lt;= (POST /resource/process HTTP/1.1) {"body":"Test document with some content.","server_mark":"confirmed","title":"Some document"}</code> </pre> <br><p>  Kesimpulan layanan ke konsol: </p><br><pre> <code class="plaintext hljs">&gt;./genie_json.jl [ Info: Ready! 2019-04-24 17:18:51:DEBUG:Main: Web Server starting at http://127.0.0.1:8080 2019-04-24 17:18:51:DEBUG:Main: Web Server running at http://127.0.0.1:8080 2019-04-24 17:19:21:INFO:Main: / 200 2019-04-24 17:19:21:INFO:Main: /user/Jemand 200 2019-04-24 17:19:22:INFO:Main: /resource/process 200</code> </pre> <br><h2 id="paket-juliawebapijl">  Paket JuliaWebAPI.jl </h2><br><p>  Paket ini diposisikan sebagai lapisan menengah untuk membuat aplikasi web pada masa itu ketika HTTP.jl hanya perpustakaan yang mengimplementasikan protokol.  Penulis paket ini juga mengimplementasikan generator kode server berdasarkan spesifikasi Swagger (OpenAPI dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://editor.swagger.io/</a> ) - lihat proyek <a href="">https://github.com/JuliaComputing/Swagger.jl</a> , dan generator ini menggunakan JuliaWebAPI .jl.  Namun, masalah dengan JuliaWebAPI.jl adalah bahwa ia tidak mengimplementasikan kemampuan untuk memproses tubuh permintaan (misalnya, JSON), dikirim ke server melalui permintaan POST.  Penulis percaya bahwa melewati parameter dalam format kunci-nilai cocok untuk semua kesempatan ... Masa depan paket ini tidak jelas.  Semua fungsinya sudah diimplementasikan dalam banyak paket lain, termasuk HTTP.jl.  Paket Swagger.jl juga tidak lagi menggunakannya. </p><br><h2 id="websocketsjl">  WebSockets.jl </h2><br><p>  Implementasi awal protokol WebSocket.  Paket ini telah digunakan sejak lama sebagai implementasi utama dari protokol ini, namun, saat ini, implementasinya termasuk dalam paket HTTP.jl.  Paket WebSockets.jl sendiri menggunakan HTTP.jl untuk membuat koneksi, namun sekarang, tidak layak menggunakannya dalam pengembangan baru.  Ini harus dianggap sebagai paket untuk kompatibilitas. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Ulasan ini menunjukkan berbagai cara untuk mengimplementasikan layanan web di Julia.  Cara termudah dan paling universal adalah dengan langsung menggunakan paket HTTP.jl.  Juga, paket Bukdu.jl dan Genie.jl sangat berguna.  Minimal, perkembangan mereka harus dipantau.  Mengenai paket Mux.jl, keuntungannya sekarang dibubarkan dengan latar belakang HTTP.jl.  Karena itu, pendapat pribadi bukan untuk menggunakannya.  Genie.jl adalah kerangka kerja yang sangat menjanjikan.  Namun, sebelum Anda mulai menggunakannya, Anda setidaknya harus memahami mengapa penulis tidak mendaftarkannya sebagai paket resmi. </p><br><p>  Perhatikan bahwa kode deserialisasi JSON dalam contoh digunakan tanpa penanganan kesalahan.  Dalam semua kasus kecuali Genie, perlu untuk menangani kesalahan penguraian dan memberi tahu pengguna tentang hal ini.  Contoh kode untuk HTTP.jl: </p><br><pre> <code class="julia hljs"> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> message = <span class="hljs-literal"><span class="hljs-literal">nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> body = <span class="hljs-built_in"><span class="hljs-built_in">IOBuffer</span></span>(HTTP.payload(req)) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> message = JSON.parse(body) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> err <span class="hljs-meta"><span class="hljs-meta">@error</span></span> err.msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HTTP.Response(<span class="hljs-number"><span class="hljs-number">400</span></span>, string(err.msg)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Secara umum, kita dapat mengatakan bahwa sudah ada cukup dana untuk membuat layanan web di Julia.  Artinya, tidak perlu "menemukan kembali roda" untuk menulisnya.  Langkah selanjutnya adalah mengevaluasi bagaimana Julia dapat menahan beban dalam tolok ukur yang ada, jika seseorang siap untuk mengambilnya.  Namun, untuk saat ini marilah kita membahas ulasan ini. </p><br><h2 id="ssylki">  Referensi </h2><br><ul><li>  <a href="">https://github.com/JuliaWeb/HTTP.jl</a> </li><li>  <a href="">https://github.com/JuliaWeb/Mux.jl</a> </li><li>  <a href="">https://github.com/wookay/Bukdu.jl</a> </li><li>  <a href="">https://github.com/essenciary/Genie.jl</a> </li><li>  <a href="">https://github.com/JuliaComputing/Swagger.jl</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449338/">https://habr.com/ru/post/id449338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449324/index.html">Banyak, smartphone, perusahaan raksasa: Program Heisenbug 2019 Piter</a></li>
<li><a href="../id449326/index.html">WebRTC dan pengawasan video: bagaimana kami mengalahkan keterlambatan video dari kamera</a></li>
<li><a href="../id449330/index.html">Modul optik WDM CFP2-ACO / CFP2-DCO yang koheren (100G / 200G) dan aplikasinya dalam sistem DWDM</a></li>
<li><a href="../id449334/index.html">Bagaimana terjemahan teknis berubah menjadi mini detektif</a></li>
<li><a href="../id449336/index.html">Perawatan HIV dari pengobatan pertama hingga saat ini</a></li>
<li><a href="../id449340/index.html">Blok oracle berdasarkan oracle acak berdasarkan tanda tangan digital</a></li>
<li><a href="../id449342/index.html">Peramalan acak berdasarkan tanda tangan digital blockchain</a></li>
<li><a href="../id449344/index.html">Kodim - pizza</a></li>
<li><a href="../id449346/index.html">MODX Digest # 4 (8 - 22 April 2019)</a></li>
<li><a href="../id449348/index.html">Buildroot - bagian 2. Membuat konfigurasi papan Anda; penerapan skrip eksternal tree, rootfs-overlay, post-build</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>