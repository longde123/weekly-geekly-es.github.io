<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≠ üÜö üèÇüèæ Patr√≥n desechable (Principio de dise√±o desechable) pt.2 ‚öïÔ∏è üè¥‚Äç‚ò†Ô∏è üë©üèø‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SafeHandle / CriticalHandle / SafeBuffer / tipos derivados 


 Siento que voy a abrir la caja de Pandora para ti. Hablemos de tipos especiales: SafeHa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Patr√≥n desechable (Principio de dise√±o desechable) pt.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443960/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="safehandle--criticalhandle--safebuffer--derived-types">  SafeHandle / CriticalHandle / SafeBuffer / tipos derivados </h2><br><p>  Siento que voy a abrir la caja de Pandora para ti.  Hablemos de tipos especiales: SafeHandle, CriticalHandle y sus tipos derivados. </p><br><p>  Esto es lo √∫ltimo sobre el patr√≥n de un tipo que da acceso a un recurso no administrado.  Pero primero, enumeremos todo lo que <em>usualmente</em> obtenemos del mundo no administrado: </p><br><p>  Lo primero y obvio son las manijas.  Esta puede ser una palabra sin sentido para un desarrollador de .NET, pero es un componente muy importante del mundo del sistema operativo.  Un identificador es un n√∫mero de 32 o 64 bits por naturaleza.  Designa una sesi√≥n abierta de interacci√≥n con un sistema operativo.  Por ejemplo, cuando abre un archivo, obtiene un identificador de la funci√≥n WinApi.  Luego puede trabajar con √©l y realizar operaciones de <em>B√∫squeda</em> , <em>Lectura</em> o <em>Escritura</em> .  O puede abrir un socket para acceder a la red.  Una vez m√°s, un sistema operativo le pasar√° un control.  En .NET, los identificadores se almacenan como tipo <em>IntPtr</em> ; </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><ul><li>  Lo segundo son las matrices de datos.  Puede trabajar con matrices no administradas a trav√©s de un c√≥digo inseguro (inseguro es una palabra clave aqu√≠) o usar SafeBuffer que envolver√° un b√∫fer de datos en una clase adecuada de .NET.  Tenga en cuenta que la primera forma es m√°s r√°pida (por ejemplo, puede optimizar los bucles en gran medida), pero la segunda es mucho m√°s segura, ya que se basa en SafeHandle; </li><li>  Luego ve a las cuerdas.  Las cadenas son simples ya que necesitamos determinar el formato y la codificaci√≥n de la cadena que capturamos.  Luego se copia para nosotros (una cadena es una clase inmutable) y ya no nos preocupamos por eso. </li><li>  Lo √∫ltimo son los ValueTypes que se acaban de copiar, por lo que no necesitamos pensar en ellos en absoluto. </li></ul><br><p>  SafeHandle es una clase especial de .NET CLR que hereda CriticalFinalizerObject y debe envolver los controladores de un sistema operativo de la manera m√°s segura y c√≥moda. </p><br><pre><code class="plaintext hljs">[SecurityCritical, SecurityPermission(SecurityAction.InheritanceDemand, UnmanagedCode=true)] public abstract class SafeHandle : CriticalFinalizerObject, IDisposable { protected IntPtr handle; // The handle from OS private int _state; // State (validity, the reference counter) private bool _ownsHandle; // The flag for the possibility to release the handle. // It may happen that we wrap somebody else's handle // have no right to release. private bool _fullyInitialized; // The initialized instance [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle) { } // The finalizer calls Dispose(false) with a pattern [SecuritySafeCritical] ~SafeHandle() { Dispose(false); } // You can set a handle manually or automatically with p/invoke Marshal [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected void SetHandle(IntPtr handle) { this.handle = handle; } // This method is necessary to work with IntPtr directly. It is used to // determine if a handle was created by comparing it with one of the previously // determined known values. Pay attention that this method is dangerous because: // // ‚Äì if a handle is marked as invalid by SetHandleasInvalid, DangerousGetHandle // it will anyway return the original value of the handle. // ‚Äì you can reuse the returned handle at any place. This can at least // mean, that it will stop work without a feedback. In the worst case if // IntPtr is passed directly to another place, it can go to an unsafe code and become // a vector for application attack by resource substitution in one IntPtr [ResourceExposure(ResourceScope.None), ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public IntPtr DangerousGetHandle() { return handle; } // The resource is closed (no more available for work) public bool IsClosed { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get { return (_state &amp; 1) == 1; } } // The resource is not available for work. You can override the property by changing the logic. public abstract bool IsInvalid { [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] get; } // Closing the resource through Close() pattern [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Close() { Dispose(true); } // Closing the resource through Dispose() pattern [SecuritySafeCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] public void Dispose() { Dispose(true); } [SecurityCritical, ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected virtual void Dispose(bool disposing) { // ... } // You should call this method every time when you understand that a handle is not operational anymore. // If you don't do it, you can get a leak. [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void SetHandleAsInvalid(); // Override this method to point how to release // the resource. You should code carefully, as you cannot // call uncompiled methods, create new objects or produce exceptions from it. // A returned value shows if the resource was releases successfully. // If a returned value = false, SafeHandleCriticalFailure will occur // that will enter a breakpoint if SafeHandleCriticalFailure // Managed Debugger Assistant is activated. [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)] protected abstract bool ReleaseHandle(); // Working with the reference counter. To be explained further. [SecurityCritical, ResourceExposure(ResourceScope.None)] [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)] [MethodImplAttribute(MethodImplOptions.InternalCall)] public extern void DangerousAddRef(ref bool success); public extern void DangerousRelease(); }</code> </pre> <br><p>  Para comprender la utilidad de las clases derivadas de SafeHandle, debe recordar por qu√© los tipos .NET son tan geniales: GC puede recopilar sus instancias autom√°ticamente.  A medida que SafeHandle se administra, el recurso no administrado que envuelve hereda todas las caracter√≠sticas del mundo administrado.  Tambi√©n contiene un contador interno de referencias externas que no est√°n disponibles para CLR.  Me refiero a referencias de c√≥digo inseguro.  No es necesario que incremente o disminuya un contador manualmente.  Cuando declara un tipo derivado de SafeHandle como par√°metro de un m√©todo inseguro, el contador aumenta al ingresar ese m√©todo o disminuye despu√©s de salir.  La raz√≥n es que cuando va a un c√≥digo inseguro al pasar un identificador all√≠, puede obtener este SafeHandle recopilado por GC, restableciendo la referencia a este identificador en otro subproceso (si trata con un identificador de varios subprocesos).  Las cosas funcionan a√∫n m√°s f√°cilmente con un contador de referencia: SafeHandle no se crear√° hasta que el contador se ponga a cero.  Es por eso que no necesita cambiar el contador manualmente.  O bien, debe hacerlo con mucho cuidado devolvi√©ndolo cuando sea posible. </p><br><p>  El segundo prop√≥sito de un contador de referencia es establecer el orden de finalizaci√≥n de <code>CriticalFinalizerObject</code> que se refieren entre s√≠.  Si un tipo basado en SafeHandle hace referencia a otro, entonces necesita incrementar adicionalmente un contador de referencia en el constructor del tipo de referencia y disminuir el contador en el m√©todo ReleaseHandle.  Por lo tanto, su objeto existir√° hasta que el objeto al que hace referencia su objeto no se destruya.  Sin embargo, es mejor evitar tales perplejidades.  Usemos el conocimiento sobre SafeHandlers y escriba la variante final de nuestra clase: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { SafeFileHandle _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; _handle.Dispose(); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern SafeFileHandle CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); /// other methods }</code> </pre> <br><p>  Como es diferente  Si configura <strong>cualquier</strong> tipo basado en SafeHandle (incluido el suyo) como el valor de retorno en el m√©todo DllImport, Marshal crear√° e inicializar√° correctamente este tipo y establecer√° un contador en 1. Sabiendo esto, configuraremos el tipo SafeFileHandle como un tipo de retorno para la funci√≥n del kernel CreateFile.  Cuando lo obtengamos, lo usaremos exactamente para llamar a ReadFile y WriteFile (a medida que el valor del contador aumente al llamar y disminuya al salir, se asegurar√° de que el identificador siga existiendo durante la lectura y la escritura en un archivo).  Este es un tipo correctamente dise√±ado y cerrar√° de manera confiable un identificador de archivo si se aborta un hilo.  Esto significa que no necesitamos implementar nuestro propio finalizador y todo lo relacionado con √©l.  Todo el tipo est√° simplificado. </p><br><h3 id="the-execution-of-a-finalizer-when-instance-methods-work">  La ejecuci√≥n de un finalizador cuando los m√©todos de instancia funcionan </h3><br><p>  Hay una t√©cnica de optimizaci√≥n utilizada durante la recolecci√≥n de basura que est√° dise√±ada para recolectar m√°s objetos en menos tiempo.  Veamos el siguiente c√≥digo: </p><br><pre> <code class="plaintext hljs">public void SampleMethod() { var obj = new object(); obj.ToString(); // ... // If GC runs at this point, it may collect obj // as it is not used anymore // ... Console.ReadLine(); }</code> </pre> <br><p>  Por un lado, el c√≥digo parece seguro, y no est√° claro de inmediato por qu√© deber√≠a importarnos.  Sin embargo, si recuerda que hay clases que envuelven recursos no administrados, comprender√° que una clase dise√±ada incorrectamente puede causar una excepci√≥n del mundo no administrado.  Esta excepci√≥n informar√° que un identificador obtenido previamente no est√° activo: </p><br><pre> <code class="plaintext hljs">// The example of an absolutely incorrect implementation void Main() { var inst = new SampleClass(); inst.ReadData(); // inst is not used further } public sealed class SampleClass : CriticalFinalizerObject, IDisposable { private IntPtr _handle; public SampleClass() { _handle = CreateFile("test.txt", 0, 0, IntPtr.Zero, 0, 0, IntPtr.Zero); } public void Dispose() { if (_handle != IntPtr.Zero) { CloseHandle(_handle); _handle = IntPtr.Zero; } } ~SampleClass() { Console.WriteLine("Finalizing instance."); Dispose(); } public unsafe void ReadData() { Console.WriteLine("Calling GC.Collect..."); // I redirected it to the local variable not to // use this after GC.Collect(); var handle = _handle; // The imitation of full GC.Collect GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); Console.WriteLine("Finished doing something."); var overlapped = new NativeOverlapped(); // it is not important what we do ReadFileEx(handle, new byte[] { }, 0, ref overlapped, (a, b, c) =&gt; {;}); } [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto, BestFitMapping = false)] static extern IntPtr CreateFile(String lpFileName, int dwDesiredAccess, int dwShareMode, IntPtr securityAttrs, int dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError = true)] static extern bool ReadFileEx(IntPtr hFile, [Out] byte[] lpBuffer, uint nNumberOfBytesToRead, [In] ref NativeOverlapped lpOverlapped, IOCompletionCallback lpCompletionRoutine); [DllImport("kernel32.dll", SetLastError = true)] static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Admita que este c√≥digo parece decente m√°s o menos.  De todos modos, no parece que haya un problema.  De hecho, hay un problema grave.  Un finalizador de clase puede intentar cerrar un archivo mientras lo lee, lo que casi inevitablemente conduce a un error.  Como en este caso el error se devuelve expl√≠citamente ( <code>IntPtr == -1</code> ) no lo veremos.  El <code>_handle</code> se establecer√° en cero, el siguiente <code>Dispose</code> no podr√° cerrar el archivo y el recurso se perder√°.  Para resolver este problema, debe usar <code>SafeHandle</code> , <code>CriticalHandle</code> , <code>SafeBuffer</code> y sus clases derivadas.  Adem√°s de que estas clases tienen contadores de uso en c√≥digo no administrado, estos contadores tambi√©n se incrementan autom√°ticamente al pasar los par√°metros de los m√©todos al mundo no administrado y disminuyen al abandonarlo. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este traductor traducido del ruso como del idioma del autor por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos a crear una versi√≥n traducida de este texto a cualquier otro idioma, incluido el chino o el alem√°n, utilizando las versiones de texto en ruso e ingl√©s como fuente. <br><br>  Adem√°s, si quiere decir "gracias", la mejor manera de elegir es d√°ndonos una estrella en github o bifurcando repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443960/">https://habr.com/ru/post/443960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443950/index.html">Conf√≠e, aconseje, sugiera: busque revisiones de software reales</a></li>
<li><a href="../443952/index.html">Internet soberano - por nuestro dinero</a></li>
<li><a href="../443954/index.html">Singularidad tecnol√≥gica: el mito moderno del fin del mundo bajo el pretexto de la hip√≥tesis del progreso</a></li>
<li><a href="../443956/index.html">Red social en 2019: Yandex lanz√≥ Aura</a></li>
<li><a href="../443958/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.1</a></li>
<li><a href="../443962/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.3</a></li>
<li><a href="../443964/index.html">Kolesa Conf es la mayor conferencia de TI en Kazajst√°n. Anuncio de informes</a></li>
<li><a href="../443966/index.html">Google Docs: un chat favorito entre los estudiantes</a></li>
<li><a href="../443968/index.html">C√≥mo compramos una casa con paneles solares, y qu√© sali√≥ de ella</a></li>
<li><a href="../443972/index.html">Yandex buscar√° piratas usando un robot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>