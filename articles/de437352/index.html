<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪 ⛄️ 👘 Quantencomputer in Spielen oder ernsthaft verrückt werden 👨🏽‍🚒 🚨 🛕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie unter den Verrückten leben, müssen Sie lernen, selbst verrückt zu sein 

 Haben Sie jemals versucht, "lernen, verrückt zu sein"? Nicht trivia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quantencomputer in Spielen oder ernsthaft verrückt werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437352/">  <i>Wenn Sie unter den Verrückten leben, müssen Sie lernen, selbst verrückt zu sein</i> <br><br>  Haben Sie jemals versucht, "lernen, verrückt zu sein"?  Nicht triviale Aufgabe.  Sie werden nicht einmal eine normale Technik finden, weil jeder auf seine Weise verrückt wird.  Mein erster Versuch: Verschwörungstheorie.  Die Theorie beinhaltet keine Praxis, was bedeutet, dass Sie nicht hart arbeiten müssen.  Auch in jeder Situation wird niemand leiden. <br><br><div class="spoiler">  <b class="spoiler_title">Wie erstelle ich Verschwörungstheorien?</b> <div class="spoiler_text">  Die Erstellung einer Verschwörungstheorie ist relativ einfach.  Wir brauchen eine Idee, die einfach genug ist, um von 90% der Bevölkerung akzeptiert zu werden.  Es sollte kontrovers sein, damit 5% der Bevölkerung 90% erklären können, was für Idioten sie sind.  Schließlich brauchen wir einige Untersuchungen, die diese 95% der Menschen nicht verstehen, die aber von 90% als Argument verwendet werden: "Die Menschen haben sich als schlauer erwiesen als wir ...". <br><br>  Quantum Computing ist ein großartiger Bereich für eine solche Studie.  Sie können ein einfaches Schema zusammenstellen, aber das Wort "Quantum" erhöht das Gewicht der Ergebnisse. <br><br>  Das Objekt des Studiums ist ein Spiel, denn das Objekt ist auf die einfache und vertraute Jugend zurückzuführen.  Wer ist an Quantencomputern und Spielen beteiligt?  Google <br></div></div><br>  Also, ketzerische Theorie: Nach 5 Jahren werden Page und Green entscheiden, wer die Hauptsache in Google sein wird, und dies mit Hilfe des Spiels tun.  Jeder von ihnen hat eine Gruppe von Forschern.  Das AlphaGo-Team mit seinen <s>kämpfenden</s> neuronalen Netzen zog Rivalen in Go an.  Die Gegner waren gezwungen, nach neuen Methoden zu suchen, und fanden dennoch ein Instrument der <s>völligen</s> Überlegenheit: das Quantencomputing. <br><br>  Kann ich Quantum Computing für Spiele verwenden?  Einfach.  Lassen Sie uns zum Beispiel zeigen, dass das Spiel "Fuchsjäger" in 6 Zügen "gelöst" werden kann.  Aus Gründen der Glaubwürdigkeit beschränken wir uns auf 15 Qubits (die Online-Editor-Eigenart emuliert nicht länger als fünfzehn). Der Einfachheit halber werden wir die Einschränkungen der Prozessorarchitektur und der Fehlerkorrektur ignorieren. <br><a name="habracut"></a><br><h3>  Die Regeln </h3><br>  Sehr einfach.  <i>Es gibt fünf Löcher in einer Reihe (wir nummerieren sie als 0-1-2-3-4).</i>  <i>In einem von ihnen ist ein Fuchs.</i>  <i>Jede Nacht bewegt sich der Fuchs zum nächsten Nerz links oder rechts.</i>  <i>Jeden Morgen kann der Jäger ein Loch zur Auswahl prüfen.</i>  <i>Die Aufgabe des Jägers ist es, den Fuchs zu fangen.</i>  <i>Die Aufgabe des Fuchses ist es zu überleben.</i>  Theoretisch kann ein Fuchs für immer vor einem Jäger fliehen.  In der Praxis gibt es eine Gewinnstrategie: Überprüfen Sie die Löcher 1-2-3-1-2-3.  Nur diese Strategie werde ich testen. <br><br><h3>  Ein Schema aufbauen </h3><br>  Beginnen wir mit der Initiierung der Qubits 0-1-2-3-4 (5 Löcher).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier können Sie bearbeiten</a> <br><img src="https://habrastorage.org/webt/jc/o3/-g/jco3-geebiz5bpjtpur3gvcctxm.png"><br><br>  Tatsächlich haben wir nach der Initiierung ein System, in dem nach der Messung streng ein Qubit einzeln ist.  Die Wahrscheinlichkeiten der "Einheit" unterscheiden sich für jedes Qubit, aber in unserem Fall ist dies nicht kritisch.  Wir müssen Raum für Diskussionen über das Schema (und gleichzeitig unsere Theorie) lassen. <br><br>  Auf Q # erhalten wir Code wie folgt: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); ResetAll(qubits); // ALWAYS clean after yourself } return Zero; } // Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[3]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } }</span></span></code> </pre> <br>  TestStrategy testet unsere Strategie 1-2-3-1-2-3. InitFoxHoles () ist nur für die Initiierung von Fuchslöchern verantwortlich.  Lassen Sie uns die Initiation überprüfen.  Kopieren Sie TestStrategy, starten Sie die Initiierung, messen Sie die ersten 5 Qubits und geben Sie ihre Werte zurück. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4); } }</span></span></code> </pre> <br>  Wir werden den Test tausendmal durchführen (mehrere Läufe sind typisch für Quantenalgorithmen, an einigen Stellen sogar notwendig).  Rufcode - unter dem Spoiler, Ergebnisse: auf dem Bildschirm unten. <br><br><div class="spoiler">  <b class="spoiler_title">Testen Sie die Initiierung schnell</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInitiation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initedQubitsValues = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .ToDictionary(qubitIndex =&gt; qubitIndex, oneMesaured =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result) result = TestInit.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">2</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">3</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">4</span></span>]++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-0 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-1 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-2 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-3 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-4 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">4</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/fb/oa/bs/fboabsw9fsu64gh7bl9a8mofh_y.png"><br><br>  Etwas ist schief gelaufen.  Eine nahezu gleichmäßige Verteilung wurde erwartet.  Der Grund ist einfach: In Schritt 3 habe ich das dritte Qubit anstelle des ersten invertiert: (Controlled (X)) ([Register [0], Register [2]], Register [3]);  <s>nicht</s> gute alte Copy-Paste. <br><br>  Wir korrigieren den Code und führen den Test durch: <br><br><div class="spoiler">  <b class="spoiler_title">Initiierung korrigiert</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[1]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } } }</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/06/q2/7b/06q27bfcca3-udvpnaarut9zmhi.png"><br><br>  Schon besser.  Der Code ist in der Rübe, Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 1, zu sehen</a> . <br><br><h3>  Wo soll der Fuchs laufen? </h3><br>  Wählen Sie das fünfte Qubit (die Nummerierung beginnt von oben) unter der aktuellen Richtung des Fuchses.  Wir sind uns einig, dass Null eine Abwärtsbewegung bedeutet, eine Einheit eine Aufwärtsbewegung.  Wenn sich der Fuchs bereits im Nullloch befindet, sollte er sich natürlich nach unten bewegen.  Befindet sich der Fuchs im vierten Loch, bewegt er sich nach oben.  In anderen Fällen kann sich der Fuchs auf und ab bewegen.  Nach diesen einfachen Regeln können wir das „Qubit der aktuellen Richtung“ auf 0, 1 oder eine Überlagerung von Null und Eins setzen.  Wir sehen uns den Code im Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 2 an</a> . <br><br><img src="https://habrastorage.org/webt/dr/tg/zd/drtgzd1c2y9jyb0n7zwrxp5qg2c.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema im Editor.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Code und Test</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Select next Fox movement direction, updating qubit 5 // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation SetupMovementDirection(qubits: Qubit[]) : Unit { body { // Step 1 CNOT(qubits[4], qubits[5]); // Step 2 (Controlled (H))([qubits[3]], qubits[5]); // Step 3 (Controlled (H))([qubits[2]], qubits[5]); // Step 4 (Controlled (H))([qubits[1]], qubits[5]); } } operation TestMovementDirectionSetup(): (Result, Result, Result, Result, Result, Result) { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; using(qubits=Qubit[16]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); set res5 = M(qubits[5]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovementDirectionSetup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestMovementDirectionSetup.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results .GroupBy(result =&gt; result) .OrderBy(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>.Key)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Key}</span></span></span><span class="hljs-string"> was measured </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Count()}</span></span></span><span class="hljs-string"> times"</span></span>); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal measures: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{results.Count()}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre><br><br><img src="https://habrastorage.org/webt/1a/oa/vm/1aoavmvs9hscf8gywpbgfpbdpiq.png"><br></div></div><br><br><h3>  Bewegung </h3>  Implementiert von kontrolliertem SWAP.  Wenn das steuernde Qubit einfach ist, tauschen Sie es aus.  Wenn das steuernde Qubit Null ist, tauschen wir auf. <br><br><img src="https://habrastorage.org/webt/zs/n8/os/zsn8osjcozts2nip6lbunqjcg_w.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema im Editor</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q # Operator</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Makes a movement based on the 5'th qubit value // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation MakeMovement(qubits: Qubit[]) : Unit { body { // Code movement Up // Step 1 mutable qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 2 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 3 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 4 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // COde movement down X(qubits[5]); // Invert direction qubit for the ZeroControlled operations // Step 5 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 6 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 7 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 8 set qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); X(qubits[5]); // Back-invert for the direction qubit } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: Anweisung für Tests</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); MakeMovement(qubits); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res0 = M(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res1 = M(qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res2 = M(qubits[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res3 = M(qubits[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res4 = M(qubits[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res5 = M(qubits[<span class="hljs-number"><span class="hljs-number">5</span></span>]); ResetAll(qubits); <span class="hljs-comment"><span class="hljs-comment">// ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C # -Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestFirstMovement.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Holes measurements foreach (var group in results .GroupBy(result =&gt; result[0]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} hole was measured {group.Count()} times"); } // Directions measuremetns foreach (var group in results .GroupBy(result =&gt; result[1]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} direction was measured {group.Count()} times"); } Console.WriteLine($"\r\nTotal measures: {results.Count()}"); } }</span></span></code> </pre> <br></div></div><br>  Der Code kann in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 3</a> angezeigt werden. <br><br><h3>  Wir machen 6 Züge </h3><br>  Schließlich wählen wir das sechste Qubit für den Status des Spiels (der Fuchs ist frei / der Fuchs ist nicht frei).  Die Einheit entspricht einem freien Fuchs.  Wir werden weitere Schritte nur mit einem einzigen Status-Qubit machen. <br><br>  Die Qubits 7,8,9,10,11 werden eine Bewegungsgeschichte führen.  Nach jedem Zug tauschen wir einen von ihnen gegen ein Qubit der aktuellen Richtung aus (dies ermöglicht es uns, den Verlauf der Züge zu speichern und das Qubit der aktuellen Richtung vor jedem Zug zurückzusetzen). <br><img src="https://habrastorage.org/webt/a0/1t/_t/a01t_t8jo_9nt9w1nimamxrd-i0.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema beigefügt</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q # Operator</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Make 6 movements. Every movement is controlled by the 6'th qubit. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> After the every qubit we check if the fox has been captured and invert the 6'th qubit </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Reminder: 6'th qubit equal to One means "Fox is free, go further" operation MakeSixMovements(qubits: Qubit[]) : Unit { body { // Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: Anweisung für Tests</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { ResetAll(qubits); InitFoxHoles(qubits); X(qubits[<span class="hljs-number"><span class="hljs-number">6</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// At the beginning of the game our fox is alive MakeSixMovements(qubits); set res = M(qubits[6]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: Testen</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zerosCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { Result result = Quantum.FoxHunter.TestSixMovements.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result == Result.Zero) { zerosCount++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal zeroes: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{zerosCount}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br>  Wir sehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 4</a> . <br><br><h3>  Feinschliff </h3><br>  Wir haben einen Fehler in der Schaltung.  Da wir die Strategie 1-2-3-1-2-3 testen, überprüfen wir jedes Loch zweimal.  Nachdem wir den Fuchs im ersten Zug gefangen haben, werden wir das Status-Qubit zweimal durchlaufen (im ersten und vierten Zug). <br><br>  Um diese Situation zu vermeiden, verwenden wir 12 Qubits, um den Status nach den Zügen 4-5-6 zu korrigieren.  Zusätzlich fügen wir die Definition des Sieges hinzu: Wenn mindestens eines der Status-Qubits auf Null geht, haben wir gewonnen. <br><img src="https://habrastorage.org/webt/cs/pc/ug/cspcugcnyqdranjm_lifypt2evc.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das endgültige Schema</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q #: Korrigieren Sie den 6-Zug-Operator</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">qubits: Qubit[]</span></span></span><span class="hljs-function">) : Unit</span></span> { body { <span class="hljs-comment"><span class="hljs-comment">// Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[1], qubits[12]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[2], qubits[12]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[3], qubits[12]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">F #: Festlegen der Operator-Teststrategie 1-2-3-1-2-3</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history // 12 - another qubit of the fox live. 1 means "fox is still free, go further" // 13 Result qubit. If it's zero, the fox is alive body { mutable res = Zero; using(qubits=Qubit[14]) { ResetAll(qubits); // Init fox positions and the fox' live InitFoxHoles(qubits); X(qubits[6]); // At the beginning of the game our fox is alive X(qubits[12]); // The second qubit of the fox live. If it's one - the fox is alive. // Make moves MakeSixMovements(qubits); // Measure results. If the 13'th qubit is zero the fox is alive X(qubits[6]); X(qubits[12]); CNOT(qubits[6], qubits[13]); CNOT(qubits[12], qubits[13]); CCNOT(qubits[6], qubits[12], qubits[13]); set res = M(qubits[13]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: Endprüfung durchführen</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunFoxHunt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foxSurvives = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hunterWins = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = (Result)(TestStrategy.Run(sim).Result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == Result.Zero) { foxSurvives++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hunterWins++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Fox survives: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{foxSurvives}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Hunter wins: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{hunterWins}</span></span></span><span class="hljs-string">"</span></span>); } sw.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Experiment finished. "</span></span> + <span class="hljs-string"><span class="hljs-string">$"Time spent: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1000</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> seconds"</span></span>); }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/qm/pr/a3/qmpra3x-ticzuunfcmlsl_8atnk.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Festschreiben 5</a> . <br><br><h3>  Was folgt daraus </h3><br>  Grundsätzlich kann das Schema sowohl in der Anzahl der Qubits als auch in der Anzahl der Operationen optimiert werden.  Die triviale Optimierung für die Anzahl der Qubits besteht darin, Qubit-13 zu entfernen und nur 6 und 12 zurückzugeben. Optimierung für Operationen - um den ersten Schuss unmittelbar nach der Initiierung zu machen.  Überlassen wir diese Arbeit jedoch den Google-Ingenieuren. <br><br>  Wie Sie sehen, kann jeder, der oberflächlich mit Quantencomputern vertraut ist, sicher den "Fuchsjäger" spielen.  Wenn wir etwas mehr Qubits hätten, könnten wir die optimale Lösung finden und nicht die vorhandene überprüfen.  Es ist durchaus möglich, dass Tic-Tac-Toe (und ihre Quantenversion), Dame, Schach, Go als nächstes fallen. <br><br>  Gleichzeitig bleibt das Thema "Lösbarkeit" von Spielen wie DotA, Starcraft und Doom offen.  Für das Quantencomputing ist die Speicherung der gesamten Klickhistorie charakteristisch.  Wir nehmen einen APM (Actions Per Minute) von 500, multiplizieren mit der Anzahl der Spieler, multiplizieren mit der Anzahl der Minuten, addieren die Zufälligkeit des Spiels selbst - die Anzahl der Qubits, die zum Speichern aller Informationen erforderlich sind, wächst zu schnell. <br><br>  Die Auswahl eines Spiels in einem kleinen Wettbewerb zwischen Brin und Page kann also eine entscheidende Rolle spielen.  Die Entwicklung eines „ebenso schwierigen“ Spiels für klassische Computer und Quantencomputer verdient jedoch eine eigene Theorie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437352/">https://habr.com/ru/post/de437352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437342/index.html">So wählen Sie eine Plattform für die Videoüberwachung: Cloud vs. DVR / NVR / VMS</a></li>
<li><a href="../de437344/index.html">Anwendungsfälle für Netzwerksichtbarkeitslösungen</a></li>
<li><a href="../de437346/index.html">Ein Spiel (nicht) für Narren. Wir schreiben AI für "The Fool" (Teil 1)</a></li>
<li><a href="../de437348/index.html">Steigern Sie die Produktivität auf GitHub: Tipps für Anfänger und mehr</a></li>
<li><a href="../de437350/index.html">Ein Auto im Zeitalter der Multifunktionalität. Welche Conversions sind möglich?</a></li>
<li><a href="../de437354/index.html">Schwächen Sie die Nüsse, Teil 2: die Abstimmungsperiode für Veröffentlichungen und andere Änderungen</a></li>
<li><a href="../de437356/index.html">Was ist mit der SSD im Jahr 2018 passiert?</a></li>
<li><a href="../de437358/index.html">Produktkompatibilitätsmanagement</a></li>
<li><a href="../de437360/index.html">Herunterladen von Controllern ohne Verwendung einer Arduino IDE-Konsole</a></li>
<li><a href="../de437364/index.html">Die Kontrolle über Tele2 kostet Rostelecom 240 Milliarden Rubel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>