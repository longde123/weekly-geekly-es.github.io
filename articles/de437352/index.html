<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™ ‚õÑÔ∏è üëò Quantencomputer in Spielen oder ernsthaft verr√ºckt werden üë®üèΩ‚Äçüöí üö® üõï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie unter den Verr√ºckten leben, m√ºssen Sie lernen, selbst verr√ºckt zu sein 

 Haben Sie jemals versucht, "lernen, verr√ºckt zu sein"? Nicht trivia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quantencomputer in Spielen oder ernsthaft verr√ºckt werden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437352/">  <i>Wenn Sie unter den Verr√ºckten leben, m√ºssen Sie lernen, selbst verr√ºckt zu sein</i> <br><br>  Haben Sie jemals versucht, "lernen, verr√ºckt zu sein"?  Nicht triviale Aufgabe.  Sie werden nicht einmal eine normale Technik finden, weil jeder auf seine Weise verr√ºckt wird.  Mein erster Versuch: Verschw√∂rungstheorie.  Die Theorie beinhaltet keine Praxis, was bedeutet, dass Sie nicht hart arbeiten m√ºssen.  Auch in jeder Situation wird niemand leiden. <br><br><div class="spoiler">  <b class="spoiler_title">Wie erstelle ich Verschw√∂rungstheorien?</b> <div class="spoiler_text">  Die Erstellung einer Verschw√∂rungstheorie ist relativ einfach.  Wir brauchen eine Idee, die einfach genug ist, um von 90% der Bev√∂lkerung akzeptiert zu werden.  Es sollte kontrovers sein, damit 5% der Bev√∂lkerung 90% erkl√§ren k√∂nnen, was f√ºr Idioten sie sind.  Schlie√ülich brauchen wir einige Untersuchungen, die diese 95% der Menschen nicht verstehen, die aber von 90% als Argument verwendet werden: "Die Menschen haben sich als schlauer erwiesen als wir ...". <br><br>  Quantum Computing ist ein gro√üartiger Bereich f√ºr eine solche Studie.  Sie k√∂nnen ein einfaches Schema zusammenstellen, aber das Wort "Quantum" erh√∂ht das Gewicht der Ergebnisse. <br><br>  Das Objekt des Studiums ist ein Spiel, denn das Objekt ist auf die einfache und vertraute Jugend zur√ºckzuf√ºhren.  Wer ist an Quantencomputern und Spielen beteiligt?  Google <br></div></div><br>  Also, ketzerische Theorie: Nach 5 Jahren werden Page und Green entscheiden, wer die Hauptsache in Google sein wird, und dies mit Hilfe des Spiels tun.  Jeder von ihnen hat eine Gruppe von Forschern.  Das AlphaGo-Team mit seinen <s>k√§mpfenden</s> neuronalen Netzen zog Rivalen in Go an.  Die Gegner waren gezwungen, nach neuen Methoden zu suchen, und fanden dennoch ein Instrument der <s>v√∂lligen</s> √úberlegenheit: das Quantencomputing. <br><br>  Kann ich Quantum Computing f√ºr Spiele verwenden?  Einfach.  Lassen Sie uns zum Beispiel zeigen, dass das Spiel "Fuchsj√§ger" in 6 Z√ºgen "gel√∂st" werden kann.  Aus Gr√ºnden der Glaubw√ºrdigkeit beschr√§nken wir uns auf 15 Qubits (die Online-Editor-Eigenart emuliert nicht l√§nger als f√ºnfzehn). Der Einfachheit halber werden wir die Einschr√§nkungen der Prozessorarchitektur und der Fehlerkorrektur ignorieren. <br><a name="habracut"></a><br><h3>  Die Regeln </h3><br>  Sehr einfach.  <i>Es gibt f√ºnf L√∂cher in einer Reihe (wir nummerieren sie als 0-1-2-3-4).</i>  <i>In einem von ihnen ist ein Fuchs.</i>  <i>Jede Nacht bewegt sich der Fuchs zum n√§chsten Nerz links oder rechts.</i>  <i>Jeden Morgen kann der J√§ger ein Loch zur Auswahl pr√ºfen.</i>  <i>Die Aufgabe des J√§gers ist es, den Fuchs zu fangen.</i>  <i>Die Aufgabe des Fuchses ist es zu √ºberleben.</i>  Theoretisch kann ein Fuchs f√ºr immer vor einem J√§ger fliehen.  In der Praxis gibt es eine Gewinnstrategie: √úberpr√ºfen Sie die L√∂cher 1-2-3-1-2-3.  Nur diese Strategie werde ich testen. <br><br><h3>  Ein Schema aufbauen </h3><br>  Beginnen wir mit der Initiierung der Qubits 0-1-2-3-4 (5 L√∂cher).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier k√∂nnen Sie bearbeiten</a> <br><img src="https://habrastorage.org/webt/jc/o3/-g/jco3-geebiz5bpjtpur3gvcctxm.png"><br><br>  Tats√§chlich haben wir nach der Initiierung ein System, in dem nach der Messung streng ein Qubit einzeln ist.  Die Wahrscheinlichkeiten der "Einheit" unterscheiden sich f√ºr jedes Qubit, aber in unserem Fall ist dies nicht kritisch.  Wir m√ºssen Raum f√ºr Diskussionen √ºber das Schema (und gleichzeitig unsere Theorie) lassen. <br><br>  Auf Q # erhalten wir Code wie folgt: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); ResetAll(qubits); // ALWAYS clean after yourself } return Zero; } // Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[3]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } }</span></span></code> </pre> <br>  TestStrategy testet unsere Strategie 1-2-3-1-2-3. InitFoxHoles () ist nur f√ºr die Initiierung von Fuchsl√∂chern verantwortlich.  Lassen Sie uns die Initiation √ºberpr√ºfen.  Kopieren Sie TestStrategy, starten Sie die Initiierung, messen Sie die ersten 5 Qubits und geben Sie ihre Werte zur√ºck. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4); } }</span></span></code> </pre> <br>  Wir werden den Test tausendmal durchf√ºhren (mehrere L√§ufe sind typisch f√ºr Quantenalgorithmen, an einigen Stellen sogar notwendig).  Rufcode - unter dem Spoiler, Ergebnisse: auf dem Bildschirm unten. <br><br><div class="spoiler">  <b class="spoiler_title">Testen Sie die Initiierung schnell</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInitiation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initedQubitsValues = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .ToDictionary(qubitIndex =&gt; qubitIndex, oneMesaured =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result) result = TestInit.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">2</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">3</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">4</span></span>]++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-0 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-1 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-2 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-3 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-4 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">4</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/fb/oa/bs/fboabsw9fsu64gh7bl9a8mofh_y.png"><br><br>  Etwas ist schief gelaufen.  Eine nahezu gleichm√§√üige Verteilung wurde erwartet.  Der Grund ist einfach: In Schritt 3 habe ich das dritte Qubit anstelle des ersten invertiert: (Controlled (X)) ([Register [0], Register [2]], Register [3]);  <s>nicht</s> gute alte Copy-Paste. <br><br>  Wir korrigieren den Code und f√ºhren den Test durch: <br><br><div class="spoiler">  <b class="spoiler_title">Initiierung korrigiert</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[1]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } } }</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/06/q2/7b/06q27bfcca3-udvpnaarut9zmhi.png"><br><br>  Schon besser.  Der Code ist in der R√ºbe, Version <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 1, zu sehen</a> . <br><br><h3>  Wo soll der Fuchs laufen? </h3><br>  W√§hlen Sie das f√ºnfte Qubit (die Nummerierung beginnt von oben) unter der aktuellen Richtung des Fuchses.  Wir sind uns einig, dass Null eine Abw√§rtsbewegung bedeutet, eine Einheit eine Aufw√§rtsbewegung.  Wenn sich der Fuchs bereits im Nullloch befindet, sollte er sich nat√ºrlich nach unten bewegen.  Befindet sich der Fuchs im vierten Loch, bewegt er sich nach oben.  In anderen F√§llen kann sich der Fuchs auf und ab bewegen.  Nach diesen einfachen Regeln k√∂nnen wir das ‚ÄûQubit der aktuellen Richtung‚Äú auf 0, 1 oder eine √úberlagerung von Null und Eins setzen.  Wir sehen uns den Code im Repository <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 2 an</a> . <br><br><img src="https://habrastorage.org/webt/dr/tg/zd/drtgzd1c2y9jyb0n7zwrxp5qg2c.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema im Editor.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Code und Test</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Select next Fox movement direction, updating qubit 5 // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation SetupMovementDirection(qubits: Qubit[]) : Unit { body { // Step 1 CNOT(qubits[4], qubits[5]); // Step 2 (Controlled (H))([qubits[3]], qubits[5]); // Step 3 (Controlled (H))([qubits[2]], qubits[5]); // Step 4 (Controlled (H))([qubits[1]], qubits[5]); } } operation TestMovementDirectionSetup(): (Result, Result, Result, Result, Result, Result) { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; using(qubits=Qubit[16]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); set res5 = M(qubits[5]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovementDirectionSetup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestMovementDirectionSetup.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results .GroupBy(result =&gt; result) .OrderBy(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>.Key)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Key}</span></span></span><span class="hljs-string"> was measured </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Count()}</span></span></span><span class="hljs-string"> times"</span></span>); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal measures: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{results.Count()}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre><br><br><img src="https://habrastorage.org/webt/1a/oa/vm/1aoavmvs9hscf8gywpbgfpbdpiq.png"><br></div></div><br><br><h3>  Bewegung </h3>  Implementiert von kontrolliertem SWAP.  Wenn das steuernde Qubit einfach ist, tauschen Sie es aus.  Wenn das steuernde Qubit Null ist, tauschen wir auf. <br><br><img src="https://habrastorage.org/webt/zs/n8/os/zsn8osjcozts2nip6lbunqjcg_w.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema im Editor</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q # Operator</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Makes a movement based on the 5'th qubit value // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation MakeMovement(qubits: Qubit[]) : Unit { body { // Code movement Up // Step 1 mutable qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 2 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 3 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 4 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // COde movement down X(qubits[5]); // Invert direction qubit for the ZeroControlled operations // Step 5 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 6 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 7 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 8 set qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); X(qubits[5]); // Back-invert for the direction qubit } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: Anweisung f√ºr Tests</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); MakeMovement(qubits); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res0 = M(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res1 = M(qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res2 = M(qubits[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res3 = M(qubits[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res4 = M(qubits[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res5 = M(qubits[<span class="hljs-number"><span class="hljs-number">5</span></span>]); ResetAll(qubits); <span class="hljs-comment"><span class="hljs-comment">// ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C # -Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestFirstMovement.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Holes measurements foreach (var group in results .GroupBy(result =&gt; result[0]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} hole was measured {group.Count()} times"); } // Directions measuremetns foreach (var group in results .GroupBy(result =&gt; result[1]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} direction was measured {group.Count()} times"); } Console.WriteLine($"\r\nTotal measures: {results.Count()}"); } }</span></span></code> </pre> <br></div></div><br>  Der Code kann in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 3</a> angezeigt werden. <br><br><h3>  Wir machen 6 Z√ºge </h3><br>  Schlie√ülich w√§hlen wir das sechste Qubit f√ºr den Status des Spiels (der Fuchs ist frei / der Fuchs ist nicht frei).  Die Einheit entspricht einem freien Fuchs.  Wir werden weitere Schritte nur mit einem einzigen Status-Qubit machen. <br><br>  Die Qubits 7,8,9,10,11 werden eine Bewegungsgeschichte f√ºhren.  Nach jedem Zug tauschen wir einen von ihnen gegen ein Qubit der aktuellen Richtung aus (dies erm√∂glicht es uns, den Verlauf der Z√ºge zu speichern und das Qubit der aktuellen Richtung vor jedem Zug zur√ºckzusetzen). <br><img src="https://habrastorage.org/webt/a0/1t/_t/a01t_t8jo_9nt9w1nimamxrd-i0.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schema beigef√ºgt</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q # Operator</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Make 6 movements. Every movement is controlled by the 6'th qubit. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> After the every qubit we check if the fox has been captured and invert the 6'th qubit </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Reminder: 6'th qubit equal to One means "Fox is free, go further" operation MakeSixMovements(qubits: Qubit[]) : Unit { body { // Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: Anweisung f√ºr Tests</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { ResetAll(qubits); InitFoxHoles(qubits); X(qubits[<span class="hljs-number"><span class="hljs-number">6</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// At the beginning of the game our fox is alive MakeSixMovements(qubits); set res = M(qubits[6]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: Testen</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zerosCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { Result result = Quantum.FoxHunter.TestSixMovements.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result == Result.Zero) { zerosCount++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal zeroes: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{zerosCount}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br>  Wir sehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Commit 4</a> . <br><br><h3>  Feinschliff </h3><br>  Wir haben einen Fehler in der Schaltung.  Da wir die Strategie 1-2-3-1-2-3 testen, √ºberpr√ºfen wir jedes Loch zweimal.  Nachdem wir den Fuchs im ersten Zug gefangen haben, werden wir das Status-Qubit zweimal durchlaufen (im ersten und vierten Zug). <br><br>  Um diese Situation zu vermeiden, verwenden wir 12 Qubits, um den Status nach den Z√ºgen 4-5-6 zu korrigieren.  Zus√§tzlich f√ºgen wir die Definition des Sieges hinzu: Wenn mindestens eines der Status-Qubits auf Null geht, haben wir gewonnen. <br><img src="https://habrastorage.org/webt/cs/pc/ug/cspcugcnyqdranjm_lifypt2evc.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das endg√ºltige Schema</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Q #: Korrigieren Sie den 6-Zug-Operator</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">qubits: Qubit[]</span></span></span><span class="hljs-function">) : Unit</span></span> { body { <span class="hljs-comment"><span class="hljs-comment">// Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[1], qubits[12]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[2], qubits[12]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[3], qubits[12]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">F #: Festlegen der Operator-Teststrategie 1-2-3-1-2-3</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history // 12 - another qubit of the fox live. 1 means "fox is still free, go further" // 13 Result qubit. If it's zero, the fox is alive body { mutable res = Zero; using(qubits=Qubit[14]) { ResetAll(qubits); // Init fox positions and the fox' live InitFoxHoles(qubits); X(qubits[6]); // At the beginning of the game our fox is alive X(qubits[12]); // The second qubit of the fox live. If it's one - the fox is alive. // Make moves MakeSixMovements(qubits); // Measure results. If the 13'th qubit is zero the fox is alive X(qubits[6]); X(qubits[12]); CNOT(qubits[6], qubits[13]); CNOT(qubits[12], qubits[13]); CCNOT(qubits[6], qubits[12], qubits[13]); set res = M(qubits[13]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: Endpr√ºfung durchf√ºhren</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunFoxHunt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foxSurvives = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hunterWins = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = (Result)(TestStrategy.Run(sim).Result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == Result.Zero) { foxSurvives++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hunterWins++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Fox survives: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{foxSurvives}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Hunter wins: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{hunterWins}</span></span></span><span class="hljs-string">"</span></span>); } sw.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Experiment finished. "</span></span> + <span class="hljs-string"><span class="hljs-string">$"Time spent: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1000</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> seconds"</span></span>); }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/qm/pr/a3/qmpra3x-ticzuunfcmlsl_8atnk.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Festschreiben 5</a> . <br><br><h3>  Was folgt daraus </h3><br>  Grunds√§tzlich kann das Schema sowohl in der Anzahl der Qubits als auch in der Anzahl der Operationen optimiert werden.  Die triviale Optimierung f√ºr die Anzahl der Qubits besteht darin, Qubit-13 zu entfernen und nur 6 und 12 zur√ºckzugeben. Optimierung f√ºr Operationen - um den ersten Schuss unmittelbar nach der Initiierung zu machen.  √úberlassen wir diese Arbeit jedoch den Google-Ingenieuren. <br><br>  Wie Sie sehen, kann jeder, der oberfl√§chlich mit Quantencomputern vertraut ist, sicher den "Fuchsj√§ger" spielen.  Wenn wir etwas mehr Qubits h√§tten, k√∂nnten wir die optimale L√∂sung finden und nicht die vorhandene √ºberpr√ºfen.  Es ist durchaus m√∂glich, dass Tic-Tac-Toe (und ihre Quantenversion), Dame, Schach, Go als n√§chstes fallen. <br><br>  Gleichzeitig bleibt das Thema "L√∂sbarkeit" von Spielen wie DotA, Starcraft und Doom offen.  F√ºr das Quantencomputing ist die Speicherung der gesamten Klickhistorie charakteristisch.  Wir nehmen einen APM (Actions Per Minute) von 500, multiplizieren mit der Anzahl der Spieler, multiplizieren mit der Anzahl der Minuten, addieren die Zuf√§lligkeit des Spiels selbst - die Anzahl der Qubits, die zum Speichern aller Informationen erforderlich sind, w√§chst zu schnell. <br><br>  Die Auswahl eines Spiels in einem kleinen Wettbewerb zwischen Brin und Page kann also eine entscheidende Rolle spielen.  Die Entwicklung eines ‚Äûebenso schwierigen‚Äú Spiels f√ºr klassische Computer und Quantencomputer verdient jedoch eine eigene Theorie. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437352/">https://habr.com/ru/post/de437352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437342/index.html">So w√§hlen Sie eine Plattform f√ºr die Video√ºberwachung: Cloud vs. DVR / NVR / VMS</a></li>
<li><a href="../de437344/index.html">Anwendungsf√§lle f√ºr Netzwerksichtbarkeitsl√∂sungen</a></li>
<li><a href="../de437346/index.html">Ein Spiel (nicht) f√ºr Narren. Wir schreiben AI f√ºr "The Fool" (Teil 1)</a></li>
<li><a href="../de437348/index.html">Steigern Sie die Produktivit√§t auf GitHub: Tipps f√ºr Anf√§nger und mehr</a></li>
<li><a href="../de437350/index.html">Ein Auto im Zeitalter der Multifunktionalit√§t. Welche Conversions sind m√∂glich?</a></li>
<li><a href="../de437354/index.html">Schw√§chen Sie die N√ºsse, Teil 2: die Abstimmungsperiode f√ºr Ver√∂ffentlichungen und andere √Ñnderungen</a></li>
<li><a href="../de437356/index.html">Was ist mit der SSD im Jahr 2018 passiert?</a></li>
<li><a href="../de437358/index.html">Produktkompatibilit√§tsmanagement</a></li>
<li><a href="../de437360/index.html">Herunterladen von Controllern ohne Verwendung einer Arduino IDE-Konsole</a></li>
<li><a href="../de437364/index.html">Die Kontrolle √ºber Tele2 kostet Rostelecom 240 Milliarden Rubel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>