<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèø ‚òîÔ∏è üïµüèª A la question des tampons (ring) üàöÔ∏è ‚û°Ô∏è üôáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬´Si vous trouvez les co√ªts de d√©veloppement de l'architecture excessifs, consid√©rez combien une mauvaise architecture peut vous co√ªter¬ª 
 - Je ne me s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A la question des tampons (ring)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438476/"><h3>  ¬´Si vous trouvez les co√ªts de d√©veloppement de l'architecture excessifs, consid√©rez combien une mauvaise architecture peut vous co√ªter¬ª </h3><br>  - Je ne me souviens pas exactement de la source <br><br>  Une fois, "il y a longtemps, dans une galaxie lointaine", j'ai achet√© le merveilleux livre Etudes for Programmers de Charles Weatherly, dans l'introduction √† laquelle l'auteur a d√©montr√© la n√©cessit√© d'√©tudier des exemples et des t√¢ches p√©dagogiques avant de commencer une programmation ind√©pendante.  Je vous recommande fortement de trouver ce livre, de lire la pr√©face (et sans vous y arr√™ter, de lire le reste et de r√©soudre les probl√®mes qui y sont donn√©s), car je ne peux pas mieux justifier la n√©cessit√© d'une telle pratique.  M√™me si vous suivez ma recommandation et acqu√©rez beaucoup de connaissances et de comp√©tences pratiques lors de la lecture du livre, vous pouvez revenir en arri√®re et lire ce post, car il est consacr√© √† plusieurs autres questions.  Et si vous ne suivez pas mes recommandations, alors vous devriez d'autant plus passer sous le chat. <br><a name="habracut"></a><br>  Il n'y a pas si longtemps, dans un article dans lequel j'ai grond√©, j'ai exprim√© mon opinion sur un RTOS national, j'ai mentionn√© que la mise en ≈ìuvre du tampon en anneau dans la biblioth√®que bien connue (et √† certains √©gards, absolument merveilleuse) de mcucpp ne pouvait pas √™tre consid√©r√©e comme id√©ale.  Je vais essayer d'expliquer mon point de vue et d'imaginer la mise en ≈ìuvre id√©ale (autant que possible dans le monde r√©el).  Remarque - le texte propos√© √† votre attention est rest√© dans le "inachev√©" pendant un certain temps, puis un cas si pratique s'est pr√©sent√©. <br><br>  Nous continuons √† d√©velopper une biblioth√®que pour travailler avec un p√©riph√©rique, et nous sommes √† c√¥t√© pour la gestion de la m√©moire et la mise en m√©moire tampon (oui, nous continuons toujours les op√©rations pr√©paratoires, mais sans eux en aucune fa√ßon).  D'o√π vient le besoin d'organiser les tampons et de quel type d'animal s'agit-il?  Le fait est qu'une partie importante de la p√©riph√©rie a une vitesse limit√©e et que le processus de transmission, d√©marr√© d'une mani√®re ou d'une autre, prend un certain temps, et parfois tr√®s important, par rapport √† la cr√©ation d'une autre partie des informations √† transmettre.  Bien s√ªr, avant que ce temps ne soit √©coul√©, la prochaine transmission ne peut pas √™tre effectu√©e et, par cons√©quent, ne peut pas √™tre d√©marr√©e. <br><br>  Nous avons un cas classique d'une paire √©crivain-lecteur avec diff√©rentes vitesses.  Il est tout simplement impossible de r√©soudre ce probl√®me sous une forme g√©n√©rale, car ¬´avec un exc√®s arbitrairement petit, mais pas nul, du flux de demandes sur le flux de service, la taille de la file d'attente tend vers l'infini¬ª et l'infini est fondamentalement impossible.  Mais un cas particulier du probl√®me, lorsque nous avons des rafales locales de demandes, mais qu'en moyenne le flux de service est capable de faire face √† la charge, une m√©moire tampon de capacit√© suffisante peut √™tre r√©solue.  Prenons garde √† l'expression ¬´capacit√© suffisante¬ª, nous apprendrons plus tard √† la calculer, tant que le fait que cela soit fondamentalement possible nous suffit. <br><br>  Que la m√©moire tampon soit une exigence absolue ne l'est bien s√ªr pas.  Pour les informations transmises, vous pouvez utiliser un enregistrement de blocage, mais avec les informations re√ßues, c'est un peu pire, il faudra l'ajouter quelque part avant le traitement, si vous ne prenez pas les mesures appropri√©es dans le protocole de haut niveau (l'expression magique xon / xoff n'est pas n√©e de z√©ro), ce qui n'est pas toujours possible et, dans tous les cas, conduit g√©n√©ralement √† une limitation importante du d√©bit de transmission.  Il existe √©galement une impl√©mentation mat√©rielle des tampons internes dans les p√©riph√©riques (au moins pour un √©l√©ment), mais cela n'est pas toujours fait et la taille du tampon est strictement limit√©e par le haut. <br><br>  Par cons√©quent, nous allons toujours impl√©menter le tampon de programme, pour lequel il serait naturel d'utiliser la m√©thode FIFO (c'est-√†-dire la file d'attente) pour organiser un tel tampon, et la file d'attente, √† son tour, est mieux impl√©ment√©e sur un tampon en anneau avec deux pointeurs.  Lorsque j'√©cris ¬´mieux¬ª, cela ne signifie pas du tout que d'autres impl√©mentations (par exemple, une file d'attente de r√©f√©rence) sont impossibles ou pr√©sentent des failles fatales autres que fatales.  Cette expression signifie seulement que la mise en ≈ìuvre ne sera pas trop compliqu√©e et assez efficace, bien que d'autres puissent avoir des avantages ind√©niables par rapport √† cela, pour lesquels ils devront payer avec quelque chose, car DarZaNeBy. <br><br>  Comme il est hautement improbable que votre mod√®le MK ait une impl√©mentation mat√©rielle d'un tel appareil √† usage g√©n√©ral (les modules p√©riph√©riques individuels peuvent avoir leurs propres tampons en anneau, mais ils n'ont rien √† voir avec le sujet de cet article), nous devrons cr√©er un tampon en anneau dans la m√©moire lin√©aire (impl√©menter sur vecteur, c'est, en g√©n√©ral, le seul objet naturel dans la m√©moire adressable), et pour cela, un index de tampon (ou peut-√™tre m√™me deux index, mais plus √† ce sujet plus tard) sera n√©cessaire.  √Ä mon avis, un tampon circulaire avec deux pointeurs (indices) est le seul moyen acceptable d'impl√©menter une file d'attente sur un vecteur, mais il existe diff√©rents points de vue sur cette question et j'ai vu de mes propres yeux une impl√©mentation dans le style de ¬´x1 = x2;  x2 = x3; ... x8 = nouveau symbole ", si vous voulez, je ne consid√©rerai pas comme exotique.  Le fait que le fragment donn√© puisse avoir le droit d'exister dans une situation sp√©cifique tr√®s limit√©e ne le rend pas acceptable en g√©n√©ral. <br><br>  Nous consid√©rerons la mise en ≈ìuvre correcte du module de programme pour organiser le pointeur, et pour commencer, faites attention au premier mot de la d√©finition.  La diff√©rence entre un code correct et un mauvais n'est pas seulement parce que le code correct ne contient pas d'erreurs, bien qu'il s'agisse d'une exigence absolue.  M√™me le code qui remplit pleinement ses fonctions peut √™tre incorrect s'il est incompr√©hensible, ou s'il existe une option qui n'est pas moins claire, mais qui s'ex√©cute plus rapidement ou qui s'ex√©cute tout aussi rapidement, mais plus clairement √©crite, de sorte que le concept de correction est quelque peu relatif.  Nous continuons notre examen de notre exemple d'impl√©mentation de tampon, qui nous permettra de d√©montrer la diff√©rence entre les diff√©rents degr√©s de correction. <br><br>  Avant de passer √† l'essentiel, un point important sur la suite de la discussion.  Je veux dire que votre compilateur est toujours activ√© √† un niveau d'otpimisation non nul (-O2), donc nous n'avons pas √† penser √† des am√©liorations mineures comme 1) la modification du pr√©fixe par rapport √† postfix, ou 2) utiliser les r√©sultats de l'op√©ration pr√©c√©dente, ou 3) la diff√©rence entre l'incr√©mentation et l'ajout unit√©s et ainsi de suite - nous supposons que le compilateur fera beaucoup pour nous.  Bien s√ªr, ce n'est pas une hypoth√®se stricte, mais sinon nous devrons plonger dans les entrailles de l'assembleur, qui √† notre √©poque n'est pas le courant dominant. <br><br>  Permettez-moi de vous rappeler que nous avons √©t√© charg√©s d'impl√©menter l'index (pointeur) du tampon en anneau, c'est-√†-dire que nous devons cr√©er un comportement variable qui <b>traverse s√©quentiellement une s√©rie de valeurs, de l'initiale √† la finale</b> .  Supposons imm√©diatement que la valeur initiale sera nulle, sinon nous devrons imm√©diatement √©crire un code plus ou moins correct, ce qui contredit les objectifs √©ducatifs et nous ne sommes pas press√©s, et le dernier est Max. <br><br>  Ce comportement de la variable peut √™tre impl√©ment√© en utilisant la construction suivante: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (++Counter) % (Max+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  et c'est pr√©cis√©ment un tel code que nous pouvons voir dans de nombreux cas (c'est-√†-dire tr√®s souvent).  Qu'est-ce qui ne va pas - eh bien, premi√®rement, pendant un certain temps (de l'ex√©cution de l'op√©ration d'incr√©mentation √† l'attribution du r√©sultat), notre variable sera sup√©rieure √† la valeur maximale autoris√©e et, si √† ce moment une interruption se produit qui doit prendre en compte la valeur de cette variable, alors je pr√©dit personnellement Je ne pr√©sume pas des r√©sultats.  Par cons√©quent, nous r√©√©crivons le programme: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter=<span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) % (Max + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Nous avons √©limin√© une erreur, et le code (ci-apr√®s je veux dire le code ¬´ex√©cutable¬ª signifie le code ex√©cutable g√©n√©r√© par le compilateur) n'est pas devenu plus long et ne s'ex√©cute plus (en fait, il s'ex√©cute plus rapidement, mais uniquement parce que dans la premi√®re version le mot volatile est utilis√© compl√®tement redondant dans ce cas), et n'est pas devenu moins clair (plut√¥t, encore plus clair, mais c'est une question de go√ªt). <br><br>  Remarque n√©cessaire sur volatile - cette directive est n√©cessaire si nous voulons √©viter l'optimisation de code qui conduit √† une ex√©cution incorrecte, et dans ce cas particulier (lorsque la valeur de la variable ne change pas en dehors de la port√©e du module et qu'il n'y a pas d'entr√©es s√©quentielles), elle (directive ) compl√®tement redondant.  Je vous recommande fortement de regarder le code g√©n√©r√© pour les deux options sur godbolt.org.  Pourquoi ne pas abuser de la directive volatile, contrairement au mot-cl√© statique, dont l'utilisation est recommand√©e dans la mesure du possible.  Eh bien, premi√®rement, nous interdisons l'optimisation, c'est-√†-dire que le code ne deviendra certainement pas plus rapide (tr√®s probablement, il deviendra plus gros et plus lent, mais nous pr√©f√©rons des formulations strictes).  Et deuxi√®mement, dans ce cas particulier, ce mot est trompeur, car par rapport √† notre programme, la valeur du compteur ne peut en aucun cas changer en dehors de notre contr√¥le.  Dans un programme qui lit sa valeur - c'est-√†-dire, dans l'impl√©mentation du tampon en anneau lui-m√™me, vous pouvez consid√©rer le compteur mutable en dehors du module, et l√† il est discutable, donc cet attribut n'est tout simplement pas applicable au compteur.  Si une variable doit √™tre interpr√©t√©e diff√©remment dans diff√©rents modules, nos services doivent √™tre combin√©s, si nous parlons d'organiser une section critique, par exemple, lors de la mise en ≈ìuvre d'une transaction ou d'op√©rations atomiques, alors cette directive ne donne rien du tout. <br><br>  Nous revenons au code et voyons que le programme est toujours faux - quel est le probl√®me - et le fait est qu'il ne fait pas ce dont nous avons besoin (voir la description de la t√¢che), mais autre chose (calcule le reste de la division), juste les r√©sultats correspondre.  Eh bien, nous le pensons (je ne pense pas, mais les auteurs du code certainement), que les r√©sultats co√Øncident, en fait, dans le cas g√©n√©ral, ils ne co√Øncident pas, nous avons juste eu de la chance avec la plage de la variable (valeurs positives).  De plus, le processus d'ex√©cution du code est plus long qu'il ne pourrait l'√™tre, car dans le meilleur des cas, nous avons l'op√©ration de division enti√®re (si elle fait partie des commandes de notre architecture), et elle n'est effectu√©e en aucun cas dans un cycle de processeur (une valeur caract√©ristique de 10 cycles pour une architecture 8 bits), et dans le pire des cas, nous verrons l'appel de proc√©dure de division √† partir de la biblioth√®que standard (et bien, si la division est courte), alors le temps d'ex√©cution sera de dizaines de cycles d'horloge. <br><br>  Alors, pourquoi une telle approche compl√®tement fausse est-elle encore possible de se rencontrer tr√®s souvent.  Ici, du public, ils me disent qu'avec la valeur de Max + 1, qui est une puissance de deux, le compilateur devinera au lieu de l'op√©ration de division, placera l'op√©ration de multiplication au niveau du bit sur le masque correspondant (√©gal √† Max), qui sera effectu√©e tr√®s rapidement et tout ira bien. <br><br>  Je serais d'accord avec cette d√©claration et adopterais cette approche, sinon pour les circonstances suivantes: <br><br><ul><li>  cela n'est possible que pour Mach d√©fini statiquement au stade de la compilation, </li><li>  cela ne se produit que lorsque l'optimisation est activ√©e, </li><li>  cela ne se produit que lorsque Mach remplit cette condition, </li><li>  cela ne se produit pas pour tous les types cardinaux. </li></ul><br>  De plus, c'est dans ce cas particulier (lorsque la variable est d√©finie comme un signe), en plus de la commande de multiplication (logique) par le masque, une commande de comparaison avec z√©ro et une branche pour les valeurs n√©gatives sera g√©n√©r√©e, et bien que cette branche ne sera jamais pour notre gamme il sera ex√©cut√©, il prendra de la place dans la m√©moire (et dans le cas d'une fonction substituable, il faudra plusieurs fois) et il faudra du temps pour effectuer l'op√©ration de comparaison, si vous n'y croyez pas, nous suivons √† nouveau le site indiqu√© et voyons par vous-m√™me.  Un autre argument en faveur des cardinaux non sign√©s, auquel j'ai r√©cemment consacr√© un poste entier. <br><br>  Par cons√©quent, si nous voulons utiliser la multiplication logique avec un masque (obtenu en optimisant le calcul du reste), nous devons r√©√©crire le module en cons√©quence: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Counter_t; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sCounter_t; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> IS_POWER2(Max + 1) return (Counter + 1) &amp; Max #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return (Counter + 1) % (Max + 1); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  Dans cette version, tout est compl√®tement clair et contr√¥lable et tout est vrai (m√™me si un certain nombre de lacunes sont rest√©es, mais elles sont maintenant √©videntes et non masqu√©es), donc c'est correct, bien que ce soit plus correct et nous allons maintenant les chercher.  Le principal inconv√©nient, √† mon avis, est une violation du principe KISS, car l'utilisation de l'op√©ration restante par division n√©glige compl√®tement ce principe.  Par cons√©quent, nous allons maintenant d√©truire tous les d√©fauts d'un seul coup (ne vous inqui√©tez pas de leur sort, ils rena√Ætront 100 500 fois, car tous les programmeurs d'Arduino ne lisent pas mes messages). <br><br>  Mais d'abord, une l√©g√®re d√©viation sur le c√¥t√©.  Comment pouvons-nous impl√©menter une v√©rification de la puissance de deux (un nombre binaire peut √™tre repr√©sent√© par {0} 1 {0}) que nous venons d'utiliser <br><br><div class="spoiler">  <b class="spoiler_title">n'espionne pas</b> <div class="spoiler_text">  #define IS_POWER2 (N) (((((N) - 1) &amp; (N)) == 0) <br></div></div><br>  Et comment pouvons-nous impl√©menter la v√©rification qu'un nombre est une bonne s√©quence d'unit√©s {0} 1 {1} en notation binaire - une option est √©vidente <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) IsPower2 ((N) + 1)</span></span></code> </pre> <br>  et le second est trivial <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) ( (((N) + 1) &amp; (N)) == 0)</span></span></code> </pre> <br>  Remarque: je ne peux pas m'emp√™cher de rappeler le magnifique th√©or√®me: "Un nombre transcendantal √† un degr√© transcendantal est toujours transcendantal, √† moins que l'inverse ne soit √©vident ou trivial." <br><br>  Et comment pouvons-nous v√©rifier qu'un nombre est une s√©quence d'unit√©s {0} 1 {1} {0} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsSequence(N) IsPower2( (N) ^ ((N) &lt;&lt; 1))</span></span></code> </pre> <br>  Et enfin - comment s√©lectionner le bit le moins significatif d'un nombre (je ne sais pas pourquoi cela pourrait √™tre n√©cessaire, mais cela sera utile) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LowerBit(N) ((((N) - 1) ^ (N)) &amp; (N)).</span></span></code> </pre> <br><br>  Mais il est venu avec ce qui peut √™tre utile <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) (IsSequence(N) &amp;&amp; (LowerBit(N) == 1))</span></span></code> </pre> <br>  Une observation curieuse - ces macros ne sont pas tout √† fait correctes, il s'av√®re que 0 est √† la fois une puissance de deux et une bonne s√©quence (bien s√ªr, une s√©quence aussi), ce qui est un peu √©trange.  Mais 1 est tous ces objets √† juste titre, donc z√©ro, semble-t-il, doit simplement √™tre consid√©r√© s√©par√©ment.  Une autre propri√©t√© int√©ressante de ces macros est que nous ne faisons aucune hypoth√®se sur la longueur de l'argument, c'est-√†-dire qu'elles fonctionnent correctement avec n'importe quel type cardinal. <br><br>  Il existe un merveilleux livre, Tricks for Programmers, o√π vous pouvez trouver les macros mentionn√©es et de nombreuses autres t√¢ches tout aussi amusantes et instructives, je vous recommande vivement de le lire, d'autant plus qu'il n'y a pas trop de lettres. <br><br>  Mais revenons √† notre indice de tampon en anneau.  Nous avons donn√© la bonne solution, mais promis encore plus correctement, ce qui signifie que notre derni√®re solution a des d√©fauts (qui en douteraient).  L'une d'entre elles - la longueur du tampon doit √™tre d√©termin√©e statiquement au stade de la compilation, la seconde - en cas de longueur infructueuse, le temps d'ex√©cution est tr√®s long et il y a encore un certain nombre d'erreurs dans un morceau relativement petit du programme, ce qui nous fait rappeler une blague sur 4 erreurs d'√©criture du mot ¬´plus¬ª.  Nous les √©liminerons tous (certains seront laiss√©s pour plus tard) et imm√©diatement, pour lesquels, enfin, nous √©crirons la solution au probl√®me d'origine telle qu'elle est: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; Max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; };</code> </pre> <br>  (Comme vous l'avez d√©j√† compris, je suis partisan des crochets √©gyptiens et il n'y a rien √† faire √† ce sujet). <br><br>  Prenons attention au fait que nous avons simplement r√©√©crit l'√©tat du probl√®me √† partir d'un langage naturel dans le langage de programmation choisi, de sorte qu'il s'av√®re extr√™mement clair et compr√©hensible.  Est-il possible de l'am√©liorer - sans doute, mais uniquement du point de vue des performances du code, car il n'y a tout simplement pas d'autres d√©fauts pour cette solution (il n'y a pas de d√©fauts √©vidents, en fait ils le sont et nous les √©liminerons avec succ√®s). <br><br>  √âvaluons la complexit√© de calcul de cette solution - addition avec unit√© (1) et comparaison (2) toujours, puis affectation de z√©ro (1) (rarement) ou addition (1) (presque toujours) - ce qui donne 1 + 2 + 1 + Œî ~ 4 √©l√©mentaire op√©rations et z√©ro m√©moire.  Il est possible qu'un bon compilateur dans le bon mode fasse certaines optimisations et r√©duise le temps d'ex√©cution du code, mais il vaut mieux le faire explicitement.  Voici l'option suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> sCounter_t Tmp; Tmp = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &gt; Max) { Tmp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Nous √©valuons la complexit√© - addition et comparaison toujours, en attribuant z√©ro (rarement) - environ 3 op√©rations et un √©l√©ment de m√©moire.  En fait, la version pr√©c√©dente avait √©galement un √©l√©ment m√©moire (implicite), nous avons donc un gain net en une seule op√©ration √©l√©mentaire.  De plus, la version pr√©c√©dente avait deux autres inconv√©nients - 1) viol√© le principe DRY (calcul√© l'augmentation d'une fois deux fois) et 2) avait plus d'un point de sortie, ce qui n'est pas bon.  Nous n'avons pas non plus perdu de vue, c'est-√†-dire que nous avons r√©ussi √† tuer un tas de lapins d'un seul coup, et nous n'avons pas d√©pens√© de cartouches non plus - c'est juste une histoire dans le style du baron Munchausen. <br><br>  Notez que je n'ai pas utilis√© la construction <code>if ( (Tmp = Counter + 1) &gt; Max)</code> , bien qu'elle contienne une instruction explicite au compilateur pour essayer de ne pas effectuer de transferts redondants.  C'est l'aromatisation sous la forme la plus flagrante, je n'aime tout simplement pas la valeur retourn√©e par l'op√©rateur d'affectation et j'essaie d'√©viter de l'utiliser.  Je ne peux pas expliquer la raison de ce sentiment fort, selon Freud, il s'agit tr√®s probablement d'un traumatisme psychologique dans l'enfance.  Les compilateurs modernes sont tout √† fait capables d'effectuer eux-m√™mes une simple optimisation, et en plus, j'ai √©galement ajout√© un qualificatif de registre, afin que le code de ma version et celui correct (du point de vue du langage C) correspondent.  N√©anmoins, je ne limite pas du tout votre libert√© d'utiliser la m√©thode qui vous semble pr√©f√©rable. <br><br>  Nous continuons √† nous am√©liorer, car il n'y a pas de limite √† la perfection et nous ne l'avons pas encore atteinte.  Pour y parvenir, nous reformulons quelque peu le probl√®me d'origine et ne laissons que l'exigence de la variable dans la plage de valeurs, sans indiquer la direction du changement.  Cette approche vous permet de r√©√©crire le programme comme suit <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> Counter_t Tmp; Tmp = (Counter - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Tmp = ; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  √Ä premi√®re vue, rien n'a beaucoup chang√©, mais nous obtenons n√©anmoins un gain de temps.  Bien s√ªr, non pas du fait que l'op√©ration de diminution de un fonctionne plus vite que l'op√©ration d'augmentation par celle-ci (bien que j'aie entendu une version similaire), mais en raison des particularit√©s de la comparaison.  Si dans les versions pr√©c√©dentes je consid√©rais la comparaison comme 2 op√©rations √©l√©mentaires (on soustrait d'abord puis on prend une d√©cision), alors dans ce cas le r√©sultat de l'op√©ration pr√©c√©dente est utilis√© pour prendre une d√©cision directement et la comparaison prend une op√©ration √©l√©mentaire, ce qui conduit √† deux op√©rations toujours et une affectation (rarement) et nous avons sauv√© une op√©ration (sans rien perdre), comme le dit le proverbe, "une bagatelle, mais agr√©able."  La solution r√©sultante est-elle id√©ale - malheureusement, non.  Il est l√©g√®rement inf√©rieur √† la solution avec un masque (qui n√©cessite exactement 2 op√©rations √©l√©mentaires) en termes de vitesse et c'est peut-√™tre son seul inconv√©nient. <br><br>  Il existe une solution encore plus rapide - il suffit d'augmenter (de diminuer) la valeur du compteur et de ne rien faire d'autre, mais ce n'est possible que dans le seul cas o√π la valeur maximale co√Øncide avec la valeur la plus repr√©sentative du type accept√©.  Pour un compteur 8 bits (c'est-√†-dire, comme uint8_t), ce sera 255, puis nous √©crivons simplement Counter = Counter + 1 et je crois que l'√©criture de Counter + = 1 ou ++ Counter est compl√®tement facultative, bien que beaucoup le soient et ils √©criront et auront tout √† fait raison.  Si nous ne consid√©rons pas s√©rieusement la version sur la n√©cessit√© de sauvegarder les caract√®res (puisque la premi√®re option est la plus longue), cela n'a aucun sens, du moins si nous √©crivons un programme pour l'architecture ARM ou AVR (pour d'autres que je n'ai tout simplement pas v√©rifi√©, je soup√ßonne que le r√©sultat sera la m√™me chose) sous le compilateur GCC (l'auteur comprend qu'ils √©crivent le programme dans l'√©diteur de l'environnement de programmation int√©gr√©, ce n'est qu'une r√©volution vocale du pass√© lorsque les ordinateurs √©taient grands et la m√©moire petite), et avec l'optimisation activ√©e √† n'importe quel niveau, car  le code donn√© sera absolument identique. <br><br>  Les compilateurs modernes sont tr√®s, tr√®s avanc√©s en termes d'optimisation et g√©n√®rent vraiment du tr√®s bon code, bien s√ªr, si vous avez activ√© le mode correspondant.  Bien que je sois pr√™t √† convenir que de telles constructions de langage ne nuisent pas et peuvent √™tre utiles dans certaines conditions, la seule chose que je note est que les expressions Counter ++ (dans ce cas particulier, bien s√ªr) doivent √™tre √©vit√©es sans ambigu√Øt√©, car elles sont destin√©es √† des situations compl√®tement diff√©rentes et peuvent donner lieu √† code plus lent, bien que facultatif. <br><br>  Une autre question est qu'un tampon de 256 √©l√©ments n'est pas toujours acceptable, mais si vous avez suffisamment de m√©moire, alors pourquoi pas.  Avec cette impl√©mentation, si vous pouvez aligner le tampon sur la bordure de page, l'acc√®s aux √©l√©ments peut √™tre rendu tr√®s rapide en √©liminant l'op√©ration de d√©placement d'index en index (le mot-cl√© union vous indiquera l'impl√©mentation d'une telle fonctionnalit√©, je ne l'apporterai pas afin de ne pas apprendre mauvais), mais c'est d√©j√† une d√©cision tr√®s, tr√®s sp√©cifique avec un fort attachement √† l'architecture, qui est dangereusement proche des astuces au pire sens du terme, et ce n'est pas notre style. <br><br>  Bien s√ªr, personne ne nous interdit d'√©crire un wrapper qui appellera telle ou telle m√©thode en fonction de la valeur du maximum (et du minimum, car de nombreuses m√©thodes ne fonctionnent tout simplement pas avec un minimum non nul), j'ai d√©j√† propos√© les principes de base d'une telle solution, donc nous proposerons cela comme un exercice. <br><br>  Eh bien, en conclusion, pour r√©sumer - nous allons rassembler diff√©rentes impl√©mentations de travail avec un indice d'anneau et √©valuer leurs propri√©t√©s. <br><div class="scrollable-table"><table><tbody><tr><th>  La m√©thode </th><th>  Polyvalence </th><th>  D√©lai de livraison </th></tr><tr><td>  ¬± </td><td>  0 (1) </td><td>  1 </td></tr><tr><td>  ¬±% </td><td>  1 (7) </td><td>  2 </td></tr><tr><td>  + si </td><td>  3 (tout) </td><td>  3.x </td></tr><tr><td>  - si </td><td>  3 (tout) </td><td>  2.x </td></tr></tbody></table></div><br>  La deuxi√®me ligne entre parenth√®ses indique le nombre de valeurs de taille de tampon (ne d√©passant pas 256) pour lesquelles cette impl√©mentation est disponible, mais nous voulons dire qu'un tampon de taille 0 ne nous int√©resse pas. <br><br>  Comme vous pouvez le voir sur ce tableau, DarZaNeBy (mon expression pr√©f√©r√©e, comme vous l'avez peut-√™tre remarqu√©), et les avantages sont achet√©s au prix d'inconv√©nients, la seule chose qui peut √™tre d√©clar√©e sans √©quivoque est que l'incr√©ment avec v√©rification a un concurrent plus efficace sous la forme d'une d√©cr√©mentation avec v√©rification et ne passe pas au cycle suivant en aucun cas. <br><br>  Une note n√©cessaire - il existe des langages de programmation dans lesquels nous n'aurions pas du tout √† penser √† la mise en ≈ìuvre de l'index, mais nous pourrions simplement utiliser le type d'intervalle.  Malheureusement, je ne peux pas appeler l'impl√©mentation de ces constructions dans le code optimal, car ces constructions (et ces langages) ne sont pas destin√©es √† l'optimisation au moment de l'ex√©cution, mais c'est dommage. <br><br>  Nous avons donc cr√©√© le bon module (quel nom fort pour la fonction inline) pour travailler avec l'index, et maintenant nous sommes pr√™ts √† commencer √† impl√©menter le tampon en anneau lui-m√™me. <br><br>  Et pour commencer, nous devons d√©cider ce que nous voulons exactement de cet objet programme.  Il est absolument n√©cessaire de pouvoir mettre un √©l√©ment de donn√©es dans un tampon et de l'extraire - deux m√©thodes principales, une sorte de getter et setter.  Il est th√©oriquement possible d'imaginer un tampon sans l'une de ces m√©thodes, ou m√™me sans les deux (peu peut √™tre imagin√© purement th√©oriquement), mais la valeur pratique d'une telle impl√©mentation est une grande question.  La prochaine fonctionnalit√© n√©cessaire - v√©rification des informations - peut √™tre impl√©ment√©e soit comme une m√©thode distincte, soit comme une valeur sp√©ciale (ou attribut) retourn√©e par la lecture.  Habituellement, ils pr√©f√®rent la premi√®re m√©thode, car elle se r√©v√®le plus compr√©hensible et pas trop ch√®re. <br>  Mais v√©rifier l'exhaustivit√© du tampon est d√©j√† une grande question - cette op√©ration n√©cessitera du temps suppl√©mentaire, qui sera toujours consacr√© √† l'enregistrement, bien que personne ne nous oblige √† l'utiliser - alors laissez-le.  Nous n'avons besoin de rien d'autre du tampon, souvenons-nous de cette phrase pour l'avenir. <br><br>  Retour √† l'impl√©mentation.  Nous avons besoin d'un endroit pour stocker les √©l√©ments de la file d'attente et de deux index - un pour √©crire dans le tampon et un pour lire √† partir de celui-ci.  Comment exactement nous obtiendrons cet endroit (et ces pointeurs) est un sujet pour une discussion s√©par√©e, pour l'instant, laissons ce moment entre crochets et croyons que nous les avons simplement.  Certains (y compris les auteurs du livre "Programmation pour les math√©maticiens" que je respecte, je le recommande pour la lecture) utilisent √©galement le compteur de places remplies, mais nous ne le ferons pas et j'essaierai de montrer pourquoi c'est mal. <br><br>  Tout d'abord, sur les indices - nous remarquons imm√©diatement que ce sont des indices, pas des pointeurs, bien que parfois je me permette d'√™tre appel√© ainsi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi les index (stockage d'informations sur le num√©ro de l'√©l√©ment de file d'attente) et non les pointeurs (stockage d'informations sur l'emplacement dans la m√©moire de l'√©l√©ment de file d'attente) est une question tr√®s difficile, il existe des situations o√π les pointeurs sont plus rentables, mais ce n'est clairement pas notre cas. </font><font style="vertical-align: inherit;">Nos files d'attente seront courtes (m√™me √† 256, nous regardons avec prudence), donc les index prendront moins de place, les op√©rations √©l√©mentaires seront plus rapides pour eux, il n'y aura pas de probl√®mes d'atomicit√© des op√©rations (dans une architecture normale, il ne devrait pas y en avoir avec des pointeurs, mais avec Les index 8 bits ne se produiront tout simplement jamais, bien s√ªr, si vous n'avez pas de contr√¥leur 4 bits), les co√ªts suppl√©mentaires associ√©s au passage de l'index au pointeur ne seront pas trop importants (√† condition que les √©l√©ments de la file d'attente soient petits).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notes marginales</font></font></b> <div class="spoiler_text"> ,       51 (   )    2 (    )   3  ( ),   ,             ,      . ,   ,  GCC     x51,       AVR  . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, de nombreuses astuces qui augmentent la vitesse d'obtention de la valeur suivante ne seront plus disponibles lors de l'utilisation du pointeur. Et si vous tenez √©galement compte de l'opinion selon laquelle les pointeurs sont plus difficiles √† comprendre (non pas que cette opinion me paraisse correcte, mais qu'elle existe), alors le choix est clair - les index.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce que les indices devraient montrer exactement - ici, la marge d'imagination est illimit√©e dans la taille du tampon Max (et m√™me plus que cela), mais un tr√®s petit ensemble d'options a une signification pratique. Pour l'index d'enregistrement, ce sont deux possibilit√©s: 1) indiquer l'endroit o√π le dernier √©l√©ment a √©t√© enregistr√© et 2) indiquer l'endroit o√π l'√©l√©ment suivant sera enregistr√©. Comme imm√©diatement apr√®s la cr√©ation de la file d'attente, la premi√®re option semble un peu √©trange, nous choisissons la seconde, d'autant plus que cela nous promet un gain tangible √† l'avenir. Pour l'index de lecture, nous supposons imm√©diatement qu'il pointe vers l'√©l√©ment qui sera lu la prochaine fois qu'il sera lu. Il existe imm√©diatement un crit√®re simple (au sens de la v√©rification) selon lequel la file d'attente n'est pas vide - les indices ne sont pas √©gaux. Mais le deuxi√®me probl√®me se pose - si nous mettons en file d'attente exactement les √©l√©ments Mach,alors les indices co√Øncideront et nous ne pourrons pas distinguer cette situation d'une file d'attente vide.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re solution √† ce probl√®me (¬´une mauvaise solution √©vidente, compr√©hensible et simple¬ª) a √©t√© utilis√©e √† plusieurs reprises et consiste √† mettre en place un compteur pour le nombre d'√©l√©ments plac√©s dans le buffer, ou dans le cas avanc√© l'indicateur d'exhaustivit√©. Pourquoi je ne l'approuve pas - c'est 1) de l'espace m√©moire suppl√©mentaire, 2) le temps pass√© √† travailler avec (ils sont petits, mais il y en a) 3) jusqu'√† ce que l'indice co√Øncide, la valeur du compteur est redondante, car elle co√Øncide avec la diff√©rence d'index, 4) dans le cas d'une taille de tampon de 256 √©l√©ments, le compteur doit √™tre plus long que les indices et peut ne pas √™tre de type natif, 5) il y a un autre inconv√©nient (presque fatal), mais plus √† ce sujet plus tard. Comme mentionn√© ci-dessus, il est partiellement possible d'att√©nuer ces lacunes en organisant non pas un compteur, mais un indicateur complet, mais il existe une solution bien meilleure.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons simplement √©viter une situation o√π les indices peuvent co√Øncider apr√®s l'enregistrement suivant (le fait qu'ils peuvent co√Øncider apr√®s la lecture est √©vident), et pour cela, nous devons limiter le nombre possible d'√©l√©ments dans le tampon √† 1 de moins que possible. </font><font style="vertical-align: inherit;">Voici sa mise en ≈ìuvre:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NeedOverflowControl YES typedef uint8_t Data_t; static Data_t BufferData[Max]; static Counter_t BufferWriteCounter=0, BufferReadCounter=BufferWriteCounter; void BufferWrite(const data_t Data) { BufferData[BuffWriteCounter] = Data; register counter_t Tmp = NextCount(BufferWriteCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NeedOverflowControl == YES) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Tmp == BufferReadCounter) {BufferOverflow();} </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { BufferWriteCounter = Tmp; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a une l√©g√®re inexactitude dans la fonction pr√©c√©dente, je propose de la trouver et de la corriger par moi-m√™me, bien que ... toujours l√†, mais nous allons continuer: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == BufferWriteCounter ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsFull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == NextCounter(BufferWriteCounter) ); }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DataSizeIsSmaller (sizeof(data_t) &lt; sizeof(counter_t)) data_t BufferRead(void) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller register data_t Tmp = BufferData[BufferReadCounter]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> register counter_t Tmp = BufferReadCounter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> BufferReadCounter = NextCount(BufferReadCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller return Tmp; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return BufferData[Tmp]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prenons attention √† la situation dans laquelle nous avons appel√© la proc√©dure de traitement de d√©bordement (si nous d√©finissons l'indicateur pour le besoin de traitement) - lorsque nous avons essay√© d'√©crire le dernier octet inoccup√© du tampon, nous ne l'avons pas signal√© en d√©pla√ßant l'index d'√©criture, nous ne pourrons donc pas le lire - comme moi et averti, avec l'option d'impl√©mentation s√©lectionn√©e, la capacit√© tampon est r√©duite de un. Notez √©galement que nous mettons d'abord l'√©l√©ment suivant dans la file d'attente, et ensuite seulement en informant en d√©pla√ßant l'index, l'ordre inverse pourrait entra√Æner des cons√©quences tr√®s d√©sagr√©ables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de regarder le code avec l'indicateur, parlons un peu de d√©bordement - cela se produit lorsque nous ne pouvons pas mettre l'√©l√©ment suivant dans le tampon, et nous avons diff√©rentes fa√ßons de r√©soudre le probl√®me, parmi lesquelles il y en a de bonnes et ainsi de suite.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, la m√©thode (correcte et bonne) num√©ro </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) pour √©viter une situation similaire en principe en choisissant la taille de tampon correcte (il existe une sous-option de cette m√©thode - augmentez la taille du tampon si n√©cessaire, mais dans le monde de la programmation int√©gr√©e, elle n'a pas pris racine, et en fait, cela semble douteux - parfois nous avons d√ª augmenter la taille du tampon, o√π il y a une garantie que nous n'aurons pas √† le faire encore et encore). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode suivante (correcte, mais pire, bien que toujours bonne) num√©ro </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) pour signaler l'occurrence d'un d√©bordement avec une valeur de retour et pour suspendre l'√©criture dans le tampon - le soi-disant enregistrement de blocage, mais il n'est pas toujours impl√©ment√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et voici deux fa√ßons mauvaises et mauvaises:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) et 4) ignorer le probl√®me et pr√©tendre que tout va bien (¬´sourire et vague¬ª). Pourquoi sont-ils mauvais - parce que nous pr√©tendons seulement que tout va bien, en fait, le principe de Dirichlet (le probl√®me des cellules N et des oiseaux N + 1) ne peut pas √™tre viol√© et nous perdons l'√©l√©ment de donn√©es, et pourquoi y a-t-il deux fa√ßons? que nous pouvons </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) perdre le dernier √©l√©ment de donn√©es enregistr√© et </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) perdre le premier des √©l√©ments non encore transf√©r√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laquelle de ces m√©thodes est pire - ¬´les deux sont pires¬ª, m√™me si certaines d'entre elles peuvent √™tre plus acceptables pour une t√¢che sp√©cifique, mais le principal inconv√©nient est inamovible - nous sommes oblig√©s de perdre des informations. Par cons√©quent, la m√©thode 3 est le plus souvent utilis√©e, car elle est plus facile √† impl√©menter (pour cela, il suffit de laisser l'index d'enregistrement inchang√©), ce que j'ai fait dans l'exemple pr√©c√©dent si le traitement de d√©passement est vide.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a une autre fa√ßon - ne contr√¥lez pas du tout la situation (dans notre exemple, commentez la ligne avec la d√©finition, mais pas la ligne avec le contr√¥le r√©el), tandis que nous </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) perdrons tout le tampon rempli - √† premi√®re vue, cela semble √™tre le pire, car les pertes sont les plus importantes grande, en fait, ce n'est pas enti√®rement vrai, car toute perte de donn√©es est mauvaise, mais elle a un avantage certain - cette m√©thode est plus rapide, car le d√©bordement ne contr√¥le pas du tout. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une observation int√©ressante - une recherche rapide sur Internet n'a pas trouv√© d'algorithme de r√©cup√©ration de donn√©es en cas de perte d'√©l√©ment, contrairement au cas d'une distorsion d'√©l√©ment, o√π les codes de blocs fonctionnent parfaitement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'option avec le drapeau de d√©bordement, √©tonnamment, perd un peu de vitesse si elle est √©crite correctement, mais perd n√©anmoins, et de m√©moire, nous gagnons bien s√ªr un √©l√©ment, mais nous devons allouer de l'espace pour le drapeau, de sorte que les √©conomies sont en question . Nous n'envisagerons tout simplement pas l'option avec le compteur, car j'ai d√©j√† √©num√©r√© 4 de ses d√©fauts et il est temps de rappeler le cinqui√®me, comme je l'ai promis, en plus du fatal. Dans l'impl√©mentation pr√©c√©demment propos√©e, les index ont les propri√©t√©s de MRSW (Multi-Reader Single-Writer) selon la classification de "The Art of Mulpiprocessor Programming" (je recommande fortement la lecture, un travail absolument incroyable), et dans le cas des op√©rations atomiques, le changement d'index (pour le type natif) ne n√©cessite pas aucun moyen de synchronisation.Un point n√©cessaire et tr√®s important - la synchronisation n'est pas seulement requise du point de vue de l'interaction de l'√©criture et de la lecture, les deux fonctions ne sont en aucun cas r√©utilisables et peu s√ªres de ce point de vue, qui est important √† retenir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais le compteur aura la propri√©t√© MRMW, et sans synchronisation, vous ne pouvez tout simplement pas travailler avec, √† partir du mot ¬´compl√®tement¬ª (√† moins, bien s√ªr, que votre objectif soit de cr√©er un programme ¬´soudainement bogu√©¬ª). Si nous prenons en compte le fait que nous √©crivons un module pour travailler avec des p√©riph√©riques et, par cons√©quent, l'√©criture ou la lecture peut √™tre appel√©e √† partir d'une interruption, alors le probl√®me de synchronisation est absolument n√©cessaire √† consid√©rer. Fait int√©ressant, le drapeau, qui semble avoir des propri√©t√©s similaires, lui permet n√©anmoins de travailler avec lui sans outils de synchronisation (dr√¥le, n'est-ce pas, mais il a une explication compl√®tement scientifique - l'op√©ration de changement devient atomique, et la logique du drapeau permet, et m√™me impose, le chevauchement enregistrements), qui est illustr√© par le fragment suivant du programme.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter qu'une telle approche (un indicateur sans outils de synchronisation) n'est possible que si certaines conditions sont remplies, ce qui doit √™tre soigneusement v√©rifi√© dans votre cas. Des d√©tails peuvent √™tre trouv√©s dans la litt√©rature, je ne les donnerai pas, car je consid√®re que cette m√©thode d'organisation du tampon n'est pas trop bonne, et je ne la cite que pour montrer que la solution la plus r√©ussie ne peut pas √™tre mise en ≈ìuvre proprement, ainsi que pour d√©montrer un autre concept que je consid√®re tr√®s utile et que j'ai l'intention d'adh√©rer.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferData[Max]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> BufferWriteCounter=<span class="hljs-number"><span class="hljs-number">0</span></span>, BufferReadCounter=WriteCounter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> BufferHaveData = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((BufferWriteCounter == BufferReadCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">1</span></span>)) {BufferOverflow();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { BufferData[BufferWriteCounter] = Data; BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; BufferWriteCounter = NextCounter(BufferWriteCounter); }; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((BufferReadCounter==BufferWriteCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">0</span></span>));}; <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferRead(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> Tmp; Tmp = BufferReadCounter; BufferReadCounter = NextCount(BufferReadCounter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BufferReadCount == BufferWriteCounter) { BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BufferData[Tmp]; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notons √† nouveau que dans la proc√©dure d'√©criture, nous d√©finissons d'abord l'indicateur, puis modifions l'index, et dans la proc√©dure de lecture, nous v√©rifions d'abord les index, puis contr√¥lons l'indicateur, ce qui nous √©vite √† nouveau des probl√®mes et chevauche en quelque sorte la gestion des ressources pour √©liminer le blocage mutuel . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De mani√®re g√©n√©rale, ce fragment doit √™tre r√©√©crit dans le bon style (√† l'exception des constantes magiques 0 et 1, si vous pensez que ce ne sont pas des constantes magiques, alors vous vous trompez), et si vous l'utilisez, faites-le, je cache le corrig√© code dans le spoiler, non pas parce que je suis g√™n√©, mais afin de ne pas inciter √† un autre cycle de la guerre sainte (sans signification et sans piti√©), haineux des transferts, vous ne devriez pas ouvrir ce bouton,</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le reste - vous pouvez</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> (NoBufferHaveData= <span class="hljs-number"><span class="hljs-number">0</span></span>, BufferHaveData =<span class="hljs-number"><span class="hljs-number">1</span></span>) BufferHave DataFlag_t; BufferHaveData_t BufferYaveDataFlag; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = NoBufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagClr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = BufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagIsSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(BufferHaveDataFlag == BufferHaveData);};</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fait int√©ressant, le code de cette approche sera exactement le m√™me que pour les constantes directes 0 et 1, mais tout est extr√™mement transparent et clair et ne laisse aucune place √† l'interpr√©tation. Je suis d'accord √† l'avance que l'exemple semble farfelu et si seules les fonctions de travail sont sorties avec le drapeau, √† l'int√©rieur, vous pouvez utiliser compl√®tement les constantes 0 et 1. Tout cela est vrai, la seule chose sur laquelle j'insiste est pr√©cis√©ment ce comportement du drapeau, vous pouvez appeler BufferFullFlag et changer la logique de travail avec, mais en aucun cas devrait √™tre appel√© BufferIsNotEmptyFlag avec ce qui suit il effectue un myst√©rieux op√©rations logiques. J'insiste √† nouveau sur le fait que le principe KISS a d√©montr√© √† plusieurs reprises sa fid√©lit√© inconditionnelle et, si nous voulons savoir si le tampon est vide, nous devons l'√©crire directement dans le programme et ne pas poser la question ¬´est-il incomplet¬ª.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans tous les cas, je ne pense pas que l'impl√©mentation avec l'indicateur soit bonne, donc je recommande fortement de se r√©concilier avec le tampon qui n'est pas pleinement utilis√© et d'accepter l'impl√©mentation avec deux index et sans champs suppl√©mentaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, un article d'une ampleur inattendue s'est av√©r√© pour un sujet aussi simple, j'ai pens√© √† √©crire davantage sur la synchronisation et les sections critiques, mais c'est la prochaine fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Et en conclusion, qu'est-ce que je n'ai pas aim√© exactement dans la biblioth√®que mentionn√©e, mais en m√™me temps, les auteurs du RTOS domestique ont pris cela dans leur code sans le moindre doute:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deux impl√©mentations du tampon sont donn√©es - une pour la taille de la puissance de deux (j'esp√®re avoir montr√© que cela est compl√®tement inutile), et la seconde pour les cas restants, mais vous devrez choisir la version avec des stylos, bien s√ªr, ils ne feront pas d'erreur, il y a des contr√¥les partout. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Des m√©thodes compl√®tement inutiles ont √©t√© cr√©√©es, telles que la suppression du dernier √©l√©ment ou l'acc√®s direct √† l'√©l√©ment tampon. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le tampon de donn√©es est align√© sur un entier. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la mise en ≈ìuvre du degr√© 2, une erreur de v√©rification du taux d'occupation. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans la mise en ≈ìuvre d'une taille arbitraire, un compteur </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les sections critiques ne sont pas du tout organis√©es, ce qui dans la bonne mise en ≈ìuvre (avec deux indices) n'est tout simplement pas n√©cessaire, mais on ne peut pas s'en passer, l'utilisation d'op√©rations atomiques √† la place n'est clairement pas suffisante. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une certaine n√©gligence de style, genre de lignes </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_writeCount - Atomic::Fetch(&amp;_readCount)) &amp; (size_type)~(_mask)) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en particulier sa seconde moiti√© - c'est exactement ce que C est bl√¢m√©, et le langage lui-m√™me n'est pas √† bl√¢mer, il vous permet seulement d'√©crire ceci au lieu du plus compr√©hensible </font></font><br><br><pre> <code class="cpp hljs">size_type(~(_mask))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mais sans le forcer √† le faire. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PPS J'esp√®re que l'auteur de la biblioth√®que accepte de consid√©rer cette critique comme constructive et apportera les corrections appropri√©es. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438476/">https://habr.com/ru/post/fr438476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438466/index.html">B√©quille pour un laser chinois</a></li>
<li><a href="../fr438468/index.html">Colonie. Chapitre 23: Essai routier</a></li>
<li><a href="../fr438470/index.html">Ventes mondiales en d√©cembre et 2018: 2 millions de v√©hicules √©lectriques rechargeables vendus</a></li>
<li><a href="../fr438472/index.html">Environnement architectural modulaire sophistiqu√© dans UE4</a></li>
<li><a href="../fr438474/index.html">Courier: Migration de Dropbox vers gRPC</a></li>
<li><a href="../fr438478/index.html">GitLab 11.7 publi√© avec des versions, des √©pop√©es imbriqu√©es √† plusieurs niveaux et le registre des packages NPM</a></li>
<li><a href="../fr438480/index.html">Placez-le correctement: 7 endroits id√©aux pour placer du contenu vid√©o</a></li>
<li><a href="../fr438482/index.html">R√©putation, travail et √©migration: comment utiliser les outils de promotion de l'entreprise pour r√©soudre des probl√®mes personnels</a></li>
<li><a href="../fr438486/index.html">Carte m√©moire imp√©n√©trable - noie, g√®le et met le feu au Kingston microSD High Endurance</a></li>
<li><a href="../fr438490/index.html">Version b√™ta d'Unity 2019.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>