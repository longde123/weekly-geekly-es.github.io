<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèª üë©üèº‚Äçüç≥ üòπ Gestion de la m√©moire Python üë©üèæ üåç üêÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous √™tes-vous d√©j√† demand√© √† quoi ressemblent les donn√©es avec lesquelles vous travaillez dans les entrailles de Python? √Ä propos de la fa√ßon dont le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gestion de la m√©moire Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441568/">  Vous √™tes-vous d√©j√† demand√© √† quoi ressemblent les donn√©es avec lesquelles vous travaillez dans les entrailles de Python?  √Ä propos de la fa√ßon dont les variables sont cr√©√©es et stock√©es en m√©moire?  Comment et quand sont-ils retir√©s?  Le mat√©riel, dont nous publions la traduction, est consacr√© √† la recherche dans les profondeurs de Python, au cours de laquelle nous essaierons de d√©couvrir les caract√©ristiques de la gestion de la m√©moire dans ce langage.  Apr√®s avoir √©tudi√© cet article, vous comprendrez comment fonctionnent les m√©canismes de bas niveau des ordinateurs, en particulier ceux li√©s √† la m√©moire.  Vous comprendrez comment Python r√©sume les op√©rations de bas niveau et comment il g√®re la m√©moire. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/ok/qc/59/okqc59rnficniaz3pfcaaae5onc.jpeg"></a> <br><br>  Savoir ce qui se passe en Python vous permettra de mieux comprendre certains comportements de ce langage.  J'esp√®re que cela vous donnera l'occasion d'appr√©cier l'√©norme travail qui est fait dans la mise en ≈ìuvre de ce langage que vous utilisez pour que vos programmes fonctionnent exactement comme vous en avez besoin. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">La m√©moire est un livre vide</font> </h2><br>  La m√©moire de l'ordinateur, au tout d√©but de son utilisation, peut √™tre repr√©sent√©e sous la forme d'un livre vide destin√© √† des histoires courtes.  Bien qu'il n'y ait rien sur ses pages, mais tr√®s bient√¥t des auteurs d'histoires appara√Ætront, chacun voulant √©crire sa propre histoire dans ce livre. <br><br>  Puisqu'une histoire ne peut pas √™tre √©crite au-dessus d'une autre, les auteurs doivent faire attention aux pages du livre sur lesquelles ils √©crivent.  Avant d'√©crire quoi que ce soit, ils consultent le r√©dacteur en chef.  Il d√©cide o√π exactement les auteurs peuvent enregistrer des histoires. <br><br>  √âtant donn√© que le livre dont nous parlons existe depuis un certain temps, de nombreuses histoires qu'il contient sont d√©j√† d√©pass√©es.  Si personne ne lit une histoire ou ne la mentionne dans ses ≈ìuvres, cette histoire est supprim√©e du livre, laissant place √† de nouvelles histoires. <br><br>  En g√©n√©ral, nous pouvons dire que la m√©moire de l'ordinateur est tr√®s similaire √† un tel livre.  En fait, des blocs continus de m√©moire d'une longueur fixe sont m√™me appel√©s pages, nous pensons donc que la comparaison de la m√©moire avec un livre est tr√®s r√©ussie. <br><br>  Les auteurs qui √©crivent leurs histoires dans un livre sont diff√©rentes applications ou processus qui doivent stocker des donn√©es en m√©moire.  Le r√©dacteur en chef, qui d√©cide sur quelles pages du livre les auteurs peuvent √©crire, est le m√©canisme qui traite de la gestion de la m√©moire.  Et celui qui supprime les vieilles histoires du livre, faisant de la place pour les nouvelles, peut √™tre compar√© au m√©canisme de collecte des ordures. <br><br><h2>  <font color="#3AC1EF">Gestion de la m√©moire: le chemin du fer aux programmes</font> </h2><br>  La gestion de la m√©moire est un processus au cours duquel les programmes √©crivent des donn√©es dans la m√©moire et les lisent.  Un gestionnaire de m√©moire est une entit√© qui d√©termine o√π exactement une application peut placer ses donn√©es en m√©moire.  √âtant donn√© que le nombre de fragments de m√©moire pouvant √™tre allou√©s aux applications n'est pas infini, tout comme le nombre de pages dans un livre n'est pas infini, le gestionnaire de m√©moire, au service des applications, doit trouver des fragments de m√©moire libres et les fournir aux applications.  Ce processus, dans lequel la m√©moire est allou√©e aux applications, est appel√© allocation de m√©moire. <br><br>  En revanche, lorsque certaines donn√©es ne sont plus n√©cessaires, elles peuvent √™tre supprim√©es ou, en d'autres termes, lib√©rer la m√©moire qu'elles occupent.  Mais qu'est-ce qu'ils ¬´isolent¬ª et ¬´lib√®rent¬ª exactement en parlant de m√©moire? <br><br>  Quelque part sur votre ordinateur, il existe un p√©riph√©rique physique qui stocke les donn√©es utilis√©es par les programmes Python pendant leur fonctionnement.  Avant qu'un objet Python n'apparaisse dans la m√©moire physique, le code doit passer par plusieurs couches d'abstraction. <br><br>  L'une des principales couches de ce type, situ√©e au-dessus du mat√©riel (comme la RAM ou le disque dur) est le syst√®me d'exploitation (OS).  Il ex√©cute (ou refuse de r√©pondre) aux demandes de lecture des donn√©es de la m√©moire et d'√©criture des donn√©es dans la m√©moire. <br><br>  Il existe une application au-dessus du syst√®me d'exploitation, dans notre cas, l'une des impl√©mentations de Python (il peut s'agir d'un progiciel qui fait partie de votre syst√®me d'exploitation ou qui est t√©l√©charg√© depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">python.org</a> ).  C'est ce progiciel qui est engag√© dans la gestion de la m√©moire, assurant le fonctionnement de votre code Python.  Cet article se concentre sur les algorithmes et les structures de donn√©es que Python utilise pour g√©rer la m√©moire. <br><br><h2>  <font color="#3AC1EF">Impl√©mentation de r√©f√©rence Python</font> </h2><br>  L'impl√©mentation de r√©f√©rence Python est appel√©e CPython.  Il est √©crit en C. Lorsque j'en ai entendu parler pour la premi√®re fois, cela m'a litt√©ralement perturb√©.  Un langage de programmation √©crit dans un autre langage?  Eh bien, en fait, ce n'est pas enti√®rement vrai. <br><br>  La sp√©cification Python est d√©crite en anglais simple dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce document</a> .  Cependant, cette sp√©cification seule, le code √©crit en Python, bien s√ªr, ne peut pas s'ex√©cuter.  Pour ce faire, vous avez besoin de quelque chose qui, suivant les r√®gles de cette sp√©cification, peut interpr√©ter le code √©crit en Python. <br><br>  De plus, vous avez besoin de quelque chose qui puisse ex√©cuter le code interpr√©t√© sur l'ordinateur.  L'impl√©mentation de r√©f√©rence Python r√©sout ces deux t√¢ches.  Il convertit le code en instructions qui sont ensuite ex√©cut√©es sur la machine virtuelle. <br><br>  Les machines virtuelles sont similaires aux ordinateurs ordinaires en silicium, m√©tal et autres mat√©riaux, mais elles sont impl√©ment√©es dans un logiciel.  Ils sont g√©n√©ralement occup√©s √† traiter des instructions de base, similaires aux instructions √©crites dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Assembler</a> . <br><br>  Python est un langage interpr√©t√©.  Le code √©crit en Python est compil√© en un ensemble d'instructions pratiques pour l'ordinateur, dans ce que l'on appelle le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code d'octets</a> .  Ces instructions sont interpr√©t√©es par la machine virtuelle lorsque vous ex√©cutez votre programme. <br><br>  Avez-vous d√©j√† vu des fichiers avec l'extension <code>.pyc</code> ou le dossier <code>__pycache__</code> ?  Ils contiennent le m√™me bytecode qui est interpr√©t√© par la machine virtuelle. <br><br>  Il est important de noter qu‚Äôen plus de CPython, il existe d‚Äôautres impl√©mentations Python.  Par exemple, lorsque vous utilisez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IronPython,</a> le code Python est compil√© dans une instruction Microsoft CLR.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jython, le</a> code est compil√© en bytecode Java et ex√©cut√© dans une machine virtuelle Java.  Dans le monde Python, il existe une chose telle que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PyPy</a> , mais elle m√©rite un article s√©par√©, alors ici nous venons de le mentionner. <br><br>  Aux fins de cet article, je me concentrerai sur le fonctionnement des m√©canismes de gestion de la m√©moire dans l'impl√©mentation de r√©f√©rence Python - CPython. <br><br>  Il convient de noter que bien que la plupart de ce dont nous allons parler ici soit vrai pour les nouvelles versions de Python, les choses peuvent changer √† l'avenir.  Par cons√©quent, faites attention au fait que dans cet article, je me concentre sur la derni√®re version de Python au moment de la r√©daction - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Python 3.7</a> . <br><br>  Ainsi, le progiciel CPython est √©crit en C, il interpr√®te le bytecode Python.  Qu'est-ce que cela a √† voir avec la gestion de la m√©moire?  Le fait est que les algorithmes et les structures de donn√©es utilis√©s pour la gestion de la m√©moire existent dans du code CPython √©crit, comme d√©j√† mentionn√©, en C.Pour comprendre comment fonctionne la gestion de la m√©moire en Python, vous devez d'abord comprendre un peu le CPython. <br><br>  Le langage C dans lequel CPython est √©crit n'a pas de support int√©gr√© pour la programmation orient√©e objet.  Pour cette raison, de nombreuses solutions architecturales int√©ressantes sont utilis√©es dans le code CPython. <br><br>  Vous avez peut-√™tre entendu dire que tout en Python est un objet, m√™me les types de donn√©es primitifs comme <code>int</code> et <code>str</code> .  Et c'est effectivement le cas au niveau de l'impl√©mentation du langage dans CPython.  Il existe une structure appel√©e <code>PyObject</code> , qui est utilis√©e par les objets cr√©√©s dans CPython. <br><br>  Une structure est un type de donn√©es composite qui peut regrouper des donn√©es de diff√©rents types.  Si vous comparez cela √† une programmation orient√©e objet, la structure est similaire √† une classe qui a des attributs mais pas de m√©thodes. <br><br>  <code>PyObject</code> est l'anc√™tre de tous les objets Python.  Cette structure ne contient que deux champs: <br><br><ul><li>  <code>ob_refcnt</code> - compteur de r√©f√©rences. </li><li>  <code>ob_type</code> - pointeur vers un autre type. </li></ul><br>  Le compteur de r√©f√©rence est utilis√© pour impl√©menter le m√©canisme de r√©cup√©ration de place.  Un autre champ <code>PyObject</code> est un pointeur sur un type d'objet sp√©cifique.  Ce type est repr√©sent√© par une autre structure qui d√©crit l'objet Python (par exemple, il peut s'agir d'un type <code>dict</code> ou <code>int</code> ). <br><br>  Chaque objet a son propre m√©canisme d'allocation de m√©moire, unique pour un tel objet, qui sait comment obtenir la m√©moire n√©cessaire pour stocker cet objet.  De plus, chaque objet poss√®de son propre m√©canisme de lib√©ration de m√©moire, qui ¬´lib√®re¬ª la m√©moire lorsqu'elle n'est plus n√©cessaire. <br><br>  Cependant, il convient de noter que dans toutes ces conversations sur l'allocation et la lib√©ration de m√©moire, il y a un facteur important.  Le fait est que la m√©moire de l'ordinateur est une ressource partag√©e.  Si, en m√™me temps, deux processus diff√©rents essaient d'√©crire quelque chose dans la m√™me zone de m√©moire, quelque chose de mauvais peut se produire. <br><br><h2>  <font color="#3AC1EF">Interpr√®te Global Lock</font> </h2><br>  Global Interpreter Lock (GIL) est une solution √† un probl√®me courant qui se produit lorsque vous travaillez avec des ressources informatiques partag√©es telles que la m√©moire.  Lorsque deux threads tentent de modifier simultan√©ment la m√™me ressource, ils peuvent ¬´entrer en collision¬ª l'un avec l'autre.  Le r√©sultat sera un g√¢chis et aucun des flux n'atteindra ses objectifs. <br><br>  Revenons √† l'analogie du livre.  Imaginez que deux auteurs aient d√©cid√© arbitrairement que maintenant c'√©tait √† leur tour de prendre des notes.  Mais ils ont √©galement d√©cid√© de prendre des notes simultan√©ment sur la m√™me page. <br><br>  Chacun d'eux ne fait pas attention au fait que l'autre essaie d'√©crire son histoire.  Ensemble, ils commencent √† √©crire du texte sur la page.  En cons√©quence, deux histoires y seront enregistr√©es, l'une au-dessus de l'autre, ce qui rendra la page compl√®tement illisible. <br><br>  L'une des solutions √† ce probl√®me est un m√©canisme d'interpr√©teur global unique qui bloque les ressources partag√©es avec lesquelles un certain thread travaille.  Dans notre exemple, il s'agit d'un ¬´m√©canisme¬ª qui ¬´bloque¬ª la page d'un livre.  Un tel m√©canisme √©limine la situation d√©crite ci-dessus, dans laquelle deux auteurs √©crivent simultan√©ment du texte sur la m√™me page. <br><br>  Le m√©canisme GIL en Python accomplit cela en bloquant l'int√©gralit√© de l'interpr√©teur.  Par cons√©quent, rien ne peut interf√©rer avec le fonctionnement du thread actuel.  Et lorsque CPython travaille avec de la m√©moire, il utilise le GIL pour s'assurer que ce travail est effectu√© en toute s√©curit√© et efficacement. <br><br>  Il y a des forces et des faiblesses √† cette approche, et le GIL fait l'objet d'un d√©bat acharn√© dans la communaut√© Python.  Pour en savoir plus sur GIL, vous pouvez consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce mat√©riel</a> . <br><br><h2>  <font color="#3AC1EF">Collecte des ordures</font> </h2><br>  Revenons √† l'analogie du livre et imaginons que certaines des histoires enregistr√©es dans ce livre sont d√©sesp√©r√©ment obsol√®tes.  Personne ne les lit, personne ne les mentionne nulle part.  Et si personne ne lit ou ne se r√©f√®re √† certains documents dans leurs ≈ìuvres, alors ces documents peuvent √™tre √©limin√©s, laissant la place √† de nouveaux textes. <br><br>  Ces vieux contes oubli√©s peuvent √™tre compar√©s √† des objets Python dont le nombre de r√©f√©rences est nul.  Ce sont les m√™mes compteurs dont nous avons parl√© lors de la discussion sur la structure <code>PyObject</code> . <br><br>  Le compteur de liens est incr√©ment√© pour plusieurs raisons.  Par exemple, le compteur est incr√©ment√© si l'objet stock√© dans une variable est √©crit dans une autre variable: <br><br><pre> <code class="python hljs">numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   = 1 more_numbers = numbers #   = 2</span></span></code> </pre> <br>  Il augmente lorsque l'objet est pass√© √† une fonction en tant qu'argument: <br><br><pre> <code class="python hljs">total = sum(numbers)</code> </pre> <br>  Et voici un autre exemple d'une situation dans laquelle le nombre dans le compteur de r√©f√©rence augmente.  Cela se produit si l'objet est inclus dans la liste: <br><br><pre> <code class="python hljs">matrix = [numbers, numbers, numbers]</code> </pre> <br>  Python permet au programmeur de d√©couvrir la valeur actuelle du compte de r√©f√©rence d'un certain objet en utilisant le module <code>sys</code> .  Pour cela, la construction suivante est utilis√©e: <br><br><pre> <code class="python hljs">sys.getrefcount(numbers)</code> </pre> <br>  <code>getfefcount()</code> , vous devez vous rappeler que le passage d'un objet √† la m√©thode <code>getfefcount()</code> augmente la valeur du compteur de 1. <br><br>  Dans tous les cas, si l'objet est toujours utilis√© quelque part dans le code, son compteur de r√©f√©rence sera sup√©rieur √† 0. Lorsque la valeur du compteur chute √† 0, une fonction sp√©ciale entre en jeu, ce qui "lib√®re" la m√©moire occup√©e par l'objet.  Cette m√©moire peut ensuite √™tre utilis√©e par d'autres objets. <br><br>  Nous nous posons maintenant des questions sur ce qu'est la ¬´lib√©ration de m√©moire¬ª et sur la mani√®re dont d'autres objets peuvent utiliser cette m√©moire.  Afin de r√©pondre √† ces questions, parlons des m√©canismes de gestion de la m√©moire dans CPython. <br><br><h2>  <font color="#3AC1EF">M√©canismes de gestion de la m√©moire dans CPython</font> </h2><br>  Nous allons maintenant parler de la fa√ßon dont CPython poss√®de une architecture de m√©moire et de la fa√ßon dont la gestion de la m√©moire s'y fait. <br><br>  Comme d√©j√† mentionn√©, il existe plusieurs couches d'abstraction entre CPython et la m√©moire physique.  Le syst√®me d'exploitation extrait la m√©moire physique et cr√©e une couche de m√©moire virtuelle avec laquelle les applications peuvent travailler (cela s'applique √©galement √† Python). <br><br>  Le gestionnaire de m√©moire virtuelle d'un syst√®me d'exploitation sp√©cifique alloue un morceau de m√©moire pour le processus Python.  Les zones gris fonc√© dans l'image suivante sont les morceaux de m√©moire qui appartiennent au processus Python. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/f01/548/e51f0154800b0ae223bf1c7d96f5bab8.png"><br>  <i><font color="#999999">Zones de m√©moire utilis√©es par CPython</font></i> <br><br>  Python utilise une certaine quantit√© de m√©moire pour un usage interne et pour des besoins non li√©s √† l'allocation de m√©moire aux objets.  Un autre morceau de m√©moire est utilis√© pour stocker des objets (ce sont des valeurs de types <code>int</code> , <code>dict</code> et autres comme √ßa).  Veuillez noter qu'il s'agit d'un sch√©ma simplifi√©.  Si vous voulez voir l'image compl√®te, jetez un oeil au code source de <a href="">CPython</a> , o√π tout ce dont nous parlons se passe. <br><br>  CPython dispose d'une fonction d'allocation de m√©moire pour les objets, qui est responsable de l'allocation de m√©moire dans la zone destin√©e au stockage des objets.  La chose la plus int√©ressante se produit lorsque ce m√©canisme fonctionne.  Elle est appel√©e lorsque l'objet a besoin de m√©moire ou dans les cas o√π la m√©moire doit √™tre lib√©r√©e. <br><br>  En r√®gle g√©n√©rale, l'ajout ou la suppression de donn√©es √† des objets Python tels que <code>list</code> et <code>int</code> n'implique pas le traitement simultan√© de tr√®s grandes quantit√©s d'informations.  Par cons√©quent, l'architecture de l'outil d'allocation de m√©moire est con√ßue en tenant compte du traitement de petites quantit√©s de donn√©es.  De plus, cet outil cherche √† ne pas allouer de m√©moire jusqu'√† ce qu'il devienne clair qu'elle est absolument n√©cessaire. <br><br>  Les commentaires dans le <a href="">code source</a> d√©crivent l'outil d'allocation de m√©moire comme "un outil d'allocation de m√©moire rapide et sp√©cialis√© pour les petits blocs qui est con√ßu pour √™tre utilis√© au-dessus du malloc universel."  Dans ce cas, <code>malloc</code> est une fonction de biblioth√®que C con√ßue pour allouer de la m√©moire. <br><br>  Discutons de la strat√©gie d'allocation de m√©moire utilis√©e par CPython.  Tout d'abord, nous parlerons de trois entit√©s - les soi-disant blocs (blocs), les piscines (pools) et les ar√®nes (ar√®ne), et comment ils sont li√©s les uns aux autres. <br><br>  Les ar√®nes sont les plus grands fragments de m√©moire.  Ils sont align√©s sur les bordures des pages de m√©moire.  La limite de page est l'endroit o√π le bloc continu de m√©moire de longueur fixe finit par √™tre utilis√© par le syst√®me d'exploitation.  Python, tout en travaillant avec la m√©moire, suppose que la taille de la page de m√©moire syst√®me est de 256 Ko. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75e/4d2/dc2/75e4d2dc2e0f6985363952432b7c169d.png"><br>  <i><font color="#999999">Ar√©nas, piscines et blocs</font></i> <br><br>  Les pools sont situ√©s sur les ar√®nes, qui sont des pages de m√©moire virtuelle de 4 Ko.  Ils ressemblent aux pages du livre de notre exemple.  Les pools sont divis√©s en petits blocs de m√©moire. <br><br>  Tous les blocs d'un m√™me pool appartiennent √† la m√™me classe de taille.  La classe de taille √† laquelle appartient le bloc d√©termine la taille de ce bloc, qui est s√©lectionn√©e en tenant compte de la taille de m√©moire demand√©e.  Voici un tableau extrait du code source qui montre la quantit√© de donn√©es que le syst√®me demande de stocker en m√©moire, les tailles des blocs allou√©s et les identificateurs des classes de taille. <br><table><tbody><tr><td>  La quantit√© de donn√©es en octets <br></td><td>  Taille de bloc <br></td><td>  taille de la classe idx <br></td></tr><tr><td>  1-8 <br></td><td>  8 <br></td><td>  0 <br></td></tr><tr><td>  9-16 <br></td><td>  16 <br></td><td>  1 <br></td></tr><tr><td>  17-24 <br></td><td>  24 <br></td><td>  2 <br></td></tr><tr><td>  25-32 <br></td><td>  32 <br></td><td>  3 <br></td></tr><tr><td>  33-40 <br></td><td>  40 <br></td><td>  4 <br></td></tr><tr><td>  41-48 <br></td><td>  48 <br></td><td>  5 <br></td></tr><tr><td>  49-56 <br></td><td>  56 <br></td><td>  6 <br></td></tr><tr><td>  57-64 <br></td><td>  64 <br></td><td>  7 <br></td></tr><tr><td>  65-72 <br></td><td>  72 <br></td><td>  8 <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td></tr><tr><td>  497-504 <br></td><td>  504 <br></td><td>  62 <br></td></tr><tr><td>  505-512 <br></td><td>  512 <br></td><td>  63 <br></td></tr></tbody></table><br>  Par exemple, si 42 octets doivent √™tre stock√©s, les donn√©es seront plac√©es dans un bloc de 48 octets. <br><br><h2>  <font color="#3AC1EF">Piscines</font> </h2><br>  Les pools sont constitu√©s de blocs appartenant √† la m√™me classe de taille.  Chaque pool est associ√© √† d'autres pools contenant des blocs de la m√™me classe de taille √† l'aide du m√©canisme de liste doublement li√©.  Avec cette approche, l'algorithme d'allocation de m√©moire peut facilement trouver de l'espace libre pour un bloc d'une taille donn√©e, m√™me s'il s'agit de trouver de l'espace libre dans diff√©rents pools. <br><br>  La liste des <code>usedpools</code> vous permet de garder une trace de tous les pools dans lesquels il y a de la place pour les donn√©es appartenant √† une classe de taille particuli√®re.  Lorsqu'il est demand√© d'enregistrer un bloc d'une certaine taille, l'algorithme recherche dans cette liste une liste de pools qui stockent des blocs de la taille requise. <br><br>  Les piscines elles-m√™mes doivent √™tre dans l'un des trois √©tats.  √Ä savoir, ils peuvent √™tre utilis√©s (√©tat <code>used</code> ), ils peuvent √™tre remplis ( <code>full</code> ) ou vides ( <code>empty</code> ).  Le pool utilis√© a des blocs libres dans lesquels il est possible d'enregistrer des donn√©es d'une taille appropri√©e.  Tous les blocs du pool rempli sont allou√©s pour les donn√©es.  Un pool vide ne contient aucune donn√©e et, si n√©cessaire, il peut √™tre affect√© √† des blocs de stockage appartenant √† n'importe quelle classe de taille. <br><br>  La liste <code>freepools</code> stocke des informations sur tous les pools qui sont √† l'√©tat <code>empty</code> .  Par exemple, s'il n'y a aucune entr√©e dans la liste des pools <code>usedpools</code> sur les pools stockant des blocs de 8 octets (classe avec idx 0), un nouveau pool est initialis√©, qui est √† l'√©tat <code>empty</code> , con√ßu pour stocker de tels blocs.  Ce nouveau pool est ajout√© √† la liste des <code>usedpools</code> , il peut √™tre utilis√© pour r√©pondre aux demandes de sauvegarde des donn√©es re√ßues apr√®s sa cr√©ation. <br><br>  Supposons que dans un pool √† l'√©tat <code>full</code> , certains blocs soient lib√©r√©s.  Cela est d√ª au fait que les donn√©es qui y sont stock√©es ne sont plus n√©cessaires.  Ce pool sera √† nouveau dans la liste des <code>usedpools</code> et il peut √™tre utilis√© pour les donn√©es de la classe de taille correspondante. <br><br>  La connaissance de cet algorithme nous permet de comprendre comment l'√©tat des pools change pendant le fonctionnement (et comment les classes de taille changent, les blocs auxquels ils peuvent √™tre stock√©s). <br><br><h2>  <font color="#3AC1EF">Blocs</font> </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/627/407/ef5/627407ef5dafac3533d81ae0beec66f2.png"><br>  <i><font color="#999999">Piscines utilis√©es, pleines et vides</font></i> <br><br>  Comme vous pouvez le voir sur l'illustration pr√©c√©dente, les pools contiennent des pointeurs vers les blocs de m√©moire "libres" qu'ils contiennent.  En ce qui concerne le travail avec des blocs, une petite caract√©ristique doit √™tre not√©e, qui est indiqu√©e dans le code source.  Le syst√®me de gestion de la m√©moire utilis√© dans CPython, √† tous les niveaux (ar√©nas, pools, blocs), s'efforce d'allouer de la m√©moire uniquement lorsque cela est absolument n√©cessaire. <br><br>  Cela signifie que les pools peuvent contenir des blocs dans l'un des trois √©tats suivants: <br><br><ul><li>  <code>untouched</code> est la partie de la m√©moire qui n'a pas encore √©t√© allou√©e. </li><li>  <code>free</code> - la partie de la m√©moire qui √©tait d√©j√† allou√©e, mais qui a ensuite √©t√© rendue ¬´libre¬ª par CPython et ne contient plus de donn√©es pr√©cieuses. </li><li>  <code>allocated</code> est la partie de la m√©moire qui contient des donn√©es pr√©cieuses. </li></ul><br>  Le pointeur <code>freeblock</code> pointe vers une liste li√©e individuellement de blocs de m√©moire libres.  En d'autres termes, il s'agit d'une liste d'endroits o√π vous pouvez mettre des donn√©es.  Si plusieurs blocs libres sont n√©cessaires pour placer des donn√©es, l'outil d'allocation de m√©moire prendra plusieurs blocs du pool qui sont dans un √©tat <code>untouched</code> . <br><br>  Comme l'outil de gestion de la m√©moire rend les blocs ¬´libres¬ª, ils, lorsqu'ils acqui√®rent l'√©tat <code>free</code> , arrivent en haut de la liste des <code>freeblock</code> .  Les blocs contenus dans cette liste ne repr√©sentent pas n√©cessairement une r√©gion de m√©moire contigu√´ similaire √† celle repr√©sent√©e sur la figure pr√©c√©dente.  Ils peuvent en fait ressembler √† celui ci-dessous. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cca/0c7/725/cca0c7725ce480809ee3d59b4a1b28fa.png"><br>  <i><font color="#999999">Liste de blocs libres li√©e unique</font></i> <br><br><h2>  <font color="#3AC1EF">Ar√®nes</font> </h2><br>  Les ar√®nes contiennent des piscines.  Ces pools, comme d√©j√† mentionn√©, peuvent r√©sider dans les √©tats <code>used</code> , <code>full</code> ou <code>empty</code> .  Il convient de noter que les ar√©nas n'ont pas d'√©tats similaires √† ceux des piscines. <br><br>  Les ar√©nas sont organis√©s en une liste doublement li√©e appel√©e <code>usable_arenas</code> .  Cette liste est tri√©e selon le nombre de pools gratuits disponibles.  Moins il y a de piscines gratuites dans l'ar√®ne, plus l'ar√®ne est proche du haut de la liste. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f91/17d/6f1/f9117d6f1b6670afd7235a2efc936713.png"><br>  <i><font color="#999999">Liste des ar√©nas utilisables</font></i> <br><br>  Cela signifie que l'ar√®ne, qui est plus forte que d'autres remplies de donn√©es, sera s√©lectionn√©e pour y placer de nouvelles donn√©es.  Et pourquoi pas l'inverse?  Pourquoi ne pas publier de nouvelles donn√©es dans l'ar√®ne avec l'espace le plus libre? <br><br>  En fait, cette fonctionnalit√© nous am√®ne √† l'id√©e de vraiment lib√©rer de la m√©moire.  Vous avez peut-√™tre remarqu√© que nous avons souvent utilis√© ici le concept de ¬´lib√©ration de m√©moire¬ª, en le mettant entre guillemets.  La raison pour laquelle cela a √©t√© fait est que bien que le bloc puisse √™tre consid√©r√© comme ¬´libre¬ª, le morceau de m√©moire qu'il repr√©sente n'est pas r√©ellement retourn√© au syst√®me d'exploitation.  Le processus Python contient ce morceau de m√©moire et l'utilise plus tard pour stocker de nouvelles donn√©es.  La v√©ritable lib√©ration de m√©moire est le retour √† son syst√®me d'exploitation, qui pourra l'utiliser. <br><br>  Les ar√®nes sont la seule entit√© du sch√©ma consid√©r√© ici, dont la m√©moire repr√©sent√©e peut √™tre v√©ritablement lib√©r√©e.  Le bon sens veut que le sch√©ma de travail avec les ar√®nes d√©crit ci-dessus vise √† permettre aux ar√®nes presque vides de se vider compl√®tement.  Avec cette approche, ce morceau de m√©moire repr√©sent√© par une ar√®ne compl√®tement vide peut √™tre vraiment lib√©r√©, ce qui r√©duira la quantit√© de m√©moire consomm√©e par Python. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Voici ce que vous avez appris en lisant ce document: <br><br><ul><li>  Qu'est-ce que la gestion de la m√©moire et pourquoi est-elle importante? </li><li>  Comment l'impl√©mentation de r√©f√©rence de Python, Cpython, √©crite dans le langage de programmation C est arrang√©e. </li><li>  Quelles structures de donn√©es et quels algorithmes sont utilis√©s dans CPython pour la gestion de la m√©moire. </li></ul><br>  La gestion de la m√©moire fait partie int√©grante du travail des programmes informatiques.  Python r√©sout presque toutes les t√¢ches de gestion de m√©moire inaper√ßues par le programmeur.  Python permet √† quiconque √©crit dans ce langage d'ignorer les nombreux petits d√©tails li√©s au travail avec les ordinateurs.  Cela donne au programmeur la possibilit√© de travailler √† un niveau sup√©rieur, de cr√©er son propre code sans se soucier de l'emplacement de stockage de ses donn√©es. <br><br>  <b>Chers lecteurs!</b>  Si vous avez de l'exp√©rience avec le d√©veloppement Python, dites-nous comment vous abordez l'utilisation de la m√©moire dans vos programmes.  Par exemple, cherchez-vous √† le sauvegarder? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441568/">https://habr.com/ru/post/fr441568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441550/index.html">La vie d'un simple programmeur est dure et simple</a></li>
<li><a href="../fr441554/index.html">Toute l'histoire de Linux. Partie I: comment tout a commenc√©</a></li>
<li><a href="../fr441560/index.html">√âv√©nements num√©riques √† Moscou du 25 f√©vrier au 3 mars</a></li>
<li><a href="../fr441562/index.html">Pixel Gallop - Cinqui√®me partie - Animation de personnages. Marcher</a></li>
<li><a href="../fr441566/index.html">12 concepts JavaScript √† conna√Ætre</a></li>
<li><a href="../fr441570/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 353 (17-24 f√©vrier 2019)</a></li>
<li><a href="../fr441572/index.html">Frontend Weekly Digest (18-24 f√©vrier 2019)</a></li>
<li><a href="../fr441574/index.html">Apprendre Docker Partie 6: Travailler avec des donn√©es</a></li>
<li><a href="../fr441576/index.html">R√©seaux Kubernetes: Pods</a></li>
<li><a href="../fr441578/index.html">Tutoriel React, partie 19: M√©thodes du cycle de vie des composants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>