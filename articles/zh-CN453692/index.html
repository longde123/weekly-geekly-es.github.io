<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽 😎 🌳 初学者3D游戏着色器：效果 🎩 👩🏼‍🍳 🧔🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ 第一部分 ] 

 在处理了基础知识之后，在本文的这一部分中，我们实现了诸如对象轮廓，光晕，SSAO，模糊，景深，像素化等效果。 

 概述 

 在场景的几何图形周围创建轮廓，使游戏具有类似于漫画或卡通的独特外观。 

 扩散材料 
 轮廓着色器需要输入纹理来识别和着色边缘。 此类传入纹理的候...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>初学者3D游戏着色器：效果</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453692/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> ] <br><br> 在处理了基础知识之后，在本文的这一部分中，我们实现了诸如对象轮廓，光晕，SSAO，模糊，景深，像素化等效果。 <br><br><h2> 概述 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/96f/9b2/3b896f9b246e1695fa908b4bdc145480.gif"></div><br> 在场景的几何图形周围创建轮廓，使游戏具有类似于漫画或卡通的独特外观。 <br><br><h3> 扩散材料 </h3><br> 轮廓着色器需要输入纹理来识别和着色边缘。 此类传入纹理的候选对象可以是材质的漫反射颜色，漫反射纹理的颜色，顶点法线，甚至可以是法线贴图的颜色。 <br><br><pre><code class="cpp hljs">uniform <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> vec4 diffuse ; } p3d_Material; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 diffuseColor = p3d_Material.diffuse.rgb; fragColor = vec4(diffuseColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br> 这是一个小的片段着色器，可将几何材料的漫反射颜色渲染到帧缓冲区纹理中。 来自帧缓冲区的漫反射色纹理将成为路径着色器的输入纹理。 <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0b/abd/05c/f0babd05caf7104156c15929995c9279.gif"></div><br> 这是帧缓冲区中材质的漫反射颜色的纹理，该纹理显示了我们在Blender中设置的颜色。 轮廓着色器将识别场景中的边缘并为其着色。 <br><br> 应该注意的是，如果场景的某些部分没有它们自己的材质的漫反射色，则材质的漫反射色将不起作用。 <br><br><h3> 创建边缘 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/a0d/57a/33aa0d57aeba90366ddd95865ea0d6c6.gif"></div><br> 创建边缘类似于在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GIMP中</a>使用边缘识别过滤器。 <br><br> 此着色技术的所有计算都在片段着色器中执行。 要为顶点着色器创建轮廓，只需将矩形网格的四个顶点传递到输出以适合屏幕即可。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D materialDiffuseTexture; // ... vec2 texSize = textureSize(materialDiffuseTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy; // ...</span></span></code> </pre> <br> 在开始识别边缘之前，您需要准备传入的纹理，我们将使用该纹理。 由于纹理具有屏幕大小，因此我们可以计算UV坐标，知道片段的坐标和传入纹理的大小。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int separation = 1; // ...</span></span></code> </pre> <br> 可以根据您的口味定制<code>separation</code> 。 间隔越大，边缘或线条越粗。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... vec4 mx = vec4(0); vec4 mn = vec4(1); int x = -1; int y = -1; for (int i = 0; i &lt; 9; ++i) { vec4 color = texture ( materialDiffuseTexture , (texCoord + (vec2(x, y) * separation)) / texSize ); mx = max(color, mx); mn = min(color, mn); x += 1; if (x &gt;= 2) { x = -1; y += 1; } } float alpha = ((mx.r + mx.g + mx.b) / 3) - ((mn.r + mn.g + mn.b) / 3); if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/d24/e56/42fd24e5682700e1e7cd5186bebc33af.gif"></div><br> 边缘识别技术可发现传入纹理的颜色变化。 着眼于当前片段，它使用3x3片段窗口查找九个样本中最亮和最暗的颜色。 然后，她从一种颜色的亮度中减去另一种颜色的亮度，得到它们的差值。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lineRgb = vec3(0.012, 0.014, 0.022); // ... vec4 lineColor = vec4(lineRgb, alpha); // ... fragColor = lineColor; // ...</span></span></code> </pre> <br> 此差异用于输出颜色的Alpha通道。 如果没有差异，则不会绘制边缘或线条。 如果存在差异，则绘制边缘。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float threshold = 0; // ... if (alpha &gt; threshold) { alpha = 1; } // ...</span></span></code> </pre> <br> 尝试试验阈值。 现在为零。 任何非零值都将成为边；可以更改此阈值。 这对于差异较小的噪声较大的传入纹理特别有用。 对于嘈杂的传入纹理，通常只需要为较大的差异创建轮廓。 <br><br><h3> 源代码 </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">物质扩散碎片</a> </li><li>  <a href="">轮廓片段</a> </li></ul><br><h2> 雾气 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/02c/e52/5af02ce52f813b27461f79e5dca5fe20.gif"></div><br> 雾（或薄雾，在Blender中被称为雾）在场景中增添了大气的阴霾，创造出神秘而柔软的突出部分。 当某些几何形状突然落入相机可见性金字塔时，会出现突出部分。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_FogParameters { vec4 color ; float start ; float end ; } p3d_Fog; // ...</span></span></code> </pre> <br>  Panda3D具有方便的数据结构，其中包含所有雾参数，但是您可以将其手动传输到着色器。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float fogIntensity = clamp ( ( p3d_Fog.end - vertexPosition.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; // ...</span></span></code> </pre> <br> 在该代码示例中，线性模型用于计算从相机移开时雾的亮度。 相反，您可以使用指数模型。 雾的亮度在雾开始之前或开始时为零。 当顶点位置接近雾的末端时，雾<code>fogIntensity</code>接近统一。 对于雾结束后的所有顶点，从上方将雾<code>fogIntensity</code>限制为1。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = mix ( outputColor , p3d_Fog.color , fogIntensity ); // ...</span></span></code> </pre> <br> 根据雾的亮度，我们将雾的颜色与输出颜色混合。 随着<code>fogIntensity</code>趋于一致，将会有越来越少的<code>outputColor</code>和越来越多的雾色。 当<code>fogIntensity</code>达到单位时，将仅保留雾的颜色。 <br><br><h3> 轮廓上的雾 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/ee8/d49/e1fee8d490abe10ecb798df618f183f7.gif"></div><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D positionTexture; // ... vec4 position = texture(positionTexture, texCoord / texSize); float fogIntensity = clamp ( ( p3d_Fog.end - position.y) / ( p3d_Fog.end - p3d_Fog.start) , 0 , 1 ); fogIntensity = 1 - fogIntensity; vec4 lineWithFogColor = mix ( lineColor , p3d_Fog.color , fogIntensity ); fragColor = vec4(lineWithFogColor.rgb, alpha); // ...</span></span></code> </pre> <br> 路径着色器将雾化到边缘的颜色，以获得更整体的图像。 如果他不这样做，轮廓的几何形状将被雾遮盖，这看起来很奇怪。 但是，他仍然使用铣刀在舞台几何图形的最外边缘上创建轮廓，因为这些边缘超出了几何图形-到达了没有顶点位置的位置。 <br><br>  <code>positionTexture</code>是一个帧缓冲区纹理，其中包含视图空间的顶点位置。 当我们实现SSAO着色器时，您将了解到这一点。 <br><br><h3> 源代码 </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">基本片段</a> </li><li>  <a href="">轮廓片段</a> </li></ul><br><h2> 布卢姆 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/744/f35/31d744f35168ac87f609474998802b12.gif"></div><br> 向场景中添加花开可以使照明模型产生令人信服的幻觉。 发光物体变得更有说服力，并且光反射会接收到更多的辐射。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//... float separation = 3; int samples = 15; float threshold = 0.5; float amount = 1; // ...</span></span></code> </pre> <br> 您可以根据自己的喜好自定义这些设置。 分离会增加模糊的大小。 样本确定模糊的强度。 阈值确定此影响将影响什么和将不会受到什么影响。 数量控制光晕输出的量。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int size = samples; int size2 = size * size; int x = 0; int y = 0; // ... float value = 0; vec4 result = vec4(0); vec4 color = vec4(0); // ... for (int i = 0; i &lt; size2; ++i) { // ... } // ...</span></span></code> </pre> <br> 该技术首先将窗口大小的<code>samples</code>传递到相对于当前片段居中的<code>samples</code>上。 它看起来像一个用于创建路径的窗口。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... color = texture ( bloomTexture , ( gl_FragCoord.xy + vec2(x * separation, y * separation) ) / texSize ); value = ((0.3 * color.r) + (0.59 * color.g) + (0.11 * color.b)); if (value &lt; threshold) { color = vec4(0); } result += color; // ...</span></span></code> </pre> <br> 此代码从传入的纹理获取颜色，并将红色，绿色和蓝色的值转换为灰度值。 如果灰度值小于阈值，则它将丢弃此颜色，使其变为黑色。 <br><br> 通过窗口中的所有样本，它将所有<code>result</code>值累加。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... result = result / size2; // ...</span></span></code> </pre> <br> 完成样本收集后，他将颜色样本的总和除以所采样的数目。 结果是片段本身及其邻居的中间颜色。 通过对每个片段执行此操作，我们得到了模糊的图像。 这种模糊称为框模糊。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f90/16f/ea4/f9016fea492bc7b136ef6437a683c937.gif"></div><br> 在这里，您将看到执行Bloom算法的过程。 <br><br><h3> 源代码 </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">Bloom.frag</a> </li></ul><br><h2> 屏幕空间环境光遮蔽（SSAO） </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/5ab/5bf/f935ab5bf4794caae3be90b611ad771c.gif"></div><br>  SSAO是您不知道存在的那些影响之一，但是一旦您知道它们就无法生存。 他可以将平庸的场景变成令人惊叹的场景！ 在静态场景中，可以将环境光遮挡烘焙到纹理中，但是对于更多动态场景，我们需要一个着色器。  SSAO是更复杂的着色技术之一，但是一旦弄清楚了，您将成为高级着色器。 <br><br> 请注意，标题中的“屏幕空间”一词并不完全正确，因为并非所有计算都在屏幕空间中执行。 <br><br><h3> 传入数据 </h3><br>  SSAO着色器将需要以下输入。 <br><br><ul><li> 可视空间中顶点位置的向量。 </li><li> 视空间中顶点的法线向量。 </li><li> 切线空间中的样本向量。 </li><li> 切线空间中的噪声向量。 </li><li> 相机镜头上的投影矩阵。 </li></ul><br><h3> 位置 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/f36/d42/2d2f36d425c2596288d8982158687354.png"></div><br> 不必将顶点位置存储在帧缓冲区纹理中。 我们可以从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">相机深度缓冲区</a>重新创建它们。 我正在为初学者编写指南，因此我们将不会使用此优化，而是立即着手开展业务。 在您的实现中，您可以轻松使用深度缓冲区。 <br><br><pre> <code class="cpp hljs">PT(Texture) depthTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture(<span class="hljs-string"><span class="hljs-string">"depthTexture"</span></span>); depthTexture-&gt;set_format(Texture::Format::F_depth_component32); PT(GraphicsOutput) depthBuffer = graphicsOutput-&gt;make_texture_buffer(<span class="hljs-string"><span class="hljs-string">"depthBuffer"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, depthTexture); depthBuffer-&gt;set_clear_color(LVecBase4f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); NodePath depthCameraNP = window-&gt;make_camera(); DCAST(Camera, depthCameraNP.node())-&gt;set_lens(window-&gt;get_camera(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;get_lens()); PT(DisplayRegion) depthBufferRegion = depthBuffer-&gt;make_display_region(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); depthBufferRegion-&gt;set_camera(depthCameraNP);</code> </pre> <br> 如果决定使用深度缓冲区，则可以在Panda3D中配置深度缓冲区。 <br><br><pre> <code class="cpp hljs">in vec4 vertexPosition; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fragColor = vertexPosition; }</code> </pre> <br> 这是一个简单的着色器，用于将查看空间中的顶点位置渲染为帧缓冲区纹理。 更加困难的任务是调整帧缓冲区的纹理，以使由此获得的片段向量的分量不限于间隔<code>[0, 1]</code> ，并且每个片段具有足够高的精度（足够多的位数）。 例如，如果某种插值的顶点位置是<code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code> ，则无法将其保存为<code>&lt;-139.444444566, 0.00000034343, 2.5&gt;</code>到纹理。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... FrameBufferProperties fbp = FrameBufferProperties::get_default(); // ... fbp.set_rgba_bits(32, 32, 32, 32); fbp.set_rgb_color(true); fbp.set_float_color(true); // ...</span></span></code> </pre> <br> 这是一个示例代码，该代码准备用于存储顶点位置的帧缓冲区纹理。 他需要32位用于红色，绿色，蓝色和Alpha，因此他将值的限制禁用为<code>[0, 1]</code>间隔。 对<code>set_rgba_bits(32, 32, 32, 32)</code>的调用将设置位音量并禁用限制。 <br><br><pre> <code class="cpp hljs"> glTexImage2D ( GL_TEXTURE_2D , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB32F , <span class="hljs-number"><span class="hljs-number">1200</span></span> , <span class="hljs-number"><span class="hljs-number">900</span></span> , <span class="hljs-number"><span class="hljs-number">0</span></span> , GL_RGB , GL_FLOAT , <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> );</code> </pre> <br> 这是在OpenGL上的类似调用。  <code>GL_RGB32F</code>设置位并禁用限制。 <br><br><blockquote> 如果颜色缓冲区具有固定的逗号，则对于无符号归一化和有符号归一化颜色缓冲区，在计算混合方程之前，初始值和最终值的成分以及混合指数分别限制为[0，1]或[-1，1]。 如果颜色缓冲区具有浮点，则不符合限制。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">来源</a> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17b/2d0/2ad/17b2d02ad53c411dc251d90fdc16fdf3.png"></div><br> 在这里，您可以看到顶点的位置；  y轴朝上。 <br><br> 请记住，Panda3D将z轴定义为指向上的向量，而在OpenGL中，y轴向上看。 位置着色器以z向上显示顶点的位置，因为在Panda3D中 <br>  <code>gl-coordinate-system default</code>参数已配置。 <br><br><h3> 正常的 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/064/9c5/0c40649c525edd7bcf3c829d6e948789.gif"></div><br> 为了使在SSAO着色器中获得的样本正确定向，我们需要顶点的法线。 该示例代码生成了分布在半球上的多个采样矢量，但是您可以使用该球体并完全解决需要法线的问题。 <br><br><pre> <code class="cpp hljs">in vec3 vertexNormal; out vec4 fragColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ vec3 normal = normalize(vertexNormal); fragColor = vec4(normal, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br> 与位置着色器一样，普通着色器非常简单。 记住要对顶点的法线进行归一化，并记住它们在视域中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/a82/f00/57ba82f003b0ab9c2aafa7c9affa28bb.gif"></div><br> 此处显示顶点的法线。  y轴朝上。 <br><br> 回想一下，Panda3D将z轴视为向上向量，将OpenGL视为y轴。 由于在Panda3D中配置了<code>gl-coordinate-system default</code> ，因此普通着色器会显示z轴指向上方的顶点的位置。 <br><br><h3> 样品 </h3><br> 为了确定任何单个片段的环境光遮挡值，我们需要对周围区域进行采样。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; numberOfSamples; ++i) { LVecBase3f sample = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) ).normalized(); float rand = randomFloats(generator); sample[0] *= rand; sample[1] *= rand; sample[2] *= rand; float scale = (float) i / (float) numberOfSamples; scale = lerp(0.1, 1.0, scale * scale); sample[0] *= scale; sample[1] *= scale; sample[2] *= scale; ssaoSamples.push_back(sample); } // ...</span></span></code> </pre> <br> 样本代码生成分布在半球中的64个随机样本。 这些<code>ssaoSamples</code>将传递到SSAO着色器。 <br><br><pre> <code class="cpp hljs"> LVecBase3f sample = LVecBase3f ( randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> , randomFloats(generator) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span> ).normalized();</code> </pre> <br> 如果要在一个球体上分布样本，请更改随机分量z的间隔，以使其从负一变为一。 <br><br><h3> 噪音 </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 16; ++i) { LVecBase3f noise = LVecBase3f ( randomFloats(generator) * 2.0 - 1.0 , randomFloats(generator) * 2.0 - 1.0 , 0.0 ); ssaoNoise.push_back(noise); } // ...</span></span></code> </pre> <br> 为了很好地覆盖采样区域，我们需要生成噪声向量。 这些噪声矢量可使样品围绕表面顶部旋转。 <br><br><h3> 环境遮挡 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d35/c1d/bb4/d35c1dbb4e0e9dfeedc3bd4285f26004.gif"></div><br>  SSAO通过采样片段周围的可视空间来完成其任务。 表面以下的样品越多，片段的颜色越深。 这些样本位于片段中，并指示顶点法线的大致方向。 每个样本用于在帧缓冲区位置的纹理中搜索一个位置。 将返回的位置与样本进行比较。 如果样品离摄像机的位置比该位置远，则样品被挡住。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/b9a/f1d/cb7b9af1d4dc613f337da5a253ef5a8c.gif"></div><br> 在这里，您可以看到采样表面上方的空间以进行遮挡。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float radius = 1.1; float bias = 0.026; float lowerRange = -2; float upperRange = 2; // ...</span></span></code> </pre> <br> 像其他一些技术一样，SSAO着色器具有几个控制参数，可以更改这些控制参数以获得所需的外观。 偏差会加到样品到相机的距离上。 此参数可用于消除污渍。 半径增加或减少样本空间的覆盖区域。  lowerRange和upperRange将因子度量标准范围从<code>[0, 1]</code>更改为您选择的任何值。 通过增加范围，可以增加对比度。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); vec3 normal = texture(normalTexture, texCoord).xyz; int noiseX = int(gl_FragCoord.x - 0.5) % 4; int noiseY = int(gl_FragCoord.y - 0.5) % 4; vec3 random = noise[noiseX + (noiseY * 4)]; // ...</span></span></code> </pre> <br> 我们获得位置，法线和随机向量以备将来使用。 回想一下，在代码示例中，创建了16个随机向量。 根据当前片段的屏幕位置选择一个随机向量。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 tangent = normalize(random - normal * dot(random, normal)); vec3 binormal = cross(normal, tangent); mat3 tbn = mat3(tangent, binormal, normal); // ...</span></span></code> </pre> <br> 使用随机向量和法线向量，我们收集切线，双法线和法线的矩阵。 我们需要这个矩阵将样本向量从切线空间转换到测量空间。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float occlusion = NUM_SAMPLES; for (int i = 0; i &lt; NUM_SAMPLES; ++i) { // ... } // ...</span></span></code> </pre> <br> 有了一个矩阵，着色器可以循环遍历循环中的所有样本，减去未打开的样本数。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 sample = tbn * samples[i]; sample = position.xyz + sample * radius; // ...</span></span></code> </pre> <br> 使用矩阵，将样品放置在顶点/片段位置旁边，并按半径缩放比例。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offset = vec4(sample, 1.0); offset = lensProjection * offset; offset.xyz /= offset.w; offset.xyz = offset.xyz * 0.5 + 0.5; // ...</span></span></code> </pre> <br> 使用样本在观察空间中的位置，我们将其从观察空间转换为裁剪空间，然后转换为UV空间。 <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">-1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br> 不要忘记剪切空间的分量在负一到一的范围内，UV坐标在零到一的范围内。 要将剪贴空间的坐标转换为UV坐标，请将它们乘以一秒钟，然后加一秒。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 offsetPosition = texture(positionTexture, offset.xy); float occluded = 0; if (sample.y + bias &lt;= offsetPosition.y) { occluded = 0; } else { occluded = 1; } // ...</span></span></code> </pre> <br> 使用通过将3D样本投影到2D位置纹理上获得的UV偏移坐标，我们找到相应的位置矢量。 这使我们从观察空间到裁剪空间再到UV空间，然后又回到观察空间。 着色器运行此循环以确定样品后面，样品位置或样品前面是否存在任何几何形状。 如果样本位于几何图形的前面或某个几何图形中，则相对于重叠片段，根本就不会考虑该样本。 如果样本在某些几何形状后面，则相对于重叠片段考虑该样本。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float intensity = smoothstep ( 0.0 , 1.0 , radius / abs(position.y - offsetPosition.y) ); occluded *= intensity; occlusion -= occluded; // ...</span></span></code> </pre> <br> 现在，根据其在半径内或半径外的距离向此采样位置添加权重。 然后，从阻塞度量中减去此样本，因为它假定所有样本在循环之前都已重叠。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... occlusion /= NUM_SAMPLES; // ... fragColor = vec4(vec3(occlusion), position.a); // ...</span></span></code> </pre> <br> 将重叠数除以样本数，将遮挡指示器从间隔<code>[0, NUM_SAMPLES]</code>转换为间隔<code>[0, 1]</code> 。 零表示完全遮挡，单位表示没有遮挡。 现在，将遮挡指标分配给片段颜色，仅此而已。 <br><br> 请注意，在示例代码中，为Alpha通道分配了来自帧缓冲区的位置纹理的Alpha值，以避免背景重叠。 <br><br><h3> 模糊 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/566/2a7/5b15662a7c46db6b8102fe9eabae17c9.gif"></div><br>  SSAO帧缓冲区的纹理有点嘈杂，因此应对其进行模糊处理以使其平滑。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( ssaoTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ).rgb; xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br>  SSAO模糊着色器是常规的框模糊。 像Bloom着色器一样，它在传入的纹理上绘制一个窗口，并将每个片段及其相邻元素的值平均。 <br><br> 请注意， <code>parameters.x</code>是分隔参数。 <br><br><h3> 环境颜色 </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 ssaoBlurTexSize = textureSize(ssaoBlurTexture, 0).xy; vec2 ssaoBlurTexCoord = gl_FragCoord.xy / ssaoBlurTexSize; float ssao = texture(ssaoBlurTexture, ssaoBlurTexCoord).r; vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex * ssao; // ...</span></span></code> </pre> <br>  SSAO面临的最后挑战还是照明计算。 在这里，我们了解了如何在纹理SSAO纹理缓冲区中找到遮挡并将其包含在环境光的计算中。 <br><br><h3> 源代码 </h3><br><ul><li>  <a href="">main.cxx</a> </li><li>  <a href="">base.vert</a> </li><li>  <a href="">basic.vert</a> </li><li>  <a href="">position.frag</a> </li><li>  <a href="">正常片段</a> </li><li>  <a href="">ssao.frag</a> </li><li>  <a href="">模糊片段</a> </li></ul><br><h2> 景深 </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/eb0/10f/6efeb010f4623ff49b928d72550f7985.gif"></div><br> 景深也是这样一种影响，如果了解了哪些，没有它就无法生存。 从艺术的角度来看，您可以使用它来吸引观看者对特定对象的关注。 但是在一般情况下，以一点点努力为代价的景深会增加很大一部分真实感。 <br><br><h3> 聚焦 </h3><br> 第一步是使场景完全聚焦。 渲染到帧缓冲区纹理。 这将是景深缓冲区的输入值之一。 <br><br><h3> 失去重点 </h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 result = vec4(0); for (int i = 0; i &lt; size2; ++i) { x = size - xCount; y = yCount - size; result += texture ( blurTexture , texCoord + vec2(x * parameters.x, y * parameters.x) ); xCount -= 1; if (xCount &lt; countMin) { xCount = countMax; yCount -= 1; } } result = result / size2; // ...</span></span></code> </pre> <br> 第二步是使场景模糊，好像它完全不在焦点上一样。 与Bloom和SSAO一样，您可以使用盒子模糊。 将此散焦场景渲染为帧缓冲区纹理。 这将是景深着色器的另一个输入值。 <br><br> 请注意， <code>parameters.x</code>是分隔参数。 <br><br><h3> 混乱 </h3><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d68/067/83a/d6806783a567c4708d8f13dcb0763f7c.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float focalLengthSharpness = 100; float blurRate = 6; // ...</span></span></code> </pre> <br> 您可以根据自己的喜好自定义这些选项。  <code>focalLengthSharpness</code>影响场景在焦距下的散焦效果。  <code>focalLengthSharpness</code>越小，场景在焦距处的散焦就越多。 当远离焦距时， <code>blurRate</code>影响场景模糊的速度。  <code>blurRate</code> ，远离焦点时场景的模糊越少。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 focusColor = texture(focusTexture, texCoord); vec4 outOfFocusColor = texture(outOfFocusTexture, texCoord); // ...</span></span></code> </pre> <br> 我们将需要焦点和散焦图像中的颜色。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 position = texture(positionTexture, texCoord); // ...</span></span></code> </pre> <br> 我们可能还需要在查看空间中顶点的位置。 您可以从用于SSAO的帧缓冲区中重新应用位置的纹理。 <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float blur = clamp ( pow ( blurRate , abs(position.y - focalLength.x) ) / focalLengthSharpness , 0 , 1 ); // ... fragColor = mix(focusColor, outOfFocusColor, blur); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里发生了混乱。</font><font style="vertical-align: inherit;">越接近</font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1，它将使用的越多</font></font><code>outOfFocusColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">零值</font></font><code>blur</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示此片段完全在焦点上。</font><font style="vertical-align: inherit;">有了</font></font><code>blur &gt;= 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这个片段就完全散焦了。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模糊片段</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">景深片段</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 后发化 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/078/84d/f1807884d79c5c73915ce9adf6ead5cb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后幅化或颜色采样是减少图像中唯一颜色数量的过程。</font><font style="vertical-align: inherit;">您可以使用此着色器使游戏具有漫画或复古外观。</font><font style="vertical-align: inherit;">如果将其与轮廓线结合使用，则会获得真正的卡通风格。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float levels = 8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以尝试使用此参数。</font><font style="vertical-align: inherit;">它越大，结果将保留的花越多。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 texColor = texture(posterizeTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将需要传入的颜色。 </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 grey = vec3((texColor.r + texColor.g + texColor.b) / 3.0); vec3 grey1 = grey; grey = floor(grey * levels) / levels; texColor.rgb += (grey - grey1); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我还没有看到这样的后代化方法。</font><font style="vertical-align: inherit;">对其进行检查后，我发现与传统方法相比，它可以产生更漂亮的结果。</font><font style="vertical-align: inherit;">要减少调色板，请先将颜色转换为灰度值。</font><font style="vertical-align: inherit;">我们通过将颜色绑定到某一级别来离散化颜色。</font><font style="vertical-align: inherit;">我们计算灰度的离散值与灰度的非离散值之间的差。</font><font style="vertical-align: inherit;">将此差异添加到输入颜色。</font><font style="vertical-align: inherit;">这种差异是颜色必须增加/减少以达到灰度离散值的数量。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texColor; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不要忘记将输入颜色的值分配给片段的颜色。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cel底纹 </font></font></h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d1/f9c/133/2d1f9c1333960c0299388fc51323a8b3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后处理可以使图片看起来像cel阴影，因为cel阴影是将漫反射和漫反射颜色离散为离散阴影的过程。</font><font style="vertical-align: inherit;">我们只想使用纯色漫反射颜色，而没有法线贴图的精细细节和较小的值</font></font><code>levels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">后海报</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像素化 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/396/0b9/9bc/3960b99bc2f1fa900c40a1c9f32169bc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D游戏的像素化可以赋予它有趣的外观，或者可以节省您手动创建所有像素图所需的时间。</font><font style="vertical-align: inherit;">将其与后代化相结合，可以创建出真正的复古外观。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... int pixelSize = 5; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以自己调整像素大小。</font><font style="vertical-align: inherit;">它越大，图像越粗糙。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/818/aee/413818aee5509763cc383f800b837cfb.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float x = int(gl_FragCoord.x) % pixelSize; float y = int(gl_FragCoord.y) % pixelSize; x = floor(pixelSize / 2.0) - x; y = floor(pixelSize / 2.0) - y; x = gl_FragCoord.x + x; y = gl_FragCoord.y + y; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此技术将每个片段附加到其最近的不重叠像素大小的窗口的中心。</font><font style="vertical-align: inherit;">这些窗口在传入纹理的顶部对齐。</font><font style="vertical-align: inherit;">窗口中心的片段确定了其窗口中其他片段的颜色。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = texture(pixelizeTexture, vec2(x, y) / texSize); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 确定所需片段的坐标后，从传入纹理中获取其颜色并将其分配给片段颜色。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素化片段</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 锐化 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/674/617/b52674617a0733ee1fe0d525b0053750.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锐化效果（锐化）可提高图像边缘的对比度。</font><font style="vertical-align: inherit;">当图形变得太软时，它会派上用场。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.8; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过更改值，我们可以控制结果的清晰度。</font><font style="vertical-align: inherit;">如果值为零，则图像不会改变。</font><font style="vertical-align: inherit;">值为负值时，图像开始看起来很奇怪。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float neighbor = amount * -1; float center = amount * 4 + 1; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相邻的片段乘以</font></font><code>amount * -1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当前片段乘以</font></font><code>amount * 4 + 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 color = texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 1) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x - 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y + 0) / texSize).rgb * center + texture(sharpenTexture, vec2(gl_FragCoord.x + 1, gl_FragCoord.y + 0) / texSize).rgb * neighbor + texture(sharpenTexture, vec2(gl_FragCoord.x + 0, gl_FragCoord.y - 1) / texSize).rgb * neighbor ; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相邻的片段位于顶部，底部，左侧和右侧。</font><font style="vertical-align: inherit;">将邻居和当前片段乘以它们的值后，将结果相加。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = vec4(color, texture(sharpenTexture, texCoord).a); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此数量是片段的最终颜色。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锐化片段</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 胶片颗粒 </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/16e/232/2f316e232598d07fa8114f8db32c12a7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">薄膜的颗粒感（小剂量，而不是示例中的情况）可以增加真实感，直到消除此效果之前，该效果才可见。</font><font style="vertical-align: inherit;">通常，这些缺陷使数字生成的图像更具说服力。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，胶片颗粒通常是在显示之前应用于帧的最后一个效果。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 价值 </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float amount = 0.1; // ...</span></span></code> </pre> <br> <code>amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">控制胶片颗粒的可见性。</font><font style="vertical-align: inherit;">值越高，图片中的“雪”越多。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 随机亮度 </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform float osg_FrameTime; //... float toRadians = 3.14 / 180; //... float randomIntensity = fract ( 10000 * sin ( ( gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime ) * toRadians ) ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这段代码计算调整该值所需的随机亮度。 </font></font><br><br><pre> <code class="cpp hljs">Time Since F1 = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> Frame Number = F1 F3 F4 F5 F6 osg_FrameTime = <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D </font></font><code>osg_FrameTime</code> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">帧时间是一个时间戳，其中包含有关自第一帧起经过了多少秒的信息。</font><font style="vertical-align: inherit;">样例代码使用它来使影片的颗粒动起来，这</font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每个帧中都会有所不同。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... ( gl_FragCoord.x + gl_FragCoord.y * 8009 // Large number here. // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于静态谷物，必须</font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大量</font><font style="vertical-align: inherit;">更换薄膜</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为避免看到模式，您可以尝试使用不同的数字。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/2bd/6d2/3582bd6d2d67eb5ac1fdcdf8d52800e6.gif"></div><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... * sin ( ( gl_FragCoord.x + gl_FragCoord.y * someNumber // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建点或胶片颗粒斑点，请同时使用坐标，x和y。</font><font style="vertical-align: inherit;">如果使用x，则仅显示垂直线，如果使用y，则仅显示水平线。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在代码中，一个坐标与另一个坐标相乘以破坏对角线对称性。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/ad6/d5a/4c0ad6d5ada5d533b6dc31bbfa7aa0fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，您可以摆脱坐标乘数，并获得完全可以接受的降雨效果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，对于雨水的动画效果，需要乘以输出</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上</font></font><code>osg_FrameTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试使用x和y坐标更改雨的方向。</font><font style="vertical-align: inherit;">对于向下淋浴，仅保留x坐标。</font></font><br><br><pre> <code class="cpp hljs">input = (gl_FragCoord.x + gl_FragCoord.y * osg_FrameTime) * toRadians frame(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(input)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) =</code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用作哈希函数。</font><font style="vertical-align: inherit;">片段坐标将使用输出值进行哈希处理</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，出现了一个方便的属性-无论输入数据（大还是小），输出间隔都将在负一到一的范围内。</font></font><br><br><pre> <code class="cpp hljs">fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">6.977777777777778</span></span>)) = fract(<span class="hljs-number"><span class="hljs-number">10000</span></span> * <span class="hljs-number"><span class="hljs-number">0.6400723818964882</span></span>) = fract(<span class="hljs-number"><span class="hljs-number">6400.723818964882</span></span>) = <span class="hljs-number"><span class="hljs-number">0.723818964882</span></span></code> </pre> <br> <code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结合</font></font><code>fract</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还用作伪随机数生成器。</font></font><br><br><pre> <code class="cpp hljs">&gt;&gt;&gt; [<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(fract(<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(x * toRadians)) * <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 0, 1, 2, 2, 3, 4, 4, 5, 6] &gt;&gt;&gt; [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fract(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10000</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(x * toRadians)) * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> x in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">] [0, 4, 8, 0, 2, 1, 7, 0, 0, 5]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先查看第一行数字，然后查看第二行。</font><font style="vertical-align: inherit;">每一行都是确定性的，但第二行中的模式不如第二行中的那么明显。</font><font style="vertical-align: inherit;">因此，尽管事实是输出是</font></font><code>fract(10000 * sin(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定性的，但人们认为该模式要弱得多。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/6e7/f0f/b886e7f0feda6760c5fc87df6680680f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我们看到因子</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">如何</font><font style="vertical-align: inherit;">先是1，然后是10，然后是100，然后是1000。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着输出值的乘数增加，</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式变得不太明显。</font><font style="vertical-align: inherit;">因此，代码</font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乘以10,000。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 片段颜色 </font></font></h3><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec2 texSize = textureSize(filmGrainTexture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; vec4 color = texture(filmGrainTexture, texCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将片段的坐标转换为UV坐标。</font><font style="vertical-align: inherit;">使用这些UV坐标，我们寻找当前片段的纹理颜色。</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... amount *= randomIntensity; color.rgb += amount; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将值更改为随机亮度，然后将其添加到颜色中。 </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... fragColor = color; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 设置片段的颜色，仅此而已。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 源代码 </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basic.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">胶片颗粒片段</font></font></a> </li></ul><br><h2> 致谢 </h2><br><ul><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Kiwi Soda Font</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453692/">https://habr.com/ru/post/zh-CN453692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453676/index.html">在Linux中通过SSH连接到Windows</a></li>
<li><a href="../zh-CN453678/index.html">如何通过水中的声音查看混响或视频传输-2</a></li>
<li><a href="../zh-CN453682/index.html">为Redd中安装的FPGA开发最简单的“固件”。 第2部分。程序代码</a></li>
<li><a href="../zh-CN453686/index.html">安全周22：威胁统计信息，银行木马和流行漏洞</a></li>
<li><a href="../zh-CN453688/index.html">Java不仅是血腥的企业，而且还是对延迟敏感的快速应用程序</a></li>
<li><a href="../zh-CN453694/index.html">像在Linux中一样通过SSH连接到Windows</a></li>
<li><a href="../zh-CN453696/index.html">角度双向绑定，多一点理解</a></li>
<li><a href="../zh-CN453698/index.html">量子意识中的量子信息</a></li>
<li><a href="../zh-CN453700/index.html">有关SDL 2的课程：第1课-您好，SDL 2</a></li>
<li><a href="../zh-CN453706/index.html">我如何通过Google Cloud Professional数据工程师认证考试</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>