<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≥ üì† üïµüèº Wir starten den Container mit Unit-Tests in Azure DevOps (VSTS). üå∑ üôåüèª üë®üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit dem Aufkommen von .Net Core haben wir die gro√üartige Gelegenheit, unseren Code nicht nur auf verschiedenen Betriebssystemen auszuf√ºhren, sondern a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir starten den Container mit Unit-Tests in Azure DevOps (VSTS).</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430958/"> Mit dem Aufkommen von .Net Core haben wir die gro√üartige Gelegenheit, unseren Code nicht nur auf verschiedenen Betriebssystemen auszuf√ºhren, sondern auch auf verschiedenen Betriebssystemen zu testen.  Und was k√∂nnte besser sein als Docker, wenn Sie mit einem anderen Betriebssystem arbeiten? <br><img src="https://habrastorage.org/webt/uw/fg/nb/uwfgnb_uo5qtahy1y9xyxof4dpu.png"><a name="habracut"></a><br>  Testen ist wertvoller, wenn Sie keinen Unterschied zwischen der Testumgebung und den Zielumgebungen haben.  Stellen Sie sich vor, Sie unterst√ºtzen Ihre Anwendung auf mehreren Betriebssystemen oder Versionen eines Betriebssystems.  Mit Docker k√∂nnen Sie Ihre Anwendung in jedem von ihnen testen. <br><br>  In diesem Artikel wird erl√§utert, wie Sie ein separates Image erstellen, in dem Komponententests Ihrer Anwendung gestartet und f√ºr die gesamte CI / CD-Pipeline in VSTS konfiguriert werden, bei der es sich k√ºrzlich um Azure DevOps handelt. <cut></cut><br><br>  Wenn Sie mit Docker arbeiten, verwenden Sie wahrscheinlich mehrstufige Builds, um Ihre Container zu erstellen.  In diesem Fall kombinieren Sie die Erstellung von Bin√§rdateien (mithilfe des Build-Images) und die Erstellung des endg√ºltigen Images (mithilfe des Laufzeit-Images) in derselben Docker-Datei. <br><br>  Wenn Ihr System aus einem Container besteht, besteht in diesem Fall der h√§ufigste Ansatz darin, Tests als Teil des Prozesses zum Erstellen des endg√ºltigen Images auszuf√ºhren.  Das hei√üt, Tests in der Docker-Datei ausf√ºhren. <br><br>  Um dies in einem mehrstufigen Prozess zu tun, f√ºhren Sie beim Starten von <code>docker build</code> die Tests als weiteren Schritt zum <code>docker build</code> des endg√ºltigen Images aus.  Schauen wir uns ein einfaches Beispiel an.  Angenommen, wir haben zwei Projekte: Webanwendungen und Komponententests: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jw/h6/uy/jwh6uyqb747mhfueifnwdlkirvm.png"></div><cut></cut><br>  Machen wir uns vorerst keine Gedanken dar√ºber, was die Webanwendung tut.  Auf der anderen Seite haben wir den einzigen Test, der das Verhalten von <code>GuidProvider</code> und so aussieht: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Never_return_a_empty_guid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Arrange &amp; Act var provider = new GuidProvider(); var id = provider.Id; // Assert Assert.NotEqual(Guid.Empty, id); }</span></span></code> </pre> <br>  Erstellen Sie nun eine Docker-Datei, die das WebApplication-Image erstellt und gleichzeitig die Tests ausf√ºhrt: <br><br><pre> <code class="plaintext hljs">FROM microsoft/dotnet:2.1-aspnetcore-runtime AS base WORKDIR /app EXPOSE 80 FROM microsoft/dotnet:2.1-sdk AS build WORKDIR /src COPY CiCd.sln . COPY WebApplication/WebApplication.csproj WebApplication/ COPY WebApplication.Test/WebApplication.Test.csproj WebApplication.Test/ RUN dotnet restore COPY . . WORKDIR /src/WebApplication RUN dotnet build --no-restore -c Release -o /app FROM build as test WORKDIR /src/WebApplication.Test RUN dotnet test FROM build AS publish WORKDIR /src/WebApplication RUN dotnet publish --no-build -c Release -o /app FROM base AS final WORKDIR /app COPY --from=publish /app . ENTRYPOINT ["dotnet", "WebApplication.dll"]</code> </pre><br>  Diese Docker-Datei muss in einem Verzeichnis mit einer L√∂sungsdatei (iCd.sln) abgelegt werden.  Verwenden Sie den folgenden Befehl, um ein Bild zu erstellen: <br><br><pre> <code class="bash hljs">docker build -t webapplication .</code> </pre> <cut></cut><br>  Unser Test schl√§gt fehl (ein Fehler in <code>GuidProvider</code> , der immer <code>Guid.Empty</code> ), sodass der Image-Build fehlschl√§gt: <br><br><div class="spoiler">  <b class="spoiler_title">Ausgabe</b> <div class="spoiler_text"><pre> <code class="bash hljs">Step 15/22 : RUN dotnet <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ---&gt; Running <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 423c27696356 Build started, please <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>... Build completed. Test run <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> /src/WebApplication.Test/bin/Debug/netcoreapp2.1/WebApplication.Test.dll(.NETCoreApp,Version=v2.1) Microsoft (R) Test Execution Command Line Tool Version 15.9.0 Copyright (c) Microsoft Corporation. All rights reserved. Starting <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> execution, please <span class="hljs-built_in"><span class="hljs-built_in">wait</span></span>... [xUnit.net 00:00:00.96] WebApplication.Test.GuidProviderTests.Never_return_a_empty_guid [FAIL] Failed WebApplication.Test.GuidProviderTests.Never_return_a_empty_guid Error Message: Assert.NotEqual() Failure Expected: Not 00000000-0000-0000-0000-000000000000 Actual: 00000000-0000-0000-0000-000000000000 Stack Trace: at WebApplication.Test.GuidProviderTests.Never_return_a_empty_guid() <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> /src/WebApplication.Test/GuidProviderTests.cs:line 17 Test Run Failed. Total tests: 1. Passed: 0. Failed: 1. Skipped: 0. Test execution time: 2.8166 Seconds The <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'/bin/sh -c dotnet test'</span></span> returned a non-zero code: 1</code> </pre> </div></div><cut></cut><br>  Lassen Sie uns nun sehen, wie Sie diesen Prozess in Azure DevOps starten. <br><br>  Unsere Build-Definition ist derzeit eine Aufgabe vom Typ Docker: <br><br><img src="https://habrastorage.org/webt/nc/ef/pf/ncefpfgqxsbt6pewrknrer6iqg4.png"><br><br>  Infolge des Starts schl√§gt der Build fehl, weil unser Test abf√§llt.  Au√üerdem haben wir keine Testergebnisse (die Registerkarte "Test" ist leer), da nach dem Verst√§ndnis von VSTS keine Tests durchgef√ºhrt werden: <br><br><img src="https://habrastorage.org/webt/vf/_u/bi/vf_ubic9-ecav4qtz0zhp9ylpz0.png"><br><br>  Das Ausf√ºhren von Tests als Teil einer Image-Assembly ist nicht ganz schlecht, verhindert jedoch, dass VSTS wei√ü, was das Ergebnis war.  Dies liegt an der ‚ÄûEinschr√§nkung‚Äú von Docker, die das Erstellen von Volumes w√§hrend des <code>docker build</code> <code>dotnet test</code> nicht zul√§sst. Daher k√∂nnen wir keine Datei mit Testergebnissen bereitstellen (die mit dem <code>dotnet test</code> generiert werden <code>dotnet test</code> ). Diese Datei verbleibt in einem Zwischencontainer und kann nicht einfach <code>dotnet test</code> ihn von dort. <cut></cut><br><br>  Wir werden einen anderen Ansatz <code>docker run</code> und eine gro√üartige Alternative zum <code>docker run</code> .  Lassen Sie uns zun√§chst einen separaten Container anheben und die Tests darin ausf√ºhren.  F√ºr beide Container k√∂nnen wir dasselbe Dockerfile verwenden.  Zun√§chst m√ºssen wir die Zeile, in der der <code>dotnet test</code> aus der Docker- <code>dotnet test</code> entfernen, da wir sie jetzt separat ausf√ºhren werden.  Ok, jetzt verwenden wir den <code>docker run</code> , mit dem Sie die <code>docker run</code> Datei bis zu einem bestimmten Punkt ausf√ºhren k√∂nnen.  In unserem Fall ist dies die Testphase: <br><br><pre> <code class="bash hljs">docker build -t webapplication-tests . --target <span class="hljs-built_in"><span class="hljs-built_in">test</span></span></code> </pre> <br>  Der Parameter <code>-target</code> gibt an, welche Stufe zusammengesetzt werden soll.  Bitte beachten Sie, dass das generierte Bild als " <b>Webanwendungstests</b> " bezeichnet wird.  Jetzt k√∂nnen wir unsere Tests ausf√ºhren und die Datei " <b>test-results.trx</b> " mit den Ergebnissen ihrer Ausf√ºhrung im Containerverzeichnis " <b>tests</b> " speichern: <br><br><pre> <code class="bash hljs">docker run -v/c/tests:/tests webapplication-tests --entrypoint <span class="hljs-string"><span class="hljs-string">"dotnet test --logger trx;LogFileName=/tests/test-results.trx"</span></span></code> </pre> <br>  Hier f√ºhren wir das im vorherigen Schritt erstellte Image aus und ordnen dadurch das Containerverzeichnis " <b>tests</b> " dem Hostverzeichnis zu (in meinem Fall D: \ CiCD \ tests).  Als Ergebnis habe ich Testergebnisse in D: \ CiCD \ tests erhalten. <br><br>  F√ºhren Sie Folgendes aus, um das endg√ºltige Image zu erstellen: <br><br><pre> <code class="bash hljs">docker build -t webapplication .</code> </pre> <br>  Der Vorteil besteht darin, dass dank des Docker-Level-Modells nicht alle anderen Schritte erneut ausgef√ºhrt werden m√ºssen (d. H. Die Anwendung muss nicht neu kompiliert werden). <br><br>  Wenden wir dies nun auf Azure DevOps-Pipelines an.  Um die Montage zu vereinfachen und eine gro√üe Anzahl von Parametern zu vermeiden, verwenden wir Docker-Compose.  Unsere docker-compose.yml hat folgenden Inhalt: <br><br><pre> <code class="plaintext hljs">version: '3.5' services: webapplication: image: webapplication build: context: . dockerfile: Dockerfile webapplication-tests: image: webapplication-tests build: context: . dockerfile: Dockerfile target: test</code> </pre><cut></cut><br>  Hier definieren wir zwei Bilder (Webanwendung und Webanwendungstests).  Damit alles dem Kanon entspricht, f√ºgen wir die Datei docker-compose.override.yml hinzu: <br><br><pre> <code class="plaintext hljs">version: '3.5' services: webapplication: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - "8080:80" webapplication-tests: entrypoint: - dotnet - test - --logger - trx;LogFileName=/tests/test-results.trx volumes: - ${BUILD_ARTIFACTSTAGINGDIRECTORY:-./tests/}:/tests</code> </pre><br>  Gro√üartig, jetzt, um die Tests durchzuf√ºhren, m√ºssen wir nur noch: <br><br><pre> <code class="bash hljs">docker-compose run webapplication-tests</code> </pre> <br>  Dieser Befehl f√ºhrt die Tests aus und erstellt die Ausgabe-TRX-Datei in dem Verzeichnis, das durch die Umgebungsvariable <code>BUILD_ARTIFACTSTAGINGDIRECTORY</code> oder es wird der Standardwert <code>./tests</code> .  Das endg√ºltige Bild sieht folgenderma√üen aus: <br><br><pre> <code class="bash hljs">docker-compose build webapplication</code> </pre> <br>  Jetzt k√∂nnen Sie unseren CI-Prozess in Azure DevOps bearbeiten.  Dazu definieren wir folgende Schritte: <br><br><ol><li>  Sammle alle Bilder [build] </li><li>  Unit-Tests ausf√ºhren [ausf√ºhren] </li><li>  Testergebnis ver√∂ffentlichen [ver√∂ffentlichen] </li><li>  F√ºhren Sie Bilder im Repository (Registrierung) aus [push] </li></ol><br>  Beginnen wir mit dem ersten Schritt, der Docker Compose-Aufgabe (Task) in Azure: <br><br><img src="https://habrastorage.org/webt/c5/yj/gm/c5yjgmookbcql36fwe6k4xc_waw.png"><br><br>  Wir setzen <code>Action: Build service images</code> und geben Sie den Pfad zu docker-compose.yml an. <br><br>  F√ºhren Sie als N√§chstes den Container mit Komponententests aus: <br><br><img src="https://habrastorage.org/webt/ls/fh/e4/lsfhe4ghplqn3acy6da7zk4j3sc.png"><br><br>  Hier m√ºssen Sie <code>Action: Run a specific service image</code> ausw√§hlen <code>Action: Run a specific service image</code> und geben Sie den Containernamen an. <code>Service Name: webapplication-tests</code> .  Vergessen Sie auch nicht den Pfad zu docker-compose.yml und docker-compose.override.yml.  Der Wert f√ºr <code>Run in Background</code> sollte nicht festgelegt werden, da sonst der Container im "Detached Mode" gestartet wird und die Task nicht auf die Ergebnisse der Tests wartet und mit dem n√§chsten Schritt fortf√§hrt.  Die Aufgabe Testergebnisse ver√∂ffentlichen versucht, Ergebnisse zu ver√∂ffentlichen, die m√∂glicherweise noch nicht verf√ºgbar sind, da das Ausf√ºhren von Tests einige Zeit in Anspruch nimmt. <cut></cut><br><br>  Der dritte Schritt ist "Testergebnisse ver√∂ffentlichen": <br><br><img src="https://habrastorage.org/webt/nz/qb/uy/nzqbuyet5qaksri-jy2wqeqrjxk.png"><br><br>  <b>Es ist wichtig</b> anzugeben, <code>Run this task: Even if a previous task has failed, unless the build was canceled</code> .  Diese Option ist wichtig, da sonst die Ergebnisse niemals ver√∂ffentlicht werden, wenn die Tests fehlschlagen. <code>Search folder: $(Build.ArtifactStagingDirectory)</code> <br><br>  Der letzte Schritt besteht darin, die Bilder in den Speicher zu verschieben.  Geben Sie dazu das Azure-Abonnement sowie die Azure-Containerregistrierung an.  Alles ist bereit, um einen neuen Build zu erstellen.  Speichern.  Wir fangen an.  Wenn die Tests fehlschlagen, schl√§gt der Build fehl, aber jetzt sehen wir die Ergebnisse in VSTS: <br><br><img src="https://habrastorage.org/webt/l8/cm/yj/l8cmyj0fl-sjayqh1t4lxncg-ps.png"><br><br>  Ich hoffe dieses Material war hilfreich.  Sie finden meine Assembly-Konfigurations-XML-Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430958/">https://habr.com/ru/post/de430958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430948/index.html">Das Kommunikationsministerium schl√§gt vor, die Kontrolle √ºber personenbezogene Daten zu versch√§rfen</a></li>
<li><a href="../de430950/index.html">Modernes Bauen</a></li>
<li><a href="../de430952/index.html">Elektroautos und Hybridautos m√ºssen zus√§tzliche Ger√§usche machen: Warum wird das ben√∂tigt?</a></li>
<li><a href="../de430954/index.html">Qt Everywhere: WebAssembly und WebGL-Streaming</a></li>
<li><a href="../de430956/index.html">Wir bringen einem Schwein auf Monoiden bei, an sich selbst zu glauben und zu fliegen</a></li>
<li><a href="../de430960/index.html">√úber Gamedev aus einer Desktop-Ausstellung</a></li>
<li><a href="../de430962/index.html">Razor-Unterst√ºtzung in Visual Studio-Code</a></li>
<li><a href="../de430964/index.html">Deklaratives Denken</a></li>
<li><a href="../de430966/index.html">Allgemeine Sprints bei Atlassian Jira Software</a></li>
<li><a href="../de430968/index.html">"Der Geist ist online." Drohnen sind √ºberall</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>