<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛅️ 📃 🕙 使用噪声和中位数割创建像素星云 ✴️ 🤛🏻 😇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在游戏《最后的边界》中想要一个星云。 它们看起来令人惊叹，没有它们的空间就不是空间，而是散布在背景周围的白色像素。 但是由于我是按照“像素艺术”风格制作游戏的，因此我需要以某种方式使我的噪波库生成像素化图像。 

 以下是一些示例： 



 更多例子 




 在单色示例中，使用8种颜色，在其...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用噪声和中位数割创建像素星云</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464203/"> 我在游戏<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《最后的边界》中</a>想要一个星云。 它们看起来令人惊叹，没有它们的空间就不是空间，而是散布在背景周围的白色像素。 但是由于我是按照“像素艺术”风格制作游戏的，因此我需要以某种方式使我的噪波库生成像素化图像。 <br><br> 以下是一些示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/65f/7fd/f2e65f7fd23c0fe2fcfafcc0fcf62a3e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/665/358/ef9/665358ef9f488bb63d7ced8ea7dfd45d.png"></div><br><div class="spoiler">  <b class="spoiler_title">更多例子</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/d6e/4ab/b88d6e4ab783d2d67f0f0f6e7e38536f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/d13/40b/705d1340be1c918a6a6e9b22d3ae416f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/daa/1c7/1ba/daa1c71bade101b11ec6025a87ca30a4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/d8c/5f9/00bd8c5f9fa01ef5a90282a2d2897de3.png"></div><br></div></div><br> 在单色示例中，使用8种颜色，在其他示例中，使用16种颜色。 在本文中，我将讨论如何为《最后的边界》创建像素化星云。 <br><a name="habracut"></a><br> 当我们使用噪声库（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LibNoise）时</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无论</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您</a>使用（或编写自己的） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">哪种</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引擎</a> ，其值通常分布在<code>-1</code>到<code>1</code>的范围内。 从理论上讲，二维噪声的可能范围是<code>-0.7</code>到<code>0.7</code> ，但是某些实现会缩放结果，将其转换为<code>-1</code>到<code>1</code>的间隔。 要使用2D纹理，通常将其转换为<code>0</code>到<code>1</code>的间隔，然后<code>RGB(255,255,255)</code> <code>RGB(0,0,0)</code>到<code>RGB(255,255,255)</code>的范围内。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>从每个像素的<code>x,y</code>坐标生成的Perlin噪声缩放为<code>0.3f</code></i> <br><br> 然后，您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分数布朗运动</a>使图像具有云层的绚丽感。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/910/a74/aed910a745d77af8d1cfa816990276a5.png"></div><br>  <i>Perlin噪声以<code>8</code>个八度音阶，频率<code>0.01</code> ，规则度<code>0.5</code>和腔隙度<code>2.0</code>进行分数布朗运动。</i> <br><br><blockquote> 我注意到Internet上有很多Perlin噪声，单纯形噪声和分数布朗运动（fBm）的错误实现。 关于什么是什么似乎有很多困惑。 确保使用正确的实现，因为如果您要创建上述链，那么在实现不正确的情况下，您可能无法获得所需的结果。 </blockquote><br> 假设我们要创建烟雾效果，也就是说，这样的解决方案将适合我们。 但是，如果从<code>RGB(0,0,0)</code>到<code>RGB(255,255,255)</code>出现一堆新的颜色，我们的像素艺术游戏看起来会很奇怪。 突然，游戏中会出现255个新等级的灰色。 <br><br> 我们需要将它们转换为有限数量的颜色。 那就是我们以后要做的。 同时... <br><br><h2> 产生随机星云 </h2><br> 我重复了有关生成随机星云的现成教程，但是添加了一些步骤并应用了自己的噪声库。 我几年前写这本书是因为我想对Perlin的噪音以及如何将其与其他概念结合使用来创建纹理等有一个很好的了解。 <br><br> 也许您可以一步一步地重复我的操作，否则您将不得不添加一些会影响噪声的代码。 我将解释除初始噪声和fBm之外的所有内容，以便您可以自己编写代码。 我认为可以假定您已经具有生成噪声和fBm的能力。 <br><br> 首先，我将显示生成星云的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>成品结果</i> <br><br> 重要的是要注意它还没有像素化。 它具有全方位的色彩和像素化的星空。 我们稍后将像素化的星云。 <br><br> 首先要做的是生成五种不同的纹理：红色，绿色，蓝色，Alpha和蒙版。 相应的最终颜色通道需要红色，绿色和蓝色纹理。 实际上，我只生成一个或两个颜色通道，因为事实证明，同时使用这三个通道会产生令人难以置信的彩色星云，看上去很难看。 任何一种颜色或两种颜色的组合都可以。 <br><br>  Alpha通道很重要，因为它取决于下层恒星是否会穿过星云发光。 我将通过显示上面示例的alpha通道来说明这一点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>从我们的示例准备好alpha通道</i> <br><br> 区域越白，该值越接近<code>1.0</code> ，这为我们提供了<code>255</code>的alpha值。 区域越黑，它越透明。 如果看一个示例，您会看到黑色区域对应于可见星空的区域。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/7d2/7ad/de97d27adeaaebdbfc8a5b5857bab02f.png"></div><br>  <i>星空的例子</i> <br><br> 这些星星与示例中的星星不同，因为它们是在每个屏幕截图中随机生成的。 我希望这不会阻止您了解星云是如何产生的。 <br><br> 我的噪声库由模块组成，遵循<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lib Noise</a>的示例。 该库中的所有内容都是可以链接在一起的“模块”。 一些模块生成新值（Perlin模块，常量值），其他模块将它们连接（乘，加），而某些模块仅对该值执行操作（Lerp，Clamp）。 <br><br><h3> 色彩通道 </h3><br> 我们使用一种，两种或三种颜色都没关系-红色，绿色和蓝色通道是以相同的方式生成的； 我只是为它们使用不同的种子值。 我的种子值取决于当前系统时间。 <br><br> 在下面，它们全部以灰度表示，但是从理论上讲，它们只是三个通道之一的值。 灰度只是为了说明结果。 <br><br><h4>  1.佩林的噪音 </h4><br> 如上所述，Perlin的噪音将是起点。 如果需要，可以使用单纯噪声，它的2D实现似乎不属于Ken Perlin，但我可能是错的。 从数学的角度来看，单纯形噪声使用较少的指令，因此类似星云的生成将更快。 由于它使用单纯形而不是网格，因此会产生更漂亮的噪点，但是我们不会对其进行过多处理，因此这并不是特别重要。 <br><br> 实际代码未在下面显示，因为在实际源中， <code>x,y</code>值在步骤3中被fBm更改。这只是图像的<code>x,y</code>坐标乘以静态比例因子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/df6/434/cacdf6434a755a3ae5dd27afbffc8ce2.png"></div><br>  <i>从每个像素的<code>x,y</code>坐标生成的Perlin噪声缩放为<code>0.3f</code> 。</i>  <i>即</i> <i><code>PixelValue = PerlinNoise(x * 0.3f, y * 0.3f)</code></i> <br><br>  Perlin噪声创建的值大约在<code>-1</code>到<code>1</code>的范围内，因此要创建上面显示的通常的灰度图像，我们将它们转换为<code>0</code>到<code>1</code>的间隔。 我测试了这些值的范围，以便转换产生最大的对比度（最低的值对应于<code>0</code> ，最大的对应于<code>1</code> ）。 <br><br><h4>  2.乘法 </h4><br> 下一个使用的模块将生成的噪声乘以<code>5</code> 。 这可以被认为是对比度的调整。 负值较暗，正值较亮。 <br><br> 我在这里没有显示任何内容，因为在将值从<code>-5</code>到<code>5</code>转换为<code>0</code>到<code>1</code>结果不会改变。 <br><br><h4>  3.分数布朗运动（fBM） </h4><br> 这个阶段将噪声变成许多人认为是真正的“噪声效应”。 在这里，我们从噪声函数（在本例中为<code>perlin(x,y)</code> ）执行越来越小的样本的八度音阶，以增加蓬松度。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/388/634/15b/38863415ba86694f3acc86618e7173d2.png"></div><br>  <i>上面显示的Perlin噪声的分数布朗运动。</i>  <i><code>8</code>个八度音阶，频率<code>.01f</code> ，规律性<code>.5f</code>和<code>2.5f</code></i> <br><br> 您已经可以看到有趣的事物的起源。 上面显示的图像不是通过缩放像素的<code>x,y</code>坐标生成的，fBM会这样做。 同样，将这些值反向转换为<code>0</code>到<code>1</code>的间隔到可能的<code>-5</code>到<code>5</code>间隔。 <br><br><h4>  4.限制（钳位） </h4><br> 现在，我将值限制为<code>-1</code>到<code>1</code> 。 超出此时间间隔的所有内容将被完全丢弃。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/f7a/b80/623f7ab80bc886e62d416726bcb63a09.png"></div><br>  <i>相同的fBm，限制为<code>-1</code> <code>1</code></i> <br><br> 此操作的任务是将这些值转换为较短的时间间隔，同时创建更陡峭的渐变并增加全白或全黑区域。 这些死或空的区域对于星云效应很重要，我们稍后将解决。 如果一开始我们没有乘以<code>5</code> ，那么钳位将不会有任何改变。 <br><br><h4>  5.加1 </h4><br> 现在我们从钳位中获取值并将它们加1.，从而将值传输到<code>0</code>到<code>2</code>的区间。 转换后，结果将与以前相同。 <br><br><h4>  6.除以2 </h4><br> 您可能知道我将结果除以<code>2</code> （乘以<code>.5</code> ）会发生什么。 在图像中，没有任何变化。 <br><br> 步骤5和6将值转换为<code>0</code>到<code>1</code>的范围。 <br><br><h4>  7.创建变形纹理 </h4><br> 下一步是创建变形纹理。 我将使用Perlin噪声（具有新的种子值）&gt;乘以4&gt;执行fBm来执行此操作。 在这种情况下，fBm使用<code>5</code>个八度音阶，频率为<code>0.025</code> ，规则度为<code>0.5</code>并且腔隙度为<code>1.5</code> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/937/748/b34937748b4e87736c9f09f464bc99dd.png"></div><br>  <i>变形纹理</i> <br><br> 为了创建比星云现有纹理更多的细节，需要这种纹理。 星云是一个相当大的波浪状云，这种质地会使它发生很小的变化。 通过它，Perlin噪声的网格性质将开始显现。 <br><br><h4>  8.使用偏移纹理偏移颜色纹理 </h4><br> 接下来，我将采用这两个纹理，并使用一个纹理将另一个纹理的坐标偏移一个因子。 在我们的例子中，组合看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>偏差结果</i> <br><br> 失真纹理用于更改我们在源噪声数据中寻找的<code>x,y</code>坐标。 <br><br> 请记住，上面显示的图像仅用于说明目的。 在每个阶段，我们实际上只有一个噪声函数。 我们给它传递值<code>x,y</code> ，它返回一个数字。 在某些阶段，此数字的间隔可能会有所不同，但在上面我们将其转换回灰度以创建图像。 通过使用噪声函数传输的图像的每个<code>x,y</code>坐标作为<code>x,y</code>来创建图像。 <br><br> 也就是说，当我们说： <br><br><blockquote> 给我X = 0和Y = 0的左上角像素的值 </blockquote><br> 函数返回一个数字。 如果我们向Perlin询问，我们知道它将在<code>-1</code>和<code>1</code>之间，如果如上所述，如果应用钳位，加法和乘法，我们将得到一个介于<code>0</code>和<code>1</code>之间的值。 <br><br> 了解了这一点后，我们了解到失真噪声函数会产生从<code>-1</code>到<code>1</code> 。 因此，当我们说： <br><br><blockquote> 给我像素X = 0和Y = 0的左上角像素的值 </blockquote><br> 偏移模块首先向偏移函数询问<code>x,y</code>坐标。 其结果在<code>-1</code>和<code>1</code>之间（与上面一样）。 然后乘以<code>40</code> （这是我选择的<em>系数</em> ）。 结果将是<code>-40</code>到<code>40</code>之间的值。 <br><br> 然后，我们使用该值并将其添加到要查找的<code>x,y</code>的坐标中，并使用此结果搜索颜色纹理。 由于将噪声函数（至少在我的噪声库中）无法找到负的<code>x,y</code>坐标，因此将钳位设为0可以消除负值。 <br><br> 也就是说，通常看起来像这样： <br><br><pre> <code class="cpp hljs">ColourFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DisplaceFunction(x,y) =     <span class="hljs-number"><span class="hljs-number">-1</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> DoDisplace(x,y) = { v = DisplaceFunction(x,y) * factor clamp(v,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>) x = x + v; y = y + v; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> then y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ColourFunction(x,y) }</code> </pre> <br> 希望您能理解。 实际上，我们并不是在看<code>x,y</code> ，而是在偏移处。 并且由于<em>幅度</em>也是一个平滑的梯度，因此它平滑地移动。 <br><br> 还有其他方法可以执行偏移。 我的噪音库有一个产生螺旋位移的模块。 它可以用来绘制纹理，逐渐减少到许多点。  <a href="">这是一个例子</a> 。 <br><br> 仅此而已。 我们对每个颜色通道使用新的种子值，将上述操作重复三遍。 您可以创建一个或两个通道。 我认为创建第三个不值得。 <br><br><h3> 阿尔法通道 </h3><br> 创建Alpha通道的方式与使用颜色通道的方式几乎相同： <br><br><ol><li> 我们从Perlin的噪音开始 </li><li> 乘以<code>5</code> </li><li> 具有<code>8</code>个八度音阶的fBM，频率<code>0.005</code> ，规则度<code>0.5</code>和腔隙度<code>2.5</code> </li><li> 我们使用Clamp将结果限制为<code>-1</code>到<code>1</code>的间隔，加<code>1</code> ，除以<code>2</code> （即我们将间隔从<code>-1</code>到<code>1</code>移到从<code>0</code>到<code>1</code>的间隔。 </li><li> 我们将结果向负方向少量移动。 我抵消了<code>0.4</code> 。 因此，一切都变得更暗了。 </li><li> 我们将结果限制为<code>0</code>到<code>1</code>的间隔。 由于我们移动了所有内容，使其变暗了一些，因此实际上，我们创建了更多具有<code>0</code>区域，并且某些区域变为负值。 </li></ol><br> 结果是alpha通道纹理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>阿尔法纹理</i> <br><br> 正如我所说，黑色区域将是透明的，而白色区域将是不透明的。 <br><br><h3> 通道遮罩 </h3><br> 这是用于创建覆盖在其他所有物体上的阴影的最后一个纹理。 就像所有其他纹理一样开始： <br><br><ol><li> 噪音珀林 </li><li> 乘以<code>5</code> </li><li> 我们执行fBm， <code>5</code>个八度音阶，频率<code>0.01</code> ，规律性<code>0.1</code> ，微弱度<code>0.1</code> 。 规律性小，因此云密度较小 </li><li> 执行从<code>-1</code>到<code>1</code>的间隔转换到从<code>0</code>到<code>1</code>的间隔转换 </li></ol><br> 但是我们创建了两个这样的纹理： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/11f/862/63011f8620c86a9bbf2f80d038a7c157.png"></div><br>  <i>遮罩</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/ae6/62e/271ae662e2038e09afba52bb2725d8cb.png"></div><br>  <i>面膜B</i> <br><br> 我们将这两个纹理暴露给我称为“ <em>选择”</em>模块的地方。 实际上，我们使用来自模块A或模块B的值。选择取决于模块C的值。它还需要另外两个值<em>-Select</em> <em>Point</em>和<em>Falloff</em> 。 <br><br> 如果模块C的点<code>x,y</code>值大于或等于<code>SelectPoint</code> ，则我们使用模块B的点<code>x,y</code>的值。如果值小于或等于<code>SelectPoint - Falloff</code> ，则我们使用模块A的<code>x,y</code>的值。 <br><br> 如果它在<code>SelectPoint - Falloff</code>和<code>SelectPoint</code> ，则我们在模块A和模块B的<code>x,y</code>值之间执行线性插值。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, moduleA, moduleB, moduleC, selectPoint, falloff)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s = moduleC(x,y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &gt;= selectPoint) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(s &lt;= selectPoint - falloff) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = moduleA(x,y); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = moduleB(x,y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lerp(a, b, (<span class="hljs-number"><span class="hljs-number">1.0</span></span> / ((selectPoint - (selectPoint-falloff)) / (selectPoint - s))); } }</code> </pre> <br> 在我们的例子中，模块A是一个<em>常量</em>模块，值为<code>0</code> 。 模块B是遮罩A的第一个纹理， <em>选择器</em> （模块C）是B的第二个遮罩<code>SelectPoint</code>将为<code>0.4</code> ，而<code>Falloff</code>将为<code>0.1</code> 。 结果，我们得到： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93a/46a/265/93a46a265f690650dec24eb5c56bcf32.png"></div><br>  <i>终极面膜</i> <br><br> 通过增加或减少<code>SelectPoint</code> ，我们减少或增加了蒙版中的黑色量。 通过增加或减少<code>falloff</code> ，我们可以增加或减少蒙版的软边缘。 除了使用其中一个掩码之外，我还可以使用<em>Constant</em>模块，其值为<code>1</code> ，但是我想向“未掩码”区域添加一些随机性。 <br><br><h3> 混合颜色通道和遮罩 </h3><br> 现在，我们需要为每个颜色通道应用一个蒙版。 这是使用<em>Blending</em>模块完成的。 它合并了两个模块中值的百分比，因此值的总和为100％。 <br><br> 也就是说，我们可以取模块A的<code>x,y</code>值的50％ <code>x,y</code>模块B的<code>x,y</code>的值的50％。或者取75％和25％，依此类推。 我们从每个模块获取的百分比取决于另一个模块-模块C。如果模块C的<code>x,y</code>值为<code>0</code> ，则我们将从模块A中获取100％，从模块B中获取0％。如果为<code>1</code> ，则我们获取逆值。 <br><br> 结合使用每种颜色纹理。 <br><br><ul><li> 模块A-常数0 </li><li> 模块B是我们已经看到的颜色通道 </li><li> 模块C-遮罩结果 </li></ul><br> 这意味着仅当蒙版的值大于<code>0</code> （接近白色）时，才会显示色彩通道的噪声，并且可见性的大小取决于蒙版的值。 <br><br> 这是我们示例的结果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>最终结果</i> <br><br> 在与面膜混合之前，将其与原始图像进行比较。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/44c/0ea/93f44c0ea7e040e0141925eede2673fd.png"></div><br>  <i>与面膜混合之前</i> <br><br> 也许这个例子不是很明显，但是由于偶然的原因，很难具体选择一个好的例子。 遮罩的作用是创建较暗的区域。 当然，您可以自定义蒙版，使它们更明显。 <br><br> 在此重要的是，将相同的蒙版应用于整个颜色通道，即，阴影中出现相同的区域。 <br><br><h3> 我们将所有东西结合在一起 </h3><br> 我们最初完成的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br>  <i>准备好例子</i> <br><br> 它使用红色，绿色和Alpha通道： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/f7e/e06/4daf7ee0635972da36bbb611250fb52d.png"></div><br>  <i>红色通道</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/001/8fb/c26/0018fbc263e0ae9983386f78428a0088.png"></div><br>  <i>绿色通道</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ee7/ba4/ee2ee7ba42267152dd2c6495828b5f17.png"></div><br>  <i>阿尔法通道</i> <br><br> 然后我们将它们放在星空之上。 <br><br> 现在一切看起来都不错，但并不非常适合像素艺术游戏。 我们需要减少颜色的数量... <br><br><h2> 中位数 </h2><br> 本文的这一部分可以应用于任何内容。 假设您要生成大理石纹理，并希望减少颜色数量。 这是中位数剪切算法派上用场的地方。 我们将使用它来减少上面显示的星云中的颜色数量。 <br><br> 这是在将其叠加在星空<em>之前</em>发生的。 颜色的数量是完全任意的。 <br><br> 维基百科中描述的中位数剪切算法： <br><br><blockquote> 假设我们有一个具有任意数量<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">像素</a>的图像，并且想要生成16种颜色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调色板</a> 。 将图像中的所有像素（即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RGB值</a> ）放入<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">垃圾桶</a> 。 找出篮子中所有像素中哪个颜色通道（红色，绿色或蓝色）具有最大的值范围，然后根据该通道的值对像素进行排序。 例如，如果蓝色通道的值范围最大，则RGB值（32、8、16）的像素小于RGB值（1、2、24）的像素，因为16 &lt;24。放入一个新的篮子。  （此步骤为中位数剪切算法起了名字；篮子被像素列表的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">中位数</a>除以一半。）对两个篮子重复该过程，这将给我们4个篮子，然后对所有4个篮子重复，得到8个篮子，然后对8个篮子重复，得到16篮子。 我们平均每个购物篮中的像素，并获得16种颜色的调色板。 由于购物篮的数量在每次迭代时都会翻倍，因此该算法只能生成这种调色板，其中颜色的数量是2 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的幂</a> 。 例如，要生成12色调色板，您需要首先生成16色调色板，然后以某种方式组合一些颜色。 <br><br> 资料来源： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//en.wikipedia.org/wiki/Median_cut</a> </blockquote><br> 在我看来，这种解释相当糟糕，并不是特别有用。 在实施该算法时，以这种方式可以获得相当难看的图像。 我通过一些更改实现了它： <br><br><ol><li> 我们将<code>boxes</code>容器与表示间隔的值一起存储（有关更多信息，请参见下文）。 该<code>box</code>仅存储原始图像中的一些动态像素。 </li><li> 将原始图像中的所有像素添加为第一个<code></code>并使用间隔<code>0</code> </li><li> 虽然<code></code>总数少于所需的颜色数量，但我们继续以下步骤。 </li><li> 如果interval值为<code>0</code> ，则对于每个当前框，我们确定该框的主要颜色通道，然后按该颜色对此<code>box</code>的像素进行排序。   —    Red, Green, Blue  Alpha,     . , <code>redRange = Max(Red) - Min(Red)</code> .           ,      . </li><li>           <code>box</code>   <code>boxes</code> .   ,        <code>box</code> . </li><li>  ,     4  5   <code>box</code> ,   <code>boxes</code>   .      ,         ,    ,     .     ,           ,      . </li><li>    <code>box</code> ( ==   )      <code>boxes</code> .               <code>0</code> (    ).  ,         ,       ,    — .            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们达到等于所需颜色数量的盒子数量时，我们只需对每个盒子中的所有像素进行平均，即可确定最适合这些颜色的调色板元素。</font><font style="vertical-align: inherit;">我只是使用了欧几里得距离，但是有一些感知解决方案可以更好地做到这一点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一张可以更清楚地说明所有内容的图片。</font><font style="vertical-align: inherit;">为了演示，我仅使用RGB，因为alpha很难显示。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/bb8/3fa/f3ebb83fa6aa4d15c0422ef3d66fd9ed.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们将此方法应用于示例图像。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原来的</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中位数最多可以切割16种颜色，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我发现当使用两个颜色通道时，使用16种颜色可以获得很好的效果。但请记住，这里我们使用alpha通道，该通道还涉及计算颜色之间的距离。因此，如果您不关心透明度，则可以使用更少的颜色。由于与Wikipedia示例不同，我的中位数剪切可以使用任意数量的颜色（而不仅仅是两个度），因此您可以自定义其颜色以满足您的需求。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70c/32e/828/70c32e82884077298e54db439472c866.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从16到2种颜色，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从每种</font><i><font style="vertical-align: inherit;">颜色中</font></i><font style="vertical-align: inherit;">选择一种颜色</font></font><code>box</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，只需对所有值进行平均即可。</font><font style="vertical-align: inherit;">但是，这不是唯一的方法。</font><font style="vertical-align: inherit;">您可能已经注意到，与原始结果相比，我们的结果不是那么好。</font><font style="vertical-align: inherit;">如果需要，则可以在较高的时间间隔中设置优先级，为时间间隔的定义增加权重。</font><font style="vertical-align: inherit;">或者，您可以轻松地选择图像中最亮的颜色的1、2或3种并将它们添加到调色板中。</font><font style="vertical-align: inherit;">因此，如果需要16种颜色，请生成13种颜色的调色板，然后手动添加亮色。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/48f/382/ce648f382b0be2409b25d24d682a528b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有三种最亮颜色的调色板</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，一切看起来都不错，但是图片太脏了。</font><font style="vertical-align: inherit;">它具有大面积的相同颜色。</font><font style="vertical-align: inherit;">现在我们需要解决它们。</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 抖动 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不需要告诉您什么是抖动，因为您已经在使用像素艺术。</font><font style="vertical-align: inherit;">因此，为了获得更平滑的图像，我们将使用其中一种抖动算法，该算法有很多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我实现了一个简单的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Floyd-Steinberg抖动</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">算法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">没有任何不愉快的惊喜。</font><font style="vertical-align: inherit;">但是，效果非常强。</font><font style="vertical-align: inherit;">这又是我们的示例：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/389/0b5/319/3890b53197b3d0e6fff931569bd330f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原来</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们再切到的16种颜色的调色板：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/617/875/453617875c9eb3c9ae389c74aaeb97da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些值将映射到16色调色板，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后进行抖动处理，然后转换为调色板：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84f/fa0/d82/84ffa0d82eb90de9f0e59c7ef718f753.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抖动完成的结果</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464203/">https://habr.com/ru/post/zh-CN464203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464189/index.html">如何创建一个开源项目</a></li>
<li><a href="../zh-CN464191/index.html">如何使用常驻代理解决聚合器站点问题</a></li>
<li><a href="../zh-CN464193/index.html">DevOps Deflope的开放式麦克风，不仅讲述了Skyeng和Nvidia的基础架构，</a></li>
<li><a href="../zh-CN464195/index.html">伏尔加格勒工作室Kefir的游戏《地球上的最后一天》的成功故事</a></li>
<li><a href="../zh-CN464197/index.html">TechTrain上会发生什么，我为什么要去那里？</a></li>
<li><a href="../zh-CN464205/index.html">人工智能和神经科学如何相互推动</a></li>
<li><a href="../zh-CN464207/index.html">从智人到易受人科学或成人安全意识影响的人</a></li>
<li><a href="../zh-CN464209/index.html">古腾堡（Gutenberg）编辑器，如何使编辑器和排字器更方便</a></li>
<li><a href="../zh-CN464217/index.html">如何在网络上可视化声音：精选主题材料和具有理论和实践意义的视频讲座</a></li>
<li><a href="../zh-CN464219/index.html">Timlid工具包，从电子邮件到看板</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>