<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öïÔ∏è üö∂üèª üòå Erstellen Sie einen Cartoon-Water-Shader f√ºr das Web. Teil 1 üïäÔ∏è üí∏ üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem Tutorial ‚ÄûErstellen von Shadern‚Äú habe ich mich haupts√§chlich mit Fragment-Shadern befasst, die ausreichen, um 2D-Effekte und Beispiele auf S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie einen Cartoon-Water-Shader f√ºr das Web. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> In meinem Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûErstellen von Shadern‚Äú habe</a> ich mich haupts√§chlich mit Fragment-Shadern befasst, die ausreichen, um 2D-Effekte und Beispiele auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">ShaderToy</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">implementieren</a> .  Es gibt jedoch eine ganze Kategorie von Techniken, die die Verwendung von Vertex-Shadern erfordern.  In diesem Tutorial werde ich √ºber das Erstellen eines stilisierten Cartoon-Wasser-Shaders sprechen und Ihnen Vertex-Shader vorstellen.  Ich werde auch √ºber den Tiefenpuffer sprechen und wie man ihn verwendet, um mehr Informationen √ºber die Szene zu erhalten und Linien aus Seeschaum zu erzeugen. <br><br>  So sieht der fertige Effekt aus.  Eine interaktive Demo finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Dieser Effekt besteht aus folgenden Elementen: <br><br><ol><li>  Ein durchscheinendes Wassernetz mit unterteilten Polygonen und versetzten Eckpunkten, um Wellen zu erzeugen. </li><li>  Statische Wasserleitungen an der Oberfl√§che. </li><li>  Simulierter Auftrieb des Bootes. </li><li>  Dynamische Schaumlinien um die Grenzen von Objekten im Wasser. </li><li>  Nachbearbeitung, um unter Wasser alles zu verzerren. </li></ol><br>  In diesem Effekt gef√§llt mir die Tatsache, dass es viele verschiedene Konzepte der Computergrafik ber√ºhrt, sodass wir die Ideen aus den vorherigen Tutorials verwenden und Techniken entwickeln k√∂nnen, die in neuen Effekten angewendet werden k√∂nnen. <br><a name="habracut"></a><br>  In diesem Tutorial werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">PlayCanvas verwenden</a> , einfach weil es eine praktische kostenlose Web-IDE ist, aber alles kann problemlos auf jede andere WebGL-Umgebung angewendet werden.  Am Ende des Artikels wird die Quellcodeversion f√ºr Three.js vorgestellt.  Wir gehen davon aus, dass Sie sich bereits mit Fragment-Shadern und der PlayCanvas-Oberfl√§che auskennen.  Hier k√∂nnen Sie Ihr Wissen √ºber Shader auffrischen und sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mit PlayCanvas vertraut machen. <br><br><h2>  Umgebungseinstellung </h2><br>  In diesem Abschnitt wird unser PlayCanvas-Projekt konfiguriert und mehrere Umgebungsobjekte eingef√ºgt, die durch Wasser beeinflusst werden. <br><br>  Wenn Sie kein PlayCanvas-Konto haben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">registrieren Sie es</a> und erstellen Sie ein neues <strong>leeres Projekt</strong> .  Standardm√§√üig sollten einige Objekte in der Szene, eine Kamera und eine Lichtquelle vorhanden sein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Modelle einf√ºgen </h3><br>  Eine gro√üartige Ressource zum Auffinden von 3D-Modellen f√ºr das Web ist das Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Poly-</a> Projekt.  Ich habe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Bootsmodell</a> von dort genommen.  Nach dem Herunterladen und Entpacken des Archivs finden Sie darin <code>.obj</code> und <code>.obj</code> Dateien. <br><br><ol><li>  Ziehen Sie beide Dateien in das Assets-Fenster des PlayCanvas-Projekts. </li><li>  W√§hlen Sie das automatisch generierte Material aus und w√§hlen Sie die <code>.png</code> Datei als diffuse Karte aus. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Jetzt k√∂nnen Sie <strong>Tugboat.json</strong> in die Szene ziehen und die Objekte Box und Plane l√∂schen.  Wenn das Boot zu klein aussieht, k√∂nnen Sie seine Skalierung erh√∂hen (ich habe den Wert auf 50 gesetzt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  Ebenso k√∂nnen Sie der Szene beliebige andere Modelle hinzuf√ºgen. <br><br><h3>  Umlaufende Kamera </h3><br>  Um die im Orbit fliegende Kamera zu konfigurieren, kopieren wir das Skript aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">diesem PlayCanvas-Beispiel</a> .  Folgen Sie dem Link und klicken Sie auf <strong>Editor</strong> , um das Projekt zu √∂ffnen. <br><br><ol><li>  Kopieren Sie den Inhalt von <code>mouse-input.js</code> und <code>orbit-camera.js</code> aus diesem Lernprogramm in gleichnamige Dateien aus Ihrem Projekt. </li><li>  F√ºgen Sie der Kamera eine <strong>Skriptkomponente hinzu</strong> . </li><li>  F√ºgen Sie der Kamera zwei Skripte hinzu. </li></ol><br><blockquote>  <em>Tipp: Um das Projekt zu organisieren, k√∂nnen Sie Ordner im Fenster Assets erstellen.</em>  <em>Ich habe diese beiden Kameraskripte im Ordner Scripts / Camera / abgelegt, mein Modell in Models / und das Material im Ordner Materials /.</em> </blockquote><br>  Wenn Sie jetzt das Spiel starten (die Starttaste im oberen rechten Teil des Szenenfensters), sollten Sie ein Boot sehen, das Sie mit einer Kamera inspizieren k√∂nnen, indem Sie es mit der Maus in die Umlaufbahn bewegen. <br><br><h2>  Wasseroberfl√§chen-Polygonabteilung </h2><br>  In diesem Abschnitt wird ein unterteiltes Netz erstellt, das als Wasseroberfl√§che verwendet wird. <br><br>  Um eine Wasseroberfl√§che zu erstellen, passen wir einen Teil des Codes aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Tutorial</a> zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Reliefgenerierung an</a> .  Erstellen Sie eine neue <code>Water.js</code> Skriptdatei.  √ñffnen Sie dieses Skript zum Bearbeiten und erstellen Sie eine neue <code>GeneratePlaneMesh</code> Funktion, die folgenderma√üen aussieht: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Jetzt k√∂nnen wir es in der <code>initialize</code> aufrufen: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Wenn Sie das Spiel starten, sollten Sie nur eine flache Oberfl√§che sehen.  Dies ist jedoch nicht nur eine flache Oberfl√§che, sondern ein Netz aus Tausenden von Gipfeln.  Versuchen Sie als √úbung, dies selbst zu √ºberpr√ºfen (dies ist ein guter Grund, den gerade kopierten Code zu studieren). <br><br><blockquote>  <em>Problem 1: Verschieben Sie die Y-Koordinate jedes Scheitelpunkts um einen zuf√§lligen Wert, sodass die Ebene wie in der folgenden Abbildung aussieht.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  Die Wellen </h2><br>  Der Zweck dieses Abschnitts besteht darin, die Wasseroberfl√§che Ihres eigenen Materials zu bestimmen und animierte Wellen zu erzeugen. <br><br>  Um die von uns ben√∂tigten Effekte zu erzielen, m√ºssen Sie Ihr eigenes Material konfigurieren.  Die meisten 3D-Engines verf√ºgen √ºber eine Reihe vordefinierter Shader zum Rendern von Objekten und zur Neudefinition.  Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">guter Link</a> dazu in PlayCanvas. <br><br><h3>  Shader-Anhang </h3><br>  Erstellen wir eine neue <code>CreateWaterMaterial</code> Funktion, <code>CreateWaterMaterial</code> neues Material mit einem ge√§nderten Shader definiert und zur√ºckgibt: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Diese Funktion √ºbernimmt den Vertex- und Fragment-Shader-Code aus den Skriptattributen.  Definieren wir sie also oben in der Datei (nach der Zeile <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Jetzt k√∂nnen wir diese Shader-Dateien erstellen und an unser Skript anh√§ngen.  <strong>Kehren</strong> Sie zum Editor zur√ºck und erstellen Sie zwei Shader-Dateien: <strong>Water.frag</strong> und <strong>Water.vert</strong> .  F√ºgen Sie diese Shader wie in der folgenden Abbildung gezeigt an das Skript an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Wenn die neuen Attribute nicht im Editor angezeigt werden, klicken Sie auf die Schaltfl√§che <strong>Analysieren</strong> , um das Skript zu aktualisieren. <br><br>  <strong>F√ºgen Sie</strong> nun diesen grundlegenden Shader in <strong>Water.frag ein</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  Und dieser ist in <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  <strong>Kehren Sie</strong> schlie√ülich zu <strong>Water.js zur√ºck</strong> , um unser neues Material anstelle des Standardmaterials zu verwenden.  Das hei√üt, anstelle von: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  einf√ºgen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Jetzt, nach dem Start des Spiels, sollte das Flugzeug blau sein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Hei√üer Neustart </h3><br>  Im Moment haben wir nur Shader-Rohlinge f√ºr unser neues Material eingerichtet.  Bevor ich anfange, echte Effekte zu schreiben, m√∂chte ich das automatische Neuladen von Code einrichten. <br><br>  Nachdem Sie die <code>swap</code> Funktion in einer Skriptdatei (z. B. in Water.js) auskommentiert haben, aktivieren wir das Hot-Reloading.  Sp√§ter werden wir sehen, wie Sie diesen Status verwenden k√∂nnen, auch wenn Sie den Code in Echtzeit aktualisieren.  Im Moment m√∂chten wir die Shader jedoch nur erneut anwenden, nachdem wir die √Ñnderungen vorgenommen haben.  Vor dem Ausf√ºhren in WebGL werden Shader kompiliert. Dazu m√ºssen wir unser Material neu erstellen. <br><br>  Wir werden pr√ºfen, ob sich der Inhalt unseres Shader-Codes ge√§ndert hat, und in diesem Fall das Material erneut erstellen.  Speichern Sie zun√§chst die aktuellen Shader in <strong>initialize</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Und im <strong>Update</strong> pr√ºfen wir, ob √Ñnderungen aufgetreten sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Um sicherzustellen, dass dies funktioniert, starten Sie das Spiel und √§ndern Sie die Farbe des Flugzeugs in <strong>Water.frag</strong> in ein angenehmeres Blau.  Nach dem Speichern der Datei sollte diese auch ohne Neustart und Neustart aktualisiert werden!  Hier ist die Farbe, die ich gew√§hlt habe: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shader </h4><br>  Um Wellen zu erzeugen, m√ºssen wir jeden Scheitelpunkt unseres Netzes in jedem Frame verschieben.  Es scheint sehr ineffizient zu sein, aber jeder Scheitelpunkt jedes Modells ist bereits in jedem gerenderten Frame transformiert.  Dies ist, was der Vertex-Shader tut. <br><br>  Wenn wir einen Fragment-Shader als eine Funktion wahrnehmen, die f√ºr jedes Pixel ausgef√ºhrt wird, seine Position erh√§lt und Farbe zur√ºckgibt, ist ein <em>Vertex-Shader eine Funktion, die f√ºr jeden Vertex ausgef√ºhrt wird, seine Position erh√§lt und seine Position zur√ºckgibt</em> . <br><br>  Ein Vertex-Shader erh√§lt standardm√§√üig eine <em>Position in der</em> Modellwelt und gibt seine <em>Position auf dem Bildschirm zur√ºck</em> .  Unsere 3D-Szene wird in x-, y- und z-Koordinaten eingestellt, aber der Monitor ist eine flache zweidimensionale Ebene, sodass wir eine 3D-Welt auf einen 2D-Bildschirm projizieren.  Matrizen des Typs, der Projektion und des Modells sind an einer solchen Projektion beteiligt, daher werden wir sie in diesem Tutorial nicht ber√ºcksichtigen.  Wenn Sie jedoch verstehen m√∂chten, was in jeder Phase genau passiert, finden Sie hier eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">sehr gute Anleitung</a> . <br><br>  Das hei√üt, diese Zeile: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  empf√§ngt <code>aPosition</code> als Position in der 3D-Welt eines bestimmten Scheitelpunkts und konvertiert sie in <code>gl_Position</code> , <code>gl_Position</code> in die endg√ºltige Position auf dem 2D-Bildschirm.  Das Pr√§fix "a" in aPosition gibt an, dass dieser Wert ein <em>Attribut ist</em> .  Vergessen Sie nicht, dass die Variable <em>uniform</em> ein Wert ist, den wir in der CPU definieren und an den Shader √ºbergeben k√∂nnen.  Der Wert bleibt f√ºr alle Pixel / Eckpunkte gleich.  Andererseits wird der Attributwert aus dem angegebenen CPU- <em>Array erhalten</em> .  F√ºr jeden Wert dieses Attributarrays wird ein Vertex-Shader aufgerufen. <br><br>  Sie k√∂nnen sehen, dass diese Attribute in der Shader-Definition konfiguriert sind, die wir in Water.js festgelegt haben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  PlayCanvas k√ºmmert sich um das Einrichten und √úbertragen eines Arrays von Scheitelpunktpositionen f√ºr <code>aPosition</code> wenn diese Aufz√§hlung √ºbergeben wird. Im allgemeinen Fall k√∂nnen wir jedoch jedes Datenarray an den Scheitelpunkt-Shader √ºbergeben. <br><br><h3>  Scheitelpunktbewegung </h3><br>  Angenommen, wir m√∂chten die gesamte Ebene komprimieren, indem wir alle <code>x</code> Werte mit 0,5 multiplizieren.  M√ºssen wir <code>aPosition</code> oder <code>gl_Position</code> ? <br><br>  Versuchen <code>aPosition</code> zuerst <code>aPosition</code> .  Wir k√∂nnen das Attribut nicht direkt √§ndern, aber wir k√∂nnen eine Kopie erstellen: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Jetzt sollte die Ebene eher wie ein Rechteck aussehen.  Und daran ist nichts Seltsames.  Aber was passiert, wenn wir <code>gl_Position</code> versuchen, <code>gl_Position</code> zu √§ndern? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Bis Sie die Kamera bewegen, sieht sie m√∂glicherweise gleich aus.  Wir √§ndern die Koordinaten des Bildschirmbereichs, dh das Bild h√§ngt davon ab, <em>wie wir es betrachten</em> . <br><br>  So k√∂nnen wir die Eckpunkte verschieben, und gleichzeitig ist es wichtig, zwischen Arbeit in der Welt und Bildschirmr√§umen zu unterscheiden. <br><br><blockquote>  <em>Aufgabe 2: K√∂nnen Sie die gesamte Oberfl√§che der Ebene im Vertex-Shader um mehrere Einheiten (entlang der Y-Achse) nach oben verschieben, ohne die Form zu verzerren?</em> </blockquote><br><blockquote>  <em>Aufgabe 3: Ich sagte, dass gl_Position zweidimensional ist, aber gl_Position.z existiert auch.</em>  <em>K√∂nnen Sie √ºberpr√ºfen, ob sich dieser Wert auf etwas auswirkt, und wenn ja, wof√ºr wird er verwendet?</em> </blockquote><br><h3>  Zeit hinzuf√ºgen </h3><br>  Das Letzte, was wir brauchen, um bewegte Wellen zu erzeugen, ist eine einheitliche Variable, die als Zeit verwendet werden kann.  Deklarieren Sie die Uniform im Vertex-Shader: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  <strong>Um</strong> es nun an den Shader zu √ºbergeben, <strong>kehren wir</strong> zu <strong>Water.js zur√ºck</strong> und definieren die Zeitvariable in initialize: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Um die Variable auf den Shader zu √ºbertragen, verwenden wir jetzt <code>material.setParameter</code> .  Zuerst setzen wir den Anfangswert am Ende der <code>CreateWaterMaterial</code> Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Jetzt k√∂nnen wir in der <code>update</code> einen Zeitschritt ausf√ºhren und √ºber den daf√ºr erstellten Link auf das Material zugreifen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Schlie√ülich kopieren wir in der Swap-Funktion den alten Zeitwert so, dass er auch nach dem √Ñndern des Codes weiter zunimmt, ohne auf 0 zur√ºckgesetzt zu werden. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Jetzt ist alles fertig.  F√ºhren Sie das Spiel aus, um sicherzustellen, dass keine Fehler vorliegen.  Bewegen wir nun unser Flugzeug mit der Zeitfunktion in <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  Und unser Flugzeug sollte sich auf und ab bewegen!  Da wir jetzt eine Swap-Funktion haben, k√∂nnen wir Water.js auch aktualisieren, ohne neu starten zu m√ºssen.  Versuchen Sie, das Zeitinkrement zu √§ndern, um sicherzustellen, dass dies funktioniert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Aufgabe 4: K√∂nnen Sie die Eckpunkte so verschieben, dass sie wie die Wellen in der folgenden Abbildung aussehen?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Lassen Sie mich Ihnen sagen, dass ich das Thema der verschiedenen Arten der Wellenerzeugung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> im Detail untersucht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">habe</a> .  Der Artikel bezieht sich auf 2D, aber mathematische Berechnungen sind auf unseren Fall anwendbar.  Wenn Sie nur die L√∂sung sehen m√∂chten, dann ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier das Wesentliche</a> . <br><br><h2>  Transluzenz </h2><br>  Der Zweck dieses Abschnitts besteht darin, eine durchscheinende Wasseroberfl√§che zu schaffen. <br><br>  M√∂glicherweise stellen Sie fest, dass die an Water.frag zur√ºckgegebene Farbe einen Alpha-Kanalwert von 0,5 hat, die Oberfl√§che jedoch weiterhin undurchsichtig bleibt.  In vielen F√§llen wird Transparenz in der Computergrafik immer noch zu einem ungel√∂sten Problem.  Eine kosteng√ºnstige M√∂glichkeit, dies zu l√∂sen, ist das Mischen. <br><br>  Normalerweise √ºberpr√ºft es vor dem Zeichnen eines Pixels den Wert im <em>Tiefenpuffer</em> und vergleicht ihn mit seinem eigenen Tiefenwert (seiner Position entlang der Z-Achse), um festzustellen, ob das aktuelle Bildschirmpixel neu gezeichnet werden soll oder nicht.  Auf diese Weise k√∂nnen Sie die Szene korrekt rendern, ohne Objekte von hinten nach vorne sortieren zu m√ºssen. <br><br>  Beim Mischen k√∂nnen wir, anstatt das Pixel einfach abzulehnen oder zu √ºberschreiben, die Farbe des bereits gerenderten Pixels (Ziels) mit dem Pixel kombinieren, das wir zeichnen m√∂chten (die Quelle).  Eine Liste aller in WebGL verf√ºgbaren Mischfunktionen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> . <br><br>  Damit der Alpha-Kanal unseren Erwartungen entspricht, m√∂chten wir, dass die kombinierte Farbe des Ergebnisses eine Quelle multipliziert mit einem Alpha-Kanal plus einem Zielpixel multipliziert mit einem minus Alpha ist.  Mit anderen Worten, wenn Alpha = 0,4 ist, sollte die endg√ºltige Farbe einen Wert haben: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  In PlayCanvas ist dies die Operation, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">pc.BLEND_NORMAL ausf√ºhrt</a> . <br><br>  Um es zu aktivieren, legen Sie einfach die Materialeigenschaft in <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Wenn Sie jetzt das Spiel starten, wird das Wasser durchscheinend!  Es ist jedoch immer noch unvollkommen.  Das Problem tritt auf, wenn die durchscheinende Oberfl√§che sich selbst √ºberlagert, wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Wir k√∂nnen es beseitigen, indem wir <em>Alpha to Coverage verwenden</em> , eine Multisampling-Technik f√ºr Transparenz, anstatt zu mischen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Es ist jedoch nur in WebGL 2 verf√ºgbar. Im weiteren Verlauf des Tutorials werde ich der Einfachheit halber das Mischen verwenden. <br><br><h2>  Zusammenfassend </h2><br>  Wir haben die Umgebung eingerichtet und eine durchscheinende Wasseroberfl√§che mit animierten Wellen vom Vertex-Shader erstellt.  Im zweiten Teil des Tutorials werden wir den Auftrieb von Objekten betrachten, Linien zur Wasseroberfl√§che hinzuf√ºgen und Schaumlinien entlang der Grenzen von Objekten erstellen, die sich mit der Oberfl√§che schneiden. <br><br>  Im dritten (letzten) Teil werden wir die Anwendung des Nachbearbeitungseffekts von Unterwasserverzerrungen betrachten und Ideen f√ºr weitere Verbesserungen pr√ºfen. <br><br><h2>  Quellcode </h2><br>  Das fertige PlayCanvas-Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> .  Unser Repository hat auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Projektport unter Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416953/">https://habr.com/ru/post/de416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416943/index.html">N√ºtzliche Materialien zum Entwerfen von Sprachschnittstellen</a></li>
<li><a href="../de416945/index.html">Wie wir BelAZ gemacht haben. Teil 1 - Eisen</a></li>
<li><a href="../de416947/index.html">Spielen Sie das Spiel vor den Olympischen Spielen: eSports wird offiziell</a></li>
<li><a href="../de416949/index.html">Das umfassende Upgrade von Herrn Steven zur Installation eines vierfach gr√∂√üeren Jagdnetzwerks wurde abgeschlossen</a></li>
<li><a href="../de416951/index.html">Kubernetes-Cluster im VPC-Dienst</a></li>
<li><a href="../de416955/index.html">Kleine Tricks mit Elasticsearch</a></li>
<li><a href="../de416957/index.html">Welche Lasermaschine kaufen? Zuverl√§ssiger Raylogic 11G Lasermaschinen-Test</a></li>
<li><a href="../de416959/index.html">Apple f√ºhrt neue iOS-Diebstahlschutzfunktion ein</a></li>
<li><a href="../de416961/index.html">Automatische Konfliktl√∂sung mithilfe operativer Transformationen</a></li>
<li><a href="../de416963/index.html">Wie wir BelAZ gemacht haben. Teil 2 - Labortests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>