<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚕️ 🚶🏻 😌 Erstellen Sie einen Cartoon-Water-Shader für das Web. Teil 1 🕊️ 💸 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In meinem Tutorial „Erstellen von Shadern“ habe ich mich hauptsächlich mit Fragment-Shadern befasst, die ausreichen, um 2D-Effekte und Beispiele auf S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen Sie einen Cartoon-Water-Shader für das Web. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416953/"> In meinem Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Erstellen von Shadern“ habe</a> ich mich hauptsächlich mit Fragment-Shadern befasst, die ausreichen, um 2D-Effekte und Beispiele auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">ShaderToy</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">implementieren</a> .  Es gibt jedoch eine ganze Kategorie von Techniken, die die Verwendung von Vertex-Shadern erfordern.  In diesem Tutorial werde ich über das Erstellen eines stilisierten Cartoon-Wasser-Shaders sprechen und Ihnen Vertex-Shader vorstellen.  Ich werde auch über den Tiefenpuffer sprechen und wie man ihn verwendet, um mehr Informationen über die Szene zu erhalten und Linien aus Seeschaum zu erzeugen. <br><br>  So sieht der fertige Effekt aus.  Eine interaktive Demo finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/58d/814/c3858d814aa8ca99c2c0c58535503482.jpg"></div><br>  Dieser Effekt besteht aus folgenden Elementen: <br><br><ol><li>  Ein durchscheinendes Wassernetz mit unterteilten Polygonen und versetzten Eckpunkten, um Wellen zu erzeugen. </li><li>  Statische Wasserleitungen an der Oberfläche. </li><li>  Simulierter Auftrieb des Bootes. </li><li>  Dynamische Schaumlinien um die Grenzen von Objekten im Wasser. </li><li>  Nachbearbeitung, um unter Wasser alles zu verzerren. </li></ol><br>  In diesem Effekt gefällt mir die Tatsache, dass es viele verschiedene Konzepte der Computergrafik berührt, sodass wir die Ideen aus den vorherigen Tutorials verwenden und Techniken entwickeln können, die in neuen Effekten angewendet werden können. <br><a name="habracut"></a><br>  In diesem Tutorial werde ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">PlayCanvas verwenden</a> , einfach weil es eine praktische kostenlose Web-IDE ist, aber alles kann problemlos auf jede andere WebGL-Umgebung angewendet werden.  Am Ende des Artikels wird die Quellcodeversion für Three.js vorgestellt.  Wir gehen davon aus, dass Sie sich bereits mit Fragment-Shadern und der PlayCanvas-Oberfläche auskennen.  Hier können Sie Ihr Wissen über Shader auffrischen und sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> mit PlayCanvas vertraut machen. <br><br><h2>  Umgebungseinstellung </h2><br>  In diesem Abschnitt wird unser PlayCanvas-Projekt konfiguriert und mehrere Umgebungsobjekte eingefügt, die durch Wasser beeinflusst werden. <br><br>  Wenn Sie kein PlayCanvas-Konto haben, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">registrieren Sie es</a> und erstellen Sie ein neues <strong>leeres Projekt</strong> .  Standardmäßig sollten einige Objekte in der Szene, eine Kamera und eine Lichtquelle vorhanden sein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f57/00e/57f/f5700e57f7434006e48831c30378d0df.png"></div><br><h3>  Modelle einfügen </h3><br>  Eine großartige Ressource zum Auffinden von 3D-Modellen für das Web ist das Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Poly-</a> Projekt.  Ich habe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Bootsmodell</a> von dort genommen.  Nach dem Herunterladen und Entpacken des Archivs finden Sie darin <code>.obj</code> und <code>.obj</code> Dateien. <br><br><ol><li>  Ziehen Sie beide Dateien in das Assets-Fenster des PlayCanvas-Projekts. </li><li>  Wählen Sie das automatisch generierte Material aus und wählen Sie die <code>.png</code> Datei als diffuse Karte aus. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b60/499/7cc/b604997ccaad7c5d0d97a81f6da3be98.png"></div><br>  Jetzt können Sie <strong>Tugboat.json</strong> in die Szene ziehen und die Objekte Box und Plane löschen.  Wenn das Boot zu klein aussieht, können Sie seine Skalierung erhöhen (ich habe den Wert auf 50 gesetzt). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4c/307/250/c4c30725001beeacf4a2149735f95a1b.png"></div><br>  Ebenso können Sie der Szene beliebige andere Modelle hinzufügen. <br><br><h3>  Umlaufende Kamera </h3><br>  Um die im Orbit fliegende Kamera zu konfigurieren, kopieren wir das Skript aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">diesem PlayCanvas-Beispiel</a> .  Folgen Sie dem Link und klicken Sie auf <strong>Editor</strong> , um das Projekt zu öffnen. <br><br><ol><li>  Kopieren Sie den Inhalt von <code>mouse-input.js</code> und <code>orbit-camera.js</code> aus diesem Lernprogramm in gleichnamige Dateien aus Ihrem Projekt. </li><li>  Fügen Sie der Kamera eine <strong>Skriptkomponente hinzu</strong> . </li><li>  Fügen Sie der Kamera zwei Skripte hinzu. </li></ol><br><blockquote>  <em>Tipp: Um das Projekt zu organisieren, können Sie Ordner im Fenster Assets erstellen.</em>  <em>Ich habe diese beiden Kameraskripte im Ordner Scripts / Camera / abgelegt, mein Modell in Models / und das Material im Ordner Materials /.</em> </blockquote><br>  Wenn Sie jetzt das Spiel starten (die Starttaste im oberen rechten Teil des Szenenfensters), sollten Sie ein Boot sehen, das Sie mit einer Kamera inspizieren können, indem Sie es mit der Maus in die Umlaufbahn bewegen. <br><br><h2>  Wasseroberflächen-Polygonabteilung </h2><br>  In diesem Abschnitt wird ein unterteiltes Netz erstellt, das als Wasseroberfläche verwendet wird. <br><br>  Um eine Wasseroberfläche zu erstellen, passen wir einen Teil des Codes aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Tutorial</a> zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Reliefgenerierung an</a> .  Erstellen Sie eine neue <code>Water.js</code> Skriptdatei.  Öffnen Sie dieses Skript zum Bearbeiten und erstellen Sie eine neue <code>GeneratePlaneMesh</code> Funktion, die folgendermaßen aussieht: <br><br><pre> <code class="javascript hljs">Water.prototype.GeneratePlaneMesh = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// 1 -    ,     if(options === undefined) options = {subdivisions:100, width:10, height:10}; // 2 -  , UV   var positions = []; var uvs = []; var indices = []; var row, col; var normals; for (row = 0; row &lt;= options.subdivisions; row++) { for (col = 0; col &lt;= options.subdivisions; col++) { var position = new pc.Vec3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0)); positions.push(position.x, position.y, position.z); uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions); } } for (row = 0; row &lt; options.subdivisions; row++) { for (col = 0; col &lt; options.subdivisions; col++) { indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + row * (options.subdivisions + 1)); indices.push(col + 1 + (row + 1) * (options.subdivisions + 1)); indices.push(col + (row + 1) * (options.subdivisions + 1)); } } //   normals = pc.calculateNormals(positions, indices); //    var node = new pc.GraphNode(); var material = new pc.StandardMaterial(); //   var mesh = pc.createMesh(this.app.graphicsDevice, positions, { normals: normals, uvs: uvs, indices: indices }); var meshInstance = new pc.MeshInstance(node, mesh, material); //      var model = new pc.Model(); model.graph = node; model.meshInstances.push(meshInstance); this.entity.addComponent('model'); this.entity.model.model = model; this.entity.model.castShadows = false; //   ,       };</span></span></code> </pre> <br>  Jetzt können wir es in der <code>initialize</code> aufrufen: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GeneratePlaneMesh({<span class="hljs-attr"><span class="hljs-attr">subdivisions</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-attr"><span class="hljs-attr">height</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>}); };</code> </pre> <br>  Wenn Sie das Spiel starten, sollten Sie nur eine flache Oberfläche sehen.  Dies ist jedoch nicht nur eine flache Oberfläche, sondern ein Netz aus Tausenden von Gipfeln.  Versuchen Sie als Übung, dies selbst zu überprüfen (dies ist ein guter Grund, den gerade kopierten Code zu studieren). <br><br><blockquote>  <em>Problem 1: Verschieben Sie die Y-Koordinate jedes Scheitelpunkts um einen zufälligen Wert, sodass die Ebene wie in der folgenden Abbildung aussieht.</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/397/111/391/397111391bbb4e1cafd0e658005ed1cc.jpg"></div><br><h2>  Die Wellen </h2><br>  Der Zweck dieses Abschnitts besteht darin, die Wasseroberfläche Ihres eigenen Materials zu bestimmen und animierte Wellen zu erzeugen. <br><br>  Um die von uns benötigten Effekte zu erzielen, müssen Sie Ihr eigenes Material konfigurieren.  Die meisten 3D-Engines verfügen über eine Reihe vordefinierter Shader zum Rendern von Objekten und zur Neudefinition.  Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">guter Link</a> dazu in PlayCanvas. <br><br><h3>  Shader-Anhang </h3><br>  Erstellen wir eine neue <code>CreateWaterMaterial</code> Funktion, <code>CreateWaterMaterial</code> neues Material mit einem geänderten Shader definiert und zurückgibt: <br><br><pre> <code class="javascript hljs">Water.prototype.CreateWaterMaterial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     var material = new pc.Material(); //    ,       material.name = "DynamicWater_Material"; //    //        . var gd = this.app.graphicsDevice; var fragmentShader = "precision " + gd.precision + " float;\n"; fragmentShader = fragmentShader + this.fs.resource; var vertexShader = this.vs.resource; //       . var shaderDefinition = { attributes: { aPosition: pc.gfx.SEMANTIC_POSITION, aUv0: pc.SEMANTIC_TEXCOORD0, }, vshader: vertexShader, fshader: fragmentShader }; //     this.shader = new pc.Shader(gd, shaderDefinition); //      material.setShader(this.shader); return material; };</span></span></code> </pre> <br>  Diese Funktion übernimmt den Vertex- und Fragment-Shader-Code aus den Skriptattributen.  Definieren wir sie also oben in der Datei (nach der Zeile <code>pc.createScript</code> ): <br><br><pre> <code class="javascript hljs">Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'vs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Vertex Shader'</span></span> }); Water.attributes.add(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'asset'</span></span>, <span class="hljs-attr"><span class="hljs-attr">assetType</span></span>: <span class="hljs-string"><span class="hljs-string">'shader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'Fragment Shader'</span></span> });</code> </pre> <br>  Jetzt können wir diese Shader-Dateien erstellen und an unser Skript anhängen.  <strong>Kehren</strong> Sie zum Editor zurück und erstellen Sie zwei Shader-Dateien: <strong>Water.frag</strong> und <strong>Water.vert</strong> .  Fügen Sie diese Shader wie in der folgenden Abbildung gezeigt an das Skript an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a2/fa4/d8a/0a2fa4d8a998e8abe1fc63da301f0ad9.png"></div><br>  Wenn die neuen Attribute nicht im Editor angezeigt werden, klicken Sie auf die Schaltfläche <strong>Analysieren</strong> , um das Skript zu aktualisieren. <br><br>  <strong>Fügen Sie</strong> nun diesen grundlegenden Shader in <strong>Water.frag ein</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>); gl_FragColor = color; }</code> </pre> <br>  Und dieser ist in <strong>Water.vert</strong> : <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  <strong>Kehren Sie</strong> schließlich zu <strong>Water.js zurück</strong> , um unser neues Material anstelle des Standardmaterials zu verwenden.  Das heißt, anstelle von: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> pc.StandardMaterial();</code> </pre> <br>  einfügen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CreateWaterMaterial();</code> </pre> <br>  Jetzt, nach dem Start des Spiels, sollte das Flugzeug blau sein. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/797/8ff/e797978ff286ff2f15b3b8465debf767.png"></div><br><h3>  Heißer Neustart </h3><br>  Im Moment haben wir nur Shader-Rohlinge für unser neues Material eingerichtet.  Bevor ich anfange, echte Effekte zu schreiben, möchte ich das automatische Neuladen von Code einrichten. <br><br>  Nachdem Sie die <code>swap</code> Funktion in einer Skriptdatei (z. B. in Water.js) auskommentiert haben, aktivieren wir das Hot-Reloading.  Später werden wir sehen, wie Sie diesen Status verwenden können, auch wenn Sie den Code in Echtzeit aktualisieren.  Im Moment möchten wir die Shader jedoch nur erneut anwenden, nachdem wir die Änderungen vorgenommen haben.  Vor dem Ausführen in WebGL werden Shader kompiliert. Dazu müssen wir unser Material neu erstellen. <br><br>  Wir werden prüfen, ob sich der Inhalt unseres Shader-Codes geändert hat, und in diesem Fall das Material erneut erstellen.  Speichern Sie zunächst die aktuellen Shader in <strong>initialize</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  initialize,       Water.prototype.initialize = function() { this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Und im <strong>Update</strong> prüfen wir, ob Änderungen aufgetreten sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  update,     Water.prototype.update = function(dt) { if(this.savedFS != this.fs.resource || this.savedVS != this.vs.resource){ //   ,      var newMaterial = this.CreateWaterMaterial(); //     var model = this.entity.model.model; model.meshInstances[0].material = newMaterial; //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; } };</span></span></code> </pre> <br>  Um sicherzustellen, dass dies funktioniert, starten Sie das Spiel und ändern Sie die Farbe des Flugzeugs in <strong>Water.frag</strong> in ein angenehmeres Blau.  Nach dem Speichern der Datei sollte diese auch ohne Neustart und Neustart aktualisiert werden!  Hier ist die Farbe, die ich gewählt habe: <br><br><pre> <code class="javascript hljs">vec4 color = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.7</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.5</span></span>);</code> </pre> <br><h4>  Vertex Shader </h4><br>  Um Wellen zu erzeugen, müssen wir jeden Scheitelpunkt unseres Netzes in jedem Frame verschieben.  Es scheint sehr ineffizient zu sein, aber jeder Scheitelpunkt jedes Modells ist bereits in jedem gerenderten Frame transformiert.  Dies ist, was der Vertex-Shader tut. <br><br>  Wenn wir einen Fragment-Shader als eine Funktion wahrnehmen, die für jedes Pixel ausgeführt wird, seine Position erhält und Farbe zurückgibt, ist ein <em>Vertex-Shader eine Funktion, die für jeden Vertex ausgeführt wird, seine Position erhält und seine Position zurückgibt</em> . <br><br>  Ein Vertex-Shader erhält standardmäßig eine <em>Position in der</em> Modellwelt und gibt seine <em>Position auf dem Bildschirm zurück</em> .  Unsere 3D-Szene wird in x-, y- und z-Koordinaten eingestellt, aber der Monitor ist eine flache zweidimensionale Ebene, sodass wir eine 3D-Welt auf einen 2D-Bildschirm projizieren.  Matrizen des Typs, der Projektion und des Modells sind an einer solchen Projektion beteiligt, daher werden wir sie in diesem Tutorial nicht berücksichtigen.  Wenn Sie jedoch verstehen möchten, was in jeder Phase genau passiert, finden Sie hier eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">sehr gute Anleitung</a> . <br><br>  Das heißt, diese Zeile: <br><br><pre> <code class="javascript hljs">gl_Position = matrix_viewProjection * matrix_model * vec4(aPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>);</code> </pre> <br>  empfängt <code>aPosition</code> als Position in der 3D-Welt eines bestimmten Scheitelpunkts und konvertiert sie in <code>gl_Position</code> , <code>gl_Position</code> in die endgültige Position auf dem 2D-Bildschirm.  Das Präfix "a" in aPosition gibt an, dass dieser Wert ein <em>Attribut ist</em> .  Vergessen Sie nicht, dass die Variable <em>uniform</em> ein Wert ist, den wir in der CPU definieren und an den Shader übergeben können.  Der Wert bleibt für alle Pixel / Eckpunkte gleich.  Andererseits wird der Attributwert aus dem angegebenen CPU- <em>Array erhalten</em> .  Für jeden Wert dieses Attributarrays wird ein Vertex-Shader aufgerufen. <br><br>  Sie können sehen, dass diese Attribute in der Shader-Definition konfiguriert sind, die wir in Water.js festgelegt haben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaderDefinition = { <span class="hljs-attr"><span class="hljs-attr">attributes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">aPosition</span></span>: pc.gfx.SEMANTIC_POSITION, <span class="hljs-attr"><span class="hljs-attr">aUv0</span></span>: pc.SEMANTIC_TEXCOORD0, }, <span class="hljs-attr"><span class="hljs-attr">vshader</span></span>: vertexShader, <span class="hljs-attr"><span class="hljs-attr">fshader</span></span>: fragmentShader };</code> </pre> <br>  PlayCanvas kümmert sich um das Einrichten und Übertragen eines Arrays von Scheitelpunktpositionen für <code>aPosition</code> wenn diese Aufzählung übergeben wird. Im allgemeinen Fall können wir jedoch jedes Datenarray an den Scheitelpunkt-Shader übergeben. <br><br><h3>  Scheitelpunktbewegung </h3><br>  Angenommen, wir möchten die gesamte Ebene komprimieren, indem wir alle <code>x</code> Werte mit 0,5 multiplizieren.  Müssen wir <code>aPosition</code> oder <code>gl_Position</code> ? <br><br>  Versuchen <code>aPosition</code> zuerst <code>aPosition</code> .  Wir können das Attribut nicht direkt ändern, aber wir können eine Kopie erstellen: <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; pos.x *= <span class="hljs-number"><span class="hljs-number">0.5</span></span>; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Jetzt sollte die Ebene eher wie ein Rechteck aussehen.  Und daran ist nichts Seltsames.  Aber was passiert, wenn wir <code>gl_Position</code> versuchen, <code>gl_Position</code> zu ändern? <br><br><pre> <code class="javascript hljs">attribute vec3 aPosition; uniform mat4 matrix_model; uniform mat4 matrix_viewProjection; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { vec3 pos = aPosition; <span class="hljs-comment"><span class="hljs-comment">//pos.x *= 0.5; gl_Position = matrix_viewProjection * matrix_model * vec4(pos, 1.0); gl_Position.x *= 0.5; }</span></span></code> </pre> <br>  Bis Sie die Kamera bewegen, sieht sie möglicherweise gleich aus.  Wir ändern die Koordinaten des Bildschirmbereichs, dh das Bild hängt davon ab, <em>wie wir es betrachten</em> . <br><br>  So können wir die Eckpunkte verschieben, und gleichzeitig ist es wichtig, zwischen Arbeit in der Welt und Bildschirmräumen zu unterscheiden. <br><br><blockquote>  <em>Aufgabe 2: Können Sie die gesamte Oberfläche der Ebene im Vertex-Shader um mehrere Einheiten (entlang der Y-Achse) nach oben verschieben, ohne die Form zu verzerren?</em> </blockquote><br><blockquote>  <em>Aufgabe 3: Ich sagte, dass gl_Position zweidimensional ist, aber gl_Position.z existiert auch.</em>  <em>Können Sie überprüfen, ob sich dieser Wert auf etwas auswirkt, und wenn ja, wofür wird er verwendet?</em> </blockquote><br><h3>  Zeit hinzufügen </h3><br>  Das Letzte, was wir brauchen, um bewegte Wellen zu erzeugen, ist eine einheitliche Variable, die als Zeit verwendet werden kann.  Deklarieren Sie die Uniform im Vertex-Shader: <br><br><pre> <code class="javascript hljs">uniform float uTime;</code> </pre> <br>  <strong>Um</strong> es nun an den Shader zu übergeben, <strong>kehren wir</strong> zu <strong>Water.js zurück</strong> und definieren die Zeitvariable in initialize: <br><br><pre> <code class="javascript hljs">Water.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/////     this.GeneratePlaneMesh(); //    this.savedVS = this.vs.resource; this.savedFS = this.fs.resource; };</span></span></code> </pre> <br>  Um die Variable auf den Shader zu übertragen, verwenden wir jetzt <code>material.setParameter</code> .  Zuerst setzen wir den Anfangswert am Ende der <code>CreateWaterMaterial</code> Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     this.shader = new pc.Shader(gd, shaderDefinition); //////////////   material.setParameter('uTime',this.time); this.material = material; //      //////////////// //      material.setShader(this.shader); return material;</span></span></code> </pre> <br>  Jetzt können wir in der <code>update</code> einen Zeitschritt ausführen und über den dafür erstellten Link auf das Material zugreifen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time += <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.material.setParameter(<span class="hljs-string"><span class="hljs-string">'uTime'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time);</code> </pre> <br>  Schließlich kopieren wir in der Swap-Funktion den alten Zeitwert so, dass er auch nach dem Ändern des Codes weiter zunimmt, ohne auf 0 zurückgesetzt zu werden. <br><br><pre> <code class="javascript hljs">Water.prototype.swap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">old</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.time = old.time; };</code> </pre> <br>  Jetzt ist alles fertig.  Führen Sie das Spiel aus, um sicherzustellen, dass keine Fehler vorliegen.  Bewegen wir nun unser Flugzeug mit der Zeitfunktion in <code>Water.vert</code> : <br><br><pre> <code class="javascript hljs">pos.y += cos(uTime)</code> </pre> <br>  Und unser Flugzeug sollte sich auf und ab bewegen!  Da wir jetzt eine Swap-Funktion haben, können wir Water.js auch aktualisieren, ohne neu starten zu müssen.  Versuchen Sie, das Zeitinkrement zu ändern, um sicherzustellen, dass dies funktioniert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/9fe/64a/ae99fe64ab5d40e47e3760ac1dae1dd7.gif"></div><br><blockquote>  <em>Aufgabe 4: Können Sie die Eckpunkte so verschieben, dass sie wie die Wellen in der folgenden Abbildung aussehen?</em> </blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1be/c55/056/1bec55056dc955769178773c2d58fe7c.gif"></div><br>  Lassen Sie mich Ihnen sagen, dass ich das Thema der verschiedenen Arten der Wellenerzeugung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> im Detail untersucht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">habe</a> .  Der Artikel bezieht sich auf 2D, aber mathematische Berechnungen sind auf unseren Fall anwendbar.  Wenn Sie nur die Lösung sehen möchten, dann ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier das Wesentliche</a> . <br><br><h2>  Transluzenz </h2><br>  Der Zweck dieses Abschnitts besteht darin, eine durchscheinende Wasseroberfläche zu schaffen. <br><br>  Möglicherweise stellen Sie fest, dass die an Water.frag zurückgegebene Farbe einen Alpha-Kanalwert von 0,5 hat, die Oberfläche jedoch weiterhin undurchsichtig bleibt.  In vielen Fällen wird Transparenz in der Computergrafik immer noch zu einem ungelösten Problem.  Eine kostengünstige Möglichkeit, dies zu lösen, ist das Mischen. <br><br>  Normalerweise überprüft es vor dem Zeichnen eines Pixels den Wert im <em>Tiefenpuffer</em> und vergleicht ihn mit seinem eigenen Tiefenwert (seiner Position entlang der Z-Achse), um festzustellen, ob das aktuelle Bildschirmpixel neu gezeichnet werden soll oder nicht.  Auf diese Weise können Sie die Szene korrekt rendern, ohne Objekte von hinten nach vorne sortieren zu müssen. <br><br>  Beim Mischen können wir, anstatt das Pixel einfach abzulehnen oder zu überschreiben, die Farbe des bereits gerenderten Pixels (Ziels) mit dem Pixel kombinieren, das wir zeichnen möchten (die Quelle).  Eine Liste aller in WebGL verfügbaren Mischfunktionen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> . <br><br>  Damit der Alpha-Kanal unseren Erwartungen entspricht, möchten wir, dass die kombinierte Farbe des Ergebnisses eine Quelle multipliziert mit einem Alpha-Kanal plus einem Zielpixel multipliziert mit einem minus Alpha ist.  Mit anderen Worten, wenn Alpha = 0,4 ist, sollte die endgültige Farbe einen Wert haben: <br><br><pre> <code class="javascript hljs">finalColor = source * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + destination * <span class="hljs-number"><span class="hljs-number">0.6</span></span>;</code> </pre> <br>  In PlayCanvas ist dies die Operation, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">pc.BLEND_NORMAL ausführt</a> . <br><br>  Um es zu aktivieren, legen Sie einfach die Materialeigenschaft in <code>CreateWaterMaterial</code> : <br><br><pre> <code class="javascript hljs">material.blendType = pc.BLEND_NORMAL;</code> </pre> <br>  Wenn Sie jetzt das Spiel starten, wird das Wasser durchscheinend!  Es ist jedoch immer noch unvollkommen.  Das Problem tritt auf, wenn die durchscheinende Oberfläche sich selbst überlagert, wie unten gezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/6b0/653/6df6b0653c6a86a4cd5d8b0500e22f04.png"></div><br>  Wir können es beseitigen, indem wir <em>Alpha to Coverage verwenden</em> , eine Multisampling-Technik für Transparenz, anstatt zu mischen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//material.blendType = pc.BLEND_NORMAL; material.alphaToCoverage = true;</span></span></code> </pre> <br>  Es ist jedoch nur in WebGL 2 verfügbar. Im weiteren Verlauf des Tutorials werde ich der Einfachheit halber das Mischen verwenden. <br><br><h2>  Zusammenfassend </h2><br>  Wir haben die Umgebung eingerichtet und eine durchscheinende Wasseroberfläche mit animierten Wellen vom Vertex-Shader erstellt.  Im zweiten Teil des Tutorials werden wir den Auftrieb von Objekten betrachten, Linien zur Wasseroberfläche hinzufügen und Schaumlinien entlang der Grenzen von Objekten erstellen, die sich mit der Oberfläche schneiden. <br><br>  Im dritten (letzten) Teil werden wir die Anwendung des Nachbearbeitungseffekts von Unterwasserverzerrungen betrachten und Ideen für weitere Verbesserungen prüfen. <br><br><h2>  Quellcode </h2><br>  Das fertige PlayCanvas-Projekt finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">hier</a> .  Unser Repository hat auch einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external">Projektport unter Three.js</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416953/">https://habr.com/ru/post/de416953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416943/index.html">Nützliche Materialien zum Entwerfen von Sprachschnittstellen</a></li>
<li><a href="../de416945/index.html">Wie wir BelAZ gemacht haben. Teil 1 - Eisen</a></li>
<li><a href="../de416947/index.html">Spielen Sie das Spiel vor den Olympischen Spielen: eSports wird offiziell</a></li>
<li><a href="../de416949/index.html">Das umfassende Upgrade von Herrn Steven zur Installation eines vierfach größeren Jagdnetzwerks wurde abgeschlossen</a></li>
<li><a href="../de416951/index.html">Kubernetes-Cluster im VPC-Dienst</a></li>
<li><a href="../de416955/index.html">Kleine Tricks mit Elasticsearch</a></li>
<li><a href="../de416957/index.html">Welche Lasermaschine kaufen? Zuverlässiger Raylogic 11G Lasermaschinen-Test</a></li>
<li><a href="../de416959/index.html">Apple führt neue iOS-Diebstahlschutzfunktion ein</a></li>
<li><a href="../de416961/index.html">Automatische Konfliktlösung mithilfe operativer Transformationen</a></li>
<li><a href="../de416963/index.html">Wie wir BelAZ gemacht haben. Teil 2 - Labortests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>