<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèº‚Äçü§ù‚Äçüßëüèº üç• üçú Ber√ßos de seguran√ßa: CSRF üë®üèæ ‚ô†Ô∏è üë©üèæ‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apesar do fato de que na √∫ltima lista publicada de vulnerabilidades dos ataques do CSRF entre os 10 principais da OWASP em 2017 s√£o classificados como...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ber√ßos de seguran√ßa: CSRF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/476880/"><img src="https://habrastorage.org/webt/n2/kv/kj/n2kvkjqgxl8zvlq8y_sqcreecka.jpeg" alt="imagem"><br><br>  Apesar do fato de que na √∫ltima lista publicada de vulnerabilidades dos ataques do CSRF entre os 10 principais da OWASP em 2017 s√£o classificados como ‚ÄúExclu√≠dos, mas n√£o esquecidos‚Äù, decidimos que n√£o seria sup√©rfluo lembrar novamente como se defender contra ataques de CSRF, contando com esses as mesmas regras fornecidas pela OWASP. <br><a name="habracut"></a><br>  <u><b>Usando token CSRF</b></u> <br><br>  O uso de um token (m√©todos sem estado e sem estado) √© o m√©todo de prote√ß√£o principal e mais popular.  O token deve ser exclusivo para cada sess√£o do usu√°rio, gerado por um gerador de n√∫meros pseudo-aleat√≥rios criptograficamente robustos.  A OWASP tamb√©m recomenda o uso dos algoritmos AES256-GCM e SHA256 / 512 para criptografia ao usar o HMAC. <br><br>  Existem v√°rias abordagens para trabalhar com tokens: Token de Sincronizador, Padr√£o de Token Baseado em Criptografia, Token Baseado em HMAC <br><br>  <b>Token de sincronizador</b> <br><br>  Usando a abordagem do token de sincroniza√ß√£o (m√©todo statefull), significa enviar um token a cada solicita√ß√£o, o que implica algumas altera√ß√µes no lado do servidor.  Se o token n√£o for v√°lido, o servidor rejeitar√° a solicita√ß√£o. <br>  Ao enviar uma solicita√ß√£o ao servidor, √© recomend√°vel adicionar um token aos par√¢metros da solicita√ß√£o, e n√£o ao cabe√ßalho.  No entanto, se voc√™ inserir um token no cabe√ßalho da solicita√ß√£o, verifique se ele n√£o est√° conectado ao servidor.  O token recebido pode ser armazenado <i>no lado do cliente em um campo oculto:</i> <br><br><pre><code class="java hljs">&lt;form action=<span class="hljs-string"><span class="hljs-string">"/post.php"</span></span> method=<span class="hljs-string"><span class="hljs-string">"post"</span></span>&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"hidden"</span></span> name=<span class="hljs-string"><span class="hljs-string">"CSRFToken"</span></span> value=<span class="hljs-string"><span class="hljs-string">"l5824xNMAYFesBxing975yR8HPJlHZ"</span></span>&gt; ... &lt;/form&gt;</code> </pre> <br><br>  <i>nos cabe√ßalhos:</i> <br><br><pre> <code class="java hljs">POST /page HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Accept: application/json, application/xml, text/json, text/x-json, text/javascript, text/xml User-Agent: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (Windows NT <span class="hljs-number"><span class="hljs-number">10.0</span></span>; Win64; x64) AppleWebKit/<span class="hljs-number"><span class="hljs-number">537.36</span></span> (KHTML, like Gecko) Chrome/<span class="hljs-number"><span class="hljs-number">74.0</span></span>.3729.169 Safari/<span class="hljs-number"><span class="hljs-number">537.36</span></span> Content-Type: application/json Host: example.com X-CSRF-TOKEN: l5824xNMAYFesBxing975yR8HPJlHZ</code> </pre> <br><br>  <i>ou em cookies</i> <br><br><pre> <code class="java hljs">POST /page HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com Set-Cookie: CSRFToken=l5824xNMAYFesBxing975yR8HPJlHZ; Content-Type: application/x-www-form-urlencoded</code> </pre> <br><br>  A OWASP recomenda armazenar o token nos cabe√ßalhos, explicando que, mesmo que o token seja aberto ou expirado, o invasor ainda n√£o poder√° falsificar a solicita√ß√£o, devido aos navegadores. <br><br>  Al√©m disso, para aumentar o n√≠vel de seguran√ßa do m√©todo proposto, √© proposto gerar um nome de par√¢metro de token aleat√≥rio e / ou o pr√≥prio token para cada solicita√ß√£o.  Com essa abordagem, o tempo durante o qual o invasor pode usar o token roubado √© m√≠nimo.  No entanto, isso pode levar a problemas de usabilidade.  Por exemplo, clicar no bot√£o "Voltar" pode levar ao envio de um token inv√°lido para o servidor, que estava contido na p√°gina anterior. <br><br>  O envio de um token usando uma solicita√ß√£o GET n√£o √© recomendado, pois com essa abordagem o token pode ser revelado: no hist√≥rico do navegador, arquivos de log, cabe√ßalhos do referenciador. <br><br>  <b>Token baseado em criptografia</b> <br><br>  Essa abordagem √© sem estado, porque usa criptografia / descriptografia para validar o token e, portanto, n√£o requer armazenamento do token no lado do servidor. <br><br>  O servidor gera um token que consiste em um identificador de sess√£o e um carimbo de data / hora (para evitar um ataque de reprodu√ß√£o).  Para criptografia, √© recomend√°vel usar o algoritmo de criptografia AES256 no modo de criptografia de bloco GSM / GSM-SIV.  O uso do modo BCE √© altamente desencorajado.  O token criptografado pelo servidor √© retornado ao cliente da mesma maneira que no caso de ‚ÄúToken de sincronizador‚Äù no campo de formul√°rio oculto ou no cabe√ßalho / par√¢metro de resposta.  Ap√≥s o recebimento do token, o servidor deve descriptograf√°-lo, verificar o identificador da sess√£o e tamb√©m verificar o registro de data e hora com o hor√°rio atual e garantir que ele n√£o exceda a vida √∫til do token definido. <br>  Se a verifica√ß√£o do identificador da sess√£o for bem-sucedida, mas o mapa de tempo n√£o for, a solicita√ß√£o poder√° ser considerada v√°lida.  Em todos os outros casos, √© recomend√°vel rejeitar a solicita√ß√£o e registr√°-la para entender melhor como responder a essas solicita√ß√µes. <br><br>  <b>Token baseado em HMAC</b> <b><br></b> <br>  Ele tamb√©m n√£o requer armazenamento de token, o princ√≠pio de opera√ß√£o √© semelhante ao Token baseado em criptografia, exceto que, em vez de criptografar o token, a fun√ß√£o HMAC (c√≥digo de autentica√ß√£o de mensagem baseada em hash) √© usada para gerar o token (√© recomend√°vel usar o SHA256 ou um algoritmo mais forte).  Nesse caso, o token √© o resultado da fun√ß√£o HMAC do identificador de sess√£o do usu√°rio + registro de data e hora. <br><br>  <b>Automa√ß√£o de token</b> <br><br>  O principal problema para combater os ataques CSRF √© que os desenvolvedores simplesmente esquecem de adicionar funcionalidades para trabalhar com tokens.  Para evitar esses problemas, vale a pena automatizar este processo: <br><br>  ‚Ä¢ escreva um wrapper que adicione automaticamente um token √†s solicita√ß√µes por meio da tag de formul√°rio ou ao usar o ajax.  Por exemplo, o Spring Security adota uma abordagem semelhante sempre que a tag &lt;form: form&gt; √© usada. <br><br>  ‚Ä¢ escreva um gancho que intercepte o tr√°fego e adicione tokens a todos os recursos vulner√°veis.  Como √© bastante dif√≠cil analisar qual solicita√ß√£o a altera√ß√£o de estado est√° executando, exigindo um token, √© recomend√°vel incluir tokens em todas as respostas POST, mas vale a pena considerar o custo do desempenho <br><br>  ‚Ä¢ adicionar automaticamente um token ao renderizar uma p√°gina.  Essa abordagem √© usada pelo CSRF Guard: tokens s√£o adicionados a todos os atributos href e src, campos ocultos e de todas as formas <br><br>  Antes de tentar escrever seu pr√≥prio sistema de gera√ß√£o autom√°tica de token, √© recomend√°vel esclarecer se a estrutura que voc√™ usa tem a capacidade de fornecer prote√ß√£o contra ataques CSRF por padr√£o.  Por exemplo, a mesma estrutura do Django implementa prote√ß√£o contra o CSRF. <br><br><br>  <b>Login CSRF</b> <br><br>  Usando o CSRF no formul√°rio de login, um invasor pode efetuar login, <br>  disfar√ßado de v√≠tima.  Tais vulnerabilidades foram enfrentadas por gigantes como PayPal e Google. <br>  Voc√™ pode lidar com o CSRF no formul√°rio de login, criando pr√©-sess√µes criadas antes da autentica√ß√£o do usu√°rio e incluindo tokens no formul√°rio de login. <br><br><br>  <b>Cookie samesite</b> <br><br>  O SameSite Cookie √© um atributo descrito no RFC6265bis cujo objetivo √© combater os ataques CSRF.  Funciona da seguinte maneira.  Um dos m√©todos de prote√ß√£o √© verificar a origem e os cabe√ßalhos do referenciador, pelos quais voc√™ pode entender de onde veio a solicita√ß√£o, mas essa abordagem requer a implementa√ß√£o de um mecanismo de verifica√ß√£o.  Usando o atributo SameSite, restringimos o envio de cookies com uma solicita√ß√£o de recursos externos.  Este atributo possui v√°rios valores poss√≠veis: Estrito, Relaxado e Nenhum. <br>  Usar o valor estrito significa que o navegador n√£o enviar√° cookies de nenhuma fonte que n√£o corresponda ao nome de dom√≠nio do recurso atual. <br>  O valor negligente torna poss√≠vel n√£o bloquear cookies de recursos externos, cuja transi√ß√£o foi realizada de maneira segura - usando o protocolo HTTPS.  Lax encontra um equil√≠brio entre usabilidade e seguran√ßa. <br><br>  Definir um atributo √© bastante simples: <br><br><pre> <code class="java hljs">Set-Cookie: JSESSIONID=xxxxx; SameSite=Strict Set-Cookie: JSESSIONID=xxxxx; SameSite=Lax</code> </pre> <br><br>  No momento da reda√ß√£o deste artigo, o suporte ao atributo pelos navegadores se parece com o seguinte: <br><br><img src="https://habrastorage.org/webt/yv/ku/ck/yvkuckcnwzycekgofxa9t0kuoy4.png" alt="imagem"><br><br><br>  √â importante lembrar que esse atributo deve ser usado como uma medida adicional de prote√ß√£o, e n√£o como uma maneira de fazer sem usar o token CSRF. <br><br>  <i>Verificando cabe√ßalhos</i> <br><br>  Como mencionado acima, um dos m√©todos de prote√ß√£o √© verificar o referenciador e os valores de origem do cabe√ßalho da solicita√ß√£o. <br>  A ess√™ncia dessa verifica√ß√£o √© verificar os valores dos cabe√ßalhos no lado do servidor.  Se eles corresponderem ao recurso, a solicita√ß√£o ser√° considerada correta, caso contr√°rio, ser√° rejeitada.  Se o cabe√ßalho Origem estiver ausente, voc√™ precisar√° garantir que o valor do Referenciador corresponda ao recurso atual.  A OWASP recomenda rejeitar solicita√ß√µes que n√£o contenham cabe√ßalhos Origin ou Referrer.  Voc√™ tamb√©m pode registrar todas essas solicita√ß√µes para analis√°-las posteriormente e decidir como lidar com elas. <br><br>  No entanto, as coisas ficam complicadas se o seu aplicativo estiver protegido por um servidor proxy, pois o URL no cabe√ßalho ser√° diferente.  Nesse caso, existem v√°rias op√ß√µes: <br>  ‚Ä¢ Configure seu aplicativo para que voc√™ sempre saiba a origem da solicita√ß√£o.  O problema dessa abordagem √© definir o valor certo se seu aplicativo for implantado em v√°rios ambientes (por exemplo, dev, QA, produ√ß√£o), o que leva a um problema de suporte <br>  ‚Ä¢ use o cabe√ßalho Host.  Este cabe√ßalho permitir√° que voc√™ determine a origem da solicita√ß√£o, independentemente do ambiente. <br>  ‚Ä¢ use o cabe√ßalho X-Forwarded-Host, cujo objetivo √© armazenar os cabe√ßalhos originais recebidos pelo servidor proxy <br><br>  Todos os m√©todos descritos funcionam apenas quando os cabe√ßalhos de origem e de refer√™ncia est√£o presentes.  Mas h√° casos em que esses cabe√ßalhos est√£o ausentes.  Aqui est√£o alguns casos em que esses cabe√ßalhos n√£o est√£o inclu√≠dos na solicita√ß√£o: <br>  ‚Ä¢ O IE 11 n√£o inclui o cabe√ßalho Origin para sites confi√°veis.  Resta confiar apenas no cabe√ßalho do Referer. <br>  ‚Ä¢ no caso de um redirecionamento, o Origin n√£o est√° inclu√≠do na solicita√ß√£o, pois acredita-se que possa conter informa√ß√µes confidenciais que n√£o devem ser enviadas para outra fonte <br>  ‚Ä¢ O cabe√ßalho de origem est√° ativado para todas as solicita√ß√µes entre sites, mas a maioria dos navegadores o adiciona apenas para solicita√ß√µes POST / DELETE / PUT <br><br>  Como regra, uma pequena quantidade de tr√°fego cai nas categorias descritas, mas geralmente voc√™ n√£o deseja perder nem mesmo essa pequena parte de usu√°rios, portanto, √© considerado v√°lido solicitar com um valor nulo para origem / referenciador ou com um valor correspondente √† lista de dom√≠nios confi√°veis. <br><br>  <b>Cookie de envio duplo</b> <b><br></b> <br>  Essa abordagem √© bastante simples de implementar e n√£o requer armazenamento do token no lado do servidor (sem estado).  A ess√™ncia do m√©todo √© enviar o token no par√¢metro request e nos cookies pelo usu√°rio.  Cada solicita√ß√£o que exige uma altera√ß√£o de estado, verificamos o valor do token nos cookies e na solicita√ß√£o.  Se a verifica√ß√£o do identificador da sess√£o for bem-sucedida, mas o mapa de tempo n√£o for, a solicita√ß√£o poder√° ser considerada v√°lida <br><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476880/">https://habr.com/ru/post/pt476880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476870/index.html">Matem√°ticos come√ßam a domar o "problema do girassol"</a></li>
<li><a href="../pt476872/index.html">Testes e economia de projetos</a></li>
<li><a href="../pt476874/index.html">‚ÄúHoje, o ICS n√£o protege o gap a√©reo nem os protocolos propriet√°rios‚Äù - entrevista com Vladimir Karantaev</a></li>
<li><a href="../pt476876/index.html">Testando a id√©ia de um futuro aplicativo. Pretype. Ou como economizar muito dinheiro</a></li>
<li><a href="../pt476878/index.html">GP LED Bulbs</a></li>
<li><a href="../pt476888/index.html">Quais tend√™ncias de design de UX seguir√£o em 2020</a></li>
<li><a href="../pt476890/index.html">Para quem trabalha na Houdini. Sobre os cursos Nature of Vex e Bites of Python</a></li>
<li><a href="../pt476900/index.html">Dispositivo aut√¥nomo no arduino, sinalizando um aumento (diminui√ß√£o) de temperatura</a></li>
<li><a href="../pt476902/index.html">Barrymore, o que h√° em torno do Voximplant? Soquetes da Web implementados, senhor</a></li>
<li><a href="../pt476904/index.html">Outra biblioteca simulada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>