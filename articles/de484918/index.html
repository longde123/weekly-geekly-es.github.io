<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçâ üñêüèø üë©üèª‚Äçü§ù‚Äçüë®üèø Inkrementelle Annotation zur Beschleunigung von Gradle-Builds üôÖüèæ ü•á üõÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ab den Versionen 4.7 und 1.3.30 von Kotlin war es aufgrund der korrekten inkrementellen Verarbeitung von Anmerkungen m√∂glich, die inkrementelle Montag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inkrementelle Annotation zur Beschleunigung von Gradle-Builds</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="Bild"></p><br><p>  Ab den Versionen 4.7 und 1.3.30 von Kotlin war es aufgrund der korrekten inkrementellen Verarbeitung von Anmerkungen m√∂glich, die inkrementelle Montage von Projekten zu beschleunigen.  In diesem Artikel erfahren Sie, wie die Theorie der inkrementellen Kompilierung in Gradle theoretisch funktioniert, was getan werden muss, um das volle Potenzial freizusetzen (ohne gleichzeitig die Codegenerierung zu verlieren) und welche Geschwindigkeitssteigerung in inkrementellen Assemblys durch die Aktivierung der inkrementellen Verarbeitung von Annotationen in der Praxis erzielt werden kann. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  So funktioniert die inkrementelle Kompilierung </h2><br><p>  Inkrementelle Builds in Gradle werden auf zwei Ebenen implementiert.  Die erste Ebene besteht darin, den Start des Neukompilierens von Modulen mit Hilfe der <a href="https://docs.gradle.org/current/userguide/java_plugin.html">Kompilierumgehung</a> abzubrechen.  Die zweite ist die direkte inkrementelle Kompilierung, bei der der Compiler im Rahmen eines Moduls nur f√ºr die Dateien gestartet wird, die ge√§ndert wurden oder direkt von den ge√§nderten Dateien abh√§ngig sind. </p><br><p>  Betrachten wir die Vermeidung von Kompilierungen an einem Beispiel (aus einem <a href="https://blog.gradle.org/incremental-compiler-avoidance">Artikel</a> von Gradle) f√ºr ein Projekt mit drei Modulen: <strong>App</strong> , <strong>Core</strong> und <strong>Utils</strong> . </p><br><p>  Die Hauptklasse des <strong>App-</strong> Moduls (abh√§ngig vom <strong>Kern</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  Im Kernmodul (abh√§ngig von <strong>Utils</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  Im <strong>utils-</strong> Modul: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Die Reihenfolge der ersten Kompilierung der Module ist wie folgt (gem√§√ü der Reihenfolge der Abh√§ngigkeiten): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>Kern</strong> <br>  3) <strong>App</strong> </p><br><p>  √úberlegen Sie nun, was passiert, wenn Sie die interne Implementierung der IOUtils-Klasse √§ndern: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Diese √Ñnderung wirkt sich nicht auf das ABI-Modul aus.  ABI (Application Binary Interface) ist eine bin√§re Darstellung der √∂ffentlichen Schnittstelle des zusammengesetzten Moduls.  In dem Fall, dass sich die √Ñnderung nur auf die interne Implementierung des Moduls bezieht und die √∂ffentliche Schnittstelle in keiner Weise beeinflusst, verwendet Gradle die Kompilierungsumgehung und startet die Neukompilierung nur des <strong>utils-</strong> Moduls.  Wenn die ABI des Moduls <strong>utils</strong> betroffen ist (z. B. eine zus√§tzliche √∂ffentliche Methode angezeigt wird oder die Signatur der vorhandenen ge√§ndert wird), wird zus√§tzlich die Kompilierung des Kernmoduls gestartet, das <strong>kernabh√§ngige</strong> <strong>App-</strong> Modul wird jedoch nicht transitiv neu kompiliert, wenn die Abh√§ngigkeit in ihm durch <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">Implementierung verbunden ist</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Darstellung der Kompilierungsvermeidung auf Projektmodulebene</em> </p><br><p>  Die zweite Inkrementstufe ist die Inkrementstufe auf Compiler-Startebene f√ºr ge√§nderte Dateien direkt in einzelnen Modulen. </p><br><p>  F√ºgen Sie dem Kernmodul beispielsweise eine neue Klasse hinzu: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  Und in <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  In diesem Fall m√ºssen in beiden Modulen nur zwei neue Dateien neu kompiliert werden (ohne die vorhandenen und nicht ge√§nderten WordCount- und IOUtils-Dateien zu beeinflussen), da keine Abh√§ngigkeiten zwischen der neuen und der alten Klasse bestehen. </p><br><p>  Der inkrementelle Compiler analysiert daher nur Abh√§ngigkeiten zwischen Klassen und kompiliert neu: </p><br><ul><li>  Klassen mit √Ñnderungen </li><li><p>  Klassen, die direkt von den wechselnden Klassen abh√§ngen </p><br><h2 id="inkrementalnyy-annotation-processing">  Inkrementelle Anmerkungsverarbeitung </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="Bildbeschreibung hier eingeben"></p><br></li></ul><br><p>  Durch das Generieren von Code mit APT und KAPT wird der Zeitaufwand f√ºr das Schreiben und Debuggen von Boilerplate-Code verringert, die Verarbeitung von Anmerkungen kann jedoch die Erstellungszeit erheblich verl√§ngern.  Um die Sache noch schlimmer zu machen, hat die Verarbeitung von Anmerkungen die M√∂glichkeiten der inkrementellen Kompilierung in Gradle f√ºr lange Zeit grundlegend zerst√∂rt. </p><br><p>  Jeder Anmerkungsprozessor in einem Projekt informiert den Compiler √ºber die Liste der von ihm verarbeiteten Anmerkungen.  Aus Assembler-Sicht ist die Annotation-Verarbeitung jedoch eine Black Box: Gradle wei√ü nicht, was der Prozessor tun wird, insbesondere welche Dateien er an welcher Stelle erstellen wird.  Bis zu Gradle 4.7 wurde die inkrementelle Kompilierung in den Quellens√§tzen, in denen Anmerkungsprozessoren verwendet wurden, automatisch deaktiviert. </p><br><p>  Mit der <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">Ver√∂ffentlichung von</a> Gradle 4.7 unterst√ºtzt die inkrementelle Kompilierung jetzt die Verarbeitung von Anmerkungen, jedoch nur f√ºr APT.  In KAPT wurde mit Kotlin 1.3.30 die Unterst√ºtzung f√ºr inkrementelle Annotationen <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">eingef√ºhrt</a> .  Es erfordert auch die <a href="https://docs.gradle.org/current/userguide/java_plugin.html">Unterst√ºtzung</a> von Bibliotheken, die Anmerkungsprozessoren bereitstellen.  Entwickler von Anmerkungsprozessoren haben die M√∂glichkeit, die Prozessorkategorie explizit festzulegen, um Gradle √ºber die Informationen zu informieren, die f√ºr die Funktion der inkrementellen Kompilierung erforderlich sind. </p><br><h2 id="kategorii-processorov-annotaciy">  Anmerkungsprozessorkategorien </h2><br><p>  Gradle unterst√ºtzt zwei Kategorien von Prozessoren: </p><br><p>  <strong>Isolieren</strong> - <strong>Diese</strong> Prozessoren m√ºssen alle Entscheidungen f√ºr die Codegenerierung nur auf der Grundlage der Informationen von <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> treffen, die einem Element einer bestimmten Annotation zugeordnet sind.  Dies ist die schnellste Kategorie von Annotation-Prozessoren, da Gradle den Prozessor m√∂glicherweise nicht neu startet und die zuvor generierten Dateien verwendet, wenn die Quelldatei nicht ge√§ndert wurde. </p><br><p>  <strong>Aggregieren</strong> - Wird f√ºr Prozessoren verwendet, die Entscheidungen auf der Grundlage mehrerer Eingaben treffen (z. B. Analyse von Anmerkungen in mehreren Dateien auf einmal oder auf der Grundlage der Untersuchung von AST, die von einem mit Anmerkungen versehenen Element aus transitiv erreichbar ist).  Jedes Mal startet Gradle den Prozessor f√ºr Dateien, die Anmerkungen des Aggregationsprozessors verwenden, kompiliert die generierten Dateien jedoch nicht neu, wenn keine √Ñnderungen daran vorgenommen wurden. </p><br><p>  Bei vielen g√§ngigen Bibliotheken, die auf der Codegenerierung basieren, ist die Unterst√ºtzung der inkrementellen Kompilierung bereits in den neuesten Versionen implementiert.  Eine Liste der Bibliotheken, die dies unterst√ºtzen, finden Sie <a href="https://docs.gradle.org/current/userguide/java_plugin.html">hier</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Unsere Erfahrung mit der Implementierung inkrementeller Anmerkungsverarbeitung </h2><br><p>  Bei Projekten, die von vorne beginnen und die neuesten Versionen von Bibliotheken und Gradle-Plug-ins verwenden, sind inkrementelle Builds wahrscheinlich standardm√§√üig aktiviert.  Der gr√∂√üte Teil der Steigerung der Montageproduktivit√§t kann jedoch durch die inkrementelle Verarbeitung von Anmerkungen bei gro√üen und langlebigen Projekten erzielt werden.  In diesem Fall ist m√∂glicherweise ein umfangreiches Versionsupdate erforderlich.  Lohnt es sich in der Praxis?  Mal sehen </p><br><p>  Damit die inkrementelle Verarbeitung von Anmerkungen funktioniert, ben√∂tigen wir: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Alle Anmerkungsprozessoren in unserem Projekt m√ºssen ihre Unterst√ºtzung haben.  Dies ist sehr wichtig, da Gradle diese Funktion f√ºr das gesamte Modul deaktiviert, wenn in einem einzelnen Modul mindestens ein Prozessor keine Inkrementalit√§t unterst√ºtzt.  Alle Dateien im Modul werden jedes Mal neu kompiliert!  Eine der alternativen Optionen, um Unterst√ºtzung f√ºr die inkrementelle Kompilierung zu erhalten, ohne die Versionen zu aktualisieren, besteht darin, den gesamten Code mithilfe von Annotation-Prozessoren in einem separaten Modul zu entfernen.  In Modulen ohne Anmerkungsprozessor funktioniert die inkrementelle Kompilierung problemlos </li></ul><br><p>  Um Prozessoren zu erkennen, die die letzte Bedingung nicht erf√ºllen, k√∂nnen Sie die Assembly mit dem Flag <em>-Pkapt.verbose = true ausf√ºhren</em> .  Wenn Gradle gezwungen war, die inkrementelle Anmerkungsverarbeitung f√ºr ein einzelnes Modul zu deaktivieren, wird im Erstellungsprotokoll eine Meldung angezeigt, welche Prozessoren und in welchen Modulen dies geschieht (siehe den Namen der Aufgabe): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  In unserem Bibliotheksprojekt mit nicht inkrementellen Annotationsprozessoren gab es 3: </p><br><ul><li>  Zahnstocher </li><li>  Zimmer </li><li>  PermissionsDispatcher </li></ul><br><p>  Gl√ºcklicherweise werden diese Bibliotheken aktiv unterst√ºtzt und ihre neuesten Versionen unterst√ºtzen bereits Inkrementalit√§t.  Dar√ºber hinaus haben alle Annotation-Prozessoren in den neuesten Versionen dieser Bibliotheken eine optimale Kategorietrennung.  Beim Anheben der Versionen musste ich mich wegen √Ñnderungen an der Toothpick-Bibliotheks-API, die fast jedes unserer Module betrafen, mit dem Refactoring befassen.  In diesem Fall hatten wir jedoch Gl√ºck und es stellte sich heraus, dass das Refactoring mithilfe der Namen der verwendeten √∂ffentlichen Bibliotheksmethoden, die automatisch ersetzt wurden, vollst√§ndig automatisch erfolgte. </p><br><p>  Beachten Sie, dass Sie bei Verwendung der <em>Raumbibliothek das</em> Flag <em>room.incremental: true</em> explizit an den Anmerkungsprozessor √ºbergeben m√ºssen.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Ein Beispiel</a> .  In Zukunft <a href="https://developer.android.com/jetpack/androidx/releases/room">planen</a> Raumentwickler, dieses Flag standardm√§√üig zu aktivieren. </p><br><p>  F√ºr Versionen von Kotlin 1.3.30-1.3.50 m√ºssen Sie die Unterst√ºtzung f√ºr die inkrementelle Verarbeitung von Anmerkungen <strong>explizit</strong> √ºber <em>kapt.incremental.apt = true</em> in der Datei gradle.properties des Projekts aktivieren.  Ab Version 1.3.50 ist diese Option standardm√§√üig auf true gesetzt. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Inkrementelle Montageprofilierung </h2><br><p>  Nachdem die Versionen aller erforderlichen Abh√§ngigkeiten erstellt wurden, ist es an der Zeit, die Geschwindigkeit inkrementeller Builds zu testen.  Dazu haben wir die folgenden Tools und Techniken verwendet: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Gradle Build Scan</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">Gradle-Profiler</a> </li><li>  Zum Ausf√ºhren von Skripten mit aktivierter und deaktivierter inkrementeller Anmerkungsverarbeitung wurde die gradle-Eigenschaft <em>kapt.incremental.apt = [true | false] verwendet</em> </li><li>  F√ºr konsistente und informative Ergebnisse wurden Assemblys in einer separaten CI-Umgebung erstellt.  Die Build-Inkrementalit√§t wurde mit Gradle-Profiler reproduziert </li></ul><br><p>  Gradle-Profiler erm√∂glicht die deklarative Vorbereitung von <a href="https://github.com/gradle/gradle-profiler">Skripten</a> f√ºr inkrementelle Build-Benchmarks.  Es wurden 4 Szenarien unter folgenden Bedingungen erstellt: </p><br><ul><li>  Das √Ñndern einer Datei wirkt sich nicht auf deren ABI aus </li><li>  Unterst√ºtzung f√ºr inkrementelle Anmerkungsverarbeitung ein / aus </li></ul><br><p>  Der Ablauf jedes der Szenarien ist eine Folge von: </p><br><ul><li>  Gradle-Daemon neu starten </li><li>  Starten Sie Warm-Up-Builds </li><li>  F√ºhren Sie 10 inkrementelle Assemblys aus, bevor eine Datei durch Hinzuf√ºgen einer neuen Methode ge√§ndert wird (privat f√ºr Nicht-ABI-√Ñnderungen und √∂ffentlich f√ºr ABI-√Ñnderungen). </li></ul><br><p>  Alle Builds wurden mit Gradle 5.4.1 erstellt.  Die Datei, die an den √Ñnderungen beteiligt ist, verweist auf eines der Kernmodule des Projekts (allgemein), von dem 40 Module (einschlie√ülich Kern und Feature) direkt abh√§ngig sind.  Diese Datei verwendet die Annotation zum Isolieren des Prozessors. </p><br><p>  Es ist auch erw√§hnenswert, dass der Benchmark-Lauf mit zwei Gradle-Tasks durchgef√ºhrt wurde: <em>ompileDebugSources</em> und <em>assembleDebug</em> .  Mit der ersten Option wird nur die Kompilierung von Dateien mit Quellcode gestartet, ohne dass mit Ressourcen gearbeitet und die Anwendung in einer APK-Datei geb√ºndelt wird.  Aufgrund der Tatsache, dass die inkrementelle Kompilierung nur .kt- und .java-Dateien betrifft, wurde die <em>compileDedugSource-</em> Task f√ºr ein isolierteres und schnelleres Benchmarking ausgew√§hlt.  Unter realen Entwicklungsbedingungen verwendet Android Studio beim Neustart der Anwendung den Task <em>assembleDebug</em> , der die vollst√§ndige Generierung der Debug-Version der Anwendung umfasst. </p><br><h2 id="rezultaty-benchmarkov">  Benchmark-Ergebnisse </h2><br><p>  In allen vom Gradle-Profiler unten generierten Diagrammen zeigt die vertikale Achse die inkrementelle Erstellungszeit in Millisekunden und die horizontale Achse die Erstellungsstartnummer. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource vor dem Aktualisieren von Anmerkungsprozessoren </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="Bildbeschreibung hier eingeben"><br>  Die durchschnittliche Laufzeit f√ºr jedes Szenario betrug 38 Sekunden, bevor Anmerkungsprozessoren auf Versionen aktualisiert wurden, die Inkrementalit√§t unterst√ºtzen.  In diesem Fall deaktiviert Gradle die Unterst√ºtzung f√ºr die inkrementelle Kompilierung, sodass zwischen den Skripten kein wesentlicher Unterschied besteht. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource nach Aktualisierung der Anmerkungsprozessoren </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Szenario </th><th>  Inkrementelle ABI-√Ñnderung </th><th>  Nicht inkrementelle ABI-√Ñnderung </th><th>  Inkrementelle Non-ABI-√Ñnderung </th><th>  Nicht inkrementelle Non-Abi-√Ñnderung </th></tr></thead><tbody><tr><td>  <strong>gemein</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>Median</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>max</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193,29 </td><td>  1240,81 </td><td>  888,24 </td><td>  815,91 </td></tr></tbody></table></div><br><p>  Die mediane Verk√ºrzung der Montagezeit aufgrund der Inkrementalit√§t betrug 31% f√ºr ABI-√Ñnderungen und 32,5% f√ºr Nicht-ABI-√Ñnderungen.  Absolut ungef√§hr 10 Sekunden. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug nach Aktualisierung der Annotation-Prozessoren </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Szenario </th><th>  Inkrementelle ABI-√Ñnderung </th><th>  Nicht inkrementelle ABI-√Ñnderung </th><th>  Inkrementelle Non-ABI-√Ñnderung </th><th>  Nicht inkrementelle Non-Abi-√Ñnderung </th></tr></thead><tbody><tr><td>  <strong>gemein</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>Median</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>max</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953,28 </td><td>  1011,20 </td><td>  1015,37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Um die vollst√§ndige Debug-Version der Anwendung f√ºr unser Projekt zu erstellen, betrug die durchschnittliche Verringerung der Erstellungszeit aufgrund des Inkrements 21,5% f√ºr ABI-√Ñnderungen und 23% f√ºr Nicht-ABI-√Ñnderungen.  In absoluten Zahlen ungef√§hr die gleichen 10 Sekunden, da das Inkrement der Kompilierung des Quellcodes die Assemblierungsgeschwindigkeit der Ressourcen nicht beeinflusst. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Erstellen Sie die Scan-Anatomie in Gradle Build Scan </h2><br><p>  Um zu verstehen, wie das Inkrement w√§hrend der inkrementellen Kompilierung erzielt wurde, vergleichen wir die Scans inkrementeller und nicht inkrementeller Baugruppen. </p><br><p>  Im Falle eines deaktivierten KAPT-Inkrements ist der Hauptteil der Erstellungszeit die Kompilierung des App-Moduls, die nicht mit anderen Aufgaben parallelisiert werden kann.  Die Zeitleiste f√ºr nicht inkrementelle KAPT lautet wie folgt: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="Bildbeschreibung hier eingeben"></p><br><p>  Aufgabenausf√ºhrung: kaptDebugKotlin unseres App-Moduls dauert in diesem Fall ca. 8 Sekunden. </p><br><p>  Zeitleiste f√ºr den Fall mit aktiviertem KAPT-Inkrement: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="Bildbeschreibung hier eingeben"></p><br><p>  Jetzt wurde das App-Modul in weniger als einer Sekunde neu kompiliert.  Es lohnt sich, auf die visuelle Disproportionalit√§t der Skalen der beiden Scans im obigen Bild zu achten.  Aufgaben, die im ersten Bild k√ºrzer erscheinen, sind im zweiten nicht unbedingt l√§nger, da sie l√§nger erscheinen.  Es ist jedoch sehr auff√§llig, wie sehr sich der Anteil der Neukompilierung des App-Moduls verringert hat, wenn Sie das inkrementelle KAPT einschalten.  In unserem Fall gewinnen wir ungef√§hr 8 Sekunden auf diesem Modul und zus√§tzliche ungef√§hr 2 Sekunden auf kleineren Modulen, die parallel kompiliert werden. </p><br><p>  Gleichzeitig betr√§gt die Gesamtausf√ºhrungszeit aller * kapt-Tasks f√ºr die deaktivierte Inkrementalit√§t der Verarbeitungsanmerkungen 1 Minute und 36 Sekunden gegen√ºber 55 Sekunden, wenn sie aktiviert sind.  Das hei√üt, ohne die parallele Anordnung der Module zu ber√ºcksichtigen, ist die Verst√§rkung wesentlich gr√∂√üer. </p><br><p>  Es ist auch erw√§hnenswert, dass die obigen Benchmark-Ergebnisse in einer CI-Umgebung erstellt wurden, in der 24 parallele Threads f√ºr die Montage ausgef√ºhrt werden k√∂nnen.  In einer 8-Thread-Umgebung betr√§gt der Gewinn durch die Aktivierung der inkrementellen Anmerkungsverarbeitung in unserem Projekt etwa 20 bis 30 Sekunden. </p><br><h2 id="incremental-vs--parallel">  Inkrementelle vs (?) Parallele </h2><br><p>  Eine andere M√∂glichkeit, die Montage erheblich zu beschleunigen (sowohl inkrementell als auch sauber), besteht in der parallelen Ausf√ºhrung einzelner Aufgaben, indem das Projekt in eine gro√üe Anzahl lose gekoppelter Module aufgeteilt wird.  Auf die eine oder andere Weise bietet die Modularisierung ein viel gr√∂√üeres Potenzial f√ºr die Beschleunigung von Baugruppen als die Verwendung von inkrementellem KAPT.  Je monolithischer das Projekt ist und je mehr Code generiert wird, desto gr√∂√üer ist die inkrementelle Verarbeitung der Anmerkungen.  Es ist einfacher, den Effekt einer vollst√§ndigen Inkrementalit√§t von Assemblys zu erzielen, als eine Anwendung in Module zu unterteilen.  Trotzdem widersprechen sich beide Ans√§tze nicht und erg√§nzen sich perfekt. </p><br><h2 id="itog">  Zusammenfassung </h2><br><ul><li>  Durch die inkrementelle Verarbeitung von Anmerkungen in unserem Projekt konnten wir die Geschwindigkeit des lokalen Wiederaufbaus um 20% steigern </li><li>  Um die inkrementelle Anmerkungsverarbeitung zu aktivieren, ist es hilfreich, das vollst√§ndige Protokoll der aktuellen Assemblys zu lesen und nach Warnmeldungen mit dem Text "Inkrementelle Anmerkungsverarbeitung angefordert, die Unterst√ºtzung ist jedoch deaktiviert, da die folgenden Prozessoren nicht inkrementell sind ..." zu suchen.  Es ist erforderlich, Bibliotheksversionen auf Versionen zu aktualisieren, die die inkrementelle Verarbeitung von Anmerkungen unterst√ºtzen, und die Versionen Gradle 4.7+, Kotlin 1.3.30+ zu verwenden </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Materialien und was zum Thema zu lesen </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">Informationen zur Unterst√ºtzung der Verarbeitung inkrementeller Anmerkungen auf der Ebene des Gradle Java-Plugins</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Artikel √ºber Gradle-Profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">Weitere Informationen zu KAPT-Funktionen</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Bericht √ºber Google I / O 2019 mit aktuellen Tricks zur Build-Beschleunigung</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Ein weiterer Bericht zur Gradle-Optimierung in Google I / O 2017 enth√§lt inkrementelles Build-Material und die Vermeidung von Kompilierungen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484918/">https://habr.com/ru/post/de484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484902/index.html">Auf Gleichungen h√∂heren Grades</a></li>
<li><a href="../de484904/index.html">Ein Jahr ohne Splunk - wie ein amerikanisches Unternehmen den Markt f√ºr Maschinendatenanalyse in Russland ver√§nderte und wen es zur√ºcklie√ü</a></li>
<li><a href="../de484906/index.html">Verteiltes Team und Teamleiter auf Remote</a></li>
<li><a href="../de484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): Was tun, wenn eine Minute Ausfallzeit 100.000 US-Dollar kostet?</a></li>
<li><a href="../de484910/index.html">Paul Graham: Hasser</a></li>
<li><a href="../de484920/index.html">Wie k√∂nnen Sie verstehen, dass Sie ein Fr√§smaschinenbediener sind?</a></li>
<li><a href="../de484930/index.html">Lassen Sie uns wie Profis schnell codieren</a></li>
<li><a href="../de484932/index.html">Die doppelte Natur der Softwareanforderungen</a></li>
<li><a href="../de484934/index.html">Von der pers√∂nlichen Entwicklung zu Agile im XXXL-Ma√üstab in zwei Tagen bei TeamLead Conf</a></li>
<li><a href="../de484936/index.html">Wissen und Kompetenzen im Team: Finden, sehen, pumpen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>