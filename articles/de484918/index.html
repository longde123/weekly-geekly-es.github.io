<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍉 🖐🏿 👩🏻‍🤝‍👨🏿 Inkrementelle Annotation zur Beschleunigung von Gradle-Builds 🙅🏾 🥇 🛃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ab den Versionen 4.7 und 1.3.30 von Kotlin war es aufgrund der korrekten inkrementellen Verarbeitung von Anmerkungen möglich, die inkrementelle Montag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inkrementelle Annotation zur Beschleunigung von Gradle-Builds</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="Bild"></p><br><p>  Ab den Versionen 4.7 und 1.3.30 von Kotlin war es aufgrund der korrekten inkrementellen Verarbeitung von Anmerkungen möglich, die inkrementelle Montage von Projekten zu beschleunigen.  In diesem Artikel erfahren Sie, wie die Theorie der inkrementellen Kompilierung in Gradle theoretisch funktioniert, was getan werden muss, um das volle Potenzial freizusetzen (ohne gleichzeitig die Codegenerierung zu verlieren) und welche Geschwindigkeitssteigerung in inkrementellen Assemblys durch die Aktivierung der inkrementellen Verarbeitung von Annotationen in der Praxis erzielt werden kann. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  So funktioniert die inkrementelle Kompilierung </h2><br><p>  Inkrementelle Builds in Gradle werden auf zwei Ebenen implementiert.  Die erste Ebene besteht darin, den Start des Neukompilierens von Modulen mit Hilfe der <a href="https://docs.gradle.org/current/userguide/java_plugin.html">Kompilierumgehung</a> abzubrechen.  Die zweite ist die direkte inkrementelle Kompilierung, bei der der Compiler im Rahmen eines Moduls nur für die Dateien gestartet wird, die geändert wurden oder direkt von den geänderten Dateien abhängig sind. </p><br><p>  Betrachten wir die Vermeidung von Kompilierungen an einem Beispiel (aus einem <a href="https://blog.gradle.org/incremental-compiler-avoidance">Artikel</a> von Gradle) für ein Projekt mit drei Modulen: <strong>App</strong> , <strong>Core</strong> und <strong>Utils</strong> . </p><br><p>  Die Hauptklasse des <strong>App-</strong> Moduls (abhängig vom <strong>Kern</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  Im Kernmodul (abhängig von <strong>Utils</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  Im <strong>utils-</strong> Modul: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Die Reihenfolge der ersten Kompilierung der Module ist wie folgt (gemäß der Reihenfolge der Abhängigkeiten): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>Kern</strong> <br>  3) <strong>App</strong> </p><br><p>  Überlegen Sie nun, was passiert, wenn Sie die interne Implementierung der IOUtils-Klasse ändern: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Diese Änderung wirkt sich nicht auf das ABI-Modul aus.  ABI (Application Binary Interface) ist eine binäre Darstellung der öffentlichen Schnittstelle des zusammengesetzten Moduls.  In dem Fall, dass sich die Änderung nur auf die interne Implementierung des Moduls bezieht und die öffentliche Schnittstelle in keiner Weise beeinflusst, verwendet Gradle die Kompilierungsumgehung und startet die Neukompilierung nur des <strong>utils-</strong> Moduls.  Wenn die ABI des Moduls <strong>utils</strong> betroffen ist (z. B. eine zusätzliche öffentliche Methode angezeigt wird oder die Signatur der vorhandenen geändert wird), wird zusätzlich die Kompilierung des Kernmoduls gestartet, das <strong>kernabhängige</strong> <strong>App-</strong> Modul wird jedoch nicht transitiv neu kompiliert, wenn die Abhängigkeit in ihm durch <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">Implementierung verbunden ist</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Darstellung der Kompilierungsvermeidung auf Projektmodulebene</em> </p><br><p>  Die zweite Inkrementstufe ist die Inkrementstufe auf Compiler-Startebene für geänderte Dateien direkt in einzelnen Modulen. </p><br><p>  Fügen Sie dem Kernmodul beispielsweise eine neue Klasse hinzu: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  Und in <strong>utils</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  In diesem Fall müssen in beiden Modulen nur zwei neue Dateien neu kompiliert werden (ohne die vorhandenen und nicht geänderten WordCount- und IOUtils-Dateien zu beeinflussen), da keine Abhängigkeiten zwischen der neuen und der alten Klasse bestehen. </p><br><p>  Der inkrementelle Compiler analysiert daher nur Abhängigkeiten zwischen Klassen und kompiliert neu: </p><br><ul><li>  Klassen mit Änderungen </li><li><p>  Klassen, die direkt von den wechselnden Klassen abhängen </p><br><h2 id="inkrementalnyy-annotation-processing">  Inkrementelle Anmerkungsverarbeitung </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="Bildbeschreibung hier eingeben"></p><br></li></ul><br><p>  Durch das Generieren von Code mit APT und KAPT wird der Zeitaufwand für das Schreiben und Debuggen von Boilerplate-Code verringert, die Verarbeitung von Anmerkungen kann jedoch die Erstellungszeit erheblich verlängern.  Um die Sache noch schlimmer zu machen, hat die Verarbeitung von Anmerkungen die Möglichkeiten der inkrementellen Kompilierung in Gradle für lange Zeit grundlegend zerstört. </p><br><p>  Jeder Anmerkungsprozessor in einem Projekt informiert den Compiler über die Liste der von ihm verarbeiteten Anmerkungen.  Aus Assembler-Sicht ist die Annotation-Verarbeitung jedoch eine Black Box: Gradle weiß nicht, was der Prozessor tun wird, insbesondere welche Dateien er an welcher Stelle erstellen wird.  Bis zu Gradle 4.7 wurde die inkrementelle Kompilierung in den Quellensätzen, in denen Anmerkungsprozessoren verwendet wurden, automatisch deaktiviert. </p><br><p>  Mit der <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">Veröffentlichung von</a> Gradle 4.7 unterstützt die inkrementelle Kompilierung jetzt die Verarbeitung von Anmerkungen, jedoch nur für APT.  In KAPT wurde mit Kotlin 1.3.30 die Unterstützung für inkrementelle Annotationen <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">eingeführt</a> .  Es erfordert auch die <a href="https://docs.gradle.org/current/userguide/java_plugin.html">Unterstützung</a> von Bibliotheken, die Anmerkungsprozessoren bereitstellen.  Entwickler von Anmerkungsprozessoren haben die Möglichkeit, die Prozessorkategorie explizit festzulegen, um Gradle über die Informationen zu informieren, die für die Funktion der inkrementellen Kompilierung erforderlich sind. </p><br><h2 id="kategorii-processorov-annotaciy">  Anmerkungsprozessorkategorien </h2><br><p>  Gradle unterstützt zwei Kategorien von Prozessoren: </p><br><p>  <strong>Isolieren</strong> - <strong>Diese</strong> Prozessoren müssen alle Entscheidungen für die Codegenerierung nur auf der Grundlage der Informationen von <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> treffen, die einem Element einer bestimmten Annotation zugeordnet sind.  Dies ist die schnellste Kategorie von Annotation-Prozessoren, da Gradle den Prozessor möglicherweise nicht neu startet und die zuvor generierten Dateien verwendet, wenn die Quelldatei nicht geändert wurde. </p><br><p>  <strong>Aggregieren</strong> - Wird für Prozessoren verwendet, die Entscheidungen auf der Grundlage mehrerer Eingaben treffen (z. B. Analyse von Anmerkungen in mehreren Dateien auf einmal oder auf der Grundlage der Untersuchung von AST, die von einem mit Anmerkungen versehenen Element aus transitiv erreichbar ist).  Jedes Mal startet Gradle den Prozessor für Dateien, die Anmerkungen des Aggregationsprozessors verwenden, kompiliert die generierten Dateien jedoch nicht neu, wenn keine Änderungen daran vorgenommen wurden. </p><br><p>  Bei vielen gängigen Bibliotheken, die auf der Codegenerierung basieren, ist die Unterstützung der inkrementellen Kompilierung bereits in den neuesten Versionen implementiert.  Eine Liste der Bibliotheken, die dies unterstützen, finden Sie <a href="https://docs.gradle.org/current/userguide/java_plugin.html">hier</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Unsere Erfahrung mit der Implementierung inkrementeller Anmerkungsverarbeitung </h2><br><p>  Bei Projekten, die von vorne beginnen und die neuesten Versionen von Bibliotheken und Gradle-Plug-ins verwenden, sind inkrementelle Builds wahrscheinlich standardmäßig aktiviert.  Der größte Teil der Steigerung der Montageproduktivität kann jedoch durch die inkrementelle Verarbeitung von Anmerkungen bei großen und langlebigen Projekten erzielt werden.  In diesem Fall ist möglicherweise ein umfangreiches Versionsupdate erforderlich.  Lohnt es sich in der Praxis?  Mal sehen </p><br><p>  Damit die inkrementelle Verarbeitung von Anmerkungen funktioniert, benötigen wir: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Alle Anmerkungsprozessoren in unserem Projekt müssen ihre Unterstützung haben.  Dies ist sehr wichtig, da Gradle diese Funktion für das gesamte Modul deaktiviert, wenn in einem einzelnen Modul mindestens ein Prozessor keine Inkrementalität unterstützt.  Alle Dateien im Modul werden jedes Mal neu kompiliert!  Eine der alternativen Optionen, um Unterstützung für die inkrementelle Kompilierung zu erhalten, ohne die Versionen zu aktualisieren, besteht darin, den gesamten Code mithilfe von Annotation-Prozessoren in einem separaten Modul zu entfernen.  In Modulen ohne Anmerkungsprozessor funktioniert die inkrementelle Kompilierung problemlos </li></ul><br><p>  Um Prozessoren zu erkennen, die die letzte Bedingung nicht erfüllen, können Sie die Assembly mit dem Flag <em>-Pkapt.verbose = true ausführen</em> .  Wenn Gradle gezwungen war, die inkrementelle Anmerkungsverarbeitung für ein einzelnes Modul zu deaktivieren, wird im Erstellungsprotokoll eine Meldung angezeigt, welche Prozessoren und in welchen Modulen dies geschieht (siehe den Namen der Aufgabe): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  In unserem Bibliotheksprojekt mit nicht inkrementellen Annotationsprozessoren gab es 3: </p><br><ul><li>  Zahnstocher </li><li>  Zimmer </li><li>  PermissionsDispatcher </li></ul><br><p>  Glücklicherweise werden diese Bibliotheken aktiv unterstützt und ihre neuesten Versionen unterstützen bereits Inkrementalität.  Darüber hinaus haben alle Annotation-Prozessoren in den neuesten Versionen dieser Bibliotheken eine optimale Kategorietrennung.  Beim Anheben der Versionen musste ich mich wegen Änderungen an der Toothpick-Bibliotheks-API, die fast jedes unserer Module betrafen, mit dem Refactoring befassen.  In diesem Fall hatten wir jedoch Glück und es stellte sich heraus, dass das Refactoring mithilfe der Namen der verwendeten öffentlichen Bibliotheksmethoden, die automatisch ersetzt wurden, vollständig automatisch erfolgte. </p><br><p>  Beachten Sie, dass Sie bei Verwendung der <em>Raumbibliothek das</em> Flag <em>room.incremental: true</em> explizit an den Anmerkungsprozessor übergeben müssen.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Ein Beispiel</a> .  In Zukunft <a href="https://developer.android.com/jetpack/androidx/releases/room">planen</a> Raumentwickler, dieses Flag standardmäßig zu aktivieren. </p><br><p>  Für Versionen von Kotlin 1.3.30-1.3.50 müssen Sie die Unterstützung für die inkrementelle Verarbeitung von Anmerkungen <strong>explizit</strong> über <em>kapt.incremental.apt = true</em> in der Datei gradle.properties des Projekts aktivieren.  Ab Version 1.3.50 ist diese Option standardmäßig auf true gesetzt. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Inkrementelle Montageprofilierung </h2><br><p>  Nachdem die Versionen aller erforderlichen Abhängigkeiten erstellt wurden, ist es an der Zeit, die Geschwindigkeit inkrementeller Builds zu testen.  Dazu haben wir die folgenden Tools und Techniken verwendet: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Gradle Build Scan</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">Gradle-Profiler</a> </li><li>  Zum Ausführen von Skripten mit aktivierter und deaktivierter inkrementeller Anmerkungsverarbeitung wurde die gradle-Eigenschaft <em>kapt.incremental.apt = [true | false] verwendet</em> </li><li>  Für konsistente und informative Ergebnisse wurden Assemblys in einer separaten CI-Umgebung erstellt.  Die Build-Inkrementalität wurde mit Gradle-Profiler reproduziert </li></ul><br><p>  Gradle-Profiler ermöglicht die deklarative Vorbereitung von <a href="https://github.com/gradle/gradle-profiler">Skripten</a> für inkrementelle Build-Benchmarks.  Es wurden 4 Szenarien unter folgenden Bedingungen erstellt: </p><br><ul><li>  Das Ändern einer Datei wirkt sich nicht auf deren ABI aus </li><li>  Unterstützung für inkrementelle Anmerkungsverarbeitung ein / aus </li></ul><br><p>  Der Ablauf jedes der Szenarien ist eine Folge von: </p><br><ul><li>  Gradle-Daemon neu starten </li><li>  Starten Sie Warm-Up-Builds </li><li>  Führen Sie 10 inkrementelle Assemblys aus, bevor eine Datei durch Hinzufügen einer neuen Methode geändert wird (privat für Nicht-ABI-Änderungen und öffentlich für ABI-Änderungen). </li></ul><br><p>  Alle Builds wurden mit Gradle 5.4.1 erstellt.  Die Datei, die an den Änderungen beteiligt ist, verweist auf eines der Kernmodule des Projekts (allgemein), von dem 40 Module (einschließlich Kern und Feature) direkt abhängig sind.  Diese Datei verwendet die Annotation zum Isolieren des Prozessors. </p><br><p>  Es ist auch erwähnenswert, dass der Benchmark-Lauf mit zwei Gradle-Tasks durchgeführt wurde: <em>ompileDebugSources</em> und <em>assembleDebug</em> .  Mit der ersten Option wird nur die Kompilierung von Dateien mit Quellcode gestartet, ohne dass mit Ressourcen gearbeitet und die Anwendung in einer APK-Datei gebündelt wird.  Aufgrund der Tatsache, dass die inkrementelle Kompilierung nur .kt- und .java-Dateien betrifft, wurde die <em>compileDedugSource-</em> Task für ein isolierteres und schnelleres Benchmarking ausgewählt.  Unter realen Entwicklungsbedingungen verwendet Android Studio beim Neustart der Anwendung den Task <em>assembleDebug</em> , der die vollständige Generierung der Debug-Version der Anwendung umfasst. </p><br><h2 id="rezultaty-benchmarkov">  Benchmark-Ergebnisse </h2><br><p>  In allen vom Gradle-Profiler unten generierten Diagrammen zeigt die vertikale Achse die inkrementelle Erstellungszeit in Millisekunden und die horizontale Achse die Erstellungsstartnummer. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource vor dem Aktualisieren von Anmerkungsprozessoren </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="Bildbeschreibung hier eingeben"><br>  Die durchschnittliche Laufzeit für jedes Szenario betrug 38 Sekunden, bevor Anmerkungsprozessoren auf Versionen aktualisiert wurden, die Inkrementalität unterstützen.  In diesem Fall deaktiviert Gradle die Unterstützung für die inkrementelle Kompilierung, sodass zwischen den Skripten kein wesentlicher Unterschied besteht. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource nach Aktualisierung der Anmerkungsprozessoren </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Szenario </th><th>  Inkrementelle ABI-Änderung </th><th>  Nicht inkrementelle ABI-Änderung </th><th>  Inkrementelle Non-ABI-Änderung </th><th>  Nicht inkrementelle Non-Abi-Änderung </th></tr></thead><tbody><tr><td>  <strong>gemein</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>Median</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>max</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193,29 </td><td>  1240,81 </td><td>  888,24 </td><td>  815,91 </td></tr></tbody></table></div><br><p>  Die mediane Verkürzung der Montagezeit aufgrund der Inkrementalität betrug 31% für ABI-Änderungen und 32,5% für Nicht-ABI-Änderungen.  Absolut ungefähr 10 Sekunden. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug nach Aktualisierung der Annotation-Prozessoren </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Szenario </th><th>  Inkrementelle ABI-Änderung </th><th>  Nicht inkrementelle ABI-Änderung </th><th>  Inkrementelle Non-ABI-Änderung </th><th>  Nicht inkrementelle Non-Abi-Änderung </th></tr></thead><tbody><tr><td>  <strong>gemein</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>Median</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>max</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953,28 </td><td>  1011,20 </td><td>  1015,37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Um die vollständige Debug-Version der Anwendung für unser Projekt zu erstellen, betrug die durchschnittliche Verringerung der Erstellungszeit aufgrund des Inkrements 21,5% für ABI-Änderungen und 23% für Nicht-ABI-Änderungen.  In absoluten Zahlen ungefähr die gleichen 10 Sekunden, da das Inkrement der Kompilierung des Quellcodes die Assemblierungsgeschwindigkeit der Ressourcen nicht beeinflusst. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Erstellen Sie die Scan-Anatomie in Gradle Build Scan </h2><br><p>  Um zu verstehen, wie das Inkrement während der inkrementellen Kompilierung erzielt wurde, vergleichen wir die Scans inkrementeller und nicht inkrementeller Baugruppen. </p><br><p>  Im Falle eines deaktivierten KAPT-Inkrements ist der Hauptteil der Erstellungszeit die Kompilierung des App-Moduls, die nicht mit anderen Aufgaben parallelisiert werden kann.  Die Zeitleiste für nicht inkrementelle KAPT lautet wie folgt: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="Bildbeschreibung hier eingeben"></p><br><p>  Aufgabenausführung: kaptDebugKotlin unseres App-Moduls dauert in diesem Fall ca. 8 Sekunden. </p><br><p>  Zeitleiste für den Fall mit aktiviertem KAPT-Inkrement: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="Bildbeschreibung hier eingeben"></p><br><p>  Jetzt wurde das App-Modul in weniger als einer Sekunde neu kompiliert.  Es lohnt sich, auf die visuelle Disproportionalität der Skalen der beiden Scans im obigen Bild zu achten.  Aufgaben, die im ersten Bild kürzer erscheinen, sind im zweiten nicht unbedingt länger, da sie länger erscheinen.  Es ist jedoch sehr auffällig, wie sehr sich der Anteil der Neukompilierung des App-Moduls verringert hat, wenn Sie das inkrementelle KAPT einschalten.  In unserem Fall gewinnen wir ungefähr 8 Sekunden auf diesem Modul und zusätzliche ungefähr 2 Sekunden auf kleineren Modulen, die parallel kompiliert werden. </p><br><p>  Gleichzeitig beträgt die Gesamtausführungszeit aller * kapt-Tasks für die deaktivierte Inkrementalität der Verarbeitungsanmerkungen 1 Minute und 36 Sekunden gegenüber 55 Sekunden, wenn sie aktiviert sind.  Das heißt, ohne die parallele Anordnung der Module zu berücksichtigen, ist die Verstärkung wesentlich größer. </p><br><p>  Es ist auch erwähnenswert, dass die obigen Benchmark-Ergebnisse in einer CI-Umgebung erstellt wurden, in der 24 parallele Threads für die Montage ausgeführt werden können.  In einer 8-Thread-Umgebung beträgt der Gewinn durch die Aktivierung der inkrementellen Anmerkungsverarbeitung in unserem Projekt etwa 20 bis 30 Sekunden. </p><br><h2 id="incremental-vs--parallel">  Inkrementelle vs (?) Parallele </h2><br><p>  Eine andere Möglichkeit, die Montage erheblich zu beschleunigen (sowohl inkrementell als auch sauber), besteht in der parallelen Ausführung einzelner Aufgaben, indem das Projekt in eine große Anzahl lose gekoppelter Module aufgeteilt wird.  Auf die eine oder andere Weise bietet die Modularisierung ein viel größeres Potenzial für die Beschleunigung von Baugruppen als die Verwendung von inkrementellem KAPT.  Je monolithischer das Projekt ist und je mehr Code generiert wird, desto größer ist die inkrementelle Verarbeitung der Anmerkungen.  Es ist einfacher, den Effekt einer vollständigen Inkrementalität von Assemblys zu erzielen, als eine Anwendung in Module zu unterteilen.  Trotzdem widersprechen sich beide Ansätze nicht und ergänzen sich perfekt. </p><br><h2 id="itog">  Zusammenfassung </h2><br><ul><li>  Durch die inkrementelle Verarbeitung von Anmerkungen in unserem Projekt konnten wir die Geschwindigkeit des lokalen Wiederaufbaus um 20% steigern </li><li>  Um die inkrementelle Anmerkungsverarbeitung zu aktivieren, ist es hilfreich, das vollständige Protokoll der aktuellen Assemblys zu lesen und nach Warnmeldungen mit dem Text "Inkrementelle Anmerkungsverarbeitung angefordert, die Unterstützung ist jedoch deaktiviert, da die folgenden Prozessoren nicht inkrementell sind ..." zu suchen.  Es ist erforderlich, Bibliotheksversionen auf Versionen zu aktualisieren, die die inkrementelle Verarbeitung von Anmerkungen unterstützen, und die Versionen Gradle 4.7+, Kotlin 1.3.30+ zu verwenden </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Materialien und was zum Thema zu lesen </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">Informationen zur Unterstützung der Verarbeitung inkrementeller Anmerkungen auf der Ebene des Gradle Java-Plugins</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Artikel über Gradle-Profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">Weitere Informationen zu KAPT-Funktionen</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Bericht über Google I / O 2019 mit aktuellen Tricks zur Build-Beschleunigung</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Ein weiterer Bericht zur Gradle-Optimierung in Google I / O 2017 enthält inkrementelles Build-Material und die Vermeidung von Kompilierungen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484918/">https://habr.com/ru/post/de484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484902/index.html">Auf Gleichungen höheren Grades</a></li>
<li><a href="../de484904/index.html">Ein Jahr ohne Splunk - wie ein amerikanisches Unternehmen den Markt für Maschinendatenanalyse in Russland veränderte und wen es zurückließ</a></li>
<li><a href="../de484906/index.html">Verteiltes Team und Teamleiter auf Remote</a></li>
<li><a href="../de484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): Was tun, wenn eine Minute Ausfallzeit 100.000 US-Dollar kostet?</a></li>
<li><a href="../de484910/index.html">Paul Graham: Hasser</a></li>
<li><a href="../de484920/index.html">Wie können Sie verstehen, dass Sie ein Fräsmaschinenbediener sind?</a></li>
<li><a href="../de484930/index.html">Lassen Sie uns wie Profis schnell codieren</a></li>
<li><a href="../de484932/index.html">Die doppelte Natur der Softwareanforderungen</a></li>
<li><a href="../de484934/index.html">Von der persönlichen Entwicklung zu Agile im XXXL-Maßstab in zwei Tagen bei TeamLead Conf</a></li>
<li><a href="../de484936/index.html">Wissen und Kompetenzen im Team: Finden, sehen, pumpen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>