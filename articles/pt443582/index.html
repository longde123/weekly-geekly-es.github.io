<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👒 👐🏾 🏴‍☠️ Hackeando um cartucho colorido HP: transformando-o em uma impressora portátil 🥠 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👨🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdução 
 Desde a juventude, quando tínhamos a antiga DeskJet, eu estava interessado em cartuchos de impressora a jato de tinta. Esses cartuchos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hackeando um cartucho colorido HP: transformando-o em uma impressora portátil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443582/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/dee/afd/78bdeeafddeac0cebecd298e836e42d1.jpg" alt="imagem"></div><br><h1>  1. Introdução </h1><br>  Desde a juventude, quando tínhamos a antiga DeskJet, eu estava interessado em cartuchos de impressora a jato de tinta.  Esses cartuchos pareciam muito interessantes e, assim que acabaram, eu os levei imediatamente para mim.  Naquela época, eu não podia fazer nada com eles, exceto desmontar e sujar as mãos ... Embora eu soubesse que havia algum tipo de eletrônica complexa por dentro, mas quando os contatos tocavam a bateria, nada de interessante aconteceu e meu conhecimento de eletrônica por mais não é suficiente. <br><br>  Um pouco mais tarde, quando me formei, consegui uma impressora jato de tinta antiga.  Naquela época, eu mesmo usava uma impressora a laser, por isso não estava muito interessado nela, mas era interessante examinar os cartuchos e tentar fazer engenharia reversa.  Na verdade, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrevi um artigo</a> sobre o gerenciamento desses cartuchos e, embora eles funcionassem muito bem, também havia desvantagens: eu ainda não conseguia descobrir a ordem exata dos bicos, o cartucho era apenas monocromático (impresso em magenta) e também bastante antigo e, portanto, a resolução acabou por ser bastante baixo. <br><br>  Recentemente, minha namorada começou a pintar, então essa era uma boa desculpa para retornar aos cartuchos de tinta na esperança de que eu pudesse desenhar algo na tela.  Dessa vez, tive sorte: consegui encontrar uma maneira de ligar todos os bicos aos sinais corretos.  Além disso, hoje os cartuchos de impressora controlam mais bicos usando menos sinais, o que simplifica o gerenciamento de cartuchos e aumenta a superfície que pode ser coberta em uma passagem. <br><a name="habracut"></a><br>  Finalmente consegui controlar o cartucho colorido e imprimir em cores! <br><br>  Se você quiser ir comigo da pilha de impressoras para concluir o controle do cartucho, fiz um relatório sobre isso no Hackaday Supercon 2018. A gravação em vídeo do discurso é adicionada abaixo.  Se você estiver interessado nos detalhes da engenharia reversa, confira.  Neste artigo, falarei sobre os detalhes técnicos dos componentes eletrônicos que criei, bem como os detalhes específicos do controle do cartucho, para que você possa desenhar o Nyancat usando o ESP32 ou outro microcontrolador. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/KjACWDPQ8nw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Anexo da apresentação </h1><br>  Se você não assistiu ao vídeo, aqui está um breve resumo: desmontei o cartucho colorido da impressora HP1112 (na China é um cartucho HP 803, mas o número do artigo depende da região), tirei fotos do cristal e tentei descobrir como ele funciona.  Quando não consegui descobrir muita coisa, comecei a ler os sinais transmitidos entre a impressora e o cartucho, descobri quais sinais enviar para que o cartucho obedecesse aos meus pedidos e depois imprimi Nyancat e outras coisas engraçadas. <br><br>  A parte do tempo do sinal do estudo foi principalmente um processo de tentativa e erro.  Só posso adivinhar que tipo de conexão existe entre os sinais, por isso foi bastante difícil descobrir a ordem entre as bordas e quais sinais podem ser atrasados ​​e quais devem ser transmitidos a tempo.  Estudei um cartucho de silicone para essa informação.  Acabei conseguindo obtê-lo colocando o cartucho sob o microscópio, mas não como eu esperava. <br><br>  Antes de falar na Supercon, estudei os cartuchos coloridos porque eles me pareciam os mais interessantes.  Depois de voltar da Supercon, eu queria fazer engenharia reversa do cartucho preto: sua cabeça de impressão é maior que a do cartucho colorido, para que eu pudesse imprimir mais de uma vez.  É provável que a adição de suporte para este cartucho não seja tão difícil: a organização dos pinos parece a mesma e eu sabia que o protocolo provavelmente seria semelhante, porque eu já havia tentado conectar o cartucho preto ao meu hardware.  Embora o software estivesse transmitindo imagens coloridas, ele ainda conseguiu imprimir alguma coisa. <br><br>  Aqui está o que fiz com o cartucho colorido: coloquei-o sob o microscópio, removi o revestimento de silicone dos contatos e preparei-me para combinar várias fotos em uma imagem grande.  No entanto, o cartucho preto diferia da cor, pois havia mais inscrições em sua placa de metal com bicos: sob o revestimento de silicone havia nomes de sinais ocultos para todos os contatos! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/cd7/ceb/31ccd7cebca89ee82bf17246cc42970b.jpg" alt="imagem"></div><br>  (A propósito, se você quiser ver fotos completas do microscópio com toda a grandeza de 40 megapixels, aqui está o <a href="">escudo</a> e o <a href="">silicone do</a> cartucho colorido! Admire a complexidade dos <a href="">bicos</a> e a <a href="">imagem cristalina do</a> cartucho preto!) <br><br>  Embora possa não parecer muito, em um mar de placas de circuito impresso não marcadas, chips sem materiais de referência e artigos que não levam a lugar algum, os nomes de vários sinais são uma descoberta real.  Em um palpite, direcionei nomes de sinais individuais com o nome “Hewlett Packard” para as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Patentes do Google</a> e descobri uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patente específica</a> (e outra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais antiga</a> mencionada pela primeira) com uma descrição clara das tecnologias e sinais usados ​​nos cartuchos.  Isso me pouparia muito tempo quando eu lutava com o tempo dos cartuchos ... tudo bem.  Posso dizer sinceramente que essa dica foi muito difícil de encontrar: os sinais não eram cobertos apenas com filme de silicone, mas também eram pequenos: as letras têm apenas 30 micrômetros de tamanho e isso é menor que a espessura de um cabelo humano. <br><br>  A patente descreve a operação interna do cartucho e vale a pena ler (se você puder descobrir o jargão jurídico usado lá) apenas para entender como a lógica estranha que a HP às vezes usa para controlar todos os bicos.  A patente em si é útil, mas não o suficiente para controlar o cartucho;  pelo menos a maior parte do trabalho de engenharia reversa que empreendi ainda seria necessária, mesmo se eu tivesse essa patente. <br><br>  Aqui e abaixo, usarei os nomes dos sinais e contatos usados ​​na patente.  Observe que, no código, meus próprios nomes de sinais ainda podem ser encontrados;  Incluirei uma tabela de tradução junto com a documentação. <br><br><h1>  Codificação de dados </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3d/a27/9b5/e3da279b5a469d8257956df6e1b213d0.jpg"></div><br>  Então, aqui está a aparência dos cartuchos em estudo.  À primeira vista, esses são dispositivos bastante simples: por dentro, quase inteiramente consistem em uma esponja encharcada de tinta.  No caso do cartucho que acompanha a impressora, há muito pouca tinta: apenas metade do espaço no cartucho é ocupado pelas esponjas, e as próprias esponjas também estão meio vazias: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/8c5/236/1d98c523675454d7f5cd6dbb88a2c685.jpg"></div><br>  No lado, existem 16 contatos na parte inferior, onde a cabeça de impressão está localizada.  Como você pode ver no microscópio, existem aproximadamente 336 injetores na cabeça de impressão do cartucho preto e 612 injetores no cartucho colorido.  Os bicos estão dispostos em linhas verticais na cabeça de impressão, e cada um pode ser controlado eletronicamente, de modo a disparar uma pequena gota de tinta na direção do lado do papel inserido na impressora.  Movendo a cabeça verticalmente, a impressora pode imprimir uma “tira” ou qualquer outra imagem;  no caso de um cartucho preto, essa fita tem aproximadamente 15 mm de comprimento e 8 mm para um cartucho colorido. <br><br>  Obviamente, os bocais podem ser controlados usando contatos.  De acordo com as pequenas inscrições da cabeça de impressão, os contatos contêm os seguintes sinais: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/10e/534/4c410e5349ffd16a8c97aed093121492.jpg"></div><br>  Como existem apenas 16 contatos, deve haver algum tipo de esquema de multiplexação para controlar todos os bicos.  A patente explica como funciona: o controle dos bicos é dividido em 14 grupos separados.  Esses grupos são acionados sequencialmente: primeiro recebe seus dados e aciona o grupo 1, depois o grupo 2 e assim por diante.  Cada grupo controla um máximo de 24 bocais e os dados para eles são transmitidos através de três barramentos de dados.  No caso de um cartucho colorido, os dados nos três barramentos correspondem às cores: D1 são dados amarelos, D2 são dados magenta e D3 controla os bicos cianos. <br><br>  Na patente, o trabalho é descrito em detalhes usando um barramento de dados como exemplo.  Esta figura da patente mostra os sinais utilizados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8f/554/372/a8f554372c6edfc81bf606ff6cf9907f.png"></div><br>  O barramento de dados contém oito bytes, 0-7.  Os bytes pares são controlados pela borda à direita do DCLK, os bytes ímpares são controlados pela borda à direita do S1-S4.  Bocais cujos dados são controlados pelos quatro primeiros bytes podem ser ligados fornecendo energia através do barramento de força F3;  os bicos associados aos últimos quatro bits são ativados pelo barramento F5. <br><br>  Não sei por que a HP decidiu usar um circuito tão complexo para gerenciar dados de bicos.  Podemos dizer que algo óbvio, como um registro de turno, teria funcionado normalmente aqui.  Entendo que a HP usa suas patentes como arma contra empresas de recarga de cartuchos;  talvez alguém já tenha patenteado uma solução mais simples e precisou criar essa solução mais complexa para ser único. <br><br>  Neste gráfico, feito por mim em um analisador lógico, não é difícil encontrar os sinais descritos na patente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/35e/025/50e35e02575c1508d44b21ba29acb909.png"></div><br>  Além de controlar os bicos, o cartucho também precisa de um sinal (csync) para ir para o próximo grupo de bicos ou para redefinir e retornar ao primeiro grupo.  Ele pode ser visto na imagem do analisador lógico: mostra o penúltimo e último grupo de 14 e o sinal csync tem uma forma reconhecível no último grupo;  ele executa uma "redefinição" do cartucho para que o primeiro grupo receba os dados a seguir.  Este sinal também pode ser usado para desviar grupos de bicos na ordem inversa;  isso é útil quando a cabeça de impressão se move da esquerda para a direita e da direita para a esquerda.  Embora a segunda patente descreva como isso funciona, eu decidi simplesmente codificar a transição para o próximo grupo e redefinir os sinais mostrados em minhas imagens pela linha csync. <br><br>  Observe que tudo isso acontece a uma velocidade bastante alta;  o atraso entre as duas bordas principais do sinal DCLK é de aproximadamente 0,4 µs e a distância entre os grupos é de aproximadamente 4 µs. <br><br>  Agora sabemos que cada bit desses três barramentos de 14 bytes contém um comando de operação para um bico.  Se o bit for 0, o bico correspondente será acionado;  se for igual a 1, o bico não funcionará.  O que não sabemos é a correspondência entre bits e bocais.  Se você assistiu à apresentação, sabe como consegui descobrir: imprimi um padrão conhecido em uma impressora em funcionamento, interceptando os sinais usando um analisador lógico e depois descobri qual deveria ser a ordem dos sinais para decodificar os sinais de volta à imagem original <br>  . <br>  Infelizmente, a correspondência de bits com bicos parece bastante constante, mas não completamente lógica.  Parece que isso se deve principalmente à necessidade de mover fisicamente os bicos simultaneamente a uma distância suficiente (para evitar superaquecimento ou ocorrência de vácuo local no tanque de tinta).  Além disso, também achei que a facilidade de encaminhar sinais em um cartucho pode tornar a correspondência de bits e bicos bastante confusa.  No meu firmware, eu simplesmente implementei esse mapeamento como um conjunto de tabelas de pesquisa. <br><br><h1>  Eletrônicos </h1><br>  Agora que sabemos como os sinais funcionam, podemos controlar o cartucho da impressora com um simples microcontrolador, certo?  Bem, não imediatamente.  O cartucho da impressora não usa lógica simples de 5 V ou 3,3 V. Os barramentos de dados são controlados por 16 V ou 9 V. Os barramentos de energia também são controlados por 16 V e, de fato, dependendo do número de bocais acionados, eles podem ser puxados para a corrente da fonte de alimentação .  Precisamos realizar uma conversão de nível. <br><br>  Como conversor de nível, eu escolhi o MC14504.  Este é um chip de conversão de nível hexadecimal unidirecional antigo que pode aumentar a tensão para 18 V. Embora esse chip também funcione, olhando para trás, posso dizer que essa não foi a melhor escolha: ele só pode produzir alguns mA e possui um atraso de propagação bastante grande.  Eu acho que isso atrasa alguns sinais de saída, dependendo do cartucho e da carga aplicada às saídas do chip.  Eu tenho pelo menos um cartucho que precisa de um pequeno ajuste de tempo para que os sinais funcionem, e acho que esse é o motivo.  Infelizmente, os conversores de nível de 16V já não estão tão acessíveis hoje, então não posso substituí-lo por algo melhor.  No entanto, este chip clássico com um pequeno ajuste é suficiente. <br><br>  Com os ônibus elétricos, as coisas são um pouco mais complicadas.  Além do fato de que esses contatos recebem uma grande parte da corrente, eles também são conectados diretamente aos resistores dos bocais incluídos: se por algum motivo a energia for fornecida por muito tempo, esses minúsculos resistores queimarão e o bico falhará completamente.  Além disso, esse "tempo demais" é bastante simples de conseguir: basta ligar os bicos por apenas alguns microssegundos e, se você fornecer energia por apenas um milissegundo, eles simplesmente evaporarão, quebrando completamente o bico.  Para evitar que isso aconteça devido a um erro de software ou a uma conexão incorreta, adicionei uma lógica de hardware que garante que o pulso seja limitado a um pequeno múltiplo de 10 μs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/293/dd0/802293dd067f458f2505e2db8036ab96.png"></div><br>  No primeiro protótipo, deixei vários conversores de nível e não sabia como o software funcionaria, então resolvi o problema com um multivibrador real de ciclo único.  Nesse circuito, dois multivibradores são usados ​​no 74HC123, gerando pulsos, cuja largura é definida pela combinação de R / C conectado ao pino RCExt.  O pulso resultante é gerado apenas com um sinal de entrada crescente; portanto, um sinal constantemente alto não levará a nada além de um pulso de saída definido com precisão, mas falso.  Depois disso, o canal MC14504 é usado como um conversor de nível para aumentar a tensão para +16 V, e o transistor MOS do canal P fornece a corrente necessária. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99b/b17/97f/99bb1797fd10e01c1c8f3a7ddceb6c8f.png"></div><br>  Na segunda placa de circuito impresso, percebi que se eu mudar a lógica dos contatos de potência para que eles não usem dois canais do circuito de mudança de nível, apenas dois chips MC14504 serão suficientes.  Agora eu tenho controle programático suficientemente bom sobre a largura do pulso, mas ainda quero ter proteção contra um sinal de contato de entrada constantemente alto.  Aqui está o diagrama que eu vim.  Funciona assim: no estado normal com um sinal baixo PWRB_IN, o capacitor C28 está vazio, porque qualquer tensão nele flui lentamente ao longo de R20 e R21: a porta do transistor Q4 é alta e PWRB_OUT é desconectado do barramento de potência de 16 V. Assim que PWRB_IN alto aparecer alto sinal, Q6 aterrou uma extremidade de C28;  uma vez que a voltagem é de 0 V, inicialmente isso também diminui o outro lado, que está conectado ao portão Q4.  Puxar o obturador Q4 para baixo o torna condutor e isso permite que a corrente flua de +16 V para PWRB_OUT.  No estado normal, PWRB_IN volta ao estado baixo com rapidez suficiente, fechando o portão Q4 e interrompendo a corrente.  No entanto, enquanto PWRB_IN estiver baixo, o C28 está carregando lentamente: um lado está aterrado no Q6 e o ​​outro está conectado a 16 V via R21 e R31.  Quando o capacitor está suficientemente carregado, o Q4 “vê” um nível alto em sua porta e desliga a corrente em PWRB_OUT, mesmo se PWRB_IN ainda estiver em um estado de sinal alto.  Esse mecanismo garante que PWRB_OUT forneça energia apenas por um período limitado de tempo. <br><br>  O circuito também possui um pequeno resistor conectado em série ao barramento de força de 16 V (R31), além de um pequeno capacitor conectado em paralelo ao sinal de saída (C15).  Eles são necessários para "aliviar a tensão" do sinal de energia: sem eles, um Q4 acentuado liga e desliga induz um monte de interferência eletromagnética, distorcendo os sinais transmitidos ao cartucho. <br><br>  Além dessa lógica, nada mais é necessário.  Obviamente, são necessários conversores de nível de +9 V e +16 V. A fonte de alimentação de +9 V. deve ser bastante modesta: eu não percebi que esses barramentos geralmente usavam mais do que alguns mA.  Como alimenta os resistores do bico, a fonte de 16 V deve ser um pouco mais forte: eu fiz isso para que a mina pudesse fornecer pelo menos 400 mA continuamente e também adicionei bastante capacitância de desacoplamento. <br><br>  Finalmente, o ônus mais importante do processamento de imagem e geração de sinal recai sobre o microcontrolador.  Para esse propósito, escolhi o ESP32, principalmente porque tirei algumas peças do trabalho, mas também porque ele possui um controlador I2S bastante poderoso que usa um modo paralelo muito conveniente: na verdade, podemos definir a frequência do relógio, especifique a área de memória para o controlador I2S e ele produzirá esses bytes em paralelo.  Graças a isso, é ideal para gerar os sinais de controle necessários;  O fato de possuir dois núcleos poderosos de 240 MHz também ajuda no processamento de imagens. <br><br><h1>  Protótipo </h1><br>  Obviamente, vários conversores e transistores MOS sozinhos não podem se tornar um controlador de cartucho de impressora em funcionamento.  Portanto, criei um dispositivo separado, concebido como uma plataforma para experimentar um cartucho e seus recursos.  Possui um módulo ESP32, a lógica necessária para controlar o cartucho e várias fontes de alimentação para trabalhar a partir de uma célula de íons de lítio.  Também é equipado com vários sensores projetados para compensar movimentos imperfeitos das mãos de uma pessoa, além de botões e uma tela que fornece feedback sobre as imagens impressas.  Vamos dar uma olhada nos componentes, talvez para alguém se torne uma inspiração para a invasão de cartuchos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/0e1/214/d4d0e12142a11a23f9e31aebcba561ae.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/054/607/540/054607540b0ff66f45b62cbc3fec15cb.png"></div><br>  Vamos começar com a fonte de energia.  A energia é fornecida a partir de uma célula de íons de lítio e convertida em 3,3 V, 16 V e 9 V. É necessária uma tensão de 3,3 V para sensores e ESP32;  é gerado usando um simples regulador LD78 HT7833.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensões de 9 V e 16 V são geradas por dois conversores de impulso baseados no chip conversor de impulso XR2203. Observe que uma fonte de alimentação de 16 V deve trabalhar muito mais do que uma fonte de alimentação de 9 V; o cartucho consome de 9 V apenas alguns miliamperes. Dois conversores de impulso foram criados no mesmo chip simplesmente porque bastava comprar um tipo de componente para ambos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como todo o dispositivo é alimentado por uma célula de íons de lítio, precisamos carregá-lo de alguma forma. Como tenho pouco espaço, adicionei um carregador de bateria de íon de lítio baseado em TP4056 para recarregar a bateria de qualquer fonte de alimentação USB.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ad/aed/33b/1adaed33b3e6be049b8ea9d8fc255575.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inteligência do dispositivo é fornecida pelo módulo ESP-Wrover32. </font><font style="vertical-align: inherit;">Usei a opção com 8 MiB de memória flash e 8 MiB de RAM SPI; </font><font style="vertical-align: inherit;">o suficiente para executar um processamento de imagem complexo. </font><font style="vertical-align: inherit;">O módulo também possui um conector de 5 pinos que permite programar e depurar o firmware, além de dois botões que podem ser usados ​​para selecionar opções e iniciar a renderização quando o firmware estiver em execução.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/080/061/edb/080061edb43ce76036ca339ce4168de7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As opções selecionadas são exibidas em uma pequena tela LCD colorida de 160x80. </font><font style="vertical-align: inherit;">A tela possui uma conexão SPI e pode ser controlada diretamente por um dos conectores SPI periféricos disponíveis no ESP32.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1b/7b3/b34/c1b7b3b34741f26232e4cc0686195d29.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa é a interface do cartucho. </font><font style="vertical-align: inherit;">Como afirmado acima, não é particularmente complicado. </font><font style="vertical-align: inherit;">O nível de todos os sinais é convertido pelo par MC14504, um para sinais de 9 V e outro para sinais de V. V. Também no diagrama há um circuito de mudança de nível / proteção que controla os barramentos de energia dupla.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/155/4c5/b7e/1554c5b7eb0ee9f845f605ead1906127.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d9d/34c/a7f/d9d34ca7fde4f19bdc9bc7431525f7b8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8f/02c/928/f8f02c928f1c353a9b12272b1971118c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui estão três tipos de sensores que eu usei. Todos eles são conectados usando um barramento I2C, ou seja, no ESP32 eles ocupam apenas dois GPIOs. Este é um bloco de sensores inerciais MPU9250 (acelerômetro, giroscópio e bússola digital) para medir o movimento, três sensores de distância a laser VL53L0X (apenas um é mostrado), direcionados para cima, esquerda e direita. A idéia é que, combinando essas informações, é teoricamente possível determinar a posição absoluta do cartucho. Isso é útil, por exemplo, ao desenhar imagens grandes com um movimento da mão livre. Este último é o sensor de cores TCS3472. O sensor de cor está localizado próximo ao LED branco; pode ser usado para "copiar" a cor do objeto ou para compensar a cor da mídia na qual imprimimos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2be/cb9/e3a/2becb9e3abd6af17cdc70f6b36f114a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como eu precisava de GPIOs adicionais, conectei um expansor GPIO ao barramento. Ele controla os barramentos de redefinição para os três sensores de distância, o barramento de redefinição para a tela LCD, a inclusão de um conversor de reforço e dois transistores MOS (não mostrados) que controlam o LED branco usado para iluminar o alvo do sensor de cor e a luz de fundo da tela LCD. Os sensores de distância precisam de um barramento de redefinição separado, porque ligam no mesmo endereço I2C. No entanto, eles possuem um comando que altera o endereço I2C após a ativação. Ao ativá-los e movê-los um a um para endereços I2C diferentes, eu posso controlar todos os três no mesmo barramento I2C.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e6/daf/fc5/4e6daffc5f3e191d8470724ea9fac785.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui está a placa de circuito que eu projetei com base no circuito. </font><font style="vertical-align: inherit;">Sua forma é estranha, pois deve ser dividida em quatro placas separadas e "circundar" o cartucho da impressora. </font><font style="vertical-align: inherit;">Eles estão conectados eletricamente e fisicamente; </font><font style="vertical-align: inherit;">a vantagem disso é que os fabricantes de placas de circuito impresso não consideram esse circuito quatro placas separadas e você só precisa pagar por uma.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/9c8/2ff/be19c82ff2d96aa49100c6608d06eba6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra vantagem é que posso montar a placa como um elemento e testá-la quando todos os componentes estiverem no mesmo plano. </font><font style="vertical-align: inherit;">Isso me permite não equilibrar cuidadosamente o dispositivo montado durante a depuração. </font><font style="vertical-align: inherit;">Uma pequena observação: os sensores VL53L0X usam um raio laser infravermelho; </font><font style="vertical-align: inherit;">Parece que é forte o suficiente para romper o filtro de proteção contra radiação infravermelha no meu “espelho” e aparece no quadro como pequenos pontos roxos de luz.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/dee/afd/78bdeeafddeac0cebecd298e836e42d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E qual será o resultado final após a montagem. Observe que quando as placas foram separadas, as conexões entre elas foram interrompidas. As placas possuem pequenas almofadas de solda nas quais você pode soldar um pequeno pedaço de arame e dobrá-lo. Obviamente, para o nível de produção, você precisará usar tecnologias como PCB FPC ou PCB flexível, mas para um protótipo barato isso funcionará. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você deseja usar esse protótipo para referência ou experimentar, pode fazer </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> download </font><a href=""><font style="vertical-align: inherit;">dos arquivos do projeto KiCad</font></a><font style="vertical-align: inherit;"> (também existem diagramas em pdf e gerber no mesmo local) e montá-lo você mesmo, ou usar seus subsistemas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como este é um protótipo, o software é bastante ... heterogêneo. </font><font style="vertical-align: inherit;">Vou dar um link para o repositório em que foi desenvolvido, mas lembre-se de que este é um instantâneo de quase todo o ciclo de desenvolvimento, portanto contém tudo em ordem, desde gravações de sinais por um analisador lógico até Nyancat e Mona Lisa impressos. </font><font style="vertical-align: inherit;">Infelizmente, portanto, o código é um caos quase não documentado, com caminhos incompletos e remanescentes do código antigo. </font><font style="vertical-align: inherit;">Se você ainda deseja aprender, pode clonar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> URL </font><font style="vertical-align: inherit;">no git </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, se você estiver mais interessado em software que possa controlar facilmente o cartucho da impressora usando o ESP32 (e contenha procedimentos úteis para controlá-lo através de outro microcontrolador), continue lendo.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versão de trabalho mínima </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para facilitar a utilização de cartuchos de impressora por outros artesãos, também criei uma versão mínima do driver. Falta suporte para todos os periféricos e hacks do código do protótipo, mas a arquitetura é limpa e, portanto, pode se tornar uma base sólida para desenvolvimento adicional. O driver possui um exemplo simples de um programa que imprime quando o botão HELLO! cartucho colorido ou preto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não criei equipamentos especializados para isso, mas na verdade você pode reutilizar o hardware da seção anterior: basta </font><a href=""><font style="vertical-align: inherit;">usar</font></a><font style="vertical-align: inherit;"> uma </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonte de alimentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP32</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conversores de nível</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e aplicá-los em seu próprio esquema. Você também pode usar totalmente o protótipo descrito na seção anterior: basta fornecer um sinal alto constante BOOST_EN para que os conversores de 9 V / 16 V estejam sempre ligados. (Dessa maneira, depurei o código.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O código em si pode ser encontrado no </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , está estruturado de maneira padrão para o projeto ESP-IDF. O código principal do driver está em </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">components / printcart</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; código do botão de ler e decidir quando deve ligar o bico, bem como o código de inicialização contidas no </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main / main.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No exemplo, os dados do bico são lidos a partir da imagem rgb incorporada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sistema possui a seguinte arquitetura: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printcart_i2s.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contém um driver simples para o modo paralelo dos conectores periféricos I2S do controlador ESP32. Ele seleciona dois buffers e transfere das palavras de 16 bits dos buffers com uma frequência de 3,3 MHz para os contatos GPIO (máximo de 16 contatos). (Aqui, esses pinos GPIO são conectados aos conversores de nível que controlam o cartucho.) Cada vez que o buffer está vazio, o driver executa um manipulador de eventos para preencher o buffer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O manipulador de eventos está localizado em </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printcart_buffer_filler.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ele recebe dados dos bicos da fila de dados dos bicos e os passa para uma função em </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printcart_genwaveform.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que por modelo converte esses dados dos bicos em sinais. O modelo depende do tipo de cartucho (colorido ou preto) e você pode alterá-lo carregando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tools / waveform_editor.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no navegador </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por outro lado, a fila de dados do bico é o procedimento de loop em main.c. Ele espera que um botão seja pressionado e, quando pressionado, gera dados de bico analisando um arquivo de imagem simples convertido em dados rgb brutos e incorporado em um arquivo binário costurado, digitalizando os dados da esquerda para a direita. Graças a isso, você pode pressionar o botão, varrendo o cartucho sobre o papel e imprimir o conteúdo da imagem na forma de uma tira de tinta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O resultado final é mais ou menos assim:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/9e9/bfc/6249e9bfca9c9fc52ff3da8f581db653.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">É muito perceptível aqui que o cartucho preto imprime aproximadamente o dobro da altura da cor (0,7 cm e 1,5 cm); portanto, se você não precisa de cores e precisa de boa visibilidade, é melhor escolher um cartucho preto. Também é importante notar que em main.c é definido que alterna entre dois cartuchos; código pode funcionar com ambos. Não está totalmente claro por que existem linhas borradas na imagem em preto: talvez haja um erro no meu sinal ou talvez o cartucho esteja um pouco cansado de testar. Seja como for, os dados impressos são bonitos e bem reconhecíveis.</font></font><br><br><h1>  Em conclusão </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A engenharia reversa desses cartuchos de impressora foi uma longa aventura, mas no final meu trabalho foi proveitoso; </font><font style="vertical-align: inherit;">embora restem alguns quebra-cabeças (por exemplo: o que o contato com ID faz?), acho que entendi bem os enigmas dos sinais usados ​​no cartucho. </font><font style="vertical-align: inherit;">Espero que, ao publicar o código e os diagramas deste projeto, adicione o uso de cartuchos de impressora ao kit de ferramentas de artesãos, hackers e criadores. </font><font style="vertical-align: inherit;">Mal posso esperar para ver exemplos interessantes de uso que a comunidade apresentará. </font><font style="vertical-align: inherit;">Se você conseguir fazer algo interessante com o meu trabalho, não deixe de me enviar uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensagem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanto à minha intenção de criar arte ... umm ... isso pode ser chamado assim?</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/491/722/895/49172289578ace93f8bd04a051d1866e.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443582/">https://habr.com/ru/post/pt443582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443570/index.html">Não esperávamos isso: uma carta aberta anual de Bill e Melinda Gates</a></li>
<li><a href="../pt443572/index.html">Outra maneira de escrever aplicativos de plataforma cruzada: Neutralinojs internals e comparação com Electron e NW.js</a></li>
<li><a href="../pt443574/index.html">Depurar aplicativos CLI angulares no VSCode usando a Visualização do navegador</a></li>
<li><a href="../pt443576/index.html">[Peter] Contentores e distribuições - JUG.ru se encontra com Dmitry Chuyko e Alexander Belokrylov</a></li>
<li><a href="../pt443578/index.html">Primeiros relatórios sobre PHDays: intercepção de videoconferência, nova versão do GhostTunnel, ataques ao Java Card</a></li>
<li><a href="../pt443584/index.html">Assista a lançamentos de filmes digitais de alta qualidade sem problemas</a></li>
<li><a href="../pt443586/index.html">GeekBrains lança maratona de trabalho remoto on-line gratuito</a></li>
<li><a href="../pt443588/index.html">Professor do Instituto de Tecnologia de Massachusetts revela o futuro das próteses no TED</a></li>
<li><a href="../pt443590/index.html">Data Science: prevendo eventos de negócios para melhorar o serviço</a></li>
<li><a href="../pt443592/index.html">Padrão de front-end RFID ISO 11785 de um antigo receptor de FM e detritos de elevadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>