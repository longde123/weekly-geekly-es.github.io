<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíï üòº ü•ò Tests de r√©gression visuelle. Red√©marrer üóª üë¶ üë¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mon article pr√©c√©dent, j'ai parl√© de l'exp√©rience d'utilisation du moteur Gemini pour d√©velopper des tests visuels, ou plut√¥t des tests de r√©gres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests de r√©gression visuelle. Red√©marrer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  Dans mon <a href="https://habr.com/ru/post/454464/">article</a> pr√©c√©dent, j'ai parl√© de l'exp√©rience d'utilisation du moteur <a href="https://github.com/gemini-testing/gemini">Gemini</a> pour d√©velopper des tests visuels, ou plut√¥t des tests de r√©gression visuelle.  Ces tests v√©rifient si quelque chose a ¬´boug√©¬ª dans l'interface utilisateur apr√®s les prochains changements en comparant les captures d'√©cran actuelles avec celles de r√©f√©rence pr√©c√©demment fix√©es.  Depuis lors, beaucoup de choses ont chang√© dans nos approches d'√©criture des tests visuels, y compris le moteur utilis√©.  Maintenant, nous utilisons <a href="https://github.com/gemini-testing/hermione">Hermione</a> , mais dans cet article, je vais parler non seulement et pas tellement d'Hermione, mais des probl√®mes qui se sont accumul√©s depuis et comment les r√©soudre, qui, entre autres, ont conduit √† la transition vers un nouveau moteur. <br><a name="habracut"></a><br>  Premi√®rement, bien que les tests aient fonctionn√© et avec succ√®s, nous ne comprenions pas clairement ce qui √©tait couvert par les tests et ce qui ne l‚Äô√©tait pas.  Il y avait bien s√ªr une certaine id√©e du degr√© de couverture, mais nous ne l'avons pas mesur√© quantitativement.  Deuxi√®mement, la composition des tests a augment√© au fil du temps et diff√©rents tests ont souvent test√© la m√™me chose, car  dans diff√©rentes captures d'√©cran, une partie co√Øncidait avec la m√™me partie, mais dans une capture d'√©cran diff√©rente.  Par cons√©quent, m√™me des modifications mineures de CSS pourraient submerger de nombreux tests √† la fois et n√©cessiter la mise √† jour d'un grand nombre de normes.  Troisi√®mement, un th√®me sombre est apparu dans notre produit, et afin de le couvrir en quelque sorte avec des tests, certains tests ont √©t√© s√©lectivement pass√©s √† l'utilisation d'un th√®me sombre, ce qui n'a pas non plus clarifi√© le probl√®me de la d√©termination du degr√© de couverture. <br><br><h2>  Optimisation des performances </h2><br>  Nous avons commenc√©, curieusement, avec des performances optimis√©es.  Je vais vous expliquer pourquoi.  Nos tests visuels sont bas√©s sur le <a href="https://github.com/storybooks/storybook">livre d'histoires</a> .  Chaque histoire du livre d'histoires n'est pas un composant unique, mais un ¬´bloc¬ª entier (par exemple, une grille avec une liste d'entit√©s, une carte d'entit√©, un dialogue ou m√™me l'application dans son ensemble).  Pour afficher ce bloc, vous devez ¬´pomper¬ª l'histoire avec des donn√©es, non seulement les donn√©es affich√©es pour l'utilisateur, mais aussi l'√©tat des composants utilis√©s √† l'int√©rieur du bloc.  Ces informations sont stock√©es avec le code source sous forme de fichiers json contenant une repr√©sentation s√©rialis√©e de l'√©tat de l'application (redux store).  Oui, ces donn√©es sont, pour le moins, redondantes, mais elles simplifient consid√©rablement la cr√©ation de tests.  Pour cr√©er un nouveau test, nous ouvrons simplement la carte, la liste ou la bo√Æte de dialogue souhait√©e dans l'application, prenons un instantan√© de l'√©tat actuel de l'application et le s√©rialisons dans un fichier.  Ensuite, nous ajoutons une nouvelle histoire et des tests qui prennent des captures d'√©cran de cette histoire (le tout en quelques lignes de code). <br><br>  Cette approche augmente in√©vitablement la taille du paquet.  Le degr√© de duplication des donn√©es en elle ne fait que ¬´rouler¬ª.  Lors de l'ex√©cution de tests, le moteur gemini ex√©cute chaque suite de tests dans une session de navigateur distincte.  Chaque session charge √† nouveau le bundle et la taille du bundle dans un tel sch√©ma est loin de la derni√®re valeur. <br><br>  Pour r√©duire le temps d'ex√©cution des tests, nous avons r√©duit le nombre de suites de tests en augmentant le nombre de tests qu'elles contiennent.  Ainsi, une suite de tests pourrait affecter plusieurs histoires √† la fois.  Dans ce sch√©ma, nous avons pratiquement perdu la possibilit√© de ¬´filtrer¬ª uniquement une certaine zone de l'√©cran en raison du fait que Gemini vous permet de d√©finir la zone de capture d'√©cran uniquement pour la suite de tests dans son ensemble (bien que l'API vous permette de le faire avant chaque capture d'√©cran, mais en pratique cela ne fonctionne pas). <br><br>  L'incapacit√© √† limiter la zone de la capture d'√©cran dans les tests a conduit √† la duplication des informations visuelles dans les images de r√©f√©rence.  Bien qu'il n'y ait pas eu beaucoup de tests, ce probl√®me ne semblait pas significatif.  Oui, et l'interface utilisateur n'a pas chang√© tr√®s souvent.  Mais cela ne pouvait pas durer √©ternellement - une refonte se profilait √† l'horizon. <br><br>  Pour l'avenir, je dirai que dans Hermione, une zone de capture d'√©cran peut √™tre d√©finie pour chaque prise de vue et, √† premi√®re vue, le passage √† un nouveau moteur r√©soudrait tous les probl√®mes.  Mais il nous faudrait encore ¬´√©craser¬ª les grandes suites de tests.  Le fait est que les tests visuels ne sont pas intrins√®quement stables (cela peut √™tre d√ª √† diverses raisons, par exemple, avec des retards de r√©seau, √† l'aide d'animations ou avec la ¬´m√©t√©o sur Mars¬ª) et il est tr√®s difficile de se passer de tentatives automatiques.  Gemini et Hermione effectuent des tentatives pour la suite de tests dans son ensemble, et plus la suite de tests est ¬´√©paisse¬ª, moins elle aura de chances de se terminer avec succ√®s pendant les nouvelles tentatives, car  lors de la prochaine ex√©cution, il se peut que les tests qui ont √©t√© r√©ussis pr√©c√©demment tombent.  Pour les suites de tests √©paisses, nous avons d√ª impl√©menter un sch√©ma de nouvelle tentative int√©gr√© au moteur Gemini et nous ne voulions vraiment pas recommencer lors du passage √† un nouveau moteur. <br><br>  Par cons√©quent, afin d'acc√©l√©rer le chargement de la suite de tests, nous avons divis√© le paquet monolithique en parties, en allouant chaque instantan√© de l'√©tat de l'application en une ¬´pi√®ce¬ª distincte, charg√©e ¬´√† la demande¬ª pour chaque histoire s√©par√©ment.  Le code de cr√©ation d'histoire ressemble maintenant √† ceci: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Pour cr√©er une histoire, le composant StoryProvider est utilis√© (son code sera donn√© ci-dessous).  Les instantan√©s sont charg√©s √† l'aide de la fonction d' <a href="https://webpack.js.org/guides/code-splitting/">importation dynamique</a> .  Diff√©rentes histoires ne diff√®rent les unes des autres que par des images d'√©tats.  Pour un th√®me sombre, sa propre histoire est g√©n√©r√©e, en utilisant le m√™me instantan√© que l'histoire pour un th√®me clair.  Dans le contexte d'un livre de contes, cela ressemble √† ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Histoire de th√®me par d√©faut</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Histoire de th√®me sombre</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  Le composant StoryProvider accepte un rappel pour charger un instantan√© dans lequel la fonction import () est appel√©e.  La fonction import () fonctionne de mani√®re asynchrone, vous ne pouvez donc pas prendre de capture d'√©cran imm√©diatement apr√®s le chargement de l'histoire - nous risquons de supprimer le vide.  Afin de saisir l'instant de la fin du t√©l√©chargement, le fournisseur rend l'√©l√©ment marqueur DOM signalant le moteur de test pour la dur√©e du t√©l√©chargement, qui doit √™tre retard√© avec la capture d'√©cran: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  De plus, pour r√©duire la taille du bundle, d√©sactivez l'ajout de mappages source au bundle.  Mais pour ne pas perdre la possibilit√© de d√©boguer l'histoire (on ne sait jamais quoi), on le fait √† la condition: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  Le <b>script npm run build-storybook</b> compile un storybook statique sans sourcemap dans le dossier storybook-static.  Il est utilis√© lors des tests.  Et le <b>script npm run storybook est</b> utilis√© pour d√©velopper et d√©boguer des histoires de test. <br><br><h2>  √âlimination de la duplication des informations visuelles </h2><br>  Comme je l'ai dit ci-dessus, Gemini vous permet de d√©finir des s√©lecteurs de zone de capture d'√©cran pour la suite de tests dans son ensemble, ce qui signifie que pour r√©soudre compl√®tement le probl√®me de duplication des informations visuelles dans les captures d'√©cran, nous devons cr√©er notre propre suite de tests pour chaque capture d'√©cran.  M√™me en tenant compte de l'optimisation du chargement de l'histoire, cela n'avait pas l'air trop optimiste en termes de vitesse et nous avons pens√© √† changer le moteur de test. <br><br>  En fait, pourquoi Hermione?  Actuellement, le r√©f√©rentiel Gemini est marqu√© comme obsol√®te et, t√¥t ou tard, nous avons d√ª ¬´d√©placer¬ª quelque part.  La structure du fichier de configuration Hermione est identique √† la structure du fichier de configuration Gemini et nous avons pu r√©utiliser cette config.  Les plugins Gemini et Hermione sont √©galement courants.  De plus, nous avons pu r√©utiliser l'infrastructure de test - machines virtuelles et grille de s√©l√©nium d√©ploy√©e. <br><br>  Contrairement √† Gemini, Hermione n'est pas positionn√©e comme un outil uniquement pour les tests de r√©gression de la mise en page.  Ses capacit√©s de manipulation du navigateur sont beaucoup plus larges et limit√©es uniquement par les capacit√©s de <a href="http://v4.webdriver.io/">Webdriver IO</a> .  En combinaison avec <a href="https://github.com/mochajs/mocha">mocha,</a> ce moteur est plus pratique √† utiliser pour les tests fonctionnels (simulation des actions de l'utilisateur) que pour les tests de mise en page.  Pour les tests de r√©gression de la mise en page, Hermione fournit uniquement la m√©thode assertView (), qui compare une capture d'√©cran d'une page de navigateur avec une r√©f√©rence.  La capture d'√©cran peut √™tre limit√©e √† la zone sp√©cifi√©e √† l'aide des s√©lecteurs css. <br><br>  Pour notre cas, le test pour chaque histoire individuelle ressemblerait √† ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  La m√©thode waitForVisible (), malgr√© son nom, vous permet de vous attendre non seulement √† l'apparence, mais √©galement au masquage de l'√©l√©ment, si vous d√©finissez le deuxi√®me param√®tre sur true.  Ici, nous l'utilisons pour attendre qu'un √©l√©ment marqueur soit masqu√©, indiquant que l'instantan√© de donn√©es n'est pas encore charg√© et que l'histoire n'est pas encore pr√™te pour une capture d'√©cran. <br><br>  Si vous essayez de trouver la m√©thode waitForVisible () dans la documentation Hermione, vous ne trouverez rien.  Le fait est que la <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">m√©thode</a> waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">est la m√©thode API Webdriver IO</a> .  La m√©thode url (), respectivement, aussi.  Dans la m√©thode url (), nous transmettons l'adresse de trame d'une histoire particuli√®re, pas le livre d'histoires entier.  Tout d'abord, cela est n√©cessaire pour que la liste des histoires ne s'affiche pas dans la fen√™tre du navigateur - nous n'avons pas besoin de la tester.  Deuxi√®mement, si n√©cessaire, nous pouvons avoir acc√®s aux √©l√©ments DOM √† l'int√©rieur du cadre (les m√©thodes webdriverIO vous permettent d'ex√©cuter du code JavaScript dans un contexte de navigateur). <br><br>  Pour simplifier l'√©criture des tests, nous avons fait notre wrapper sur les tests mocha.  Le fait est qu'il n'y a pas de sens particulier dans l'√©laboration d√©taill√©e des cas de test pour les tests de r√©gression.  Tous les cas de test sont identiques - ¬´devrait √™tre √©gal √† √©talon¬ª.  Eh bien, je ne veux pas non plus dupliquer le code pour attendre le chargement des donn√©es dans chaque test.  Par cons√©quent, le m√™me travail pour tous les tests ¬´singe¬ª est d√©l√©gu√© √† la fonction wrapper, et les tests eux-m√™mes sont √©crits de mani√®re d√©clarative (enfin, presque).  Voici le texte de cette fonction: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Un objet d√©crivant la suite de tests est pass√© √† l'entr√©e de la fonction.  Chaque suite de tests est construite selon le sc√©nario suivant: prendre une capture d'√©cran de la mise en page principale (par exemple, une zone d'une carte d'entit√© ou une zone d'une liste d'entit√©s), puis appuyer sur des boutons par programmation pouvant entra√Æner l'apparition d'autres √©l√©ments (par exemple, des panneaux contextuels ou des menus contextuels) et ¬´prendre une capture d'√©cran ¬ªChacun de ces √©l√©ments s√©par√©ment.  Ainsi, nous simulons les actions des utilisateurs dans le navigateur, mais pas dans le but de tester une sorte de sc√©nario d'entreprise, mais simplement pour ¬´capturer¬ª le nombre maximal possible de composants visuels.  De plus, la duplication des informations visuelles dans les captures d'√©cran est minime, car  les captures d'√©cran sont prises "ponctuellement" √† l'aide de s√©lecteurs.  Exemple de suite de tests: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  D√©termination de la couverture </h2><br>  Donc, nous avons compris la vitesse et la redondance, il reste √† d√©terminer l'efficacit√© de nos tests, c'est-√†-dire d√©terminer le degr√© de couverture du code avec des tests (ici par code, j'entends les feuilles de style CSS). <br><br>  Pour les histoires de test, nous avons empiriquement s√©lectionn√© les cartes, listes et autres √©l√©ments les plus compliqu√©s √† remplir afin de couvrir autant de styles que possible avec une capture d'√©cran.  Par exemple, pour tester une carte d'entit√©, des cartes avec un grand nombre de types de contr√¥les diff√©rents (texte, nombre, transferts, dates, grilles, etc.) ont √©t√© s√©lectionn√©es.  Les cartes pour diff√©rents types d'entit√©s ont leurs propres sp√©cificit√©s, par exemple, √† partir d'une carte de document, vous pouvez afficher un panneau avec une liste des versions de document, et la carte de t√¢che affiche la correspondance pour cette t√¢che.  En cons√©quence, pour chaque type d'entit√©, sa propre histoire et un ensemble de tests sp√©cifiques √† ce type, etc., ont √©t√© cr√©√©s.  Au final, nous avons pens√© que tout semblait √™tre couvert de tests, mais nous voulions un peu plus de confiance que ¬´j'aime¬ª. <br><br>  Pour √©valuer la couverture dans Chrome DevTools, il existe un outil avec le nom Couverture tr√®s adapt√© √† ce cas: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  La couverture vous permet de d√©terminer quels styles ou quel code js a √©t√© utilis√© lors de l'utilisation de la page du navigateur.  Le rapport sur l'utilisation des rayures vertes indique le code utilis√©, rouge - non utilis√©.  Et tout irait bien si nous avions une application du niveau ¬´bonjour, monde¬ª, mais que faire quand nous avons des milliers de lignes de code?  Les d√©veloppeurs de couverture l'ont bien compris et ont fourni la possibilit√© d'exporter le rapport dans un fichier qui peut d√©j√† √™tre √©labor√© par programme. <br><br>  Je dois dire tout de suite que jusqu'√† pr√©sent, nous n'avons pas trouv√© de moyen de collecter automatiquement le degr√© de couverture.  Th√©oriquement, cela peut √™tre fait en utilisant le navigateur sans t√™te pupeteer, mais pupeteer ne fonctionne pas sous le contr√¥le du s√©l√©nium, ce qui signifie que nous ne pourrons pas r√©utiliser le code de nos tests.  Donc pour l'instant, sautons ce sujet extr√™mement int√©ressant et travaillons avec des stylos. <br><br>  Apr√®s avoir ex√©cut√© les tests en mode manuel, nous obtenons un rapport de couverture, qui est un fichier json.  Dans le rapport pour chaque css, js, ts, etc.  le fichier indique son texte (sur une ligne) et les intervalles du code utilis√© dans ce texte (sous forme d'indices de caract√®res de cette ligne).  Voici un extrait du rapport: <br><br><div class="spoiler">  <b class="spoiler_title">coverage.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  √Ä premi√®re vue, il n'y a rien de difficile √† trouver des s√©lecteurs CSS inutilis√©s.  Mais alors que faire de ces informations?  En effet, en derni√®re analyse, nous devons trouver non pas des s√©lecteurs sp√©cifiques, mais des composants que nous avons oubli√© de couvrir avec des tests.  Les styles d'un composant peuvent √™tre d√©finis par plus d'une douzaine de s√©lecteurs.  En cons√©quence, sur la base des r√©sultats de l'analyse du rapport, nous obtenons des centaines de s√©lecteurs inutilis√©s, et si vous traitez avec chacun d'eux, vous pouvez tuer beaucoup de temps. <br><br>  Ici, les expressions r√©guli√®res nous aident.  Bien s√ªr, ils ne fonctionneront que si les conventions de d√©nomination des classes css sont respect√©es (dans notre code, les classes css sont nomm√©es selon la m√©thodologie BEM - block_name_name_name_modifier).  √Ä l'aide d'expressions r√©guli√®res, nous calculons les valeurs uniques des noms de blocs, qui ne sont plus difficiles √† associer aux composants.  Bien s√ªr, nous nous int√©ressons √©galement aux √©l√©ments et aux modificateurs, mais pas en premier lieu, nous devons d'abord faire face √† un ¬´poisson¬ª plus gros.  Vous trouverez ci-dessous un script pour le traitement d'un rapport de couverture <br><br><div class="spoiler">  <b class="spoiler_title">couverture.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Nous ex√©cutons le script en pla√ßant d'abord le fichier coverage.json export√© de Chrome DevTools et en √©crivant l'√©chappement dans un fichier .csv: <br><br>  <b>node coverage.js&gt; coverage.csv</b> <br><br>  Vous pouvez ouvrir ce fichier √† l'aide d'Excel et analyser les donn√©es, notamment en d√©terminant le pourcentage de couverture de code par des tests. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Au lieu d'un CV </h2><br>  L'utilisation du livre d'histoires comme base pour des tests visuels se justifie pleinement - nous avons un degr√© suffisant de couverture du code CSS avec des tests avec un nombre relativement faible d'histoires et des co√ªts minimes pour en cr√©er de nouveaux. <br><br>  La transition vers un nouveau moteur nous a permis d'√©liminer la duplication des informations visuelles dans les captures d'√©cran, ce qui a grandement simplifi√© la prise en charge des tests existants. <br><br>  Le degr√© de couverture du code CSS est mesurable et, de temps en temps, est surveill√©.  Il y a bien s√ªr une grande question - comment ne pas oublier la n√©cessit√© de ce contr√¥le et comment ne pas rater quelque chose dans le processus de collecte d'informations sur la couverture.  Id√©alement, je voudrais mesurer automatiquement le degr√© de couverture √† chaque test, de sorte que lorsque le seuil sp√©cifi√© est atteint, les tests tombent avec une erreur.  Nous y travaillerons, s'il y a des nouvelles, je vous le dirai certainement. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479040/">https://habr.com/ru/post/fr479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479022/index.html">Les t√©l√©viseurs intelligents Samsung, LG, Vizio et TCL prennent chaque seconde des "empreintes digitales" de l'√©cran et les envoient au serveur</a></li>
<li><a href="../fr479026/index.html">V√©ritable somme des canaux Internet - OpenMPTCPRouter</a></li>
<li><a href="../fr479034/index.html">Comment se connecter √† un VPN d'entreprise sous Linux en utilisant openconnect et vpn-slice</a></li>
<li><a href="../fr479036/index.html">Intel ne peut pas faire face √† la demande de processeurs. HP et Dell en souffrent</a></li>
<li><a href="../fr479038/index.html">Transformation num√©rique Leroy Merlin: Conception d'une interface pour travailler avec les appels clients</a></li>
<li><a href="../fr479042/index.html">La m√©thode Y est un moyen tr√®s simple de cr√©er un Rubik's Cube</a></li>
<li><a href="../fr479044/index.html">Mon impl√©mentation de tampon en anneau dans NOR flash</a></li>
<li><a href="../fr479048/index.html">Node.js Streams pour les nuls ou comment travailler avec les streams</a></li>
<li><a href="../fr479050/index.html">Recherche de brevets en informatique. Le parcours du jeune combattant. Partie II Sources d'information pour la recherche sur les brevets</a></li>
<li><a href="../fr479052/index.html">[Supercalcul 2019]. Stockage multicloud en tant qu'application pour les nouveaux disques Kingston DC1000M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>