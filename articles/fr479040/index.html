<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💕 😼 🥘 Tests de régression visuelle. Redémarrer 🗻 👦 👴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans mon article précédent, j'ai parlé de l'expérience d'utilisation du moteur Gemini pour développer des tests visuels, ou plutôt des tests de régres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests de régression visuelle. Redémarrer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/directum/blog/479040/">  Dans mon <a href="https://habr.com/ru/post/454464/">article</a> précédent, j'ai parlé de l'expérience d'utilisation du moteur <a href="https://github.com/gemini-testing/gemini">Gemini</a> pour développer des tests visuels, ou plutôt des tests de régression visuelle.  Ces tests vérifient si quelque chose a «bougé» dans l'interface utilisateur après les prochains changements en comparant les captures d'écran actuelles avec celles de référence précédemment fixées.  Depuis lors, beaucoup de choses ont changé dans nos approches d'écriture des tests visuels, y compris le moteur utilisé.  Maintenant, nous utilisons <a href="https://github.com/gemini-testing/hermione">Hermione</a> , mais dans cet article, je vais parler non seulement et pas tellement d'Hermione, mais des problèmes qui se sont accumulés depuis et comment les résoudre, qui, entre autres, ont conduit à la transition vers un nouveau moteur. <br><a name="habracut"></a><br>  Premièrement, bien que les tests aient fonctionné et avec succès, nous ne comprenions pas clairement ce qui était couvert par les tests et ce qui ne l’était pas.  Il y avait bien sûr une certaine idée du degré de couverture, mais nous ne l'avons pas mesuré quantitativement.  Deuxièmement, la composition des tests a augmenté au fil du temps et différents tests ont souvent testé la même chose, car  dans différentes captures d'écran, une partie coïncidait avec la même partie, mais dans une capture d'écran différente.  Par conséquent, même des modifications mineures de CSS pourraient submerger de nombreux tests à la fois et nécessiter la mise à jour d'un grand nombre de normes.  Troisièmement, un thème sombre est apparu dans notre produit, et afin de le couvrir en quelque sorte avec des tests, certains tests ont été sélectivement passés à l'utilisation d'un thème sombre, ce qui n'a pas non plus clarifié le problème de la détermination du degré de couverture. <br><br><h2>  Optimisation des performances </h2><br>  Nous avons commencé, curieusement, avec des performances optimisées.  Je vais vous expliquer pourquoi.  Nos tests visuels sont basés sur le <a href="https://github.com/storybooks/storybook">livre d'histoires</a> .  Chaque histoire du livre d'histoires n'est pas un composant unique, mais un «bloc» entier (par exemple, une grille avec une liste d'entités, une carte d'entité, un dialogue ou même l'application dans son ensemble).  Pour afficher ce bloc, vous devez «pomper» l'histoire avec des données, non seulement les données affichées pour l'utilisateur, mais aussi l'état des composants utilisés à l'intérieur du bloc.  Ces informations sont stockées avec le code source sous forme de fichiers json contenant une représentation sérialisée de l'état de l'application (redux store).  Oui, ces données sont, pour le moins, redondantes, mais elles simplifient considérablement la création de tests.  Pour créer un nouveau test, nous ouvrons simplement la carte, la liste ou la boîte de dialogue souhaitée dans l'application, prenons un instantané de l'état actuel de l'application et le sérialisons dans un fichier.  Ensuite, nous ajoutons une nouvelle histoire et des tests qui prennent des captures d'écran de cette histoire (le tout en quelques lignes de code). <br><br>  Cette approche augmente inévitablement la taille du paquet.  Le degré de duplication des données en elle ne fait que «rouler».  Lors de l'exécution de tests, le moteur gemini exécute chaque suite de tests dans une session de navigateur distincte.  Chaque session charge à nouveau le bundle et la taille du bundle dans un tel schéma est loin de la dernière valeur. <br><br>  Pour réduire le temps d'exécution des tests, nous avons réduit le nombre de suites de tests en augmentant le nombre de tests qu'elles contiennent.  Ainsi, une suite de tests pourrait affecter plusieurs histoires à la fois.  Dans ce schéma, nous avons pratiquement perdu la possibilité de «filtrer» uniquement une certaine zone de l'écran en raison du fait que Gemini vous permet de définir la zone de capture d'écran uniquement pour la suite de tests dans son ensemble (bien que l'API vous permette de le faire avant chaque capture d'écran, mais en pratique cela ne fonctionne pas). <br><br>  L'incapacité à limiter la zone de la capture d'écran dans les tests a conduit à la duplication des informations visuelles dans les images de référence.  Bien qu'il n'y ait pas eu beaucoup de tests, ce problème ne semblait pas significatif.  Oui, et l'interface utilisateur n'a pas changé très souvent.  Mais cela ne pouvait pas durer éternellement - une refonte se profilait à l'horizon. <br><br>  Pour l'avenir, je dirai que dans Hermione, une zone de capture d'écran peut être définie pour chaque prise de vue et, à première vue, le passage à un nouveau moteur résoudrait tous les problèmes.  Mais il nous faudrait encore «écraser» les grandes suites de tests.  Le fait est que les tests visuels ne sont pas intrinsèquement stables (cela peut être dû à diverses raisons, par exemple, avec des retards de réseau, à l'aide d'animations ou avec la «météo sur Mars») et il est très difficile de se passer de tentatives automatiques.  Gemini et Hermione effectuent des tentatives pour la suite de tests dans son ensemble, et plus la suite de tests est «épaisse», moins elle aura de chances de se terminer avec succès pendant les nouvelles tentatives, car  lors de la prochaine exécution, il se peut que les tests qui ont été réussis précédemment tombent.  Pour les suites de tests épaisses, nous avons dû implémenter un schéma de nouvelle tentative intégré au moteur Gemini et nous ne voulions vraiment pas recommencer lors du passage à un nouveau moteur. <br><br>  Par conséquent, afin d'accélérer le chargement de la suite de tests, nous avons divisé le paquet monolithique en parties, en allouant chaque instantané de l'état de l'application en une «pièce» distincte, chargée «à la demande» pour chaque histoire séparément.  Le code de création d'histoire ressemble maintenant à ceci: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// visual-regression.stories.js import React from 'react'; import StoryProvider from './story-provider'; const stories = storiesOf('visual-regression', module); [ { name: 'Contract', loadData: import('./snapshots/contract.testdata') }, { name: 'ExecutionTask', loadData: import('./snapshots/execution-task.testdata') }, { name: 'ExecutionAssignment', loadData: import('./snapshots/execution-assignment.testdata') }, { name: 'DocumentTemplate', loadData: import('./snapshots/document-template.testdata') }, { name: 'Explorer', loadData: import('./snapshots/explorer.testdata') }, { name: 'Inbox', loadData: import('./snapshots/inbox.testdata') }, ] .map(story =&gt; { stories .add(story.name, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} /&gt;) .add(`${story.name}Dark`, () =&gt; &lt;StoryProvider loadSnapshot={story.loadData} theme='night' /&gt;); });</span></span></code> </pre> <br>  Pour créer une histoire, le composant StoryProvider est utilisé (son code sera donné ci-dessous).  Les instantanés sont chargés à l'aide de la fonction d' <a href="https://webpack.js.org/guides/code-splitting/">importation dynamique</a> .  Différentes histoires ne diffèrent les unes des autres que par des images d'états.  Pour un thème sombre, sa propre histoire est générée, en utilisant le même instantané que l'histoire pour un thème clair.  Dans le contexte d'un livre de contes, cela ressemble à ceci: <br><br><div class="spoiler">  <b class="spoiler_title">Histoire de thème par défaut</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d6/vc/uk/d6vcukhmensy0jogshjj4hifoui.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Histoire de thème sombre</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jy/z0/uu/jyz0uuyel6t1pofayyjxftuunwg.png"><br></div></div><br>  Le composant StoryProvider accepte un rappel pour charger un instantané dans lequel la fonction import () est appelée.  La fonction import () fonctionne de manière asynchrone, vous ne pouvez donc pas prendre de capture d'écran immédiatement après le chargement de l'histoire - nous risquons de supprimer le vide.  Afin de saisir l'instant de la fin du téléchargement, le fournisseur rend l'élément marqueur DOM signalant le moteur de test pour la durée du téléchargement, qui doit être retardé avec la capture d'écran: <br><br><div class="spoiler">  <b class="spoiler_title">story-provider.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// story-provider.js const propsStub = { // -,      . . . }; type Props = { loadSnapshot: () =&gt; Object, theme: ?string }; const StoryProvider = (props: Props) =&gt; { const [ snapshotState, setsnapshotState ] = React.useState(null); React.useEffect(() =&gt; { //    (async() =&gt; setsnapshotState((await props.loadSnapshot).default))(); }); if (!snapshotState) //     ,     return &lt;div className={'loading-stub'}&gt;Loading...&lt;/div&gt;; //    snapshotState.metadata = require('./snapshots/metadata'); //  redux-   const store = createMockStore(snapshotState); //   applyTheme(props.theme); return ( &lt;Provider store={store}&gt; &lt;MemoryRouter&gt; &lt;App {...propsStub} /&gt; &lt;/MemoryRouter&gt; &lt;/Provider&gt; ); }; export default StoryProvider;</span></span></code> </pre><br></div></div><br>  De plus, pour réduire la taille du bundle, désactivez l'ajout de mappages source au bundle.  Mais pour ne pas perdre la possibilité de déboguer l'histoire (on ne sait jamais quoi), on le fait à la condition: <br><br><div class="spoiler">  <b class="spoiler_title">.storybook / webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// .storybook/webpack.config.js ... module.exports = { ... devtool: process.env.NODE_ENV === 'vr-test' ? '(none)' : 'eval-source-map' };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">package.json</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// package.json { ... "scripts": { ... "storybook": "start-storybook", "build-storybook": "cross-env NODE_ENV=vr-test build-storybook -o ./storybook-static", ... },</span></span></code> </pre><br></div></div><br>  Le <b>script npm run build-storybook</b> compile un storybook statique sans sourcemap dans le dossier storybook-static.  Il est utilisé lors des tests.  Et le <b>script npm run storybook est</b> utilisé pour développer et déboguer des histoires de test. <br><br><h2>  Élimination de la duplication des informations visuelles </h2><br>  Comme je l'ai dit ci-dessus, Gemini vous permet de définir des sélecteurs de zone de capture d'écran pour la suite de tests dans son ensemble, ce qui signifie que pour résoudre complètement le problème de duplication des informations visuelles dans les captures d'écran, nous devons créer notre propre suite de tests pour chaque capture d'écran.  Même en tenant compte de l'optimisation du chargement de l'histoire, cela n'avait pas l'air trop optimiste en termes de vitesse et nous avons pensé à changer le moteur de test. <br><br>  En fait, pourquoi Hermione?  Actuellement, le référentiel Gemini est marqué comme obsolète et, tôt ou tard, nous avons dû «déplacer» quelque part.  La structure du fichier de configuration Hermione est identique à la structure du fichier de configuration Gemini et nous avons pu réutiliser cette config.  Les plugins Gemini et Hermione sont également courants.  De plus, nous avons pu réutiliser l'infrastructure de test - machines virtuelles et grille de sélénium déployée. <br><br>  Contrairement à Gemini, Hermione n'est pas positionnée comme un outil uniquement pour les tests de régression de la mise en page.  Ses capacités de manipulation du navigateur sont beaucoup plus larges et limitées uniquement par les capacités de <a href="http://v4.webdriver.io/">Webdriver IO</a> .  En combinaison avec <a href="https://github.com/mochajs/mocha">mocha,</a> ce moteur est plus pratique à utiliser pour les tests fonctionnels (simulation des actions de l'utilisateur) que pour les tests de mise en page.  Pour les tests de régression de la mise en page, Hermione fournit uniquement la méthode assertView (), qui compare une capture d'écran d'une page de navigateur avec une référence.  La capture d'écran peut être limitée à la zone spécifiée à l'aide des sélecteurs css. <br><br>  Pour notre cas, le test pour chaque histoire individuelle ressemblerait à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    describe('Visual regression', function() { it('Contract card should equal to etalon', function() { return this.browser //  story   .url('http://localhost:8080/iframe.html?selectedKind=visual-regression&amp;selectedStory=ContractDark') // ,      story .waitForVisible('.loading-stub', true) //          .assertView('layout', '.form'); }) });</span></span></code> </pre><br>  La méthode waitForVisible (), malgré son nom, vous permet de vous attendre non seulement à l'apparence, mais également au masquage de l'élément, si vous définissez le deuxième paramètre sur true.  Ici, nous l'utilisons pour attendre qu'un élément marqueur soit masqué, indiquant que l'instantané de données n'est pas encore chargé et que l'histoire n'est pas encore prête pour une capture d'écran. <br><br>  Si vous essayez de trouver la méthode waitForVisible () dans la documentation Hermione, vous ne trouverez rien.  Le fait est que la <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">méthode</a> waitForVisible () <a href="http://v4.webdriver.io/api/utility/waitForVisible.html">est la méthode API Webdriver IO</a> .  La méthode url (), respectivement, aussi.  Dans la méthode url (), nous transmettons l'adresse de trame d'une histoire particulière, pas le livre d'histoires entier.  Tout d'abord, cela est nécessaire pour que la liste des histoires ne s'affiche pas dans la fenêtre du navigateur - nous n'avons pas besoin de la tester.  Deuxièmement, si nécessaire, nous pouvons avoir accès aux éléments DOM à l'intérieur du cadre (les méthodes webdriverIO vous permettent d'exécuter du code JavaScript dans un contexte de navigateur). <br><br>  Pour simplifier l'écriture des tests, nous avons fait notre wrapper sur les tests mocha.  Le fait est qu'il n'y a pas de sens particulier dans l'élaboration détaillée des cas de test pour les tests de régression.  Tous les cas de test sont identiques - «devrait être égal à étalon».  Eh bien, je ne veux pas non plus dupliquer le code pour attendre le chargement des données dans chaque test.  Par conséquent, le même travail pour tous les tests «singe» est délégué à la fonction wrapper, et les tests eux-mêmes sont écrits de manière déclarative (enfin, presque).  Voici le texte de cette fonction: <br><br><div class="spoiler">  <b class="spoiler_title">create-test-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> themes = [ <span class="hljs-string"><span class="hljs-string">'default'</span></span>, <span class="hljs-string"><span class="hljs-string">'dark'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootClassName = <span class="hljs-string"><span class="hljs-string">'.explorer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadingStubClassName = <span class="hljs-string"><span class="hljs-string">'.loading-stub'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTestSuite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">testSuite</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, storyName, browsers, testCases, selector } = testSuite; <span class="hljs-comment"><span class="hljs-comment">//  ,       browsers &amp;&amp; hermione.only.in(browsers); //      themes.forEach(theme =&gt; { describe(`${name}_${theme}`, () =&gt; it('should equal to etalon', function() { let browser = this.browser //   story .url(`${storybookUrl}/iframe.html?selectedKind=visual-regression&amp;selectedStory=${storyName}-${theme}`) //     .waitForVisible(loadingStubClassName, timeout, true) .waitForVisible(rootClassName); //    (  ) if (testCases &amp;&amp; testCases.length &gt; 0) { testCases.forEach(testCase =&gt; { if (testCase.before) browser = testCase.before(browser); browser = browser.assertView(`${name}__${testCase.name}_${theme}`, testCase.selector || selector || rootClassName, testCase.options); }); return browser; } //    ,    return browser.assertView(`${name}_${theme}`, selector || rootClassName); })); }); }</span></span></code> </pre><br></div></div><br>  Un objet décrivant la suite de tests est passé à l'entrée de la fonction.  Chaque suite de tests est construite selon le scénario suivant: prendre une capture d'écran de la mise en page principale (par exemple, une zone d'une carte d'entité ou une zone d'une liste d'entités), puis appuyer sur des boutons par programmation pouvant entraîner l'apparition d'autres éléments (par exemple, des panneaux contextuels ou des menus contextuels) et «prendre une capture d'écran »Chacun de ces éléments séparément.  Ainsi, nous simulons les actions des utilisateurs dans le navigateur, mais pas dans le but de tester une sorte de scénario d'entreprise, mais simplement pour «capturer» le nombre maximal possible de composants visuels.  De plus, la duplication des informations visuelles dans les captures d'écran est minime, car  les captures d'écran sont prises "ponctuellement" à l'aide de sélecteurs.  Exemple de suite de tests: <br><br><div class="spoiler">  <b class="spoiler_title">explorer-suite.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// explorer-suite.js //         module.exports = { //  story,    storyName: 'explorer', //    name: 'explorer', //  ,       browsers: [ 'chrome-1920x1080', 'ie-1920x1080' ], //   testCases: [ { //    name: 'layout' }, { //    name: 'notification-area', selector: '.notification-area__popup', before: b =&gt; b .click('.notification-area__popup-button') .waitForVisible('.notification-area__popup') .execute(function() { //       document.querySelectorAll('.expandable-item__content')[2].click(); }) }, //... ] };</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">tests.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tests.js [ require('./suites/explorer-suite'), //... ] .forEach(suite =&gt; createTestSuite(suite));</span></span></code> </pre><br></div></div><br><h2>  Détermination de la couverture </h2><br>  Donc, nous avons compris la vitesse et la redondance, il reste à déterminer l'efficacité de nos tests, c'est-à-dire déterminer le degré de couverture du code avec des tests (ici par code, j'entends les feuilles de style CSS). <br><br>  Pour les histoires de test, nous avons empiriquement sélectionné les cartes, listes et autres éléments les plus compliqués à remplir afin de couvrir autant de styles que possible avec une capture d'écran.  Par exemple, pour tester une carte d'entité, des cartes avec un grand nombre de types de contrôles différents (texte, nombre, transferts, dates, grilles, etc.) ont été sélectionnées.  Les cartes pour différents types d'entités ont leurs propres spécificités, par exemple, à partir d'une carte de document, vous pouvez afficher un panneau avec une liste des versions de document, et la carte de tâche affiche la correspondance pour cette tâche.  En conséquence, pour chaque type d'entité, sa propre histoire et un ensemble de tests spécifiques à ce type, etc., ont été créés.  Au final, nous avons pensé que tout semblait être couvert de tests, mais nous voulions un peu plus de confiance que «j'aime». <br><br>  Pour évaluer la couverture dans Chrome DevTools, il existe un outil avec le nom Couverture très adapté à ce cas: <br><br><img src="https://habrastorage.org/webt/ma/yt/dh/maytdhehcjiumoxdsdj-woa40lo.png"><br><br>  La couverture vous permet de déterminer quels styles ou quel code js a été utilisé lors de l'utilisation de la page du navigateur.  Le rapport sur l'utilisation des rayures vertes indique le code utilisé, rouge - non utilisé.  Et tout irait bien si nous avions une application du niveau «bonjour, monde», mais que faire quand nous avons des milliers de lignes de code?  Les développeurs de couverture l'ont bien compris et ont fourni la possibilité d'exporter le rapport dans un fichier qui peut déjà être élaboré par programme. <br><br>  Je dois dire tout de suite que jusqu'à présent, nous n'avons pas trouvé de moyen de collecter automatiquement le degré de couverture.  Théoriquement, cela peut être fait en utilisant le navigateur sans tête pupeteer, mais pupeteer ne fonctionne pas sous le contrôle du sélénium, ce qui signifie que nous ne pourrons pas réutiliser le code de nos tests.  Donc pour l'instant, sautons ce sujet extrêmement intéressant et travaillons avec des stylos. <br><br>  Après avoir exécuté les tests en mode manuel, nous obtenons un rapport de couverture, qui est un fichier json.  Dans le rapport pour chaque css, js, ts, etc.  le fichier indique son texte (sur une ligne) et les intervalles du code utilisé dans ce texte (sous forme d'indices de caractères de cette ligne).  Voici un extrait du rapport: <br><br><div class="spoiler">  <b class="spoiler_title">coverage.json</b> <div class="spoiler_text"><pre> <code class="json hljs">[ { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/theme-default.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">8127</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... --theme_primary-accent: #5b9bd5;\r\n --theme_primary-light: #ffffff;\r\n --theme_primary: #f4f4f4;\r\n ..."</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://localhost:6006/main.css"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ranges"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">610</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-number"><span class="hljs-number">728</span></span>, <span class="hljs-attr"><span class="hljs-attr">"end"</span></span>: <span class="hljs-number"><span class="hljs-number">754</span></span> } ] <span class="hljs-string"><span class="hljs-string">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"... \r\n line-height:1;\r\n}\r\n\r\nol, ul{\r\n list-style:none;\r\n}\r\n\r\nblockquote, q..."</span></span> ]</code> </pre><br></div></div><br>  À première vue, il n'y a rien de difficile à trouver des sélecteurs CSS inutilisés.  Mais alors que faire de ces informations?  En effet, en dernière analyse, nous devons trouver non pas des sélecteurs spécifiques, mais des composants que nous avons oublié de couvrir avec des tests.  Les styles d'un composant peuvent être définis par plus d'une douzaine de sélecteurs.  En conséquence, sur la base des résultats de l'analyse du rapport, nous obtenons des centaines de sélecteurs inutilisés, et si vous traitez avec chacun d'eux, vous pouvez tuer beaucoup de temps. <br><br>  Ici, les expressions régulières nous aident.  Bien sûr, ils ne fonctionneront que si les conventions de dénomination des classes css sont respectées (dans notre code, les classes css sont nommées selon la méthodologie BEM - block_name_name_name_modifier).  À l'aide d'expressions régulières, nous calculons les valeurs uniques des noms de blocs, qui ne sont plus difficiles à associer aux composants.  Bien sûr, nous nous intéressons également aux éléments et aux modificateurs, mais pas en premier lieu, nous devons d'abord faire face à un «poisson» plus gros.  Vous trouverez ci-dessous un script pour le traitement d'un rapport de couverture <br><br><div class="spoiler">  <b class="spoiler_title">couverture.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> modules = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./coverage.json'</span></span>).filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> e.url.endsWith(<span class="hljs-string"><span class="hljs-string">'.css'</span></span>)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module, rangeStart, rangeEnd, isUsed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rules = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.text.slice(rangeStart, rangeEnd); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> regex = <span class="hljs-regexp"><span class="hljs-regexp">/^\.([^\d{:,)_ ]+-?)+/gm</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classNames = rules.match(regex); classNames &amp;&amp; classNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> selectors[name] = selectors[name] || isUsed); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> previousEnd, selectors = {}; modules.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> { previousEnd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.ranges) { processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, range.start, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, range.start, range.end, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); previousEnd = range.end; } processRange(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, previousEnd, <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.length, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'className;isUsed'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(selectors).sort().forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${s}</span></span></span><span class="hljs-string">;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selectors[s]}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br></div></div><br>  Nous exécutons le script en plaçant d'abord le fichier coverage.json exporté de Chrome DevTools et en écrivant l'échappement dans un fichier .csv: <br><br>  <b>node coverage.js&gt; coverage.csv</b> <br><br>  Vous pouvez ouvrir ce fichier à l'aide d'Excel et analyser les données, notamment en déterminant le pourcentage de couverture de code par des tests. <br><br><img src="https://habrastorage.org/webt/gh/ss/b8/ghssb8zrlh41pakcvwhyl6fcjge.png"><br><br><h2>  Au lieu d'un CV </h2><br>  L'utilisation du livre d'histoires comme base pour des tests visuels se justifie pleinement - nous avons un degré suffisant de couverture du code CSS avec des tests avec un nombre relativement faible d'histoires et des coûts minimes pour en créer de nouveaux. <br><br>  La transition vers un nouveau moteur nous a permis d'éliminer la duplication des informations visuelles dans les captures d'écran, ce qui a grandement simplifié la prise en charge des tests existants. <br><br>  Le degré de couverture du code CSS est mesurable et, de temps en temps, est surveillé.  Il y a bien sûr une grande question - comment ne pas oublier la nécessité de ce contrôle et comment ne pas rater quelque chose dans le processus de collecte d'informations sur la couverture.  Idéalement, je voudrais mesurer automatiquement le degré de couverture à chaque test, de sorte que lorsque le seuil spécifié est atteint, les tests tombent avec une erreur.  Nous y travaillerons, s'il y a des nouvelles, je vous le dirai certainement. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479040/">https://habr.com/ru/post/fr479040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479022/index.html">Les téléviseurs intelligents Samsung, LG, Vizio et TCL prennent chaque seconde des "empreintes digitales" de l'écran et les envoient au serveur</a></li>
<li><a href="../fr479026/index.html">Véritable somme des canaux Internet - OpenMPTCPRouter</a></li>
<li><a href="../fr479034/index.html">Comment se connecter à un VPN d'entreprise sous Linux en utilisant openconnect et vpn-slice</a></li>
<li><a href="../fr479036/index.html">Intel ne peut pas faire face à la demande de processeurs. HP et Dell en souffrent</a></li>
<li><a href="../fr479038/index.html">Transformation numérique Leroy Merlin: Conception d'une interface pour travailler avec les appels clients</a></li>
<li><a href="../fr479042/index.html">La méthode Y est un moyen très simple de créer un Rubik's Cube</a></li>
<li><a href="../fr479044/index.html">Mon implémentation de tampon en anneau dans NOR flash</a></li>
<li><a href="../fr479048/index.html">Node.js Streams pour les nuls ou comment travailler avec les streams</a></li>
<li><a href="../fr479050/index.html">Recherche de brevets en informatique. Le parcours du jeune combattant. Partie II Sources d'information pour la recherche sur les brevets</a></li>
<li><a href="../fr479052/index.html">[Supercalcul 2019]. Stockage multicloud en tant qu'application pour les nouveaux disques Kingston DC1000M</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>