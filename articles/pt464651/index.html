<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§î üíÄ üîß Biblioteca de gerador de c√≥digo Assembler para microcontroladores AVR. Parte 5 ü§Æ ‚öñÔ∏è üßíüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üê Parte 4. Programa√ß√£o de perif√©ricos e manuseio de interrup√ß√µes 
 Biblioteca do gerador de c√≥digo do assembler para microcontroladores AVR 
 Parte 5....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioteca de gerador de c√≥digo Assembler para microcontroladores AVR. Parte 5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464651/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚Üê Parte 4. Programa√ß√£o de perif√©ricos e manuseio de interrup√ß√µes</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Biblioteca do gerador de c√≥digo do assembler para microcontroladores AVR </h2><br><h3 id="chast-5-proektirovanie-mnogopotochnyh-prilozheniy">  Parte 5. Projetando aplicativos multithread </h3><br><p>  Nas partes anteriores do artigo, elaboramos os conceitos b√°sicos de programa√ß√£o usando a biblioteca.  Na parte anterior, nos familiarizamos com a implementa√ß√£o de interrup√ß√µes e as restri√ß√µes que podem surgir ao trabalhar com elas.  Nesta parte do post, abordaremos uma das op√ß√µes poss√≠veis para programar processos paralelos usando a classe <em>Parallel</em> .  O uso dessa classe possibilita simplificar a cria√ß√£o de aplicativos nos quais os dados devem ser processados ‚Äã‚Äãem v√°rios fluxos de programas independentes. </p><a name="habracut"></a><br><p>  Todos os sistemas multitarefa para sistemas de n√∫cleo √∫nico s√£o semelhantes entre si.  O multithreading √© implementado atrav√©s do trabalho do expedidor, que aloca um intervalo de tempo para cada encadeamento e, quando termina, assume o controle e concede controle ao pr√≥ximo encadeamento.  A diferen√ßa entre as v√°rias implementa√ß√µes est√° apenas nos detalhes, portanto, vamos nos aprofundar mais nos principais recursos espec√≠ficos dessa implementa√ß√£o. </p><br><p>  A unidade de execu√ß√£o do processo no encadeamento √© a tarefa.  Um n√∫mero ilimitado de tarefas pode existir no sistema, mas a qualquer momento, apenas um certo n√∫mero delas pode ser ativado, limitado pelo n√∫mero de fluxos de trabalho no expedidor.  Nesta implementa√ß√£o, o n√∫mero de fluxos de trabalho √© especificado no construtor do gerenciador e n√£o pode ser alterado posteriormente.  No processo, os threads podem executar tarefas ou permanecer livres.  Diferentemente de outras solu√ß√µes, o <em>Parallel</em> Manager n√£o alterna tarefas.  Para que a tarefa retorne o controle ao expedidor, os comandos apropriados devem ser inseridos em seu c√≥digo.  Portanto, a responsabilidade pela dura√ß√£o do intervalo de tempo na tarefa √© do programador, que deve inserir comandos de interrup√ß√£o em determinados locais do c√≥digo se a tarefa demorar muito e tamb√©m determinar o comportamento do encadeamento ap√≥s a conclus√£o da tarefa.  A vantagem dessa abordagem √© que o programador controla os pontos de altern√¢ncia entre tarefas, o que permite otimizar significativamente o c√≥digo de salvar / restaurar ao alternar tarefas, al√©m de livrar-se da maioria dos problemas relacionados ao acesso a dados seguros para threads. </p><br><p>  Para controlar a execu√ß√£o de tarefas em execu√ß√£o, uma classe <em>Signal</em> especial √© usada.  O sinal √© um pouco vari√°vel, cuja configura√ß√£o √© usada como sinal de ativa√ß√£o para iniciar uma tarefa em um fluxo.  Os valores do sinal podem ser definidos manualmente ou por um evento associado a este sinal. </p><br><p>  O sinal √© redefinido quando a tarefa √© ativada pelo expedidor ou pode ser executada programaticamente. </p><br><p>  As tarefas no sistema podem estar nos seguintes estados: </p><br><p>  <strong>Desativado</strong> - estado inicial para todas as tarefas.  A tarefa n√£o ocupa o fluxo e o controle de execu√ß√£o n√£o √© transferido.  O retorno a esse estado para tarefas ativadas ocorre ap√≥s o comando de conclus√£o. </p><br><p>  <strong>Ativado</strong> - o estado em que a tarefa est√° localizada ap√≥s a ativa√ß√£o.  O processo de ativa√ß√£o associa uma tarefa a um encadeamento de execu√ß√£o e um sinal de ativa√ß√£o.  O gerente consulta os encadeamentos e inicia a tarefa se o sinal da tarefa estiver ativado. </p><br><p>  <strong>Bloqueado</strong> - quando uma tarefa √© ativada, um sinal j√° pode ser atribu√≠do a ela como um sinal, que j√° √© usado para controlar outro encadeamento.  Nesse caso, para evitar a ambiguidade do comportamento do programa, a tarefa ativada entra no estado bloqueado.  Nesse estado, a tarefa ocupa o encadeamento, mas n√£o pode receber controle, mesmo que seu sinal esteja ativado.  Ap√≥s a conclus√£o das tarefas ou ao alterar o sinal de ativa√ß√£o, o expedidor verifica e altera o status das tarefas nos encadeamentos.  Se os threads bloquearem tarefas para as quais o sinal corresponde ao liberado, o primeiro encontrado √© ativado.  Se necess√°rio, o programador pode bloquear e desbloquear tarefas independentemente, com base na l√≥gica necess√°ria do programa. </p><br><p>  <strong>Aguardando</strong> - o estado em que a tarefa est√° ap√≥s a execu√ß√£o do comando <em>Delay</em> .  Nesse estado, a tarefa n√£o recebe controle at√© que o intervalo necess√°rio tenha decorrido.  Na classe <em>Paralela</em> , interrup√ß√µes WDT de 16 ms s√£o usadas para controlar o atraso, o que permite n√£o ocupar temporizadores para as necessidades do sistema.  Caso voc√™ precise de mais estabilidade ou resolu√ß√£o em pequenos intervalos, em vez de <em>Atraso,</em> voc√™ pode usar a ativa√ß√£o por sinais de timer.  Deve-se ter em mente que a precis√£o do atraso ainda ser√° baixa e variar√° no <em>‚Äútempo de resposta do despachante‚Äù - ‚Äúdura√ß√£o m√°xima do intervalo de tempo no sistema + tempo de resposta do despachante‚Äù</em> .  Para tarefas com intervalos de tempo exatos, voc√™ deve usar o modo h√≠brido, no qual o timer, que n√£o √© usado na classe <em>Parallel</em> , funciona independentemente do fluxo de tarefas e processa intervalos no modo de interrup√ß√£o pura. </p><br><p>  Cada tarefa executada em um encadeamento √© um processo isolado.  Isso requer a defini√ß√£o de dois tipos de dados: dados locais de um fluxo, que devem ser vis√≠veis e alterados apenas dentro da estrutura desse fluxo, e dados globais para troca entre fluxos e acesso a recursos compartilhados.  Na estrutura desta implementa√ß√£o, os dados globais s√£o criados por comandos anteriormente considerados no n√≠vel do dispositivo.  Para criar vari√°veis ‚Äã‚Äãde tarefas locais, elas devem ser criadas usando m√©todos da classe de tarefas.  O comportamento da vari√°vel de tarefa local √© o seguinte: quando a tarefa √© interrompida antes de transferir o controle para o distribuidor, todas as vari√°veis ‚Äã‚Äãde registro local s√£o armazenadas na mem√≥ria do fluxo.  Quando o controle √© retornado, as vari√°veis ‚Äã‚Äãde registro local s√£o restauradas antes que o pr√≥ximo comando seja executado. <br>  Uma classe com a interface <em>IHeap</em> associada √† propriedade <em>Heap</em> da classe <em>Parallel</em> √© respons√°vel por armazenar dados locais do fluxo.  A implementa√ß√£o mais simples dessa classe √© <em>StaticHeap</em> , que implementa a aloca√ß√£o est√°tica dos mesmos blocos de mem√≥ria para cada encadeamento.  Caso as tarefas tenham uma grande dispers√£o de acordo com o requisito para a quantidade de dados locais, voc√™ poder√° usar o <em>DynamicHeap</em> , que permite determinar o tamanho da mem√≥ria local individualmente para cada tarefa.  Obviamente, a sobrecarga de trabalhar com a mem√≥ria de fluxo nesse caso ser√° significativamente maior. </p><br><p>  Agora, vamos dar uma olhada na sintaxe da classe usando dois fluxos como exemplo, cada um dos quais alterna independentemente uma sa√≠da de porta separada. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328 { FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>, CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">2</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop();</code> </pre> <br><p>  As principais linhas do programa j√° lhe s√£o familiares.  Neles, determinamos o tipo de controlador e atribu√≠mos o primeiro e o segundo bits da porta B como sa√≠da.  A seguir, vem a inicializa√ß√£o de uma vari√°vel da classe <em>Parallel</em> , onde no segundo par√¢metro determinamos o n√∫mero m√°ximo de threads de execu√ß√£o.  Na pr√≥xima linha, alocamos mem√≥ria para acomodar fluxos vari√°veis ‚Äã‚Äãlocais.  Como temos tarefas iguais, usamos o <em>StaticHeap</em> .  O pr√≥ximo bloco de c√≥digo √© a defini√ß√£o de tarefa.  Nele, definimos duas tarefas quase id√™nticas.  A √∫nica diferen√ßa √© a porta de controle e a quantidade de atraso.  Para trabalhar com objetos de tarefas locais, um ponteiro para a tarefa local <em>tsk</em> √© passado para o <em>bloco de c√≥digo</em> da tarefa.  O texto da tarefa em si √© muito simples: </p><br><ul><li>  um r√≥tulo local √© criado para organizar um ciclo de comuta√ß√£o infinito </li><li>  o status da porta √© revertido </li><li>  o controle √© retornado ao expedidor e a tarefa entra no status de espera pelo n√∫mero especificado de milissegundos </li><li>  O ponteiro de retorno √© definido como o bloco inicial do bloco e o controle √© retornado ao expedidor. <br>  Obviamente, em um exemplo concreto, o √∫ltimo comando pode ser substitu√≠do por um comando normal para ir para o in√≠cio do bloco e fornecido no exemplo apenas com o objetivo de demonstr√°-lo.  Se desejado, o exemplo pode ser facilmente expandido para controlar um grande n√∫mero de conclus√µes, copiando tarefas e aumentando o n√∫mero de threads. </li></ul><br><p>  Uma lista completa dos comandos de interrup√ß√£o de tarefas para transferir o controle ao expedidor √© a seguinte <br>  <strong>AWAIT (sinal)</strong> - o fluxo salva todas as vari√°veis ‚Äã‚Äãna mem√≥ria do fluxo e transfere o controle para o despachante.  Na pr√≥xima vez que o fluxo for ativado, as vari√°veis ‚Äã‚Äãser√£o restauradas e a execu√ß√£o continuar√°, iniciando com a pr√≥xima instru√ß√£o ap√≥s <em>AWAIT</em> .  O comando foi projetado para dividir a tarefa em intervalos de tempo e implementar a m√°quina de estado de acordo com o esquema <em>Sinal ‚Üí Processamento 1 ‚Üí Sinal ‚Üí Processamento 2</em> , etc. </p><br><p>  O comando AWAIT pode ter um sinal como par√¢metro opcional.  Se o par√¢metro estiver vazio, o sinal de ativa√ß√£o √© salvo.  Se for especificado no par√¢metro, todas as chamadas de tarefas subseq√ºentes ser√£o feitas quando o sinal especificado for ativado e a comunica√ß√£o com o sinal anterior for perdida. </p><br><p>  <strong>TaskContinue (etiqueta, sinal)</strong> - o comando finaliza o fluxo e d√° controle ao expedidor sem salvar vari√°veis.  Na pr√≥xima vez que o fluxo for ativado, o controle √© transferido para o <em>r√≥tulo</em> .  O par√¢metro opcional <em>Signal</em> permite substituir o sinal de ativa√ß√£o do fluxo para a pr√≥xima chamada.  Se n√£o especificado, o sinal permanece o mesmo.  Um comando sem especificar um sinal pode ser usado para organizar ciclos em uma √∫nica tarefa, em que cada ciclo √© executado em um intervalo de tempo separado.  Tamb√©m pode ser usado para atribuir uma nova tarefa ao segmento atual depois de concluir o anterior.  A vantagem dessa abordagem em compara√ß√£o com o ciclo <em>Liberando um encadeamento ‚Üí Destacar um fluxo</em> √© um programa mais eficiente.  O uso do <em>TaskContinue</em> elimina a necessidade de o gerente procurar um encadeamento livre no pool e garante erros ao tentar alocar encadeamentos na aus√™ncia de encadeamentos livres. </p><br><p>  <strong>TaskEnd ()</strong> - limpe o fluxo ap√≥s a conclus√£o da tarefa.  A tarefa termina, o encadeamento √© liberado e pode ser usado para atribuir uma nova tarefa com o comando <em>Ativar</em> . </p><br><p>  <strong>Atraso (ms)</strong> - o fluxo, como no caso de usar <em>AWAIT</em> , salva todas as vari√°veis ‚Äã‚Äãna mem√≥ria do fluxo e transfere o controle para o expedidor.  Nesse caso, o valor do atraso em milissegundos √© registrado no cabe√ßalho do fluxo.  No loop do despachante, no caso de um valor diferente de zero no campo de atraso, o fluxo n√£o √© ativado.  A altera√ß√£o dos valores no campo de atraso para todos os fluxos √© realizada interrompendo o temporizador WDT a cada 16 ms.  Quando o valor zero √© atingido, a proibi√ß√£o de execu√ß√£o √© removida e o sinal de ativa√ß√£o do fluxo √© definido.  Somente um valor de byte √∫nico para o atraso √© armazenado no cabe√ßalho, o que fornece uma faixa relativamente estreita de poss√≠veis atrasos; portanto, para implementar atrasos maiores, <em>Delay ()</em> cria um loop interno usando vari√°veis ‚Äã‚Äãde fluxo locais. <br>  A ativa√ß√£o dos comandos no exemplo √© realizada usando os comandos <em>ContinuousActivate</em> e <em>ActivateNext</em> .  Esse √© um tipo especial de ativa√ß√£o de tarefa inicial na inicializa√ß√£o.  No est√°gio de ativa√ß√£o inicial, garantimos que n√£o temos um √∫nico encadeamento ocupado, portanto, o processo de ativa√ß√£o n√£o requer uma pesquisa preliminar de um encadeamento livre para uma tarefa e permite que voc√™ ative as tarefas em sequ√™ncia.  <em>ContinuousActivate</em> ativa a tarefa no segmento zero e retorna um ponteiro para o cabe√ßalho do pr√≥ximo segmento, e a fun√ß√£o <em>ActivateNext</em> usa esse ponteiro para ativar as seguintes tarefas nos segmentos sequenciais. </p><br><p>  Como sinal de ativa√ß√£o, o exemplo usa o sinal <em>AlwaysOn</em> .  Este √© um dos sinais do sistema.  Sua finalidade significa que a tarefa sempre ser√° executada, pois esse √© o √∫nico sinal que √© sempre ativado e n√£o √© redefinido pelo uso. </p><br><p>  O exemplo termina com uma chamada de <em>loop</em> .  Essa fun√ß√£o inicia o ciclo do expedidor, portanto, este comando deve ser o √∫ltimo no c√≥digo. </p><br><p>  Considere outro exemplo em que o uso da biblioteca pode simplificar significativamente a estrutura do c√≥digo.  Que seja um dispositivo de controle condicional que registra um sinal anal√≥gico e o envia na forma de um c√≥digo HEX para o terminal. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cData = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outDigit = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chex = Const.String(<span class="hljs-string"><span class="hljs-string">"0123456789ABCDEF"</span></span>); m.ADC.Clock = eADCPrescaler.S64; m.ADC.ADCReserved = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; m.ADC.Source = eASource.ADC0; m.Usart.Baudrate = <span class="hljs-number"><span class="hljs-number">9600</span></span>; m.Usart.FrameFormat = eUartFrame.U8N1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ADS = os.AddSignal(m.ADC.Handler, () =&gt; m.ADC.Data(cData)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trm = os.AddSignal(m.Usart.TXC_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> starts = os.AddLocker(); os.PrepareSignals(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t0 = os.CreateTask((tsk) =&gt; { m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { m.ADC.ConvertAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">500</span></span>); }); }, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mref = m.ROMPTR(); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); mref.Load(chex); m.TempL.Load(cData.High); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); mref.Load(chex); m.TempL.Load(cData.Low); m.TempL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; mref += m.TempL; mref.MLoad(m.TempL); m.TempL.MStore(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); starts.Set(); tsk.TaskContinue(loop); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); trm.Clear(); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'0'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(trm); m.TempL.Load(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">0</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">1</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">2</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.MLoad(outDigit[<span class="hljs-number"><span class="hljs-number">3</span></span>]); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">13</span></span>); m.Usart.Transmit(m.TempL); tsk.AWAIT(); m.TempL.Load(<span class="hljs-number"><span class="hljs-number">10</span></span>); m.Usart.Transmit(m.TempL); tsk.TaskContinue(loop, starts); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = os.ContinuousActivate(os.AlwaysOn, t0); os.ActivateNext(p, ADS, t1); os.ActivateNext(p, starts, t2); m.ADC.Activate(); m.Usart.Activate(); m.EnableInterrupt(); os.Loop();</code> </pre> <br><p>  Isso n√£o quer dizer que vimos muitas coisas novas aqui, mas voc√™ pode ver algo interessante neste c√≥digo. </p><br><p>  Neste exemplo, o ADC (conversor anal√≥gico-digital) √© mencionado pela primeira vez.  Este dispositivo perif√©rico foi projetado para converter a tens√£o do sinal de entrada em um c√≥digo digital.  O ciclo de convers√£o √© iniciado pela fun√ß√£o <em>ConvertAsync</em> , que inicia o processo apenas sem aguardar o resultado.  Quando a convers√£o estiver conclu√≠da, o ADC gera uma interrup√ß√£o que ativa o sinal <em>adcSig</em> .  Preste aten√ß√£o na defini√ß√£o do sinal <em>adcSig</em> .  Al√©m do ponteiro de interrup√ß√£o, ele tamb√©m cont√©m um bloco de c√≥digo para armazenar valores do registro de dados ADC.  Todo o c√≥digo que √© executado preferencialmente imediatamente ap√≥s a interrup√ß√£o (por exemplo, leitura de dados dos registros do dispositivo) deve estar localizado neste local. <br>  A tarefa de <em>convers√£o</em> √© converter um c√≥digo de tens√£o bin√°rio em uma representa√ß√£o HEX de quatro caracteres para o nosso terminal condicional.  Aqui podemos observar o uso de fun√ß√µes para descrever fragmentos repetidos para reduzir o tamanho do c√≥digo-fonte e o uso de uma string constante para convers√£o de dados. </p><br><p>  O problema de <em>transmiss√£o</em> √© interessante do ponto de vista da implementa√ß√£o da sa√≠da formatada de uma string na qual a sa√≠da de dados est√°ticos e din√¢micos √© combinada.  O mecanismo em si n√£o pode ser considerado ideal; √© uma demonstra√ß√£o das possibilidades de gerenciamento de manipuladores.  Aqui voc√™ tamb√©m pode prestar aten√ß√£o √† redefini√ß√£o do sinal de ativa√ß√£o durante a execu√ß√£o, que altera o sinal de ativa√ß√£o de <em>ConvS</em> para <em>TxS</em> e vice-versa. </p><br><p>  Para uma melhor compreens√£o, descrevemos em palavras o algoritmo do programa. </p><br><p>  No estado inicial, lan√ßamos tr√™s tarefas.  Dois deles t√™m sinais inativos, uma vez que o sinal para a tarefa de <em>convers√£o (adcSig) √©</em> ativado no final do ciclo de leitura do sinal anal√≥gico, e o <em>ConvS</em> para a tarefa de <em>transmiss√£o</em> √© ativado por um c√≥digo que ainda n√£o foi executado.  Como resultado, a primeira tarefa a ser lan√ßada ap√≥s o lan√ßamento ser√° sempre a medi√ß√£o.  O c√≥digo para esta tarefa inicia o ciclo de convers√£o do ADC, ap√≥s o qual a tarefa de 500 ms entra no ciclo de espera.  No final do ciclo de convers√£o, o sinalizador <em>adcSig</em> √© <em>ativado</em> , o que aciona a tarefa de <em>convers√£o</em> .  Nesta tarefa, um ciclo de convers√£o dos dados recebidos em uma sequ√™ncia √© implementado.  Antes de sair da tarefa, ativamos o sinalizador <em>ConvS</em> , deixando claro que temos novos dados para enviar ao terminal.  O comando exit redefine o ponto de retorno para o in√≠cio da tarefa e d√° controle ao expedidor.  O <em>conjunto de</em> sinalizadores <em>ConvS</em> permite transferir o controle para a tarefa de <em>transmiss√£o</em> .  Ap√≥s transmitir o primeiro byte da sequ√™ncia, o sinal de ativa√ß√£o na tarefa muda para <em>TxS</em> .  Como resultado, ap√≥s a transfer√™ncia do byte ser conclu√≠da, a tarefa de transmiss√£o ser√° chamada novamente, o que levar√° √† transfer√™ncia do pr√≥ximo byte.  Ap√≥s o √∫ltimo byte da sequ√™ncia ser transmitido, a tarefa retorna o <em>sinal de</em> ativa√ß√£o do <em>ConvS</em> e redefine o ponto de retorno para o in√≠cio da tarefa.  O ciclo est√° completo.  O pr√≥ximo ciclo come√ßar√° quando a tarefa de medi√ß√£o concluir a espera e ativar o pr√≥ximo ciclo de medi√ß√£o. </p><br><p>  Em quase todos os sistemas multitarefa, existe o conceito de filas para a intera√ß√£o entre threads.  J√° descobrimos que, como alternar entre tarefas neste sistema √© um processo completamente controlado, √© poss√≠vel usar vari√°veis ‚Äã‚Äãglobais para trocar dados entre tarefas.  No entanto, h√° v√°rias tarefas em que o uso de filas √© justificado.  Portanto, n√£o deixaremos de lado este t√≥pico e veremos como ele √© implementado na biblioteca. </p><br><p>  Para implementar uma fila em um programa, √© melhor usar a classe <em>RingBuff</em> .  A classe, como o nome indica, implementa um buffer de anel com comandos de grava√ß√£o e busca.  A leitura e grava√ß√£o de dados s√£o realizadas pelos comandos de <em>leitura</em> e <em>grava√ß√£o</em> .  Os comandos de leitura e grava√ß√£o n√£o t√™m par√¢metros.  O buffer usa a vari√°vel de registro especificada no construtor como a fonte / receptor de dados.  O acesso a essa vari√°vel √© feito atrav√©s do par√¢metro <em>IOReg</em> class.  O status do buffer √© determinado pelos dois sinalizadores <em>Ovf</em> e <em>Empty</em> , que ajudam a determinar o estado de estouro durante a grava√ß√£o e estouro durante a leitura.  Al√©m disso, a classe tem a capacidade de determinar o c√≥digo que √© executado nos eventos de estouro / estouro.  <em>RingBuff</em> n√£o tem depend√™ncias na classe <em>Parallel</em> e pode ser usado separadamente.  A limita√ß√£o ao trabalhar com a classe √© a capacidade permitida, que deve ser um m√∫ltiplo da pot√™ncia de dois (8.16.32 etc.) por motivos de otimiza√ß√£o de c√≥digo. </p><br><p>  Um exemplo de trabalho com a classe √© dado abaixo. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//     16     io. var bf = new RingBuff(m, 16, io) { //    OnOverflow = () =&gt; { AVRASM.Comment("   "); }, OnEmpty = () =&gt; { AVRASM.Comment("   "); } }; var cntr = m.REG(); cntr.Load(16); //       m.LOOP(cntr, (r, l) =&gt; { cntr--; m.IFNOTEMPTY(l); },(r)=&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment("‚Äù)}; bf.IOReg.Load(cntr); //      bf.Write(); //    }); //     m.LOOP(cntr, (r, l) =&gt; { m.GO(l); }, (r) =&gt; { //         //m.IF(bf.Ovf,()=&gt;{AVRASM.Comment(" ‚Äù)}; bf.Read(); //       IOReg //    });</span></span></code> </pre> <br><p>  Esta parte conclui a vis√£o geral dos recursos da biblioteca.  Infelizmente, ainda havia v√°rios aspectos relacionados √†s capacidades da biblioteca, que nem sequer foram mencionados.  No futuro, no caso de interesse no projeto, os artigos est√£o planejados para resolver problemas espec√≠ficos usando a biblioteca e uma descri√ß√£o mais detalhada de problemas complexos que requerem uma publica√ß√£o separada. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt464651/">https://habr.com/ru/post/pt464651/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt464641/index.html">Como configurar o PVS-Studio no Travis CI usando o exemplo do emulador de console de jogos PSP</a></li>
<li><a href="../pt464643/index.html">Nem uma √∫nica varredura ou como criar um processo de gerenciamento de vulnerabilidades em 9 etapas</a></li>
<li><a href="../pt464645/index.html">Como configurar o PVS-Studio no Travis CI usando o emulador de console de jogos PSP como exemplo</a></li>
<li><a href="../pt464647/index.html">Jornal Harry Potter</a></li>
<li><a href="../pt464649/index.html">Sistema de colabora√ß√£o de documentos para Zimbra Open-Source Edition</a></li>
<li><a href="../pt464655/index.html">Como os sal√°rios e a popularidade das linguagens de programa√ß√£o mudaram nos √∫ltimos 2 anos</a></li>
<li><a href="../pt464657/index.html">Cornija el√©trica para engenharia reversa AM82TV</a></li>
<li><a href="../pt464659/index.html">Seguran√ßa de aplicativos ou Como incorporar seguran√ßa no desenvolvimento personalizado. Experi√™ncia pessoal na AGIMA</a></li>
<li><a href="../pt464661/index.html">A quem confiar o projeto de instala√ß√µes t√©cnicas de reequipamento e reconstru√ß√£o</a></li>
<li><a href="../pt464665/index.html">Particionando no SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>