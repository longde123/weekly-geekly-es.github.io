<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª üé¢ üçç [DotNetBook] Ausnahmeereignisse und wie Sie StackOverflow und ExecutionEngineException von Grund auf neu erstellen üîÇ üë©üèΩ‚Äç‚úàÔ∏è ü§úüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ausnahmeereignisse 


 Im Allgemeinen kennen wir die Ausnahmen, die in unseren Programmen auftreten, nicht immer, da wir fast immer etwas verwenden, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Ausnahmeereignisse und wie Sie StackOverflow und ExecutionEngineException von Grund auf neu erstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/419929/"><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left"><br><h2 id="sobytiya-ob-isklyuchitelnyh-situaciyah">  Ausnahmeereignisse </h2><br><p> Im Allgemeinen kennen wir die Ausnahmen, die in unseren Programmen auftreten, nicht immer, da wir fast immer etwas verwenden, das von anderen Personen geschrieben wurde und das sich in anderen Subsystemen und Bibliotheken befindet.  Es kann nicht nur eine Vielzahl von Situationen in Ihrem eigenen Code geben, sondern auch im Code anderer Bibliotheken, und es gibt auch viele Probleme, die mit der Ausf√ºhrung von Code in isolierten Dom√§nen verbunden sind.  Und gerade in diesem Fall w√§re es √§u√üerst n√ºtzlich, Daten √ºber den Betrieb von isoliertem Code empfangen zu k√∂nnen.  Schlie√ülich kann eine Situation durchaus real sein, wenn Code von Drittanbietern ausnahmslos alle Fehler abf√§ngt und ihren <code>fault</code> Block √ºbert√∂nt: </p><br><pre> <code class="plaintext hljs">try { // ... } catch { // do nothing, just to make code call more safe }</code> </pre> <br><p>  In einer solchen Situation kann sich herausstellen, dass die Codeausf√ºhrung nicht mehr so ‚Äã‚Äãsicher ist, wie es aussieht, aber wir haben keine Meldungen √ºber Probleme.  Die zweite Option ist, wenn die Anwendung einige, sogar rechtliche Ausnahmen unterdr√ºckt.  Und das Ergebnis - die folgende Ausnahme an einer zuf√§lligen Stelle f√ºhrt dazu, dass die Anwendung in Zukunft aufgrund eines scheinbar zuf√§lligen Fehlers abst√ºrzt.  Hier m√∂chte ich eine Vorstellung davon haben, was der Hintergrund dieses Fehlers war.  Wie verliefen die Ereignisse zu dieser Situation?  Eine M√∂glichkeit, dies zu erm√∂glichen, besteht darin, zus√§tzliche Ereignisse zu verwenden, die sich auf Ausnahmesituationen beziehen: <code>AppDomain.FirstChanceException</code> und <code>AppDomain.UnhandledException</code> . </p><br><blockquote><h3>  Hinweis </h3><br>  Das auf Habr√© ver√∂ffentlichte Kapitel ist nicht aktualisiert und wahrscheinlich bereits etwas veraltet.  Wenden Sie sich daher f√ºr einen neueren Text dem Original zu: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub, Inhaltsverzeichnis</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="">GitHub, Kapitel</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 B√ºcher, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  Wenn Sie "eine Ausnahme ausl√∂sen", wird die √ºbliche Methode eines internen <code>Throw</code> Subsystems aufgerufen, das in sich die folgenden Operationen ausf√ºhrt: </p><br><ul><li>  <code>AppDomain.FirstChanceException</code> </li><li>  Sucht nach passenden Filtern in der Handlerkette </li><li>  Bewirkt, dass der Handler den Stapel auf den gew√ºnschten Frame vorrollt. </li><li>  Wenn kein Handler gefunden wurde, wird eine <code>AppDomain.UnhandledException</code> , die den Thread zum Absturz <code>AppDomain.UnhandledException</code> , in dem die Ausnahme aufgetreten ist. </li></ul><br><p>  Man sollte sofort eine Reservierung vornehmen, wenn man eine Frage beantwortet, die viele K√∂pfe qu√§lt: Ist es m√∂glich, die Ausnahme, die in dem unkontrollierten Code aufgetreten ist, der in der isolierten Dom√§ne ausgef√ºhrt wird, irgendwie abzubrechen, ohne dadurch den Thread zu unterbrechen, in den diese Ausnahme ausgel√∂st wurde?  Die Antwort ist kurz und einfach: Nein.  Wenn eine Ausnahme nicht f√ºr alle aufgerufenen Methoden erfasst wird, kann sie grunds√§tzlich nicht behandelt werden.  Andernfalls tritt eine seltsame Situation auf: Wenn wir eine <code>AppDomain.FirstChanceException</code> um eine <code>AppDomain.FirstChanceException</code> (eine Art synthetischen <code>catch</code> ) zu behandeln, auf welchen Frame sollte der Thread-Stapel dann zur√ºckgesetzt werden?  Wie kann ich dies als Teil der .NET CLR-Regeln festlegen?  Auf keinen Fall.  Es ist einfach nicht m√∂glich.  Das einzige, was wir tun k√∂nnen, ist, die erhaltenen Informationen f√ºr zuk√ºnftige Forschungen aufzuzeichnen. </p><br><p>  Das zweite, <code>AppDomain</code> an Land sprechen sollte, ist, warum diese Ereignisse nicht bei <code>Thread</code> , sondern bei <code>AppDomain</code> .  Wenn Sie der Logik folgen, entstehen schlie√ülich Ausnahmen, wo?  Im Ablauf der Befehlsausf√ºhrung.  Das hei√üt,  eigentlich <code>Thread</code> .  Warum hat die Domain Probleme?  Die Antwort ist sehr einfach: F√ºr welche Situationen wurden <code>AppDomain.FirstChanceException</code> und <code>AppDomain.UnhandledException</code> ?  Unter anderem - um Sandboxen f√ºr Plugins zu erstellen.  Das hei√üt,  f√ºr Situationen, in denen eine bestimmte <code>AppDomain</code> f√ºr PartialTrust konfiguriert ist.  Innerhalb dieser AppDomain kann alles passieren: Dort k√∂nnen jederzeit Threads erstellt oder vorhandene Threads aus ThreadPool verwendet werden.  Dann stellt sich heraus, dass wir au√üerhalb dieses Prozesses (wir haben diesen Code nicht geschrieben) die Ereignisse interner Flows nicht abonnieren k√∂nnen.  Nur weil wir keine Ahnung haben, welche Fl√ºsse dort erzeugt wurden.  Wir haben jedoch garantiert eine <code>AppDomain</code> , die die Sandbox und den Link, zu dem wir haben, organisiert. </p><br><p>  Tats√§chlich werden uns also zwei regionale Ereignisse zur Verf√ºgung gestellt: etwas ist passiert, das nicht angenommen wurde ( <code>FirstChanceExecption</code> ) und "alles ist schlecht", niemand hat die Ausnahme behandelt: Es wurde nicht bereitgestellt.  Daher ist der Ablauf der Befehlsausf√ºhrung nicht sinnvoll und es wird ( <code>Thread</code> ) ausgeliefert. </p><br><p>  Was kann durch diese Ereignisse erreicht werden und warum ist es schlecht, dass Entwickler diese Ereignisse umgehen? </p><br><h3 id="appdomainfirstchanceexception">  AppDomain.FirstChanceException </h3><br><p>  Dieses Ereignis ist von Natur aus rein informativer Natur und kann nicht ‚Äûverarbeitet‚Äú werden.  Seine Aufgabe ist es, Sie zu benachrichtigen, dass innerhalb dieser Dom√§ne eine Ausnahme aufgetreten ist, und sie wird nach der Verarbeitung des Ereignisses vom Anwendungscode verarbeitet.  Die Ausf√ºhrung enth√§lt einige Funktionen, die beim Entwurf des Prozessors ber√ºcksichtigt werden m√ºssen. </p><br><p>  Aber schauen wir uns zuerst ein einfaches synthetisches Beispiel f√ºr seine Verarbeitung an: </p><br><pre> <code class="plaintext hljs">void Main() { var counter = 0; AppDomain.CurrentDomain.FirstChanceException += (_, args) =&gt; { Console.WriteLine(args.Exception.Message); if(++counter == 1) { throw new ArgumentOutOfRangeException(); } }; throw new Exception("Hello!"); }</code> </pre> <br><p>  Was ist an diesem Code bemerkenswert?  Wenn ein Code eine Ausnahme ausl√∂st, wird er zuerst in der Konsole protokolliert.  Das hei√üt,  Selbst wenn Sie eine Ausnahme vergessen oder sich nicht vorstellen k√∂nnen, wird sie dennoch in dem von Ihnen organisierten Ereignisprotokoll angezeigt.  Die zweite ist eine etwas seltsame Bedingung f√ºr das Ausl√∂sen einer internen Ausnahme.  Die Sache ist, dass Sie im <code>FirstChanceException</code> Handler nicht einfach eine weitere Ausnahme <code>FirstChanceException</code> k√∂nnen.  Vielmehr auch dies: Im FirstChanceException-Handler k√∂nnen Sie zumindest keine Ausnahme ausl√∂sen.  In diesem Fall gibt es zwei m√∂gliche Ereignisse.  Wenn es keine <code>if(++counter == 1)</code> Bedingung <code>if(++counter == 1)</code> g√§be, w√ºrden wir zun√§chst eine unendliche <code>FirstChanceException</code> f√ºr eine <code>FirstChanceException</code> <code>ArgumentOutOfRangeException</code> .  Was bedeutet das?  Dies bedeutet, dass wir zu einem bestimmten Zeitpunkt eine <code>StackOverflowException</code> : <code>throw new Exception("Hello!")</code> <code>FirstChanceException</code> CLR Throw-Methode aus, die <code>FirstChanceException</code> , die <code>Throw</code> bereits f√ºr <code>ArgumentOutOfRangeException</code> ausl√∂st und dann rekursiv.  Die zweite Option - wir haben uns durch die Tiefe der Rekursion unter Verwendung der <code>counter</code> verteidigt.  Das hei√üt,  In diesem Fall wird eine Ausnahme nur einmal ausgel√∂st.  Das Ergebnis ist mehr als unerwartet: Wir erhalten eine Ausnahme, die tats√§chlich innerhalb der <code>Throw</code> Anweisung funktioniert.  Und was ist f√ºr diese Art von Fehler am besten geeignet?  Laut ECMA-335 muss eine <code>ExecutionEngineException</code> ausgel√∂st werden, wenn eine Anweisung in eine Ausnahme ausgel√∂st wurde!  Wir sind jedoch nicht in der Lage, mit dieser Ausnahmesituation umzugehen.  Dies f√ºhrt zu einem vollst√§ndigen Absturz der Anwendung.  Welche sicheren Verarbeitungsoptionen haben wir? </p><br><p>  Das erste, was <code>FirstChanceException</code> in den Sinn kommt, ist das Setzen eines <code>try-catch</code> Blocks f√ºr den gesamten Code des <code>FirstChanceException</code> : </p><br><pre> <code class="plaintext hljs">void Main() { var fceStarted = false; var sync = new object(); EventHandler&lt;FirstChanceExceptionEventArgs&gt; handler; handler = new EventHandler&lt;FirstChanceExceptionEventArgs&gt;((_, args) =&gt; { lock (sync) { if (fceStarted) { //     - ,        -      , //   try  . Console.WriteLine($"FirstChanceException inside FirstChanceException ({args.Exception.GetType().FullName})"); return; } fceStarted = true; try { //     . ,   Console.WriteLine(args.Exception.Message); throw new ArgumentOutOfRangeException(); } catch (Exception exception) { //       Console.WriteLine("Success"); } finally { fceStarted = false; } } }); AppDomain.CurrentDomain.FirstChanceException += handler; try { throw new Exception("Hello!"); } finally { AppDomain.CurrentDomain.FirstChanceException -= handler; } } OUTPUT: Hello! Specified argument was out of the range of valid values. FirstChanceException inside FirstChanceException (System.ArgumentOutOfRangeException) Success !Exception: Hello!</code> </pre> <br><p>  Das hei√üt,  Einerseits haben wir den Code f√ºr die Behandlung des <code>FirstChanceException</code> Ereignisses und andererseits haben wir zus√§tzlichen Code f√ºr die Behandlung von Ausnahmen in der <code>FirstChanceException</code> selbst.  Die Protokollierungstechniken f√ºr beide Situationen sollten jedoch unterschiedlich sein.  Wenn die Ereignisverarbeitungsprotokollierung beliebig verlaufen kann, sollte die <code>FirstChanceException</code> der <code>FirstChanceException</code> Verarbeitungslogik grunds√§tzlich ausnahmslos erfolgen.  Das zweite, was Sie wahrscheinlich bemerkt haben, ist die Synchronisation zwischen Threads.  Dies kann die Frage aufwerfen: Warum ist es hier, wenn in einem Thread eine Ausnahme ausgel√∂st wird, was bedeutet, dass <code>FirstChanceException</code> sein sollte.  Es ist jedoch nicht alles so fr√∂hlich.  <code>FirstChanceException</code> wir bei AppDomain.  Dies bedeutet, dass es f√ºr jeden Thread auftritt, der in einer bestimmten Dom√§ne gestartet wurde.  Das hei√üt,  Wenn wir eine Dom√§ne haben, in der mehrere Threads gestartet werden, kann <code>FirstChanceException</code> parallel geschaltet werden.  Und das bedeutet, dass wir uns irgendwie durch Synchronisation sch√ºtzen m√ºssen: zum Beispiel durch <code>lock</code> . </p><br><p>  Die zweite M√∂glichkeit besteht darin, die Verarbeitung auf einen benachbarten Thread umzuleiten, der zu einer anderen Anwendungsdom√§ne geh√∂rt.  Es ist jedoch erw√§hnenswert, dass wir bei einer solchen Implementierung eine dedizierte Dom√§ne speziell f√ºr diese Aufgabe erstellen m√ºssen, damit dies nicht funktioniert, damit andere funktionierende Flows diese Dom√§ne platzieren k√∂nnen: </p><br><pre> <code class="plaintext hljs">static void Main() { using (ApplicationLogger.Go(AppDomain.CurrentDomain)) { throw new Exception("Hello!"); } } public class ApplicationLogger : MarshalByRefObject { ConcurrentQueue&lt;Exception&gt; queue = new ConcurrentQueue&lt;Exception&gt;(); CancellationTokenSource cancellation; ManualResetEvent @event; public void LogFCE(Exception message) { queue.Enqueue(message); } private void StartThread() { cancellation = new CancellationTokenSource(); @event = new ManualResetEvent(false); var thread = new Thread(() =&gt; { while (!cancellation.IsCancellationRequested) { if (queue.TryDequeue(out var exception)) { Console.WriteLine(exception.Message); } Thread.Yield(); } @event.Set(); }); thread.Start(); } private void StopAndWait() { cancellation.Cancel(); @event.WaitOne(); } public static IDisposable Go(AppDomain observable) { var dom = AppDomain.CreateDomain("ApplicationLogger", null, new AppDomainSetup { ApplicationBase = AppDomain.CurrentDomain.BaseDirectory, }); var proxy = (ApplicationLogger)dom.CreateInstanceAndUnwrap(typeof(ApplicationLogger).Assembly.FullName, typeof(ApplicationLogger).FullName); proxy.StartThread(); var subscription = new EventHandler&lt;FirstChanceExceptionEventArgs&gt;((_, args) =&gt; { proxy.LogFCE(args.Exception); }); observable.FirstChanceException += subscription; return new Subscription(() =&gt; { observable.FirstChanceException -= subscription; proxy.StopAndWait(); }); } private class Subscription : IDisposable { Action act; public Subscription (Action act) { this.act = act; } public void Dispose() { act(); } } }</code> </pre> <br><p>  In diesem Fall ist die Behandlung von <code>FirstChanceException</code> so sicher wie m√∂glich: im benachbarten Thread, der zur benachbarten Dom√§ne geh√∂rt.  In diesem Fall k√∂nnen Fehler bei der Verarbeitung einer Nachricht die Anwendungsworkflows nicht beeintr√§chtigen.  Au√üerdem k√∂nnen Sie die UnhandledException der Nachrichtenprotokollierungsdom√§ne separat abh√∂ren: Schwerwiegende Fehler w√§hrend der Protokollierung f√ºhren nicht zum Herunterfahren der gesamten Anwendung. </p><br><h3 id="appdomainunhandledexception">  AppDomain.UnhandledException </h3><br><p>  Die zweite Nachricht, die wir abfangen k√∂nnen und die sich mit der Ausnahmebehandlung befasst, ist <code>AppDomain.UnhandledException</code> .  Diese Nachricht ist eine sehr schlechte Nachricht f√ºr uns, da es bedeutet, dass es niemanden gab, der einen Weg finden konnte, den Fehler in einem bestimmten Thread zu behandeln.  Wenn eine solche Situation eingetreten ist, k√∂nnen wir nur die Konsequenzen eines solchen Fehlers "kl√§ren".  Das hei√üt,  in irgendeiner Weise, um Ressourcen zu bereinigen, die nur zu diesem Stream geh√∂ren, falls welche erstellt wurden.  Eine noch bessere Situation ist es jedoch, Ausnahmen an der Wurzel der Threads zu behandeln, ohne den Thread zu blockieren.  Das hei√üt,  im Wesentlichen <code>try-catch</code> .  Versuchen wir, die Angemessenheit dieses Verhaltens zu pr√ºfen. </p><br><p>  Angenommen, wir haben eine Bibliothek, die Threads erstellen und eine Art Logik in diesen Threads implementieren muss.  Wir als Benutzer dieser Bibliothek sind nur daran interessiert, API-Aufrufe zu garantieren und Fehlermeldungen zu erhalten.  Wenn die Bibliothek Streams zum Absturz bringt, ohne dar√ºber informiert zu werden, kann uns dies nicht viel helfen.  Dar√ºber hinaus f√ºhrt der Zusammenbruch des Streams zu einer <code>AppDomain.UnhandledException</code> Nachricht, in der keine Informationen dar√ºber enthalten sind, welcher bestimmte Stream auf seiner Seite liegt.  Wenn wir √ºber unseren Code sprechen, ist es auch unwahrscheinlich, dass ein abst√ºrzender Stream f√ºr uns n√ºtzlich ist.  Auf jeden Fall habe ich die Notwendigkeit daf√ºr nicht erf√ºllt.  Unsere Aufgabe ist es, Fehler korrekt zu verarbeiten, Informationen √ºber ihr Auftreten an das Fehlerprotokoll zu senden und den Ablauf korrekt zu beenden.  Das hei√üt,  Schlie√üen Sie im Wesentlichen die Methode ein, mit der der Thread in <code>try-catch</code> beginnt: </p><br><pre> <code class="plaintext hljs"> ThreadPool.QueueUserWorkitem(_ =&gt; { using(Disposables aggregator = ...){ try { // do work here, plus: aggregator.Add(subscriptions); aggregator.Add(dependantResources); } catch (Exception ex) { logger.Error(ex, "Unhandled exception"); } } });</code> </pre> <br><p>  In einem solchen Schema bekommen wir, was wir brauchen: Einerseits werden wir den Strom nicht brechen.  Bereinigen Sie andererseits lokale Ressourcen korrekt, wenn sie erstellt wurden.  Nun, im Anhang - wir organisieren die Protokollierung des empfangenen Fehlers.  Aber warte, sagst du?  Irgendwie haben Sie das Problem des Ereignisses <code>AppDomain.UnhandledException</code> .  Ist es wirklich √ºberhaupt nicht n√∂tig?  Es ist notwendig.  Aber nur um zu informieren, dass wir vergessen haben, einige Threads mit der notwendigen Logik in <code>try-catch</code> zu verpacken.  Mit allem: mit Protokollierung und Reinigung von Ressourcen.  Andernfalls ist es v√∂llig falsch: Nehmen Sie alle Ausnahmen und l√∂schen Sie sie, als ob sie √ºberhaupt nicht da w√§ren. </p><br><blockquote><h3>  Link zum ganzen Buch </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 B√ºcher, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419929/">https://habr.com/ru/post/de419929/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419919/index.html">Versionskontrolle in SQL Server</a></li>
<li><a href="../de419921/index.html">So verwerfen Sie 10 Millionen Pakete pro Sekunde</a></li>
<li><a href="../de419923/index.html">Meine Zeitarbeit, Motherboard-Uhren</a></li>
<li><a href="../de419925/index.html">Versionskontrolle einzelner Dateien mit dem GitHub Gist</a></li>
<li><a href="../de419927/index.html">[DotNetBook] Ausnahmen: Typ Systemarchitektur</a></li>
<li><a href="../de419931/index.html">[DotNetBook] Zeit f√ºr unterhaltsame Geschichten: au√üergew√∂hnlich au√üergew√∂hnliche Situationen</a></li>
<li><a href="../de419933/index.html">So f√ºhren Sie Benutzersuchen in Github mit Angular durch</a></li>
<li><a href="../de419935/index.html">Genau einmal ist NICHT genau dasselbe: Artikelanalyse</a></li>
<li><a href="../de419939/index.html">Wie ich die Navigation in React Native nicht so schrecklich gemacht habe</a></li>
<li><a href="../de419941/index.html">Audiomania Office Fototour: Teil Eins</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>