<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘  â™’ï¸ â˜ï¸ HL 2018. Ringkasan laporan â€œBuat kata sandi hebat lagi! Cara mengalahkan brute force dan meninggalkan peretas tanpa apa-apa â€ ğŸ¤¶ğŸ¿ âœğŸ¼ ğŸ‘¨ğŸ½â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Akhmadeev Rinat, saya Sr. Pengembang PHP. 


 Saya berikan kepada Anda ringkasan laporan Buat kata sandi menjadi luar biasa lagi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HL 2018. Ringkasan laporan â€œBuat kata sandi hebat lagi! Cara mengalahkan brute force dan meninggalkan peretas tanpa apa-apa â€</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434708/"><p><img src="https://habrastorage.org/webt/ey/xs/qh/eyxsqh1i0z7s2_fexslxgbdi-fy.png" alt="Kata sandi seperti pakaian dalam"></p><br><p>  Halo, Habr!  Nama saya Akhmadeev Rinat, saya Sr.  Pengembang PHP. </p><br><p>  Saya berikan kepada Anda ringkasan laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buat kata sandi menjadi luar biasa lagi!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara mengalahkan bruteforce dan meninggalkan peretas tanpa apa pun</a> dari Alexey Ermishkin dari Virgil Security dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++ 2018</a> . </p><br><p>  Ketika saya pergi ke laporan, saya pesimis.  Tapi sejak itu  Karena ini adalah Virgil Security, saya masih memutuskan untuk pergi.  Pada awalnya, laporan itu tampaknya benar-benar milik kapten, dan saya bahkan mulai kehilangan minat, tetapi kemudian, ternyata, saya bahkan menemukan beberapa pendekatan perlindungan kata sandi baru yang berbeda dari hashing garam biasa. </p><br><p>  Laporan ini membahas cara untuk melindungi kata sandi dari hash ke pendekatan yang lebih modern, seperti kata sandi Facebook Bawang, Sphinx dan Pythia.  Pada akhirnya, Layanan Enkripsi Hardened Enkripsi Sederhana (PHE) baru diperkenalkan. </p><br><p>  Saya sangat menyukai laporan itu sehingga saya menyiapkan ringkasan.  Saya merekomendasikan semua orang untuk membiasakan diri. </p><a name="habracut"></a><br><p>  Alexey Ermishkin membagikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slide</a> dan laporan video dalam komentar: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y1MQyl13ssc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="konspekt">  Abstrak </h2><br><h3 id="vstuplenie">  Entri </h3><br><p><img src="https://habrastorage.org/webt/wd/sg/tu/wdsgtu8tz1yjoswesm2sjy7gs0k.png" alt="Slide 0. Buat kata sandi menjadi hebat lagi"></p><br><p>  Halo semuanya, selamat pagi semuanya!  Saya senang melihat Anda semua di Konferensi Highload.  Nama saya Alexey Ermishkin, saya bekerja untuk Virgil Security. </p><br><p><img src="https://habrastorage.org/webt/p_/dm/2o/p_dm2o99hyouir1mw0qn1nq_k0s.png" alt="Keamanan perawan"></p><br><p>  Kami terlibat dalam pengembangan berbagai produk kriptografi untuk pengembang individu dan bisnis.  Kami fokus pada solusi end-to-end, ini adalah saat Anda tidak perlu mempercayai layanan untuk melakukan tindakan seperti transfer data, otentikasi, dll.  SDK kami terbuka dan dapat diakses oleh semua. </p><br><p><img src="https://habrastorage.org/webt/mt/_q/ey/mt_qeyv-o-f8tcltewqjz5bdxze.png" alt="Geser 7. Kinerja, kenyamanan, keamanan"></p><br><p>  Kata sandi telah lama digunakan sebagai sarana otentikasi, sebagai cara untuk mencapai suatu tempat.  Itu jauh sebelum komputer muncul.  Tetapi dengan munculnya komputer, dengan munculnya sistem IT, orang tidak meninggalkan kebiasaan menggunakan kata sandi.  Ini menjadi masalah yang sangat besar bagi pengembang, karena mereka mengalami masalah bagaimana membuat sistem yang nyaman dan cepat dan aman.  Sangat sering, ketika beberapa dari aspek-aspek ini berusaha untuk melakukannya dengan baik, yang ketiga tidak terlalu baik.  Jika Anda membuat sistem ini produktif dan aman, maka itu bisa merepotkan, dll. </p><br><p><img src="https://habrastorage.org/webt/yf/vy/8n/yfvy8nslfegffzdm8ldboycqpvc.png" alt="Slide 8. Dari apa kita melindungi diri kita?"></p><br><p>  Jadi, apa yang akan kita bicarakan hari ini? </p><br><p>  Saya akan berbicara tentang perlindungan terhadap serangan offline.  Ketika kata sandi masuk ke dalam basis data Anda, maka pengguna tidak mengontrolnya.  Jika basis data Anda diretas, ia bocor di suatu tempat, lalu setelah itu peretas dapat melakukan apa saja dengan itu.  Bahkan jika Anda entah bagaimana melindungi kata sandi, mereka dapat mulai memilahnya dan mereka tidak perlu berinteraksi dengan siapa pun untuk ini, mereka sudah memiliki segalanya untuk ini.  Selain itu, pengguna tidak berhenti menggunakan kata sandi yang lemah.  Kebijakan kata sandi tentu saja merupakan hal yang bermanfaat, tetapi juga tidak selalu nyaman, mis.  bahkan ketika orang-orang memasukkannya sebagai kata sandi yang kuat, kebijakan itu masih mengatakan Anda perlu menambahkan huruf atau angka, maka bagi mereka itu tidak nyaman.  Jelas juga bahwa masalahnya adalah kebutuhan untuk membandingkan apa yang dimasukkan pengguna dengan apa yang Anda miliki dalam database.  Bagaimana cara melakukannya dengan cara yang aman?  Nah, jangan lupa bahwa di dalam perusahaan ada juga orang-orang yang tidak sepenuhnya ramah dan ingin melindungi diri mereka dari mereka juga. </p><br><h3 id="heshi">  Hash </h3><br><p><img src="https://habrastorage.org/webt/-w/aj/lj/-wajlj6zqzv9v52a1tm-jyykii0.png" alt="Slide 9. Apa yang salah dengan kata sandi?"></p><br><p>  Pada prinsipnya, mengapa kata sandi adalah subjek yang sangat menyakitkan, mengapa perlu bekerja dengan mereka dengan lebih hati-hati?  Masalahnya adalah bahwa kata sandi memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entropi</a> kecil.  Apa itu entropi?  Ini adalah jumlah informasi yang terkandung dalam data, mis.  misalnya, dalam kata Highload 8 huruf adalah 8 byte, tetapi jika kita menghitung entropi, itu tidak akan menjadi 64 bit seperti seluruh kata, tetapi kurang dari 30 bit.  Ketika hari ini mereka berbicara tentang memecahkan kata sandi, mereka mengatakan bahwa adalah mungkin untuk memecahkan kata sandi dengan entropi dalam waktu seperti itu, tidak ada lagi atau tidak kurang dari begitu banyak bit.  Yaitu  bahkan jumlah kata sandi tidak diperhitungkan. </p><br><p><img src="https://habrastorage.org/webt/2u/ry/lh/2urylhxlc1vap1pdvcq8wqubgai.png" alt="Slide 10.1.  Hash"></p><br><p>  Bagaimana orang memulai dengan keamanan kata sandi?  Hal pertama yang terlintas dalam pikiran adalah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hash kriptografi</a> searah. </p><br><p><img src="https://habrastorage.org/webt/ny/ng/3e/nyng3eb-ukqoj_siqeyekl-m6ys.png" alt="Slide 10.2.  Hash"></p><br><p>  Fitur luar biasa mereka adalah bahwa mereka tidak dapat dikembalikan.  Yaitu  Jika Anda mentransfer beberapa informasi ke hash ini, menerima nilai pada output, Anda tidak bisa mendapatkan informasi ini kembali dari nilai ini.  Namun, sayangnya, perhitungannya sangat cepat.  Misalnya, sekelompok kartu grafis NVidia 4 modern dapat memproses beberapa miliar kata sandi per detik.  Yaitu  jika entropi kata sandi Anda kurang dari 40 bit, maka sekelompok 4 kartu video akan mengambilnya di sana dalam satu menit, atau bahkan kurang. </p><br><h3 id="raduzhnye-tablicy">  Meja pelangi </h3><br><p><img src="https://habrastorage.org/webt/rw/bd/ku/rwbdku7uc7nlyovcvlp7fh19zbk.png" alt="Slide 11.1.  Meja pelangi"></p><br><p>  Selain itu, setiap hash yang rumit memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel pelangi</a> sendiri.  Apa meja ini dan bagaimana mereka dibuat? </p><br><p><img src="https://habrastorage.org/webt/m_/sj/yy/m_sjyylroq0g4wcqjj8stum8yq4.png" alt="Slide 11.2.  Meja pelangi"></p><br><p>  Yaitu  mereka mengambil kata sandi dan kombinasi karakter paling populer yang dapat ditampung di hard drive, mempertimbangkan hash untuk mereka dan menempatkannya di beberapa penyimpanan lebih untuk beberapa terabyte.  Ketika ada beberapa jenis hash, Anda tidak dapat menghitungnya, tetapi menemukannya sangat cepat dari tabel ini dan membandingkannya dengan kata sandi yang sebelumnya dihitung.  Yaitu  Keuntungan dari tabel adalah bahwa mereka bekerja sangat cepat, tetapi Anda membutuhkan banyak ruang untuk menyimpannya.  Namun demikian, ada tabel untuk hash paling populer di Internet, dapat diunduh, atau bahkan dibeli. </p><br><p>  <em>Catatan penulis sinopsis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> tidak setuju dengan pembicara: "Rainbow table adalah versi khusus dari tabel pencarian untuk membalikkan fungsi hash kriptografi menggunakan mekanisme kompromi yang masuk akal antara waktu pencarian dalam tabel dan memori yang ditempati."</em>  <em>Yaitu</em>  <em>itu tidak menyimpan hash dari kata sandi paling populer yang akan muat di disk, tetapi hanya hash dari beberapa kata sandi, sisanya dihitung berdasarkan kata-kata yang ada - ada beberapa kata sandi per catatan dalam tabel.</em> </p><br><h3 id="sol">  Garam </h3><br><p><img src="https://habrastorage.org/webt/nx/cx/l3/nxcxl3ijlwytnvaumlbt9zlnjdo.png" alt="Slide 12.1.  Garam"></p><br><p>  Tetapi sekali lagi, setiap meja pelangi memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">garam</a> sendiri.  Apa itu garam?  Ini adalah serangkaian byte acak, yang ditambahkan ke kata sandi.  Itu disimpan di meja di suatu tempat dekat hash dan melindungi dari tabel pelangi. </p><br><p><img src="https://habrastorage.org/webt/xl/z1/_j/xlz1_j7oasnp6wpvijtlbmpw5n8.png" alt="Slide 12.2.  Garam"></p><br><p>  Yaitu  orang-orang yang mendapatkan tangan mereka dengan hash asin masih harus menghitung hash ini.  Tetapi masalahnya adalah bahwa hash ini dihitung dengan sangat cepat dan garam tidak banyak membantu di sini. </p><br><h3 id="kak-zamedlit-perebor">  Bagaimana cara memperlambat pencarian? </h3><br><p><img src="https://habrastorage.org/webt/tb/vh/of/tbvhoftqtm7hlvgibwwvafv9cl4.png" alt="Slide 13.1.  Bagaimana cara mencoba pencarian?"></p><br><p>  Cara alami dari ini bisa memperlambat pengurutan hash dalam beberapa cara.  Bagaimana ini bisa dilakukan? </p><br><p><img src="https://habrastorage.org/webt/6j/9c/x0/6j9cx0nof6w-dzgbc3b6nx5qw-8.png" alt="Slide 13.2.  Bagaimana cara mencoba pencarian?"></p><br><p>  Pendekatan yang paling naif adalah bahwa kita mengambil semacam fungsi hash, misalnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sha256,</a> dan menghitungnya secara iteratif, mis.  hitung hash, dari hash ini hash lagi, dll.  Anda dapat melakukan ini ribuan bahkan jutaan kali.  Masalahnya adalah bahwa jika Anda menulis sendiri implementasi seperti itu, maka kemungkinan besar akan lebih lambat daripada implementasi orang yang secara profesional terlibat dalam menebak kata sandi. </p><br><p><img src="https://habrastorage.org/webt/nj/f3/hr/njf3hrodtzqbbu5w3purv-vsm6u.png" alt="Slide 14. Fungsi hashing kata sandi"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCrypt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bcrypt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Argon2</a> </p><br><p>  Dan oleh karena itu, cryptographers memunculkan beberapa fungsi yang secara khusus dirancang untuk memperlambat pencarian kata sandi - mereka menggunakan sejumlah besar memori dan semua kemungkinan instruksi prosesor modern.  Jika kata sandi yang dilindungi oleh fungsi seperti itu jatuh ke tangan penyerang, maka mereka harus menggunakan perangkat keras yang sangat kuat. </p><br><p><img src="https://habrastorage.org/webt/-e/ed/gw/-eedgw4f2c-6q3khy9pywdotzwa.png" alt="Slide 15. Argon2"></p><br><p>  Sebagai contoh, fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Argon2</a> paling modern berfungsi sebagai berikut: pada diagram Anda dapat melihat bahwa ada banyak blok memori berbeda yang digunakan untuk menjalankan hash.  Dia melakukan ini dengan berbagai cara pulang pergi, memori digunakan dengan sangat intensif, seluruh memori digunakan.  Agak sulit untuk mengoptimalkan fungsi seperti itu (kecepatan pencarian). </p><br><p><img src="https://habrastorage.org/webt/eu/gn/u2/eugnu2x_t3tsbyfzqmyesuwlmse.png" alt="Slide 16. Fungsi hashing kata sandi"></p><br><p>  Namun pendekatan ini juga memiliki kelemahan.  Fungsi-fungsi ini dibuat lambat secara khusus, tetapi mereka secara khusus lambat tidak hanya untuk penyerang, mereka akan sangat lambat untuk Anda juga.  Mereka akan memuat besi Anda.  Fungsi-fungsi ini dapat disesuaikan, mis.  Anda dapat memilih berapa banyak memori yang akan digunakan untuk menghitung hash dari satu kata sandi, hingga beberapa gigabytes, berapa banyak yang melewati memori ini.  Jika Anda memutar parameter ini dengan sangat serius, perangkat keras Anda sendiri akan rusak dan jika Anda memiliki banyak orang yang masuk ke sistem, maka Anda hanya perlu mengalokasikan sumber daya yang cukup besar untuk perlindungan kata sandi dan kata sandi sederhana, yah, kata sandi yang sangat sederhana masih dapat diambil. . </p><br><h3 id="facebooks-password-onion">  Kata sandi Facebook Bawang </h3><br><p><img src="https://habrastorage.org/webt/jg/ij/6k/jgij6ksfudwqixuwbidyqos8g_y.png" alt="Slide 17. Dan bisakah kamu memuat backend?"></p><br><p>  Orang-orang memikirkan hal ini dan mengajukan pertanyaan: apakah mungkin untuk mencapai properti yang sama tanpa memuat backend, tanpa memuat server mereka sendiri? </p><br><p><img src="https://habrastorage.org/webt/3t/bt/i5/3tbti5mfy7-5smkvkfpkzyw8cq0.png" alt="Geser 18. Kata sandi Facebook Bawang"></p><br><p>  Salah satu pelopor dalam hal ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah Facebook</a> .  Baris-baris ini yang Anda lihat adalah tahapan historis Facebook, bagaimana mereka melindungi kata sandi, pada awalnya hanya ada kata sandi, kemudian mereka mengambil fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">md5</a> lama, yang telah dipecah untuk waktu yang lama, kemudian mereka menambahkan garam di sana dan mengambil hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sha1</a> , dan kemudian itu terjadi Yang menarik, mereka membawa perhitungan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hmac</a> (ini adalah hash dengan kunci) ke layanan jarak jauh. </p><br><p><img src="https://habrastorage.org/webt/at/hg/59/athg59eofneynp9pmmn1ffzdbg8.png" alt="Geser 19. Facebook"></p><br><p>  Bagaimana cara kerjanya?  Ada backend, ada layanan jarak jauh.  Ada semacam kunci rahasia pada layanan ini.  Seseorang memasuki backend, memasukkan kata sandinya.  Kata sandi ini dicampur dengan garam yang ada di database, dijalankan melalui hash dan dikirim ke layanan.  Layanan mengambil kunci privatnya, menghitung fungsi hmac, dan mengirim semuanya kembali.  Di backend, diletakkan di pangkalan. </p><br><p><img src="https://habrastorage.org/webt/nj/hw/ac/njhwackeuo-kschvhkkvaxstmky.png" alt="Geser 20. Facebook"></p><br><p>  Apa yang diberikannya?  Jika Facebook memiliki basis data pengguna, maka tidak layak untuk mengurutkan kata sandi di dalamnya, karena mereka tidak memiliki kunci rahasia jarak jauh.  Tetapi masalah dengan pendekatan Facebook adalah jika sesuatu terjadi pada kunci pribadi jarak jauh mereka, mereka akan berada dalam masalah besar.  Mereka tidak bisa berbuat apa-apa karena mereka menggunakan hash, mereka menggunakan hmac.  Mereka tidak memiliki cara untuk menyelesaikan situasi ini sehingga pengguna tidak akan melihat apa-apa dan ini akan membuat mereka terpojok. </p><br><h3 id="sphinx">  Sphinx </h3><br><p><img src="https://habrastorage.org/webt/_t/kq/nd/_tkqnduhchzryj-sgjt-kqytyo0.png" alt="Slide 21. Apakah lebih baik?"></p><br><p>  Cryptographers melihat semuanya.  Mereka menyukai gagasan menggunakan layanan jarak jauh dan memutuskan untuk berpikir: apakah mungkin melakukan lebih baik?  Apakah mungkin untuk membuat sistem yang serupa, tetapi tanpa kekurangan yang telah diberkahi oleh Facebook? </p><br><p><img src="https://habrastorage.org/webt/hh/04/o5/hh04o5poadnr-d4diswhuaferuq.png" alt="Slide 22. Apakah kata sandi itu nomor?"></p><br><p> Dan mereka memutuskan untuk mendekati masalah ini sebagai berikut: bagaimana jika kata sandi atau kata sandi hash direpresentasikan sebagai angka?  Jika kita memiliki kata <code>passw0rd</code> , kata itu terdiri dari 8 byte.  Di hampir semua bahasa pemrograman, ada tipe integer delapan byte, mis.  Pada prinsipnya, ini satu dan sama.  Yaitu  8 byte, kata <code>passw0rd</code> dan kita dapat menyatakannya sebagai angka desimal biasa.  Apa yang ini berikan pada kita?  Ini memberi kita kebebasan bertindak yang sama sekali berbeda.  Kita dapat menambahkan kata sandi atau hash dari mereka, melipatgandakannya, mengubahnya menjadi beberapa nomor lain.  Kita dapat melakukan operasi matematika yang sangat serius dengan mereka. </p><br><p><img src="https://habrastorage.org/webt/6h/3d/wm/6h3dwmeitk9jftagy1hszcqbmgo.png" alt="Slide 23.1. Sphinx - pengelola kata sandi"></p><br><p>  Salah satu sistem pertama yang menggunakan teknologi ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sphinx</a> .  Dia muncul beberapa tahun yang lalu.  Ini adalah pengelola kata sandi deterministik.  Ada banyak program berbeda seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keepass</a> , di mana Anda memiliki kata sandi utama dan untuk setiap situs menghasilkan kata sandi acak.  Tetapi ada juga hal-hal deterministik di mana Anda memasukkan kata sandi utama Anda, situs yang ingin Anda kunjungi dan menghitung sesuatu di sana dan mengeluarkan kata sandi unik untuk setiap situs.  Tetapi jelas bahwa jika kata sandi utama ini masuk ke suatu tempat, maka semua kata sandi dari situs Anda akan dikompromikan secara permanen. </p><br><p><img src="https://habrastorage.org/webt/qs/9j/0z/qs9j0z8enfk9_j_p53msuqcxufu.png" alt="Slide 23.2. Sphinx - pengelola kata sandi"></p><br><p>  Bagaimana Sphinx mendekati masalah ini?  Dia mengambil kata sandi utama, dia mengambil domain yang ingin Anda masuki, menjalankan semuanya melalui hash dan mengubahnya menjadi angka.  Tetapi pada kenyataannya, kriptografi eliptik digunakan di sana, untuk kesederhanaan saya akan menjelaskan semua ini pada bilangan biasa dengan matematika biasa.  Dia mengubahnya menjadi angka (sebut saja <code>a</code> ) dan apa yang dia lakukan selanjutnya? </p><br><p><img src="https://habrastorage.org/webt/wx/ba/hk/wxbahkcpmzzmwsaxj1_abbdwrpq.png" alt="Slide 24. Sphinx - &quot;pengelola&quot; kata sandi, samarkan!"></p><br><p>  Hal yang benar-benar luar biasa, setiap kali kita dapat menghasilkan angka acak <code>r</code> .  Jika kita menaikkan bilangan <code>a</code> ke pangkat <code>r</code> , dan beberapa waktu kemudian kita menaikkan bilangan ini ke pangkat kebalikan ke b, maka kita mendapatkan kembali bilangan yang sama <code>a</code> , kan?  Yaitu  kita bisa menutupi sesuatu dari awal, dan kemudian membuka kedoknya. </p><br><p><img src="https://habrastorage.org/webt/pu/yp/5t/puyp5t7x6yprlu_xyybj4z8llna.png" alt="Slide 25.1. Sphinx - pengelola kata sandi"></p><br><p>  Dan apa yang dilakukan sphinx?  Sekali lagi ada pengguna, ada layanan jarak jauh.  Nomor bertopeng dikirim ke layanan jarak jauh ini.  Pada layanan jarak jauh, ada kunci pribadi <code>b</code> .  Apa yang dia lakukan  Dia mengalikan nomor yang dikirim dengan kunci rahasianya <code>b</code> dan mengirimkannya kembali.  ( <em>Catatan penulis ringkasan: pada slide, jumlah yang dikirim tidak dikalikan dengan kunci privat, tetapi dinaikkan ke tingkat kunci privat, tetapi poin utamanya adalah</em> ).  Karena angka <code>r</code> berbeda setiap kali, layanan jarak jauh tidak dapat mengatakan apa pun tentang kata sandi dan domain mana yang di-mask, yaitu  setiap kali dia melihat beberapa angka acak yang berbeda.  Dan dia hanya mengalikan dengan kunci pribadinya <code>b</code> dan mengirim kembali. </p><br><p><img src="https://habrastorage.org/webt/gs/nm/bx/gsnmbxvngd2m2ziqnuqo-mdtney.png" alt="Slide 25.2. Sphinx - pengelola kata sandi"></p><br><p>  Pengguna membuka tabir apa yang dikirim oleh server kepadanya dan ia mendapatkan nomor - kata sandi masternya dengan domain dikalikan dengan kunci rahasia server <code>a^b</code> .  Ternyata dia tidak tahu kunci rahasia server, server tidak tahu apa yang dikirim pengguna, tetapi pada akhirnya dia juga mendapat semacam nomor deterministik.  Setiap kali Anda menjalankan protokol ini, penyamaran akan berbeda, tetapi hasilnya akan selalu sama dan hasil ini kemudian dapat diubah kembali menjadi semacam kata sandi dan digunakan untuk memasuki berbagai situs. </p><br><p><img src="https://habrastorage.org/webt/7v/zd/hv/7vzdhvrksyvyg_awii2rkvphdgy.png" alt="Slide 26. Sphinx - &quot;pengelola&quot; kata sandi"></p><br><p>  Teknologi yang benar-benar luar biasa.  Pertama, Anda dapat menghasilkan kata sandi besar, mis.  melindungi dari busting.  Kedua, jika seorang hacker mendapatkan akses ke beberapa kata sandi, ia tidak akan dapat mengatakan apa pun tentang sisanya, karena  mereka dihasilkan secara independen satu sama lain.  Ketiga, jika kata sandi pengguna hilang di suatu tempat, maka ini juga tidak akan memberikan apa-apa, karena peretas tidak akan memiliki kunci rahasia.  Keempat, ini bekerja sangat cepat, karena  tidak ada hash besar berulang diperlukan di sini, yaitu  secara harfiah 2-3 perkalian dilakukan dan semuanya bekerja secara instan. </p><br><p>  Tetapi sistem ini memiliki kekurangan.  Server yang digunakan pengguna untuk berbicara tidak tahu apa-apa tentang dirinya.  Dia hanya menerima beberapa angka acak sebagai input, mengalikannya dengan sesuatu dan mengirimkannya kembali.  Klien juga tidak tahu apa-apa tentang server, ia mengirim sesuatu ke suatu tempat, menerima hasilnya, ia bekerja - baik.  Tetapi jika sesuatu terjadi pada layanan, pengguna tidak akan dapat mengatakan apa-apa tentang itu, ia tidak memiliki informasi untuk ini.  Kunci rahasia juga tidak bisa diubah, tidak ada yang bisa dilakukan dengan itu. </p><br><h3 id="pythia">  Pythia </h3><br><p><img src="https://habrastorage.org/webt/cp/kt/3z/cpkt3zvvpwx7svjbydprtntli5i.png" alt="Slide 27. Mungkinkah ini lebih baik?"></p><br><p>  Mungkinkah ini lebih baik? </p><br><p><img src="https://habrastorage.org/webt/ot/jg/ms/otjgmsc63aic6zb8mpod01tn9jy.png" alt="Slide 28. END-TO-END!"></p><br><p>  Cryptographers melihat sistem ini dan berpikir, apakah mungkin untuk meningkatkan sistem dan menambahnya dengan properti yang akan memungkinkan kita untuk mengatakan bahwa itu sesuai dengan prinsip-prinsip ujung ke ujung?  Yaitu  klien dapat berkomunikasi dengan server, tetapi pada saat yang sama, ia juga dapat mengotentikasi dan dapat mempercayainya sampai batas tertentu. </p><br><p><img src="https://habrastorage.org/webt/gv/2o/p8/gv2op8fshghvw1rvt0dnqnqwxnw.png" alt="Slide 29.1. Pythia"></p><br><p>  Dan mereka datang dengan protokol yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pythia</a> . </p><br><p><img src="https://habrastorage.org/webt/kq/wd/in/kqwdin-__0xxfcerqmva6s2vewo.png" alt="Slide 29.2. Pythia"></p><br><p>  Itu dibuat oleh pria hebat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Adam Everspaugh</a> dengan rekan-rekannya.  Apa yang membuatnya unik?  Pertama, layanan tahu siapa yang memasukkan kata sandi, yaitu  ID pengguna diteruskan ke server melewati kata sandi.  Ini bisa berupa kotak id acak yang terletak di sebelahnya, atau hanya nama pengguna.  Itu tidak masalah.  Tetapi layanan tahu tentang itu.  Tetapi server tidak hanya tahu sedikit tentang ini, secara matematis dapat membuktikan bahwa itu adalah dia. </p><br><p><img src="https://habrastorage.org/webt/pf/lo/zf/pflozf9qji8nzq_nhpswlqd-3xa.png" alt="Slide 30.1. Pythia"></p><br><p>  Bagaimana cara kerjanya?  Ada backend (semacam layanan web, situs) dan ada layanan Pythia.  Apa yang dilakukan backend dan apa yang dilakukan layanan?  Ada kunci pribadi <code>k</code> pada layanan, tetapi juga mentransfer kunci publiknya ke backend.  Backend layanan tidak hanya mengirim nomor bertopeng <code>a^r</code> , seperti dalam protokol Sphinx, tetapi juga mengirimkan semacam pengenal pengguna ( <code>UserID</code> ).  Layanan ini mengalikan ID pengguna dan kata sandi dengan kunci privatnya dan hasilnya <code>(UserID, a)^(r*k)</code> mengirimkan backend.  Dia juga mengirim kembali <code>Proof</code> tertentu, yang dapat digunakan oleh backend untuk memeriksa server bahwa ia belum diretas, bahwa ia merespons sebagaimana mestinya. </p><br><p><img src="https://habrastorage.org/webt/re/qr/x2/reqrx276lka5gxfal99x0_l9esy.png" alt="Slide 30.2. Pythia"></p><br><p>  Lalu ada unmasking dan angka <code>y</code> yang hasilnya dimasukkan ke dalam DB.  Dalam database kami tidak hanya memiliki hash, tetapi angka, titik kurva eliptik. </p><br><p><img src="https://habrastorage.org/webt/xx/qc/jt/xxqcjtbljojosjg0ssvhptf3oj0.png" alt="Slide 31. Pythia"></p><br><p>  Ada beberapa poin menarik di sini: </p><br><ul><li>  Kemampuan server menggabungkan ID pengguna dan kata sandi menjadi satu nomor.  Ini disebut operasi bilinear atau pasangan bilinear.  Ini adalah matematika yang relatif baru, yang baru-baru ini mulai digunakan.  Dia memiliki semua sifat matematikawan baru dalam 30 tahun yang belum berlalu sehingga semua orang akan yakin bahwa semuanya normal dengan ini. </li><li>  Tetapi <code>Proof</code> yang mengirim layanan adalah teknologi yang agak lama.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protokol Schnorr</a> .  Generasi kunci publik adalah penggandaan titik dasar dengan beberapa kunci rahasia.  Protokol Schnorr membuktikan bahwa kunci rahasia yang digunakan untuk menghasilkan kunci publik digunakan untuk mengalikan kata sandi pengguna dengan nomor yang sama.  Protokol ini sudah lama ada, sudah banyak digunakan di mana dan memungkinkan Anda untuk membuktikan.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zero-proof proof</a> - server tidak menunjukkan kunci publiknya, tetapi dikatakan bahwa operasi yang saya lakukan dilakukan oleh kunci pribadi itu, yang semula kami sepakati. </li></ul><br><p><img src="https://habrastorage.org/webt/jz/pg/lo/jzpglodcswcwxprayrpud8semws.png" alt="Slide 32.1. Pro dari Pythia"></p><br><p>  Apa kelebihan sistem ini? </p><br><p><img src="https://habrastorage.org/webt/xn/dg/zg/xndgzgr-to_dgnypnwarbyxengg.png" alt="Slide 32.2. Pro dari Pythia"></p><br><p>  Dan dia tidak punya banyak. </p><br><ul><li>  Sistem tidak memuat backend.  Karena backend melakukan segalanya, itu mengubah kata sandi menjadi angka, menyamarkannya, mengirimkannya, lalu membuka kedok hasilnya. </li><li>  Jika database dengan nomor tersebut dicuri dari Anda, maka pengurutan kata sandi juga tidak masuk akal tanpa kunci pribadi. </li><li>  Layanan Pythia dapat memblokir upaya kekerasan, yang berarti backend tidak harus melakukan ini pada prinsipnya.  Jika dia melihat bahwa di bawah ID pengguna yang sama mereka mencoba melakukan operasi transformasi ini beberapa kali, dia bisa memotongnya dan memblokirnya pada batas nilai. </li><li>  Berkat penyamarannya, layanan ini tidak tahu apa-apa tentang kata sandi.  Setiap kali nomor acak baru dikirimkan kepadanya.  Hanya pengidentifikasi pengguna yang tetap konstan. </li><li>  Berkat ZKP (Zero-knowledge proof), backend selalu tahu bahwa itu adalah layanan yang pernah ia hubungi. </li><li>  Jika Anda memiliki database dengan hashes dan garam misalnya, maka Anda dapat bermigrasi ke solusi seperti itu untuk pengguna.  Mereka bahkan mungkin tidak memperhatikan apa pun.  Alih-alih kata sandi pengguna, Anda mengambil hash, mengarahkannya ke Pythia dan di masa depan cukup gunakan protokol ini, dapatkan nomor <code>y</code> , taruh lagi di database Anda.  Hash kemudian dapat dihapus.  Setiap kali pengguna login ke sistem Anda, protokol ini akan dieksekusi, beberapa nomor akan diperoleh, yang akan Anda bandingkan dengan apa yang ada di database.  Sistem otentikasi itu sendiri akan tetap tidak berubah, seperti  pengguna akan masuk lebih awal dan masuk, dengan kata sandi yang sama, bahkan yang lemah.  Dalam hal ini, sistem akan jauh lebih aman. </li></ul><br><p><img src="https://habrastorage.org/webt/2i/63/ja/2i63jae0xiucsx-dqailxoaqiuw.png" alt="Slide 33.1. Bukan itu saja"></p><br><p>  Tapi ini tidak semua barang. </p><br><p><img src="https://habrastorage.org/webt/oa/dy/h9/oadyh9nurjtlv5qdbgo8f2xfcui.png" alt="Slide 33.2. Bukan itu saja"></p><br><p>  Salah satu fitur utama adalah bahwa bahkan jika layanan Pythia diretas, dimungkinkan untuk membuat kunci pribadi baru.  Dalam database kami, nomor disimpan, bukan hash.  Jika kita merepresentasikan kunci lama sebagai angka <code>k</code> , dan yang baru sebagai angka <code>k'</code> , maka kita dapat menghitung angka yang disebut token Pembaruan.  Untuk melakukan ini, kami mengalikan angka baru dengan angka terbalik dengan yang lama.  Dan dengan token pembaruan ini, Anda dapat pergi melalui database untuk setiap pengguna dan mengalikan angka ini dengan memperbarui token.  Setelah Anda melakukan ini, sistem Anda terus bekerja dengan kunci pribadi baru pada layanan jarak jauh.  Itu semua terjadi secara instan.  Jika terjadi bencana, basis data Anda dengan kata sandi telah dicuri dari Anda, Anda melepaskan token pembaruan dengan mengklik jari dan fakta bahwa peretas mencuri dari Anda menjadi tidak berguna secara instan.  Anda hanya diam-diam berjalan melalui semua catatan di latar belakang, memperbaruinya dan mereka bekerja dengan kunci rahasia baru untuk Anda.  Pengguna umumnya bahkan tidak memperhatikan apa pun.  Yaitu  Pembaruan yang mulus dan pembatalan database kata sandi yang instan adalah beberapa fitur inovatif utama dari sistem ini. </p><br><p><img src="https://habrastorage.org/webt/uu/cb/_z/uucb_z0ikld1bufittz0asq5m84.png" alt="Slide 34.1. Bonus"></p><br><p>  Tapi itu belum semuanya. </p><br><p><img src="https://habrastorage.org/webt/vr/jo/3k/vrjo3kpwbw1xuzdr6wklxmwkrgw.png" alt="Slide 34.2. Bonus"></p><br><p>  Angka yang terletak di pangkalan besar <code>y</code> , pada dasarnya besar dan terlihat cukup pseudo-acak, yaitu  sangat mudah untuk tidak mengambilnya.  Jika kita mentransfer fungsionalitas yang kita miliki di backend, misalnya, ke perangkat klien, ke ponsel, maka kita dapat menggunakan ini untuk menghasilkan kunci.  Kami menyebut hal ini BrainKey.  Ini berarti bahwa pengguna memasukkan kata sandi di suatu tempat di telepon, juga menyamarkannya, mengirimkannya ke layanan jarak jauh.  Layanan mengembalikan angka tertentu <code>y</code> dan kemudian Anda dapat menggunakan <code>y</code> ini untuk menghasilkan beberapa kunci asimetris.  Dengan demikian, pengguna dari kata sandinya bisa mendapatkan pasangan kunci.  Ini digunakan di semua jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BrainWallets</a> .  Inilah saatnya Anda memasukkan kata sandi dan mendapatkan dompet bitcoin yang dihasilkan untuk itu.  Tetapi aplikasi ini tidak terbatas pada cryptocurrency, ini adalah tanda tangan digital, beberapa cadangan, dan pemulihan akun, mis.  dimanapun kriptografi asimetris digunakan, di mana kunci asimetris diperlukan.  Semua ini dapat digunakan, tetapi pada saat yang sama sepasang kunci, dan mereka, tergantung pada kebutuhan, dapat dihasilkan sebanyak yang Anda suka.  Jadi mereka semua akan bergantung pada kata sandi pengguna, dan ini sangat nyaman. </p><br><p><img src="https://habrastorage.org/webt/sy/cw/nl/sycwnl1rpbmtpsc_0ddxi3fjlx0.png" alt="Slide 35.1. Kontra?"></p><br><p>  Dalam satu tong madu, itu bukan tanpa lalat di salep. </p><br><p><img src="https://habrastorage.org/webt/wx/jw/an/wxjwanacuusmfnb_ptce1peh_cg.png" alt="Slide 35.2. Kontra?"></p><br><p>  Dan fitur teknologi ini sangat baru.  Ini menggunakan kurva eliptik, yang untuk operasi bilinear ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BLS12-381</a> ).  Matematika itu sendiri telah ada selama beberapa waktu, tetapi kurva khusus ini, yang digunakan khususnya dalam implementasi kami, hanya digunakan dalam <nobr>ZCash</nobr> kecuali kami.  Dengan demikian, perpustakaan yang menggunakan matematika baru ini dapat dihitung dengan jari satu tangan.  Untuk membawa ini ke dalam keadaan produksi, Anda perlu menghabiskan sejumlah waktu dan upaya.  Namun demikian, industri tidak tinggal diam dan semua kerugian ini bersifat sementara.  Sebagai konsekuensi dari dua properti pertama, kecepatan operasi bilinear ini tidak terlalu konsisten dengan matematika modern, khususnya elips, yang kita semua gunakan sekarang, ketika kita menggunakan protokol TLS, ketika kita menggunakan beberapa situs.  Ini adalah sekitar beberapa ratus operasi pada layanan pada satu inti.  Sebenarnya, ini tidak menghentikan kami dan pada musim semi kami menerapkan protokol ini, merilisnya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">produksi</a> dan menerjemahkan semua catatan kami, melindungi mereka menggunakan protokol ini.  Pada prinsipnya, kami puas dengan kinerja untuk tugas-tugas kami saat ini, jika perlu, kami akan meningkatkan simpul lain dengan layanan Pythia dan, pada prinsipnya, Anda sudah bisa bermain dengan semua ini. </p><br><h3 id="phe">  PHE </h3><br><p><img src="https://habrastorage.org/webt/hv/1e/1l/hv1e1lslzyk31hgsw2fu5sffk_o.png" alt="Slide 36. Apakah ini lebih baik?"></p><br><p>  Tetapi kami berpikir apakah kami bisa melakukan yang lebih baik lagi?  Apakah mungkin untuk mencapai properti yang disediakan oleh Pythia dengan menggunakan matematika kemarin?  Bukan besok, bukan hari ini, tapi bahkan kemarin, yang telah digunakan selama bertahun-tahun. </p><br><p><img src="https://habrastorage.org/webt/6r/rn/0x/6rrn0xaorj5qjkyuk2hhamqaqyk.png" alt="Slide 37.1.  Layanan Enkripsi Hardened-Password Sederhana (PHE)"></p><br><p>  Dan secara harfiah pada bulan Juli tahun ini, para ilmuwan merilis sebuah protokol baru yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan Enkripsi Hardened Simple Password,</a> atau singkatnya PHE. </p><br><p><img src="https://habrastorage.org/webt/hx/o5/zv/hxo5zveu2y75lmqm-t3pqknaq0e.png" alt="Slide 37.2.  Layanan Enkripsi Hardened-Password Sederhana (PHE)"></p><br><p>  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Russell Lai</a> , seorang ilmuwan dari Eropa. </p><br><p>  Apa kelebihan layanan ini?  Pertama, ia menggunakan kurva <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P-256</a> standar, yang digunakan di mana-mana, di semua browser, produk, di mana saja kurva default, yang telah ada selama bertahun-tahun.  Kedua, benda ini bekerja sekitar 10 kali lebih cepat daripada Pythia dan menggunakan primitif standar.  Agak sulit, tetapi Anda bisa menerapkannya dengan tangan Anda sendiri tanpa menggunakan perpustakaan yang tidak jelas.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenSSL</a> , atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bouncy Castle</a> , apa saja. </p><br><p><img src="https://habrastorage.org/webt/el/f0/ho/elf0hoawmvsekav9jgvkqxp0_ju.png" alt="Slide 38. Layanan Enkripsi Sederhana yang Dilengkapi Kata Sandi (PHE)"></p><br><p>  Tapi itu bekerja sedikit berbeda.  Sekali lagi ada backend, ada layanan PHE.  Backend memiliki kunci publik, layanan ini memiliki kunci pribadi <code>y</code> .  Tidak seperti Pythia, proses registrasi dan proses verifikasi kata sandi sedikit berbeda.  Ketika seorang pengguna baru datang ke layanan dan ingin mendaftar, apa yang dilakukan backend?  Sejak awal, dia bertanya ke layanan PHE, tolong beri saya beberapa data yang bisa saya gunakan untuk mendaftar, semacam catatan Pendaftaran.  Layanan mengatakan OK dan menjawab backend dengan hal-hal berikut.  Ini menghasilkan beberapa garam 32-byte acak ( <code>sNonce</code> ).  Berdasarkan garam ini dan kunci privasinya y, ia menghasilkan dua angka, sebut saja mereka <code>C0</code> dan <code>C1</code> .  Ini juga menghasilkan bukti ( <code>Proof</code> ) bahwa dua angka atau 2 poin ini dihasilkan secara tepat menggunakan kunci privasinya <code>y</code> , menggunakan protokol Schnorr (seperti pada protokol sebelumnya).  Backend memeriksa <code>Proof</code> .  Belum ada kata sandi di sini.  Apa yang dilakukan backend?  Untuk bagiannya, ia juga memiliki kunci pribadi klien pribadi <code>x</code> dan, setelah menerima kata sandi dari pengguna, ia melakukan hal yang sama seperti layanan, hanya menambahkan kata sandi di sana.  Dibutuhkan <code>cNonce</code> acak (garam klien acak), kata sandi, dan sekali lagi menghasilkan 2 angka <code>HC0</code> dan <code>HC1</code> .  Kenapa 2?  Karena <code>HC0</code> pertama digunakan untuk otentikasi, dan angka kedua <code>HC1</code> mencampur beberapa angka acak <code>M</code> dikalikan dengan kunci pribadi <code>x</code> ( <code>MC</code> ).  Angka <code>M</code> juga berukuran 32 byte dan nantinya dapat digunakan untuk mengenkripsi data pengguna (kami memiliki Layanan Enkripsi) ( <em>catatan oleh penulis catatan: kunci enkripsi dalam hal ini adalah <code>MC</code></em> ).  Nomor <code>MC</code> akan tersedia sebagai kunci hanya setelah pengguna memasukkan kata sandi yang benar.  Ternyata pada tahap pendaftaran Anda dapat menghasilkan tidak hanya catatan otorisasi, tetapi juga kunci enkripsi, unik untuk setiap pengguna, yang dengannya Anda dapat mengenkripsi profilnya, beberapa data, dan sesuatu yang lain.  Kemudian backend hanya menjumlahkan apa yang dikirim layanan dan apa yang dilakukannya - menambahkan poin-poin ini dan mendapatkan <code>T0</code> dan <code>T1</code> .  Dalam kasus pertama, itu menambahkan dua ( <code>C0 + HC0</code> ), dan dalam tiga yang kedua ( <code>C1 + HC1 + MC</code> ).  Dan dia memasukkan garam-garam dasar 2 ( <code>sNonce</code> , <code>cNonce</code> ), dengan bantuan yang memperoleh angka-angka ini dan 2 angka ( <code>T0</code> dan <code>T1</code> ), yang ternyata merupakan hasil penjumlahan. </p><br><p><img src="https://habrastorage.org/webt/ly/9d/fj/ly9dfjao1laxszgo9okoovsvzjy.png" alt="Slide 39. Login PHE"></p><br><p>  Dengan demikian, proses otentikasi pengguna terjadi dalam urutan terbalik.  Pengguna memasukkan kata sandinya di backend.  Backend menghitung <code>HC0</code> dan dari apa yang ada dalam database, kurangi <code>HC0</code> dari <code>T0</code> dan mengirimkan <code>C0</code> dihasilkan ke layanan bersama dengan garam server.  Layanan, mengetahui garam server, menghitung titik yang sama dengan sendirinya dan terlihat, itu bertepatan dengan fakta bahwa ia mengirim backend atau tidak, jika cocok, maka kata sandi itu benar dan Anda dapat menjawabnya dengan nomor kedua <code>C1</code> , yang akan dikurangkan bersama dengan <code>HC1</code> dari nomor tersebut. <code>T1</code> dan dapatkan kunci enkripsi.  Dengan demikian, kata sandi untuk layanan PHE bahkan tidak hilang.  Dia bahkan tidak meninggalkan backend.  Itu adalah dalam bentuk beberapa poin dikalikan dengan kunci pribadi backend.  Bahkan tidak ada seperti itu, tetapi pada saat yang sama, layanan jarak jauh dapat membuat kesimpulan yang ketat tentang apakah kata sandi ini benar atau tidak dan membuktikan, di samping itu, bahwa ia melakukan semua perhitungan menggunakan kunci pribadinya <code>y</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/7-/op/bi7-opjxk_7cwvgb4lm4wkwgtbi.png" alt="Slide 40.1.  Fitur phe"></p><br><p>  Fitur apa yang dimiliki sistem ini? </p><br><p><img src="https://habrastorage.org/webt/2t/ar/rm/2tarrmmsr5j4sgk5zlrtcsu1eyc.png" alt="Slide 40.2.  Fitur phe"></p><br><p>  Kata sandi, seperti yang saya katakan, tidak meninggalkan backend.  Tetapi tidak seperti Pythia, Anda memerlukan kunci pribadi di backend.  Yah, kita perlu dan perlu, simpan di suatu tempat.  PHE memiliki semua fungsi dasar Pythia: </p><br><ul><li>  Anda juga dapat mengeluarkan token pembaruan jika sesuatu terjadi pada Anda dengan kunci pribadi; </li><li>  Anda juga dapat melalui seluruh database, memperbarui dan semuanya akan seperti apa adanya; </li><li>  perlindungan pencarian; </li><li>  layanan tidak tahu apa-apa tentang kata sandi; </li><li>   (Pythia , ,  ,    ,  PHE ); </li><li>     . </li></ul><br><p><img src="https://habrastorage.org/webt/vq/_m/yr/vq_myrj2venkvtkjqaij3ujapd4.png" alt="Slide 41. Memperkenalkan ..."></p><br><p>      ... </p><br><p><img src="https://habrastorage.org/webt/hp/s9/_t/hps9_tr6ha4ysxt6szxsdhseuoe.png" alt="Geser 42. passw0rd.io"></p><br><p> â€¦      .      .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">passw0rd.io</a>  .    password  ,    18-        ,    ,    zero trust, ..    .     , , ..  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Let's encrypt</a> .  ,   .    CLI     ,   .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 SDK</a> ,  GO  .Net,     . </p><br><p><img src="https://habrastorage.org/webt/ey/xs/qh/eyxsqh1i0z7s2_fexslxgbdi-fy.png" alt="Slide 43. Kata sandi seperti pakaian dalam"></p><br><p>           : </p><br><ol><li>    . </li><li>      . </li><li>     . </li></ol><br><p><img src="https://habrastorage.org/webt/d4/nh/d4/d4nhd4nzbnhgfq21j-8yqs1ps0m.png" alt="Slide 44. Sumber Daya"></p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VirgilSecurity.com</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@VirgilSecurity</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub.com/VirgilSecurity</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoiseSocket.com</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">passw0rd.io</a> </li></ul><br><p>     ,             . </p><br><h3 id="voprosy"> ? </h3><br><p> <strong> 37. ?</strong> </p><br><p><img src="https://habrastorage.org/webt/z_/t0/05/z_t005mcdxnznvcinnqsg-z750a.png" alt="Slide 45. Pertanyaan?"></p><br><p>     . </p><br><p> Q: ,    !   .     ,      Pythia       update token,        ?        private key  .         update token?  Atau tidak? <br> A: , update token-     . <br> Q:    .      -        update token-,       Private key         ? <br> A: ,    update token-,     ,  - ,   ,  ,    update token.     , ..   . <br> Q: , ,    ,   . <br> A: ..     . </p><br><p> Q: ,   ,     ,     -   Pythia  -    ,       ,     ,   ? <br> A:  . <br> Q:      ? <br> A: ,      Pythia   .  Yaitu     ,        . <br> Q: ( )  bcrypt      ? <br> A: ,      ,   ,      . </p><br><p> Q:  ,    .      ?  , â€¦ <br> A: password   <br> Q: password  ?  Api!  Umumnya. <br> A: 123456   ,        12345, 123456. <br> Q: .    Pythia  ,  PHE   . <br> A:    ,           . <br> Q: .   .         ?  production   ? <br> A:  . !   Pythia. <br> Q:   Pythia,    , ? <br> A:  . <br> Q:   ,  ? <br> A:   . <br> Q: , , ! <br> A:     SDK,     . </p><br><p> Q: ,  ,  ,     , ..   -  ,     ?    ?    ? <br> A: ,    ,    , ..       PHE,    ,    5   2 ,   2   5  .    ,     .    PHE ( ,    ),    ,     10 ,    . <br> Q: ..      - ,      -  ?   ? <br> A:   .     rate limiting,   ,                . <br> Q: ..             , ? <br> A: . </p><br><p> Q: . , ..       Pythia      (),          , ? ? <br> A: ,    ,     . <br> Q:  ,   update   ? <br> A: ,    Pythia  ,         ,  -     -  ,   ,        ,     ) </p><br><p> A: ?   !   .     , ,   PHE,   , . </p><br><h2 id="vyvody">  Kesimpulan </h2><br><p>      PHE (    )          + â€”    (  ,   ,  )      (     ).   PHE      ,                   . </p><br><p>         : </p><br><ul><li>       ( <strong></strong> )   ; </li><li>              (      ). </li></ul><br><p>  ,         . </p><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Scratch</a>   Virgil Security  ,    ,      ! </p><br><p>      (  )? </p><br><p> <strong>UPD</strong> :   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Scratch</a> .          .     ,     .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434708/">https://habr.com/ru/post/id434708/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434698/index.html">Pesimisme Tentang Multithreading</a></li>
<li><a href="../id434700/index.html">Keuntungan mengikuti style guide saat mengembangkan aplikasi Angular</a></li>
<li><a href="../id434702/index.html">Mengapa SSD modern membuat saya crash</a></li>
<li><a href="../id434704/index.html">Alasan penurunan biaya lalu lintas seluler di Rusia dan perkiraan untuk 2019</a></li>
<li><a href="../id434706/index.html">UDB. Apa ini Bagian 3. Datapath FIFO</a></li>
<li><a href="../id434710/index.html">RUVDS blog di Habr: tahun dalam tiga</a></li>
<li><a href="../id434712/index.html">Tes Turing Ketiga dalam bahasa Rusia</a></li>
<li><a href="../id434714/index.html">Sinkronisasi Permintaan Klien di Musim Semi</a></li>
<li><a href="../id434716/index.html">Pindah ke pusat data: Persiapan</a></li>
<li><a href="../id434718/index.html">Dua tahun kemudian, saya masih merindukan jack headphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>