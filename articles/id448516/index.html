<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏼 🐏 🏗️ Evolusi atau buat basis untuk robot pada platform ARDUINO, dan kami menggerakkan sensor dan video ke komputer melalui smartphone 🚅 🧒🏽 👍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagi para pembaca GeekTimes, artikel (keempat) berikutnya yang telah lama dinanti-nantikan tentang apa yang akan terjadi jika Anda mencampur arduino, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Evolusi atau buat basis untuk robot pada platform ARDUINO, dan kami menggerakkan sensor dan video ke komputer melalui smartphone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448516/"> Bagi para pembaca GeekTimes, artikel (keempat) berikutnya yang telah <s>lama dinanti-nantikan</s> tentang apa yang akan terjadi jika Anda mencampur arduino, ESP8266, WI-FI lagi, bumbui dengan smartphone Android dan taburkan di atas aplikasi JAVA. <br><br>  Kami akan berbicara tentang robot dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelum yang terakhir, yang datang setidaknya untuk menjadi sedikit lebih pintar. <br><br><img src="https://habrastorage.org/webt/dc/uf/us/dcufusp1engi_cqy_pdjltx-qgq.jpeg" alt="gambar"><br><br>  Siapa peduli, selamat datang ke kucing. <br><a name="habracut"></a><br>  Jika Anda tidak terlalu tertarik membaca artikel-artikel lama, maka secara singkat - intinya adalah untuk mengendalikan troli beroda empat yang biasa di platform Arduino, jembatan UART nirkabel yang dikembangkan oleh saya berdasarkan modul ESP8266 yang terkenal ditambahkan ke dalamnya.  Juga untuk kenyamanan (dan secara umum ini adalah tujuan utama) menggunakan ESP yang sama, saya menulis seorang programmer untuk arduinki, yang memungkinkan Anda untuk mem-flash-nya sendiri dari jarak jauh. <br><br><img src="https://habrastorage.org/webt/y-/57/pt/y-57pte4rudizc-oitiqraysx7m.png" alt="gambar"><br><br>  Yaitu, kereta di suatu tempat yang jauh (tetapi dalam jaringan WI-FI Anda) melakukan perjalanan (ya, saya suka menulis kata ini), mengirim data dan menerima perintah, dan jika perlu, berdasarkan pesanan, ia juga dapat mengubah program dalam mikrokontroler AVR-nya.  Dengan demikian, program pada JAVA untuk PC dijalankan, berjalan yang Anda dapat menikmati kontrol dan mendapatkan telemetri primitif dalam bentuk jarak yang ditempuh (saklar buluh dan magnet pada roda). <br><br><img src="https://habrastorage.org/webt/yf/r_/nk/yfr_nk3y69gts4z4x4ubodhd7cy.png" alt="gambar"><br><br>  Selanjutnya, saya berhasil bereksperimen dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> berikutnya dengan mengendalikan kereta menggunakan smartphone - tombol, miring, dan bahkan suara.  Tetapi ketika kereta pergi ke kamar sebelah, maka bahkan suara tidak bisa mengembalikannya (tidak seperti kucing).  Dia pergi ke sana, mengetuk dinding dan furnitur, terjerat dalam kabel, tetapi selain informasi tentang jarak yang ditempuh, dia tidak mengirim apa-apa. <br><br>  Oleh karena itu, segera muncul ide untuk menyediakan Terminator organ indera di masa depan.  Salah satu opsi termudah untuk ini adalah penggunaan sonar. <br><br><img src="https://habrastorage.org/webt/yj/qh/eg/yjqhegrrkudwtrwdx5nr_ppkywo.png" alt="gambar"><br><br>  Algoritma bekerja untuk aib sederhana, kami memulai sensor dari satu depan dan pada saat yang sama beberapa mikrokontroler counter.  HC-SR04 mulai menembakkan ultrasound ke kejauhan.  Sinyal respons dari sensor melalui kabel lain memberi sinyal akhir pengukuran jarak, dan interval waktu antara awal dan respons sebanding dengan jarak yang diukur.  Oleh karena itu, pada saat ini kami memperlambat konter dan melihat berapa banyak yang masuk. <br><br>  Akurasi diperoleh hingga sekitar satu sentimeter, dan jangkauan meter hingga dua.  Dia tidak suka permukaan yang lembut dan wol (misalnya, kucing), di mana setiap sinyal gema tenggelam tanpa dapat ditarik kembali. <br><br>  <s>Area yang terpengaruh</s> sudut pandang HC-SR04 kecil, sehingga untuk mengetahui apa yang terjadi di depan dalam kerangka sudut setidaknya 90 derajat, diinginkan untuk melakukan hal berikut: <br><br><ol><li>  pasang sensor ke mesin servo dan lihat di arah yang berbeda </li><li>  menaruh beberapa sensor. </li></ol><br>  Pada awalnya, saya menerapkan opsi pertama, menempatkan sonar pada SG90 servo murah dan kereta berubah menjadi bajak.  Begitu banyak waktu yang diperlukan untuk mengambil setidaknya tiga pengukuran, jadi pada dasarnya gerobak berdiri berputar dengan servo, kemudian dengan hati-hati bergerak maju, tetapi tidak terlalu jauh (dan tiba-tiba sebuah hambatan muncul di samping), dan sekali lagi merasakan ruang di depan itu sendiri.  Meski begitu, suaranya bukan cahaya untuk Anda. <br><br>  Karena itu, tanpa basa-basi, saya menempatkan tiga sistem sonar sekaligus.  Gerobak itu memperoleh penampilan laba-laba chthonic, berhenti tumpul di depan rintangan, dan mulai menumpang mereka saat bepergian.  Tetapi otak pada akhirnya cukup untuk tidak terjebak dalam lingkungan yang ramah.  Kami harus pindah - ke otonomi dan kemajuan.  Dan di sini, tanpa indra yang berbeda, bahkan cacing nematoda akan memberi tahu Anda, Anda tidak dapat melakukannya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yjUsvUk880o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Lebih jauh, biasanya para penggemar mulai memahat pada kreasi mereka berbagai sensor baru, seperti giroskop, akselerometer, magnetometer, dan bahkan sensor KEBAKARAN (semua produk Cina yang tak bernama dalam jutaan jumlah untuk Arduino).  Dan saya juga hampir memulai sepanjang jalan yang licin ini, tetapi mengubah pikiran saya pada waktunya.  Dan saya melakukannya karena alasan ini.  Dalam perspektif terjauh, robot robot seharusnya mendapatkan penglihatan dalam bentuk kamera dan juga memahami apa yang dilihatnya.  Tetapi mikrokontroler AVR dari papan Arduino akan mengucapkan "selamat tinggal" kepada Anda pada tahap menerima video, belum lagi memprosesnya.  Dan tiba-tiba tatapanku tertuju pada smartphone tua GALAXY S7, yang sudah hancur lebur. <br><br>  Kekuatan komputasi seperti itu, delapan core, memori 4 gigabytes, dua kamera, akses ke jaringan, apa lagi yang diperlukan untuk mengubah monyet menjadi seseorang? <br><br>  Tapi kita hanya perlu desain kecil agar smartphone kita bersandar pada troli dan agar bisa dengan mudah diletakkan dan dilepas. <br><br><img src="https://habrastorage.org/webt/l6/ej/gf/l6ejgf5jxwlzkqs21pifxg-wtl8.jpeg" alt="gambar"><br><br>  Lalu saya naik ke situs pengembang Android untuk mencari tahu fitur apa saja yang bisa diberikan oleh smartphone biasa kepada kami.  Ternyata tidak kecil.  Secara teoritis Anda bisa <br><br><div class="spoiler">  <b class="spoiler_title">akses sensor sensor berikut.</b> <div class="spoiler_text">  TYPE_ACCELEROMETER <br><br>  TYPE_AMBIENT_TEMPERATURE <br><br>  TYPE_GAME_ROTATION_VECTOR <br><br>  GEOMAGNETIC_ROTATION_VECTOR <br><br>  TYPE_GRAVITY <br><br>  TYPE_GYROSCOPE <br><br>  TYPE_GYROSCOPE_UNCALIBRATED <br><br>  TYPE_HEART_BEAT <br><br>  TYPE_HEART_RATE <br><br>  TYPE_LIGHT <br><br>  TYPE_LINEAR_ACCELERATION <br><br>  TYPE_LOW_LATENCY_OFFBODY_DETECT <br><br>  TYPE_MAGNETIC_FIELD <br><br>  TYPE_MAGNETIC_FIELD_UNCALIBRATED <br><br>  TYPE_MOTION_DETECT <br><br>  TYPE_ORIENTATION <br><br>  TYPE_POSE_6DOF <br><br>  TYPE_PRESSURE <br><br>  TYPE_PROXIMITY <br><br>  TYPE_RELATIVE_HUMIDITY <br><br>  TYPE_ROTATION_VECTOR <br><br>  TYPE_SIGNIFICANT_MOTION <br><br>  TYPE_STATIONARY_DETECT <br><br>  TYPE_STEP_COUNTER <br><br>  TYPE_STEP_DETECTOR <br><br></div></div><br>  Seperti yang mereka katakan, apa yang ada di sana saja!  Dan memang, tidak banyak yang khusus untuk GALAXY S7.  Misalnya, sensor kelembaban.  Dan suhu sekitar (meskipun saya mengerti bahwa berada di dalam case, itu akan menunjukkan suhu smartphone itu sendiri).  Tetapi sensor tekanan dan cahaya hadir.  Belum lagi giroskop, akselerometer, yang menggunakannya, Anda dapat dengan mudah menentukan posisi Anda di ruang angkasa. <br><br>  Akibatnya, sebuah keputusan telah matang, biarkan smartphone menerima dan memproses semua informasi dari tingkat atas - video dan semua berbagai sensor ini.  Dan platform Arduino akan bertanggung jawab, untuk berbicara, untuk ketidaksadaran - untuk segala sesuatu yang sudah bekerja dan tidak memerlukan pengerjaan ulang, semua motor ini, sonar, buluh switch dan sebagainya. <br><br>  Karena sulit untuk men-debug program secara langsung pada smartphone, bahkan dengan UDB, saya memutuskan untuk membiarkan semuanya ditransfer ke komputer pribadi yang normal dan diproses di sana.  Dan entah bagaimana, ketika akan ada versi yang berfungsi, kami akan mengembalikan otak ke gerobak.  Kita harus memulai dari yang kecil, dan memang menarik untuk melihat transmisi video dari keranjang yang panik. <br><br>  Data dari sensor dapat dikirim dalam garis sederhana, melalui server klien primitif, tidak ada masalah dengan ini sama sekali.  Tetapi dengan transfer video, segera ada kesulitan.  Secara umum, saya membutuhkan siaran streaming real-time dari kamera ponsel cerdas ke jendela aplikasi di komputer.  Ini untuk sekarang.  Di masa depan, bukan hanya saya, tetapi semacam sistem pengenalan pola bisa menatap gambar ini di jendela.  Misalnya JAVA OpenCV.  Atau mungkin bahkan jaringan saraf dari cloud: D.  Saya tidak tahu, panggung ini masih sangat jauh.  Tapi saya ingin melihat dunia dengan "mata" truk robot. <br><br>  Semua orang tahu tentang banyak aplikasi seperti "kamera seluler" dari Google store, tempat Anda menangkap aliran video dari kamera ponsel cerdas dengan membuka browser dengan IP yang diinginkan di komputer.  Oleh karena itu, pada awalnya saya berpikir bahwa tidak akan sulit untuk menerjemahkan dari GALAXY saya sendiri (yang bukan merupakan kesalahan yang lemah), jadi pertama-tama Anda perlu memeriksa bagaimana dengan penerimaannya di komputer, mengingat bahwa saya dapat menulis entah bagaimana hanya di JAVA. <br><br>  Ternyata, dengan pemutaran video JAWA, secara halus, tidak terlalu baik.  Suatu ketika pada tahun 1997, Java Media Framework dirilis - sebuah perpustakaan yang memfasilitasi pengembangan program yang bekerja dengan audio dan video dari pencipta JAVA sendiri.  Tapi, di suatu tempat setelah 2003, baut besar diletakkan di atasnya dan sejak itu sudah 15 tahun.  Setelah beberapa percobaan, saya berhasil menjalankan satu file di jendela, saya tidak ingat yang mana (sepertinya AVI), tetapi pemandangan ini terlihat sangat menyedihkan.  File dengan ekstensi lain tidak ingin berjalan sama sekali, dalam kasus ekstrim ada satu trek audio. <br><br>  Di Internet, saya menemukan dua proyek alternatif untuk bekerja dengan video: Xuggler dan aprica VLCj.  Proyek pertama menarik dalam kemampuannya, tetapi juga sudah lama mati, tetapi yang kedua ternyata cukup hidup dan menarik dalam idenya.  Orang-orang mengambil dan diikat ke JAVA media player VLC terkenal yang terkenal.  Yaitu, aprica tidak menggunakan codec yang ditulis sendiri, tetapi menggunakan codec yang sudah jadi.  Dengan itu, Anda akan kehilangan file apa pun.  Keputusan yang bijak, tetapi yang utama adalah Anda sudah menginstal VLC player ini di komputer Anda.  Nah, siapa yang tidak memilikinya?  Namun, satu-satunya peringatan adalah bahwa Anda memiliki kedalaman bit yang sama dengan pemain dan JAWA.  Sebagai contoh, saya kemudian, dengan terkejut, mengetahui bahwa saya masih memiliki VLC 32-bit di komputer saya, tidak seperti JAVA 64-bit.  Dan setengah hari hidup hilang sia-sia. <br><br>  Pengembang Caprica menjanjikan banyak hal kepada pengguna di situs web mereka.  Dan semua format file dan peluncuran di beberapa jendela dalam aplikasi JAVA, memutar video dari You-Tube, menangkap aliran video "langsung" dan sebagainya.  Tetapi kenyataan pahit menempatkan segalanya pada tempatnya.  Tidak, mereka tidak menipu dengan file - semuanya dimainkan.  Namun sekarang video dari YouTube tidak lagi diinginkan.  Pada awalnya saya tidak mengerti mengapa, tetapi kemudian saya melihat sebuah tulisan di log yang entah bagaimana, di suatu tempat, tidak mungkin untuk menjalankan skrip lua tertentu dan segera mengingatnya: <br><blockquote>  'Kerusakan layar' laman web YouTube ini rapuh - jika YouTube mengubah struktur laman web mereka, maka VLC terkadang gagal menemukan URL streaming, saat ini terjadi, Anda harus menunggu pengembang untuk memberikan LUA baru skrip dan tunggu VLC versi baru dirilis. </blockquote>  Singkatnya, tampaknya YouTube telah mengubah struktur halaman webnya dan saya harus menunggu rilis baru.  Di sisi lain, saya memerlukan siaran video "langsung", dan tidak memutar file dari situs.  Artinya, bahkan jika skrip lua bekerja, itu tidak akan banyak membantu saya. <br><br>  Tetapi saya tidak menemukan streaming yang dijanjikan sama sekali, meskipun ada tertulis bahwa: <br><br><blockquote>  Server streaming jaringan (mis. Stasiun radio jaringan atau video on demand server); <br>  Klien streaming jaringan; </blockquote>  Mungkin Daftar Keinginan, atau mungkin dalam versi komersial, sulit dikatakan. <br><br>  Tetapi file diputar, saya ulangi, tanpa keluhan.  Misalnya, Anda dapat membuat, di sini ada ketidaksenonohan <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6yH53kRyHXk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Instalasi paket itu sendiri tidak sulit dan bahkan dijelaskan secara rinci, misalnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Benar, saya entah bagaimana dengan kikuk meresepkan variabel lingkungan dan sekarang VLC saya mulai untuk pertama kalinya dengan penundaan sepuluh detik, tetapi kemudian menyimpan apa yang dibutuhkan dalam cache dan kemudian dalam sesi saat ini dimulai tanpa jeda. <br><br>  Kemudian dalam proyek JAVA Anda, Anda meresepkan dependensi yang diperlukan dan Anda dapat mulai <s>memukau pemutar media di windows JAVA</s> untuk bekerja. <br><br>  Dengan demikian menandai perkiraan rencana kerja di sisi komputer pribadi, saya kembali ke sumber data video, ponsel Android ANDROID saya. <br><br>  Tapi di sini saya mengharapkan kekecewaan yang agak besar.  Setelah memindai beberapa situs dan bahkan manual ANDROID online, saya menemukan bahwa tidak mungkin untuk mengatur streaming secara real time menggunakan cara biasa.  Seperti di Caprica, Anda hanya dapat membaca file yang sudah direkam.  Artinya, kamera dihidupkan, MEDIA RECORDER mulai merekam ketika perlu dihentikan.  Dan kita bisa mendapatkan akses ke data (dan transfernya) hanya setelah berhenti. <br><br>  Saya menemukan konfirmasi kesimpulan saya di sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> kuno.  Benar-benar ada petunjuk bahwa seseorang pernah menipu Android untuk berpikir bahwa itu sedang menulis ke file, tetapi kenyataannya mereka menyelipkan buffer.  Tetapi bagaimanapun juga, seperti yang sudah dijelaskan sebelumnya, saya tidak bisa menangkap aliran video seperti itu di sisi PC dalam aplikasi JAVA. <br><br>  Oleh karena itu, keputusan sederhana, ek, <u>sementara</u> (saya ingin tekankan) dibuat - untuk mengirim streaming video dari kamera menjadi beberapa bagian selama dua detik.  Bukan bajak, tentu saja, tetapi bajak sudah cukup. <br><br>  Setelah menetapkan keputusan ini, saya mulai menguasai kelas CAMERA dan MEDIA RECORDER.  Ada beberapa contoh kode di jaringan untuk meluncurkan kamera dan merekam file video, tetapi untuk beberapa alasan tidak ada yang bekerja untuk saya.  Baik pada emulator, maupun pada perangkat nyata.  Ternyata alasannya terletak pada izin, yaitu izin.  Ternyata contoh kode ditulis pada masa itu ketika Android masih bebas dan programmer dapat melakukan apa pun yang dia inginkan jika dia menulis semua izin yang diperlukan dalam manifes.  Tetapi versi OC saya saat ini tidak mengizinkan ini.  Pertama, Anda harus memberi izin kepada pengguna untuk menulis file dan menghidupkan kamera segera setelah memulai aplikasi.  Ini membebani saya aktivitas ekstra, yaitu dalam Aktivitas. <br><br><div class="spoiler">  <b class="spoiler_title">Kelas MainActivity.java</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.Manifest; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Intent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.pm.PackageManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.Camera; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaRecorder; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.AsyncTask; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.support.v4.app.ActivityCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.support.v4.content.ContextCompat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.support.v7.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Toast; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ Camera camera; MediaRecorder mediaRecorder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MainActivity m; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> Camera_granted; File videoFile; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ContextCompat.checkSelfPermission(MainActivity.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) ||(ContextCompat.checkSelfPermission(MainActivity.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ) <span class="hljs-comment"><span class="hljs-comment">//ask for authorisation { ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE}, 50); } if ((ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED)&amp; (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)) { Toast.makeText(MainActivity.this,"", Toast.LENGTH_SHORT).show();} m=this; MyTask mt = new MyTask(); mt.execute(); } } class MyTask extends AsyncTask&lt;Void, Void, Void&gt; { @Override protected void onPreExecute() { super.onPreExecute(); } @Override protected Void doInBackground(Void... params) { boolean ready = false; while(!ready) { if ((ContextCompat.checkSelfPermission(MainActivity.m, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED)&amp; (ContextCompat.checkSelfPermission(MainActivity.m, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED)) { System.out.println(" "); ready=true; } } return null; } @Override protected void onPostExecute(Void result) { Toast.makeText(MainActivity.m,"", Toast.LENGTH_SHORT).show(); Intent intent=new Intent(MainActivity.m,CameraActivity.class); //   : MainActivity.m.startActivity(intent); } }</span></span></code> </pre> <br></div></div><br>  Setelah itu, semuanya berjalan dengan baik dan kode kerja berikut muncul.  Aktivitas kedua dari kelas Camera_Activity bertanggung jawab untuk bekerja dengan kamera dan merekam file video.  Kelas Http_server untuk penerusan (nama, tentu saja, tidak benar, tetapi ternyata secara historis).  Kode ini sederhana, di mana pun ada penjelasan. <br><br><img src="https://habrastorage.org/webt/dv/-z/l1/dv-zl1u_fxzjus5hcacejbzhudc.png"><br><br>  Semuanya benar-benar terletak di Github.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan</a> <br><br><div class="spoiler">  <b class="spoiler_title">Camera_Activity</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.Camera; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.media.MediaRecorder; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.AsyncTask; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Bundle; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.os.Environment; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.support.annotation.Nullable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.support.v7.app.AppCompatActivity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.SurfaceHolder; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.SurfaceView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.view.View; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.Button; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.widget.TextView; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.ServerSocket; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.SensorEvent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.SensorEventListener; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.SensorManager; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.content.Context; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> android.hardware.Sensor; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> android.hardware.Camera.getNumberOfCameras; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.BufferedOutputStream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.OutputStreamWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.PrintWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.Socket; <span class="hljs-comment"><span class="hljs-comment">/** * Created by m on 01.02.2019. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CameraActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SensorEventListener</span></span></span><span class="hljs-class"> </span></span>{ SurfaceView surfaceView; TextView mTextView; Button mStart; Button mStop; Camera camera; MediaRecorder mediaRecorder; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ServerSocket ss; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ServerSocket ss2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> MainActivity m; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> stopCamera=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> File videoFile1; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> File videoFile2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> File videoFile3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SensorManager mSensorManager; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Sensor mAxeleration, mLight,mRotation,mHumidity,mPressure,mTemperature; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ax; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ay; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> az; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> light; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> hum; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> press; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tempr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String Sensors; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE); <span class="hljs-comment"><span class="hljs-comment">//    mAxeleration = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); //    mSensorManager.registerListener(this, mAxeleration, SensorManager.SENSOR_DELAY_NORMAL); mLight = mSensorManager.getDefaultSensor(Sensor.TYPE_LIGHT); mSensorManager.registerListener(this, mLight, SensorManager.SENSOR_DELAY_NORMAL); mRotation = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION); mSensorManager.registerListener(this, mRotation, SensorManager.SENSOR_DELAY_NORMAL); mHumidity = mSensorManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION); mSensorManager.registerListener(this, mHumidity, SensorManager.SENSOR_DELAY_NORMAL); mPressure = mSensorManager.getDefaultSensor(Sensor.TYPE_PRESSURE); mSensorManager.registerListener(this, mPressure, SensorManager.SENSOR_DELAY_NORMAL); mTemperature = mSensorManager.getDefaultSensor(Sensor.TYPE_AMBIENT_TEMPERATURE); mSensorManager.registerListener(this, mTemperature, SensorManager.SENSOR_DELAY_NORMAL); setContentView(R.layout.camera); // videoFile = new File(Environment.getExternalStorageDirectory() + File.separator+ Environment.DIRECTORY_DCIM + File.separator + "test.3gp"); videoFile1 = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "test1.3gp"); videoFile2 = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "test2.3gp"); videoFile3 = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "test3.3gp"); // videoFile4 = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), "testOUT.3gp"); // File file = new File(Environment.getExternalStorageDirectory(),VIDEO_PATH_NAME);//   // "touch" the file try { videoFile1.createNewFile(); videoFile2.createNewFile(); videoFile3.createNewFile(); } catch (IOException e) { } mStart = (Button) findViewById(R.id.btnStartRecord); mStop = (Button) findViewById(R.id.btnStopRecord); surfaceView = (SurfaceView) findViewById(R.id.surfaceView); mTextView = (TextView) findViewById(R.id.textView); SurfaceHolder holder = surfaceView.getHolder(); holder.addCallback(new SurfaceHolder.Callback() { @Override public void surfaceCreated(SurfaceHolder holder) { try { camera.setPreviewDisplay(holder); camera.startPreview(); } catch (Exception e) { e.printStackTrace(); } } @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { } @Override public void surfaceDestroyed(SurfaceHolder holder) { } }); mStart.setOnClickListener(new View.OnClickListener() { public void onClick(View v){ System.out.println("  "); //    WriteVideo WV = new WriteVideo(); WV.start(); mStart.setClickable(false); mStop.setClickable(true); Http_server.File_is_sent=true; new ServerCreation().execute();//      } } ); mStop.setOnClickListener(new View.OnClickListener() { public void onClick(View v){ stopCamera = false; // mTextView.setText(" "); releaseMediaRecorder(); releaseCamera(); mStart.setClickable(true); mStop.setClickable(false); System.out.println("  "); Http_server.File_is_sent=true; } } ); } @Override public void onAccuracyChanged(Sensor sensor, int accuracy) { //    } @Override public void onSensorChanged(SensorEvent event) { //   switch (event.sensor.getType()) { case Sensor.TYPE_ACCELEROMETER: ax = (int)(event.values[0] * 9); // + -  az = (int)(event.values[2] * 9);//  +  -  // System.out.println(" = "+ ax + "  = " + az); break; case Sensor.TYPE_LIGHT: light = event.values[0]; // System.out.println(" = "+ light); break; case Sensor.TYPE_ORIENTATION: x = (int)event.values[0]; y = (int)event.values[1]+90; //  +  -  z = (int)event.values[2]; // + -  // System.out.println("x = "+ x + " y = " + y+ " z= "+ z); break; case Sensor.TYPE_LINEAR_ACCELERATION: hum = event.values[2]; int k = (int)(hum*100); hum = - (double)k;//   ,    /2 // System.out.println(hum); break; case Sensor.TYPE_PRESSURE: press = event.values[0]*760/10.1325; int i = (int) press; press = (double)i/100; // System.out.println(press); break; case Sensor.TYPE_AMBIENT_TEMPERATURE: tempr = event.values[0]; System.out.println(tempr); break; } Sensors = " tangaz_1 "+ az+ " kren_1 " + ax + " tangaz_2 "+ y + " kren_2 " + z + " forvard_accel "+ hum + " light " + light+ " "; // System.out.println(Sensors); } @Override protected void onResume() { super.onResume(); releaseCamera(); releaseMediaRecorder(); int t = getNumberOfCameras(); mTextView.setText(""+t); if(camera == null) { camera = Camera.open(); // camera.unlock(); } else{ } } @Override protected void onPause() { super.onPause(); } @Override protected void onStop() { super.onStop(); releaseCamera(); releaseMediaRecorder(); } private boolean prepareVideoRecorder() { if (mediaRecorder==null) {mediaRecorder = new MediaRecorder();} camera.unlock(); mediaRecorder.setCamera(camera); mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); switch (count) { case 1: mediaRecorder.setOutputFile(videoFile1.getAbsolutePath()); break; case 2: mediaRecorder.setOutputFile(videoFile2.getAbsolutePath()); break; case 3: mediaRecorder.setOutputFile(videoFile3.getAbsolutePath()); break; } mediaRecorder.setPreviewDisplay(surfaceView.getHolder().getSurface()); mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP); //mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4); mediaRecorder.setVideoSize(640,480); mediaRecorder.setOrientationHint(90);//    ,     mediaRecorder.setVideoFrameRate(30); mediaRecorder.setVideoEncoder(1); try { mediaRecorder.prepare(); } catch (Exception e) { e.printStackTrace(); releaseMediaRecorder(); return false; } return true; } private void releaseMediaRecorder() { if (mediaRecorder != null) { mediaRecorder.release(); mediaRecorder = null; if (camera != null) { // camera.lock();//         } } } public void releaseCamera() { if (camera != null) { // camera.setPreviewCallback(null); // SurfaceView.getHolder().removeCallback(SurfaceView); camera.release(); camera = null; } } private class WriteVideo extends Thread{ public void run () { stopCamera=true; do{ // releaseMediaRecorder(); // releaseCamera(); if(camera == null) { camera = Camera.open(Camera.CameraInfo.CAMERA_FACING_BACK); } System.out.println(""); if (prepareVideoRecorder()) { mediaRecorder.start(); } else { releaseMediaRecorder(); } try { Thread.sleep(2000);//     } catch (Exception e) { } count++; if(count==3){count=1;}// 4 if (mediaRecorder != null) { releaseMediaRecorder(); } System.out.println(""); File f=null; switch (count) { case 1: f = videoFile2;// 3 break; case 2: f = videoFile1;//1 break; case 3: f = videoFile2; break; } try { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(f)); data = new byte[bis.available()]; bis.read(data); bis.close(); }catch (Exception e) { System.out.println(e); } if(Http_server.File_is_sent)//       { System.out.println("  "); new HTTP_Server_Calling().execute(); Http_server.File_is_sent=false; } } while(stopCamera); if (mediaRecorder != null) { System.out.println(""); } } } } class ServerCreation extends AsyncTask&lt;Void, Void, Void&gt; { @Override protected void onPreExecute() { super.onPreExecute(); } @Override protected Void doInBackground(Void... params) { try { CameraActivity.ss = new ServerSocket(40001);//      System.out.println("  "); new Http_server(CameraActivity.ss.accept()); CameraActivity.ss2 = new ServerSocket(40002);//      }catch (Exception e) { System.out.println(e); System.out.println("   "); } new HTTP_Server_Calling2().start(); return null; } @Override protected void onPostExecute(Void result) { } } class HTTP_Server_Calling extends AsyncTask&lt;Void, Void, Void&gt; { @Override protected void onPreExecute() { super.onPreExecute(); } @Override protected Void doInBackground(Void... params) { try { new Http_server(CameraActivity.ss.accept()); } catch (Exception e) { System.out.println(e); } return null; } @Override protected void onPostExecute(Void result) { } } class HTTP_Server_Calling2 extends Thread//           { public void run() { while (CameraActivity.stopCamera) { try { Thread.sleep(500);//      new Http_server_Sensors(CameraActivity.ss2.accept()); } catch (Exception e) { System.out.println(e); } } } } class Http_server extends Thread { public Socket socket; public static volatile boolean File_is_sent=true; Http_server(Socket s) { System.out.println("  "); socket = s; setPriority(MAX_PRIORITY); start(); } public void run() { try { System.out.println("    "); BufferedOutputStream bos = new BufferedOutputStream((socket.getOutputStream())); bos.write(CameraActivity.data); bos.flush(); bos.close(); socket.close(); } catch (Exception e) { System.out.println(e); } File_is_sent = true; } } public class Http_server_Sensors extends Thread { public Socket socket; PrintWriter pw; Http_server_Sensors(Socket s) { socket = s; setPriority(MAX_PRIORITY); start(); } public void run() { try { pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true);//    System.out.println(CameraActivity.Sensors); pw.println(CameraActivity.Sensors);//  pw.flush(); pw.close(); socket.close(); } catch (Exception e) { System.out.println(e); } } }</span></span></code> </pre><br></div></div><br><br>  Inti dari program setelah memulai dan menyalakan kamera adalah sebagai berikut: <br>  menulis video selama dua detik ke file pertama, <br>  kami menulis video selama dua detik ke file kedua, dan sementara itu kami mengirim file pertama melalui TCP-IP melalui WI-FI lokal ke komputer, <br>  tulis file pertama lagi, dan sementara itu kirim yang kedua, <br>  dan sebagainya. <br><br>  Kemudian siklus berulang sampai tombol "berhenti" ditekan atau baterai ponsel pintar mati.  Pada prinsipnya, dimungkinkan untuk menerapkan analog dari tombol yang ditekan, menggunakan perintah dari komputer, juga melalui TCP, ini tidak sulit. <br><br>  Pada awalnya, buffer video, untuk berjaga-jaga, terdiri dari tiga file format 3GP (kami menulis yang pertama, mengirim yang ketiga, kami menulis yang kedua, kami mengirim yang pertama, kami menulis yang ketiga, kami mengirim yang kedua), tetapi kemudian ternyata kedua file tersebut cukup cukup (merekam dan saling mengirim satu sama lain jangan ikut campur). <br><br>  Dengan resolusi kamera 640 x 480, file diperoleh, sekitar 200-300 kB, yang cukup sulit untuk router saya.  Saya belum repot-repot dengan suaranya, tetapi semuanya tampak sederhana di sana: Anda memasang enkoder audio yang diperlukan, bitrate, jumlah saluran dan sejenisnya. <br><br>  Beberapa saat kemudian, ketika saya melakukan debug pada transfer video, saya menambahkan kode juga dengan mengirimkan informasi dari sensor smartphone.  Semuanya ditransmisikan sepele dalam satu baris, tetapi saya tidak bisa mentransfernya melalui soket yang sama dengan video.  Rupanya, kelas-kelas untuk mentransmisikan string PrintWriter dan mentransmisikan data biner. BufferedOutputStream menggunakan aliran yang berbeda, tetapi kemudian mereka memiliki satu buffer output, di mana mereka berhasil merusak satu sama lain.  Akibatnya, video mulai glitch dan hancur.  Selain itu, file video ditransmisikan setiap dua detik sekali, dan untuk sensor, interval ini terlalu besar.  Oleh karena itu, diputuskan untuk mendistribusikannya di soket yang berbeda sehingga tidak saling mengganggu.  Untuk alasan ini, kelas baru Http_server_Sensors telah muncul. <br><br>  Jadi, kami mengatur pengiriman, sekarang lagi kami akan kembali ke sisi penerima gelap. <br><br>  Seperti yang telah kita lihat dari contoh pertama, memutar file video dalam aplikasi JAVA menggunakan pemutar VLC sekarang tidak menimbulkan masalah.  Yang utama adalah mendapatkan file-file ini. <br><br>  Program demo berikut bertanggung jawab untuk ini. <br><br><div class="spoiler">  <b class="spoiler_title">Pemutar video</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.BorderLayout; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.event.ActionEvent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.event.ActionListener; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.event.WindowAdapter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.event.WindowEvent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.JButton; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.JFrame; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.JOptionPane; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.JPanel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.SwingUtilities; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uk.co.caprica.vlcj.component.EmbeddedMediaPlayerComponent; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uk.co.caprica.vlcj.discovery.NativeDiscovery; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uk.co.caprica.vlcj.player.MediaPlayer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uk.co.caprica.vlcj.player.MediaPlayerEventAdapter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.net.Socket; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoPlayer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JFrame frame; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> EmbeddedMediaPlayerComponent mediaPlayerComponent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JButton pauseButton; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JButton rewindButton; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> JButton skipButton; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String mr1, mr2; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> playing_finished = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> File_1_play_starting = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> File_1_play_finished = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> File_2_play_starting = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> File_2_play_finished = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//192.168.1.128 public static void main(final String[] args) { new NativeDiscovery().discover(); mr1 = "D:\\test1.3gp"; mr2 = "D:\\test2.3gp"; SwingUtilities.invokeLater(new Runnable() { @Override public void run() { VideoPlayer vp = new VideoPlayer(); vp.mediaPlayerComponent.getMediaPlayer().setPlaySubItems(true); VideoPlayer.playing_finished=false; new Control().start();//   // while (!Http_client.File_ready) { // System.out.println(""); try { Thread.sleep(100); } catch (Exception e) { } } // while (true) { playing_finished = false; } // System.out.println("  1"); } }); } public VideoPlayer() { frame = new JFrame("My First Media Player"); frame.setBounds(100, 100, 600, 400); frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE); frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.out.println(e); mediaPlayerComponent.release(); System.exit(0); } }); JPanel contentPane = new JPanel(); contentPane.setLayout(new BorderLayout()); mediaPlayerComponent = new EmbeddedMediaPlayerComponent(); contentPane.add(mediaPlayerComponent, BorderLayout.CENTER); frame.setContentPane(contentPane); JPanel controlsPane = new JPanel(); pauseButton = new JButton("Pause"); controlsPane.add(pauseButton); rewindButton = new JButton("Rewind"); controlsPane.add(rewindButton); skipButton = new JButton("Skip"); controlsPane.add(skipButton); contentPane.add(controlsPane, BorderLayout.SOUTH); pauseButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { mediaPlayerComponent.getMediaPlayer().pause(); } }); rewindButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { mediaPlayerComponent.getMediaPlayer().skip(-10000); } }); skipButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { mediaPlayerComponent.getMediaPlayer().skip(10000); } }); mediaPlayerComponent.getMediaPlayer().addMediaPlayerEventListener(new MediaPlayerEventAdapter() { @Override public void playing(MediaPlayer mediaPlayer) { SwingUtilities.invokeLater(new Runnable() { @Override public void run() { frame.setTitle(String.format( "My First Media Player - %s", mediaPlayerComponent.getMediaPlayer() )); } }); } @Override public void finished(MediaPlayer mediaPlayer) { SwingUtilities.invokeLater(new Runnable() { @Override public void run() { playing_finished = true; System.out.println("finished " + playing_finished); //closeWindow(); } }); } @Override public void error(MediaPlayer mediaPlayer) { SwingUtilities.invokeLater(new Runnable() { @Override public void run() { JOptionPane.showMessageDialog( frame, "Failed to play media", "Error", JOptionPane.ERROR_MESSAGE ); closeWindow(); } }); } }); frame.setVisible(true); //mediaPlayerComponent.getMediaPlayer(); } public void start(String mrl) { mediaPlayerComponent.getMediaPlayer().setPlaySubItems(true); mediaPlayerComponent.getMediaPlayer().prepareMedia(mrl); //mediaPlayerComponent.getMediaPlayer().parseMedia(); mediaPlayerComponent.getMediaPlayer().playMedia(mrl); // mediaPlayerComponent. } public void closeWindow() { frame.dispatchEvent(new WindowEvent(frame, WindowEvent.WINDOW_CLOSING)); } } class PlayFile { public static void run(int number) { if (number==1) { VideoPlayer.mediaPlayerComponent.getMediaPlayer().prepareMedia(VideoPlayer.mr1); System.out.println("  1"); VideoPlayer.mediaPlayerComponent.getMediaPlayer().start(); VideoPlayer.mediaPlayerComponent.getMediaPlayer().playMedia(VideoPlayer.mr1); VideoPlayer.File_1_play_starting = true; VideoPlayer.File_1_play_finished = false; while (!VideoPlayer.playing_finished) {//      try { Thread.sleep(1); } catch (Exception e) { } } VideoPlayer.mediaPlayerComponent.getMediaPlayer().stop(); VideoPlayer.playing_finished = false; VideoPlayer.File_1_play_starting = false; VideoPlayer.File_1_play_finished = true; } { try { Thread.sleep(10); } catch (Exception e) { } } if (number==2) { VideoPlayer.mediaPlayerComponent.getMediaPlayer().prepareMedia(VideoPlayer.mr2); System.out.println("  2"); VideoPlayer.mediaPlayerComponent.getMediaPlayer().start(); VideoPlayer.mediaPlayerComponent.getMediaPlayer().playMedia(VideoPlayer.mr2); VideoPlayer.File_2_play_starting = true; VideoPlayer.File_2_play_finished = false; while (!VideoPlayer.playing_finished) { try { Thread.sleep(1); } catch (Exception e) { } } VideoPlayer.mediaPlayerComponent.getMediaPlayer().stop(); VideoPlayer.playing_finished = false; VideoPlayer.File_2_play_starting = false; VideoPlayer.File_2_play_finished = true; } { try { Thread.sleep(10); } catch (Exception e) { } } } } public class Control extends Thread{ public static boolean P_for_play_1=false; public static boolean P_for_play_2=false; public void run() { // new Http_client(1).start(); while (!Http_client.File1_reception_complete) { try { Thread.sleep(1); } catch (Exception e) { } } while (true) { new Http_client(2).start(); PlayFile.run(1); while (!VideoPlayer.File_1_play_finished) { try { Thread.sleep(1); } catch (Exception e) { } } while (!Http_client.File2_reception_complete) { try { Thread.sleep(1); } catch (Exception e) { } } new Http_client(1).start(); PlayFile.run(2); while (!VideoPlayer.File_2_play_finished) { try { Thread.sleep(1); } catch (Exception e) { } } while (!Http_client.File1_reception_complete) { try { Thread.sleep(1); } catch (Exception e) { } } //PlayFile.run(1); } } } public class Http_client extends Thread { public static boolean File1_starts_writing=false; public static boolean File1_reception_complete=false; public static boolean File2_starts_writing=false; public static boolean File2_reception_complete=false; public int Number; public BufferedOutputStream bos; Http_client(int Number) { this.Number = Number; } public void run(){ try { Socket socket= new Socket("192.168.1.128", 40001); // System.out.println(" "); // PrintWriter pw = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()), true); // pw.println("ready");// Greetings with CLIENT // System.out.println(" "); BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); if (Number ==1) { File1_starts_writing=true; File1_reception_complete=false; System.out.println("  1,    2"); bos = new BufferedOutputStream(new FileOutputStream(VideoPlayer.mr1)); byte[] buffer = new byte[32768]; while (true) { //     int readBytesCount = bis.read(buffer); if (readBytesCount == -1) { //   break; } if (readBytesCount &gt; 0) { //    - ,   bos.write(buffer, 0, readBytesCount); } } System.out.println(" "); System.out.println(" "); bos.flush(); bos.close(); File1_starts_writing=false; File1_reception_complete=true; } if (Number==2) { File2_starts_writing=true; File2_reception_complete=false; System.out.println("  2,    1"); bos = new BufferedOutputStream(new FileOutputStream(VideoPlayer.mr2)); byte[] buffer = new byte[32768]; while (true) { //     int readBytesCount = bis.read(buffer); if (readBytesCount == -1) { //   break; } if (readBytesCount &gt; 0) { //    - ,   bos.write(buffer, 0, readBytesCount); } } System.out.println(" "); System.out.println(" "); bos.flush(); bos.close(); File2_starts_writing=false; File2_reception_complete=true; } socket.close(); // pw.close(); bis.close(); } catch(Exception e){ System.out.println(e); System.out.println("gfgfg"); } try { Thread.sleep(10); } catch (Exception e) { } } }</span></span></code> </pre></div></div><br><br>  Esensinya sederhana.  Klien TCP diluncurkan, yang mulai menunggu server siap pada smartphone.  Setelah menerima file pertama, itu mulai diputar segera dan file nomor dua diharapkan secara paralel.  Selanjutnya, diharapkan akhir penerimaan file kedua, atau akhir memainkan yang pertama.  Yang terbaik dari semuanya, tentu saja, <s>tiga bintang</s> , ketika file mengunduh lebih cepat daripada yang dimainkannya.  Jika Anda kehilangan file pertama, tetapi belum menerima yang kedua, maka semuanya menunggu ... Kami akan menunjukkan layar hitam.  Jika tidak, segera mulai putar file kedua dan unduh secara bersamaan file pertama lagi. <br>  Saya memiliki harapan yang tidak jelas bahwa jeda antara beralih file yang diputar akan kurang dari waktu reaksi mata manusia, tetapi itu tidak terwujud.  Santai, tentu saja, VLC ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BaY3gD6RBdU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Alhasil, kami mendapatkan semacam video diskontinyu keji (trilobite pertama, tampaknya, melihat dunia seperti ini), di mana penyesuaian ketajaman terus terjadi.  Dan kita harus memperhitungkan bahwa videonya juga terlambat selama dua detik.  Singkatnya, dalam produksi saya tidak merekomendasikan untuk menyebarkannya.  Tapi saya kekurangan ikan dan trilobite, seperti yang mereka katakan ... <br><br>  Meringkas hal di atas, kita dapat benar-benar mengatakan bahwa: <br><br>  Mengirim video dalam jumlah banyak pada dasarnya tidak beroperasi dan hanya dapat berguna dalam kasus-kasus di mana video cukup panjang dan Anda tidak perlu reaksi kedua terhadap apa yang terjadi. <br><br>  Transmisi video melalui TCP-IP juga merupakan ide yang salah, apa pun yang dikatakan beberapa orang tentang Habr tentang kecepatan transfer data menggunakan protokol ini (yang seharusnya lebih cepat daripada UDP).  Tentu saja, intranet nirkabel modern memiliki karakteristik yang baik untuk menyediakan jabat tangan berkesinambungan dari server dan klien TCP, dan TCP itu sendiri tampaknya telah ditingkatkan untuk data yang panjang, tetapi tetap saja colokan di antara pemutaran video fokus, seperti yang Anda lihat di demo, muncul secara berkala. <br><br>  Tapi, setidaknya untuk masa depan, pemikiran berikut muncul: <br><br><ol><li>  mengirim frame-by-frame (bukan video, tetapi foto) melalui UDP, tetapi mengontrol informasi melalui TCP, </li><li>  drive bingkai foto semua melalui UDP tetapi dengan sinyal sinkronisasi di saluran yang sama. </li></ol><br>  Tentu saja, sejauh ini ada lebih banyak pertanyaan daripada jawaban.  Apakah ada kecepatan penerimaan yang cukup di JAVA dengan tingkat abstraksi dalam bekerja dengan jaringan dan gambar?  Apakah mungkin untuk melakukan 30 pemotretan normal per detik di tingkat yang dapat saya akses di Android?  Apakah saya harus memetiknya sebelum mengirim untuk mengurangi bitrate?  Lalu apakah JAVA cukup untuk pengemasan dan pembongkaran?  Dan jika, tiba-tiba, sesuatu berhasil, apakah mungkin untuk melalui langkah berikutnya, untuk mengacaukan sistem visi komputer JAVA OpenCV di sini?  Dirinya sendiri, tentu saja, selalu menarik untuk menonton video streaming dari lantai, tetapi kita tidak boleh melupakan tujuan tertinggi - robot robot dengan kecerdasan semut! <br><br>  Tapi, sambil memiliki apa yang kita miliki, kita akan kembali ke troli saat ini.  Program lama dari artikel sebelum terakhir untuk mikrokontroler AVR pada platform Arduino tidak banyak berubah, hanya saja pilihan percabangan telah ditambahkan - mengemudi secara otonom atau dikendalikan oleh operator.  Data yang ditransmisikan oleh kereta (spinal cord) melalui WIFI adalah sama - jarak yang ditempuh.  Beberapa saat kemudian, saya juga memasang transfer suhu dari elemen kritis - driver motor.  Semua ini dikirim dan diterima pertama kali oleh UART, dan sudah ketika memasuki jaringan melalui UDP.  Saya tidak memberikan kode, semua analisis lengkap dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> sebelum yang terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br><br><img src="https://habrastorage.org/webt/zh/gb/vz/zhgbvzhttcqg7o_la1sabrmw2gy.png"><br><br>  Untuk dua motor itu (pengemudi) masih cukup kurang lebih, tetapi dengan empat setelah beberapa saat itu terlalu panas ke keadaan tidak beroperasi.  Pada awalnya saya mencoba menggunakan sensor suhu analog paling sederhana berdasarkan dioda zener, seperti LM335, tetapi tidak ada yang datang darinya.  Singkatnya, saya tidak memiliki sumber tegangan referensi, ION.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan menangkap millivolt dengan baterai rendah tidak masuk akal. Ngomong-ngomong, tentang baterai - ketika saya lelah terus-menerus melepas dan memasukkan kembali baterai lithium 14500 untuk mengisi ulang, saya hanya mengambil baterai cadangan dari obeng dan gerobak mulai mengemudi terus menerus selama satu setengah jam, ditambah lagi memiliki tampilan dan berat yang mengancam (ya, itu ada pada baterai ini) "Mata"). Oleh karena itu, untuk mengukur suhu, saya memasang giroskop-akselerometer yang salah berdasarkan L3G4200D. Untungnya, dia juga mengukur suhu dan mengirimkannya melalui bus I2C.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponsel cerdas yang duduk di belakang baterai dan di atas mata gema-sonar mentransmisikan aliran video, pembacaan akselerometer (Anda dapat menggunakannya untuk memiringkan gerobak dan lemparan gerobak ketika sedang berdiri), menggulung dan melempar dalam derajat dalam dinamika yang sudah dihitung oleh smartphone itu sendiri (pilihan yang sangat nyaman) , percepatan linier dalam arah perjalanan, penerangan. Secara umum, tentu saja, Anda dapat mentransfer segala sesuatu yang dapat diukur ponsel cerdas Anda dari tekanan udara ke arah ke utara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, aplikasi di JAVA memperoleh bentuk berikut: </font></font><br><br><img src="https://habrastorage.org/webt/do/6y/oe/do6yoema_7rnzm9z38yfijhzv14.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang lucu adalah bahwa itu benar-benar terlihat seperti panel kontrol penjelajah bulan Soviet, hanya saja saya memiliki layar TV di samping, dan mereka memilikinya di tengah.</font></font><br><br><img src="https://habrastorage.org/webt/hw/ql/tu/hwqltuwvxsplpvdat2pcokifzye.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat Anda menyalakannya, sambungkan terlebih dahulu ke keranjang dan smartphone di atasnya, pilih mode kontrol manual atau otonomi penuh - dan pergi! Sampai jendela suhu pengemudi berubah menjadi kuning dan kemudian berubah menjadi merah. Grafik! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sesuatu seperti ini terlihat hidup.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AaMWKKeBff8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak membawa program ke sini, karena seperti biasa, membangun windows membutuhkan 95% dari kode. </font><font style="vertical-align: inherit;">Itu dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini. </font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di masa depan, otak (smartphone) harus belajar mentransfer video normal (dan bukan seperti sekarang) ke komputer, di mana ia harus dikenali dengan cara yang baik (untuk saat ini, tujuannya adalah membangun peta ruang di lantai dan menentukan lokasinya). </font><font style="vertical-align: inherit;">Yah, dan sudah di bawah komunisme, saya ingin port kembali ke smartphone saya sehingga dia tidak membutuhkan komputer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika setidaknya ada sesuatu yang berhasil, saya pasti akan mempostingnya.</font></font> Terima kasih atas perhatian anda </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448516/">https://habr.com/ru/post/id448516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448498/index.html">"Russia 404": Seberapa banyak internet gratis yang tersisa untuk hidup</a></li>
<li><a href="../id448500/index.html">Memecahkan Crackme sederhana untuk Sega Mega Drive</a></li>
<li><a href="../id448504/index.html">Mereka mengumpulkan untuk semua orang "Habrom" buku referensi "Oleh siapa itu diterbitkan ..." untuk paspor. Unduh untuk kesehatan</a></li>
<li><a href="../id448506/index.html">Matrix berusia 20 tahun: bagaimana Wachowski membuat cyberpunk, yang menentukan agenda untuk seluruh generasi</a></li>
<li><a href="../id448510/index.html">Acer in 2019: bagaimana jika Anda menghapus semua lalat dari laptop gaming</a></li>
<li><a href="../id448518/index.html">Bagaimana cara melihat lubang hitam?</a></li>
<li><a href="../id448522/index.html">Pembuatan konfigurasi untuk nginx, riwayat satu permintaan tarik</a></li>
<li><a href="../id448524/index.html">Ilmuwan Israel untuk pertama kalinya di dunia mencetak hati yang hidup</a></li>
<li><a href="../id448528/index.html">Layanan VPN Wireguard Gratis di AWS</a></li>
<li><a href="../id448530/index.html">Bagaimana Megaphone tidur di langganan seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>