<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍂 ♟️ 🕺🏽 Index bitmap dans Go: vitesse de recherche incroyable 📔 🤘🏼 🐖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon nom est Marko et j'ai donné une conférence à Gophercon Russie cette année sur un type d'index très intéressant appelé "index bitmap". Je voulais l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index bitmap dans Go: vitesse de recherche incroyable</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Mon nom est Marko et j'ai donné une conférence à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gophercon Russie</a> cette année sur un type d'index très intéressant appelé "index bitmap".  Je voulais le partager avec la communauté, non seulement au format vidéo, mais aussi en tant qu'article.  C'est une version anglaise et vous pouvez lire le russe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Profitez-en! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Des documents supplémentaires, des diapositives et tout le code source peuvent être trouvés ici: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Enregistrement vidéo original: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Commençons! <br><br><h2>  Présentation </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Aujourd'hui, je vais parler de <br><br><ul><li>  Quels sont les index. <br></li><li>  Qu'est-ce qu'un index bitmap; <br></li><li>  Où il est utilisé.  Pourquoi il n'est pas utilisé là où il n'est pas utilisé. <br></li><li>  Nous allons voir une implémentation simple dans Go et ensuite essayer le compilateur. <br></li><li>  Ensuite, nous allons examiner une implémentation un peu moins simple, mais sensiblement plus rapide dans l'assemblage Go. <br></li><li>  Et après cela, je vais aborder les "problèmes" des index bitmap un par un. <br></li><li>  Et enfin, nous verrons quelles sont les solutions existantes. <br></li></ul><br><h2>  Quels sont donc les index? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Un index est une structure de données distincte qui est mise à jour en plus des données principales, utilisée pour accélérer les demandes de recherche.  Sans index, la recherche impliquerait de parcourir toutes les données (dans un processus également appelé «analyse complète») et ce processus a une complexité algorithmique linéaire.  Mais les bases de données contiennent généralement d'énormes quantités de données, de sorte que la complexité linéaire est trop lente.  Idéalement, nous souhaiterions atteindre des vitesses de complexité logarithmique voire constante. <br><br>  Il s'agit d'un sujet énorme et complexe impliquant de nombreux compromis, mais en revenant sur des décennies de mise en œuvre de bases de données et de recherche, je dirais qu'il n'y a que quelques approches couramment utilisées: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Tout d'abord, réduit la zone de recherche en coupant la zone entière en parties plus petites, hiérarchiquement. <br><br>  Généralement, cela est réalisé en utilisant des arbres.  C'est comme avoir des boîtes de boîtes dans votre garde-robe.  Chaque boîte contient des matériaux qui sont ensuite triés dans des boîtes plus petites, chacune pour une utilisation spécifique.  Si nous avons besoin de matériel, nous ferions mieux de chercher la case intitulée "matériel" au lieu d'une case intitulée "cookies". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  La seconde consiste à localiser instantanément un élément ou un groupe d'éléments spécifique comme dans les cartes de hachage ou les index inversés.  L'utilisation de cartes de hachage est similaire à l'exemple précédent, mais vous utilisez de nombreuses petites boîtes qui ne contiennent pas de boîtes elles-mêmes, mais plutôt des éléments finaux. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  La troisième approche supprime la nécessité de rechercher du tout comme dans les filtres à fleurs ou les filtres à coucou.  Les filtres Bloom peuvent vous donner une réponse tout de suite et vous faire gagner du temps autrement consacré à la recherche. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  Le dernier accélère la recherche en faisant un meilleur usage de nos capacités matérielles comme dans les index bitmap.  Les indices bitmap impliquent parfois de parcourir l'intégralité de l'index, oui, mais cela se fait de manière très efficace. <br><br>  Comme je l'ai déjà dit, la recherche a une tonne de compromis, nous utilisons donc souvent plusieurs approches pour améliorer encore plus la vitesse ou pour couvrir tous nos types de recherche potentiels. <br><br>  Aujourd'hui, je voudrais parler d'une de ces approches qui est moins connue: les index bitmap. <br><br><h2>  Mais qui suis-je pour parler de ce sujet? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Je suis chef d'équipe chez Badoo (vous connaissez peut-être une autre de nos marques: Bumble).  Nous avons plus de 400 millions d'utilisateurs dans le monde et beaucoup de fonctionnalités que nous avons impliquent de rechercher la meilleure correspondance pour vous!  Pour ces tâches, nous utilisons des services sur mesure qui utilisent des index bitmap, entre autres. <br><br><h2>  Maintenant, qu'est-ce qu'un index bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Comme leur nom l'indique, les index Bitmap utilisent des bitmaps aka bitsets pour implémenter l'index de recherche.  D'un point de vue à vol d'oiseau, cet index se compose d'une ou plusieurs images bitmap qui représentent des entités (par exemple, des personnes) et leurs paramètres (par exemple, l'âge ou la couleur des yeux) et un algorithme pour répondre aux requêtes de recherche en utilisant des opérations au niveau du bit comme ET, OU, NON, etc. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Les index bitmap sont considérés comme très utiles et très performants si vous avez une recherche qui doit combiner des requêtes par plusieurs colonnes avec une faible cardinalité (peut-être la couleur des yeux ou l'état matrimonial) par rapport à quelque chose comme la distance au centre-ville qui a une cardinalité infinie. <br><br>  Mais plus tard dans l'article, je montrerai que les index bitmap fonctionnent même avec des colonnes à cardinalité élevée. <br><br>  Regardons l'exemple le plus simple d'un index bitmap ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Imaginez que nous avons une liste de restaurants de Moscou avec des caractéristiques binaires: <br><br><ul><li>  près du métro <br></li><li>  dispose d'un parking privé <br></li><li>  a une terrasse <br></li><li>  accepte les réservations <br></li><li>  végétalien <br></li><li>  cher <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Donnons à chaque restaurant un index à partir de 0 et allouons 6 bitmaps (un pour chaque caractéristique).  Ensuite, nous remplirions ces bitmaps selon que le restaurant a ou non une caractéristique spécifique.  Si le restaurant numéro 4 a la terrasse, alors le bit numéro 4 dans le bitmap "terrasse" sera mis à 1 (0 sinon). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Nous avons maintenant l'index bitmap le plus simple possible que nous pouvons utiliser pour répondre à des questions comme <br><br><ul><li>  Donnez-moi des restaurants végétaliens <br></li><li>  Donnez-moi des restaurants avec terrasse qui acceptent les réservations, mais ne sont pas chers <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Comment?  Voyons voir.  La première question est simple.  Nous prenons simplement le bitmap "vegan-friendly" et retournons tous les index qui ont un bit défini. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  La deuxième question est légèrement plus compliquée.  Nous utiliserons l'opération au niveau du bit NON sur le bitmap «cher» pour obtenir des restaurants non chers, ET avec le bitmap «accepter la réservation» et ET avec «a le bitmap en terrasse».  Le bitmap résultant sera composé de restaurants qui ont toutes ces caractéristiques que nous voulions.  Nous voyons ici que seul Yunost possède toutes ces caractéristiques. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Cela peut sembler un peu théorique, mais ne vous inquiétez pas, nous verrons le code sous peu. <br><br><h2>  Où les index bitmap sont utilisés </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Si vous google "bitmap index", 90% des résultats pointeront vers Oracle DB qui a des index bitmap de base.  Mais, sûrement, d'autres SGBD utilisent également des index bitmap, n'est-ce pas?  Non, en fait, ils ne le font pas.  Passons en revue les suspects habituels un par un. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  MySQL n'a pas encore d'index bitmap, mais il est proposé de les ajouter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ) <br></li><li>  PostgreSQL n'a pas d'index bitmap, mais ils utilisent des bitmaps simples et des opérations bit à bit pour combiner les résultats de plusieurs index différents. <br></li><li>  Tarantool a des index de bits et permet des recherches très simples avec eux. <br></li><li>  Redis a des champs de bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://redis.io/commands/bitfiel</a> d sans capacité de recherche <br></li><li>  MongoDB ne les a pas encore, mais il existe également une proposition pour les ajouter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723)</a> <br></li><li>  Elasticsearch utilise des bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps en</a> interne <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Mais il y a un nouveau garçon sur le bloc: Pilosa.  Pilosa est un nouveau SGBD écrit en Go (notez qu'il n'y a pas de R, ce n'est pas relationnel) qui base tout sur des index bitmap.  Et nous parlerons de Pilosa plus tard. <br></li></ul><br><h2>  Implémentation en cours </h2><br>  Mais pourquoi?  Pourquoi les index bitmap sont-ils si rarement utilisés?  Avant de répondre à cette question, je voudrais vous guider à travers l'implémentation de base de l'index bitmap dans Go. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  Le bitmap est représenté comme un morceau de mémoire.  Dans Go, utilisons une tranche d'octets pour cela. <br><br>  Nous avons un bitmap par caractéristique de restaurant.  Chaque bit dans un bitmap représente si un restaurant particulier a cette caractéristique ou non. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  Nous aurions besoin de deux fonctions d'assistance.  L'un est utilisé pour remplir le bitmap de manière aléatoire, mais avec une probabilité spécifiée d'avoir la caractéristique.  Par exemple, je pense qu'il y a très peu de restaurants qui n'acceptent pas les réservations et environ 20% sont végétaliens. <br><br>  Une autre fonction nous donnera la liste des restaurants à partir d'un bitmap. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Afin de répondre à la question «donnez-moi des restaurants avec terrasse qui acceptent les réservations mais ne sont pas chers», nous aurions besoin de deux opérations: NON et ET. <br><br>  Nous pouvons légèrement simplifier le code en introduisant une opération complexe ET NON. <br><br>  Nous avons les fonctions pour chacun d'eux.  Les deux fonctions passent par nos tranches en prenant les éléments correspondants de chacune, en effectuant l'opération et en écrivant le résultat dans la tranche résultante. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  Et maintenant, nous pouvons utiliser nos bitmaps et nos fonctions pour obtenir la réponse. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  Les performances ne sont pas si bonnes ici même si nos fonctions sont vraiment simples et nous avons beaucoup économisé sur les allocations en ne retournant pas de nouvelle tranche à chaque appel de fonction. <br><br>  Après un profilage avec pprof, j'ai remarqué que le compilateur go manquait l'une des optimisations très basiques: la fonction inline. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Vous voyez, le compilateur Go a pathologiquement peur des boucles à travers les tranches et refuse de mettre en ligne toute fonction qui en a. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Mais je n'ai pas peur d'eux et je peux tromper le compilateur en utilisant goto pour ma boucle. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Comme vous pouvez le voir, l'inlining nous a permis d'économiser environ 2 microsecondes.  Pas mal! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Un autre goulot d'étranglement est facile à repérer lorsque vous examinez de plus près la sortie de l'assemblage.  Le compilateur Go a inclus des vérifications de plage dans notre boucle.  Go est un langage sûr et le compilateur a peur que mes trois bitmaps aient des longueurs différentes et qu'il y ait un débordement de tampon. <br><br>  Calmes le compilateur et montrons-lui que tous mes bitmaps sont de la même longueur.  Pour ce faire, nous pouvons ajouter une simple vérification au début de la fonction. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Avec cette vérification, le compilateur go sautera volontiers les vérifications de plage et nous économiserons quelques nanosecondes. <br><br><h2>  Mise en œuvre en montage </h2><br>  Très bien, nous avons donc réussi à réduire un peu plus les performances grâce à notre implémentation simple, mais ce résultat est bien pire que ce qui est possible avec le matériel actuel. <br><br>  Vous voyez, ce que nous faisons sont des opérations binaires très basiques et nos processeurs sont très efficaces avec celles-ci. <br><br>  Malheureusement, nous alimentons notre CPU avec de très petits morceaux de travail.  Notre fonction fait des opérations octet par octet.  Nous pouvons facilement modifier notre implémentation pour qu'elle fonctionne avec des blocs de 8 octets en utilisant des tranches d'uint64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Comme vous pouvez le voir ici, nous avons gagné environ 8 fois les performances pour une taille de lot de 8 fois, donc les gains de performances sont à peu près linéaires. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Mais ce n'est pas la fin de la route.  Nos processeurs ont la capacité de fonctionner avec des blocs de 16 octets, 32 octets et même avec des blocs de 64 octets.  Ces opérations sont appelées SIMD (Single Instruction Multiple Data) et le processus d'utilisation de telles opérations CPU est appelé vectorisation. <br><br>  Malheureusement, le compilateur Go n'est pas très bon avec la vectorisation.  Et la seule chose que nous pouvons faire de nos jours pour vectoriser notre code est d'utiliser l'assemblage Go et d'ajouter nous-mêmes ces instructions SIMD. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  L'assemblage de go est une étrange bête.  On pourrait penser que l'assemblage est quelque chose qui est lié à l'architecture pour laquelle vous écrivez, mais l'assemblage de Go ressemble plus à IRL (langage de représentation intermédiaire): il est indépendant de la plate-forme.  Il y a quelques années, Rob Pike a fait un discours étonnant à ce sujet. <br><br>  De plus, Go utilise un format plan9 inhabituel qui est différent des formats AT&amp;T et Intel. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  Il est sûr de dire qu'écrire du code d'assemblage Go n'est pas amusant. <br><br>  Heureusement pour nous, il existe déjà deux outils de niveau supérieur pour vous aider à écrire l'assemblage Go: PeachPy et avo.  Les deux génèrent un assemblage go à partir d'un code de niveau supérieur écrit respectivement en Python et Go. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Ces outils simplifient des choses comme l'allocation de registres et les boucles et, dans l'ensemble, réduisent la complexité d'entrer dans le domaine de la programmation d'assemblage pour Go. <br><br>  Nous utiliserons l'évitement pour ce message afin que nos programmes ressemblent presque au code Go ordinaire. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Ceci est l'exemple le plus simple d'un programme avo.  Nous avons une fonction main () qui définit une fonction appelée Add () qui ajoute deux nombres.  Il existe des fonctions d'aide pour obtenir les paramètres par nom et pour obtenir l'un des registres généraux disponibles.  Il existe des fonctions pour chaque opération d'assemblage comme ADDQ ici, et il existe des fonctions d'assistance pour enregistrer le résultat d'un registre dans la valeur résultante. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  L'appel à go generate exécutera ce programme avo et deux fichiers seront créés <br><br><ul><li>  add.s avec le code d'assembly généré <br></li><li>  stub.go avec des en-têtes de fonction nécessaires pour connecter notre code go et assembly <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Maintenant que nous avons vu ce que fait avo, regardons nos fonctions.  J'ai implémenté des versions scalaires et SIMD (vectorielles) de nos fonctions. <br><br>  Voyons à quoi ressemble la version scalaire en premier. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Comme dans un exemple précédent, nous pouvons demander un registre général et en évitant de nous en donner le bon qui soit disponible.  Nous n'avons pas besoin de suivre les décalages en octets pour nos arguments, en évitant cela pour nous. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Auparavant, nous sommes passés de boucles à l'utilisation de goto pour des raisons de performances et pour tromper le compilateur go.  Ici, nous utilisons goto (sauts) et étiquettes dès le début car les boucles sont des constructions de niveau supérieur.  Au montage, nous n'avons que des sauts. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  L'autre code devrait être assez clair.  Nous émulons la boucle avec des sauts et des étiquettes, prenons une petite partie de nos données de nos deux bitmaps, les combinons en utilisant l'une des opérations au niveau du bit et insérons le résultat dans le bitmap résultant. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  C'est un code asm résultant que nous obtenons.  Nous n'avons pas eu à calculer les décalages et les tailles (en vert), nous n'avons pas eu à traiter de registres spécifiques (en rouge). <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Si nous comparions cette implémentation en assembleur avec la meilleure précédente écrite en go, nous verrions que les performances sont les mêmes que prévu.  Nous n'avons rien fait différemment. <br><br>  Malheureusement, nous ne pouvons pas forcer le compilateur Go à intégrer nos fonctions écrites en asm.  Il manque complètement de support pour cela et la demande pour cette fonctionnalité existe depuis un certain temps maintenant.  C'est pourquoi les petites fonctions asm dans go ne donnent aucun avantage.  Vous devez soit écrire des fonctions plus grandes, utiliser un nouveau package math / bits ou ignorer complètement asm. <br><br>  Écrivons maintenant une version vectorielle de nos fonctions. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  J'ai choisi d'utiliser AVX2, nous allons donc utiliser des morceaux de 32 octets.  Il est très similaire à la structure scalaire.  Nous chargeons des paramètres, demandons des registres généraux, etc. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  L'un des changements concerne le fait que les opérations vectorielles utilisent des registres larges spécifiques.  Pour 32 octets, ils ont le préfixe Y, c'est pourquoi vous y voyez YMM ().  Pour 64 octets, ils auraient eu le préfixe Z. <br><br>  Une autre différence a à voir avec l'optimisation que j'ai effectuée, appelée déroulage ou déroulage de boucle.  J'ai choisi de dérouler partiellement notre boucle et de faire 8 opérations de boucle en séquence avant de reboucler.  Cette technique accélère le code en réduisant les branches dont nous disposons et elle est à peu près limitée par le nombre de registres dont nous disposons. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  Quant aux performances ... c'est incroyable.  Nous avons obtenu une amélioration d'environ 7x par rapport au meilleur précédent.  Assez impressionnant, non? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Il devrait être possible d'améliorer encore plus ces résultats en utilisant AVX512, la prélecture et peut-être même en utilisant la compilation JIT (juste à temps) au lieu du générateur de plan de requête "manuel", mais ce serait un sujet pour un article totalement différent. <br><br><h2>  Problèmes d'index bitmap </h2><br>  Maintenant que nous avons vu l'implémentation de base et la vitesse impressionnante de l'implémentation asm, parlons du fait que les index bitmap ne sont pas très largement utilisés.  Pourquoi ça? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  Des publications plus anciennes nous donnent ces trois raisons.  Mais les plus récents et je soutiens que ceux-ci ont été "corrigés" ou traités à ce jour.  Je n'entrerai pas dans beaucoup de détails à ce sujet ici parce que nous n'avons pas beaucoup de temps, mais cela vaut certainement le coup d'œil. <br><br><h2>  Problème de cardinalité élevée </h2><br>  Ainsi, on nous a dit que les index bitmap ne sont réalisables que pour les champs à faible cardinalité.  c'est-à-dire des champs qui ont peu de valeurs distinctes, comme le sexe ou la couleur des yeux.  La raison en est que la représentation commune (un bit par valeur distincte) peut devenir assez grande pour les valeurs à cardinalité élevée.  Et, par conséquent, le bitmap peut devenir énorme même s'il est peu peuplé. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  Parfois, une représentation différente peut être utilisée pour ces champs, comme une représentation numérique binaire comme illustré ici, mais le plus grand changeur de jeu est une compression.  Les scientifiques ont mis au point des algorithmes de compression incroyables.  Presque tous sont basés sur des algorithmes de longueur d'exécution répandus, mais ce qui est plus étonnant, c'est que nous n'avons pas besoin de décompresser les bitmaps pour effectuer des opérations au niveau du bit sur eux.  Les opérations normales au niveau du bit fonctionnent sur les bitmaps compressés. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  Récemment, nous avons vu des approches hybrides ressembler à des "bitmaps rugissants".  Les bitmaps rugissants utilisent trois représentations distinctes pour les bitmaps: les bitmaps, les tableaux et les "exécutions de bits" et ils équilibrent l'utilisation de ces trois représentations à la fois pour maximiser la vitesse et pour minimiser l'utilisation de la mémoire. <br><br>  Des bitmaps rugissants peuvent être trouvés dans certaines des applications les plus utilisées et il existe des implémentations pour de nombreux langages, y compris plusieurs implémentations pour Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Une autre approche qui peut aider avec les champs à cardinalité élevée est appelée binning.  Imaginez que nous ayons un champ représentant la taille d'une personne.  La hauteur est un flotteur, mais nous ne pensons pas de cette façon.  Personne ne se soucie si votre taille est de 185,2 ou 185,3 cm.  Nous pouvons donc utiliser des «bacs virtuels» pour presser des hauteurs similaires dans le même bac: le bac de 1 cm, dans ce cas.  Et si vous supposez qu'il y a très peu de personnes avec une hauteur inférieure à 50 cm, ou supérieure à 250 cm, nous pouvons convertir notre hauteur sur le terrain avec une cardinalité d'environ 200 éléments, au lieu d'une cardinalité presque infinie.  Si nécessaire, nous pourrions effectuer un filtrage supplémentaire sur les résultats ultérieurement. <br><br><h2>  Problème de haut débit </h2><br>  Une autre raison pour laquelle les index bitmap sont mauvais est qu'il peut être coûteux de mettre à jour les bitmaps. <br>  Les bases de données effectuent des mises à jour et des recherches en parallèle, vous devez donc être en mesure de mettre à jour les données alors qu'il peut y avoir des centaines de threads passant par des bitmaps faisant une recherche.  Les verrous seraient des verrous nécessaires pour éviter les courses de données ou les problèmes de cohérence des données.  Et là où il y a un gros verrou, il y a conflit de verrouillage. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Ce problème, si vous l'avez, peut être résolu en partitionnant vos index ou en ayant des versions d'index, le cas échéant. <br><br>  Le sharding est simple.  Vous les divisez comme vous le feriez pour les utilisateurs d'une base de données et maintenant, au lieu d'un verrou, vous disposez de plusieurs verrous, ce qui réduit considérablement votre conflit de verrous. <br><br>  Une autre approche qui est parfois réalisable est d'avoir des index versionnés.  Vous avez l'index que vous utilisez pour la recherche et vous avez un index que vous utilisez pour les écritures, pour les mises à jour.  Et vous les copiez et les commutez à une basse fréquence, par exemple 100 ou 500 ms. <br><br>  Mais cette approche n'est possible que si votre application est capable de tolérer des index de recherche périmés qui sont un peu périmés. <br>  Bien entendu, ces deux approches peuvent également être utilisées ensemble.  Vous pouvez avoir des index versionnés fragmentés. <br><br><h2>  Requêtes non triviales </h2><br>  Un autre problème d'index bitmap concerne l'utilisation d'index bitmap avec des requêtes de plage.  Et à première vue, les opérations au niveau du bit comme ET et OU ne semblent pas être très utiles pour les requêtes de gamme comme "donnez-moi des chambres d'hôtel qui coûtent de 200 à 300 dollars par nuit". <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Une solution naïve et très inefficace consisterait à obtenir des résultats pour chaque prix de 200 à 300 et à OU les résultats. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Une approche légèrement meilleure consisterait à utiliser le binning et à placer nos hôtels dans des fourchettes de prix avec des largeurs de gamme de, disons, 50 dollars.  Cette approche réduirait nos frais de recherche d'environ 50 fois. <br><br>  Mais ce problème peut également être résolu très facilement en utilisant un encodage spécial qui rend les requêtes de plage possibles et rapides.  Dans la littérature, ces bitmaps sont appelés bitmaps à plage codée. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  Dans les bitmaps codés par plage, nous ne définissons pas seulement un bit spécifique pour, disons, la valeur 200, mais nous définissons tous les bits à 200 et plus.  La même chose pour 300. <br><br>  Ainsi, en utilisant cette requête de plage de représentation bitmap codée par plage, il est possible de répondre en seulement deux passages par bitmap.  Nous obtenons tous les hôtels dont le coût est inférieur ou égal à 300 dollars et nous retirons du résultat tous les hôtels dont le coût est inférieur ou égal à 199 dollars.  Terminé <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Vous seriez étonné mais même les requêtes géographiques sont possibles en utilisant des bitmaps.  L'astuce consiste à utiliser une représentation comme Google S2 ou similaire qui entoure une coordonnée dans une figure géométrique qui peut être représentée sous forme de trois lignes indexées ou plus.  Si vous utilisez une telle représentation, vous pouvez alors représenter la requête géographique comme plusieurs requêtes de plage sur ces index de ligne. <br><br><h2>  Solutions prêtes </h2><br>  Eh bien, j'espère avoir un peu piqué votre intérêt.  Vous avez maintenant un outil de plus sous votre ceinture et si jamais vous avez besoin d'implémenter quelque chose comme ça dans votre service, vous saurez où chercher. <br><br>  C'est bien beau, mais tout le monde n'a pas le temps, la patience et les ressources pour implémenter l'index bitmap eux-mêmes, surtout quand il s'agit de choses plus avancées comme les instructions SIMD. <br><br>  N'ayez crainte, il existe deux produits open source qui peuvent vous aider dans votre entreprise. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Rugissant </h2><br>  Tout d'abord, il y a une bibliothèque que j'ai déjà mentionnée appelée "bitmaps rugissants".  Cette bibliothèque implémente un "conteneur" rugissant et toutes les opérations au niveau du bit dont vous auriez besoin si vous deviez implémenter un index bitmap complet. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Malheureusement, les implémentations go n'utilisent pas SIMD, elles donnent donc des performances légèrement inférieures à, disons, l'implémentation C. <br><br><h2>  Pilosa </h2><br>  Un autre produit est un SGBD appelé Pilosa qui n'a que des index bitmap.  C'est un projet récent, mais il a gagné beaucoup de traction ces derniers temps. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  Pilosa utilise des bitmaps rugissants en dessous et donne, simplifie ou explique presque tout ce que je vous ai dit aujourd'hui: le binning, les bitmaps à plage codée, la notion de champs, etc. <br><br>  Regardons brièvement un exemple de Pilosa utilisé ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  L'exemple que vous voyez est très très similaire à ce que nous avons vu plus tôt.  Nous créons un client pour le serveur pilosa, créons un index et des champs pour nos caractéristiques.  Nous remplissons les champs avec des données aléatoires avec quelques probabilités comme nous l'avons fait précédemment, puis nous exécutons notre requête de recherche. <br>  Vous voyez le même modèle de base ici.  PAS cher intersecté ou ET-ed avec terrasse et intersecté avec réservations. <br><br>  Le résultat est comme prévu. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  Et enfin, j'espère que dans le futur, les bases de données comme mysql et postgresql obtiendront un nouveau type d'index: index bitmap. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Mots de clôture </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  Et si vous êtes encore éveillé, je vous en remercie.  Le manque de temps a signifié que j'ai dû survoler beaucoup de choses dans ce post, mais j'espère que cela a été utile et peut-être même inspirant. <br><br>  Les index bitmap sont une chose utile à connaître et à comprendre même si vous n'en avez pas besoin pour le moment.  Gardez-les comme un autre outil dans votre portefeuille. <br><br>  Au cours de mon exposé, nous avons vu diverses astuces de performance que nous pouvons utiliser et des choses avec lesquelles Go a du mal à l'instant.  Ce sont certainement des choses que chaque programmeur Go doit savoir. <br><br>  Et c'est tout ce que j'ai pour vous pour l'instant.  Merci beaucoup! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455608/">https://habr.com/ru/post/fr455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455598/index.html">Mettre à jour Exim à 4.92 de toute urgence - il y a une infection active</a></li>
<li><a href="../fr455600/index.html">La plateforme 3DEXPERIENCE aide à créer les transports publics du futur</a></li>
<li><a href="../fr455602/index.html">Provoquer un crash du navigateur avec fuzzing comportemental</a></li>
<li><a href="../fr455604/index.html">Possibilité de gérer la configuration de Windows. Histoire de réussite</a></li>
<li><a href="../fr455606/index.html">Apprentissage automatique et analyse des données: programme de maîtrise à l'École supérieure d'économie de Saint-Pétersbourg</a></li>
<li><a href="../fr455610/index.html">Intel Core i7-2600K légendaire: test de Sandy Bridge en 2019 (partie 1)</a></li>
<li><a href="../fr455612/index.html">Nous réfléchissons aux personnages de jeux et dialogues sur les conseils d'écrivains et sur l'exemple des partisans de la théorie d'une Terre plate</a></li>
<li><a href="../fr455614/index.html">FFI: écrire en Rust dans un programme PHP</a></li>
<li><a href="../fr455616/index.html">Pourquoi aller à "Programmation industrielle" au HSE de Saint-Pétersbourg?</a></li>
<li><a href="../fr455618/index.html">DevOps LEGO: comment nous avons conçu un pipeline sur des cubes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>