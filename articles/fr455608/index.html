<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÇ ‚ôüÔ∏è üï∫üèΩ Index bitmap dans Go: vitesse de recherche incroyable üìî ü§òüèº üêñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mon nom est Marko et j'ai donn√© une conf√©rence √† Gophercon Russie cette ann√©e sur un type d'index tr√®s int√©ressant appel√© "index bitmap". Je voulais l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index bitmap dans Go: vitesse de recherche incroyable</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Mon nom est Marko et j'ai donn√© une conf√©rence √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gophercon Russie</a> cette ann√©e sur un type d'index tr√®s int√©ressant appel√© "index bitmap".  Je voulais le partager avec la communaut√©, non seulement au format vid√©o, mais aussi en tant qu'article.  C'est une version anglaise et vous pouvez lire le russe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Profitez-en! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Des documents suppl√©mentaires, des diapositives et tout le code source peuvent √™tre trouv√©s ici: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Enregistrement vid√©o original: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Commen√ßons! <br><br><h2>  Pr√©sentation </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Aujourd'hui, je vais parler de <br><br><ul><li>  Quels sont les index. <br></li><li>  Qu'est-ce qu'un index bitmap; <br></li><li>  O√π il est utilis√©.  Pourquoi il n'est pas utilis√© l√† o√π il n'est pas utilis√©. <br></li><li>  Nous allons voir une impl√©mentation simple dans Go et ensuite essayer le compilateur. <br></li><li>  Ensuite, nous allons examiner une impl√©mentation un peu moins simple, mais sensiblement plus rapide dans l'assemblage Go. <br></li><li>  Et apr√®s cela, je vais aborder les "probl√®mes" des index bitmap un par un. <br></li><li>  Et enfin, nous verrons quelles sont les solutions existantes. <br></li></ul><br><h2>  Quels sont donc les index? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Un index est une structure de donn√©es distincte qui est mise √† jour en plus des donn√©es principales, utilis√©e pour acc√©l√©rer les demandes de recherche.  Sans index, la recherche impliquerait de parcourir toutes les donn√©es (dans un processus √©galement appel√© ¬´analyse compl√®te¬ª) et ce processus a une complexit√© algorithmique lin√©aire.  Mais les bases de donn√©es contiennent g√©n√©ralement d'√©normes quantit√©s de donn√©es, de sorte que la complexit√© lin√©aire est trop lente.  Id√©alement, nous souhaiterions atteindre des vitesses de complexit√© logarithmique voire constante. <br><br>  Il s'agit d'un sujet √©norme et complexe impliquant de nombreux compromis, mais en revenant sur des d√©cennies de mise en ≈ìuvre de bases de donn√©es et de recherche, je dirais qu'il n'y a que quelques approches couramment utilis√©es: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Tout d'abord, r√©duit la zone de recherche en coupant la zone enti√®re en parties plus petites, hi√©rarchiquement. <br><br>  G√©n√©ralement, cela est r√©alis√© en utilisant des arbres.  C'est comme avoir des bo√Ætes de bo√Ætes dans votre garde-robe.  Chaque bo√Æte contient des mat√©riaux qui sont ensuite tri√©s dans des bo√Ætes plus petites, chacune pour une utilisation sp√©cifique.  Si nous avons besoin de mat√©riel, nous ferions mieux de chercher la case intitul√©e "mat√©riel" au lieu d'une case intitul√©e "cookies". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  La seconde consiste √† localiser instantan√©ment un √©l√©ment ou un groupe d'√©l√©ments sp√©cifique comme dans les cartes de hachage ou les index invers√©s.  L'utilisation de cartes de hachage est similaire √† l'exemple pr√©c√©dent, mais vous utilisez de nombreuses petites bo√Ætes qui ne contiennent pas de bo√Ætes elles-m√™mes, mais plut√¥t des √©l√©ments finaux. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  La troisi√®me approche supprime la n√©cessit√© de rechercher du tout comme dans les filtres √† fleurs ou les filtres √† coucou.  Les filtres Bloom peuvent vous donner une r√©ponse tout de suite et vous faire gagner du temps autrement consacr√© √† la recherche. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  Le dernier acc√©l√®re la recherche en faisant un meilleur usage de nos capacit√©s mat√©rielles comme dans les index bitmap.  Les indices bitmap impliquent parfois de parcourir l'int√©gralit√© de l'index, oui, mais cela se fait de mani√®re tr√®s efficace. <br><br>  Comme je l'ai d√©j√† dit, la recherche a une tonne de compromis, nous utilisons donc souvent plusieurs approches pour am√©liorer encore plus la vitesse ou pour couvrir tous nos types de recherche potentiels. <br><br>  Aujourd'hui, je voudrais parler d'une de ces approches qui est moins connue: les index bitmap. <br><br><h2>  Mais qui suis-je pour parler de ce sujet? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Je suis chef d'√©quipe chez Badoo (vous connaissez peut-√™tre une autre de nos marques: Bumble).  Nous avons plus de 400 millions d'utilisateurs dans le monde et beaucoup de fonctionnalit√©s que nous avons impliquent de rechercher la meilleure correspondance pour vous!  Pour ces t√¢ches, nous utilisons des services sur mesure qui utilisent des index bitmap, entre autres. <br><br><h2>  Maintenant, qu'est-ce qu'un index bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Comme leur nom l'indique, les index Bitmap utilisent des bitmaps aka bitsets pour impl√©menter l'index de recherche.  D'un point de vue √† vol d'oiseau, cet index se compose d'une ou plusieurs images bitmap qui repr√©sentent des entit√©s (par exemple, des personnes) et leurs param√®tres (par exemple, l'√¢ge ou la couleur des yeux) et un algorithme pour r√©pondre aux requ√™tes de recherche en utilisant des op√©rations au niveau du bit comme ET, OU, NON, etc. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Les index bitmap sont consid√©r√©s comme tr√®s utiles et tr√®s performants si vous avez une recherche qui doit combiner des requ√™tes par plusieurs colonnes avec une faible cardinalit√© (peut-√™tre la couleur des yeux ou l'√©tat matrimonial) par rapport √† quelque chose comme la distance au centre-ville qui a une cardinalit√© infinie. <br><br>  Mais plus tard dans l'article, je montrerai que les index bitmap fonctionnent m√™me avec des colonnes √† cardinalit√© √©lev√©e. <br><br>  Regardons l'exemple le plus simple d'un index bitmap ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Imaginez que nous avons une liste de restaurants de Moscou avec des caract√©ristiques binaires: <br><br><ul><li>  pr√®s du m√©tro <br></li><li>  dispose d'un parking priv√© <br></li><li>  a une terrasse <br></li><li>  accepte les r√©servations <br></li><li>  v√©g√©talien <br></li><li>  cher <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Donnons √† chaque restaurant un index √† partir de 0 et allouons 6 bitmaps (un pour chaque caract√©ristique).  Ensuite, nous remplirions ces bitmaps selon que le restaurant a ou non une caract√©ristique sp√©cifique.  Si le restaurant num√©ro 4 a la terrasse, alors le bit num√©ro 4 dans le bitmap "terrasse" sera mis √† 1 (0 sinon). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Nous avons maintenant l'index bitmap le plus simple possible que nous pouvons utiliser pour r√©pondre √† des questions comme <br><br><ul><li>  Donnez-moi des restaurants v√©g√©taliens <br></li><li>  Donnez-moi des restaurants avec terrasse qui acceptent les r√©servations, mais ne sont pas chers <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Comment?  Voyons voir.  La premi√®re question est simple.  Nous prenons simplement le bitmap "vegan-friendly" et retournons tous les index qui ont un bit d√©fini. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  La deuxi√®me question est l√©g√®rement plus compliqu√©e.  Nous utiliserons l'op√©ration au niveau du bit NON sur le bitmap ¬´cher¬ª pour obtenir des restaurants non chers, ET avec le bitmap ¬´accepter la r√©servation¬ª et ET avec ¬´a le bitmap en terrasse¬ª.  Le bitmap r√©sultant sera compos√© de restaurants qui ont toutes ces caract√©ristiques que nous voulions.  Nous voyons ici que seul Yunost poss√®de toutes ces caract√©ristiques. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Cela peut sembler un peu th√©orique, mais ne vous inqui√©tez pas, nous verrons le code sous peu. <br><br><h2>  O√π les index bitmap sont utilis√©s </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Si vous google "bitmap index", 90% des r√©sultats pointeront vers Oracle DB qui a des index bitmap de base.  Mais, s√ªrement, d'autres SGBD utilisent √©galement des index bitmap, n'est-ce pas?  Non, en fait, ils ne le font pas.  Passons en revue les suspects habituels un par un. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  MySQL n'a pas encore d'index bitmap, mais il est propos√© de les ajouter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ) <br></li><li>  PostgreSQL n'a pas d'index bitmap, mais ils utilisent des bitmaps simples et des op√©rations bit √† bit pour combiner les r√©sultats de plusieurs index diff√©rents. <br></li><li>  Tarantool a des index de bits et permet des recherches tr√®s simples avec eux. <br></li><li>  Redis a des champs de bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://redis.io/commands/bitfiel</a> d sans capacit√© de recherche <br></li><li>  MongoDB ne les a pas encore, mais il existe √©galement une proposition pour les ajouter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723)</a> <br></li><li>  Elasticsearch utilise des bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps en</a> interne <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Mais il y a un nouveau gar√ßon sur le bloc: Pilosa.  Pilosa est un nouveau SGBD √©crit en Go (notez qu'il n'y a pas de R, ce n'est pas relationnel) qui base tout sur des index bitmap.  Et nous parlerons de Pilosa plus tard. <br></li></ul><br><h2>  Impl√©mentation en cours </h2><br>  Mais pourquoi?  Pourquoi les index bitmap sont-ils si rarement utilis√©s?  Avant de r√©pondre √† cette question, je voudrais vous guider √† travers l'impl√©mentation de base de l'index bitmap dans Go. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  Le bitmap est repr√©sent√© comme un morceau de m√©moire.  Dans Go, utilisons une tranche d'octets pour cela. <br><br>  Nous avons un bitmap par caract√©ristique de restaurant.  Chaque bit dans un bitmap repr√©sente si un restaurant particulier a cette caract√©ristique ou non. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  Nous aurions besoin de deux fonctions d'assistance.  L'un est utilis√© pour remplir le bitmap de mani√®re al√©atoire, mais avec une probabilit√© sp√©cifi√©e d'avoir la caract√©ristique.  Par exemple, je pense qu'il y a tr√®s peu de restaurants qui n'acceptent pas les r√©servations et environ 20% sont v√©g√©taliens. <br><br>  Une autre fonction nous donnera la liste des restaurants √† partir d'un bitmap. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Afin de r√©pondre √† la question ¬´donnez-moi des restaurants avec terrasse qui acceptent les r√©servations mais ne sont pas chers¬ª, nous aurions besoin de deux op√©rations: NON et ET. <br><br>  Nous pouvons l√©g√®rement simplifier le code en introduisant une op√©ration complexe ET NON. <br><br>  Nous avons les fonctions pour chacun d'eux.  Les deux fonctions passent par nos tranches en prenant les √©l√©ments correspondants de chacune, en effectuant l'op√©ration et en √©crivant le r√©sultat dans la tranche r√©sultante. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  Et maintenant, nous pouvons utiliser nos bitmaps et nos fonctions pour obtenir la r√©ponse. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  Les performances ne sont pas si bonnes ici m√™me si nos fonctions sont vraiment simples et nous avons beaucoup √©conomis√© sur les allocations en ne retournant pas de nouvelle tranche √† chaque appel de fonction. <br><br>  Apr√®s un profilage avec pprof, j'ai remarqu√© que le compilateur go manquait l'une des optimisations tr√®s basiques: la fonction inline. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Vous voyez, le compilateur Go a pathologiquement peur des boucles √† travers les tranches et refuse de mettre en ligne toute fonction qui en a. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Mais je n'ai pas peur d'eux et je peux tromper le compilateur en utilisant goto pour ma boucle. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Comme vous pouvez le voir, l'inlining nous a permis d'√©conomiser environ 2 microsecondes.  Pas mal! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Un autre goulot d'√©tranglement est facile √† rep√©rer lorsque vous examinez de plus pr√®s la sortie de l'assemblage.  Le compilateur Go a inclus des v√©rifications de plage dans notre boucle.  Go est un langage s√ªr et le compilateur a peur que mes trois bitmaps aient des longueurs diff√©rentes et qu'il y ait un d√©bordement de tampon. <br><br>  Calmes le compilateur et montrons-lui que tous mes bitmaps sont de la m√™me longueur.  Pour ce faire, nous pouvons ajouter une simple v√©rification au d√©but de la fonction. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Avec cette v√©rification, le compilateur go sautera volontiers les v√©rifications de plage et nous √©conomiserons quelques nanosecondes. <br><br><h2>  Mise en ≈ìuvre en montage </h2><br>  Tr√®s bien, nous avons donc r√©ussi √† r√©duire un peu plus les performances gr√¢ce √† notre impl√©mentation simple, mais ce r√©sultat est bien pire que ce qui est possible avec le mat√©riel actuel. <br><br>  Vous voyez, ce que nous faisons sont des op√©rations binaires tr√®s basiques et nos processeurs sont tr√®s efficaces avec celles-ci. <br><br>  Malheureusement, nous alimentons notre CPU avec de tr√®s petits morceaux de travail.  Notre fonction fait des op√©rations octet par octet.  Nous pouvons facilement modifier notre impl√©mentation pour qu'elle fonctionne avec des blocs de 8 octets en utilisant des tranches d'uint64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Comme vous pouvez le voir ici, nous avons gagn√© environ 8 fois les performances pour une taille de lot de 8 fois, donc les gains de performances sont √† peu pr√®s lin√©aires. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Mais ce n'est pas la fin de la route.  Nos processeurs ont la capacit√© de fonctionner avec des blocs de 16 octets, 32 octets et m√™me avec des blocs de 64 octets.  Ces op√©rations sont appel√©es SIMD (Single Instruction Multiple Data) et le processus d'utilisation de telles op√©rations CPU est appel√© vectorisation. <br><br>  Malheureusement, le compilateur Go n'est pas tr√®s bon avec la vectorisation.  Et la seule chose que nous pouvons faire de nos jours pour vectoriser notre code est d'utiliser l'assemblage Go et d'ajouter nous-m√™mes ces instructions SIMD. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  L'assemblage de go est une √©trange b√™te.  On pourrait penser que l'assemblage est quelque chose qui est li√© √† l'architecture pour laquelle vous √©crivez, mais l'assemblage de Go ressemble plus √† IRL (langage de repr√©sentation interm√©diaire): il est ind√©pendant de la plate-forme.  Il y a quelques ann√©es, Rob Pike a fait un discours √©tonnant √† ce sujet. <br><br>  De plus, Go utilise un format plan9 inhabituel qui est diff√©rent des formats AT&amp;T et Intel. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  Il est s√ªr de dire qu'√©crire du code d'assemblage Go n'est pas amusant. <br><br>  Heureusement pour nous, il existe d√©j√† deux outils de niveau sup√©rieur pour vous aider √† √©crire l'assemblage Go: PeachPy et avo.  Les deux g√©n√®rent un assemblage go √† partir d'un code de niveau sup√©rieur √©crit respectivement en Python et Go. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Ces outils simplifient des choses comme l'allocation de registres et les boucles et, dans l'ensemble, r√©duisent la complexit√© d'entrer dans le domaine de la programmation d'assemblage pour Go. <br><br>  Nous utiliserons l'√©vitement pour ce message afin que nos programmes ressemblent presque au code Go ordinaire. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Ceci est l'exemple le plus simple d'un programme avo.  Nous avons une fonction main () qui d√©finit une fonction appel√©e Add () qui ajoute deux nombres.  Il existe des fonctions d'aide pour obtenir les param√®tres par nom et pour obtenir l'un des registres g√©n√©raux disponibles.  Il existe des fonctions pour chaque op√©ration d'assemblage comme ADDQ ici, et il existe des fonctions d'assistance pour enregistrer le r√©sultat d'un registre dans la valeur r√©sultante. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  L'appel √† go generate ex√©cutera ce programme avo et deux fichiers seront cr√©√©s <br><br><ul><li>  add.s avec le code d'assembly g√©n√©r√© <br></li><li>  stub.go avec des en-t√™tes de fonction n√©cessaires pour connecter notre code go et assembly <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Maintenant que nous avons vu ce que fait avo, regardons nos fonctions.  J'ai impl√©ment√© des versions scalaires et SIMD (vectorielles) de nos fonctions. <br><br>  Voyons √† quoi ressemble la version scalaire en premier. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Comme dans un exemple pr√©c√©dent, nous pouvons demander un registre g√©n√©ral et en √©vitant de nous en donner le bon qui soit disponible.  Nous n'avons pas besoin de suivre les d√©calages en octets pour nos arguments, en √©vitant cela pour nous. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Auparavant, nous sommes pass√©s de boucles √† l'utilisation de goto pour des raisons de performances et pour tromper le compilateur go.  Ici, nous utilisons goto (sauts) et √©tiquettes d√®s le d√©but car les boucles sont des constructions de niveau sup√©rieur.  Au montage, nous n'avons que des sauts. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  L'autre code devrait √™tre assez clair.  Nous √©mulons la boucle avec des sauts et des √©tiquettes, prenons une petite partie de nos donn√©es de nos deux bitmaps, les combinons en utilisant l'une des op√©rations au niveau du bit et ins√©rons le r√©sultat dans le bitmap r√©sultant. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  C'est un code asm r√©sultant que nous obtenons.  Nous n'avons pas eu √† calculer les d√©calages et les tailles (en vert), nous n'avons pas eu √† traiter de registres sp√©cifiques (en rouge). <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Si nous comparions cette impl√©mentation en assembleur avec la meilleure pr√©c√©dente √©crite en go, nous verrions que les performances sont les m√™mes que pr√©vu.  Nous n'avons rien fait diff√©remment. <br><br>  Malheureusement, nous ne pouvons pas forcer le compilateur Go √† int√©grer nos fonctions √©crites en asm.  Il manque compl√®tement de support pour cela et la demande pour cette fonctionnalit√© existe depuis un certain temps maintenant.  C'est pourquoi les petites fonctions asm dans go ne donnent aucun avantage.  Vous devez soit √©crire des fonctions plus grandes, utiliser un nouveau package math / bits ou ignorer compl√®tement asm. <br><br>  √âcrivons maintenant une version vectorielle de nos fonctions. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  J'ai choisi d'utiliser AVX2, nous allons donc utiliser des morceaux de 32 octets.  Il est tr√®s similaire √† la structure scalaire.  Nous chargeons des param√®tres, demandons des registres g√©n√©raux, etc. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  L'un des changements concerne le fait que les op√©rations vectorielles utilisent des registres larges sp√©cifiques.  Pour 32 octets, ils ont le pr√©fixe Y, c'est pourquoi vous y voyez YMM ().  Pour 64 octets, ils auraient eu le pr√©fixe Z. <br><br>  Une autre diff√©rence a √† voir avec l'optimisation que j'ai effectu√©e, appel√©e d√©roulage ou d√©roulage de boucle.  J'ai choisi de d√©rouler partiellement notre boucle et de faire 8 op√©rations de boucle en s√©quence avant de reboucler.  Cette technique acc√©l√®re le code en r√©duisant les branches dont nous disposons et elle est √† peu pr√®s limit√©e par le nombre de registres dont nous disposons. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  Quant aux performances ... c'est incroyable.  Nous avons obtenu une am√©lioration d'environ 7x par rapport au meilleur pr√©c√©dent.  Assez impressionnant, non? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Il devrait √™tre possible d'am√©liorer encore plus ces r√©sultats en utilisant AVX512, la pr√©lecture et peut-√™tre m√™me en utilisant la compilation JIT (juste √† temps) au lieu du g√©n√©rateur de plan de requ√™te "manuel", mais ce serait un sujet pour un article totalement diff√©rent. <br><br><h2>  Probl√®mes d'index bitmap </h2><br>  Maintenant que nous avons vu l'impl√©mentation de base et la vitesse impressionnante de l'impl√©mentation asm, parlons du fait que les index bitmap ne sont pas tr√®s largement utilis√©s.  Pourquoi √ßa? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  Des publications plus anciennes nous donnent ces trois raisons.  Mais les plus r√©cents et je soutiens que ceux-ci ont √©t√© "corrig√©s" ou trait√©s √† ce jour.  Je n'entrerai pas dans beaucoup de d√©tails √† ce sujet ici parce que nous n'avons pas beaucoup de temps, mais cela vaut certainement le coup d'≈ìil. <br><br><h2>  Probl√®me de cardinalit√© √©lev√©e </h2><br>  Ainsi, on nous a dit que les index bitmap ne sont r√©alisables que pour les champs √† faible cardinalit√©.  c'est-√†-dire des champs qui ont peu de valeurs distinctes, comme le sexe ou la couleur des yeux.  La raison en est que la repr√©sentation commune (un bit par valeur distincte) peut devenir assez grande pour les valeurs √† cardinalit√© √©lev√©e.  Et, par cons√©quent, le bitmap peut devenir √©norme m√™me s'il est peu peupl√©. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  Parfois, une repr√©sentation diff√©rente peut √™tre utilis√©e pour ces champs, comme une repr√©sentation num√©rique binaire comme illustr√© ici, mais le plus grand changeur de jeu est une compression.  Les scientifiques ont mis au point des algorithmes de compression incroyables.  Presque tous sont bas√©s sur des algorithmes de longueur d'ex√©cution r√©pandus, mais ce qui est plus √©tonnant, c'est que nous n'avons pas besoin de d√©compresser les bitmaps pour effectuer des op√©rations au niveau du bit sur eux.  Les op√©rations normales au niveau du bit fonctionnent sur les bitmaps compress√©s. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  R√©cemment, nous avons vu des approches hybrides ressembler √† des "bitmaps rugissants".  Les bitmaps rugissants utilisent trois repr√©sentations distinctes pour les bitmaps: les bitmaps, les tableaux et les "ex√©cutions de bits" et ils √©quilibrent l'utilisation de ces trois repr√©sentations √† la fois pour maximiser la vitesse et pour minimiser l'utilisation de la m√©moire. <br><br>  Des bitmaps rugissants peuvent √™tre trouv√©s dans certaines des applications les plus utilis√©es et il existe des impl√©mentations pour de nombreux langages, y compris plusieurs impl√©mentations pour Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Une autre approche qui peut aider avec les champs √† cardinalit√© √©lev√©e est appel√©e binning.  Imaginez que nous ayons un champ repr√©sentant la taille d'une personne.  La hauteur est un flotteur, mais nous ne pensons pas de cette fa√ßon.  Personne ne se soucie si votre taille est de 185,2 ou 185,3 cm.  Nous pouvons donc utiliser des ¬´bacs virtuels¬ª pour presser des hauteurs similaires dans le m√™me bac: le bac de 1 cm, dans ce cas.  Et si vous supposez qu'il y a tr√®s peu de personnes avec une hauteur inf√©rieure √† 50 cm, ou sup√©rieure √† 250 cm, nous pouvons convertir notre hauteur sur le terrain avec une cardinalit√© d'environ 200 √©l√©ments, au lieu d'une cardinalit√© presque infinie.  Si n√©cessaire, nous pourrions effectuer un filtrage suppl√©mentaire sur les r√©sultats ult√©rieurement. <br><br><h2>  Probl√®me de haut d√©bit </h2><br>  Une autre raison pour laquelle les index bitmap sont mauvais est qu'il peut √™tre co√ªteux de mettre √† jour les bitmaps. <br>  Les bases de donn√©es effectuent des mises √† jour et des recherches en parall√®le, vous devez donc √™tre en mesure de mettre √† jour les donn√©es alors qu'il peut y avoir des centaines de threads passant par des bitmaps faisant une recherche.  Les verrous seraient des verrous n√©cessaires pour √©viter les courses de donn√©es ou les probl√®mes de coh√©rence des donn√©es.  Et l√† o√π il y a un gros verrou, il y a conflit de verrouillage. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Ce probl√®me, si vous l'avez, peut √™tre r√©solu en partitionnant vos index ou en ayant des versions d'index, le cas √©ch√©ant. <br><br>  Le sharding est simple.  Vous les divisez comme vous le feriez pour les utilisateurs d'une base de donn√©es et maintenant, au lieu d'un verrou, vous disposez de plusieurs verrous, ce qui r√©duit consid√©rablement votre conflit de verrous. <br><br>  Une autre approche qui est parfois r√©alisable est d'avoir des index versionn√©s.  Vous avez l'index que vous utilisez pour la recherche et vous avez un index que vous utilisez pour les √©critures, pour les mises √† jour.  Et vous les copiez et les commutez √† une basse fr√©quence, par exemple 100 ou 500 ms. <br><br>  Mais cette approche n'est possible que si votre application est capable de tol√©rer des index de recherche p√©rim√©s qui sont un peu p√©rim√©s. <br>  Bien entendu, ces deux approches peuvent √©galement √™tre utilis√©es ensemble.  Vous pouvez avoir des index versionn√©s fragment√©s. <br><br><h2>  Requ√™tes non triviales </h2><br>  Un autre probl√®me d'index bitmap concerne l'utilisation d'index bitmap avec des requ√™tes de plage.  Et √† premi√®re vue, les op√©rations au niveau du bit comme ET et OU ne semblent pas √™tre tr√®s utiles pour les requ√™tes de gamme comme "donnez-moi des chambres d'h√¥tel qui co√ªtent de 200 √† 300 dollars par nuit". <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Une solution na√Øve et tr√®s inefficace consisterait √† obtenir des r√©sultats pour chaque prix de 200 √† 300 et √† OU les r√©sultats. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Une approche l√©g√®rement meilleure consisterait √† utiliser le binning et √† placer nos h√¥tels dans des fourchettes de prix avec des largeurs de gamme de, disons, 50 dollars.  Cette approche r√©duirait nos frais de recherche d'environ 50 fois. <br><br>  Mais ce probl√®me peut √©galement √™tre r√©solu tr√®s facilement en utilisant un encodage sp√©cial qui rend les requ√™tes de plage possibles et rapides.  Dans la litt√©rature, ces bitmaps sont appel√©s bitmaps √† plage cod√©e. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  Dans les bitmaps cod√©s par plage, nous ne d√©finissons pas seulement un bit sp√©cifique pour, disons, la valeur 200, mais nous d√©finissons tous les bits √† 200 et plus.  La m√™me chose pour 300. <br><br>  Ainsi, en utilisant cette requ√™te de plage de repr√©sentation bitmap cod√©e par plage, il est possible de r√©pondre en seulement deux passages par bitmap.  Nous obtenons tous les h√¥tels dont le co√ªt est inf√©rieur ou √©gal √† 300 dollars et nous retirons du r√©sultat tous les h√¥tels dont le co√ªt est inf√©rieur ou √©gal √† 199 dollars.  Termin√© <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Vous seriez √©tonn√© mais m√™me les requ√™tes g√©ographiques sont possibles en utilisant des bitmaps.  L'astuce consiste √† utiliser une repr√©sentation comme Google S2 ou similaire qui entoure une coordonn√©e dans une figure g√©om√©trique qui peut √™tre repr√©sent√©e sous forme de trois lignes index√©es ou plus.  Si vous utilisez une telle repr√©sentation, vous pouvez alors repr√©senter la requ√™te g√©ographique comme plusieurs requ√™tes de plage sur ces index de ligne. <br><br><h2>  Solutions pr√™tes </h2><br>  Eh bien, j'esp√®re avoir un peu piqu√© votre int√©r√™t.  Vous avez maintenant un outil de plus sous votre ceinture et si jamais vous avez besoin d'impl√©menter quelque chose comme √ßa dans votre service, vous saurez o√π chercher. <br><br>  C'est bien beau, mais tout le monde n'a pas le temps, la patience et les ressources pour impl√©menter l'index bitmap eux-m√™mes, surtout quand il s'agit de choses plus avanc√©es comme les instructions SIMD. <br><br>  N'ayez crainte, il existe deux produits open source qui peuvent vous aider dans votre entreprise. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Rugissant </h2><br>  Tout d'abord, il y a une biblioth√®que que j'ai d√©j√† mentionn√©e appel√©e "bitmaps rugissants".  Cette biblioth√®que impl√©mente un "conteneur" rugissant et toutes les op√©rations au niveau du bit dont vous auriez besoin si vous deviez impl√©menter un index bitmap complet. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Malheureusement, les impl√©mentations go n'utilisent pas SIMD, elles donnent donc des performances l√©g√®rement inf√©rieures √†, disons, l'impl√©mentation C. <br><br><h2>  Pilosa </h2><br>  Un autre produit est un SGBD appel√© Pilosa qui n'a que des index bitmap.  C'est un projet r√©cent, mais il a gagn√© beaucoup de traction ces derniers temps. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  Pilosa utilise des bitmaps rugissants en dessous et donne, simplifie ou explique presque tout ce que je vous ai dit aujourd'hui: le binning, les bitmaps √† plage cod√©e, la notion de champs, etc. <br><br>  Regardons bri√®vement un exemple de Pilosa utilis√© ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  L'exemple que vous voyez est tr√®s tr√®s similaire √† ce que nous avons vu plus t√¥t.  Nous cr√©ons un client pour le serveur pilosa, cr√©ons un index et des champs pour nos caract√©ristiques.  Nous remplissons les champs avec des donn√©es al√©atoires avec quelques probabilit√©s comme nous l'avons fait pr√©c√©demment, puis nous ex√©cutons notre requ√™te de recherche. <br>  Vous voyez le m√™me mod√®le de base ici.  PAS cher intersect√© ou ET-ed avec terrasse et intersect√© avec r√©servations. <br><br>  Le r√©sultat est comme pr√©vu. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  Et enfin, j'esp√®re que dans le futur, les bases de donn√©es comme mysql et postgresql obtiendront un nouveau type d'index: index bitmap. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Mots de cl√¥ture </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  Et si vous √™tes encore √©veill√©, je vous en remercie.  Le manque de temps a signifi√© que j'ai d√ª survoler beaucoup de choses dans ce post, mais j'esp√®re que cela a √©t√© utile et peut-√™tre m√™me inspirant. <br><br>  Les index bitmap sont une chose utile √† conna√Ætre et √† comprendre m√™me si vous n'en avez pas besoin pour le moment.  Gardez-les comme un autre outil dans votre portefeuille. <br><br>  Au cours de mon expos√©, nous avons vu diverses astuces de performance que nous pouvons utiliser et des choses avec lesquelles Go a du mal √† l'instant.  Ce sont certainement des choses que chaque programmeur Go doit savoir. <br><br>  Et c'est tout ce que j'ai pour vous pour l'instant.  Merci beaucoup! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455608/">https://habr.com/ru/post/fr455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455598/index.html">Mettre √† jour Exim √† 4.92 de toute urgence - il y a une infection active</a></li>
<li><a href="../fr455600/index.html">La plateforme 3DEXPERIENCE aide √† cr√©er les transports publics du futur</a></li>
<li><a href="../fr455602/index.html">Provoquer un crash du navigateur avec fuzzing comportemental</a></li>
<li><a href="../fr455604/index.html">Possibilit√© de g√©rer la configuration de Windows. Histoire de r√©ussite</a></li>
<li><a href="../fr455606/index.html">Apprentissage automatique et analyse des donn√©es: programme de ma√Ætrise √† l'√âcole sup√©rieure d'√©conomie de Saint-P√©tersbourg</a></li>
<li><a href="../fr455610/index.html">Intel Core i7-2600K l√©gendaire: test de Sandy Bridge en 2019 (partie 1)</a></li>
<li><a href="../fr455612/index.html">Nous r√©fl√©chissons aux personnages de jeux et dialogues sur les conseils d'√©crivains et sur l'exemple des partisans de la th√©orie d'une Terre plate</a></li>
<li><a href="../fr455614/index.html">FFI: √©crire en Rust dans un programme PHP</a></li>
<li><a href="../fr455616/index.html">Pourquoi aller √† "Programmation industrielle" au HSE de Saint-P√©tersbourg?</a></li>
<li><a href="../fr455618/index.html">DevOps LEGO: comment nous avons con√ßu un pipeline sur des cubes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>