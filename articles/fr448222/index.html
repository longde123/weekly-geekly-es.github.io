<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôçüèæ ‚òùüèΩ üöû GPU, acc√©l√©rateurs hexagonaux et alg√®bre lin√©aire ü§≥üèª üï¶ üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tous ces mots sont beaucoup plus √©troitement li√©s au d√©veloppement mobile qu'il n'y para√Æt √† premi√®re vue: les acc√©l√©rateurs hexagonaux aident d√©j√† √† ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GPU, acc√©l√©rateurs hexagonaux et alg√®bre lin√©aire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/448222/"> Tous ces mots sont beaucoup plus √©troitement li√©s au d√©veloppement mobile qu'il n'y para√Æt √† premi√®re vue: les acc√©l√©rateurs hexagonaux aident d√©j√† √† former des r√©seaux de neurones sur des appareils mobiles;  l'alg√®bre et le matan sont utiles pour obtenir un emploi chez Apple;  et la programmation GPU vous permet non seulement d'acc√©l√©rer les applications, mais vous apprend √©galement √† voir l'essence des choses. <br><br>  En tout cas, dit le responsable du d√©veloppement mobile de Prisma <b>Andrey Volodin</b> .  Et aussi sur la fa√ßon dont les id√©es se d√©veloppent dans le d√©veloppement mobile √† partir de GameDev, comment les paradigmes diff√®rent, pourquoi Android n'a pas de flou natif - et bien plus encore, une version productive d'AppsCast a √©t√© publi√©e.  Sous la coupe, nous parlerons du rapport d'Andrey sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> sans spoilers. <br><br><img src="https://habrastorage.org/webt/0q/af/fk/0qaffkk1onyogn5werp4i1_rcxg.jpeg"><br><a name="habracut"></a><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsCast</a> est le podcast de la conf√©rence des d√©veloppeurs mobiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> .</i>  <i>Chaque num√©ro est un nouvel invit√©.</i>  <i>Chaque invit√© est un conf√©rencier de la conf√©rence avec lequel nous discutons de son rapport et discutons de sujets li√©s √† celui-ci.</i>  <i>Le podcast est h√©berg√© par les membres du comit√© du programme AppsConf, Alexei Kudryavtsev et Daniil Popov.</i> <br><br>  <strong>Alexey Kudryavtsev:</strong> Bonjour √† tous!  Andrey, parlez-nous de votre exp√©rience. <br><br>  <b>Andrey Volodin</b> : <b>Chez</b> Prisma, nous d√©veloppons des produits qui sont principalement li√©s au traitement des photos et des vid√©os.  Notre application phare est Prisma.  Nous cr√©ons maintenant une autre application Lensa pour des fonctionnalit√©s de type Facetune. <br><br>  Je dirige le d√©veloppement mobile, mais je suis coach de jeu.  J'ai toute la partie centrale, j'√©cris des pipelines GPU pour toutes ces applications.  Je d√©veloppe des frameworks de base pour que les algorithmes et les neurones d√©velopp√©s par l'√©quipe R&amp;D fonctionnent sur des appareils mobiles, fonctionnent en temps r√©el.  Bref, pour tuer l'informatique serveur et tout √ßa. <br><br>  <b>Alexei Kudryavtsev:</b> Cela ne ressemble pas √† un d√©veloppement iOS r√©gulier. <br><br>  <b>Andrey Volodin:</b> Oui, j'ai de telles sp√©cificit√©s - j'√©cris sur Swift tous les jours, mais en m√™me temps, c'est tr√®s loin de ce qui est consid√©r√© comme un d√©veloppement iOS. <br><br>  <b>Daniil Popov:</b> Vous avez mentionn√© les pipelines GPU, de quoi s'agit-il? <br><br>  <b>Andrey Volodin:</b> Lorsque vous faites des √©diteurs de photos, vous devez √©galement configurer l'architecture et d√©composer la logique, car l'application dispose de diff√©rents outils.  Par exemple, √† Lensa, il y a un outil de bokeh qui brouille l'arri√®re-plan √† l'aide d'un neurone, il y a un outil de retouche qui rend une personne plus belle.  Tout cela doit fonctionner plus efficacement sur le GPU.  De plus, il est conseill√© de ne pas transf√©rer de donn√©es entre le processeur et la carte vid√©o √† chaque fois, mais de pr√©-construire un ensemble d'op√©rations, de les ex√©cuter en une seule fois et de montrer √† l'utilisateur le r√©sultat final. <br><br>  Les pipelines GPU sont des ¬´petits morceaux¬ª √† partir desquels les instructions pour une carte vid√©o sont assembl√©es.  Ensuite, elle fait tout cela tr√®s rapidement et efficacement, et vous prenez le r√©sultat √† la fois, et non apr√®s chaque instrument.  Je m'assure que nos pipelines GPU sont aussi rapides que possible, efficaces et existent g√©n√©ralement en principe. <br><br>  <b>Alexey Kudryavtsev:</b> Dites-moi, comment en √™tes-vous arriv√© l√†?  Un d√©veloppeur iOS r√©gulier commence par riveter et mouler, puis va quelque part par l'API et est content.  Comment est-il arriv√© que vous fassiez quelque chose de compl√®tement diff√©rent? <br><br>  <b>Andrey Volodin:</b> Pour la plupart, c'est une co√Øncidence.  Avant de d√©crocher un emploi, j'ai cr√©√© des jeux pour iOS.  Cela a toujours √©t√© int√©ressant pour moi, mais j'ai compris qu'en Russie, il n'y a surtout nulle part o√π se d√©velopper dans cette direction.  Il se trouve que nous nous sommes rencontr√©s avec Prisma.  Ils avaient besoin d'un d√©veloppeur iOS capable d'√©crire sur Swift et connaissant en m√™me temps le GPU, en particulier Metal, qui vient de sortir √† l'√©poque, et je correspond d√©finitivement √† cette description. <br><br>  J'ai r√©pondu √† la vacance, nous avions une synergie, et pour la troisi√®me ann√©e maintenant, je suis all√© de plus en plus profond√©ment dans cette chose.  Si quelque chose ne va pas maintenant, alors j'ai d√©j√† tous ces Viper et MVVM - je ne sais m√™me pas comment √ßa d√©crypte - je devrai comprendre d√®s le d√©but. <br><br><h2>  Que fait l'ing√©nieur GPU </h2><br>  <b>Daniil Popov:</b> votre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">profil</a> AppsConf indique le GPU Engineer.  Que fait le GPU Engineer la plupart de la journ√©e en plus de boire du caf√©? <br><br>  <b>Andrey Volodin:</b> Ici, il est n√©cessaire de mentionner en quoi le processeur est fondamentalement diff√©rent du GPU.  Le processeur ex√©cute les op√©rations comme si s√©quentiellement.  M√™me le multithreading que nous avons est souvent faux: le processeur s'arr√™te et bascule pour faire de petits morceaux de t√¢ches diff√©rentes, et les ex√©cute en quelques tranches.  Le GPU fonctionne exactement de la mani√®re oppos√©e.  Il existe n processeurs qui fonctionnent r√©ellement en parall√®le, et il existe un parall√©lisme entre les processus et le parall√©lisme au sein du GPU. <br><br>  Mon travail principal, en plus d'optimiser le travail avec la m√©moire et d'organiser la r√©utilisation du code, est de porter les algorithmes √©crits pour le CPU sur les cartes vid√©o afin qu'ils soient parall√®les.  Ce n'est pas toujours une t√¢che banale, car il existe des algorithmes tr√®s efficaces qui sont compl√®tement li√©s √† l'ex√©cution s√©quentielle des instructions.  Mon travail consiste √† trouver, par exemple, une approximation pour un tel algorithme qui ne fait peut-√™tre pas exactement la m√™me chose, mais visuellement le r√©sultat ne peut pas √™tre distingu√©.  Nous pouvons donc obtenir une acc√©l√©ration 100 fois, sacrifiant un peu la qualit√©. <br><br>  Je porte √©galement des neurones.  Soit dit en passant, nous ferons bient√¥t une version majeure de l'Open Source.  Avant m√™me l'apparition de Core ML, nous avions notre propre homologue, et nous avons finalement m√ªri pour le mettre en Open Source.  Son paradigme est l√©g√®rement diff√©rent de Core ML.  Moi, notamment, j'√©labore sa partie centrale. <br><br>  En g√©n√©ral, je fais tout ce qui concerne les algorithmes de vision par ordinateur et l'informatique. <br><br>  <b>Alexey Kudryavtsev:</b> Une annonce int√©ressante. <br><br>  <b>Andrey Volodin:</b> Ce n'est pas un secret, nous ne l'annoncerons pas avec une sorte de fanfare, il sera juste possible de voir un exemple des frameworks utilis√©s √† l'int√©rieur de Prisma. <br><br><h2>  Pourquoi optimiser pour le GPU </h2><br>  <b>Alexei Kudryavtsev:</b> Dites-moi, s'il vous pla√Æt, pourquoi optimisons-nous les algorithmes pour le GPU en g√©n√©ral?  Il peut sembler suffisant d'ajouter des c≈ìurs au processeur ou d'optimiser l'algorithme.  Pourquoi exactement le GPU? <br><br>  <b>Andrey Volodin: Le</b> travail sur le GPU peut consid√©rablement acc√©l√©rer les algorithmes.  Par exemple, nous avons des neurones qui fonctionneront sur le processeur central Samsung S10 pendant 30 s, et sur le GPU, il y aura 1 trame, soit 1/60 s.  C'est une exp√©rience utilisateur incroyablement changeante.  Il n'y a pas d'√©cran de chargement √©ternel, vous pouvez voir le r√©sultat de l'algorithme travaillant sur le flux vid√©o, ou tourner le curseur et voir les effets l√†. <br><br><blockquote>  Ce n'est pas du tout que nous sommes trop cool pour √©crire sur le CPU, donc nous r√©√©crivons tout sur le GPU.  L'utilisation d'un GPU a un objectif transparent - acc√©l√©rer les choses. </blockquote><br>  <b>Alexei Kudryavtsev: Le</b> GPU g√®re bien des op√©rations similaires les unes aux autres en parall√®le.  Avez-vous de telles op√©rations et par cons√©quent r√©ussissez-vous √† obtenir un tel succ√®s? <br><br>  <b>Andrey Volodin:</b> Oui, la principale difficult√© n'est pas de coder, mais de cr√©er de tels algorithmes qui sont bien transf√©r√©s au GPU.  Ce n'est pas toujours trivial.  Il arrive que vous ayez compris comment tout faire cool, mais pour cela, vous avez besoin de trop de points de synchronisation.  Par exemple, vous √©crivez tout dans une seule propri√©t√©, et c'est un signe clair que ce sera mal parall√®le.  Si vous √©crivez beaucoup au m√™me endroit, tous les threads devront se synchroniser pour cela.  Notre t√¢che est d'approximer les algorithmes pour qu'ils soient bien parall√®les. <br><br>  <b>Alexei Kudryavtsev:</b> Pour moi, en tant que d√©veloppeur mobile, cela ressemble √† de la science des fus√©es. <br><br>  <b>Andrey Volodin:</b> En fait, ce n'est pas si difficile.  Pour moi, la science des fus√©es est VIPER. <br><br><h2>  Troisi√®me puce </h2><br>  <b>Daniil Popov:</b> Il semble qu'√† la derni√®re conf√©rence Google I / O, ils aient annonc√© un morceau de fer pour TensorFlow et d'autres choses.  Quand la troisi√®me puce appara√Ætra-t-elle enfin dans les t√©l√©phones mobiles, en TPU ou comment s'appellera-t-elle, qui fera √©galement toute la magie ML sur l'appareil? <br><br>  <b>Andrey Volodin:</b> Nous avons ce truc, il se connecte via USB, et vous pouvez y conduire des neurones de Google.  Huawei a d√©j√† cela, nous avons m√™me √©crit un logiciel pour leurs acc√©l√©rateurs hexagonaux, afin que les neurones de segmentation chassent rapidement le P20. <br><br>  Je dois dire que dans l'iPhone, ils existent d√©j√†.  Par exemple, dans le dernier iPhone XS, il existe un coprocesseur appel√© NPU (Neural Processing Unit), mais jusqu'√† pr√©sent, seul Apple y a acc√®s.  Ce coprocesseur coupe d√©j√† le GPU dans l'iPhone.  Certains mod√®les Core ML utilisent des NPU et sont donc plus rapides que le m√©tal nu. <br><br>  Ceci est important, √©tant donn√© qu'en plus des neurones √† inf√©rence la plus faible, Core ML n√©cessite beaucoup d'actions suppl√©mentaires.  Vous devez d'abord convertir les donn√©es d'entr√©e au format Core ML, il les traitera, puis les renverra dans leur format - vous devez les reconvertir et ensuite les montrer √† l'utilisateur.  Tout cela prend un certain temps.  Nous √©crivons des pipelines sans frais g√©n√©raux qui fonctionnent du d√©but √† la fin sur le GPU, tandis que les mod√®les Core ML sont plus rapides pr√©cis√©ment en raison de ce processus mat√©riel. <br><br><blockquote>  Tr√®s probablement, lors de la WWDC en juin, ils pr√©senteront un cadre pour travailler avec NPU. </blockquote><br>  Autrement dit, comme vous l'avez dit, il existe d√©j√† des appareils, seuls les d√©veloppeurs ne peuvent pas encore les utiliser pleinement.  Mon hypoth√®se est que les entreprises elles-m√™mes ne comprennent pas encore comment proc√©der soigneusement sous la forme d'un cadre.  Ou ils ne veulent tout simplement pas donner pour avoir un avantage sur le march√©. <br><br>  <b>Alexei Kudryavtsev:</b> Avec le scanner d'empreintes digitales, la m√™me chose √©tait dans l'iPhone, si je me souviens bien. <br><br>  <b>Andrey Volodin:</b> Il n'est pas si abordable que √ßa maintenant.  Vous pouvez l'utiliser au niveau sup√©rieur, mais vous ne pouvez pas obtenir l'impression elle-m√™me.  Vous pouvez simplement demander √† Apple de laisser l'utilisateur l'utiliser.  Ce n'est toujours pas un acc√®s complet au scanner lui-m√™me. <br><br><h2>  Acc√©l√©rateurs hexagonaux </h2><br>  <b>Daniil Popov:</b> Vous avez mentionn√© le terme acc√©l√©rateurs hexagonaux.  Je pense que tout le monde ne sait pas ce que c'est. <br><br>  <b>Andrey Volodin:</b> Ce n'est qu'un morceau d'architecture mat√©rielle que Huawei utilise.  Je dois dire qu'elle est plut√¥t sophistiqu√©e.  Peu de gens le savent, mais dans certains Huawei, ces processeurs sont, mais ne sont pas utilis√©s, car ils ont un bug mat√©riel.  Huawei les a lib√©r√©s, puis a trouv√© un probl√®me, maintenant dans certains t√©l√©phones, les puces sp√©ciales sont mortes.  Dans les nouvelles versions, tout fonctionne d√©j√†. <br><br>  En programmation, il y a le paradigme SIMD (Single Instruction, Multiple Data), lorsque les m√™mes instructions sont ex√©cut√©es en parall√®le sur des donn√©es diff√©rentes.  La puce est con√ßue de mani√®re √† pouvoir traiter une op√©ration en parall√®le sur plusieurs flux de donn√©es √† la fois.  En particulier, hexagonal signifie que sur 6 √©l√©ments en parall√®le. <br><br>  <b>Alexei Kudryavtsev:</b> Je pensais que le GPU fonctionne comme ceci: il vectorise une t√¢che et effectue la m√™me op√©ration sur diff√©rentes donn√©es.  Quelle est la diff√©rence? <br><br>  <b>Andrey Volodin</b> : Le GPU est plus polyvalent.  Malgr√© le fait que la programmation pour le GPU soit plut√¥t bas, en ce qui concerne le travail avec les coprocesseurs, c'est assez haut niveau.  Pour la programmation sur le GPU, un langage de type C est utilis√©.  Sur iOS, le code est toujours compil√© avec LLVM dans les instructions de la machine.  Et ces choses pour les coprocesseurs sont le plus souvent √©crites directement hardcore - dans l'assembleur, sur les instructions de la machine.  Par cons√©quent, l'augmentation de la productivit√© est beaucoup plus notable, car ils sont aff√ªt√©s pour des op√©rations sp√©cifiques.  Vous ne pouvez rien compter du tout sur eux, mais vous ne pouvez compter que ce √† quoi ils √©taient initialement destin√©s. <br><br>  <b>Alexei Kudryavtsev:</b> Et pourquoi sont-ils g√©n√©ralement con√ßus? <br><br>  <b>Andrey Volodin:</b> Maintenant principalement pour les op√©rations les plus courantes dans les r√©seaux de neurones: convolution - convolution ou une sorte d'activation interm√©diaire.  Ils ont une fonctionnalit√© pr√©c√¢bl√©e qui fonctionne tr√®s rapidement.  Ils sont donc beaucoup plus rapides sur certaines t√¢ches que le GPU, mais dans tout le reste, ils ne sont tout simplement pas applicables. <br><br>  <b>Alexei Kudryavtsev:</b> Cela ressemble √† des processeurs DSP, qui √©taient autrefois utilis√©s pour l'audio, et tous les plugins et effets y ont fonctionn√© tr√®s rapidement.  Du mat√©riel cher et sp√©cial a √©t√© vendu, mais les processeurs ont grandi, et maintenant nous enregistrons et traitons les podcasts directement sur les ordinateurs portables. <br><br>  <b>Andrey Volodin:</b> Oui, √† peu pr√®s la m√™me chose. <br><br><h2>  GPU non seulement pour les graphiques </h2><br>  <b>Daniil Popov:</b> Je comprends bien que maintenant, sur le GPU, vous pouvez traiter des donn√©es qui ne sont pas directement li√©es aux graphiques?  Il s'av√®re que le GPU perd son objectif d'origine. <br><br>  <b>Andrey Volodin:</b> Exactement.  J'en parle souvent lors de conf√©rences.  Le premier √©tait NVidia, qui a pr√©sent√© CUDA.  Il s'agit d'une technologie qui simplifie le GPGPU (General-purpose computing on graphics processing units).  Vous pouvez y √©crire un sur-ensemble d'algorithmes C ++ parall√©lis√©s sur le GPU. <br><br>  Mais les gens l'ont d√©j√† fait.  Par exemple, les artisans d'OpenGL ou de DirectX encore plus ancien ont simplement √©crit des donn√©es dans la texture - chaque pixel a √©t√© interpr√©t√© comme des donn√©es: les 4 premiers octets du premier pixel, les 4 derniers octets du second.  Ils ont trait√© les textures, puis les donn√©es de la texture ont √©t√© extraites et interpr√©t√©es.  C'√©tait tr√®s compliqu√© et compliqu√©.  Les cartes vid√©o prennent d√©sormais en charge la logique √† usage g√©n√©ral.  Vous pouvez alimenter n'importe quel tampon dans le GPU, d√©crire vos structures, m√™me la hi√©rarchie des structures dans lesquelles elles se r√©f√©reront, calculer quelque chose et le renvoyer au processeur. <br><br>  <b>Daniil Popov:</b> Autrement dit, nous pouvons dire que le GPU est d√©sormais Data PU. <br><br>  <b>Andrey Volodin:</b> Oui, les graphiques sur le GPU sont parfois moins trait√©s que les calculs g√©n√©raux. <br><br>  <b>Alexei Kudryavtsev: L'</b> architecture du CPU et du GPU est diff√©rente dans son essence, mais vous pouvez la consid√©rer √† la fois l√† et l√†. <br><br>  <b>Andrey Volodin</b> : En effet, √† certains √©gards, le CPU est plus rapide, √† certains √©gards le GPU.  Cela ne veut pas dire que le GPU est toujours plus rapide. <br><br>  <b>Daniil Popov:</b> Si je me souviens bien, si la t√¢che consiste √† calculer quelque chose de tr√®s diff√©rent, alors sur le CPU, cela peut √™tre beaucoup plus rapide. <br><br>  <b>Andrey Volodin: Cela</b> d√©pend <b>aussi</b> de la quantit√© de donn√©es.  Il y a toujours la surcharge de transfert de donn√©es du CPU vers le GPU et vice versa.  Si vous consid√©rez, par exemple, un million d'√©l√©ments, l'utilisation d'un GPU est g√©n√©ralement justifi√©e.  Mais compter un millier d'√©l√©ments sur un processeur peut √™tre plus rapide que de simplement les copier sur une carte graphique.  Par cons√©quent, vous devez toujours choisir la t√¢che. <br><br>  Soit dit en passant, Core ML le fait.  Core ML peut ex√©cuter, selon Apple, pour choisir o√π il est plus rapide √† calculer: sur le processeur ou sur la carte vid√©o.  Je ne sais pas si cela fonctionne en r√©alit√©, mais ils disent oui. <br><br><h2>  Connaissances d'ing√©nieur GPU hardcore pour un d√©veloppeur mobile </h2><br>  <b>Alexey Kudryavtsev:</b> Revenons au d√©veloppement mobile.  Vous √™tes un ing√©nieur GPU, vous avez des tonnes de connaissances hardcore.  Comment ces connaissances peuvent-elles √™tre appliqu√©es √† un d√©veloppeur mobile?  Par exemple, que voyez-vous dans UIKit que les autres ne voient pas? <br><br>  <b>Andrey Volodin:</b> Je vais en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parler</a> en d√©tail √† AppsConf.  Vous pouvez appliquer beaucoup o√π.  Quand je vois, par exemple, comment fonctionne l'API UIKit, je peux imm√©diatement comprendre pourquoi cela est fait et pourquoi.  En observant la baisse des performances lors du rendu de certaines vues, je peux comprendre la raison, car je sais comment le rendu est √©crit √† l'int√©rieur.  Je comprends: pour afficher les effets du flou gaussien sur le tampon de trame, vous devez d'abord mettre en cache l'int√©gralit√© de la texture, lui appliquer une op√©ration de flou intense, renvoyer le r√©sultat, terminer le rendu du reste des vues, puis l'afficher uniquement √† l'√©cran.  Tout cela doit tenir en 1/60 de seconde, sinon cela ralentira. <br><br>  Il est absolument √©vident pour moi que ce soit si long, mais pour mes coll√®gues ce n'est pas clair.  C'est pourquoi je veux partager les astuces de conception que nous utilisons souvent dans GameDev, et mes id√©es sur la fa√ßon dont je regarde les probl√®mes et essaie de les r√©soudre.  Ce sera une exp√©rience, mais je pense que cela devrait √™tre int√©ressant. <br><br><h2>  Pourquoi Android n'a pas de flou natif </h2><br>  <b>Daniil Popov:</b> Vous avez mentionn√© le flou, et j'avais une question qui inqui√®te, je pense, tous les d√©veloppeurs Android: pourquoi y a-t-il un natif plus bleu dans iOS et pas dans Android. <br><br>  <b>Andrei Volodin:</b> Je pense que c'est √† cause de l'architecture.  Les plates-formes Apple utilisent l'architecture de rendu Tiled Shading.  Avec cette approche, non pas le cadre entier est rendu, mais de petites tuiles - carr√©s, parties de l'√©cran.  Cela vous permet d'optimiser le fonctionnement de l'algorithme, car le gain de performances principal lors de l'utilisation du GPU permet une utilisation efficace du cache.  Sur iOS, le cadre est souvent rendu afin qu'il n'occupe pas du tout de m√©moire.  Par exemple, sur l'iPhone 7 Plus, la r√©solution est de 1920 * 1080, soit environ 2 millions de pixels.  On multiplie par 4 octets par canal, cela donne environ 20 m√©gaoctets par trame.  20 Mo pour simplement stocker le tampon de trame syst√®me. <br><br>  L'approche Tiled Shading vous permet de diviser ce tampon en petits morceaux et de le rendre un peu.  Cela augmente consid√©rablement le nombre d'acc√®s au cache, car pour flouter, vous devez lire les pixels d√©j√† dessin√©s et calculer la distribution gaussienne sur eux.  Si vous lisez la trame enti√®re, le taux de cache sera tr√®s faible, car chaque flux lira des endroits diff√©rents.  Mais si vous lisez de petits morceaux, le taux de cache sera tr√®s √©lev√© et la productivit√© sera √©galement √©lev√©e. <br><br>  Il me semble que le manque de flou natif dans Android est li√© aux caract√©ristiques architecturales.  Bien qu'il s'agisse peut-√™tre d'une solution de produit. <br><br>  <b>Daniil Popov:</b> Dans Android, il y a RenderScript pour cela, mais l√†, vous devez m√©langer, dessiner, int√©grer avec vos mains.  C'est beaucoup plus compliqu√© que de cocher une case dans iOS. <br><br>  <b>Andrey Volodin:</b> Tr√®s probablement, les performances sont √©galement inf√©rieures. <br><br>  <b>Daniil Popov:</b> Oui, afin de satisfaire la liste de souhaits du concepteur, nous devons r√©duire l'√©chelle de l'image, la bleuir, puis la redimensionner afin de la sauvegarder d'une mani√®re ou d'une autre. <br><br>  <b>Andrey Volodin:</b> Soit dit en passant, avec cela, vous pouvez faire diff√©rentes astuces.  La distribution gaussienne est un cercle flou.  Le sigma de Gauss d√©pend du nombre de pixels que vous souhaitez qu'ils collectent.  Souvent, en tant qu'optimisation, vous pouvez r√©duire l'√©chelle d'une image et r√©tr√©cir l√©g√®rement le sigma, et lorsque vous retournez l'√©chelle d'origine, il n'y aura pas de diff√©rence, car le sigma d√©pend directement de la taille de l'image.  Nous utilisons souvent cette astuce √† l'int√©rieur pour acc√©l√©rer le flou. <br><br>  <b>Daniil Popov:</b> Cependant, RenderScript dans Android ne vous permet pas de cr√©er un rayon sup√©rieur √† 30. <br><br>  <b>Andrey Volodin:</b> En fait, un rayon de 30, c'est beaucoup.  Encore une fois, je comprends que la collecte de 30 pixels √† l'aide d'un GPU sur chaque thread est tr√®s co√ªteuse. <br><br><h2>  Quelles sont les similitudes entre le d√©veloppement mobile et GameDev </h2><br>  <b>Alexei Kudryavtsev:</b> Dans les th√®ses de votre rapport, vous dites que le d√©veloppement mobile et GameDev ont beaucoup en commun.  Dites-moi un peu, quoi exactement? <br><br>  <b>Andrey Volodin: L'</b> architecture d'UIKit n'est pas sans rappeler les moteurs de jeu, et les anciens.  Les modernes sont all√©s dans le sens du syst√®me de composants d'entit√©, et cela figurera √©galement dans le rapport.  Cela vient √©galement d'UIKit, il y a des articles qui √©crivent comment vous pouvez concevoir des vues sur les composants.     GameDev,  Component System    Thief  98 . <br><br> , , Cocos2d,      ,  ,     ,  .  ,    Scene graph ‚Äî  ,      -,        ,    iOS  CGAffineTransform.    4*4,  ,    .     . <br><br>    ,   UIKit      .    -  ‚Äî       .    :  GameDev     ,   UIKit  setNeedsLayout, layoutIfNeeded. <br><br>        ‚Äî  ,   - ,   ,      Apple.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> . <br><br> <b> :</b> , API Cocos2d   iOS ( UI).  ,         ? <br><br> <b> :</b> ,  - . Cocos2d   2008-2009 ,  UIKit    UIKit,    .   ,  -    ,     ,     . <br><br> ,   :  core- Cocos2d    Apple,   Apple   Cocos2d,     . SpriteKit      ,    Cocos2d.    Apple   . <br><br> <b> :</b>  ,   ,   UIKit  2009,    MacOS,     .    setNeedsLayout, layoutIfNeeded ,  . <br><br> <b> :</b> ,  GameDev   ,  MacOS. <br><br> <b> :</b>  ! <br><br> <b> :</b>     Cocos2d   Apple,      ,    GameDev.   GameDev   ,   ‚Äî  .     ,  GameDev   ,    ,   .  ,  ,     . <br><br> <b> :</b> ,    - ,   ‚Äî  . <br><br> <b> </b> : ,   , ,       ,   ‚Äî  .    Protocol-Oriented Programming  Swift, ,    - .  GameDev      . <br><br> <b> :</b>  :     ,   .  ,    ,    ,     . <br><br><h2>     GameDev </h2><br> <b> :</b>    :  GameDev     ,    GameDev    ? <br><br> <b> :</b>  ,    ,     .       ¬´  ,  ¬ª.    ,     .      :    ,    ,  . <br><br> GameDev-    .     : 30  60        ,  ,   ,    .   ,      .      ‚Äî       .  --   1/60  1/30 .   ,     , ,  GPU  ,   CPU .        ,    . <br><br> <b> :</b>         ? <br><br> <b> :</b>    . -       , , ,         .     ‚Äî   .     , , ,  ‚Äî  - ,  - ,  .      ,      ,      . <br><br>      . , GPU     float,    double, -    . , ,     ,    .  CPU  ,        ,       ,   GPU     . <br><br>      ,      ,    ‚Äî     . <br><br><h2>      GameDev,    </h2><br> <b> :</b>        ,  ¬´     GameDev,   ¬ª.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    ,     ,   .     ,  GameDev ‚Äî      .        ,  .      GameDev. <br><br> <b> :</b> , enterprise-   ,    GameDev    .      .   ,     ,    GameDev,     . <br><br> ,  .    ,      4*4.  CGAffineTransform ‚Äî    ,   -        ,   . <br><br><blockquote>        ,     ,   ,  ,    . </blockquote><br><h2>    </h2><br> <b> :</b>       ?  ,       UIKit,     ,     ?  ,   ,       ,   .   ,     ? <br><br> <b> :</b>    ‚Äî   pet project. <br><br> ,      :    GPU     ,     . iOS GPU      ,     .    iOS     ,     -  NVidia  AMD-   .    . API  ,   ,         . <br><br> <b> :</b>   API, ,   Cocos2d  Unity,      ‚Äî   - .    ,    ,   ,   UIKit    ? <br><br> <b> :</b> Cocos2d ‚Äî Open Source    .    ,      ,   ,     ,     .       objective-C,        . <br><br>      pet project,          ,   ,   API,  , , -. ,   API,   VHS-.    ,   GPU.    ,     .     ,      .      ,   : ¬´     saturation  Instagram,   lightroom!¬ª ,   ,   4      ‚Äî  . <br><br><blockquote>     ,   . </blockquote><br>         ‚Äî ,   , .     ,      ,    -  ,   ,      ,   . <br><br> <b> :</b>    ,   -  . ,  Cocos2d -  ‚Äî  5  ,       ,    ,    ,   . ,       ,   ,    .. <br><br> <b> :</b>   .       ,   .   ,         ,          ,        ,        ,    , , ,    ,     . <br><br> <b> :</b>     ,       . ,     ,    . <br><br> <b> :</b>     .    ,  ,       .       ,      Apple,   ARKit.       ,       ,    .    ,     ,        ,     ,   . <br><br> ,            ,  : ¬´,      IDE, ,   ,     ,   .        ¬ª. <br><br> <b> :</b>   ‚Äî  ? <br><br> <b> :</b> , ,    ,      . <br><br> <b> :</b>   ,   ,       . <br><br> <b> :</b> ,      ,   ,  VR   .    Project Template  Xcode,    ,   , - .    ,       . <br><br> <b> :</b>       . <br><br><h2>  </h2><br> <b> :</b>  -  ,      GameDev  GPU. <br><br> <b> :</b>    .   - ,      ,   ,  .   ,         ,   ,   ,  ,      UI: ,  , runtime Objective-C ‚Äî  ,    ,     .     .      ,     : ,  ‚Äî , X  Y, ! <br><br><blockquote>    ,  ,  - ,  GameDev  GPU- ‚Äî   . </blockquote><br> <b>        ,   .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf</a> 22  23     .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448222/">https://habr.com/ru/post/fr448222/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448212/index.html">Protocole chinois AIBUS et r√©acteur chimique de laboratoire</a></li>
<li><a href="../fr448214/index.html">Proxy ES6 en pratique</a></li>
<li><a href="../fr448216/index.html">Configurer un assemblage pratique de projets dans Visual Studio</a></li>
<li><a href="../fr448218/index.html">Nouvelle s√©curit√© MFP: imageRUNNER ADVANCE III</a></li>
<li><a href="../fr448220/index.html">Les bases du format GLTF et GLB, partie 1</a></li>
<li><a href="../fr448224/index.html">AppsConf pour les gouverner tous</a></li>
<li><a href="../fr448226/index.html">A la recherche de l'un (sujets de rapport pour AppsConf)</a></li>
<li><a href="../fr448228/index.html">Types de mod√©lisation. Bases de la sculpture, de la r√©topologie et du balayage</a></li>
<li><a href="../fr448230/index.html">G√©rer la continuit√© des op√©rations avec ClearView</a></li>
<li><a href="../fr448234/index.html">AI et MO: quelques tendances et tendances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>