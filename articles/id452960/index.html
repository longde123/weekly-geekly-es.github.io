<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏽 😫 🤶🏻 Anda akan menjawab untuk semuanya! Kontrak yang Didorong Konsumen melalui mata pengembang 🚵🏼 👊🏽 🕴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kita akan berbicara tentang masalah yang dipecahkan oleh Kontrak yang Didorong Konsumen, dan menunjukkan cara menerapkannya dengan m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anda akan menjawab untuk semuanya! Kontrak yang Didorong Konsumen melalui mata pengembang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/452960/">  Pada artikel ini, kita akan berbicara tentang masalah yang dipecahkan oleh Kontrak yang Didorong Konsumen, dan menunjukkan cara menerapkannya dengan menggunakan contoh Pakta dengan Node.js dan Spring Boot.  Dan bicarakan keterbatasan pendekatan ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/vg/za/guvgzadja02vflw5bi8mgh_wbbo.png"></div><br><h2>  Masalah </h2><br>  Saat menguji produk, pengujian skenario sering digunakan di mana integrasi berbagai komponen sistem dalam lingkungan yang dipilih khusus diperiksa.  Tes semacam itu pada layanan langsung memberikan hasil yang paling dapat diandalkan (tidak termasuk tes dalam pertempuran).  Tetapi pada saat yang sama, mereka adalah salah satu yang paling mahal. <br><a name="habracut"></a><br><ul><li>  Sering keliru dipercaya bahwa lingkungan integrasi seharusnya tidak toleran terhadap kesalahan.  SLA, jaminan untuk lingkungan seperti itu jarang diucapkan, tetapi jika itu tidak tersedia, tim harus menunda rilis, atau berharap untuk yang terbaik dan pergi ke pertempuran tanpa ujian.  Meskipun semua orang tahu bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harapan bukanlah strategi</a> .  Dan teknologi infrastruktur bermodel baru hanya mempersulit pekerjaan dengan lingkungan integrasi. </li><li>  <b>Nyeri lain bekerja dengan data uji</b> .  Banyak skenario membutuhkan kondisi sistem tertentu, perlengkapan.  Seberapa dekat mereka dengan data pertempuran?  Bagaimana cara memperbaruinya sebelum ujian dan membersihkannya setelah selesai? </li><li> <b>Tes terlalu tidak stabil</b> .  Dan bukan hanya karena infrastruktur yang kami sebutkan di paragraf pertama.  Tes mungkin gagal karena tim tetangga meluncurkan cek sendiri yang merusak kondisi sistem yang diharapkan!  Banyak cek negatif palsu, tes tidak pasti mengakhiri hidup mereka di <code>@Ignored</code> .  Juga, berbagai bagian integrasi dapat didukung oleh tim yang berbeda.  Mereka meluncurkan kandidat rilis baru dengan kesalahan - mereka menghancurkan semua konsumen.  Seseorang memecahkan masalah ini dengan loop tes khusus.  Tetapi dengan biaya mengalikan biaya dukungan. </li><li>  <b>Tes semacam itu membutuhkan banyak waktu</b> .  Bahkan dengan pemikiran otomatis, hasil dapat diharapkan selama berjam-jam. </li><li>  Dan to top it off, jika tes benar-benar jatuh, maka jauh dari selalu mungkin untuk segera menemukan penyebab masalahnya.  Itu bisa bersembunyi jauh di balik lapisan integrasi.  Atau mungkin merupakan hasil kombinasi tak terduga dari banyak komponen sistem. </li></ul><br>  Tes yang stabil dalam lingkungan integrasi memerlukan investasi serius dari QA, dev, dan bahkan ops.  Tidak heran mereka berada di puncak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">piramida tes</a> .  Tes semacam itu berguna, tetapi ekonomi sumber daya tidak memungkinkan mereka memeriksa semuanya.  Sumber utama nilainya adalah lingkungan. <br><br>  Di bawah piramida yang sama adalah tes lain di mana kami bertukar kepercayaan untuk sakit kepala dukungan yang lebih kecil - menggunakan pemeriksaan isolasi.  Granular, semakin kecil skala tes, semakin sedikit ketergantungan pada lingkungan eksternal.  Di bagian paling bawah piramida adalah unit test.  Kami memeriksa fungsi individu, kelas, kami beroperasi tidak begitu banyak dengan semantik bisnis seperti halnya dengan konstruksi implementasi tertentu.  Tes-tes ini memberikan umpan balik cepat. <br><br>  Tapi begitu kita turun piramida, kita harus mengganti lingkungan dengan sesuatu.  Rintisan bertopik muncul - sebagai keseluruhan layanan, dan entitas individu dari bahasa pemrograman.  Dengan bantuan colokan, kita dapat menguji komponen secara terpisah.  Tetapi mereka juga mengurangi validitas cek.  Bagaimana cara memastikan bahwa rintisan mengembalikan data yang benar?  Bagaimana memastikan kualitasnya? <br><br>  <b>Solusinya dapat berupa dokumentasi komprehensif</b> yang menggambarkan berbagai skenario dan kemungkinan status komponen sistem.  Tetapi setiap formulasi masih meninggalkan kebebasan interpretasi.  Oleh karena itu, dokumentasi yang baik adalah artefak hidup yang terus membaik seiring tim memahami bidang masalahnya.  Lalu bagaimana memastikan kepatuhan dengan bertopik dokumentasi? <br><br>  Pada banyak proyek, Anda dapat mengamati situasi di mana tulisan rintisan ditulis oleh orang yang sama yang mengembangkan artefak tes.  Misalnya, pengembang aplikasi seluler membuat sendiri selokan untuk pengujian mereka.  Akibatnya, programmer dapat memahami dokumentasi dengan caranya sendiri (yang benar-benar normal), mereka membuat tulisan rintisan dengan perilaku yang diharapkan salah, menulis kode sesuai dengan itu (dengan tes hijau), dan kesalahan terjadi selama integrasi nyata. <br><br>  Selain itu, dokumentasi biasanya bergerak ke hilir - klien menggunakan spesifikasi layanan (dalam hal ini, layanan lain dapat menjadi klien dari layanan).  Itu tidak mengungkapkan <strong>bagaimana</strong> konsumen menggunakan data, data apa yang dibutuhkan sama sekali, asumsi apa yang mereka buat untuk data itu.  Konsekuensi dari ketidaktahuan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum Hyrum</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ek/bh/ho/ekbhhofe0ox95w50drdg8tybsbi.png" width="300"></div><br><br>  Hyrum Wright telah mengembangkan alat publik di dalam Google untuk waktu yang lama dan telah mengamati bagaimana perubahan terkecil dapat menyebabkan gangguan bagi pelanggan yang menggunakan fitur tersirat (tidak terdokumentasi) dari perpustakaannya.  Konektivitas tersembunyi semacam itu menyulitkan evolusi API. <br><br>  Masalah-masalah ini dapat diselesaikan sampai batas tertentu menggunakan Kontrak yang Didorong Konsumen.  Seperti pendekatan dan alat apa pun, alat ini memiliki serangkaian penerapan dan biaya, yang juga akan kami pertimbangkan.  Implementasi pendekatan ini telah mencapai tingkat kematangan yang cukup untuk mencoba proyek mereka. <br><br><h2>  Apa itu CDC? </h2><br>  Tiga elemen kunci: <br><br><ul><li>  <b>Kontrak</b>  Dijelaskan menggunakan beberapa DSL, implementasi tergantung.  Ini berisi deskripsi API dalam bentuk skenario interaksi: jika permintaan tertentu tiba, maka klien harus menerima respons tertentu. </li><li>  <b>Tes pelanggan</b> .  Selain itu, mereka menggunakan rintisan, yang secara otomatis dihasilkan dari kontrak. </li><li>  <b>Tes untuk API</b> .  Mereka juga dihasilkan dari kontrak. </li></ul><br>  Dengan demikian, kontrak dapat dieksekusi.  Dan fitur utama dari pendekatan ini adalah persyaratan untuk perilaku API naik, dari klien ke server. <br><br>  Kontrak berfokus pada perilaku yang <strong>benar</strong> - <strong>benar</strong> penting bagi konsumen.  Jadikan asumsinya tentang API secara eksplisit. <br><br>  Tujuan utama CDC adalah untuk membawa pemahaman tentang perilaku API kepada pengembang dan pengembang kliennya.  Pendekatan ini dikombinasikan dengan BDD, pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertemuan tiga amigo</a> Anda dapat membuat sketsa kosong untuk kontrak.  Pada akhirnya, kontrak ini juga berfungsi untuk meningkatkan komunikasi;  berbagi pemahaman bersama tentang area masalah dan mengimplementasikan solusi di dalam dan di antara tim. <br><br><h2>  Pakta </h2><br>  Pertimbangkan untuk menggunakan CDC sebagai contoh dari Pact, salah satu implementasinya.  Misalkan kita membuat aplikasi web untuk peserta konferensi.  Dalam iterasi berikutnya, tim mengembangkan jadwal presentasi - sejauh ini tanpa cerita seperti voting atau catatan, hanya output dari grid laporan.  Kode sumber untuk contoh ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Pada pertemuan <s>tiga</s> empat amigo, sebuah produk, penguji, pengembang backend dan aplikasi mobile bertemu.  Mereka mengatakan itu <br><br><ul><li>  Daftar dengan teks akan ditampilkan di UI: Judul laporan + Pembicara + Tanggal dan waktu. </li><li>  Untuk melakukan ini, backend harus mengembalikan data seperti pada contoh di bawah ini. </li></ul><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }</code> </pre> <br>  Setelah itu pengembang frontend menulis kode klien (backend untuk frontend).  Dia menginstal pakta kontrak kontrak dalam proyek: <br><br><pre> <code class="bash hljs">yarn add --dev @pact-foundation/pact</code> </pre> <br>  Dan mulai menulis ujian.  Ini mengkonfigurasi server rintisan lokal, yang akan mensimulasikan layanan dengan jadwal laporan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pact({ <span class="hljs-comment"><span class="hljs-comment">//      consumer: "schedule-consumer", provider: "schedule-producer", // ,     port: pactServerPort, //  pact     log: path.resolve(process.cwd(), "logs", "pact.log"), // ,     dir: path.resolve(process.cwd(), "pacts"), logLevel: "WARN", //  DSL  spec: 2 });</span></span></code> </pre> <br>  Kontrak adalah file JSON yang menggambarkan skenario klien yang berinteraksi dengan layanan.  Tetapi Anda tidak perlu mendeskripsikannya secara manual, karena ini dibentuk dari pengaturan rintisan dalam kode.  Pengembang sebelum tes menjelaskan perilaku berikut. <br><br><pre> <code class="javascript hljs">provider.setup().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> provider .addInteraction({ <span class="hljs-attr"><span class="hljs-attr">uponReceiving</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">withRequest</span></span>: { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">willRespondWith</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] } } }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()) );</code> </pre> <br>  Di sini, dalam contoh, kami menentukan permintaan layanan spesifik yang diharapkan, tetapi pact-js juga mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa metode untuk menentukan kecocokan</a> . <br><br>  Akhirnya, programmer menulis tes bagian kode yang menggunakan rintisan ini.  Dalam contoh berikut, kami akan menyebutnya langsung untuk kesederhanaan. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"fetches schedule"</span></span>, done =&gt; { fetch(<span class="hljs-string"><span class="hljs-string">`http://localhost:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${pactServerPort}</span></span></span><span class="hljs-string">/schedule`</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">json</span></span></span><span class="hljs-function"> =&gt;</span></span> expect(json).toStrictEqual({ <span class="hljs-attr"><span class="hljs-attr">talks</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">speakers</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] })) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> done()); });</code> </pre> <br>  Dalam proyek nyata, ini bisa berupa unit tes cepat dari fungsi interpretasi respon yang terpisah atau tes UI lambat untuk menampilkan data yang diterima dari layanan. <br><br>  Selama uji coba, pakta memverifikasi bahwa rintisan menerima permintaan yang ditentukan dalam tes.  Perbedaan ini dapat dilihat sebagai perbedaan pada file pact.log. <br><br><pre> <code class="plaintext hljs">E, [2019-05-21T01:01:55.810194 #78394] ERROR -- : Diff with interaction: "a request for schedule" Diff -------------------------------------- Key: - is expected + is actual Matching keys and values are not shown { "headers": { - "Accept": "application/json" + "Accept": "*/*" } } Description of differences -------------------------------------- * Expected "application/json" but got "*/*" at $.headers.Accept</code> </pre> <br><br>  Jika tes berhasil, kontrak dihasilkan dalam format JSON.  Ini menjelaskan perilaku yang diharapkan dari API. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"consumer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-consumer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"provider"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"schedule-producer"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"interactions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"a request for schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"request"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"method"</span></span>: <span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/schedule"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Accept"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"response"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"status"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"headers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Content-Type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json;charset=UTF-8"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"body"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"talks"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>:<span class="hljs-string"><span class="hljs-string">"      "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"speakers"</span></span>:[ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">" "</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>:<span class="hljs-string"><span class="hljs-string">"2019-05-27T12:00:00+03:00"</span></span> } ] }}} ], <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pactSpecification"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"2.0.0"</span></span> } } }</code> </pre> <br>  Dia memberikan kontrak ini kepada pengembang backend.  Katakanlah API ada di Spring Boot.  Pact memiliki perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pact-jvm-provider-spring</a> yang dapat bekerja dengan MockMVC.  Tetapi kita akan melihat pada Spring Cloud Contract, yang mengimplementasikan CDC dalam ekosistem Spring.  Ia menggunakan format kontraknya sendiri, tetapi juga memiliki titik ekstensi untuk menghubungkan konverter dari format lain.  Format kontrak aslinya hanya didukung oleh Kontrak Spring Cloud itu sendiri - tidak seperti Pact, yang memiliki perpustakaan untuk JVM, Ruby, JS, Go, Python, dll. <br><br>  Misalkan, dalam contoh kita, pengembang backend menggunakan Gradle untuk membangun layanan.  Ini menghubungkan dependensi berikut: <br><br><pre> <code class="plaintext hljs">buildscript { // ... dependencies { classpath "org.springframework.cloud:spring-cloud-contract-pact:2.1.1.RELEASE" } } plugins { id "org.springframework.cloud.contract" version "2.1.1.RELEASE" // ... } // ... dependencies { // ... testImplementation 'org.springframework.cloud:spring-cloud-starter-contract-verifier' }</code> </pre> <br>  Dan itu menempatkan kontrak Pakta yang diterima dari frotender ke direktori <code>src/test/resources/contracts</code> . <br><br>  Dari situ, secara default, plugin spring-cloud-contract mengurangi kontrak.  Selama perakitan, tugas gradle generateContractTests dieksekusi, yang menghasilkan tes berikut di direktori build / generate-test-sources. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// given: MockMvcRequestSpecification request = given() .header("Accept", "application/json"); // when: ResponseOptions response = given().spec(request) .get("/scheduler"); // then: assertThat(response.statusCode()).isEqualTo(200); assertThat(response.header("Content-Type")).isEqualTo("application/json;charset=UTF-8"); // and: DocumentContext parsedJson = JsonPath.parse(response.getBody().asString()); assertThatJson(parsedJson).array("['talks']").array("['speakers']").contains("['name']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['time']").isEqualTo( /*...*/ ); assertThatJson(parsedJson).array("['talks']").contains("['title']").isEqualTo( /*...*/ ); } }</span></span></code> </pre> <br><br>  Saat memulai tes ini, kita akan melihat kesalahan: <br><br><pre> <code class="plaintext hljs">java.lang.IllegalStateException: You haven't configured a MockMVC instance. You can do this statically</code> </pre> <br>  Karena kita dapat menggunakan alat yang berbeda untuk pengujian, kita perlu memberi tahu plug-in mana yang telah kita konfigurasikan.  Ini dilakukan melalui kelas dasar, yang akan mewarisi tes yang dihasilkan dari kontrak. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ScheduleController scheduleController = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScheduleController(); <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RestAssuredMockMvc.standaloneSetup(scheduleController); } }</code> </pre> <br><br>  Untuk menggunakan kelas dasar ini selama pembuatan, Anda perlu mengonfigurasi plugin gradle spring-cloud-contract. <br><br><pre> <code class="plaintext hljs">contracts { baseClassForTests = 'ru.example.schedule.ContractsBaseTest' }</code> </pre> <br><br>  Sekarang kami memiliki tes berikut yang dihasilkan: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractVerifierTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContractsBaseTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_aggregator_client_aggregator_service</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  Tes dimulai dengan sukses, tetapi gagal dengan kesalahan verifikasi - pengembang belum menulis implementasi layanan.  Tapi sekarang dia bisa melakukannya berdasarkan kontrak.  Dia dapat memastikan bahwa dia dapat memproses permintaan klien dan mengembalikan respons yang diharapkan. <br><br>  Pengembang layanan mengetahui melalui kontrak apa yang perlu dia lakukan, perilaku apa yang harus diterapkan. <br><br>  Pakta dapat diintegrasikan lebih dalam ke dalam proses pengembangan.  Anda dapat menggunakan Pact-broker yang mengagregasi kontrak tersebut, mendukung versi mereka, dan dapat menampilkan grafik ketergantungan. <br><br><img src="https://habrastorage.org/webt/dq/pd/v0/dqpdv0c4qk89kboewjxrafys1iq.png"><br><br>  Mengunggah kontrak baru yang dihasilkan ke pialang dapat dilakukan pada langkah CI saat membangun klien.  Dan dalam kode server menunjukkan pemuatan dinamis kontrak dengan URL.  Kontrak Spring Cloud juga mendukung ini. <br><br><h2>  Penerapan CDC </h2><br>  Apa batasan dari Kontrak yang Didorong Konsumen? <br><br>  Untuk menggunakan pendekatan ini, <b>Anda harus membayar dengan alat tambahan</b> seperti pakta.  Kontrak per se adalah artefak tambahan, abstraksi lain yang harus dipelihara dengan hati-hati dan secara sadar menerapkan praktik-praktik rekayasa. <br><br>  <b>Mereka tidak menggantikan tes e2e</b> , karena bertopik masih tetap bertopik - model komponen sistem nyata, yang mungkin sedikit, tetapi tidak sesuai dengan kenyataan.  Melalui mereka, skenario kompleks tidak dapat diverifikasi. <br><br>  Juga, <b>CDC tidak menggantikan tes fungsional API</b> .  Mereka lebih mahal untuk didukung daripada Tes Unit Lama Biasa.  Pengembang pakta merekomendasikan menggunakan heuristik berikut - jika Anda menghapus kontrak dan ini tidak menyebabkan kesalahan atau salah tafsir oleh klien, maka itu tidak diperlukan.  Misalnya, tidak perlu untuk menguraikan sepenuhnya semua kode kesalahan API melalui kontrak jika klien memprosesnya dengan cara yang sama.  Dengan kata lain, kontrak hanya menjelaskan untuk layanan <strong>yang penting bagi kliennya</strong> .  Tidak lebih, tetapi tidak kurang. <br><br>  Terlalu banyak kontrak juga mempersulit evolusi API.  <b>Setiap kontrak tambahan adalah kesempatan untuk tes merah</b> .  Adalah penting untuk merancang CDC sedemikian rupa sehingga setiap pengujian gagal membawa beban semantik yang berguna melebihi biaya dukungannya.  Misalnya, jika kontrak menetapkan panjang minimum bidang teks tertentu yang tidak peduli pada konsumen (ia menggunakan teknik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembaca Toleran</a> ), maka setiap perubahan pada nilai minimum ini akan memutus kontrak dan saraf orang-orang di sekitarnya.  Pemeriksaan semacam itu perlu ditransfer ke tingkat API itu sendiri dan dilaksanakan tergantung pada sumber pembatasan. <br><br><h2>  Kesimpulan </h2><br>  CDC meningkatkan kualitas produk dengan menjelaskan perilaku integrasi secara eksplisit.  Ini membantu pelanggan dan pengembang layanan untuk mencapai pemahaman bersama, memungkinkan Anda untuk berbicara melalui kode.  Tetapi ini dilakukan dengan biaya menambahkan alat, memperkenalkan abstraksi baru dan tindakan tambahan dari anggota tim. <br><br>  Pada saat yang sama, alat dan kerangka kerja CDC sedang dikembangkan secara aktif dan telah mencapai kematangan untuk pengujian pada proyek Anda.  Tes :) <br><br><blockquote>  Pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QualityConf</a> pada 27-28 Mei, Andrei Markelov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan berbicara</a> tentang teknik pengujian pada prod, dan Arthur Khineltsev akan berbicara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang pemantauan</a> front-end yang sangat dimuat, ketika harga bahkan kesalahan kecil adalah puluhan ribu pengguna yang sedih. <br><br>  Ayo ngobrol untuk kualitas! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452960/">https://habr.com/ru/post/id452960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452946/index.html">Membaca ulang Lou Greenaw “Windows 95 / NT Programming Philosophy”</a></li>
<li><a href="../id452952/index.html">JetBrains Open Day di St. Petersburg</a></li>
<li><a href="../id452954/index.html">Membangun waktu, kecepatan jaringan dan perutean: bagaimana kami meningkatkan jaringan mesh kami dan sedikit tentang jaringan saraf</a></li>
<li><a href="../id452956/index.html">Benchmark konsumsi CPU untuk Istio dan Linkerd</a></li>
<li><a href="../id452958/index.html">JMAP - protokol terbuka menggantikan IMAP saat bertukar email</a></li>
<li><a href="../id452962/index.html">Penyebab utama kecelakaan di pusat data adalah peletakan antara komputer dan kursi</a></li>
<li><a href="../id452964/index.html">Penjelasan yang terjangkau dari hipotesis Riemann</a></li>
<li><a href="../id452966/index.html">Mitos kesadaran: pandangan meditasi "neurosentris"</a></li>
<li><a href="../id452968/index.html">Indeks dalam PostgreSQL - 10 (Bloom)</a></li>
<li><a href="../id452974/index.html">Pemrograman asinkron (kursus penuh)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>