<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👫 🚹 🐩 Golang API Framework 🧑🏽‍🤝‍🧑🏽 🏰 🔭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während ich Golang kennenlernte, beschloss ich, den Rahmen für die Anwendung festzulegen, mit dem ich in Zukunft bequem arbeiten kann. Das Ergebnis wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang API Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455302/"><p>  Während ich Golang kennenlernte, beschloss ich, den Rahmen für die Anwendung festzulegen, mit dem ich in Zukunft bequem arbeiten kann.  Das Ergebnis war meiner Meinung nach ein gutes Werkstück, das ich teilen und gleichzeitig die Momente diskutieren wollte, die während der Erstellung des Rahmens entstanden sind. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/599/73a/8a9/59973a8a925f690405c0f171fdd53048.jpg" alt="Bild"></p><br><p>  Im Prinzip deutet das Design der Go-Sprache darauf hin, dass keine umfangreichen Anwendungen erforderlich sind (ich meine das Fehlen von Generika und einen nicht sehr leistungsfähigen Fehlerbehandlungsmechanismus).  Wir wissen jedoch immer noch, dass die Größe der Anwendungen normalerweise nicht abnimmt, sondern häufiger im Gegenteil.  Daher ist es besser, sofort ein Framework zu erstellen, in dem neue Funktionen verknüpft werden können, ohne die Codeunterstützung zu beeinträchtigen. </p><a name="habracut"></a><br><p>  Ich habe versucht, weniger Code in den Artikel einzufügen, stattdessen habe ich Links zu bestimmten Codezeilen auf Github hinzugefügt, in der Hoffnung, dass es bequemer wäre, das gesamte Bild zu sehen. </p><br><p>  Zuerst skizzierte ich einen Plan für das, was in der Anwendung enthalten sein sollte.  Da ich in dem Artikel über jedes Element einzeln sprechen werde, werde ich zuerst das Hauptelement aus dieser Liste als Inhalt angeben. </p><br><ul><li>  Wählen Sie den Paketmanager </li><li> Wählen Sie ein Framework zum Erstellen einer API </li><li>  Wählen Sie das Werkzeug für die Abhängigkeitsinjektion (DI). </li><li>  Webanforderungsrouten </li><li>  JSON / XML-Antworten gemäß Anforderungsheadern </li><li>  ORM </li><li>  Migrationen </li><li>  Erstellen Sie Basisklassen für Modellebenen Service-&gt; Repository-&gt; Entität </li><li>  Grundlegendes CRUD-Repository </li><li>  Grundlegender CRUD-Service </li><li>  Grundlegender CRUD-Controller </li><li>  Validierung anfordern </li><li>  Konfigurationen und Umgebungsvariablen </li><li>  Konsolenbefehle </li><li>  Protokollierung </li><li>  Logger-Integration mit Sentry oder einem anderen Warnsystem </li><li>  Alarm für Fehler einstellen </li><li>  Unit-Tests mit Neudefinition von Diensten durch DI </li><li>  Prozent- und Testabdeckungscode-Karte </li><li>  Prahlerei </li><li>  Docker komponieren </li></ul><br><h2 id="menedzher-paketov">  Paketmanager </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachdem ich die</a> Beschreibungen für verschiedene Implementierungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelesen hatte</a> , entschied <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich</a> mich für den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gouverneur</a> und war im Moment mit der Wahl zufrieden.  Der Grund ist einfach: Sie können Abhängigkeiten mit der Anwendung im Verzeichnis installieren und Informationen zu Paketen und deren Versionen speichern. </p><br><p>  Informationen zu Paketen und ihren Versionen werden in einer vendor.json- <a href="">Datei gespeichert</a> .  Auch bei diesem Ansatz gibt es ein Minus.  Wenn Sie ein Paket mit seinen Abhängigkeiten hinzufügen, werden neben Informationen zum Paket auch Informationen zu seinen Abhängigkeiten in die Datei aufgenommen.  Die Datei wächst schnell und es ist nicht mehr möglich, eindeutig zu bestimmen, welche Abhängigkeiten die Hauptabhängigkeiten und welche Ableitungen sind. </p><br><p>  In PHP Composer oder in npm werden die Hauptabhängigkeiten in einer Datei beschrieben, und alle Haupt- und abgeleiteten Abhängigkeiten und ihre Versionen werden automatisch in der Sperrdatei aufgezeichnet.  Dieser Ansatz ist meiner Meinung nach bequemer.  Aber für den Moment hat mir die Implementierung des Gouverneurs gereicht. </p><br><h2 id="freymvork">  Framework </h2><br><p>  Aus dem Framework brauche ich nicht viel, einen praktischen Router, die Validierung von Anfragen.  All dies wurde im beliebten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gin gefunden</a> .  Er blieb stehen. </p><br><h2 id="dependency-injection">  Abhängigkeitsinjektion </h2><br><p>  Mit DI musste ich ein wenig leiden.  Zuerst wählte Dig.  Und anfangs war alles super.  Beschriebene Dienste, Dig baut bequemerweise weitere Abhängigkeiten auf.  Dann stellte sich jedoch heraus, dass Dienste beispielsweise beim Testen nicht neu definiert werden können.  Daher kam ich am Ende zu dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schluss,</a> dass ich einen einfachen Servicebehälter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sarulabs / di genommen habe</a> . </p><br><p>  Ich musste es nur gabeln, weil es Ihnen sofort erlaubt, Dienste hinzuzufügen, und verbietet, sie neu zu definieren.  Und beim Schreiben von Autotests ist es meiner Meinung nach bequemer, den Container wie in der Anwendung zu initialisieren und dann einige der Dienste neu zu definieren und stattdessen Stubs anzugeben.  In Fork fügte er eine Methode hinzu, um die Beschreibung des Dienstes zu überschreiben. </p><br><p> Aber am Ende musste ich sowohl im Fall von Dig als auch im Fall des Service-Containers die Tests in ein separates Paket packen.  Andernfalls stellt sich heraus, dass die Tests separat in Paketen ausgeführt werden ( <code>go test model/service</code> ), aber aufgrund der auftretenden zyklischen Abhängigkeiten nicht sofort für die gesamte Anwendung gestartet werden ( <code>go test ./...</code> ). </p><br><h2 id="otvety-v-formate-jsonxml-v-sootvetstvii-s-zagolovkami-zaprosa">  JSON / XML-Antworten gemäß Anforderungsheadern </h2><br><p>  In Gin habe ich dies nicht gefunden, daher habe ich dem Basis-Controller eine <a href="">Methode</a> hinzugefügt, die abhängig vom Anforderungsheader eine Antwort generiert. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c BaseController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context *gin.Context, obj </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, code </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> context.GetHeader(<span class="hljs-string"><span class="hljs-string">"Accept"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"application/xml"</span></span>: context.XML(code, obj) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: context.JSON(code, obj) } }</code> </pre><br><h2 id="orm">  ORM </h2><br><p>  Mit ORM fühlte sich die lange Qual der Wahl nicht an.  Es gab viel zur Auswahl.  Aber gemäß der Beschreibung der Funktionen mochte ich GORM, das zum Zeitpunkt der Auswahl eines der beliebtesten ist.  Das am häufigsten verwendete DBMS wird unterstützt.  Zumindest PostgreSQL und MySQL sind definitiv da.  Es enthält auch Methoden zum Verwalten des Basisschemas, die Sie beim Erstellen von Migrationen verwenden können. </p><br><h2 id="migracii">  Migrationen </h2><br><p>  Für Migrationen habe ich mich für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gorm-Goose-</a> Paket entschieden.  Ich habe ein separates Paket global abgelegt und die Migration dorthin gestartet.  Eine solche Implementierung war zunächst peinlich, da die Verbindung zur Datenbank in einer separaten <a href="">Datei db / dbconf.yml beschrieben werden musste</a> .  Dann stellte sich jedoch heraus, dass die darin enthaltene Verbindungszeichenfolge so beschrieben werden kann, dass der Wert der Umgebungsvariablen entnommen wird. </p><br><pre> <code class="plaintext hljs">development: driver: postgres open: $DB_URL</code> </pre> <br><p>  Und das ist ganz praktisch.  Zumindest mit Docker-Compose musste ich die <a href="">Verbindungszeichenfolge</a> nicht duplizieren. </p><br><p>  Gorm-Goose unterstützt auch Migrations-Rollbacks, was ich sehr nützlich finde. </p><br><h2 id="bazovyy-crud-repozitoriy">  Grundlegendes CRUD-Repository </h2><br><p>  Ich bevorzuge alles, was sich auf Ressourcen bezieht, in einer separaten Repository-Schicht zu platzieren.  Meiner Meinung nach ist bei diesem Ansatz der Geschäftslogikcode sauberer.  In diesem Fall weiß der Geschäftslogikcode nur, dass er mit den Daten arbeiten muss, die er aus dem Repository entnimmt.  Und was im Repository passiert, ist die Geschäftslogik nicht wichtig.  Das Repository kann mit einer relationalen Datenbank, einem KV-Speicher, einer Festplatte oder möglicherweise mit der API eines anderen Dienstes arbeiten.  Der Geschäftslogikcode ist in all diesen Fällen derselbe. </p><br><p>  Das CRUD-Repository implementiert die folgende <a href="">Schnittstelle</a> </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CrudRepositoryInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BaseRepositoryInterface GetModel() (entity.InterfaceEntity) Find(id <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) (entity.InterfaceEntity, error) List(parameters ListParametersInterface) (entity.InterfaceEntity, error) Create(item entity.InterfaceEntity) entity.InterfaceEntity Update(item entity.InterfaceEntity) entity.InterfaceEntity Delete(id <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>) error }</code> </pre> <br><p>  Das heißt, CRUD implementiert die <code>GetModel()</code> <code>Create()</code> , <code>Find()</code> , <code>List()</code> , <code>Update()</code> , <code>Delete()</code> und die Methode <code>GetModel()</code> . </p><br><p>  Über <a href="">GetModel ()</a> .  Es gibt ein grundlegendes <code>CrudRepository</code> Repository, das grundlegende CRUD-Operationen implementiert.  In den Repositorys, in die es eingebettet ist, reicht es aus, anzugeben, mit welchem ​​Modell sie arbeiten sollen.  Dazu muss die <code>GetModel()</code> -Methode ein GORM-Modell zurückgeben.  Dann mussten wir das Ergebnis von <code>GetModel()</code> Verwendung von Reflektion in CRUD-Methoden verwenden. </p><br><p>  <a href="">Zum Beispiel</a> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c CrudRepository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity.InterfaceEntity, error)</span></span></span></span> { item := reflect.New(reflect.TypeOf(c.GetModel()).Elem()).Interface() err := c.db.First(item, id).Error <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item, err }</code> </pre> <br><p>  Das heißt, in diesem Fall war es notwendig, die statische Typisierung zugunsten der dynamischen Typisierung aufzugeben.  In solchen Momenten ist der Mangel an Generika in der Sprache besonders zu spüren. </p><br><p>  Damit die Repositorys, die mit bestimmten Modellen arbeiten, ihre eigenen Regeln zum Filtern von Listen in der <code>List()</code> -Methode implementieren, habe ich zuerst die späte Bindung implementiert, sodass die für die Erstellung der Auswahlabfrage verantwortliche Methode aus der <code>List()</code> -Methode aufgerufen wird.  Und diese Methode könnte in einem bestimmten Repository implementiert werden.  Es ist schwierig, die Denkmuster, die bei der Arbeit mit anderen Sprachen entstanden sind, irgendwie aufzugeben.  Aber als er dies mit einem frischen Blick betrachtete und die „Eleganz“ des gewählten Pfades schätzte, überarbeitete er ihn zu einem Ansatz, der näher an Go liegt.  Dazu wird einfach in <code>CrudRepository</code> über die Schnittstelle <a href="">ein Abfrage-Builder</a> deklariert, der bereits <a href=""><code>  List()</code></a> . </p><br><pre> <code class="go hljs">listQueryBuilder ListQueryBuilderInterface</code> </pre><br><p>  Es wird ziemlich lustig.  Die Beschränkung der Sprache auf spätes Binden, was zunächst als Fehler erscheint, fördert eine klarere Trennung des Codes. </p><br><h2 id="bazovyy-crud-servis">  Grundlegender CRUD-Service </h2><br><p>  Hier gibt es nichts Interessantes, da das Framework keine Geschäftslogik enthält.  Aufrufe von CRUD-Methoden an das Repository werden einfach <a href="">weitergeleitet</a> . </p><br><p>  In der Serviceschicht muss Geschäftslogik implementiert werden. </p><br><h2 id="bazovyy-crud-kontroller">  Grundlegender CRUD-Controller </h2><br><p>  Der Controller implementiert <a href="">CRUD-Methoden</a> .  Sie verarbeiten die Parameter aus der Anforderung, die Steuerung wird an die entsprechende Dienstmethode übertragen, und basierend auf der Antwort des Dienstes wird eine Antwort an den Client gebildet. </p><br><p>  Mit dem Controller hatte ich die gleiche Geschichte wie mit dem Repository in Bezug auf Filterlisten.  Infolgedessen habe ich die Implementierung mit hausgemachter <a href="">Spätbindung überarbeitet</a> und einen <a href="">Hydrator</a> hinzugefügt, der basierend auf den Anforderungsparametern eine Struktur mit Parametern zum Filtern der Liste bildet. </p><br><p>  In dem mit dem CRUD-Controller gelieferten Hydrator werden nur die Paginierungsparameter verarbeitet.  In den spezifischen Reglern, in die der CRUD-Regler integriert ist, kann der <a href="">Hydrator</a> neu <a href="">definiert werden</a> . </p><br><h2 id="validaciya-zaprosov">  Validierung anfordern </h2><br><p>  Die Validierung wird von Gin durchgeführt.  Wenn Sie beispielsweise einen Datensatz hinzufügen ( <code>Create()</code> -Methode), reicht es aus, <a href="">die</a> Elemente der Entitätsstruktur zu <a href="">dekorieren</a> </p><br><pre> <code class="go hljs">Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`binding:"required"`</span></span></code> </pre> <br><p>  Die <a href=""><code>ShouldBindJSON()</code></a> -Methode des Frameworks überprüft die Anforderungsparameter auf Übereinstimmung mit den im Dekorator beschriebenen Anforderungen. </p><br><h2 id="konfigi-i-peremennye-okruzheniya">  Konfigurationen und Umgebungsvariablen </h2><br><p>  Die Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Viper</a> hat mir sehr gut gefallen, besonders in Verbindung mit Cobra. </p><br><p>  Lesen der Konfiguration, die ich <a href="">in main.go beschrieben habe.</a>  Grundlegende Parameter, die keine Geheimnisse enthalten, werden <a href="">in der Datei base.env beschrieben</a> .  Sie können sie in der .env-Datei überschreiben, die zu .gitignore hinzugefügt wird.  In .env können Sie geheime Werte für die Umgebung beschreiben. </p><br><p>  Umgebungsvariablen haben eine höhere Priorität. </p><br><h2 id="konsolnye-komandy">  Konsolenbefehle </h2><br><p>  Für die Beschreibung der Konsolenbefehle habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cobra gewählt</a> .  Dann ist es gut, Cobra zusammen mit Viper zu verwenden.  Wir können <a href="">den Befehl beschreiben</a> </p><br><pre> <code class="go hljs">serverCmd.PersistentFlags().StringVar(&amp;serverPort, <span class="hljs-string"><span class="hljs-string">"port"</span></span>, defaultServerPort, <span class="hljs-string"><span class="hljs-string">"Server port"</span></span>)</code> </pre> <br><p>  <a href="">Binden Sie die Umgebungsvariable</a> an den Wert des Befehlsparameters </p><br><pre> <code class="go hljs">viper.BindPFlag(<span class="hljs-string"><span class="hljs-string">"SERVER_PORT"</span></span>, serverCmd.PersistentFlags().Lookup(<span class="hljs-string"><span class="hljs-string">"port"</span></span>))</code> </pre> <br><p>  Tatsächlich ist die gesamte Anwendung dieses Frameworks eine Konsole.  Der Webserver wird mit einem der Serverkonsolenbefehle gestartet. </p><br><pre> <code class="bash hljs">gin -i run server</code> </pre> <br><h2 id="logirovanie">  Protokollierung </h2><br><p>  Ich habe das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">logrus-</a> Paket für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Protokollierung ausgewählt</a> , da es alles enthält, was ich normalerweise benötige: Festlegen der Protokollierungsstufen, Protokollieren, Hinzufügen von Hooks, z. B. zum Senden von Protokollen an das Warnsystem. </p><br><h2 id="integraciya-loggera-s-sistemoy-alertinga">  Logger-Integration mit dem Warnsystem </h2><br><p>  Ich habe mich für Sentry entschieden, weil sich dank der einfachen Integration in logrus: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">logrus_sentry</a> alles als recht einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">herausstellte</a> .  Ich habe die <a href="">Parameter</a> mit der URL zu Sentry <code>SENTRY_DSN</code> und dem Timeout für das Senden an Sentry <code>SENTRY_TIMEOUT</code> .  Es stellte sich heraus, dass das Zeitlimit standardmäßig klein ist, wenn nicht falsch, 300 ms, und viele Nachrichten nicht zugestellt wurden. </p><br><h2 id="nastroyka-alertinga-dlya-oshibok">  Alarm für Fehler einstellen </h2><br><p>  Ich habe die Panikverarbeitung separat für den <a href="">Webserver</a> und für <a href="">Konsolenbefehle durchgeführt</a> . </p><br><h2 id="yunit-testy-s-pereopredeleniem-servisov-cherez-di">  Unit-Tests mit Neudefinition von Diensten durch DI </h2><br><p>  Wie oben erwähnt, musste für Unit-Tests ein separates Paket zugewiesen werden.  Da die ausgewählte Bibliothek zum Erstellen eines Dienstcontainers keine Neudefinition von Diensten zuließ, wurde in fork eine Methode zum Neudefinieren der Beschreibung von Diensten hinzugefügt.  Aus diesem Grund können Sie im <a href="">Komponententest</a> dieselbe Beschreibung der Dienste wie in der Anwendung verwenden </p><br><pre> <code class="go hljs">dic.InitBuilder()</code> </pre> <br><p>  Und <a href="">definieren Sie</a> auf diese Weise nur einige Servicebeschreibungen in Stubs neu </p><br><pre> <code class="go hljs">dic.Builder.Set(di.Def{ Name: dic.UserRepository, Build: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctn di.Container)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewUserRepositoryMock(), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, })</code> </pre> <br><p>  Als Nächstes können Sie <a href="">einen Container erstellen</a> und die erforderlichen Dienste im Test verwenden: </p><br><pre> <code class="go hljs">dic.Container = dic.Builder.Build() userService := dic.Container.Get(dic.UserService).(service.UserServiceInterface)</code> </pre> <br><p>  Daher werden wir userService testen, der anstelle des realen Repositorys den bereitgestellten Stub verwendet. </p><br><p>  Prozent- und Testabdeckungscode-Karte <br>  Ich war mit dem Standard-Go-Test-Dienstprogramm völlig zufrieden. </p><br><p>  Sie können Tests einzeln ausführen </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/unit/user_service_test.go -v</code> </pre> <br><p>  Sie können alle Tests gleichzeitig ausführen </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./... -v</code> </pre> <br><p>  Sie können eine Abdeckungskarte erstellen und den Prozentsatz der Abdeckung berechnen </p><br><pre> <code class="bash hljs">go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ./... -v -coverpkg=./... -coverprofile=coverage.out</code> </pre> <br><p>  Und sehen Sie sich eine Karte der Codeabdeckung mit Tests in einem Browser an </p><br><pre> <code class="bash hljs">go tool cover -html=coverage.out</code> </pre> <br><h2 id="swagger">  Prahlerei </h2><br><p>  Für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gin</a> gibt es ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gin-Swagger-</a> Projekt, mit dem sowohl Spezifikationen für Swagger als auch darauf basierende Dokumentationen erstellt werden können.  Wie sich herausstellte, müssen jedoch Kommentare zu bestimmten Funktionen der Steuerung angegeben werden, um Spezifikationen für bestimmte Vorgänge zu generieren.  Dies stellte sich für mich als nicht sehr praktisch heraus, da ich den CRUD-Operationscode nicht in jedem Controller duplizieren wollte.  Stattdessen bettete ich in bestimmten Controllern einfach einen CRUD-Controller wie oben beschrieben ein.  Ich wollte auch dafür keine Stub-Funktionen erstellen. </p><br><p>  Daher bin ich zu dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schluss gekommen,</a> dass die Spezifikation mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">goswagger</a> generiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> , da in diesem Fall die Operationen <a href="">beschrieben werden können, ohne an bestimmte Funktionen gebunden zu sein</a> . </p><br><pre> <code class="bash hljs">swagger generate spec -o doc/swagger.yml</code> </pre> <br><p>  Übrigens, mit goswagger können Sie sogar vom Gegenteil ausgehen und den Webserver-Code basierend auf der Swagger-Spezifikation generieren.  Bei diesem Ansatz gab es jedoch Schwierigkeiten bei der Verwendung von ORM, und ich gab es schließlich auf. </p><br><p>  Die Dokumentation wird mit Gin-Swagger erstellt. Hierzu wird eine vorgenerierte Spezifikationsdatei <a href="">angezeigt</a> . </p><br><h2 id="docker-compose">  Docker komponieren </h2><br><p>  Im Framework habe ich eine Beschreibung von zwei Containern hinzugefügt - <a href="">für den Code und für die Basis</a> .  Zu Beginn des Containers mit dem Code warten wir, bis der Container mit der Basis vollständig gestartet ist.  Und bei jedem Start rollen wir bei Bedarf Migrationen.  Die Parameter für die Verbindung zur Datenbank für Migrationen sind, wie oben erwähnt, in <a href="">dbconf.yml beschrieben</a> , wo die <a href="">Umgebungsvariable</a> zum Übertragen der Einstellungen für die Verbindung zur Datenbank verwendet werden konnte. </p><br><p>  Vielen Dank für Ihre Aufmerksamkeit.  Dabei musste ich mich an die Merkmale der Sprache anpassen.  Es würde mich interessieren, die Meinung von Kollegen zu erfahren, die mehr Zeit mit Go verbracht haben.  Sicherlich könnten einige Momente eleganter gestaltet werden, daher freue ich mich über nützliche Kritik.  Link zum Frame: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/zubroide/go-api-boilerplate</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455302/">https://habr.com/ru/post/de455302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455284/index.html">Alexey Savvateev und die Spieltheorie: "Wie hoch ist die Wahrscheinlichkeit, dass eine Atombombe in den nächsten fünf Jahren abgeworfen wird?"</a></li>
<li><a href="../de455286/index.html">Zähne der Weisheit: können nicht entfernt werden</a></li>
<li><a href="../de455288/index.html">Nachrichten der Woche: Werbeblocker für Unternehmen mit Chrome-, FSB- und Yandex-Verschlüsselungsschlüsseln, Kommunikation wird immer teurer</a></li>
<li><a href="../de455290/index.html">Der vollständige Leitfaden zu Prometheus im Jahr 2019</a></li>
<li><a href="../de455292/index.html">So erhöhen Sie die Laufzeit von Geräten mit eigener Stromversorgung um das Vierfache</a></li>
<li><a href="../de455306/index.html">Antworten auf Ihre Fragen, warum Sie einen Verlag benötigen, um ein Buch zu veröffentlichen</a></li>
<li><a href="../de455308/index.html">Vielversprechender Ort</a></li>
<li><a href="../de455310/index.html">Angriffe auf Bypass-Kanäle: Jetzt werden nicht nur PCs, sondern auch Smartphones angegriffen (analytische Überprüfung)</a></li>
<li><a href="../de455312/index.html">Ein-Bit-Volladdierer auf ungewöhnlichen Chips</a></li>
<li><a href="../de455316/index.html">Wir modifizieren den Bluetooth-Stack, um den Klang von Kopfhörern ohne Codecs AAC, aptX und LDAC zu verbessern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>