<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üçà üå•Ô∏è OpenGL ultramoderno. Parte 2 üíÉüèª ‚ôãÔ∏è üõë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tudo de bom humor e temperatura mais baixa do lado de fora da janela. Como prometido, estou publicando uma continua√ß√£o do artigo sobre o supervisor do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenGL ultramoderno. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457380/"><img src="https://habrastorage.org/webt/ui/wu/2k/uiwu2kjzkvznzwubjaqnk7lkoz0.jpeg"><br><br>  Tudo de bom humor e temperatura mais baixa do lado de fora da janela.  Como prometido, estou publicando uma continua√ß√£o do artigo sobre o supervisor do OpenGL moderno.  Quem n√£o leu a primeira parte - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ultramodern OpenGL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> <br><br>  Talvez voc√™ tenha sorte e eu possa colocar todo o material restante neste artigo, isso n√£o √© certo ... <br><a name="habracut"></a><br><h3>  <font color="#4682B4">Textura de matriz</font> </h3><br>  Matrizes de textura foram adicionadas novamente no OpenGL 3.0, mas por algum motivo poucas pessoas escrevem sobre elas (as informa√ß√µes s√£o ocultadas com seguran√ßa pelos Masons).  Todos voc√™s est√£o familiarizados com programa√ß√£o e sabem o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√© matriz</a> , embora seja melhor "abordar" do outro lado. <br><br>  Para reduzir o n√∫mero de altern√¢ncia entre texturas e, como resultado, reduzir as opera√ß√µes de altern√¢ncia de estado, as pessoas usam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atlas de textura</a> (uma textura que armazena dados para v√°rios objetos).  Mas os caras espertos da Khronos desenvolveram uma alternativa para n√≥s - textura Array.  Agora podemos armazenar texturas como camadas nessa matriz, ou seja, √© uma alternativa aos atlas.  O OpenGL Wiki tem uma descri√ß√£o ligeiramente diferente sobre mipmaps etc., mas parece muito complicado para mim ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> ). <br><br>  As vantagens de usar essa abordagem em compara√ß√£o com os atlas s√£o que cada camada √© considerada uma textura separada em termos de quebra e mipmap. <br><br>  Mas voltando aos nossos carneiros ... A matriz de textura tem tr√™s tipos de alvo: <br><br><ul><li>  GL_TEXTURE_1D_ARRAY </li><li>  GL_TEXTURE_2D_ARRAY </li><li>  GL_TEXTURE_CUBE_MAP_ARRAY </li></ul><br>  C√≥digo para criar uma matriz de textura: <br><br><pre><code class="cpp hljs">GLsizei width = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei height = <span class="hljs-number"><span class="hljs-number">512</span></span>; GLsizei layers = <span class="hljs-number"><span class="hljs-number">3</span></span>; glCreateTextures(GL_TEXTURE_2D_ARRAY, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_array); glTextureStorage3D(texture_array, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGBA8, width, height, layers);</code> </pre> <br>  Os mais atentos perceberam que estamos criando um reposit√≥rio para texturas 2D, mas por alguma raz√£o estamos usando uma matriz 3D, n√£o h√° erro ou erro de digita√ß√£o aqui.  Armazenamos texturas 2D, mas, como est√£o localizadas em "camadas", obtemos uma matriz 3D (na verdade, os dados de pixel s√£o armazenados, n√£o texturas. A matriz 3D possui camadas 2D com dados de pixel). <br><br>  Aqui √© f√°cil entender o exemplo da textura 1D.  Cada linha em uma matriz de pixels 2D √© uma camada 1D separada.  Texturas Mipmap tamb√©m podem ser criadas automaticamente. <br><br>  Com isso, todas as dificuldades terminam e adicionar uma imagem a uma camada espec√≠fica √© bastante simples: <br><br><pre> <code class="cpp hljs">glTextureSubImage3D(texarray, mipmap_level, offset.x, offset.y, layer, width, height, <span class="hljs-number"><span class="hljs-number">1</span></span>, GL_RGBA, GL_UNSIGNED_BYTE, pixels);</code> </pre> <br>  Ao usar matrizes, precisamos alterar um pouco o shader <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core layout (location = 0) out vec4 color; layout (location = 0) in vec2 texture_0; uniform sampler2DArray texture_array; uniform uint diffuse_layer; float getCoord(uint capacity, uint layer) { return max(0, min(float(capacity - 1), floor(float(layer) + 0.5))); } void main() { color = texture(texture_array, vec3(texture_0, getCoord(3, diffuse_layer))); }</span></span></code> </pre> <br>  A melhor op√ß√£o seria calcular a camada desejada fora do shader, para isso, podemos usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UBO</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSBO</a> (tamb√©m √© usado para transferir matrizes e muitos outros dados, mas de alguma forma √© outra hora).  Se algu√©m n√£o puder esperar por <a href="">tyk_1</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tyk_2</a> , voc√™ poder√° ler. <br><br>  Quanto √†s dimens√µes, ou seja, GL_MAX_ARRAY_TEXTURE_LAYERS, que √© 256 no OpenGL 3.3 e 2048 no OpenGL 4.5. <br><br>  Vale a pena falar sobre o Sampler Object (n√£o relacionado √† textura Array, mas uma coisa √∫til) - este √© um objeto usado para ajustar o estado de uma unidade de textura, independentemente de qual objeto esteja atualmente anexado √† unidade.  Ajuda a separar os estados do amostrador de um objeto de textura espec√≠fico, o que melhora a abstra√ß√£o. <br><br><pre> <code class="cpp hljs">GLuint sampler_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; glGenSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_S, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_WRAP_T, GL_REPEAT); glSamplerParameteri(sampler_state, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glSamplerParameteri(sampler_state, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glSamplerParameterf(sampler_state, GL_TEXTURE_MAX_ANISOTROPY_EXT, <span class="hljs-number"><span class="hljs-number">16.0f</span></span>);</code> </pre> <br>  Acabei de criar um objeto de amostrador, habilitei a filtragem linear e a filtragem anisotr√≥pica 16x para qualquer unidade de textura. <br><br><pre> <code class="cpp hljs">GLuint texture_unit = <span class="hljs-number"><span class="hljs-number">0</span></span>; glBindSampler(texture_unit, sampler_state);</code> </pre> <br>  Aqui, apenas ligamos o amostrador √† unidade de textura desejada e quando ele deixa de ser o bindim 0 desejado para esta unidade. <br><br><pre> <code class="cpp hljs">glBindSampler(texture_unit, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Quando vinculamos o amostrador, suas configura√ß√µes t√™m preced√™ncia sobre as configura√ß√µes da unidade de textura.  Resultado: n√£o h√° necessidade de modificar a base de c√≥digo existente para adicionar objetos do amostrador.  Voc√™ pode deixar a cria√ß√£o da textura como est√° (com seus pr√≥prios estados de amostrador) e apenas adicionar c√≥digo para controlar e usar os objetos de amostrador. <br><br>  Quando √© hora de excluir o objeto, simplesmente chamamos esta fun√ß√£o: <br><br><pre> <code class="cpp hljs">glDeleteSamplers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;sampler_state);</code> </pre> <br><h3>  <font color="#4682B4">Vista de textura</font> </h3><br>  Traduzirei isso como "um ponteiro de textura (pode ser mais correto que o link, sou xs)", porque n√£o conhe√ßo a melhor tradu√ß√£o. <br><br>  O que s√£o ponteiros na perspectiva do OpenGL? <br><br>  Tudo √© muito simples, este √© um ponteiro para os dados de uma textura imut√°vel (ou seja, mut√°vel), como podemos ver na figura abaixo. <br><br><img src="https://habrastorage.org/webt/ul/r0/sy/ulr0syubsujlqfshyemnh6sqdoq.jpeg"><br><br>  De fato, este √© um objeto que compartilha os dados texel de um determinado objeto de textura, por analogia, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">std :: shared_ptr do C ++</a> .  Enquanto houver pelo menos um ponteiro de textura, a textura original n√£o ser√° removida pelo driver. <br><br>  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> √© descrito em mais detalhes, bem como vale a pena ler sobre os tipos de textura e alvo (eles n√£o precisam corresponder) <br><br>  Para criar um ponteiro, precisamos obter um descritor de textura chamando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">glGenTexture</a> (nenhuma inicializa√ß√£o √© necess√°ria) e depois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">glTextureView</a> . <br><br><pre> <code class="cpp hljs">glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texture_view); glTextureView(texture_view, GL_TEXTURE_2D, source_name, internal_format, min_level, level_count, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Ponteiros de textura podem apontar para o en√©simo n√≠vel do mipmap, bastante √∫til e conveniente.  Os ponteiros podem ser matrizes de textura, partes de matrizes, uma camada espec√≠fica nessa matriz ou uma fatia de uma textura 3D como uma textura 2D. <br><br><h3>  <font color="#4682B4">Buffer √∫nico para √≠ndice e v√©rtice</font> </h3><br>  Bem, tudo ser√° r√°pido e f√°cil.  Anteriormente, a especifica√ß√£o OpenGL para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vertex Buffer Object</a> recomendava que o desenvolvedor dividisse os dados de v√©rtice e √≠ndice em buffers diferentes, mas agora isso n√£o √© necess√°rio (um longo hist√≥rico porque n√£o). <br>  Tudo o que precisamos √© salvar os √≠ndices na frente dos v√©rtices e dizer onde os v√©rtices come√ßam (mais precisamente, o deslocamento), para isso existe o comando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">glVertexArrayVertexBuffer</a> <br><br>  Aqui est√° como far√≠amos: <br><br><pre> <code class="cpp hljs">GLint alignment = GL_NONE; glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &amp;alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei ind_len = GLsizei(ind_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">element_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLsizei vrt_len = GLsizei(vrt_buffer.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint ind_len_aligned = align(ind_len, alignment); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GLuint vrt_len_aligned = align(vrt_len, alignment); GLuint buffer = GL_NONE; glCreateBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;buffer); glNamedBufferStorage(buffer, ind_len_aligned + vrt_len_aligned, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_DYNAMIC_STORAGE_BIT); glNamedBufferSubData(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, ind_len, ind_buffer.data()); glNamedBufferSubData(buffer, ind_len_aligned, vrt_len, vrt_buffer.data()); GLuint vao = GL_NONE; glCreateVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;vao); glVertexArrayVertexBuffer(vao, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer, ind_len_aligned, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">vertex_t</span></span>)); glVertexArrayElementBuffer(vao, buffer);</code> </pre> <br><br><h3>  <font color="#4682B4">Tecelagem e sombreamento de computa√ß√£o</font> </h3><br>  N√£o vou falar sobre o shader de mosaico, j√° que h√° muito material no Google sobre isso (em russo), eis algumas li√ß√µes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> .  Passamos a considerar o sombreador para os c√°lculos (bliiin, tamb√©m muito material, vou lhe dizer brevemente). <br><br>  A vantagem das placas de v√≠deo em um n√∫mero muito grande de n√∫cleos, as placas de v√≠deo s√£o projetadas para um grande n√∫mero de pequenas tarefas que podem ser executadas em paralelo.  O sombreador de c√°lculo, como o nome indica, permite resolver problemas que n√£o est√£o relacionados aos gr√°ficos (n√£o √© necess√°rio). <br><br>  Uma imagem, n√£o sei como cham√°-la (como os fluxos s√£o agrupados). <br><br><img src="https://habrastorage.org/webt/tw/3a/x_/tw3ax_rzsrwx5look90ggm5xehw.jpeg"><br><br>  Para que podemos usar? <br><br><ul><li>  Processamento de imagem <ol><li>  Bloom </li><li>  Algoritmos baseados em blocos (sombreamento atrasado) </li></ol></li><li>  Simula√ß√µes <br><ol><li>  Part√≠culas </li><li>  Agua </li></ol></li></ul><br>  Al√©m disso, n√£o vejo raz√£o para escrever, tamb√©m h√° muitas informa√ß√µes no Google, aqui est√° um exemplo simples de uso: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     glUseProgramStages( pipeline, GL_COMPUTE_SHADER_BIT, cs); // ,    / glBindImageTexture( 0, tex, 0, GL_FALSE, 0, GL_WRITE_ONLY, GL_RGBA8); // 80x45   (  1280720) glDispatchCompute( 80, 45, 1);</span></span></code> </pre> <br><br>  Aqui est√° um exemplo de um sombreador de computa√ß√£o vazio: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 430 layout(local_size_x = 1, local_size_y = 1) in; layout(rgba32f, binding = 0) uniform image2D img_output; void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// base pixel color for image vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0); // get index in global work group ie x,y position ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy); // // interesting stuff happens here later // // output to a specific pixel in the image imageStore(img_output, pixel_coords, pixel); }</span></span></span></span></code> </pre> <br><br>  Aqui est√£o alguns links para uma an√°lise mais profunda de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4</a> . <br><br><h3>  <font color="#4682B4">Renderiza√ß√£o de caminho</font> </h3><br>  Esta √© uma nova extens√£o (n√£o nova) da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NVidia</a> , cujo objetivo principal √© a renderiza√ß√£o em vetor 2D.  Podemos us√°-lo para textos ou interface do usu√°rio e, como os gr√°ficos s√£o vetoriais, n√£o depende da resolu√ß√£o, o que √© sem d√∫vida uma grande vantagem e nossa interface do usu√°rio ficar√° √≥tima. <br><br>  O conceito b√°sico √© um est√™ncil, depois uma capa (capa no original).  Defina o est√™ncil do caminho e visualize os pixels. <br><br>  Para gerenciamento, GLuint padr√£o √© usado e as fun√ß√µes de cria√ß√£o e exclus√£o t√™m uma conven√ß√£o de nomenclatura padr√£o. <br><br><pre> <code class="cpp hljs">glGenPathsNV <span class="hljs-comment"><span class="hljs-comment">//  glDeletePathsNV // </span></span></code> </pre> <br><br>  Aqui est√° um pouco sobre como podemos obter o caminho: <br><ul><li>  SVG ou PostScript em string'e <pre> <code class="cpp hljs">glPathStringNV</code> </pre> </li><li>  matriz de comandos com coordenadas correspondentes <pre> <code class="cpp hljs">glPathCommandsNV</code> </pre>  e para atualizar dados <pre> <code class="cpp hljs">glPathSubCommands, glPathCoords, glPathSubCoords</code> </pre> </li><li>  fontes <pre> <code class="cpp hljs">glPathGlyphsNV, glPathGlyphRangeNV</code> </pre> </li><li>  combina√ß√µes lineares de caminhos existentes (interpola√ß√£o de um, dois ou mais caminhos) <pre> <code class="cpp hljs">glCopyPathNV, glInterpolatePathsNV, glCombinePathsNV</code> </pre> </li><li>  transforma√ß√£o linear de um caminho existente <pre> <code class="cpp hljs">glTransformPathNV</code> </pre> </li></ul><br>  Lista de comandos padr√£o: <br><br><ul><li>  mover para (x, y) </li><li>  caminho pr√≥ximo </li><li>  linha para (x, y) </li><li>  curva quadr√°tica (x1, y1, x2, y2) </li><li>  curva c√∫bica (x1, y1, x2, y2, x3, y3) </li><li>  curva quadr√°tica suave (x, y) </li><li>  curva c√∫bica suave (x1, y1, x2, y2) </li><li>  arco el√≠ptico (rx, ry, rota√ß√£o do eixo x, bandeira de arco grande, bandeira de varredura, x, y) </li></ul><br>  Aqui est√° a apar√™ncia da string de caminho no PostScript: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"100 180 moveto 40 10 lineto 190 120 lineto 10 120 lineto 160 10 lineto closepath‚Äù // "</span></span><span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> moveto <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> curveto <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span> curveto closepath‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  E aqui no SVG: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"M100,180 L40,10 L190,120 L10,120 L160,10 z‚Äù // "</span></span>M300 <span class="hljs-number"><span class="hljs-number">300</span></span> C <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span> <span class="hljs-number"><span class="hljs-number">300</span></span>Z‚Äù <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Ainda existem todos os tipos de bolos com tipos de recheios, bordas e dobras: <br><br><img src="https://habrastorage.org/webt/wx/uy/wv/wxuywvdg2rfuxlrrasn_hh9yzkm.jpeg"><br><br>  N√£o vou descrever tudo aqui, pois h√° muito material e ser√° necess√°rio um artigo inteiro (se for interessante, escreverei de alguma forma). <br><br>  Aqui est√° uma lista de primitivas de renderiza√ß√£o <br><br><ul><li>  Curvas c√∫bicas </li><li>  Curvas quadr√°ticas </li><li>  Linhas </li><li>  Glifos de fonte </li><li>  Arcos </li><li>  Estilo Dash &amp; Endcap </li></ul><br>  Aqui est√° algum c√≥digo e, em seguida, h√° muito texto: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SVG  glPathStringNV( pathObj, GL_PATH_FORMAT_SVG_NV, strlen(svgPathString), svgPathString); //  glStencilFillPathNV( pathObj, GL_COUNT_UP_NV, 0x1F); // //  ( ) glCoverFillPathNV( pathObj, GL_BOUNDING_BOX_NV);</span></span></code> </pre> <br>  Isso √© tudo. <br><br>  Parece-me que este artigo saiu menos interessante e informativo, era dif√≠cil destacar a principal coisa no material.  Se algu√©m estiver interessado em aprender mais detalhadamente, posso descartar alguns materiais e links da NVidia para as especifica√ß√µes (se me lembro onde os salvei).  Tamb√©m estou feliz por qualquer ajuda na edi√ß√£o do artigo. <br><br>  Conforme prometido, escreverei o seguinte artigo sobre como otimizar e reduzir as chamadas de empate.  Gostaria de pedir que voc√™ escreva nos coment√°rios sobre o que mais voc√™ gostaria de ler e o que voc√™ est√° interessado: <br><ul><li>  Escrevendo um jogo no cocos2d-x (somente pr√°tica, sem √°gua) </li><li>  Tradu√ß√£o de uma s√©rie de artigos sobre Vulkan </li><li>  Alguns t√≥picos em OpenGL (quaternions, nova funcionalidade) </li><li>  Algoritmos de computa√ß√£o gr√°fica (ilumina√ß√£o, oclus√£o ambiental da tela espacial, reflex√£o da tela espacial) </li><li>  Suas op√ß√µes </li></ul><br><br>  Obrigado a todos pela aten√ß√£o. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457380/">https://habr.com/ru/post/pt457380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt457354/index.html">Ofusca√ß√£o de dados para testes de desempenho</a></li>
<li><a href="../pt457362/index.html">Promo√ß√£o da RUVDS: prepare o servidor no ver√£o</a></li>
<li><a href="../pt457366/index.html">Um fan√°tico, um peda√ßo de ferro ou um espectador - que tipo de jogador voc√™ √©?</a></li>
<li><a href="../pt457374/index.html">Reduza o tempo de compila√ß√£o de seus projetos Android</a></li>
<li><a href="../pt457378/index.html">Como a id Software criou o Wolfenstein 3D com base na tecnologia do Commander Keen</a></li>
<li><a href="../pt457382/index.html">7 h√°bitos de programadores de alto desempenho</a></li>
<li><a href="../pt457386/index.html">Apresentando as interfaces virtuais do Linux: t√∫neis</a></li>
<li><a href="../pt457390/index.html">Madagascar - ilha dos contrastes</a></li>
<li><a href="../pt457392/index.html">Economias no desenvolvimento de plataformas cruzadas m√≥veis: estudo de caso da Skyeng</a></li>
<li><a href="../pt457396/index.html">Desbloquear automaticamente o cont√™iner LUKS raiz ap√≥s uma inicializa√ß√£o a quente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>