<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆖 ✊🏽 📛 Untuk pertanyaan tentang AVR dan rekor dunia 🔱 🙂 ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lakukan dengan baik, itu akan menjadi buruk 
 Alasan untuk posting ini adalah yang terbaru (ketika saya mulai menulis posting ini, itu benar-benar bar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Untuk pertanyaan tentang AVR dan rekor dunia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412959/"><h3>  Lakukan dengan baik, itu akan menjadi buruk </h3><br>  Alasan untuk posting ini adalah yang terbaru (ketika saya mulai menulis posting ini, itu benar-benar baru, tetapi sesuatu terjadi untuk waktu yang lama di folder Unfinished) di Habré mengenai aspek penerapan perangkat lunak UART pada AVR's MK.  Pertanyaan yang diajukan sendiri bukan tanpa minat, tetapi jawaban aneh seperti itu diberikan bahwa mereka menganggap itu tugasnya untuk membuat penjelasan yang diperlukan.  Topiknya ditandai, mereka yang ingin membaca tentang "raja, kubis dan sepatu", yaitu persyaratan standar, membaca dokumentasi teknis dan catatan (benar) dalam pemrograman bahasa assembly untuk AVR, dapat mengklik tombol di bawah ini. <br><a name="habracut"></a><br>  Mari kita uraikan pertanyaan secara lebih rinci - apakah mungkin untuk mengimplementasikan IRPS (nama biasa untuk antarmuka, atas nama UART), pada AVR tipe MK (khususnya, itu adalah Tiny13) ketika bekerja dari generator internal.  Faktanya adalah bahwa generator ini tidak memiliki indikator akurasi retensi frekuensi yang sangat baik, itulah mengapa pertanyaan ini muncul.  Saya harus segera melakukan reservasi bahwa tidak masalah apakah kami mempertimbangkan implementasi perangkat lunak (seperti yang disarankan dalam posting asli) atau menggunakan blok perangkat keras MK.  Hasil dari satu metode (dalam hal parameter akurasi dalam waktu) hampir sepenuhnya diterjemahkan ke yang lain. <br><br>  Pertanyaan mendasar adalah apakah generator internal dapat memberikan akurasi operasi yang diperlukan, karena dalam hal jawaban negatif untuk pertanyaan ini, studi lebih lanjut menjadi tidak berarti.  Untuk membandingkan dua kuantitas independen, kita perlu mengetahui keduanya, jadi kita akan mulai dengan menentukan akurasi yang diperlukan dari pengurungan frekuensi dan kemampuan yang disediakan oleh MK khusus ini di bagian ini.  Sebuah komentar penting untuk kalimat sebelumnya - ini tidak berarti contoh khusus, "diberikan kepada kita dalam sensasi", tetapi jenis MK tertentu, yang disajikan oleh deskripsi teknisnya. <br><br>  Untuk memulainya, kita akan menemukan sesuatu yang lebih mudah ditemukan (well, saya pikir begitu) - persyaratan untuk akurasi parameter waktu antarmuka.  Kami akan membuka standar untuk RS232 dan segera melihat semua yang Anda butuhkan.  Ternyata "Anda tidak bisa mengambilnya dan ..." karena standar dibayar dan semua salinan di Web ilegal.  Oke, kami mengambil versi domestik GOST ke C2 bersama dan kami tidak menemukan parameter waktu di sana sama sekali, dengan pengecualian durasi depan dan pemotongan pulsa.  Pada awalnya, ini menyebabkan sedikit kebingungan - seperti yang bisa terjadi - tetapi kemudian menjadi mengerti bahwa sambungan C2 hanya menggambarkan bagian antarmuka dari IRPS dan persyaratan harus di yang terakhir.  Pada prinsipnya, semuanya logis, tidak jelas hanya mengapa ini tidak dijelaskan secara eksplisit dalam GOST, tetapi, pada akhirnya, Anda kadang-kadang dapat berpikir sendiri, meskipun masih “entah bagaimana tidak diperoleh dengan rapi”. <br><br>  Tentu saja, dengan mengetahui protokol transmisi, dimungkinkan, dari pertimbangan umum, untuk menemukan ketidaksesuaian maksimum yang diijinkan antara kecepatan pemancar dan penerima (0,5 / 9,5 = 5,2%), tetapi ini akan menjadi penyelidikan kuda bulat yang Anda tahu di mana, karena: <br><br><ol><li>  persyaratan standar dapat dan harus lebih keras daripada perhitungan teoritis serupa dari ketidaksesuaian maksimum yang diizinkan; </li><li>  mengetahui angka ketidakcocokan terakhir tidak akan memberi kami anggaran pemancar dan penerima. </li></ol><br>  Berkeliaran di Internet menyebabkan Atmel's AppNote (well, karena kami masih menggunakan MK perusahaan ini), yang secara eksplisit berbicara tentang ketidakcocokan yang diizinkan sebesar 2% dengan anggaran yang sama, yang mengarah pada persyaratan akurasi menjaga frekuensi pemancar 1%.  Kami akan mempercayai perusahaan yang memiliki reputasi baik dan mengira bahwa mereka memiliki akses ke bahan-bahan rahasia dan angka ini benar, terutama karena terlihat masuk akal.  Saya memahami kerentanan posisi seperti itu, tetapi jujur ​​saja, saya lelah mencari jawaban yang tepat untuk pertanyaan sederhana seperti itu, dan tidak sabar untuk melanjutkan ke bagian selanjutnya. <br><br>  Bagian selanjutnya dari jawaban terletak di dalam MK dan ditentukan oleh dokumentasi teknis untuk itu.  Pertama, sedikit tentang perangkat generator internal, terutama karena lebih atau kurang dijelaskan.  Generator menggunakan rantai RC sebagai elemen pengaturan waktu dan, karena tugas membentuk kapasitor terintegrasi dari kapasitor yang tepat, dan resistor yang tepat, sangat tidak trivial, frekuensi akhir dari instance ke instance dari MC akan bervariasi secara signifikan.  Untuk membuat parameter ini lebih mudah diprediksi, pabrikan menambahkan node perangkat keras yang dikendalikan melalui byte kalibrasi.  Unit ini memungkinkan Anda untuk mengubah frekuensi generator pada rentang yang luas dan, karenanya, untuk mendapatkan nilai yang diinginkan dengan akurasi yang jauh lebih tinggi. <br><br>  Akan menarik untuk mencari tahu bagaimana kontrol diterapkan pada perangkat keras, saya melihat opsi baik dengan mengendalikan tegangan muatan kapasitor melalui DAC atau mengendalikan tegangan perbandingan pada komparator.  Kedua opsi ini, bagaimanapun, mengarah ke non-linearitas signifikan dari karakteristik kontrol, meskipun mereka mudah diimplementasikan.  Tetapi menetapkan implementasi internal generator bukan bagian dari tugas kami, kami tertarik pada parameter eksternal. <br><br>  Jadi kami membuka dokumentasi (Anda dapat membuka file di viewer, tetapi saya memiliki versi deskripsi tipografi yang dicetak oleh pabrikan itu sendiri - ya, dulu) dan mencari bagian yang sesuai.  Parameter yang kami minati adalah di bagian “Kalibrasi RC Internal Oscillator”, kemudian ikuti tautan jika perlu.  Dan di sini kita (pasti, saya tidak yakin tentang Anda) menunggu kekecewaan pertama - saya telah bekerja dengan produk Atmel untuk waktu yang lama (sekitar 15 tahun), dan selalu percaya bahwa mereka memiliki dokumentasi yang baik untuk MK.  Menurut psikiater, “tidak ada orang sehat, tidak ada orang yang belum dijelajahi” dan penelitian yang cermat atas bagian yang relevan mengkonfirmasi kebenaran ini, karena saya tidak bisa melihat kegagalan seperti itu dalam dokumentasi sebelumnya.  Dalam pembelaan saya, saya hanya bisa mengatakan bahwa: <br><br><ol><li>  Saya tidak pernah menggunakan generator internal dalam data MK, jadi saya tidak mempelajarinya dengan hati-hati; </li><li>  ketika saya mulai bekerja dengan MK ini (lebih dari 10 tahun yang lalu) saya masih muda (yah, jelas lebih muda dari sekarang) dan bodoh dan tidak sepenuhnya memahami perlunya dokumentasi yang baik (dapat dimengerti, komprehensif dan tidak ambigu); </li><li>  Saya siap untuk banyak memaafkan diri saya sendiri, hanya karena saya sering memaafkan diri sendiri, dan semua kekurangan saya tidak fatal (argumen terakhir sangat meyakinkan, bukan). </li></ol><br>  Jadi, setelah selesai membersihkan kepala saya dengan abu, saya akan mulai menyatakan klaim saya pada dokumentasi dan tidak ada alasan bagi produsen.  Kami membuka bagian di atas dan mulai mempelajarinya dengan cermat, pergi ke halaman yang diperlukan jika perlu (Anda masih mengklik tautan).  Bersama-sama kita akan mencari parameter berikut yang mengkarakterisasi karakteristik waktu generator: akurasi nominal, pengaruh tegangan suplai, pengaruh suhu dan parameter penuaan - ini adalah set minimum yang diperlukan untuk mengevaluasi parameter akurasi setiap generator. <br><br>  Bagian pertama balet Marleson adalah akurasi nominal. <br><br>  Segera kami menemukan parameter yang diinginkan - tabel akurasi penyetelan generator, di mana kami melihat dua baris "Factory Calibrated" dengan nilai yang ditentukan ± 10% dan "Manual Calibrating" dengan parameter yang sama ± 2%. <br><br>  Mengenai data ini, sejumlah pertanyaan segera muncul - apa artinya dan bagaimana pengukuran parameter ini.  Untuk baris pertama, tabel menunjukkan suhu (lingkungan atau MK itu sendiri - tidak jelas, tetapi ini adalah kemauan pada bagian saya) dan tegangan suplai, di samping itu, catatan itu mengatakan (menurut saya, tidak perlu) bahwa pengukuran ini dilakukan pada titik tertentu di ruang kondisi eksternal.  Orang bisa menebak bahwa dalam hal ini kita harus menggunakan faktor kalibrasi yang direkam di pabrik, meskipun akan lebih baik untuk secara eksplisit menunjukkan ini dalam catatan.  Semuanya kurang lebih jelas dan ditafsirkan hampir secara tidak ambigu (walaupun dalam konteks studi dokumentasi teknis harus dikatakan bahwa semuanya kabur dan memungkinkan untuk variasi interpretasi, dan ini tidak dapat diterima, tetapi jika kita melakukannya, topik diskusi lebih lanjut hanya menghilang (dan apa yang akan terjadi selanjutnya) menulis, tidak jelas, karena itu, menunjukkan kesenangan). <br><br>  Tetapi dengan lini kedua kasing, ini lebih buruk - batas perubahan suhu dan tegangan suplai diberikan dan dikatakan bahwa dengan menggunakan semacam prosedur kalibrasi ajaib, Anda dapat mencapai secara signifikan lebih baik daripada hasil pabrik di seluruh jajaran.  Pertanyaan saya segera muncul - jika ini dapat dicapai di mana-mana (pada titik suhu dan catu daya) dan pabrikan tahu bagaimana melakukan ini, lalu mengapa dia tidak melakukannya sendiri di kalibrasi pabrik pada titik tertentu dalam kondisi?  Kami beralih ke deskripsi byte kalibrasi dan melihat bahwa dibutuhkan 128 nilai dan ini mencakup kisaran dari 50% hingga 200% dari nominal, yang sesuai dengan 150/128 ~ 1,17% dari perubahan frekuensi per nilai kalibrasi unit, yang seharusnya memberikan akurasi yang diharapkan lebih baik daripada di 1%  Tapi kemudian kita harus mempertimbangkan bahwa karakteristik penyesuaian jelas tidak linier dan di wilayah nilai kalibrasi besar kita memiliki 60% / 32 ~ 2% dari langkah (data diambil dari grafik, saya telah berulang kali menyatakan sikap saya pada metode yang sama untuk mewakili parameter teknis, tapi saya ulangi - ini tidak dapat diterima metode ini, walaupun, tentu saja, lebih baik daripada tidak sama sekali), yang memberikan akurasi 1% dan jika kita mempertimbangkan monotonitas karakteristik penyesuaian (ya, itulah yang dikatakan dokumentasi, itu tidak digambarkan dalam grafik, tetapi jelas ditunjukkan dalam teks. Saya menolak untuk memahami untuk  untuk, dan yang paling penting mengapa, perusahaan ingin membuat hukum penyesuaian, tetapi berhasil), yang jelas dinyatakan dalam pedoman, perlu untuk mempertimbangkan akurasi 2% cukup dicapai.  Saya tidak begitu suka saya harus melihat grafik, tetapi ini tidak perlu dan data tabel cukup.  Pada bagian ini, dokumentasi harus dianggap sepenuhnya dapat dipahami dan konsisten, kriteria kebenaran berada di luar lingkup kompetensi kita. <br><br>  Bagian kedua dari balet Marlezon.  - pengaruh kondisi eksternal. <br><br>  Dan kemudian mulai "sampah, asap, dan sodomi."  Alih-alih tabel nilai, kita diundang untuk melihat gambar (untuk beberapa alasan mereka disebut grafik nilai-nilai khas dalam dokumentasi), dan, seperti yang Anda tahu, "keuntungan utama dari representasi grafis informasi adalah visibilitasnya, dan tidak memiliki keunggulan lain."  Adalah mungkin untuk menggunakan bahkan informasi semacam itu dan menghapus nilai batas dari grafik (“walaupun ini menyinggung tim”) jika grafik ini tidak diberikan di bagian “Karakteristik Khas”.  Saya tidak tahu bagaimana seseorang, secara pribadi, saya sangat yakin bahwa untuk menunjukkan makna khas (atau tipikal, saya tidak tahu bagaimana menjadi lebih benar, dalam satu film mereka mengatakan "penampilan khas"), setidaknya dalam bentuk grafik, bahkan dalam tabel, itu tidak menunjukkan apa-apa.  Mereka tidak dapat dipandu dalam desain, karena parameter ini tidak jelas apa artinya dan penyimpangan dari nilai-nilai tipikal dapat diterima, berbeda dengan nilai minimum dan maksimum, transisi yang menunjukkan kerusakan perangkat. <br><br>  Yah, kami sudah lulus, kami akan mencoba mengekstraksi setidaknya beberapa informasi dan melihat bahwa ketika suhu berubah dari -40 menjadi + 80 ° , frekuensi generator berubah ± 4%.  Gambar yang serupa dengan tegangan suplai - hanya grafik khas dan kesalahan yang dihasilkan di -6 + 2% dari 3,3 ke 5,5.  Data tentang penuaan generator tidak diberikan, yang, secara umum, logis, karena dengan latar belakang parameter yang telah diberikan, akurasi satu persen selama 5 tahun (nilai karakteristik untuk silikon) tidak mengganggu siapa pun. <br><br>  Sekarang kami memiliki semua data untuk menjawab pertanyaan awal kami - selama kalibrasi pabrik, generator tidak memenuhi persyaratan antarmuka untuk akurasi, ketika dikalibrasi untuk kondisi aplikasi tertentu - memenuhi persyaratan batas, tetapi tidak memenuhi standar.  Juga harus diperhitungkan bahwa jika kalibrasi untuk tegangan suplai dan MK tertentu dapat dilakukan dalam pembuatan perangkat dan berharap bahwa mereka tidak berubah dalam waktu, maka suhu hanya dapat diperhitungkan dengan cepat dan memerlukan standar waktu eksternal dengan akurasi yang sesuai.  Karena pengembangan perangkat harus dipandu oleh aturan "kami percaya pada Tuhan, segala sesuatu yang lain membutuhkan bukti", dan kami belum membuktikan kemungkinan memenuhi persyaratan, jawaban yang benar adalah bahwa tidak mungkin untuk menjamin implementasi IRPS yang memenuhi persyaratan standar dalam MC ini dengan generator internal.  Perhatikan bahwa kami membuat kesimpulan di atas ketika menganalisis dokumentasi dan merumuskannya sedemikian rupa untuk menekankan bahwa pada contoh spesifik MK semuanya dapat dan akan berubah jika bintang-bintang naik dengan sukses.  Artinya, kesimpulan kami bertentangan dengan pos yang disebutkan sebelumnya, bagaimana ini bisa terjadi, karena semuanya bekerja baik untuk seseorang - mari kita cari tahu. <br><br>  Sekarang kritik terhadap posting di atas akan dimulai.  Pertama, mari kita pikirkan bagaimana kita dapat memastikan bahwa perangkat diperiksa untuk memenuhi persyaratan antarmuka tertentu.  Saya dapat menyarankan beberapa cara berikut: <br><br><ol><li>  Cara yang baik adalah mengukur parameter penting dari antarmuka perangkat dan membandingkannya dengan persyaratan standar - ini dapat dilakukan dengan menggunakan instrumen universal (dalam kasus kami, osiloskop dan panjang interval bit atau transmisi lengkap), atau menggunakan perangkat khusus yang disertifikasi untuk menguji antarmuka ini. </li><li>  Cara begitu-begitu - untuk mengatur interaksi dengan perangkat lain yang mengimplementasikan bagian respons antarmuka dan terbukti (memenuhi persyaratan standar).  Tentu saja, pemeriksaan semacam itu sama sekali tidak cukup, dan lebih tepatnya, dapat diterapkan lebih banyak untuk mengkonfirmasi kerusakan perangkat yang sedang diuji, tetapi setidaknya melakukan sesuatu. </li><li>  Cara yang buruk adalah mengimplementasikan bagian respons antarmuka secara independen (di perangkat yang sama atau di perangkat lain) dan berinteraksi dengannya.  Karena kedua perangkat jelas tidak terbukti, kegunaan pemeriksaan seperti itu sangat, sangat diragukan.  Contoh yang baik dari pendekatan ini adalah "echo" pada saluran serial, yang tidak membuktikan apa-apa dan melaporkan sedikit lebih banyak daripada tidak sama sekali tentang kecepatan perangkat, pada prinsipnya, tidak rusak dan mampu mentransmisikan sesuatu. </li><li>  Cara yang mengerikan adalah mengambil sebagai penguji alat yang tidak memenuhi persyaratan standar sama sekali (atau lebih tepatnya, bertentangan dengan mereka) dan bekerja, seperti pada paragraf sebelumnya. </li></ol><br>  Ini adalah metode yang terakhir yang digunakan dalam pos yang dipertimbangkan - penerima perangkat lunak saluran serial diimplementasikan, yang, bertentangan dengan persyaratan standar, mengubah frekuensinya untuk beradaptasi dengan sinyal input (khususnya, panjang bit mulai), yang memungkinkan penerimaan sinyal kualitas buruk yang stabil dalam hal parameter waktu.  Ini bukan untuk mengatakan bahwa ini tidak boleh dilakukan, apalagi, dalam modem analog, penyetelan untuk kecepatan masuk diadopsi, yang diimplementasikan dengan cara yang sama, tetapi justru mengubah frekuensi dengan mengubah pembagi, dan ini jelas bukan kasus kami.  Dan dalam versi inilah segala sesuatu diperoleh dengan sempurna dan informasi ditransmisikan secara stabil dalam kondisi eksternal apa pun.  Oleh karena itu, jika kita berbicara tentang kemungkinan pengiriman informasi antara dua MC yang beroperasi dari generator internal menggunakan antarmuka yang mengingatkan IRPS dari jarak jauh, maka jawabannya adalah ya.  Jika kita berbicara tentang berinteraksi dengan perangkat eksternal yang memenuhi persyaratan standar dan tidak lebih, maka kita akan mengharapkan banyak kejutan yang tidak menyenangkan. <br><br>  Kesimpulan umum dari hal di atas: <br><br><ol><li>  saat mendesain perangkat, Anda harus fokus pada dokumentasi (RTFM), </li><li>  Anda perlu mempelajari dokumentasi dan menafsirkan dengan benar apa yang Anda baca (RTFMF), </li><li>  perlu diingat bahwa dalam dokumentasi waktu kita dapat salah paham, ketidakakuratan (dan bahkan kesalahan), oleh karena itu </li><li>  periksa informasi yang diterima untuk konsistensi dan kredibilitas, dan </li><li>  gunakan informasi yang diperoleh secara eksperimental hanya untuk mengkonfirmasi kesimpulan yang diperoleh dari analisis dokumentasi, sementara </li><li>  hati-hati memilih metode eksperimen untuk menguji peralatan untuk mendapatkan hasil yang andal. </li></ol><br>  Kesimpulannya, seperti yang dijanjikan, seorang assembler kecil.  Saya membiarkan diri saya menulis ulang cuplikan kode yang dikutip oleh penulis dalam bentuk normal, karena assembler yang dibangun di GCC tidak lain adalah sebuah olok-olok pada programmer, saya dapat menyebutkan namanya.  Tidak, tentu saja, saya mengerti bahwa pengembang kompiler dipandu oleh alasan yang baik, tetapi hasilnya sangat mirip dengan frase "well, it works." <br><br><pre><code class="hljs vhdl">.equ delay=<span class="hljs-number"><span class="hljs-number">15</span></span> TX_Byte: cli ; ld r18,Z+ ; cp r18,r1 ; breq Exit_Transmit ; dec r1 cbi <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>, TX_line Delay_TX: ldi r16,delay Do_Delay_TX: nop dec r16 brne Do_Delay_TX TX_Bit: sbrc r18,<span class="hljs-number"><span class="hljs-number">0</span></span> sbi <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>,TX_line sbrs r18,<span class="hljs-number"><span class="hljs-number">0</span></span> cbi <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>,TX_line lsr r18 lsr r17 brcs Delay_TX sbi <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>, TX_line ldi r16,delay Stop_Bit_TX: nop dec r16 brne Stop_Bit_TX Sei</code> </pre> <br>  Dan segera kesalahan dalam program menarik perhatian Anda - di baris 3 (berkomentar) nilai register 1 harus nol, tetapi tugas tidak secara eksplisit ditulis dalam fungsi.  Setelah siklus transfer byte tunggal selesai, nilai ini dijamin oleh baris 12, tetapi tidak pada pass pertama.  Oleh karena itu, inisialisasi harus ditambahkan, yang akan membutuhkan peningkatan ukuran kode. <br><br>  Kelemahan kedua adalah pembentukan aktual level dalam baris 4-7, karena metode yang diadopsi oleh penulis untuk mengeluarkan bit berikutnya akan mengarah ke jittering depan selama 2 siklus clock pada berbagai transisi (0-1 dan 1-0), yang akan memerlukan peningkatan persyaratan untuk keakuratan retensi frekuensi.  Bukannya ini akan memberikan pengaruh yang sangat kuat, tetapi jika Anda dapat memperbaiki kesalahan tanpa memperpanjang program, maka mengapa tidak - lihat epigrafnya.  Versi aslinya mengambil 4 kata dan dilakukan dalam 4 langkah, yang baru mengambil 4 kata dan dilakukan dalam 4 langkah yang sama.  Ya, versi yang diperbaiki membutuhkan studi yang lebih mendalam tentang arsitektur MK, tetapi siapa bilang itu akan mudah.  Di sisi lain, pada versi pertama, modifikasi port bersifat atomik, dan pada versi kedua tidak, dalam hal ini tidak masalah (kami secara eksplisit melarang interupsi), tetapi endapan tetap ada.  Jika MK yang bersangkutan memiliki prosesor bit nyata, seperti dalam arsitektur 51, maka kita dapat menulis sebuah fragmen ideal yang menggabungkan semua keunggulan dari kedua pendekatan (dan bahkan menjadi sedikit lebih pendek), tetapi apa yang dapat kita impikan dari mimpi pipa ... <br><br>  Kelemahan ketiga adalah masalah gaya lebih.  Saya telah berulang kali menyatakan sikap saya terhadap konstanta sihir yang kita lihat dalam pembukaan program ini.  Saya menekankan sekali lagi - dari kenyataan bahwa penulis menetapkan konstanta dalam pembukaan program, dan tidak langsung di operator, "sihir jalanan biasa" tidak pergi ke mana pun.  Faktanya adalah bahwa kita harus secara eksplisit menyajikan kepada pembaca metode pembentukan nilai tertentu, dan tidak membuat sinonim untuk nilai yang diperoleh dengan cara yang tidak diketahui.  Anda dapat, tentu saja, menulis komentar pada baris dengan nilai untuk menentukan rumus perhitungan, tetapi lebih baik untuk secara eksplisit menggunakan rumus perhitungan untuk membentuk konstanta dan kemudian Anda tidak perlu komentar (tentu saja, dengan nama-nama yang berbicara dari konstanta yang diterapkan).  Ini dilakukan dalam teks di bawah ini, dan perhatikan bahwa kami mengonversi ke integer hanya pada saat terakhir dan dibulatkan dengan benar, yang memungkinkan kami untuk tidak kehilangan keakuratan hasil. <br><br>  Ada kesalahan lain - panjang bit mulai agak berbeda dari interval bit untuk data.  Meskipun penyimpangan tidak terlalu signifikan (3 siklus clock), namun, pada laju bit tinggi, di mana interval bit berlangsung sekitar 90 siklus clock, ini sudah merupakan kesalahan beberapa persen, yang tidak dapat diterima.  Kesalahan ini dapat dengan mudah diperbaiki dengan menambahkan perintah untuk menghasilkan penundaan tambahan, tetapi ini akan menambah panjang program, sehingga kami hanya memperbaiki keberadaannya dan kemudian memastikan bahwa arsitektur program yang benar (yaitu, bahkan jangka pendek ini berlaku) dihilangkan secara otomatis. <br><br>  Nah, sekarang setelah kami memperbaiki kesalahan (kecuali yang terakhir), kami akan mencoba untuk memperbaiki program dalam arti kriteria utama (untuk mencapai catatan, dalam kasus khusus ini) - panjang kode.  Hal pertama yang menarik perhatian Anda adalah adanya dua penundaan waktu, yang buruk karena melanggar prinsip KERING (persyaratan umum) dan meningkatkan ukuran kode (persyaratan khusus).  Dimungkinkan untuk mengatur fragmen ini dalam bentuk subprogram dan kami masih akan menang panjangnya, karena kami menambahkan 3 kata kode (1 untuk setiap panggilan di dua tempat dan 1 untuk kembali), dan kami menyimpan 4, tetapi ada cara yang jauh lebih indah - rapi organisasi siklus transmisi byte, yang dapat dilihat pada teks berikut. <br><br><pre> <code class="hljs vhdl">.equ delay=<span class="hljs-number"><span class="hljs-number">15</span></span> TX_Byte: cli sec ;   - clt ;  - TransBit: ;    <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r17,<span class="hljs-keyword"><span class="hljs-keyword">port</span></span> bld r17,Tx_line <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">port</span></span>,r17 Delay_TX: ;     ldi r17,delay Do_Delay_TX: nop dec r17 brne Do_Delay_TX TX_Bit: bst r16,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ror</span></span> r16 clc brne TransBit ;    brcs TransBit ;  - Exit_Transmit: Sei</code> </pre><br>  Perhatikan bagaimana kita menggunakan byte yang ditransmisikan bersama-sama dengan carry bit sebagai bit counter, solusi yang indah, tetapi memiliki satu kelemahan - durasi bit data terakhir akan beberapa (2 siklus) lebih lama dari yang lain, karena keterlambatan transisi.  Jika kita berbicara tentang stop bit, maka “jangan peduli dan lupakan”, karena kita belum diberi interval minimum antar transfer, tetapi ini sedikit signifikan, dan kami baru saja mengkritik program asli untuk perilaku seperti itu.  Kita tidak akan disamakan dengan karakter alkitabiah dari perumpamaan mote di mata orang lain dan mengambil langkah-langkah untuk menghilangkannya.  Fenomena ini dapat dengan mudah dikompensasi dengan memperkenalkan penundaan 2 ukuran, tetapi panjang kode akan meningkat, dan ini adalah parameter utama.  Oleh karena itu, mari kita pergi dengan cara klasik dan mengubah waktu untuk memori - kami menggunakan register terpisah untuk mengatur penghitung bit yang ditransmisikan, dan kami mendapatkan interval bit yang persis sama dengan ukuran kode yang sama. <br><br>  Peningkatan selanjutnya terkait dengan pembentukan durasi interval bit, yang dalam program aslinya dilakukan pada siklus 4-siklus.  Jika kita membuatnya 3-jam (kemungkinan terkecil dalam MK ini), kita dapat menyimpan satu byte kode dan berpotensi dapat meningkatkan parameter akurasi, karena diskresi keterlambatan akan menjadi kurang (deviasi tidak melebihi setengah ukuran diskrit dengan pembulatan yang tepat).  Tetapi harus diingat bahwa dalam kasus tertentu kita mungkin kehilangan keakuratan, semuanya tergantung pada sumber data.  Keadaan lain yang dapat memengaruhi pilihan hanya durasi siklus tersebut - ukuran keterlambatan maksimum untuk penghitung byte adalah 256 nilai - untuk opsi yang tersedia, Anda dapat menggunakan kecepatan dari 9600 baud dan lebih tinggi, tetapi dengan penundaan 3 siklus ini tidak mungkin.  Akan sangat bagus untuk mencerminkan keadaan ini (kecepatan port minimum yang diizinkan) dalam komentar untuk program dan pada saat yang sama menampilkan pesan peringatan jika terjadi pelanggaran terhadap persyaratan ini.  Nah, buat modifikasi yang sesuai untuk makro formasi parameter untuk membentuk penundaan, jangan lupa untuk menggunakan nama "berbicara" untuk menunjukkan variabel. <br><br><pre> <code class="hljs dos">.<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> Freq = <span class="hljs-number"><span class="hljs-number">8000000</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> BaudRate = <span class="hljs-number"><span class="hljs-number">115200</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> PayLoad = <span class="hljs-number"><span class="hljs-number">9</span></span> ;     .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> CycleTime = <span class="hljs-number"><span class="hljs-number">3</span></span> ;    .<span class="hljs-keyword"><span class="hljs-keyword">equ</span></span> delay=((Freq*<span class="hljs-number"><span class="hljs-number">2</span></span>/BaudRate - PayLoad*<span class="hljs-number"><span class="hljs-number">2</span></span>)+CycleTime)/(CycleTime*<span class="hljs-number"><span class="hljs-number">2</span></span>) TX_Byte: cli ldi r18,<span class="hljs-number"><span class="hljs-number">10</span></span> sec ;   - clt ;  - TransBit: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r17,port bld r17,Tx_line out port,r17 Delay_TX: ldi r17,delay Do_Delay_TX: dec r17 brne Do_Delay_TX TX_Bit: bst r16,<span class="hljs-number"><span class="hljs-number">0</span></span> ror r16 dec r18 brne TransBit Exit_Transmit: sei</code> </pre><br>  Sekarang mari kita lihat hasilnya - ukuran kode telah berkurang dari 20 menjadi 16 kata (jika kita hanya memperhitungkan transmisi itu sendiri, maka bahkan lebih mencolok lagi - dari 18 hingga 14, jitter dari front telah menghilang (tentu saja, hanya komponen jitter, yang disebabkan oleh fitur program, pada komponen perangkat keras, kita kami tidak melanggar), keakuratan mempertahankan interval waktu telah meningkat, program menjadi lebih terlihat dan lebih mudah dipahami (karena komentar, karena bahkan program assembler yang ditulis dengan baik biasanya tidak didokumentasikan sendiri). <br><br>  Kesimpulan dari bagian terakhir adalah bahwa jika kita akan membuat rekor dunia dalam pemrograman bahasa assembly, maka kita harus mempelajari arsitektur dari MK tertentu dengan sangat dalam dan menerapkan pengetahuan yang diperoleh untuk mendapatkan hasil yang ideal, memperhatikan semua seluk-beluk. <br><br>  Baik dan sebagai kesimpulan - tugas menulis kode ukuran minimum saat ini terlihat agak dibuat-buat, tetapi, tanpa diduga, menerima konfirmasi vitalitasnya.  Pada akhir tahun lalu (2016, ini adalah berapa lama posting ini telah menunggu gilirannya), sebuah MK baru dari keluarga MSP430 diumumkan, yang bersamaan dengan harga unik yang rendah (26 sen - kami sedang menunggu kemunculan perangkat China berdasarkan itu) juga memiliki ukuran memori program yang kecil - 512 byte (tidak, saya tidak salah, huruf "k" segera setelah nomornya tidak).  Jadi ukuran kode bisa berubah menjadi kritis ketika menggunakan perangkat ini, dan umumnya menulis program ekstrem seperti itu membutuhkan studi mendalam tentang MK, dan "bekerja sendiri adalah berkah." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412959/">https://habr.com/ru/post/id412959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412949/index.html">Ahli astrologi mengumumkan minggu pengembangan iOS di Avito</a></li>
<li><a href="../id412951/index.html">DotVVM - Komunikasi antara klien dan server</a></li>
<li><a href="../id412953/index.html">Kalibrasi Kamera Intel RealSense d435 Menggunakan OpenCV2 dan ROS</a></li>
<li><a href="../id412955/index.html">Tes UI di Xcode dengan Kedutaan Besar dan Sukulen</a></li>
<li><a href="../id412957/index.html">Mi Band 4 dan Mi Band 5: masa depan gelang pintar Xiaomi</a></li>
<li><a href="../id412961/index.html">Berbagi ekonomi dalam telekomunikasi</a></li>
<li><a href="../id412963/index.html">Fallout Baru: Apa yang diketahui tentang Vault 76?</a></li>
<li><a href="../id412967/index.html">Membuat widget penyesuaian kecerahan yang bagus</a></li>
<li><a href="../id412969/index.html">Sistem pengenalan wajah muncul di sekolah-sekolah AS, tetapi efektivitasnya dipertanyakan</a></li>
<li><a href="../id412971/index.html">Membuat aplikasi pewarnaan di Unity3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>