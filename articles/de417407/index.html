<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úã ‚èÆÔ∏è üòΩ Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 1 üëÜüèæ ‚ÜñÔ∏è üï∫üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Walt Disney Animation Studios (WDAS) haben der Rendering-Forschungsgemeinschaft k√ºrzlich ein unsch√§tzbares Geschenk gemacht, indem sie eine vollst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417407/">  Die Walt Disney Animation Studios (WDAS) haben der Rendering-Forschungsgemeinschaft k√ºrzlich ein unsch√§tzbares Geschenk gemacht, indem sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollst√§ndige</a> Inselszene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus <em>dem Moana-</em> Cartoon ver√∂ffentlicht haben</a> .  Geometrie und Texturen f√ºr einen Frame belegen mehr als 70 GB Speicherplatz.  Dies ist ein hervorragendes Beispiel f√ºr die Komplexit√§t, mit der Rendering-Systeme heute umgehen m√ºssen.  Noch nie konnten Forscher und Entwickler, die au√üerhalb von Filmstudios am Rendern beteiligt waren, mit so realistischen Szenen arbeiten. <br><br>  So sieht das Ergebnis des Renderns einer Szene mit modernem pbrt aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/729/ae6/97a/729ae697af18f30723b71a7168807a3f.jpg"></div><br>  <i>Eine Insel aus Moana, die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> mit einer Aufl√∂sung von 2048 x 858 mit 256 Abtastwerten pro Pixel gerendert wurde.</i>  <i>Die gesamte Renderzeit auf einer 12-Core / 24-Thread-Instanz von Google Compute Engine mit einer Frequenz von 2 GHz mit der neuesten Version von pbrt-v3 betrug 1 h 44 min 45 s.</i> <br><br>  Seitens Disney war es eine gro√üe Aufgabe, sie musste die Szene aus ihrem eigenen internen Format extrahieren und in das √ºbliche konvertieren;  Besonderer Dank geht an sie f√ºr die Zeit, die sie f√ºr das Verpacken und Aufbereiten dieser Daten f√ºr die breite Verwendung aufgewendet hat.  Ich bin sicher, dass ihre Arbeit in Zukunft gut belohnt wird, da Forscher diese Szene verwenden, um die Probleme beim effizienten Rendern von Szenen dieser Komplexit√§t zu untersuchen. <br><a name="habracut"></a><br>  Diese Szene hat mir bereits viel beigebracht und mir erm√∂glicht, den pbrt-Renderer zu verbessern, aber bevor wir darauf eingehen, werde ich eine kurze Geschichte erz√§hlen, um den Kontext zu verstehen. <br><br><h2>  Der Hash war das nicht </h2><br>  W√§hrend eines Praktikums im Pixar-Rendering-Team habe ich vor vielen Jahren eine merkw√ºrdige Lektion gelernt: ‚ÄûInteressante‚Äú Dinge erscheinen fast immer, wenn Eingabedaten an das Programmsystem √ºbergeben werden, die sich erheblich von allem unterscheiden, was vorher war.  Selbst in gut geschriebenen und ausgereiften Softwaresystemen f√ºhren neue Arten von Eingaben fast immer zur Entdeckung unbekannter Fehler in einer vorhandenen Implementierung. <br><br>  Diese Lektion habe ich zum ersten Mal w√§hrend der Produktion von <em>Toy Story 2</em> gelernt.  Eines Tages bemerkte jemand, dass erstaunlich viel Zeit damit verbracht wurde, RIB-Szenenbeschreibungsdateien zu analysieren.  Jemand anderes vom Rendering-Team (ich denke, es war Craig Kolb) hat den Profiler gestartet und angefangen, es herauszufinden. <br><br>  Es stellte sich heraus, dass der gr√∂√üte Teil der Analysezeit mit Suchen in der Hash-Tabelle belegt war, die f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internieren von Zeichenfolgen verwendet wurde</a> .  Die Hash-Tabelle war ziemlich klein, wahrscheinlich 256 Elemente, und als mehrere Werte in eine Zelle gehasht wurden, organisierte sie eine Kette.  Nach der ersten Implementierung der Hash-Tabelle verging viel Zeit und es befanden sich nun Zehntausende von Objekten in den Szenen, sodass eine so kleine Tabelle schnell gef√ºllt und unwirksam wurde. <br><br>  Es war am ratsamsten, die Gr√∂√üe des Tisches einfach zu vergr√∂√üern - all dies geschah auf der H√∂he des Workflows, sodass keine Zeit f√ºr eine elegante L√∂sung blieb, z. B. die Gr√∂√üe des Tisches beim Ausf√ºllen zu vergr√∂√üern.  Wir nehmen eine √Ñnderung in einer Zeile vor, erstellen die Anwendung neu, f√ºhren vor dem Festschreiben einen Schnelltest durch und ... es treten keine Geschwindigkeitsverbesserungen auf.  Das Durchsuchen einer Hash-Tabelle dauert genauso lange.  Super! <br><br>  Nach weiteren Untersuchungen stellten wir fest, dass die verwendete Hash-Tabellenfunktion der folgenden √§hnlich war: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  (Verzeihen Sie mir, Pixar, wenn ich Ihren streng geheimen RenderMan-Quellcode enth√ºllt habe.) <br><br>  Die "Hash" -Funktion wurde bereits in den 1980er Jahren implementiert.  Zu diesem Zeitpunkt war der Programmierer wahrscheinlich der Ansicht, dass der Rechenaufwand f√ºr die √úberpr√ºfung der Auswirkung aller Zeichen in der Zeichenfolge auf den Hashwert zu hoch und nicht wert w√§re.  (Ich denke, wenn es nur wenige Objekte und 256 Elemente in der Hash-Tabelle in der Szene gab, war das genug.) <br><br>  Eine weitere veraltete Implementierung trug dazu bei: Von dem Moment an, als Pixar mit der Erstellung seiner Filme begann, sind die Namen der Objekte in den Szenen erheblich gewachsen, z. B. ‚ÄûBuzzLightyear / LeftArm / Hand / IndexFinger / Knuckle2‚Äú.  In einem Anfangsstadium der Pipeline wurde jedoch ein Puffer mit fester L√§nge verwendet, um die Namen von Objekten zu speichern, und alle langen Namen wurden gek√ºrzt, wobei nur das Ende beibehalten wurde. Mit etwas Gl√ºck wurde am Anfang eine Ellipse hinzugef√ºgt, um deutlich zu machen, dass ein Teil des Namens verloren gegangen ist: "... year / LeftArm / Hand / IndexFinger / Knuckle2 ". <br><br>  Anschlie√üend hatten alle Namen der Objekte, die der Renderer sah, diese Form, die Hash-Funktion hat sie alle als "." In einen Speicher gehasht, und die Hash-Tabelle war tats√§chlich eine gro√üe verkn√ºpfte Liste.  Gute alte Zeiten.  Zumindest nachdem wir es herausgefunden hatten, haben wir diesen Fehler schnell behoben. <br><br><h2>  Faszinierende Innovation </h2><br>  Diese Lektion wurde mir letztes Jahr in Erinnerung gerufen, als Heather Pritchet und Rasmus Tamstorf von WDAS mich kontaktierten und fragten, ob ich daran interessiert w√§re, die m√∂gliche Qualit√§t des Renderns der Szene von <em>Moana</em> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt</a> <sup>1 zu</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberpr√ºfen</a> .  Nat√ºrlich stimmte ich zu.  Ich war gl√ºcklich zu helfen und habe mich gefragt, wie alles ausgehen wird. <br><br>  Der naive Optimist in mir hoffte, dass es keine gro√üen √úberraschungen geben w√ºrde - am Ende wurde die erste Version von pbrt vor ungef√§hr 15 Jahren ver√∂ffentlicht, und viele Leute verwendeten und studierten ihren Code viele Jahre lang.  Sie k√∂nnen sicher sein, dass es keine Interferenzen wie bei der alten Hash-Funktion von RenderMan gibt, oder? <br><br>  Die Antwort war nat√ºrlich nein.  (Und deshalb schreibe ich diesen und einige andere Beitr√§ge.) Obwohl ich ein wenig entt√§uscht war, dass pbrt nicht ‚Äûout of the box‚Äú perfekt war, denke ich, dass meine Erfahrung mit der <em>Moana-</em> Szene die erste Best√§tigung f√ºr den Wert der Ver√∂ffentlichung dieser Szene war ;;  pbrt ist bereits zu einem besseren System geworden, da ich herausgefunden habe, wie ich mit dieser Szene umgehen soll. <br><br><h3>  Erste Renderings </h3><br>  Nachdem ich auf die Szene zugegriffen hatte, lud ich sie sofort herunter (es dauerte mehrere Stunden mit meiner Heim-Internetverbindung) und entpackte sie aus tar, wobei ich 29 GB pbrt-Dateien und 38 GB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptex</a> <sup>2-</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten erhielt</a> .  Ich habe munter versucht, die Szene auf meinem Heimsystem zu rendern (mit 16 GB RAM und einer 4-Kern-CPU).  Nachdem ich nach einiger Zeit zum Computer zur√ºckgekehrt war, stellte ich fest, dass er eingefroren war, der gesamte Arbeitsspeicher voll war und pbrt immer noch versuchte, das Parsen der Szenenbeschreibung abzuschlie√üen.  Das Betriebssystem versuchte, die Aufgabe mithilfe des virtuellen Speichers zu bew√§ltigen, aber es schien hoffnungslos.  Nachdem ich den Prozess abgeschlossen hatte, musste ich noch eine Minute warten, bis das System auf meine Aktionen reagierte. <br><br>  Der n√§chste Versuch war eine Instanz von Google Compute Engine, mit der Sie mehr RAM (120 GB) und mehr CPU (32 Threads auf 16 CPUs) verwenden k√∂nnen.  Die gute Nachricht war, dass pbrt die Szene erfolgreich rendern konnte (dank der Arbeit von Heather und Rasmus, sie in das pbrt-Format zu konvertieren).  Es war sehr aufregend zu sehen, dass pbrt relativ gute Pixel f√ºr qualitativ hochwertige Filminhalte erzeugen kann, aber die Geschwindigkeit erwies sich als nicht so erstaunlich: 34 min 58 s nur zum Parsen der Szenenbeschreibung und beim Rendern des Systems bis zu 70 GB RAM. <br><br>  Ja, es gab 29 Gigabyte Szenenbeschreibungsdateien im pbrt-Format auf der Festplatte, die gespart werden mussten, sodass ich nicht damit gerechnet hatte, dass die erste Phase einige Sekunden dauern w√ºrde.  Aber eine halbe Stunde verbringen, noch bevor die Strahlen zu verfolgen beginnen?  Dies erschwert die Arbeit mit der Szene erheblich. <br><br>  Auf der anderen Seite sagte uns diese Geschwindigkeit, dass im Code wahrscheinlich etwas sehr √ºbelriechendes passiert;  nicht nur "Matrixinversion kann 10% schneller durchgef√ºhrt werden";  Vielmehr etwas auf der Ebene von ‚ÄûOh, wir gehen eine verkn√ºpfte Liste von 100.000 Elementen durch‚Äú.  Ich war optimistisch und hoffte, dass ich den Prozess erheblich beschleunigen konnte, nachdem ich es herausgefunden hatte. <br><br><h3>  Statistiken helfen nicht </h3><br>  Der erste Ort, an dem ich nach Hinweisen suchte, war die pbrt-Dump-Statistik nach dem Rendern.  Die Hauptphasen der pbrt-Ausf√ºhrung sind so konfiguriert, dass Sie ungef√§hre Profildaten erfassen k√∂nnen, indem Sie Vorg√§nge mit periodischen Unterbrechungen w√§hrend des Rendervorgangs korrigieren.  Leider hat uns die Statistik nicht viel geholfen: Berichten zufolge wurden fast 35 Minuten vor Beginn des Renderns 4 Minuten und 22 Sekunden f√ºr den Aufbau des BVH aufgewendet, aber f√ºr den Rest der Zeit wurden keine Details angegeben. <br><br>  Das Erstellen von BVH ist die einzige wichtige Rechenaufgabe, die beim Parsen von Szenen ausgef√ºhrt wird.  Alles andere ist im Wesentlichen eine Deserialisierung von Geometrie und Materialbeschreibungen.  Wenn man wusste, wie viel Zeit f√ºr die Erstellung des BVH aufgewendet wurde, konnte man verstehen, wie (un) effektiv das System war: Die verbleibende Zeit, n√§mlich etwa 30 Minuten, analysierte 29 GB Daten, dh die Geschwindigkeit betrug 16,5 MB / s.  Gut optimierte JSON-Parser, die im Wesentlichen dieselbe Aufgabe ausf√ºhren, arbeiten mit einer Geschwindigkeit von 50 bis 200 MB / s.  Nat√ºrlich gibt es noch Verbesserungspotenzial. <br><br>  Um besser zu verstehen, wie viel Zeit verschwendet wird, habe ich pbrt mit einem Linux- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perf-</a> Tool gestartet, das ich noch nie zuvor verwendet hatte.  Aber anscheinend hat er die Aufgabe gemeistert.  Ich wies ihn an, nach DWARF-Zeichen zu suchen, um Funktionsnamen zu erhalten ( <code>--call-graph dwarf</code> ), und um keine 100-Gigabyte-Trace-Dateien zu erhalten, musste ich die Abtastrate von 4000 auf 100 Abtastungen pro Sekunde ( <code>-F 100</code> ) senken.  Aber mit diesen Parametern lief alles gut und ich war angenehm √ºberrascht, dass das <code>perf report</code> Tool eine Oberfl√§che mit netten Fl√ºchen hat. <br><br>  Folgendes k√∂nnte er mir sagen, nachdem er mit pbrt angefangen hat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/d31/643/a9ed31643e22b9c5d0566c7b210f4067.png"></div><br>  <i>Ich habe nicht gescherzt, als ich √ºber die "Schnittstelle mit sch√∂nen Fl√ºchen" sprach.</i> <br><br>  Wir sehen, dass mehr als die H√§lfte der Zeit f√ºr die Analyse der Mechanik <code>yyparse()</code> : <code>yyparse()</code> ist das von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bison</a> erzeugte <code>yylex()</code> und <code>yylex()</code> ist der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">flex</a> erzeugte lexikalische Analysator (Lexer).  Mehr als die H√§lfte der Zeit in <code>yylex()</code> wird f√ºr <code>strtod()</code> , das Zeichenfolgen in doppelte Werte konvertiert.  Wir werden <code>yyparse()</code> Angriff auf <code>yyparse()</code> und <code>yylex()</code> den dritten Artikel in dieser Reihe verschieben, aber jetzt k√∂nnen wir bereits verstehen, dass es eine gute Idee sein k√∂nnte, die in den Renderer geworfene Datenmenge zu reduzieren. <br><br><h3>  Vom Text zum PLY </h3><br>  Eine M√∂glichkeit, weniger Zeit mit dem Parsen von Textdaten zu verbringen, besteht darin, die Daten in ein Format zu konvertieren, das effizienter analysiert wird.  Die meisten der 29 GB dieser Szenenbeschreibungsdateien sind Dreiecksnetze, und pbrt unterst√ºtzt bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das PLY-Format</a> , eine effektive bin√§re Darstellung von Polygonnetzen.  Au√üerdem gibt es in pbrt ein Befehlszeilenflag <code>--toply</code> , das die Szenenbeschreibungsdatei pbrt analysiert, alle gefundenen Dreiecksnetze in PLY-Dateien konvertiert und eine neue pbrt-Datei erstellt, die auf diese PLY-Dateien verweist. <br><br>  Der Haken ist, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptex-</a> Texturen in der Disney-Szene aktiv verwendet werden, was wiederum erfordert, dass jedem Dreieck ein <code>faceIndex</code> Wert zugeordnet wird, der bestimmt, von welcher Fl√§che des urspr√ºnglichen Teilnetzes es stammt.  Um diese Werte zu √ºbertragen, gen√ºgte es, einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung f√ºr neue Felder in der PLY-Datei hinzuzuf√ºgen</a> .  Weitere Untersuchungen ergaben, dass beim Konvertieren jedes Netzes - selbst wenn es nur ein Dutzend Dreiecke enth√§lt - in eine PLY-Datei Zehntausende kleiner PLY-Dateien im Ordner erstellt werden, was zu eigenen Leistungsproblemen f√ºhrt.  Wir haben es geschafft, dieses Problem zu beseitigen, indem wir der Implementierung die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M√∂glichkeit</a> hinzugef√ºgt haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, kleine Netze unver√§ndert zu lassen</a> . <br><br>  Ich habe ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleines Befehlszeilenskript geschrieben</a> , um alle <code>*_geometry.pbrt</code> Dateien in einen Ordner zu konvertieren und PLY f√ºr gro√üe Netze zu verwenden.  Beachten Sie, dass es fest codierte Annahmen zu Pfaden gibt, die ge√§ndert werden m√ºssen, damit das Skript an anderer Stelle funktioniert. <br><br><h3>  Erster Geschwindigkeitsschub </h3><br>  Nach dem Konvertieren aller gro√üen Netze in PLY verringerte sich die Gr√∂√üe der Szenenbeschreibung auf der Festplatte von 29 auf 22 GB: 16,9 GB pbrt-Szenendateien und 5,1 GB PLY-Bin√§rdateien.  Nach der Konvertierung verringerte sich die Gesamtzeit der ersten Stufe des Systems auf 27 Minuten und 35 Sekunden, und die Einsparungen beliefen sich auf 7 Minuten und 23 Sekunden, dh wir beschleunigten um das 1,3-fache <sup>3</sup> .  Das Verarbeiten einer PLY-Datei ist viel effizienter als das Verarbeiten einer pbrt-Textdatei: Nur 40 Sekunden Startzeit wurden f√ºr das Parsen von PLY-Dateien aufgewendet, und wir sehen, dass PLY-Dateien mit einer Geschwindigkeit von ca. 130 MB / s oder ca. 8-mal schneller als das pbrt-Textformat verarbeitet wurden . <br><br>  Es war ein guter, einfacher Sieg, aber wir hatten noch viel zu tun. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim n√§chsten Mal werden</a> wir herausfinden, wo der gesamte Speicher tats√§chlich verwendet wird, hier einige Fehler beheben und dabei noch mehr Geschwindigkeit erzielen. <br><br><h2>  Anmerkungen </h2><br><ol><li>  Sie sollten jetzt ein besseres Verst√§ndnis f√ºr die Motivation haben, meinerseits ptex-Unterst√ºtzung hinzuzuf√ºgen und Disney BSDF letztes Jahr auf pbrt umzustellen. </li><li>  Die ganze Zeit hier und in nachfolgenden Beitr√§gen ist f√ºr die WIP-Version (Work In Progress) angegeben, mit der ich vor der offiziellen Ver√∂ffentlichung gearbeitet habe.  Es scheint, dass die endg√ºltige Version etwas gr√∂√üer ist.  Wir werden uns an die Ergebnisse halten, die ich bei der Arbeit mit der Originalszene aufgenommen habe, obwohl sie nicht ganz den Ergebnissen der endg√ºltigen Version entsprechen.  Ich vermute, dass die Lehren aus ihnen die gleichen sein k√∂nnen. </li><li>  Beachten Sie, dass die Geschwindigkeitssteigerung im Wesentlichen dem entspricht, was Sie bei einer Reduzierung des Parsing-Datenvolumens um ca. 50 Prozent erwarten w√ºrden.  Die Zeit, die wir laut Profiler verbringen, best√§tigt unsere Idee. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417407/">https://habr.com/ru/post/de417407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417395/index.html">End-to-End-Tests: Was, warum, warum</a></li>
<li><a href="../de417397/index.html">Welche Programmiersprache soll man 2018 lernen und warum?</a></li>
<li><a href="../de417399/index.html">Willkommen an Bord: Einf√ºhrung neuer Entwickler in das Team</a></li>
<li><a href="../de417401/index.html">Schlie√ülich w√§hlen wir ein Budget-Multimeter mit guter Funktionalit√§t</a></li>
<li><a href="../de417405/index.html">Auto-Encoder und starke k√ºnstliche Intelligenz</a></li>
<li><a href="../de417409/index.html">Wie man Teamkollegen in skalierbarem Scram √ºberlebt und die Codequalit√§tskontrolle aufrechterh√§lt</a></li>
<li><a href="../de417411/index.html">Bewerten Sie den Entwickler anhand objektiver Daten</a></li>
<li><a href="../de417413/index.html">Unterscheiden sich die Probleme der Teamleiter in St. Petersburg? Informieren Sie sich bei Saint TeamLead Conf</a></li>
<li><a href="../de417415/index.html">3D-Druckunterricht. Drucken von Teilen mit unterschiedlichen Schichtdicken aus 3Dtool</a></li>
<li><a href="../de417419/index.html">[Jekaterinburg, Ank√ºndigung] Alice besucht Kontur - Hackathon, um F√§higkeiten f√ºr Sprachassistenten zu entwickeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>