<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋ ⏮️ 😽 Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 1 👆🏾 ↖️ 🕺🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Walt Disney Animation Studios (WDAS) haben der Rendering-Forschungsgemeinschaft kürzlich ein unschätzbares Geschenk gemacht, indem sie eine vollst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417407/">  Die Walt Disney Animation Studios (WDAS) haben der Rendering-Forschungsgemeinschaft kürzlich ein unschätzbares Geschenk gemacht, indem sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständige</a> Inselszene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus <em>dem Moana-</em> Cartoon veröffentlicht haben</a> .  Geometrie und Texturen für einen Frame belegen mehr als 70 GB Speicherplatz.  Dies ist ein hervorragendes Beispiel für die Komplexität, mit der Rendering-Systeme heute umgehen müssen.  Noch nie konnten Forscher und Entwickler, die außerhalb von Filmstudios am Rendern beteiligt waren, mit so realistischen Szenen arbeiten. <br><br>  So sieht das Ergebnis des Renderns einer Szene mit modernem pbrt aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/729/ae6/97a/729ae697af18f30723b71a7168807a3f.jpg"></div><br>  <i>Eine Insel aus Moana, die von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt-v3</a> mit einer Auflösung von 2048 x 858 mit 256 Abtastwerten pro Pixel gerendert wurde.</i>  <i>Die gesamte Renderzeit auf einer 12-Core / 24-Thread-Instanz von Google Compute Engine mit einer Frequenz von 2 GHz mit der neuesten Version von pbrt-v3 betrug 1 h 44 min 45 s.</i> <br><br>  Seitens Disney war es eine große Aufgabe, sie musste die Szene aus ihrem eigenen internen Format extrahieren und in das übliche konvertieren;  Besonderer Dank geht an sie für die Zeit, die sie für das Verpacken und Aufbereiten dieser Daten für die breite Verwendung aufgewendet hat.  Ich bin sicher, dass ihre Arbeit in Zukunft gut belohnt wird, da Forscher diese Szene verwenden, um die Probleme beim effizienten Rendern von Szenen dieser Komplexität zu untersuchen. <br><a name="habracut"></a><br>  Diese Szene hat mir bereits viel beigebracht und mir ermöglicht, den pbrt-Renderer zu verbessern, aber bevor wir darauf eingehen, werde ich eine kurze Geschichte erzählen, um den Kontext zu verstehen. <br><br><h2>  Der Hash war das nicht </h2><br>  Während eines Praktikums im Pixar-Rendering-Team habe ich vor vielen Jahren eine merkwürdige Lektion gelernt: „Interessante“ Dinge erscheinen fast immer, wenn Eingabedaten an das Programmsystem übergeben werden, die sich erheblich von allem unterscheiden, was vorher war.  Selbst in gut geschriebenen und ausgereiften Softwaresystemen führen neue Arten von Eingaben fast immer zur Entdeckung unbekannter Fehler in einer vorhandenen Implementierung. <br><br>  Diese Lektion habe ich zum ersten Mal während der Produktion von <em>Toy Story 2</em> gelernt.  Eines Tages bemerkte jemand, dass erstaunlich viel Zeit damit verbracht wurde, RIB-Szenenbeschreibungsdateien zu analysieren.  Jemand anderes vom Rendering-Team (ich denke, es war Craig Kolb) hat den Profiler gestartet und angefangen, es herauszufinden. <br><br>  Es stellte sich heraus, dass der größte Teil der Analysezeit mit Suchen in der Hash-Tabelle belegt war, die für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Internieren von Zeichenfolgen verwendet wurde</a> .  Die Hash-Tabelle war ziemlich klein, wahrscheinlich 256 Elemente, und als mehrere Werte in eine Zelle gehasht wurden, organisierte sie eine Kette.  Nach der ersten Implementierung der Hash-Tabelle verging viel Zeit und es befanden sich nun Zehntausende von Objekten in den Szenen, sodass eine so kleine Tabelle schnell gefüllt und unwirksam wurde. <br><br>  Es war am ratsamsten, die Größe des Tisches einfach zu vergrößern - all dies geschah auf der Höhe des Workflows, sodass keine Zeit für eine elegante Lösung blieb, z. B. die Größe des Tisches beim Ausfüllen zu vergrößern.  Wir nehmen eine Änderung in einer Zeile vor, erstellen die Anwendung neu, führen vor dem Festschreiben einen Schnelltest durch und ... es treten keine Geschwindigkeitsverbesserungen auf.  Das Durchsuchen einer Hash-Tabelle dauert genauso lange.  Super! <br><br>  Nach weiteren Untersuchungen stellten wir fest, dass die verwendete Hash-Tabellenfunktion der folgenden ähnlich war: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  (Verzeihen Sie mir, Pixar, wenn ich Ihren streng geheimen RenderMan-Quellcode enthüllt habe.) <br><br>  Die "Hash" -Funktion wurde bereits in den 1980er Jahren implementiert.  Zu diesem Zeitpunkt war der Programmierer wahrscheinlich der Ansicht, dass der Rechenaufwand für die Überprüfung der Auswirkung aller Zeichen in der Zeichenfolge auf den Hashwert zu hoch und nicht wert wäre.  (Ich denke, wenn es nur wenige Objekte und 256 Elemente in der Hash-Tabelle in der Szene gab, war das genug.) <br><br>  Eine weitere veraltete Implementierung trug dazu bei: Von dem Moment an, als Pixar mit der Erstellung seiner Filme begann, sind die Namen der Objekte in den Szenen erheblich gewachsen, z. B. „BuzzLightyear / LeftArm / Hand / IndexFinger / Knuckle2“.  In einem Anfangsstadium der Pipeline wurde jedoch ein Puffer mit fester Länge verwendet, um die Namen von Objekten zu speichern, und alle langen Namen wurden gekürzt, wobei nur das Ende beibehalten wurde. Mit etwas Glück wurde am Anfang eine Ellipse hinzugefügt, um deutlich zu machen, dass ein Teil des Namens verloren gegangen ist: "... year / LeftArm / Hand / IndexFinger / Knuckle2 ". <br><br>  Anschließend hatten alle Namen der Objekte, die der Renderer sah, diese Form, die Hash-Funktion hat sie alle als "." In einen Speicher gehasht, und die Hash-Tabelle war tatsächlich eine große verknüpfte Liste.  Gute alte Zeiten.  Zumindest nachdem wir es herausgefunden hatten, haben wir diesen Fehler schnell behoben. <br><br><h2>  Faszinierende Innovation </h2><br>  Diese Lektion wurde mir letztes Jahr in Erinnerung gerufen, als Heather Pritchet und Rasmus Tamstorf von WDAS mich kontaktierten und fragten, ob ich daran interessiert wäre, die mögliche Qualität des Renderns der Szene von <em>Moana</em> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pbrt</a> <sup>1 zu</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">überprüfen</a> .  Natürlich stimmte ich zu.  Ich war glücklich zu helfen und habe mich gefragt, wie alles ausgehen wird. <br><br>  Der naive Optimist in mir hoffte, dass es keine großen Überraschungen geben würde - am Ende wurde die erste Version von pbrt vor ungefähr 15 Jahren veröffentlicht, und viele Leute verwendeten und studierten ihren Code viele Jahre lang.  Sie können sicher sein, dass es keine Interferenzen wie bei der alten Hash-Funktion von RenderMan gibt, oder? <br><br>  Die Antwort war natürlich nein.  (Und deshalb schreibe ich diesen und einige andere Beiträge.) Obwohl ich ein wenig enttäuscht war, dass pbrt nicht „out of the box“ perfekt war, denke ich, dass meine Erfahrung mit der <em>Moana-</em> Szene die erste Bestätigung für den Wert der Veröffentlichung dieser Szene war ;;  pbrt ist bereits zu einem besseren System geworden, da ich herausgefunden habe, wie ich mit dieser Szene umgehen soll. <br><br><h3>  Erste Renderings </h3><br>  Nachdem ich auf die Szene zugegriffen hatte, lud ich sie sofort herunter (es dauerte mehrere Stunden mit meiner Heim-Internetverbindung) und entpackte sie aus tar, wobei ich 29 GB pbrt-Dateien und 38 GB <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptex</a> <sup>2-</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texturkarten erhielt</a> .  Ich habe munter versucht, die Szene auf meinem Heimsystem zu rendern (mit 16 GB RAM und einer 4-Kern-CPU).  Nachdem ich nach einiger Zeit zum Computer zurückgekehrt war, stellte ich fest, dass er eingefroren war, der gesamte Arbeitsspeicher voll war und pbrt immer noch versuchte, das Parsen der Szenenbeschreibung abzuschließen.  Das Betriebssystem versuchte, die Aufgabe mithilfe des virtuellen Speichers zu bewältigen, aber es schien hoffnungslos.  Nachdem ich den Prozess abgeschlossen hatte, musste ich noch eine Minute warten, bis das System auf meine Aktionen reagierte. <br><br>  Der nächste Versuch war eine Instanz von Google Compute Engine, mit der Sie mehr RAM (120 GB) und mehr CPU (32 Threads auf 16 CPUs) verwenden können.  Die gute Nachricht war, dass pbrt die Szene erfolgreich rendern konnte (dank der Arbeit von Heather und Rasmus, sie in das pbrt-Format zu konvertieren).  Es war sehr aufregend zu sehen, dass pbrt relativ gute Pixel für qualitativ hochwertige Filminhalte erzeugen kann, aber die Geschwindigkeit erwies sich als nicht so erstaunlich: 34 min 58 s nur zum Parsen der Szenenbeschreibung und beim Rendern des Systems bis zu 70 GB RAM. <br><br>  Ja, es gab 29 Gigabyte Szenenbeschreibungsdateien im pbrt-Format auf der Festplatte, die gespart werden mussten, sodass ich nicht damit gerechnet hatte, dass die erste Phase einige Sekunden dauern würde.  Aber eine halbe Stunde verbringen, noch bevor die Strahlen zu verfolgen beginnen?  Dies erschwert die Arbeit mit der Szene erheblich. <br><br>  Auf der anderen Seite sagte uns diese Geschwindigkeit, dass im Code wahrscheinlich etwas sehr übelriechendes passiert;  nicht nur "Matrixinversion kann 10% schneller durchgeführt werden";  Vielmehr etwas auf der Ebene von „Oh, wir gehen eine verknüpfte Liste von 100.000 Elementen durch“.  Ich war optimistisch und hoffte, dass ich den Prozess erheblich beschleunigen konnte, nachdem ich es herausgefunden hatte. <br><br><h3>  Statistiken helfen nicht </h3><br>  Der erste Ort, an dem ich nach Hinweisen suchte, war die pbrt-Dump-Statistik nach dem Rendern.  Die Hauptphasen der pbrt-Ausführung sind so konfiguriert, dass Sie ungefähre Profildaten erfassen können, indem Sie Vorgänge mit periodischen Unterbrechungen während des Rendervorgangs korrigieren.  Leider hat uns die Statistik nicht viel geholfen: Berichten zufolge wurden fast 35 Minuten vor Beginn des Renderns 4 Minuten und 22 Sekunden für den Aufbau des BVH aufgewendet, aber für den Rest der Zeit wurden keine Details angegeben. <br><br>  Das Erstellen von BVH ist die einzige wichtige Rechenaufgabe, die beim Parsen von Szenen ausgeführt wird.  Alles andere ist im Wesentlichen eine Deserialisierung von Geometrie und Materialbeschreibungen.  Wenn man wusste, wie viel Zeit für die Erstellung des BVH aufgewendet wurde, konnte man verstehen, wie (un) effektiv das System war: Die verbleibende Zeit, nämlich etwa 30 Minuten, analysierte 29 GB Daten, dh die Geschwindigkeit betrug 16,5 MB / s.  Gut optimierte JSON-Parser, die im Wesentlichen dieselbe Aufgabe ausführen, arbeiten mit einer Geschwindigkeit von 50 bis 200 MB / s.  Natürlich gibt es noch Verbesserungspotenzial. <br><br>  Um besser zu verstehen, wie viel Zeit verschwendet wird, habe ich pbrt mit einem Linux- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perf-</a> Tool gestartet, das ich noch nie zuvor verwendet hatte.  Aber anscheinend hat er die Aufgabe gemeistert.  Ich wies ihn an, nach DWARF-Zeichen zu suchen, um Funktionsnamen zu erhalten ( <code>--call-graph dwarf</code> ), und um keine 100-Gigabyte-Trace-Dateien zu erhalten, musste ich die Abtastrate von 4000 auf 100 Abtastungen pro Sekunde ( <code>-F 100</code> ) senken.  Aber mit diesen Parametern lief alles gut und ich war angenehm überrascht, dass das <code>perf report</code> Tool eine Oberfläche mit netten Flüchen hat. <br><br>  Folgendes könnte er mir sagen, nachdem er mit pbrt angefangen hat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/d31/643/a9ed31643e22b9c5d0566c7b210f4067.png"></div><br>  <i>Ich habe nicht gescherzt, als ich über die "Schnittstelle mit schönen Flüchen" sprach.</i> <br><br>  Wir sehen, dass mehr als die Hälfte der Zeit für die Analyse der Mechanik <code>yyparse()</code> : <code>yyparse()</code> ist das von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bison</a> erzeugte <code>yylex()</code> und <code>yylex()</code> ist der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">flex</a> erzeugte lexikalische Analysator (Lexer).  Mehr als die Hälfte der Zeit in <code>yylex()</code> wird für <code>strtod()</code> , das Zeichenfolgen in doppelte Werte konvertiert.  Wir werden <code>yyparse()</code> Angriff auf <code>yyparse()</code> und <code>yylex()</code> den dritten Artikel in dieser Reihe verschieben, aber jetzt können wir bereits verstehen, dass es eine gute Idee sein könnte, die in den Renderer geworfene Datenmenge zu reduzieren. <br><br><h3>  Vom Text zum PLY </h3><br>  Eine Möglichkeit, weniger Zeit mit dem Parsen von Textdaten zu verbringen, besteht darin, die Daten in ein Format zu konvertieren, das effizienter analysiert wird.  Die meisten der 29 GB dieser Szenenbeschreibungsdateien sind Dreiecksnetze, und pbrt unterstützt bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das PLY-Format</a> , eine effektive binäre Darstellung von Polygonnetzen.  Außerdem gibt es in pbrt ein Befehlszeilenflag <code>--toply</code> , das die Szenenbeschreibungsdatei pbrt analysiert, alle gefundenen Dreiecksnetze in PLY-Dateien konvertiert und eine neue pbrt-Datei erstellt, die auf diese PLY-Dateien verweist. <br><br>  Der Haken ist, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ptex-</a> Texturen in der Disney-Szene aktiv verwendet werden, was wiederum erfordert, dass jedem Dreieck ein <code>faceIndex</code> Wert zugeordnet wird, der bestimmt, von welcher Fläche des ursprünglichen Teilnetzes es stammt.  Um diese Werte zu übertragen, genügte es, einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterstützung für neue Felder in der PLY-Datei hinzuzufügen</a> .  Weitere Untersuchungen ergaben, dass beim Konvertieren jedes Netzes - selbst wenn es nur ein Dutzend Dreiecke enthält - in eine PLY-Datei Zehntausende kleiner PLY-Dateien im Ordner erstellt werden, was zu eigenen Leistungsproblemen führt.  Wir haben es geschafft, dieses Problem zu beseitigen, indem wir der Implementierung die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Möglichkeit</a> hinzugefügt haben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, kleine Netze unverändert zu lassen</a> . <br><br>  Ich habe ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kleines Befehlszeilenskript geschrieben</a> , um alle <code>*_geometry.pbrt</code> Dateien in einen Ordner zu konvertieren und PLY für große Netze zu verwenden.  Beachten Sie, dass es fest codierte Annahmen zu Pfaden gibt, die geändert werden müssen, damit das Skript an anderer Stelle funktioniert. <br><br><h3>  Erster Geschwindigkeitsschub </h3><br>  Nach dem Konvertieren aller großen Netze in PLY verringerte sich die Größe der Szenenbeschreibung auf der Festplatte von 29 auf 22 GB: 16,9 GB pbrt-Szenendateien und 5,1 GB PLY-Binärdateien.  Nach der Konvertierung verringerte sich die Gesamtzeit der ersten Stufe des Systems auf 27 Minuten und 35 Sekunden, und die Einsparungen beliefen sich auf 7 Minuten und 23 Sekunden, dh wir beschleunigten um das 1,3-fache <sup>3</sup> .  Das Verarbeiten einer PLY-Datei ist viel effizienter als das Verarbeiten einer pbrt-Textdatei: Nur 40 Sekunden Startzeit wurden für das Parsen von PLY-Dateien aufgewendet, und wir sehen, dass PLY-Dateien mit einer Geschwindigkeit von ca. 130 MB / s oder ca. 8-mal schneller als das pbrt-Textformat verarbeitet wurden . <br><br>  Es war ein guter, einfacher Sieg, aber wir hatten noch viel zu tun. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim nächsten Mal werden</a> wir herausfinden, wo der gesamte Speicher tatsächlich verwendet wird, hier einige Fehler beheben und dabei noch mehr Geschwindigkeit erzielen. <br><br><h2>  Anmerkungen </h2><br><ol><li>  Sie sollten jetzt ein besseres Verständnis für die Motivation haben, meinerseits ptex-Unterstützung hinzuzufügen und Disney BSDF letztes Jahr auf pbrt umzustellen. </li><li>  Die ganze Zeit hier und in nachfolgenden Beiträgen ist für die WIP-Version (Work In Progress) angegeben, mit der ich vor der offiziellen Veröffentlichung gearbeitet habe.  Es scheint, dass die endgültige Version etwas größer ist.  Wir werden uns an die Ergebnisse halten, die ich bei der Arbeit mit der Originalszene aufgenommen habe, obwohl sie nicht ganz den Ergebnissen der endgültigen Version entsprechen.  Ich vermute, dass die Lehren aus ihnen die gleichen sein können. </li><li>  Beachten Sie, dass die Geschwindigkeitssteigerung im Wesentlichen dem entspricht, was Sie bei einer Reduzierung des Parsing-Datenvolumens um ca. 50 Prozent erwarten würden.  Die Zeit, die wir laut Profiler verbringen, bestätigt unsere Idee. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417407/">https://habr.com/ru/post/de417407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417395/index.html">End-to-End-Tests: Was, warum, warum</a></li>
<li><a href="../de417397/index.html">Welche Programmiersprache soll man 2018 lernen und warum?</a></li>
<li><a href="../de417399/index.html">Willkommen an Bord: Einführung neuer Entwickler in das Team</a></li>
<li><a href="../de417401/index.html">Schließlich wählen wir ein Budget-Multimeter mit guter Funktionalität</a></li>
<li><a href="../de417405/index.html">Auto-Encoder und starke künstliche Intelligenz</a></li>
<li><a href="../de417409/index.html">Wie man Teamkollegen in skalierbarem Scram überlebt und die Codequalitätskontrolle aufrechterhält</a></li>
<li><a href="../de417411/index.html">Bewerten Sie den Entwickler anhand objektiver Daten</a></li>
<li><a href="../de417413/index.html">Unterscheiden sich die Probleme der Teamleiter in St. Petersburg? Informieren Sie sich bei Saint TeamLead Conf</a></li>
<li><a href="../de417415/index.html">3D-Druckunterricht. Drucken von Teilen mit unterschiedlichen Schichtdicken aus 3Dtool</a></li>
<li><a href="../de417419/index.html">[Jekaterinburg, Ankündigung] Alice besucht Kontur - Hackathon, um Fähigkeiten für Sprachassistenten zu entwickeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>