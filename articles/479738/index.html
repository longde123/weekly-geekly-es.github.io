<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚽️ 🧚🏻 🤖 Como Youtube e Instagram: internacionalizando y localizando una aplicación Python 💯 🎳 🤶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python está en el centro de aplicaciones mundialmente famosas como Youtube, Instagram y Pinterest. Para avanzar en el mercado mundial, una aplicación ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como Youtube e Instagram: internacionalizando y localizando una aplicación Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/479738/">  Python está en el centro de aplicaciones mundialmente famosas como Youtube, Instagram y Pinterest.  Para avanzar en el mercado mundial, una aplicación necesita localización, es decir, adaptación a las características de un país en particular e internacionalización: traducción de contenido.  En este artículo, compartiremos nuestra experiencia sobre cómo acelerar la automatización de la traducción y resolver algunos problemas típicos en esta área. <br><br><img src="https://habrastorage.org/webt/pj/ju/ug/pjjuugy6izlwm2of_m-qwzrkogm.jpeg"><a name="habracut"></a><br><br><h2>  Introduccion </h2><br>  Esta es una guía breve para internacionalizar las aplicaciones de Python (i18n).  Esta guía será interesante para todos los programadores con experiencia en desarrollo de Python.  Leer un artículo tomará entre 10 y 15 minutos. <br><br>  Utilizaremos la herramienta gettext bien probada incluida en el lenguaje python. <br><br>  Para empezar, entenderemos qué es la internacionalización: <br><br>  <u>La internacionalización (I18N)</u> es el proceso de adaptación de una aplicación a los idiomas de diferentes países y regiones además del idioma en el que se desarrolló. <br><br>  Pero también hay un concepto más amplio: <br><br>  <u>La localización (L10N)</u> es el proceso de adaptar una aplicación internacionalizada a una región o idioma específico mediante la adición de componentes específicos a un entorno local determinado y la traducción del texto. <br><br>  Localización significa traducción: <br><br><ul><li>  formato de fecha y hora; </li><li>  formato de número; </li><li>  zona horaria </li><li>  un calendario </li><li>  representaciones monetarias; </li><li>  impuestos / IVA; </li><li>  temperatura y otras medidas; </li><li>  códigos postales, teléfonos; </li><li>  formato de dirección; </li><li>  Código del acuerdo. </li></ul><br><img src="https://habrastorage.org/webt/qn/iu/pp/qniuppyynx8jszhbt21l9xllxuw.png"><br><br>  La localización va más allá de traducir contenido a otro idioma.  Hay parámetros culturales y funcionales que también requieren atención.  Por ejemplo, el formato de fecha en Norteamérica es MM / DD / AAAA, pero en la mayoría de los países asiáticos se escribe DD / MM / AAAA. <br><br><img src="https://habrastorage.org/webt/uf/rg/pd/ufrgpdvzppo4v91mpmwcwkoeoli.png"><br><br>  <i>Un ejemplo bien conocido de un error de traducción de la aplicación.</i> <br><br>  Otro ejemplo se refiere a la visualización de nombres en las aplicaciones.  En los Estados Unidos, llamar a alguien por su nombre es aceptable e incluso preferible, el nombre del cliente se muestra en el encabezado tan pronto como el cliente inicia sesión.  Sin embargo, en Japón sucede lo contrario: llamar a alguien por su nombre es descortés o incluso ofensivo.  La localización debe tener esto en cuenta y evitar el uso de nombres para una audiencia japonesa. <br><br>  En este artículo consideraremos solo la internacionalización, pero los mecanismos de localización se construyen de manera similar.  Las bibliotecas mencionadas en este artículo admiten la localización de aplicaciones. <br><br><h2>  Tipos principales </h2><br>  La internacionalización se divide en: <br><br><ol><li>  Traducción de datos directamente en scripts de python. </li><li>  Traducción de datos en motores de plantillas. </li><li>  Traducción de datos almacenados en una base de datos. </li></ol><br><h3>  1. Traducción de datos de script python </h3><br>  Para que nuestra internacionalización funcione, tenemos que ocuparnos de la biblioteca babel y el kit de herramientas distutils para gestionar el montaje del proyecto para la venta y más. <br><br><h4>  Preparación de traducción </h4><br>  Para empezar, necesitamos crear una lista de traducciones.  Para comenzar, instalamos la biblioteca <a href="http://babel.pocoo.org/">Babel</a> : esta es una biblioteca de Python generalmente reconocida para localizar y convertir fechas, monedas, con adiciones convenientes para construir el proyecto (discutido a continuación). <br><br>  Python proporciona un conjunto de herramientas para el multilingüismo: gettext.  GNU gettext es en realidad una solución de localización universal que proporciona soporte para otros lenguajes de programación en mensajes multilingües.  Gettext se utiliza no solo en muchos lenguajes de programación, sino también en la traducción de sistemas operativos; es un software bien probado y de distribución gratuita disponible en <a href="https://github.com/autotools-mirror/gettext">github</a> . <br><br>  Para que funcionen las traducciones, debe importar el módulo gettext y pasar los scripts con las traducciones a la entrada.  Primero, marcamos todas las cadenas traducidas con la función especial _ ('some_text').  La llamada a esta función en el proyecto se verá así: <br><br><pre><code class="php hljs">import gettext import os localedir = os.path.join(os.path.abspath(<span class="hljs-string"><span class="hljs-string">'/path/to/locales'</span></span>), <span class="hljs-string"><span class="hljs-string">'locales'</span></span>) translate = gettext.translation(<span class="hljs-string"><span class="hljs-string">'domain_name'</span></span>, localedir, [<span class="hljs-string"><span class="hljs-string">'ru'</span></span>]) _ = translate.gettext <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(_(<span class="hljs-string"><span class="hljs-string">'some_text'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(_(<span class="hljs-string"><span class="hljs-string">'some_text_2'</span></span>))</code> </pre> <br>  En un pequeño fragmento de código, cree un objeto de internacionalización que use el directorio 'locales' como fuente de frases traducidas.  El directorio 'locales' aún no se ha creado, pero es allí donde la aplicación buscará traducciones en tiempo de ejecución. <br><br>  Por brevedad, la función translate.gettext se indicará a continuación como _.  El subrayado es el nombre común para esta función, que es reconocida por la comunidad Python. <br><br>  La función _ () marca las líneas a traducir.  El módulo gettext está acompañado por la herramienta xgettext, que analiza los marcadores de cadena _ () por código y forma una plantilla de objeto portátil (archivo pot).  Para crear el archivo pot, volvamos a la biblioteca de Babel instalada, que tiene muchas características para apoyar la internacionalización.  Babel amplía el script de compilación setup.py, que puede escribirse utilizando la biblioteca estándar de python distutils o el paquete de herramientas de configuración de terceros de su elección.  El ensamblaje de los módulos Python está más allá del alcance de nuestro artículo; para más detalles, consulte la <a href="https://docs.python.org/2/distutils/introduction.html">documentación</a> .  Todo lo que se necesita es crear un archivo setup.py con el siguiente contenido: <br><br><pre> <code class="php hljs">from babel.messages import frontend <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> babel from distutils.core import setup setup(name=<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, version=<span class="hljs-string"><span class="hljs-string">'1.0'</span></span>, cmdclass = {<span class="hljs-string"><span class="hljs-string">'extract_messages'</span></span>: babel.extract_messages, <span class="hljs-string"><span class="hljs-string">'init_catalog'</span></span>: babel.init_catalog, <span class="hljs-string"><span class="hljs-string">'update_catalog'</span></span>: babel.update_catalog, <span class="hljs-string"><span class="hljs-string">'compile_catalog'</span></span>: babel.compile_catalog,} )</code> </pre> <br>  Por lo tanto, creamos instrucciones para construir el proyecto y agregamos cuatro equipos de internacionalización de la biblioteca de babel.  Considere estos comandos con más detalle en orden de uso. <br><br>  <b>mensajes_extractos</b> <br><br>  Este comando es un contenedor sobre la herramienta GNU xgettext, que analiza _ () etiquetas traducibles en un archivo pot.  Para ejecutar, necesita varias configuraciones para el ensamblaje.  Para hacer esto, en el directorio raíz, cree el archivo setup.cfg con el contenido: <br><br><pre> <code class="php hljs">[extract_messages] input_dirs = foobar output_file = foobar/locales/messages.pot</code> </pre> <br><br><ul><li>  input_dirs: el nombre del directorio desde el que se seleccionarán todas las etiquetas en el código _ () para las traducciones. </li><li>  archivo_salida: ruta del archivo .pot resultante </li></ul><br>  Para ejecutar el comando, ejecute en la consola: <br><br><pre> <code class="php hljs">$ python setup.py extract_messages</code> </pre> <br><br><pre> <code class="php hljs">running extract_messages extracting messages from foobar/__init__.py extracting messages from foobar/core.py ... writing PO template file to foobar/locales/messages.pot</code> </pre> <br>  En el archivo pot, las líneas marcadas se recopilan en una lista desde la cual los traductores pueden crear traducciones para cada uno de los idiomas deseados. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment"># SOME DESCRIPTIVE TITLE. # Copyright (C) YEAR ORGANIZATION # FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR. # msgid "" msgstr "" "Project-Id-Version: PACKAGE VERSION\n" "POT-Creation-Date: 2018-01-28 16:47+0000\n" "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n" "Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n" "Language-Team: LANGUAGE &lt;LL@li.org&gt;\n" "MIME-Version: 1.0\n" "Content-Type: text/plain; charset=UTF-8\n" "Content-Transfer-Encoding: 8bit\n" "Generated-By: pygettext.py 1.5\n" #: src/main.py:5 msgid "some_text" msgstr "" #: src/main.py:6 msgid "some_text_2" msgstr ""</span></span></code> </pre> <br>  A continuación, debe crear traducciones para varios idiomas.  Para hacer esto, use los siguientes comandos de babel. <br><br>  <b>init_catalog</b> <br><br>  Este comando es un contenedor sobre la herramienta msginit de GNU, que crea un nuevo directorio de traducción basado en el archivo pot. <br><br><pre> <code class="php hljs">$ python setup.py init_catalog -l en -i foobar/locales/messages.pot \ -o foobar/locales/en/LC_MESSAGES/base.po</code> </pre> <br><pre> <code class="php hljs">running init_catalog creating catalog <span class="hljs-string"><span class="hljs-string">'foobar/locales/en/LC_MESSAGES/messages.po'</span></span> based on <span class="hljs-string"><span class="hljs-string">'foobar/locales/messages.pot'</span></span></code> </pre> <br>  <b>Importante!</b>  Los archivos de localización se almacenan de forma específica, de acuerdo con la convención: <br><br>  locales // LC_MESSAGES / .po <br><br>  - un directorio con traducciones a un idioma específico, en nuestro caso es inglés (en).  También puede haber un directorio con traducciones no solo a un idioma específico, sino también teniendo en cuenta características adicionales.  Por ejemplo, una traducción al inglés para los Estados Unidos es en_US; <br><br>  - dominio con traducciones.  Si nuestra aplicación crece, las traducciones se dividirán en dominios para no sobrecargar un archivo. <br><br>  <b>update_catalog</b> <br><br>  Este comando es un contenedor sobre la herramienta GNU msgmerge, que actualiza los directorios de traducción existentes para archivos * .po. <br><br>  Al agregar nuevas traducciones, simplemente ejecutamos el comando: <br><br><pre> <code class="php hljs">$ python setup.py update_catalog -l en -i foobar/locales/messages.pot \ -o foobar/locales/en/LC_MESSAGES/base.po</code> </pre> <br><pre> <code class="php hljs">running update_catalog updating catalog <span class="hljs-string"><span class="hljs-string">'foobar/locales/en/LC_MESSAGES/base.po'</span></span> based on <span class="hljs-string"><span class="hljs-string">'foobar/locales/messages.pot'</span></span></code> </pre> <br>  También podemos especificar la localización en ruso especificando ru en lugar de en. <br><br>  <b>compile_catalog</b> <br><br>  El comando final es un contenedor sobre la herramienta msgfmt de GNU.  Toma mensajes traducibles de archivos * .po y los compila en archivos binarios * .mo para optimizar el rendimiento. <br><br><pre> <code class="php hljs">$ python setup.py compile_catalog --directory foobar/locales --domain base</code> </pre><br><pre> <code class="php hljs">running compile_catalog compiling catalog to foobar/locales/en/LC_MESSAGES/base.mo</code> </pre><br>  --directory - ruta al directorio con localización, <br>  --dominio - una bandera para especificar un dominio de traducción, lo especificamos de acuerdo con los dominios de aplicación existentes. <br><br>  Los scripts de Python solo funcionan con traducciones optimizadas * .mo.  Por lo tanto, con cualquier cambio, para que aparezca en la aplicación, es necesario volver a compilar los archivos con localización.  Para trabajar con archivos de traducción, puede usar la aplicación poedit: está disponible para todos los sistemas operativos y es un software de distribución gratuita. <br><br><img src="https://habrastorage.org/webt/4_/x5/iy/4_x5iyrgxqxdw_qxlucmagupbt0.png"><br><br>  <i>poedit - aplicación de traducción</i> <br><br>  Cada traducción se muestra como una línea separada, y esto es conveniente.  Al finalizar el trabajo con las traducciones, al guardar los cambios, se compila automáticamente un archivo binario * .mo con todos los cambios. <br><br>  Como resultado, la estructura de los catálogos de traducción se verá así: <br><br><pre> <code class="php hljs">locales ├── en │ └── LC_MESSAGES │ ├── base.mo │ └── base.po ├── ru │ └── LC_MESSAGES │ ├── base.mo │ └── base.po └── messages.pot</code> </pre> <br><br>  <b>Convención de nombres de marcadores de traducción</b> <br><br>  Los archivos po contienen traducciones de texto y se combinan lógicamente en un archivo con un nombre común.  Estos grupos se llaman dominios.  En el ejemplo anterior, solo hay un dominio denominado base.  En aplicaciones grandes, habrá más dominios, y las listas de traducción deben escribirse teniendo en cuenta la estructura de la aplicación. <br><br>  Es necesario mantener la uniformidad de los nombres de los tokens de traducción para eliminar más confusión en las traducciones.  Por ejemplo, tenemos un formulario para guardar datos de usuario en la página de perfil de usuario: <br><br>  <i>profile.user_form.component.title: Datos del usuario</i> <i><br></i>  <i>profile.user_form.component.save: Guardar</i> <i><br></i>  <i>profile.user_form.field.username: Nombre de usuario</i> <i><br></i>  <i>profile.user_form.field.password: Contraseña</i> <i><br></i> <br><br>  <b>Implementación de aplicaciones</b> <br><br>  Para implementar y desplegar la aplicación en Docker, debe compilar los archivos de traducción en archivos binarios * .mo con el siguiente comando: <br><br><pre> <code class="php hljs">$ python setup.py compile_catalog --domain &lt;&gt;</code> </pre> <br>  Recomendamos excluir los archivos * .mo y * .pot en .gitignore: <br><br>  <i># Traducciones</i> <i><br></i>  <i>* .mo</i> <i><br></i>  <i>* .pot</i> <br><br><h3>  2. Traducción de datos en motores de plantillas </h3><br>  Con la localización en plantillas, todo es un poco más fácil.  Considere el motor de plantillas de python más popular: jinja.  Para este motor de plantillas, el soporte para la localización de gettext a través de complementos ya está implementado.  Para activar el complemento, debe especificar la ruta al módulo del complemento en el constructor Entorno.  Para plataformas multilingües, debe descargar las traducciones una vez y agregar objetos de traducción al objeto Environment durante la inicialización de la aplicación: <br><br><pre> <code class="php hljs">translations = get_gettext_translations() env = Environment(extensions=[<span class="hljs-string"><span class="hljs-string">'jinja2.ext.i18n'</span></span>]) env.install_gettext_translations(translations)</code> </pre><br>  Luego, en las plantillas, solo usamos las construcciones: <br><br><pre> <code class="php hljs">{{ gettext(<span class="hljs-string"><span class="hljs-string">'some_text'</span></span>) }} {{ gettext(<span class="hljs-string"><span class="hljs-string">'Hello %(name)s!'</span></span>)|format(name=<span class="hljs-string"><span class="hljs-string">'World'</span></span>) }}</code> </pre> <br><h3>  3. Traducción de los datos almacenados en la base de datos. </h3><br>  Consideremos opciones para trabajar con traducciones en las bases de datos relacionales más comunes.  Cabe señalar que la implementación de traducciones y localización para las bases de datos noSQL y newSQL es similar. <br><br>  <i>Nota:</i> no consideraremos el caso cuando la traducción para cada idioma se almacene en una columna separada.  Dicha implementación conlleva limitaciones de escala y otros riesgos con un mayor soporte de aplicaciones. <br><br><h4>  1) líneas separadas para cada idioma </h4><br>  Con este enfoque, para cada idioma, la traducción a un idioma específico en las filas se basa en el valor de la columna, por ejemplo, language_code.  Si el valor en está en esta columna, todos los valores traducidos deben referirse al país y la región dados. <br><br><img src="https://habrastorage.org/webt/di/vv/b_/divvb_ulaekslblbgv98taqsncg.png"><br><br>  Para el esquema descrito, los datos en la tabla deberían verse así: <br><br><img src="https://habrastorage.org/webt/ds/kx/cx/dskxcx_ffmnvcv97yus9d10q_bq.png"><br><br>  <b>Ventajas:</b> <br><br><ul><li>  Implementación simple y eficiente. </li><li>  Consultas simples cuando se utiliza un código de idioma específico. </li></ul><br><br>  <b>Desventaja</b> <br><ul><li>  Falta de centralización. </li></ul><br>  Las traducciones a diferentes idiomas se pueden almacenar en diferentes tablas.  Por lo tanto, no sabe cuántos idiomas está traducida completamente su aplicación. <br><br>  Esta solución es adecuada para aplicaciones que inicialmente no requieren una internacionalización completa de todos los datos.  Pero es posible agregar traducciones para nuevas regiones a medida que el negocio se expande. <br><br>  La solicitud de datos será la siguiente: <br><br><pre> <code class="php hljs">SELECT p.product_name, p.price, p.description FROM product p WHERE p.language_code = @language_code;</code> </pre> <br><h3>  2) Tablas separadas con traducciones </h3><br>  En este enfoque, para cada tabla que requiere localización, creamos tablas con traducciones. <br><br><img src="https://habrastorage.org/webt/yr/_i/ro/yr_iror7tyoqltdgao6fua4ambo.png"><br><br>  <b>Pros:</b> <br><br><ul><li>  No hay necesidad de unir tablas para datos no traducidos. </li><li>  Las consultas se vuelven fáciles ya que hay tablas separadas para la traducción. </li><li>  No hay discrepancias en los datos. </li><li>  Además de las traducciones, es posible localizar efectivamente el resto de los datos en la tabla de idiomas. </li></ul><br>  <b>Desventaja</b> <br><br><ul><li>  En aplicaciones grandes, la tabla de traducción está hinchada y se ralentiza.  Al optimizar la aplicación, será necesario implementar la migración de datos en tablas separadas. </li></ul><br>  La solicitud de datos será la siguiente: <br><br><pre> <code class="php hljs">SELECT tp.text, p.price, tc.text, c.contact_name FROM order_line o, product p, customer c, translation tp, translation tc, language l WHERE o.product_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> o.customer_id = c.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> p.name_translation_id = tp.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.name_translation_id = tc.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tp.language_id = l.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tc.language_id = l.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.name = @language_code <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> o.id = ***;</code> </pre> <br><h4>  3) Crear entidades para campos traducidos y no traducidos </h4><br>  En esta solución, las tablas de entidad que contienen uno o más campos traducidos amplían los datos con los no traducidos. <br><br><img src="https://habrastorage.org/webt/ox/vv/dw/oxvvdwlufgyhcks2akl7vf5-mqk.png"><br><br>  <b>Pros:</b> <br><br><ul><li>  No es necesario combinar tablas de traducción con tablas que contienen datos que no requieren traducción.  Por lo tanto, el muestreo de dichos datos tendrá un mejor rendimiento, </li><li>  Es fácil escribir consultas ORM, </li><li>  Una simple consulta SQL para obtener texto traducido, </li><li>  Es fácil admitir la traducción de ciertos datos a todos los idiomas disponibles. </li></ul><br>  <b>Desventaja</b> <br><br><ul><li>  La relativa complejidad de la implementación. </li></ul><br>  Aquí hay un ejemplo de una consulta que recuperará el texto traducido: <br><br><pre> <code class="php hljs">SELECT pt.product_name, pt.description, p.price FROM order_line o, product p, product_translation pt, language l WHERE o.product_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> p.id = pt.product_non_trans_id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pt.language_id = l.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.name = @language_code;</code> </pre><br><h2>  Conclusiones </h2><br>  Al localizar e internacionalizar aplicaciones para el mercado internacional, se pueden utilizar varios métodos, cada uno de los cuales tiene ciertas características y limitaciones. <br><br>  En este artículo, examinamos los siguientes tipos de internacionalización: <br><br><ul><li>  <b>en código:</b> usamos traducciones al crear un servicio o aplicación con gui; </li><li>  <b>en plantillas:</b> usamos cuando desarrollamos una aplicación web sin una interfaz dinámica; </li><li>  <b>en la base de datos:</b> utilícelo al almacenar datos de usuario o generados dinámicamente. </li></ul><br>  Esperamos que nuestro artículo lo ayude a elegir el método más adecuado para su proyecto. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479738/">https://habr.com/ru/post/479738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479724/index.html">Tru hackers han terminado</a></li>
<li><a href="../479726/index.html">Vladimir también conocido como wowik: "OpenStreetMap necesita ideas que no se pueden realizar en otros sistemas"</a></li>
<li><a href="../479728/index.html">¿Cómo organizar una startup exitosa?</a></li>
<li><a href="../479732/index.html">Dejar de emitir algo más como una pérdida de memoria</a></li>
<li><a href="../479736/index.html">Cámaras o láser</a></li>
<li><a href="../479742/index.html">Patios traseros: una malla de servicios automatizada sobre una infraestructura multi-nube e híbrida</a></li>
<li><a href="../479744/index.html">Python Memory Management: un poco sobre la fragmentación de la memoria</a></li>
<li><a href="../479746/index.html">El software empresarial hace que sus empleados sean más geniales. Lo necesitas</a></li>
<li><a href="../479748/index.html">GoLand 2019.3 con rendimiento mejorado, soporte mejorado para módulos Go y más</a></li>
<li><a href="../479750/index.html">2. Fortinet Getting Started v 6.0. Arquitectura de soluciones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>