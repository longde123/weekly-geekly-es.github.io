<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ñ ü§∑üèΩ üóÑÔ∏è Tutoriel Java 9 pour ceux qui doivent travailler avec du code h√©rit√© üë®üèæ‚Äçüé® üï≥Ô∏è üë©üèø‚Äçü§ù‚Äçüë©üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonsoir, chers coll√®gues. Il y a exactement un mois, nous avons re√ßu un contrat pour la traduction de Java moderne de Manning, qui devrait √™tre l'un d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutoriel Java 9 pour ceux qui doivent travailler avec du code h√©rit√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/417733/"> Bonsoir, chers coll√®gues.  Il y a exactement un mois, nous avons re√ßu un contrat pour la traduction de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java moderne</a> de Manning, qui devrait √™tre l'un de nos nouveaux produits les plus remarquables l'ann√©e prochaine.  Le probl√®me de "Modern" et "Legacy" en Java est si aigu que le besoin d'un tel livre est assez m√ªr.  L'ampleur de la catastrophe et la mani√®re de r√©soudre les probl√®mes dans Java 9 sont bri√®vement d√©crites dans un article de Wayne Citrin, dont nous voulons vous proposer une traduction aujourd'hui. <br><a name="habracut"></a><br>  Toutes les quelques ann√©es, avec la sortie d'une nouvelle version de Java, les intervenants de JavaOne commencent √† savourer de nouvelles constructions de langage et API et louent leurs vertus.  Et les d√©veloppeurs z√©l√©s, quant √† eux, sont impatients d'introduire de nouvelles fonctionnalit√©s.  Une telle image est loin de la r√©alit√© - elle ne tient absolument pas compte du fait que la plupart des programmeurs sont occup√©s √† prendre en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">charge et √† finaliser les applications existantes</a> , et √† ne pas √©crire de nouvelles applications √† partir de z√©ro. <br><br>  La plupart des applications - en particulier les applications commerciales - doivent √™tre r√©trocompatibles avec les versions ant√©rieures de Java qui ne prennent pas en charge toutes ces nouvelles fonctionnalit√©s de super-duper.  Enfin, la plupart des clients et des utilisateurs finaux, en particulier dans le segment des grandes entreprises, se m√©fient d'une mise √† niveau radicale de la plate-forme Java, pr√©f√©rant attendre qu'elle se renforce. <br><br>  Par cons√©quent, d√®s que le d√©veloppeur va tenter une nouvelle opportunit√©, il est confront√© √† des probl√®mes.  Souhaitez-vous utiliser les m√©thodes d'interface par d√©faut dans votre code?  Peut-√™tre - si vous avez de la chance et que votre application n'a pas besoin d'interagir avec Java 7 ou une version ant√©rieure.  Vous souhaitez utiliser la classe <code>java.util.concurrent.ThreadLocalRandom</code> pour g√©n√©rer des nombres pseudo-al√©atoires dans une application multithread?  Cela ne fonctionnera pas si votre application doit s'ex√©cuter sur Java 6, 7, 8 ou 9 en m√™me temps. <br><br>  Avec la sortie de la nouvelle version, les d√©veloppeurs qui prennent en charge le code h√©rit√© se sentent comme des enfants forc√©s de regarder une vitrine de p√¢tisserie.  Ils ne sont pas autoris√©s √† l'int√©rieur, leur destin est donc la d√©ception et la frustration. <br><br>  Alors, y a-t-il quelque chose dans la nouvelle version de Java 9 pour les programmeurs impliqu√©s dans la prise en charge du code h√©rit√©?  Quelque chose qui pourrait leur faciliter la vie?  Heureusement oui. <br><br>  <b>Ce qui devait √™tre fait avec le support du code h√©rit√©, c'est l'apparition de Java 9</b> <br><br>  Bien s√ªr, vous pouvez pousser les capacit√©s de la nouvelle plate-forme dans des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">applications h√©rit√©es</a> dans lesquelles vous devez vous conformer √† la compatibilit√© descendante.  En particulier, il existe toujours des opportunit√©s pour profiter des nouvelles API.  Cependant, cela peut s'av√©rer un peu moche. <br><br>  Par exemple, vous pouvez appliquer une liaison tardive si vous souhaitez acc√©der √† la nouvelle API lorsque votre application doit √©galement fonctionner avec des versions plus anciennes de Java qui ne prennent pas en charge cette API.  Supposons que vous souhaitiez utiliser la classe <code>java.util.stream.LongStream</code> , introduite dans Java 8, et que vous souhaitiez utiliser la <code>anyMatch(LongPredicate)</code> de cette classe, mais que l'application doit √™tre compatible avec Java 7. Vous pouvez cr√©er une classe d'assistance, comme ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> classLongStreamHelper { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longStreamClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Class longPredicateClass; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Method anyMatchMethod; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { longStreamClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.stream.LongStream"</span></span>); longPredicateClass = Class.forName(<span class="hljs-string"><span class="hljs-string">"java.util.function.LongPredicate"</span></span>); anyMatchMethod = longStreamClass.getMethod(<span class="hljs-string"><span class="hljs-string">"anyMatch"</span></span>, longPredicateClass): } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ClassNotFoundException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchMethodException e) { longStreamClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; longPredicateClass = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; anyMatchMethod = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object theLongStream, Object thePredicate)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NotImplementedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (longStreamClass == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Boolean result = (Boolean) anyMatchMethod.invoke(theLongStream, thePredicate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.booleanValue(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-comment"><span class="hljs-comment">// lots of potential exceptions to handle. Let's simplify. throw new NotImplementedException(); } } }</span></span></code> </pre> <br>  Il existe des moyens de simplifier cette op√©ration, ou de la rendre plus g√©n√©rale ou plus efficace - vous avez l'id√©e. <br><br>  Au lieu d'appeler <code>theLongStream.anyMatch(thePredicate)</code> , comme vous le feriez dans Java 8, vous pouvez appeler <code>LongStreamHelper.anyMatch(theLongStream, thePredicate)</code> dans n'importe quelle version de Java.  Si vous traitez avec Java 8, cela fonctionnera, mais si avec Java 7, le programme <code>NotImplementedException</code> une <code>NotImplementedException</code> . <br><br>  Pourquoi est-ce laid?  Parce que le code peut devenir trop compliqu√© si vous devez acc√©der √† de nombreuses API (en fait, m√™me maintenant, avec une seule API, cela est d√©j√† g√™nant).  En outre, cette pratique n'est pas s√©curis√©e, car le code ne peut pas mentionner directement <code>LongStream</code> ou <code>LongPredicate</code> .  Enfin, cette pratique est beaucoup moins efficace, en raison de la surcharge de r√©flexion, ainsi que des blocs <code>try-catch</code> suppl√©mentaires.  Par cons√©quent, bien que cela puisse √™tre fait de cette fa√ßon, ce n'est pas trop int√©ressant et il est lourd d'erreurs dues √† la n√©gligence. <br><br>  Oui, vous pouvez acc√©der aux nouvelles API et votre code conserve en m√™me temps la compatibilit√© descendante, mais vous ne r√©ussirez pas avec les nouvelles constructions de langage.  Par exemple, supposons que nous devons utiliser des expressions lambda dans du code qui devraient rester r√©trocompatibles et fonctionner dans Java 7. Vous n'avez pas de chance.  Le compilateur Java ne vous permettra pas de sp√©cifier une version du code source au-dessus de la cible.  Donc, si vous d√©finissez le niveau de conformit√© du code source sur 1,8 (c'est-√†-dire Java 8) et que le niveau de conformit√© cible est 1,7 (Java 7), le compilateur ne vous le permettra pas. <br><br>  <b>Les fichiers JAR multi-versions vous aideront</b> <br><br>  Plus r√©cemment, une autre grande opportunit√© est apparue d'utiliser les derni√®res fonctionnalit√©s Java, tout en permettant aux applications de fonctionner avec les anciennes versions de Java, o√π ces applications n'√©taient pas prises en charge.  Dans Java 9, cette fonctionnalit√© est fournie √† la fois pour les nouvelles API et les nouvelles constructions de langage Java: nous parlons de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichiers JAR multi-versions</a> . <br><br>  Les fichiers JAR multi-versions sont presque les m√™mes que les bons vieux fichiers JAR, mais avec une mise en garde importante: une nouvelle ¬´niche¬ª est apparue dans les nouveaux fichiers JAR, o√π vous pouvez √©crire des classes qui utilisent les derni√®res fonctionnalit√©s de Java 9. Si vous travaillez avec Java 9, alors La JVM trouvera ce "cr√©neau", en utilisera les classes et ignorera les classes du m√™me nom de la partie principale du fichier JAR. <br><br>  Cependant, lorsqu'elle travaille avec Java 8 ou une version ant√©rieure, la JVM n'est pas consciente de l'existence de cette ¬´niche¬ª.  Elle l'ignore et utilise les classes de la partie principale du fichier JAR.  Avec la sortie de Java 10, une nouvelle ¬´niche¬ª similaire appara√Ætra pour les classes qui utilisent les fonctionnalit√©s les plus pertinentes de Java 10 et ainsi de suite. <br><br>  Dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 238</a> , une proposition de d√©veloppement Java, qui d√©crit des fichiers JAR voraces, un exemple simple est fourni.  Disons que nous avons un fichier JAR avec quatre classes fonctionnant en Java 8 ou inf√©rieur: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class</code> </pre> <br>  Imaginez maintenant qu'apr√®s la sortie de Java 9, nous r√©√©crivions les classes A et B afin qu'elles puissent utiliser les nouvelles fonctionnalit√©s sp√©cifiques √† Java 9. Ensuite, Java 10 sort, et nous r√©√©crivons la classe A afin qu'il puisse utiliser les nouvelles fonctionnalit√©s de Java 10. , l'application devrait toujours fonctionner correctement avec Java 8. Le nouveau fichier JAR multi-version ressemble √† ceci: <br><br><pre> <code class="java hljs">JAR root - A.class - B.class - C.class - D.class - META-INF Versions - <span class="hljs-number"><span class="hljs-number">9</span></span> - A.class - B.class - <span class="hljs-number"><span class="hljs-number">10</span></span> - A.class</code> </pre> <br>  Le fichier JAR n'a pas seulement acquis une nouvelle structure;  maintenant dans son manifeste, il est indiqu√© que ce fichier est multi-versionn√©. <br><br>  Lorsque vous ex√©cutez ce fichier JAR dans la machine virtuelle Java 8, il ignore la section <code>\META-INF\Versions</code> car il ne le soup√ßonne m√™me pas ou ne le recherche pas.  Seules les classes d'origine A, B, C et D sont utilis√©es. <br><br>  Lors de l'ex√©cution sous Java 9, les classes situ√©es dans <code>\META-INF\Versions\9</code> sont utilis√©es, en outre, elles sont utilis√©es √† la place des classes d'origine A et B, mais les classes dans <code>\META-INF\Versions\10</code> ignor√©es. <br><br>  Lors de l'ex√©cution sous Java 10, les deux branches <code>\META-INF\Versions</code> ;  en particulier, la version A de Java 10, la version B de Java 9 et les versions par d√©faut C et D. <br><br>  Donc, si dans votre application vous avez besoin de la nouvelle API ProcessBuilder de Java 9, mais vous devez vous assurer que l'application continue de fonctionner sous Java 8, √©crivez simplement les nouvelles versions de vos classes √† l'aide de ProcessBuilder dans la section <code>\META-INF\Versions\9</code> du fichier JAR et laissez les anciennes classes dans la partie principale de l'archive, utilis√©es par d√©faut.  C'est le moyen le plus simple d'utiliser les nouvelles fonctionnalit√©s de Java 9 sans sacrifier la compatibilit√© descendante. <br><br>  Java 9 JDK poss√®de une version de l'outil jar.exe qui prend en charge la cr√©ation de fichiers JAR multi-versions.  D'autres outils non JDK fournissent √©galement ce support. <br><br>  <b>Java 9: ‚Äã‚Äãmodules, modules partout</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le syst√®me de modules Java 9</a> (√©galement connu sous le nom de Project Jigsaw) est sans aucun doute le plus grand changement de Java 9. L'un des objectifs de la modularisation est de renforcer le m√©canisme d'encapsulation de Java afin que le d√©veloppeur puisse sp√©cifier quelles API sont fournies aux autres composants et compter, que la JVM appliquera l'encapsulation.  L'encapsulation est plus puissante avec la modularisation qu'avec <code>public/protected/private</code> modificateurs d'acc√®s <code>public/protected/private</code> pour les classes ou les membres de classe. <br><br>  Le deuxi√®me objectif de la modularisation est d'indiquer quels modules ont besoin d'autres modules pour fonctionner, et avant de d√©marrer l'application, assurez-vous que tous les modules n√©cessaires sont en place.  En ce sens, les modules sont plus forts que le m√©canisme de chemin de classe traditionnel, car les chemins de chemin de classe ne sont pas v√©rifi√©s √† l'avance et des erreurs sont possibles en raison du manque de classes n√©cessaires.  Ainsi, un chemin de classe incorrect peut d√©j√† √™tre d√©tect√© lorsque l'application a le temps de fonctionner suffisamment longtemps ou apr√®s avoir √©t√© lanc√©e plusieurs fois. <br>  L'ensemble du syst√®me de modules est vaste et complexe, et une discussion d√©taill√©e √† ce sujet d√©passe le cadre de cet article (voici une bonne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">explication d√©taill√©e</a> ).  Ici, je pr√™terai attention aux aspects de la modularisation qui aident le d√©veloppeur √† prendre en charge les applications h√©rit√©es. <br><br>  La modularisation est une bonne chose, et le d√©veloppeur devrait essayer de diviser le nouveau code en modules chaque fois que possible, m√™me si le reste de l'application est (pas encore) modularis√©.  Heureusement, cela est facile √† faire gr√¢ce aux sp√©cifications pour travailler avec des modules. <br><br>  Tout d'abord, le fichier JAR devient modularis√© (et se transforme en module) avec l'apparition du fichier module-info.class (compil√© √† partir de module-info.java) √† la racine du fichier JAR.  <code>module-info.java</code> contient des m√©tadonn√©es, en particulier le nom du module dont les packages sont export√©s (c'est-√†-dire qui deviennent visibles de l'ext√©rieur), les modules dont ce module a besoin et d'autres informations. <br><br>  Les informations contenues dans <code>module-info.class</code> sont visibles que lorsque la machine <code>module-info.class</code> les recherche - c'est-√†-dire que le syst√®me traite les fichiers JAR modulaires comme d'habitude s'il fonctionne avec des versions plus anciennes de Java (on suppose que le code a √©t√© compil√© pour fonctionner avec une version plus ancienne de Java √Ä proprement parler, cela prend un peu de chimie, et c'est toujours Java 9 qui est sp√©cifi√© comme la version cible de module-info.class, mais c'est r√©el). <br><br>  Ainsi, vous devriez pouvoir ex√©cuter des fichiers JAR modularis√©s avec Java 8 et versions ult√©rieures, √† condition qu'√† d'autres √©gards, ils soient √©galement compatibles avec les versions ant√©rieures de Java.  Notez √©galement que les <code>module-info.class</code> peuvent, avec des r√©serves, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√™tre plac√©s dans des zones versionn√©es de fichiers JAR multi-versions</a> . <br><br>  Dans Java 9, il existe √† la fois un chemin de classe et un chemin de module.  et un chemin de module.  Classpath fonctionne comme d'habitude.  Si vous placez un fichier JAR modularis√© dans un chemin de classe, il est gaspill√© comme tout autre fichier JAR.  Autrement dit, si vous avez modularis√© le fichier JAR et que votre application n'est pas encore pr√™te √† le traiter comme un module, vous pouvez le placer dans le chemin de classe, cela fonctionnera comme toujours.  Votre code h√©rit√© devrait le g√©rer avec succ√®s. <br><br>  Notez √©galement que la collection de tous les fichiers JAR dans le chemin de classe est consid√©r√©e comme faisant partie d'un seul module sans nom.  Un tel module est consid√©r√© comme le plus courant, cependant, il exporte toutes les informations vers d'autres modules et peut faire r√©f√©rence √† n'importe quel autre module.  Ainsi, si vous ne disposez pas encore d'une application Java modularis√©e, mais qu'il existe certaines anciennes biblioth√®ques qui ne sont pas non plus modularis√©es (et ne le seront probablement jamais) - vous pouvez simplement placer toutes ces biblioth√®ques dans le chemin de classe, et l'ensemble du syst√®me fonctionnera correctement. <br><br>  Java 9 a un chemin de module qui fonctionne avec le chemin de classe.  Lors de l'utilisation de modules √† partir de ce chemin, la JVM peut v√©rifier (√† la fois au moment de la compilation et au moment de l'ex√©cution) si tous les modules n√©cessaires sont en place et signaler une erreur si des modules manquent.  Tous les fichiers JAR du chemin de classe, en tant que membres d'un module sans nom, sont accessibles aux modules r√©pertori√©s dans le chemin modulaire - et vice versa. <br><br>  Il n'est pas difficile de transf√©rer le fichier JAR du chemin de classe vers le chemin du module - et de profiter pleinement de la modularisation.  Tout d'abord, vous pouvez ajouter le fichier <code>module-info.class</code> fichier JAR, puis placer le fichier JAR modularis√© dans le chemin des modules.  Un tel module nouvellement cr√©√© pourra toujours acc√©der √† tous les fichiers JAR restants dans le JAR classpath, car ils entrent dans le module sans nom et restent en acc√®s. <br><br>  Il est √©galement possible que vous ne souhaitiez pas moduler le fichier JAR ou que le fichier JAR ne vous appartienne pas, mais √† quelqu'un d'autre, vous ne pouvez donc pas le moduler vous-m√™me.  Dans ce cas, le fichier JAR peut toujours √™tre plac√© dans le chemin du module, il deviendra un module automatique. <br><br>  Un module automatique est consid√©r√© comme un module, m√™me s'il n'a pas de <code>module-info.class</code> .  Ce module porte le m√™me nom que le fichier JAR qu'il contient et d'autres modules peuvent le demander explicitement.  Il exporte automatiquement toutes ses API accessibles au public et lit (c'est-√†-dire, n√©cessite) tous les autres modules nomm√©s ainsi que les modules sans nom. <br><br>  Ainsi, un fichier JAR non modulaire d'un chemin de classe peut √™tre transform√© en module sans rien faire du tout.  Les fichiers JAR h√©rit√©s sont automatiquement convertis en modules, il leur manque juste quelques informations qui d√©termineraient si tous les modules n√©cessaires sont en place, ou d√©terminer ce qui manque. <br><br>  Tous les fichiers JAR non modularis√©s ne peuvent pas √™tre d√©plac√©s vers le chemin du module et transform√©s en module automatique.  Il existe une r√®gle: un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package peut faire partie d'un seul module nomm√©</a> .  Autrement dit, si un package se trouve dans plusieurs fichiers JAR, alors un seul fichier JAR avec ce package dans la composition peut √™tre transform√© en module automatique.  Le reste peut rester dans le chemin de classe et rejoindre le module sans nom. <br><br>  √Ä premi√®re vue, le m√©canisme d√©crit ici semble compliqu√©, mais en pratique il est tr√®s simple.  En fait, dans ce cas, vous pouvez simplement laisser les anciens fichiers JAR dans le chemin de classe ou les d√©placer vers le chemin du module.  Vous pouvez les diviser en modules ou non.  Et lorsque vos anciens fichiers JAR sont modularis√©s, vous pouvez les laisser dans le chemin de classe ou les d√©placer vers le chemin du module. <br><br>  Dans la plupart des cas, tout devrait simplement fonctionner, comme auparavant.  Vos fichiers JAR h√©rit√©s devraient prendre racine dans le nouveau syst√®me modulaire.  Plus vous modulez le code, plus vous devez v√©rifier les informations de d√©pendance, et les modules et les API manquants seront d√©tect√©s √† des stades de d√©veloppement beaucoup plus anciens et vous feront probablement √©conomiser beaucoup de travail. <br><br>  <b>Java 9 ¬´faites-le vous-m√™me¬ª: JDK et Jlink modulaires</b> <br><br>  L'un des probl√®mes des applications Java h√©rit√©es est que l'utilisateur final peut ne pas travailler avec un environnement Java appropri√©.  Une fa√ßon de garantir l'int√©grit√© d'une application Java consiste √† fournir un runtime avec l'application.  Java vous permet de cr√©er des JRE priv√©s (redistribuables) qui peuvent √™tre distribu√©s dans l'application.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> comment cr√©er un JRE priv√©.  En r√®gle g√©n√©rale, la hi√©rarchie de fichiers JRE est prise, qui est install√©e avec le JDK, les fichiers n√©cessaires sont enregistr√©s et les fichiers facultatifs avec les fonctionnalit√©s qui peuvent √™tre n√©cessaires dans votre application sont enregistr√©s. <br><br>  Le processus est un peu g√™nant: vous devez maintenir une hi√©rarchie des fichiers d'installation, tout en √©tant prudent, afin de ne pas manquer un seul fichier, pas un seul r√©pertoire.  Cela en soi ne fera pas de mal, cependant, vous voulez toujours vous d√©barrasser de tout ce qui est superflu, car ces fichiers prennent de la place.  Oui, il est facile de c√©der et de commettre une telle erreur. <br><br>  Alors pourquoi ne pas d√©l√©guer ce travail au JDK? <br><br>  Dans Java 9, vous pouvez cr√©er un environnement autonome qui est ajout√© √† l'application - et dans cet environnement, il y aura tout le n√©cessaire pour que l'application fonctionne.  Vous n'avez plus √† vous soucier du fait que l'ordinateur de l'utilisateur aura le mauvais environnement pour ex√©cuter Java, vous n'avez pas √† vous inqui√©ter du fait que vous avez vous-m√™me mal construit un JRE priv√©. <br><br>  Une ressource cl√© pour cr√©er de telles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">images ex√©cutables autonomes</a> est un syst√®me modulaire.  Vous pouvez d√©sormais modulariser non seulement votre propre code, mais √©galement le JDK Java 9 lui-m√™me.  Maintenant, la biblioth√®que de classes Java est une collection de modules, et les outils JDK sont √©galement constitu√©s de modules.  Le syst√®me de modules vous oblige √† sp√©cifier les modules de classe de base n√©cessaires dans votre code et vous sp√©cifiez les √©l√©ments JDK n√©cessaires. <br><br>  Pour tout rassembler, Java 9 fournit un nouvel outil sp√©cial appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jlink</a> .  En lan√ßant jlink, vous obtenez une hi√©rarchie de fichiers - exactement ceux dont vous avez besoin pour ex√©cuter votre application, ni plus, ni moins.  Un tel ensemble sera beaucoup plus petit que le JRE standard, de plus, il sera sp√©cifique √† la plate-forme (c'est-√†-dire qu'il sera s√©lectionn√© pour un syst√®me d'exploitation et une machine sp√©cifiques).  Par cons√©quent, si vous souhaitez cr√©er de telles images ex√©cutables pour d'autres plates-formes, vous devrez ex√©cuter jlink dans le contexte de l'installation sur chaque plate-forme sp√©cifique pour laquelle vous avez besoin d'une telle image. <br><br>  Notez √©galement: si vous ex√©cutez jlink avec une application dans laquelle rien n'est modularis√©, l'outil ne dispose tout simplement pas des informations n√©cessaires pour compresser le JRE, de sorte que jlink n'aura plus qu'√† emballer l'ensemble du JRE.  M√™me dans ce cas, cela sera un peu plus pratique pour vous: jlink emballera le JRE pour vous, vous ne pouvez donc pas vous soucier de la fa√ßon de copier correctement la hi√©rarchie des fichiers. <br><br>  Avec jlink, il devient facile d'emballer l'application et tout ce dont vous avez besoin pour l'ex√©cuter - et vous n'avez pas √† vous inqui√©ter de faire quelque chose de mal.  L'outil ne conditionnera que la partie du runtime n√©cessaire au fonctionnement de l'application.  Autrement dit, une application Java h√©rit√©e est garantie de recevoir un environnement dans lequel elle sera op√©rationnelle. <br><br>  <b>La rencontre de l'ancien et du nouveau</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des probl√®mes qui se posent lors de la prise en charge d'une application Java h√©rit√©e est que vous √™tes priv√© de tous les avantages qui apparaissent lors de la sortie d'une nouvelle version. </font><font style="vertical-align: inherit;">Dans Java 9, comme dans les versions pr√©c√©dentes, tout un tas de nouvelles API et fonctionnalit√©s de langage sont apparues, mais les d√©veloppeurs (enseign√©s par une exp√©rience am√®re) peuvent supposer qu'ils ne pourront tout simplement pas les utiliser sans rompre la compatibilit√© avec les versions ant√©rieures de Java. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons rendre hommage aux concepteurs de Java 9: ‚Äã‚Äãapparemment, ils en ont tenu compte et ont fait du bon travail pour fournir ces nouvelles fonctionnalit√©s aux d√©veloppeurs qui doivent prendre en charge les anciennes versions de Java.</font></font><br><br>  JAR-      Java 9       JAR-,     Java   .  ,      Java 9,     Java 8        ‚Äì     . <br><br>   Java,    ,     JAR-   ,     .   ,             ,  ¬´  ¬ª   . <br><br>   JDK  jlink,             ,       .       ,    Java    ‚Äì    . <br><br>      Java,  Java 9       ,             ‚Äì       ,   ,          Java. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417733/">https://habr.com/ru/post/fr417733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417721/index.html">Les GPU pour r√©soudre les probl√®mes informatiques modernes</a></li>
<li><a href="../fr417723/index.html">Utilisation de l'API KOMPAS-3D ‚Üí Le√ßon 11 ‚Üí √âtiquettes de texte simples</a></li>
<li><a href="../fr417725/index.html">Comment Flant embauche des employ√©s</a></li>
<li><a href="../fr417729/index.html">Intel Core i7-8086K (partie 2)</a></li>
<li><a href="../fr417731/index.html">L'histoire d'un T61</a></li>
<li><a href="../fr417735/index.html">Infrastructure de cl√© publique: jetons GnuPG / SMIME et PKCS # 11 avec prise en charge de la cryptographie russe</a></li>
<li><a href="../fr417737/index.html">√áa y est, notre √©t√©</a></li>
<li><a href="../fr417739/index.html">Apprentissage automatique contre le risque de cr√©dit, ou "Come on, Gini, Come On"</a></li>
<li><a href="../fr417741/index.html">27 juillet 2018 - √©clipse lunaire totale et grande confrontation de Mars</a></li>
<li><a href="../fr417743/index.html">Amplificateurs l√©gendaires - Anatomie de la tendance historique: son du transistor froid</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>