<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍋 👨‍⚖️ 💛 《巫师3》渲染的逆向工程 🗨️ 👴🏻 🤵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="翻译的第一部分在这里 。 在这一部分中，我们将讨论锐度，平均亮度，月相和降雨期间大气现象的影响。 

 第6部分。 
 在这一部分中，我们将仔细研究The Witcher 3-Sharpen的另一个后期处理效果。 

 锐化使输出图像更锐利。 我们从Photoshop和其他图形编辑器中就知道了这种效...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>《巫师3》渲染的逆向工程</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437100/"> 翻译的第一部分在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 在这一部分中，我们将讨论锐度，平均亮度，月相和降雨期间大气现象的影响。 <br><br><h2> 第6部分。 </h2><br> 在这一部分中，我们将仔细研究The Witcher 3-Sharpen的另一个后期处理效果。 <br><br> 锐化使输出图像更锐利。 我们从Photoshop和其他图形编辑器中就知道了这种效果。 <br><br> 在《巫师3》中，锐化有两个选项：低和高。 我将在下面讨论它们之间的区别，但现在让我们看一下屏幕截图： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/285/1fc/6bc/2851fc6bc19e39660e0307f2775b0322.png" alt="图片"></div><br>  <i>选项“低”-最高</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/cd4/4cd/dc2cd44cd83306f2c08bbf7f87831d8c.png" alt="图片"></div><br>  <i>选项“低”-之后</i> <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aad/807/2aa/aad8072aa3977f32549856c0be24206b.png"></div><br>  <i>高选项-最高</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b87/3ce/0f3/b873ce0f320a785f4fb4bc83e9a696f5.png"></div><br>  <i>选项“高”-之后</i> <br><br> 如果要查看更详细的（交互式）比较，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《 Nvidia The Witcher 3性能指南》中的部分</a> 。 如您所见，这种效果在草和树叶上尤为明显。 <br><br> 在这篇文章的这一部分中，我们将从游戏一开始就研究框架：我故意选择它，因为在这里我们看到了浮雕（长绘图距离）和天空穹顶。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/898/e97/895/898e9789593705231157a07ebcf34f5e.png"></div><br> 在输入方面，锐化需要颜色缓冲区<b>t0</b> （色调校正和镜头光晕后的LDR）和深度缓冲区<b>t1</b> 。 <br><br> 让我们检查一下像素着色器的汇编代码： <br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb3[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_input_ps_siv v0.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 7 <br> 0: ftoi r0.xy, v0.xyxx <br> 1: mov r0.zw, l(0, 0, 0, 0) <br> 2: ld_indexable(texture2d)(float,float,float,float) r0.x, r0.xyzw, t1.xyzw <br> 3: mad r0.x, r0.x, cb12[22].x, cb12[22].y <br> 4: mad r0.y, r0.x, cb12[21].x, cb12[21].y <br> 5: max r0.y, r0.y, l(0.000100) <br> 6: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 7: mad_sat r0.y, r0.y, cb3[1].z, cb3[1].w <br> 8: add r0.z, -cb3[1].x, cb3[1].y <br> 9: mad r0.y, r0.y, r0.z, cb3[1].x <br> 10: add r0.y, r0.y, l(1.000000) <br> 11: ge r0.x, r0.x, l(1.000000) <br> 12: movc r0.x, r0.x, l(0), l(1.000000) <br> 13: mul r0.z, r0.x, r0.y <br> 14: round_z r1.xy, v0.xyxx <br> 15: add r1.xy, r1.xyxx, l(0.500000, 0.500000, 0.000000, 0.000000) <br> 16: div r1.xy, r1.xyxx, cb3[0].zwzz <br> 17: sample_l(texture2d)(float,float,float,float) r2.xyz, r1.xyxx, t0.xyzw, s0, l(0) <br> 18: lt r0.z, l(0), r0.z <br> 19: if_nz r0.z <br> 20: div r3.xy, l(0.500000, 0.500000, 0.000000, 0.000000), cb3[0].zwzz <br> 21: add r0.zw, r1.xxxy, -r3.xxxy <br> 22: sample_l(texture2d)(float,float,float,float) r4.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 23: mov r3.zw, -r3.xxxy <br> 24: add r5.xyzw, r1.xyxy, r3.zyxw <br> 25: sample_l(texture2d)(float,float,float,float) r6.xyz, r5.xyxx, t0.xyzw, s0, l(0) <br> 26: add r4.xyz, r4.xyzx, r6.xyzx <br> 27: sample_l(texture2d)(float,float,float,float) r5.xyz, r5.zwzz, t0.xyzw, s0, l(0) <br> 28: add r4.xyz, r4.xyzx, r5.xyzx <br> 29: add r0.zw, r1.xxxy, r3.xxxy <br> 30: sample_l(texture2d)(float,float,float,float) r1.xyz, r0.zwzz, t0.xyzw, s0, l(0) <br> 31: add r1.xyz, r1.xyzx, r4.xyzx <br> 32: mul r3.xyz, r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000) <br> 33: mad r1.xyz, -r1.xyzx, l(0.250000, 0.250000, 0.250000, 0.000000), r2.xyzx <br> 34: max r0.z, abs(r1.z), abs(r1.y) <br> 35: max r0.z, r0.z, abs(r1.x) <br> 36: mad_sat r0.z, r0.z, cb3[2].x, cb3[2].y <br> 37: mad r0.x, r0.y, r0.x, l(-1.000000) <br> 38: mad r0.x, r0.z, r0.x, l(1.000000) <br> 39: dp3 r0.y, l(0.212600, 0.715200, 0.072200, 0.000000), r2.xyzx <br> 40: dp3 r0.z, l(0.212600, 0.715200, 0.072200, 0.000000), r3.xyzx <br> 41: max r0.w, r0.y, l(0.000100) <br> 42: div r1.xyz, r2.xyzx, r0.wwww <br> 43: add r0.y, -r0.z, r0.y <br> 44: mad r0.x, r0.x, r0.y, r0.z <br> 45: max r0.x, r0.x, l(0) <br> 46: mul r2.xyz, r0.xxxx, r1.xyzx <br> 47: endif <br> 48: mov o0.xyz, r2.xyzx <br> 49: mov o0.w, l(1.000000) <br> 50: ret</code> <br> <br>  50行汇编程序代码看起来像是一个可行的任务。 让我们开始解决它。 <br><br><h3> 提升价值创造 </h3><br> 第一步是加载深度缓冲区（第1行）。 值得注意的是，“巫师3”使用的是倒置深度（1.0-接近，0.0-接近）。 如您所知，硬件深度是非线性关联的（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关详细信息，</a>请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a> ）。 <br><br> 第3-6行提供了一种非常有趣的方式来将此硬件深度[1.0-0.0]与[near-far]值相关联（我们将它们设置在MatrixPerspectiveFov阶段）。 考虑常量缓冲区中的值： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/636/345/52a/63634552ae9daf03f14305c118cccc25.png"></div><br> 具有“关闭”值0.2和“远”值5000，我们可以计算出cb12_v21.xy的值，如下所示： <br><br> <code>cb12_v21.y = 1.0 / near <br> cb12_v21.x = - (1.0 / near) + (1.0 / near) * (near / far)</code> <br> <br> 这段代码在TW3着色器中很常见，因此我认为它只是一个函数。 <br><br> 在获得“可见性金字塔的深度”之后，第7行使用比例尺/变形来创建插值系数（此处，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">saturate</a>将值限制为区间[0-1]）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/efd/571/e89efd5711cb2aa1a3c544e9deda9321.png"></div><br>  cb3_v1.xy和cb3_v2.xy-这是近距离和远距离锐化效果的亮度。 我们称它们为SharpenNear和SharpenFar。 这是《巫师3》中此效果的“低”和“高”选项之间的唯一区别。 <br><br> 现在该使用所得比率了。 第8-9行<code>lerp(sharpenNear, sharpenFar, interpolationCoeff)</code> 。 这是为了什么 由于这一点，我们在Geralt附近和远离他的地方获得了不同的亮度。 看一下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/646/233/515/6462335151728759f236b58f14b894dd.png"></div><br> 也许这几乎没有引起注意，但是在这里我们根据距离对插值进行了插值，即靠近播放器的锐化亮度（2.177151），效果亮度非常远（1.91303）。 计算之后，我们将亮度加1.0（第10行）。 为什么需要这个？ 假设上面显示的操作lerp给我们0.0。 添加1.0之后，我们自然会得到1.0，并且该值在锐化时不会影响像素。 在下面阅读有关此内容的更多信息。 <br><br> 在锐化时，我们不想影响天空。 这可以通过添加简单的条件检查来实现： <br><br> <code>//   sharpen   <br> float fSkyboxTest = (fDepth &gt;= 1.0) ? 0 : 1;</code> <br> <br> 在《巫师3》中，天空的像素深度值为1.0，因此我们使用它来获得一种“二进制过滤器”（一个有趣的事实：在这种情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">步骤</a>将无法正常工作）。 <br><br> 现在我们可以将插值的亮度乘以“天空滤镜”： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63c/ed1/f50/63ced1f5036d9ee63cfe54de6a501bc1.png"></div><br> 此乘法在第13行执行。 <br><br> 着色器代码示例： <br><br> <code>//    sharpen <br> float fSharpenAmount = fSharpenIntensity * fSkyboxTest;</code> <br> <br><h3> 像素采样中心 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SV_Position</a>有一个很重要的方面： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">半像素偏移量</a> 。 事实证明，就SV_Position.xy而言，左上角（0，0）的此像素的坐标不是（0，0），而是（0.5，0.5）。 哇！ <br><br> 这里我们要在像素的中心进行采样，因此让我们看一下第14-16行。 您可以用HLSL编写它们： <br><br> <code>//   . <br> //   ""   SV_Position.xy. <br> float2 uvCenter = trunc( Input.Position.xy ); <br> <br> //   ,       <br> uvCenter += float2(0.5, 0.5); <br> uvCenter /= g_Viewport.xy</code> <br> <br> 然后，我们从texcoords“ uvCenter”中采样输入的颜色纹理。 不用担心，采样结果将与“常规”方法（SV_Position.xy / ViewportSize.xy）相同。 <br><br><h3> 锐化或不锐化 </h3><br> 是否使用锐化的决定取决于fSharpenAmount。 <br><br> <code>//     <br> float3 colorCenter = TexColorBuffer.SampleLevel( samplerLinearClamp, uvCenter, 0 ).rgb; <br> <br> //   <br> float3 finalColor = colorCenter; <br> <br> if ( fSharpenAmount &gt; 0 ) <br> { <br> //   sharpening... <br> } <br> <br> return float4( finalColor, 1 );</code> <br> <br><h3> 锐化 </h3><br> 现在是时候看看算法本身的内部了。 <br><br> 本质上，它执行以下操作： <br><br>  -在像素的四角对输入颜色纹理进行四倍采样， <br><br>  -添加样本并计算平均值， <br><br>  -计算“中心”和“ cornerAverage”之间的差， <br><br>  -找到差异的最大绝对成分， <br><br>  -更正最大值 腹肌 使用比例+偏差值的组件， <br><br>  -使用最大值确定效果的大小。 腹肌 组成部分 <br><br>  -计算“ centerColor”和“ averageColor”的亮度值（亮度）， <br><br>  -将colorCenter划分为亮度 <br><br>  -根据效果的大小计算一个新的内插亮度值， <br><br>  -将colorCenter乘以新的亮度值。 <br><br> 大量的工作，我很难弄清楚，因为我从未尝试过锐化滤镜。 <br><br> 让我们从采样模式开始。 如您在汇编代码中所见，执行了四个纹理读取。 <br><br> 最好以像素图像为例（艺术家的技术水平是<i>专家</i> ）来展示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e3/d46/5fa/5e3d465fadc0bccd551256c40c6e5368.png"></div><br> 着色器中的所有读取均使用双线性采样（D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT）。 <br><br> 从中心到每个角度的偏移量为（±0.5，±0.5），具体取决于角度。 <br><br> 看看如何在HLSL上实现？ 让我们看看： <br><br> <code>float2 uvCorner; <br> float2 uvOffset = float2( 0.5, 0.5 ) / g_Viewport.xy; // remember about division! <br> <br> float3 colorCorners = 0; <br> <br> //    <br> // -0,5, -0.5 <br> uvCorner = uvCenter - uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, -0.5 <br> uvCorner = uvCenter + float2(uvOffset.x, -uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // -0.5, +0.5 <br> uvCorner = uvCenter + float2(-uvOffset.x, uvOffset.y); <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb; <br> <br> //    <br> // +0.5, +0.5 <br> uvCorner = uvCenter + uvOffset; <br> colorCorners += TexColorBuffer.SampleLevel( samplerLinearClamp, uvCorner, 0 ).rgb;</code> <br> <br> 因此，现在所有四个样本都汇总在“ colorCorners”变量中。 让我们按照以下步骤操作： <br><br> <code>//     <br> float3 averageColorCorners = colorCorners / 4.0; <br> <br> //    <br> float3 diffColor = colorCenter - averageColorCorners; <br> <br> //  . . RGB-  <br> float fDiffColorMaxComponent = max( abs(diffColor.x), max( abs(diffColor.y), abs(diffColor.z) ) ); <br> <br> //    <br> float fDiffColorMaxComponentScaled = saturate( fDiffColorMaxComponent * sharpenLumScale + sharpenLumBias ); <br> <br> //     . <br> //   "1.0" -      fSharpenIntensity  1.0. <br> float fPixelSharpenAmount = lerp(1.0, fSharpenAmount, fDiffColorMaxComponentScaled); <br> <br> //   ""     . <br> float lumaCenter = dot( LUMINANCE_RGB, finalColor ); <br> float lumaCornersAverage = dot( LUMINANCE_RGB, averageColorCorners ); <br> <br> //  "centerColor"    <br> float3 fColorBalanced = colorCenter / max( lumaCenter, 1e-4 ); <br> <br> //    <br> float fPixelLuminance = lerp(lumaCornersAverage, lumaCenter, fPixelSharpenAmount); <br> <br> //     <br> finalColor = fColorBalanced * max(fPixelLuminance, 0.0); <br> } <br> <br> return float4(finalColor, 1.0);</code> <br> <br> 通过计算最大值来执行边缘识别。 腹肌 差异成分。 聪明的举动！ 查看其可视化效果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/a26/44a/aa9a2644a16b1b79c6213f7d4effe068.jpg"></div><br>  <i>可视化最大差异绝对值。</i> <br><br> 太好了 成品HLSL着色器可<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处获得</a> 。 抱歉，格式化效果很差。 您可以使用我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HLSLexplorer</a>程序并尝试该代码。 <br><br> 我可以高兴地说，上面的代码创建的代码与游戏中的代码相同！ <br><br> 总结一下：Witcher 3锐度着色器的编写非常好（请注意fPixelSharpenAmount大于1.0！这很有趣...）。 另外，改变效果亮度的主要方法是近/远物体的亮度。 在这个游戏中，它们不是常数。 我已经编译了几个值的示例： <br><br> 骷髅： <br><br><table><tbody><tr><th></th><th> 在附近锐化 </th><th> 锐化远 </th><th>  sharpenDistanceScale </th><th> 锐化距离偏差 </th><th>  SharpenLumScale </th><th> 锐化 </th></tr><tr><td>  <b>低</b> </td></tr></tbody><tbody><tr><td>  <b>高</b> </td><td>  2.0 </td><td>  1.8 </td><td>  0.025 <br></td><td>  -0.25 <br></td><td>  -13.33333 <br></td><td>  1.33333 </td></tr></tbody></table><br>  Kaer Morhen： <br><br><table><tbody><tr><th></th><th> 在附近锐化 <br></th><th> 锐化远 <br></th><th>  sharpenDistanceScale <br></th><th> 锐化距离偏差 <br></th><th>  SharpenLumScale <br></th><th> 锐化 <br></th></tr><tr><td> 低 <br></td><td>  0.57751 <br></td><td>  0.31303 <br></td><td>  0.06665 <br></td><td>  -0.33256 <br></td><td>  -1.0 <br></td><td>  2.0 <br></td></tr><tr><td> 高 <br></td><td>  2.17751 <br></td><td>  1.91303 <br></td><td>  0.06665 <br></td><td>  -0.33256 <br></td><td>  -1.0 <br></td><td>  2.0 </td></tr></tbody></table><br><h2> 第7部分。平均亮度 </h2><br> 几乎在任何现代视频游戏中都可以找到计算当前帧的平均亮度的操作。 此值通常在以后用于眼睛适应和色调校正的效果（请参阅文章的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上半部分</a> ）。 在简单的解决方案中，将亮度计算用于（例如）纹理512 <sup>2</sup> ，然后计算其mip级别并应用后者。 这通常可行，但是极大地限制了可能性。 更复杂的解决方案使用计算着色器执行例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并行约简</a> 。 <br><br> 让我们找出CD Projekt Red团队如何在The Witcher 3中解决此问题。 在上一部分中，我已经检查了眼睛的色调校正和适应性，因此难题中唯一剩下的部分就是平均亮度。 <br><br> 首先，《巫师3》的平均亮度计算包括两遍。 为了清楚起见，我决定将它们分成几个部分，首先我们看一下第一遍-“亮度分布”（亮度直方图的计算）。 <br><br><h3> 亮度分布 </h3><br> 在任何帧分析器中都非常容易找到这两个遍。 这些是在执行眼睛适应之前按顺序进行的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dispatch</a>调用： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/5fb/09c/7de5fb09ce00453f14262f9e2b1bae30.png"></div><br> 让我们看看此通行证的输入。 他需要两个纹理： <br><br>  1）HDR彩色缓冲区，其大小缩小为1/4 x 1/4（例如，从1920x1080降至480x270）， <br><br>  2）全屏深度缓冲区 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/021/38b/795/02138b795946d192f553eadc20d34366.png"></div><br>  <i>1/4 x 1/4 HDR彩色缓冲区。</i>  <i>请注意棘手的技巧-此缓冲区是较大缓冲区的一部分。</i>  <i>重用缓冲区是一种好习惯。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/62d/c97/0e362dc97908f75db564cff0f46b1e7e.png"></div><br>  <i>全屏深度缓冲区</i> <br><br> 为什么要缩小颜色缓冲区？ 我认为这全都与性能有关。 <br><br> 至于此遍的输出，它是一个结构化的缓冲区。  256个元素，每个元素4个字节。 <br><br> 着色器在这里没有调试信息，因此假设它只是无符号int值的缓冲区。 <br><br> 重要提示：计算平均亮度的第一步是调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ClearUnorderedAccessViewUint</a>将结构化缓冲区的所有元素重置为零。 <br><br> 让我们研究计算着色器的汇编代码（这是我们整个分析中的第一个计算着色器！） <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[3], immediateIndexed <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_uav_structured u0, 4 <br> dcl_input vThreadGroupID.x <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 6 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: store_structured g0.x, vThreadIDInGroup.x, l(0), l(0) <br> 1: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 2: store_structured g0.x, r0.x, l(0), l(0) <br> 3: store_structured g0.x, r0.y, l(0), l(0) <br> 4: store_structured g0.x, r0.z, l(0), l(0) <br> 5: sync_g_t <br> 6: ftoi r1.x, cb0[2].z <br> 7: mov r2.y, vThreadGroupID.x <br> 8: mov r2.zw, l(0, 0, 0, 0) <br> 9: mov r3.zw, l(0, 0, 0, 0) <br> 10: mov r4.yw, l(0, 0, 0, 0) <br> 11: mov r1.y, l(0) <br> 12: loop <br> 13: utof r1.z, r1.y <br> 14: ge r1.z, r1.z, cb0[0].x <br> 15: breakc_nz r1.z <br> 16: iadd r2.x, r1.y, vThreadIDInGroup.x <br> 17: utof r1.z, r2.x <br> 18: lt r1.z, r1.z, cb0[0].x <br> 19: if_nz r1.z <br> 20: ld_indexable(texture2d)(float,float,float,float) r5.xyz, r2.xyzw, t0.xyzw <br> 21: dp3 r1.z, r5.xyzx, l(0.212600, 0.715200, 0.072200, 0.000000) <br> 22: imul null, r3.xy, r1.xxxx, r2.xyxx <br> 23: ld_indexable(texture2d)(float,float,float,float) r1.w, r3.xyzw, t1.yzwx <br> 24: eq r1.w, r1.w, cb0[2].w <br> 25: and r1.w, r1.w, cb0[2].y <br> 26: add r2.x, -r1.z, cb0[2].x <br> 27: mad r1.z, r1.w, r2.x, r1.z <br> 28: add r1.z, r1.z, l(1.000000) <br> 29: log r1.z, r1.z <br> 30: mul r1.z, r1.z, l(88.722839) <br> 31: ftou r1.z, r1.z <br> 32: umin r4.x, r1.z, l(255) <br> 33: atomic_iadd g0, r4.xyxx, l(1) <br> 34: endif <br> 35: iadd r1.y, r1.y, l(64) <br> 36: endloop <br> 37: sync_g_t <br> 38: ld_structured r1.x, vThreadIDInGroup.x, l(0), g0.xxxx <br> 39: mov r4.z, vThreadIDInGroup.x <br> 40: atomic_iadd u0, r4.zwzz, r1.x <br> 41: ld_structured r1.x, r0.x, l(0), g0.xxxx <br> 42: mov r0.w, l(0) <br> 43: atomic_iadd u0, r0.xwxx, r1.x <br> 44: ld_structured r0.x, r0.y, l(0), g0.xxxx <br> 45: atomic_iadd u0, r0.ywyy, r0.x <br> 46: ld_structured r0.x, r0.z, l(0), g0.xxxx <br> 47: atomic_iadd u0, r0.zwzz, r0.x <br> 48: ret</code> <br> <br> 还有一个常量缓冲区： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/805/dc6/c14805dc6b7ffd431d9307cc46dcba0d.png"></div><br> 我们已经知道第一个输入是HDR颜色缓冲区。 使用FullHD时，其分辨率为480x270。 让我们看一下Dispatch调用。 <br><br> 调度（270，1，1）-这意味着我们运行270个线程组。 简而言之，我们在颜色缓冲区的每一行运行一组线程。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/a97/7e3/e9aa977e3f9a60104fe9a66d797a27cc.png"></div><br>  <i>每个线程组执行一行HDR颜色缓冲区</i> <br><br> 现在我们有了这个上下文，让我们尝试找出着色器的功能。 <br><br> 每个线程组在X方向上具有64个线程（dcl_thread_group 64、1、1），以及共享内存，256个元素（每个元素4个字节）（dcl_tgsm_structured g0、4、256）。 <br><br> 请注意，在着色器中，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SV_GroupThreadID</a> （vThreadIDInGroup.x）[0-63]和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SV_GroupID</a> （vThreadGroupID.x）[0-269]。 <br><br>  1）我们首先为共享内存的所有元素分配零值。 由于总内存每个组包含256个元素和64个线程，因此可以通过一个简单的循环方便地完成此操作： <br><br> <code>//   -      . <br> //        64 ,          4 . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = 0; <br> }</code> <br> <br>  2）之后，我们使用GroupMemoryBarrierWithGroupSync（sync_g_t）设置障碍。 我们这样做是为了确保在进行下一步之前，组共享内存中的所有线程都重置为零。 <br><br>  3）现在我们正在执行一个循环，大致可以这样写： <br><br> <code>// cb0_v0.x -      .  1920x1080   1920/4 = 480; <br> float ViewportSizeX = cb0_v0.x; <br> [loop] for ( uint PositionX = 0; PositionX &lt; ViewportSizeX; PositionX += 64 ) <br> { <br> ...</code> <br> <br> 这是一个简单的for循环，增量为64（您已经知道为什么吗？）。 <br><br> 下一步是计算加载像素的位置。 <br><br> 让我们考虑一下。 <br><br> 对于Y坐标，我们可以使用SV_GroupID.x，因为我们启动了270个线程组。 <br><br> 对于X坐标，我们...可以利用当前的组流！ 让我们尝试去做。 <br><br> 由于每个组中有64个线程，因此这种解决方案将绕过所有像素。 <br><br> 考虑线程组（0、0、0）。 <br><br>  -流（0，0，0）将处理像素（0，0），（64，0），（128，0），（192，0），（256，0），（320，0），（384， 0），（448,0）。 <br><br>  -流（1、0、0）将处理像素（1、0），（65、0），（129、0），（193、0），（257、0），（321、0），（385， 0），（449、0）... <br><br>  -流（63，0，0）将处理像素（63，0），（127，0），（191，0），（255，0），（319，0），（383，0），（447， 0） <br><br> 因此，将处理所有像素。 <br><br> 我们还需要确保不从颜色缓冲区外部加载像素： <br><br> <code>//      X.  Y  GroupID. <br> uint CurrentPixelPositionX = PositionX + threadID; <br> uint CurrentPixelPositionY = groupID; <br> if ( CurrentPixelPositionX &lt; ViewportSizeX ) <br> { <br> // HDR- . <br> //   HDR-    ,     . <br> uint2 colorPos = uint2(CurrentPixelPositionX, CurrentPixelPositionY); <br> float3 color = texture0.Load( int3(colorPos, 0) ).rgb; <br> float luma = dot(color, LUMA_RGB);</code> <br> <br> 看吗 很简单！ <br><br> 我还计算了亮度（汇编代码的第21行）。 <br><br> 太好了，我们已经从彩色像素计算出了亮度。 下一步是加载（而不是采样！）相应的深度值。 <br><br> 但是这里存在一个问题，因为我们连接了全分辨率深度缓冲。 怎么办呢？ <br><br> 这非常简单，只需将colorPos乘以某个常数（cb0_v2.z）。 我们将HDR颜色缓冲区缩小了四倍。 因此该值为4！ <br><br> <code>const int iDepthTextureScale = (int) cb0_v2.z; <br> uint2 depthPos = iDepthTextureScale * colorPos; <br> float depth = texture1.Load( int3(depthPos, 0) ).x;</code> <br> <br> 到目前为止一切顺利！ 但是...我们到了24-25行... <br><br> <code>24: eq r2.x, r2.x, cb0[2].w <br> 25: and r2.x, r2.x, cb0[2].y</code> <br> <br> 所以 首先，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对</a>浮点<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相等进行比较</a> ，其结果写在r2.x中，然后紧接着...什么？ 按位<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">和</a> ?? 真的吗 对于浮点值？ 到底是什么??? <br><br>  <b>'eq + and'问题</b> <br><br> 我只想说这对着色器来说是最难的部分。 我什至尝试了怪异的asint / asfloat组合... <br><br> 如果使用稍微不同的方法？ 让我们在HLSL中进行通常的浮点比较。 <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y); <br> return test; <br> }</code> <br> <br> 这是汇编代码的输出： <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, l(0x3f800000) <br> 2: ret</code> <br> <br> 有趣吧？ 我没想到在这里看到“和”。 <br><br>  0x3f800000仅为1.0f ...这是合理的，因为如果比较成功，我们将得到1.0和0.0。 <br><br> 但是，如果我们用其他值“替换” 1.0怎么办？ 例如，像这样： <br><br> <code>float DummyPS() : SV_Target0 <br> { <br> float test = (cb0_v0.x == cb0_v0.y) ? cb0_v0.z : 0.0; <br> return test; <br> }</code> <br> <br> 我们得到以下结果： <br><br> <code>0: eq r0.x, cb0[0].y, cb0[0].x <br> 1: and o0.x, r0.x, cb0[0].z <br> 2: ret</code> <br> <br> 哈！ 奏效了。 这只是HLSL编译器的魔力。 注意：如果将0.0替换为其他内容，则只会得到movc。 <br><br> 让我们回到计算着色器。 下一步是验证深度等于cb0_v2.w。 它始终等于0.0-换句话说，我们检查像素是否在远平面上（在天空中）。 如果是这样，那么我们给这个系数分配一个大约0.5的值（我在几帧上检查了一下）。 <br><br> 该计算出的系数用于在颜色的亮度和“天空”的亮度（cb0_v2.x值，通常大约等于0.0）之间进行插值。 我认为这对于控制天空在计算平均亮度中的重要性是必要的。 通常重要性降低。 非常聪明的主意。 <br><br> <code>// ,       ( ).  ,    ,    <br> //    . <br> float value = (depth == cb0_v2.w) ? cb0_v2.y : 0.0; <br> <br> //  'value'  0.0,   lerp    'luma'.   'value'  <br> // (  0.50),   luma    . (cb0_v2.x    0.0). <br> float lumaOk = lerp( luma, cb0_v2.x, value );</code> <br> <br> 由于我们有lumaOk，下一步是计算其自然对数以创建良好的分布。 但是，等等，假设lumaOk为0.0。 我们知道log（0）的值是不确定的，所以我们加1.0是因为log（1）= 0.0。 <br><br> 之后，我们将计算的对数缩放为128，以将其分布在256个像元中。 很聪明！ <br><br> 从这里开始，将采用此值88.722839。 这是<code>128 *   (2)</code> 。 <br><br> 这只是HLSL计算对数的方式。 <br><br>  HLSL汇编器代码中只有一个函数可以计算对数： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">log</a> ，其底数为2。 <br><br> <code>// ,  lumaOk  0.0. <br> // log(0)   undefined <br> // log(1) = 0. <br> //     <br> lumaOk = log(lumaOk + 1.0); <br> <br> //     128 <br> lumaOk *= 128;</code> <br> <br> 最后，我们根据对数分布的亮度计算单元格的索引，并将1加到共享内存中的相应单元格。 <br><br> <code>//   .    Uint,    256 , <br> //  ,      . <br> uint uLuma = (uint) lumaOk; <br> uLuma = min(uLuma, 255); <br> <br> //  1    . <br> InterlockedAdd( shared_data[uLuma], 1 );</code> <br> <br> 下一步将再次设置障碍，以确保已处理该行中的所有像素。 <br><br> 最后一步是将共享内存中的值添加到结构化缓冲区中。 通过一个简单的循环以相同的方式完成此操作： <br><br> <code>// ,       <br> GroupMemoryBarrierWithGroupSync(); <br> <br> //      . <br> [unroll] for (uint idx = 0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> <br> uint data = shared_data[offset]; <br> InterlockedAdd( g_buffer[offset], data ); <br> }</code> <br> <br> 在线程组中的所有64个线程填充公共数据之后，每个线程将4个值添加到输出缓冲区。 <br><br> 考虑输出缓冲区。 让我们考虑一下。 缓冲区中所有值的总和等于像素总数！  （480x270 = 129,600）。 也就是说，我们知道有多少像素具有特定的亮度值。 <br><br> 如果您不熟悉计算着色器（例如我），那么一开始可能不清楚，因此请多读几遍文章，拿着纸和一支铅笔，并尝试了解构建此技术的概念。 <br><br> 仅此而已！ 这就是巫师3如何计算亮度的直方图。 就个人而言，在编写此部分时我学到了很多东西。 祝贺CD Projekt Red的出色工作！ <br><br> 如果您对完整的HLSL着色器感兴趣，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处获得</a> 。 我一直在努力使汇编代码尽可能地接近游戏，并且对我再次成功感到非常高兴！ <br><br><h2> 平均亮度计算 </h2><br> 这是《巫师3：狂猎》中中等亮度计算分析的第二部分。 <br><br> 在与另一个计算着色器进行战斗之前，让我们简单地重复上一部分的内容：我们使用缩小到1 / 4x1 / 4的HDR颜色缓冲区。 第一次通过后，我们获得了亮度直方图（256个无符号整数值的结构化缓冲区）。 我们计算了每个像素亮度的对数，将其分布在256个单元中，并将结构化缓冲区的相应值每个像素增加1。 因此，这256个单元中所有值的总和等于像素数。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/89c/d16/3c389cd16ec2eed7617dcf9334429c6e.png"></div><br>  <i>第一次通过的输出示例。</i>  <i>有256个元素。</i> <br><br> 例如，我们的全屏缓冲区的大小为1920x1080。 缩小后，第一遍使用480x270缓冲区。 缓冲区中所有256个值的总和将等于480 * 270 = 129600。 <br><br> 简短介绍之后，我们准备继续进行下一步：计算。 <br><br> 这次仅使用了一个线程组（调度（1、1、1、1））。 <br><br> 让我们看一下计算着色器的汇编代码： <br><br> <code>cs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_uav_structured u0, 4 <br> dcl_uav_typed_texture2d (float,float,float,float) u1 <br> dcl_input vThreadIDInGroup.x <br> dcl_temps 4 <br> dcl_tgsm_structured g0, 4, 256 <br> dcl_thread_group 64, 1, 1 <br> 0: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, vThreadIDInGroup.x, l(0), u0.xxxx <br> 1: store_structured g0.x, vThreadIDInGroup.x, l(0), r0.x <br> 2: iadd r0.xyz, vThreadIDInGroup.xxxx, l(64, 128, 192, 0) <br> 3: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.w, r0.x, l(0), u0.xxxx <br> 4: store_structured g0.x, r0.x, l(0), r0.w <br> 5: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.y, l(0), u0.xxxx <br> 6: store_structured g0.x, r0.y, l(0), r0.x <br> 7: ld_structured_indexable(structured_buffer, stride=4)(mixed,mixed,mixed,mixed) r0.x, r0.z, l(0), u0.xxxx <br> 8: store_structured g0.x, r0.z, l(0), r0.x <br> 9: sync_g_t <br> 10: if_z vThreadIDInGroup.x <br> 11: mul r0.x, cb0[0].y, cb0[0].x <br> 12: ftou r0.x, r0.x <br> 13: utof r0.y, r0.x <br> 14: mul r0.yz, r0.yyyy, cb0[0].zzwz <br> 15: ftoi r0.yz, r0.yyzy <br> 16: iadd r0.x, r0.x, l(-1) <br> 17: imax r0.y, r0.y, l(0) <br> 18: imin r0.y, r0.x, r0.y <br> 19: imax r0.z, r0.y, r0.z <br> 20: imin r0.x, r0.x, r0.z <br> 21: mov r1.z, l(-1) <br> 22: mov r2.xyz, l(0, 0, 0, 0) <br> 23: loop <br> 24: breakc_nz r2.x <br> 25: ld_structured r0.z, r2.z, l(0), g0.xxxx <br> 26: iadd r3.x, r0.z, r2.y <br> 27: ilt r0.z, r0.y, r3.x <br> 28: iadd r3.y, r2.z, l(1) <br> 29: mov r1.xy, r2.yzyy <br> 30: mov r3.z, r2.x <br> 31: movc r2.xyz, r0.zzzz, r1.zxyz, r3.zxyz <br> 32: endloop <br> 33: mov r0.w, l(-1) <br> 34: mov r1.yz, r2.yyzy <br> 35: mov r1.xw, l(0, 0, 0, 0) <br> 36: loop <br> 37: breakc_nz r1.x <br> 38: ld_structured r2.x, r1.z, l(0), g0.xxxx <br> 39: iadd r1.y, r1.y, r2.x <br> 40: utof r2.x, r2.x <br> 41: utof r2.w, r1.z <br> 42: add r2.w, r2.w, l(0.500000) <br> 43: mul r2.w, r2.w, l(0.011271) <br> 44: exp r2.w, r2.w <br> 45: add r2.w, r2.w, l(-1.000000) <br> 46: mad r3.z, r2.x, r2.w, r1.w <br> 47: ilt r2.x, r0.x, r1.y <br> 48: iadd r2.w, -r2.y, r1.y <br> 49: itof r2.w, r2.w <br> 50: div r0.z, r3.z, r2.w <br> 51: iadd r3.y, r1.z, l(1) <br> 52: mov r0.y, r1.z <br> 53: mov r3.w, r1.x <br> 54: movc r1.xzw, r2.xxxx, r0.wwyz, r3.wwyz <br> 55: endloop <br> 56: store_uav_typed u1.xyzw, l(0, 0, 0, 0), r1.wwww <br> 57: endif <br> 58: ret</code> <br> <br> 有一个常量缓冲区： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbe/13a/0ab/bbe13a0abe0d79f47b0a59d33d51ab9c.png"></div><br> 让我们快速看一下汇编代码：附加了两个UAV（u0：第一部分的输入缓冲区，u1：1x1 R32_FLOAT格式的输出纹理）。 我们还看到，每个组有64个线程，而4字节共享组内存有256个元素。 <br><br> 我们首先用来自输入缓冲区的数据填充共享内存。 我们有64个线程，因此您将必须执行与以前几乎相同的操作。 <br><br> 为了绝对确保已加载所有数据以进行进一步处理，在此之后，我们设置了障碍。 <br><br> <code>//   -        . <br> //        64 ,    4     <br> //    . <br> [unroll] for (uint idx=0; idx &lt; 4; idx++) <br> { <br> const uint offset = threadID + idx*64; <br> shared_data[ offset ] = g_buffer[offset]; <br> } <br> //    ,       ,     <br> //             . <br> GroupMemoryBarrierWithGroupSync();</code> <br> <br> 所有计算仅在一个线程中执行，所有其他计算仅用于将缓冲区中的值加载到共享内存中。 <br><br>  “计算”流的索引为0。为什么？ 从理论上讲，我们可以使用间隔[0-63]中的任何流，但是由于与0进行了比较，因此可以避免其他整数-整数比较（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ieq</a>指令）。 <br><br> 该算法基于在操作中将要考虑的像素间隔的指示。 <br><br> 在第11行中，我们将width * height乘以得到像素总数，然后将它们乘以间隔[0.0f-1.0f]中的两个数字，以指示间隔的开始和结束。 进一步的限制用于确保<code>0 &lt;= Start &lt;= End &lt;= totalPixels - 1</code> ： <br><br> <code>//        0. <br> [branch] if (threadID == 0) <br> { <br> //         <br> uint totalPixels = cb0_v0.x * cb0_v0.y; <br> <br> //   (,  ,    ), <br> //        . <br> int pixelsToConsiderStart = totalPixels * cb0_v0.z; <br> int pixelsToConsiderEnd = totalPixels * cb0_v0.w; <br> <br> int pixelsMinusOne = totalPixels - 1; <br> <br> pixelsToConsiderStart = clamp( pixelsToConsiderStart, 0, pixelsMinusOne ); <br> pixelsToConsiderEnd = clamp( pixelsToConsiderEnd, pixelsToConsiderStart, pixelsMinusOne );</code> <br> <br> 如您所见，下面有两个循环。 它们（或它们的汇编代码）的问题在于，循环的末尾有奇怪的条件转换。 我很难重新创建它们。 还要看一下第21行。为什么会有“ -1”？ 我会在下面解释一下。 <br><br> 第一个循环的任务是删除<i>pixelToConsiderStart</i>并为我们提供其中存在<i>pixelToConsiderStart</i> +1的缓冲单元的索引（以及先前单元中所有像素的数量）。 <br><br> 假设<i>pixelsToConsiderStart</i>大约等于30,000，并且缓冲区中的“零”单元中有37,000个像素（这种情况发生在夜间的游戏中）。 因此，我们要开始分析像素“零”中存在的像素30001的亮度。 在这种情况下，我们立即退出循环，获得起始索引“ 0”和零废弃像素。 <br><br> 看一下HLSL代码： <br><br> <code>//     <br> int numProcessedPixels = 0; <br> <br> //   [0-255] <br> int lumaValue = 0; <br> <br> //      <br> bool bExitLoop = false; <br> <br> //    -  "pixelsToConsiderStart" . <br> //          lumaValue,      . <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> // ,      lumaValue <br> int tempSum = numProcessedPixels + numPixels; <br> <br> //  ,  pixelsToConsiderStart,    . <br> // ,      lumaValue. <br> //  , pixelsToConsiderStart -   "" ,   ,    . <br> [flatten] <br> if (tempSum &gt; pixelsToConsiderStart) <br> { <br> bExitLoop = true; <br> } <br> else <br> { <br> numProcessedPixels = tempSum; <br> lumaValue++; <br> } <br> }</code> <br> <br> 汇编代码第21行中的神秘数字“ -1”与用于循环执行的布尔条件相关联（我偶然发现了这一点）。 <br><br> 从<i>lumaValue</i>单元和<i>lumaValue</i>本身接收到像素数后，我们可以继续第二个循环。 <br><br> 第二个周期的任务是计算像素和平均亮度的影响。 <br><br> 我们从在第一个循环中计算出的<i>lumaValue</i>开始。 <br><br> <code>float finalAvgLuminance = 0.0f; <br> <br> //       <br> uint numProcessedPixelStart = numProcessedPixels; <br> <br> //    -      . <br> //    ,    ,        lumaValue. <br> //      [0-255],     ,    ,   ,    <br> //    pixelsToConsiderEnd. <br> //          . <br> bExitLoop = false; <br> [loop] <br> while (!bExitLoop) <br> { <br> //       . <br> uint numPixels = shared_data[lumaValue]; <br> <br> //      <br> numProcessedPixels += numPixels; <br> <br> //    ,    [0-255] (uint) <br> uint encodedLumaUint = lumaValue; <br> <br> //        <br> float numberOfPixelsWithCurrentLuma = numPixels; <br> <br> //    ,    [0-255] (float) <br> float encodedLumaFloat = encodedLumaUint;</code> <br> <br> 在这一阶段，我们获得了以[0.0f-255.f]间隔编码的亮度值。 <br><br> 解码过程非常简单-您需要反转编码阶段的计算。 <br><br> 编码过程的简短重复： <br><br> <code>float luma = dot( hdrPixelColor, float3(0.2126, 0.7152, 0.0722) ); <br> ... <br> float outLuma; <br> <br> //   log(0)  undef,  log(1) = 0 <br> outLuma = luma + 1.0; <br> <br> //   <br> outLuma = log( outLuma ); <br> <br> //   128,   log(1) * 128 = 0, log(2,71828) * 128 = 128, log(7,38905) * 128 = 256 <br> outLuma = outLuma * 128 <br> <br> //   uint <br> uint outLumaUint = min( (uint) outLuma, 255);</code> <br> <br> 为了解码亮度，我们反转编码过程，例如： <br><br> <code>//    0.5f (  ,    ) <br> float fDecodedLuma = encodedLumaFloat + 0.5; <br> <br> //   : <br> <br> //   128 <br> fDecodedLuma /= 128.0; <br> <br> // exp(x),   log(x) <br> fDecodedLuma = exp(fDecodedLuma); <br> <br> //  1.0 <br> fDecodedLuma -= 1.0;</code> <br> <br> 然后，我们将给定亮度的像素数乘以解码后的亮度，然后求和，直到进行<i>pixelToConsiderEnd</i>像素处理， <i>从而</i>计算出分布。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后，我们将总效果除以分析的像素数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是循环的其余部分（和着色器）：</font><font style="vertical-align: inherit;">完整的着色器</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在此处</font></a><font style="vertical-align: inherit;">可用</font><font style="vertical-align: inherit;">。它与我的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;">程序完全兼容</font><font style="vertical-align: inherit;">，没有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">，我将无法在The Witcher 3中有效地重新创建平均亮度计算（以及所有其他效果！）。</font><font style="vertical-align: inherit;">总之，有几点想法。在计算平均亮度方面，很难重建此着色器。主要原因是：</font><font style="vertical-align: inherit;">1）对循环执行过程进行奇怪的“挂起”检查，比我以前想象的要花费更多的时间。</font><font style="vertical-align: inherit;">2）在RenderDoc（v。1.2）中调试此计算着色器时出现问题。</font></font><br><br> <code>//     <br> float fCurrentLumaContribution = numberOfPixelsWithCurrentLuma * fDecodedLuma; <br> <br> // ()       . <br> float tempTotalContribution = fCurrentLumaContribution + finalAvgLuminance; <br> <br> <br> [flatten] <br> if (numProcessedPixels &gt; pixelsToConsiderEnd ) <br> { <br> //     <br> bExitLoop = true; <br> <br> //      ,     . <br> //         <br> int diff = numProcessedPixels - numProcessedPixelStart; <br> <br> //     <br> finalAvgLuminance = tempTotalContribution / float(diff); <br> } <br> else <br> { <br> //       lumaValue <br> finalAvgLuminance = tempTotalContribution; <br> lumaValue++; <br> } <br> } <br> <br> //    <br> g_avgLuminance[uint2(0,0)] = finalAvgLuminance;</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管从索引0读取的结果给出了正确的值，但并未完全支持“ ld_structured_indexable”操作，而所有其他操作都返回零，这就是循环无限期继续的原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我无法实现与原始代码相同的汇编代码（有关差异，请参见下面的屏幕截图），但是使用RenderDoc，我可以将此着色器注入到管道中-结果是相同的！</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/a0e/74f/de1a0e74f0f6619994d1edc9621d148d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">战斗的结果。</font><font style="vertical-align: inherit;">左边是我的着色器，右边是原始的汇编代码。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第8部分。月亮及其相位 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文的第八部分中，我研究了《巫师3》中的月亮着色器（更具体地说，是《血与酒》的扩展部分）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">月亮是夜空的重要元素，很难让人相信它，但是对我来说，在TW3夜间行走确实是一种享受。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看看这个场景！</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53f/099/b6c/53f099b6ccfcef0eeb0755ced73894b9.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在介绍像素着色器之前，我会先谈谈渲染的细微差别。从几何角度来看，月球只是一个球体（见下文），具有纹理坐标，法线和切线向量。顶点着色器计算世界空间中的位置，以及法线的归一化向量（与向量相乘）的两个点的切线和切线，再乘以世界矩阵。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确保完全月球位于远程平面，字段和MinDepth MAXDEPTH结构</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D3D11_VIEWPORT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配值0.0（这是用于天空圆顶同一特技）。月亮在天空之后立即渲染。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/999/ec7/6f5999ec7ca1176dfac370f60820d97f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用来吸引月球的球体，</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嗯，我想，一切都可以继续进行。</font><font style="vertical-align: inherit;">让我们看一下像素着色器：</font><font style="vertical-align: inherit;">我从Blood and Wine中选择着色器的主要原因很简单-它更短。</font><font style="vertical-align: inherit;">首先，我们计算偏移量以对纹理进行采样。</font><font style="vertical-align: inherit;">cb0 [0] .w用作X轴的偏移量，通过此简单技巧，我们可以模拟月亮绕其轴的旋转。</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[1], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[267], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_input_ps linear v1.w <br> dcl_input_ps linear v2.xyzw <br> dcl_input_ps linear v3.xy <br> dcl_input_ps linear v4.xy <br> dcl_output o0.xyzw <br> dcl_temps 3 <br> 0: mov r0.x, -cb0[0].w <br> 1: mov r0.y, l(0) <br> 2: add r0.xy, r0.xyxx, v2.xyxx <br> 3: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, r0.xyxx, t0.xyzw, s0 <br> 4: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 5: log r0.w, r0.w <br> 6: mul r0.w, r0.w, l(2.200000) <br> 7: exp r0.w, r0.w <br> 8: add r0.xyz, r0.xyzx, r0.xyzx <br> 9: dp3 r1.x, r0.xyzx, r0.xyzx <br> 10: rsq r1.x, r1.x <br> 11: mul r0.xyz, r0.xyzx, r1.xxxx <br> 12: mul r1.xy, r0.yyyy, v3.xyxx <br> 13: mad r0.xy, v4.xyxx, r0.xxxx, r1.xyxx <br> 14: mad r0.xy, v2.zwzz, r0.zzzz, r0.xyxx <br> 15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185) <br> 17: sincos r1.x, r2.x, r0.z <br> 18: mov r2.y, r1.x <br> 19: dp2_sat r0.x, r0.xyxx, r2.xyxx <br> 20: mul r0.xyz, r0.xxxx, cb12[266].xyzx <br> 21: mul r0.xyz, r0.xyzx, r0.wwww <br> 22: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 23: add_sat r0.w, -v1.w, l(1.000000) <br> 24: mul r0.w, r0.w, cb2[2].w <br> 25: mul o0.xyz, r0.wwww, r0.xyzx <br> 26: mov o0.w, l(0) <br> 27: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc2/ddb/c02/fc2ddbc0262d27002f70d837a623c366.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来自常量缓冲区的值的示例。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个纹理（1024x512）附加为输入。</font><font style="vertical-align: inherit;">法线贴图在RGB通道中进行编码，而月球表面的颜色在alpha通道中进行编码。</font><font style="vertical-align: inherit;">聪明！</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/733/1a1/3927331a17867d712e667c36a0ee6641.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理的Alpha通道是月球表面的颜色。</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/542/d70/c64542d70a7e3b58aa9426f12e8880d7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理RGB通道是一个法线贴图。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到正确的纹理坐标后，我们对RGBA通道进行采样。我们需要解压缩法线贴图并执行表面颜色的伽玛校正。当前，可以这样编写HLSL着色器，例如：</font><font style="vertical-align: inherit;">下一步是执行常规绑定，但仅在XY组件中。 （在“巫师3”中，Z轴朝上，纹理的整个Z通道为1.0）。我们可以这样进行：</font><font style="vertical-align: inherit;">现在是时候使用该着色器中我最喜欢的部分了。</font><font style="vertical-align: inherit;">再看</font><font style="vertical-align: inherit;">15-16行：</font><font style="vertical-align: inherit;">这个神秘的0.033864是什么？乍一看似乎没有任何意义，但如果我们计算与之相反的值，我们将得出大约29.53的价格，这等于</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">宗教会议月份</font></a><font style="vertical-align: inherit;">的持续时间。</font></font><br><br> <code>float4 MoonPS(in InputStruct IN) : SV_Target0 <br> { <br> //  Texcoords <br> float2 uvOffsets = float2(-cb0_v0.w, 0.0); <br> <br> //  texcoords <br> float2 uv = IN.param2.xy + uvOffsets; <br> <br> //   <br> float4 sampledTexture = texture0.Sample( sampler0, uv); <br> <br> //    -  - <br> float moonColorTex = pow(sampledTexture.a, 2.2 ); <br> <br> //     [0,1]   [-1,1]. <br> // : sampledTexture.xyz * 2.0 - 1.0    <br> float3 sampledNormal = normalize((sampledTexture.xyz - 0.5) * 2);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>//    <br> float3 Tangent = IN.param4.xyz; <br> float3 Normal = float3(IN.param2.zw, IN.param3.w); <br> float3 Bitangent = IN.param3.xyz; <br> <br> //  TBN <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> <br> //    XY <br> //   TBN  float3x2: 3 , 2  <br> float2 vNormal = mul(sampledNormal, (float3x2)TBN).xy;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>15: mad r0.z, cb0[0].y, l(0.033864), cb0[0].w <br> 16: mul r0.z, r0.z, l(6.283185)</code> <br> <br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在几天之内！</font><font style="vertical-align: inherit;">这就是我所谓的关注细节！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以可靠地假定cb0 [0] .y是游戏过程中经过的天数。</font><font style="vertical-align: inherit;">此处使用一个附加偏差，用作沿着纹理x轴的偏移。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到该系数后，我们将其乘以2 * Pi。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后使用sincos计算另一个2d向量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过计算法向矢量和“月球”矢量之间的标量积，可以模拟月球的一个相位。</font><font style="vertical-align: inherit;">查看不同月相的屏幕截图：</font></font><br><br> <code>//  . <br> //   days/29.53 + bias. <br> float phase = cb0_v0.y * (1.0 / SYNODIC_MONTH_LENGTH) + cb0_v0.w; <br> <br> //   2*PI.  , 29.53     <br> //   sin/cos. <br> phase *= TWOPI; <br> <br> //      . <br> float outSin = 0.0; <br> float outCos = 0.0; <br> sincos(phase, outSin, outCos); <br> <br> //    <br> float lunarPhase = saturate( dot(vNormal, float2(outCos, outSin)) );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c54/e7f/648/c54e7f6488b10d402a7f4b45e61d455d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/133/edc/899133edc0c04c67ffb4987748e908b7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后一步是执行一系列乘法运算以计算最终颜色。</font><font style="vertical-align: inherit;">您可能不明白为什么此着色器将alpha值0.0发送到输出。</font><font style="vertical-align: inherit;">这是因为在启用混合的情况下渲染了月亮：</font></font><br><br> <code>//        . <br> <br> // cb12_v266.xyz ,      . <br> //  (1.54, 2.82, 4.13) <br> float3 moonSurfaceGlowColor = cb12_v266.xyz; <br> <br> float3 moonColor = lunarPhase * moonSurfaceGlowColor; <br> moonColor = moonColorTex * moonColor; <br> <br> // cb_v2.xyz - , , ,  (1.0, 1.0, 1.0) <br> moonColor *= cb2_v2.xyz; <br> <br> //   ,    , .  -   . <br> //     ,         , <br> //   . <br> float paramHorizon = saturate(1.0 - IN.param1.w); <br> paramHorizon *= cb2_v2.w; <br> <br> moonColor *= paramHorizon; <br> <br> //        <br> return float4(moonColor, 0.0);</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/549/32c/2d954932c188bcdcdd0a156796b85da7.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果此着色器返回黑色，则可以使用此方法获得背景（天空）颜色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您对完整的着色器感兴趣，则可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处获取</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它具有大的常量缓冲区，应该已经准备好注入RenderDoc而不是原始的着色器（只需将“ MoonPS”重命名为“ EditedShaderPS”）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后：我想与您分享结果：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左边是我的着色器，右边是游戏中的原始着色器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差异很小，不会影响结果。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff8/c4a/8fa/ff8c4a8fa103b9592941c965ad060729.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如您所见，此着色器很容易重新创建。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第9部分。G缓冲区 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一部分中，我将揭示The Witcher 3中gbuffer的一些细节。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将假定您了解延迟着色的基础知识。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简短的重复：推迟的想法不是立即计算所有完成的照明和阴影，而是将计算分为两个阶段。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一个（几何过程）中，我们用表面数据（位置，法线，镜面颜色等）填充GBuffer，在第二个（光照过程）中，我们将所有内容组合起来并计算光照。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟着色是一种非常流行的方法，因为它使您可以通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">平铺延迟着色</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等技术在单个全屏通道中进行计算</font><font style="vertical-align: inherit;">，从而大大提高了性能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简而言之，GBuffer是一组具有几何属性的纹理。</font><font style="vertical-align: inherit;">为它创建正确的结构非常重要。</font><font style="vertical-align: inherit;">以现实生活中的示例为例，您可以研究《</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">孤岛危机3》渲染技术</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简要介绍之后，让我们看一下《巫师3：血与酒》中的一个示例框架：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/6f5/537/2c36f5537e82217c31d0f5f682b17b6c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toussent</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic GBuffer </font><i><font style="vertical-align: inherit;">的众多酒店之一，</font></i><font style="vertical-align: inherit;">包含DXGI_FORMAT_R8G8B8A8_UNORM格式的三个全屏渲染目标和DXGI_FORMAT_D24_UNORM_S8_UINT格式的depth +模具缓冲区。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是他们的屏幕截图：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/dec/857/309dec857a7839f41984b44ff82516ab.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染目标0-RGB通道，表面颜色</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/44c/b90/16c44cb90b067cb420d921e101319bb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染目标0-Alpha通道。</font><font style="vertical-align: inherit;">老实说，我不知道这些信息是什么。</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de9/f1a/cf3/de9f1acf36c9f9e18ec6f4a9708ede11.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染目标1-RGB通道。</font><font style="vertical-align: inherit;">在此记录间隔[0-1]中的法向矢量。</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/a60/1e8/0a5a601e893d88a619b94f1ed7d21ae2.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染目标1-Alpha通道。</font><font style="vertical-align: inherit;">看起来像反射率！</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fa/8f5/d61/7fa8f5d61cfc903b764eec1e9b46c431.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染目标2-RGB通道。</font><font style="vertical-align: inherit;">看起来像镜面的颜色！</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此场景中，alpha通道为黑色（但稍后使用）。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7e/27d/dab/e7e27ddab2102174b3f63bb9037e28a0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓冲区深度。</font><font style="vertical-align: inherit;">请注意，此处使用倒置深度。</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/77d/daa/e4e77ddaa01705381f956410f546fdf4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于标记特定类型像素（例如，皮肤，植被等）的模具缓冲区</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是整个GBuffer。</font><font style="vertical-align: inherit;">照明通道还使用照明探针和其他缓冲区，但是在本文中我将不讨论它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在继续本文的“主要”部分之前，我将给出一般性观察：</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 一般观察 </font></font></h3><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1）唯一要清除的缓冲区是深度/模板缓冲区。</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果在一个好的帧分析器中分析上述纹理，您会感到有些惊讶，因为它们不使用“清除”调用，而是“深度” /“模具”除外。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，实际上，RenderTarget1如下所示（请注意，远端平面上的“模糊”像素）：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/16a/3a7/22a16a3a7df971c2d1609f15e254cd06.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个简单而智能的优化。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的一课：</font><font style="vertical-align: inherit;">您需要</font><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClearRenderTargetView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用上</font><font style="vertical-align: inherit;">花费资源，因此仅在必要时使用它们。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）倒深度-这是酷</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文章</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已经</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于浮点深度缓冲的精确度。巫师3使用反向Z。对于具有较长渲染距离的开放世界游戏，这是自然的选择。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">切换到DirectX并不困难：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a）通过写入“ 0”而不是“ 1”来清除深度缓冲区。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在传统方法中，将far值“ 1”用于清除深度缓冲区。深度翻转后，新的“ distance”值变为0，因此您需要更改所有内容。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b）在计算投影矩阵时交换近边界和远边界</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c）将深度检查从“较小”​​更改为“较大”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于OpenGL，需要做更多的工作（请参见上述文章），但这是值得的。</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3）我们不保持自己在世界上的地位，</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是的，一切都如此简单。</font><font style="vertical-align: inherit;">在照明的传递中，我们从深处重新建立了在世界上的位置。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像素着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一部分中，我想确切显示向GBuffer提供表面数据的像素着色器。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，现在我们已经知道如何存储颜色，法线和镜面反射。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，一切都不如您想像的那么简单。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像素着色器的问题在于它具有许多选项。</font><font style="vertical-align: inherit;">它们的不同之处在于传递给它们的纹理数量以及从常量缓冲区（可能与描述材料的常量缓冲区）使用的参数数量不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了进行分析，我决定使用这个漂亮的桶：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/635/aa0/262635aa0a42dde5353586c867bc91d1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的英勇桶！</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请欢迎纹理：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e4/fde/9bb/9e4fde9bbe2ebcc3c1088eff5e3ea40d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们有了反照率，法线贴图和镜面反射颜色。很标准的情况。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在开始之前，请先谈谈几何输入：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几何是通过位置，texcoords，法线和切线缓冲区传输的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顶点着色器</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至少</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输出</font><font style="vertical-align: inherit;">texcoords，归一化切线/法线/切线向量到两个点，之前已与世界矩阵相乘。对于更复杂的材质（例如，具有两个扩散贴图或两个法线贴图），顶点着色器可以输出其他数据，但我想在此处显示一个简单示例。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汇编代码中的像素着色器：</font><font style="vertical-align: inherit;">着色器包含几个步骤。我将分别描述此着色器的每个主要部分。</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[3], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t2 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 3 <br> 0: sample_indexable(texture2d)(float,float,float,float) r0.xyzw, v1.xyxx, t1.xyzw, s0 <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t0.xyzw, s0 <br> 2: add r1.w, r1.y, r1.x <br> 3: add r1.w, r1.z, r1.w <br> 4: mul r2.x, r1.w, l(0.333300) <br> 5: add r2.y, l(-1.000000), cb4[1].x <br> 6: mul r2.y, r2.y, l(0.500000) <br> 7: mov_sat r2.z, r2.y <br> 8: mad r1.w, r1.w, l(-0.666600), l(1.000000) <br> 9: mad r1.w, r2.z, r1.w, r2.x <br> 10: mul r2.xzw, r1.xxyz, cb4[0].xxyz <br> 11: mul_sat r2.xzw, r2.xxzw, l(1.500000, 0.000000, 1.500000, 1.500000) <br> 12: mul_sat r1.w, abs(r2.y), r1.w <br> 13: add r2.xyz, -r1.xyzx, r2.xzwx <br> 14: mad r1.xyz, r1.wwww, r2.xyzx, r1.xyzx <br> 15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx <br> 21: add r0.xyz, r0.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r1.xyz, v3.xyzx, r0.xxxx, r1.xyzx <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r1.xyzx <br> 28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w <br> 46: dp3 r0.w, r0.xyzx, r0.xyzx <br> 47: rsq r0.w, r0.w <br> 48: mul r0.xyz, r0.wwww, r0.xyzx <br> 49: max r0.w, abs(r0.y), abs(r0.x) <br> 50: max r0.w, r0.w, abs(r0.z) <br> 51: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 52: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 53: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 54: lt r1.z, r1.y, r1.x <br> 55: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 56: div r1.z, r1.y, r1.x <br> 57: div r0.xyz, r0.xyzx, r0.wwww <br> 58: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 59: mul r0.xyz, r0.wwww, r0.xyzx <br> 60: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 61: mov o0.w, cb4[2].x <br> 62: mov o2.w, l(0) <br> 63: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 但是首先，像往常一样-屏幕截图包含来自常量缓冲区的值： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e94/24c/abb/e9424cabbd31630a47b7489e0e32c6af.jpg"></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 反照率 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从复杂的事情开始。</font><font style="vertical-align: inherit;">不仅仅是</font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ OutputColor.rgb = Texture.Sample（uv）.rgb”</font></font></strike> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对RGB颜色纹理进行采样（第1行）之后，接下来的14行被称为“饱和度降低缓冲区”。</font><font style="vertical-align: inherit;">让我向您展示HLSL代码：</font><font style="vertical-align: inherit;">对于大多数对象，此代码除了从纹理返回原始颜色外，什么也不做。</font><font style="vertical-align: inherit;">这是通过相应的“ material cbuffer”值实现的。</font><font style="vertical-align: inherit;">cb4_v1.x的值为1.0，返回的掩码为0.0，并返回来自</font><i><font style="vertical-align: inherit;">lerp</font></i><font style="vertical-align: inherit;">指令的输入颜色</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，也有一些例外。</font><font style="vertical-align: inherit;">我</font><i><font style="vertical-align: inherit;">发现</font></i><font style="vertical-align: inherit;">最大的</font><i><font style="vertical-align: inherit;">desaturationFactor</font></i><font style="vertical-align: inherit;">是4.0（从不小于1.0），并且</font><i><font style="vertical-align: inherit;">desaturatedColor</font></i></font><br><br> <code>float3 albedoColorFilter( in float3 color, in float desaturationFactor, in float3 desaturationValue ) <br> { <br> float sumColorComponents = color.r + color.g + color.b; <br> <br> float averageColorComponentValue = 0.3333 * sumColorComponents; <br> float oneMinusAverageColorComponentValue = 1.0 - averageColorComponentValue; <br> <br> float factor = 0.5 * (desaturationFactor - 1.0); <br> <br> float avgColorComponent = lerp(averageColorComponentValue, oneMinusAverageColorComponentValue, saturate(factor)); <br> float3 desaturatedColor = saturate(color * desaturationValue * 1.5); <br> <br> float mask = saturate( avgColorComponent * abs(factor) ); <br> <br> float3 finalColor = lerp( color, desaturatedColor, mask ); <br> return finalColor; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取决于材料。</font><font style="vertical-align: inherit;">可以是（0.2，0.3，0.4）; </font><font style="vertical-align: inherit;">没有严格的规则。</font><font style="vertical-align: inherit;">当然，我无法抗拒在自己的DX11框架中实现此功能，这是所有</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturatedColor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">均等于float3（0.25，0.3，0.45）的结果</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12f/184/2d9/12f1842d9d272fc057f35bc73439c4c1.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 1.0（无效）</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/ead/3a3/03cead3a3d5a713e051e7d863d99ecb0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 2.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caf/c81/992/cafc81992ebb70914c1e9d6605b8ba17.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 3.0</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f37/193/7fb/f371937fb39f94a887410a951f9eb628.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desaturationFactor = 4.0</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我确定这只是材料参数的应用，而不是在反照率部分的末尾执行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第15-20行添加了最后的接触：</font><font style="vertical-align: inherit;">v0.z是顶点着色器的输出，它们为零。</font><font style="vertical-align: inherit;">不要忘记它，因为v0.z将在以后使用两次。</font><font style="vertical-align: inherit;">看起来这是某种系数，整个代码看起来有点暗淡反照率，但是由于v0.z为0，因此颜色保持不变。</font><font style="vertical-align: inherit;">HLSL：</font><font style="vertical-align: inherit;">关于RT0.a，我们可以看到，它是从材质常量缓冲区中获取的，但是由于着色器没有调试信息，因此很难说出它是什么。</font><font style="vertical-align: inherit;">也许半透明？</font><font style="vertical-align: inherit;">我们已经完成了第一个渲染目标！</font></font><br><br> <code>15: max r1.w, r1.z, r1.y <br> 16: max r1.w, r1.w, r1.x <br> 17: lt r1.w, l(0.220000), r1.w <br> 18: movc r1.w, r1.w, l(-0.300000), l(-0.150000) <br> 19: mad r1.w, v0.z, r1.w, l(1.000000) <br> 20: mul o0.xyz, r1.wwww, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* ALBEDO */ <br> //     (?) <br> float3 albedoColor = albedoColorFilter( colorTex, cb4_v1.x, cb4_v0.rgb ); <br> float albedoMaxComponent = getMaxComponent( albedoColor ); <br> <br> //   ,   <br> //       "paramZ"   0 <br> float paramZ = Input.out0.z; // ,    0 <br> <br> // ,  0.70  0.85      <br> //       lerp,     . <br> float param = (albedoMaxComponent &gt; 0.22) ? 0.70 : 0.85; <br> float mulParam = lerp(1, param, paramZ); <br> <br> //  <br> pout.RT0.rgb = albedoColor * mulParam; <br> pout.RT0.a = cb4_v2.x;</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 正常的 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们首先打开法线贴图的包装，然后像往常一样绑定法线：</font><font style="vertical-align: inherit;">到目前为止，不足为奇。</font><i><font style="vertical-align: inherit;">看一下28-33行：</font></i><font style="vertical-align: inherit;">我们可以大致如下编写它们：</font><font style="vertical-align: inherit;">不知道编写是否正确。</font><font style="vertical-align: inherit;">如果您知道这个数学运算是什么，请告诉我。</font><font style="vertical-align: inherit;">我们看到像素着色器使用了SV_IsFrontFace。</font></font><br><br> <code>/*  */ <br> float3 sampledNormal = ((normalTex.xyz - 0.5) * 2); <br> <br> //     TBN <br> float3 Tangent = Input.TangentW.xyz; <br> float3 Normal = Input.NormalW.xyz; <br> float3 Bitangent; <br> Bitangent.x = Input.out0.w; <br> Bitangent.yz = Input.out1.zw; <br> <br> //      ;  ,  ,   normal-tbn <br> //      'mad'   'mov' <br> Bitangent = saturate(Bitangent); <br> <br> float3x3 TBN = float3x3(Tangent, Bitangent, Normal); <br> float3 normal = mul( sampledNormal, TBN );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <i><font style="vertical-align: inherit;"></font></i> <br><br> <code>28: uge r1.x, l(0), v4.x <br> 29: if_nz r1.x <br> 30: dp3 r1.x, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r1.xxxx, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>[branch] if (bIsFrontFace &lt;= 0) <br> { <br> float cosTheta = dot(Input.NormalW, normal); <br> float3 invNormal = cosTheta * Input.NormalW; <br> normal = normal - 2*invNormal; <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> 这是什么<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以帮助您</font><font style="vertical-align: inherit;">（我想写“ msdn”，但是...）：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">确定三角形是否在看着相机。</font><font style="vertical-align: inherit;">对于线和点，IsFrontFace为true。</font><font style="vertical-align: inherit;">一个例外是从三角形绘制的线（线框模式），其设置IsFrontFace类似于在实体模式下栅格化三角形。</font><font style="vertical-align: inherit;">可以通过几何体着色器进行写入，并通过像素着色器进行读取。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想自己检查一下。</font><font style="vertical-align: inherit;">实际上，这种效果仅在线框模式下才明显。</font><font style="vertical-align: inherit;">我相信这段代码是线框模式下正确计算法线（并因此计算照明）所必需的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行比较：启用/禁用此技巧的完成场景的帧颜色，以及启用/禁用此技巧的gbuffer [0-1]法线的纹理：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/46b/81b/59846b81b8b9ed57f0441f29e22e6656.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现场色彩毫不费力</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/590/7e1/a97/5907e1a978e58b6fa362ef2e4b6187a8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色彩特技表演</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/09a/c0e/74509ac0e56fa639ec4ae2d70a39be44.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">普通[0-1]绝招</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db8/2f8/622/db82f86223182135807d316fe479ff08.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常[0-1]的技巧</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您是否注意到GBuffer中的每个渲染目标都具有R8G8B8A8_UNORM格式？这意味着每个组件有256个可能的值。这足以存储法线吗？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Gbuffer中存储具有足够字节数的高质量法线是一个已知问题，但是幸运的是，</font><font style="vertical-align: inherit;">可以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">学习</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">许多</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的</font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">材料</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">也许有些人已经知道这里使用了什么技术。我必须说，在几何图形的整个过程中，插槽13附加了一个附加纹理...：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/e4a/0bf/ab1e4a0bf128bfed8837d3cd081748f8.jpg"></div><br><br> 哈！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巫师3使用一种称为“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最佳拟合法线</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ” </font><font style="vertical-align: inherit;">的技术</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这里，我将不进行详细解释（请参阅演示文稿）。</font><font style="vertical-align: inherit;">它是Crytek在2009-2010年左右发明的，并且由于CryEngine具有开源功能，因此BFN也是</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开源的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BFN使法线纹理具有“粒状”外观。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用BFN缩放法线后，我们将其从[-1; 1]间隔重新编码为[0，1]。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 高光 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从第34行开始，对镜面纹理进行采样：</font><font style="vertical-align: inherit;">如您所见，我们从Albedo那里知道有一个“变暗”滤镜：我们</font><font style="vertical-align: inherit;">计算出最大的分量。</font><font style="vertical-align: inherit;">值，然后计算“变暗”的颜色并使用原始镜面反射颜色进行插值，并从顶点着色器中获取参数...为0，因此在输出时，我们从纹理中获取颜色。</font><font style="vertical-align: inherit;">HLSL：</font></font><br><br> <code>34: sample_indexable(texture2d)(float,float,float,float) r1.xyz, v1.xyxx, t2.xyzw, s0 <br> 35: max r1.w, r1.z, r1.y <br> 36: max r1.w, r1.w, r1.x <br> 37: lt r1.w, l(0.200000), r1.w <br> 38: movc r2.xyz, r1.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 39: add r2.xyz, -r1.xyzx, r2.xyzx <br> 40: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>/* SPECULAR */ <br> float3 specularTex = texture2.Sample( samplerAnisoWrap, Texcoords ).rgb; <br> <br> //   ,    Albedo.  . ,    <br> // -        "". <br> //      paramZ   0,    <br> //  . <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> float3 specB = (specularMaxComponent &gt; 0.2) ? specularTex : float3(0.12, 0.12, 0.12); <br> float3 finalSpec = lerp(specularTex, specB, paramZ); <br> pout.RT2.xyz = finalSpec;</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 反射率 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不知道这个名称是否适合此参数，因为我不知道它如何影响照明的通过。</font><font style="vertical-align: inherit;">事实是输入法线贴图的Alpha通道包含其他数据：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d2/9e5/bd1/5d29e5bd1cb4888593139c38630e3f8e.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alpha通道纹理“法线贴图”。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汇编代码：</font><font style="vertical-align: inherit;">向我们的老朋友问好-v0.z！</font><font style="vertical-align: inherit;">其含义类似于反照率和镜面反射：</font></font><br><br> <code>41: lt r1.x, r0.w, l(0.330000) <br> 42: mul r1.y, r0.w, l(0.950000) <br> 43: movc r1.x, r1.x, r1.y, l(0.330000) <br> 44: add r1.x, -r0.w, r1.x <br> 45: mad o1.w, v0.z, r1.x, r0.w</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>/* REFLECTIVITY */ <br> float reflectivity = normalTex.a; <br> float reflectivity2 = (reflectivity &lt; 0.33) ? (reflectivity * 0.95) : 0.33; <br> <br> float finalReflectivity = lerp(reflectivity, reflectivity2, paramZ); <br> pout.RT1.a = finalReflectivity;</code> <br> <br> 太好了！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">至此，对像素着色器的第一个版本进行了分析。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是我的着色器（左）与原始着色器（右）的比较：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/f18/47b/2c1f1847b5ceef3cd0e2f8dfba45d2a6.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这些差异不会影响计算，因此我在这里的工作已经完成。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像素着色器：反照率+普通选项 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我决定再显示一个选项，现在仅使用反照率和法线贴图，而没有镜面纹理。汇编代码稍长一些：</font><font style="vertical-align: inherit;">此选项与之前的选项之间的区别如下：</font><font style="vertical-align: inherit;">a）</font><b><font style="vertical-align: inherit;">第19行</font></b><font style="vertical-align: inherit;">：插值参数v0.z乘以常量缓冲区中的cb4 [0] .x，但此乘积仅用于第19行的插值反照率。对于其他输出，使用v0.z的“正常”值。</font><font style="vertical-align: inherit;">b）</font><b><font style="vertical-align: inherit;">第54-55行</font></b><font style="vertical-align: inherit;">：o2.w现在的设置条件是（cb4 [7] .x&gt; 0.0）</font><font style="vertical-align: inherit;">我们已经从亮度直方图的计算中识别出这种模式“某种比较</font><font style="vertical-align: inherit;">-AND </font><font style="vertical-align: inherit;">”。可以这样写：</font><font style="vertical-align: inherit;">c）</font><b><font style="vertical-align: inherit;">34-42行</font></b><font style="vertical-align: inherit;">：完全不同的镜面反射计算。</font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s13, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t1 <br> dcl_resource_texture2d (float,float,float,float) t13 <br> dcl_input_ps linear v0.zw <br> dcl_input_ps linear v1.xyzw <br> dcl_input_ps linear v2.xyz <br> dcl_input_ps linear v3.xyz <br> dcl_input_ps_sgv v4.x, isfrontface <br> dcl_output o0.xyzw <br> dcl_output o1.xyzw <br> dcl_output o2.xyzw <br> dcl_temps 4 <br> 0: mul r0.x, v0.z, cb4[0].x <br> 1: sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t1.xyzw, s0 <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.yzw, v1.xyxx, t0.wxyz, s0 <br> 3: add r2.x, r0.z, r0.y <br> 4: add r2.x, r0.w, r2.x <br> 5: add r2.z, l(-1.000000), cb4[2].x <br> 6: mul r2.yz, r2.xxzx, l(0.000000, 0.333300, 0.500000, 0.000000) <br> 7: mov_sat r2.w, r2.z <br> 8: mad r2.x, r2.x, l(-0.666600), l(1.000000) <br> 9: mad r2.x, r2.w, r2.x, r2.y <br> 10: mul r3.xyz, r0.yzwy, cb4[1].xyzx <br> 11: mul_sat r3.xyz, r3.xyzx, l(1.500000, 1.500000, 1.500000, 0.000000) <br> 12: mul_sat r2.x, abs(r2.z), r2.x <br> 13: add r2.yzw, -r0.yyzw, r3.xxyz <br> 14: mad r0.yzw, r2.xxxx, r2.yyzw, r0.yyzw <br> 15: max r2.x, r0.w, r0.z <br> 16: max r2.x, r0.y, r2.x <br> 17: lt r2.x, l(0.220000), r2.x <br> 18: movc r2.x, r2.x, l(-0.300000), l(-0.150000) <br> 19: mad r0.x, r0.x, r2.x, l(1.000000) <br> 20: mul o0.xyz, r0.xxxx, r0.yzwy <br> 21: add r0.xyz, r1.xyzx, l(-0.500000, -0.500000, -0.500000, 0.000000) <br> 22: add r0.xyz, r0.xyzx, r0.xyzx <br> 23: mov r1.x, v0.w <br> 24: mov r1.yz, v1.zzwz <br> 25: mul r1.xyz, r0.yyyy, r1.xyzx <br> 26: mad r0.xyw, v3.xyxz, r0.xxxx, r1.xyxz <br> 27: mad r0.xyz, v2.xyzx, r0.zzzz, r0.xywx <br> 28: uge r0.w, l(0), v4.x <br> 29: if_nz r0.w <br> 30: dp3 r0.w, v2.xyzx, r0.xyzx <br> 31: mul r1.xyz, r0.wwww, v2.xyzx <br> 32: mad r0.xyz, -r1.xyzx, l(2.000000, 2.000000, 2.000000, 0.000000), r0.xyzx <br> 33: endif <br> 34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx <br> 43: max r0.w, r1.z, r1.y <br> 44: max r0.w, r0.w, r1.x <br> 45: lt r0.w, l(0.200000), r0.w <br> 46: movc r2.xyz, r0.wwww, r1.xyzx, l(0.120000, 0.120000, 0.120000, 0.000000) <br> 47: add r2.xyz, -r1.xyzx, r2.xyzx <br> 48: mad o2.xyz, v0.zzzz, r2.xyzx, r1.xyzx <br> 49: lt r0.w, r1.w, l(0.330000) <br> 50: mul r1.x, r1.w, l(0.950000) <br> 51: movc r0.w, r0.w, r1.x, l(0.330000) <br> 52: add r0.w, -r1.w, r0.w <br> 53: mad o1.w, v0.z, r0.w, r1.w <br> 54: lt r0.w, l(0), cb4[7].x <br> 55: and o2.w, r0.w, l(0.064706) <br> 56: dp3 r0.w, r0.xyzx, r0.xyzx <br> 57: rsq r0.w, r0.w <br> 58: mul r0.xyz, r0.wwww, r0.xyzx <br> 59: max r0.w, abs(r0.y), abs(r0.x) <br> 60: max r0.w, r0.w, abs(r0.z) <br> 61: lt r1.xy, abs(r0.zyzz), r0.wwww <br> 62: movc r1.yz, r1.yyyy, abs(r0.zzyz), abs(r0.zzxz) <br> 63: movc r1.xy, r1.xxxx, r1.yzyy, abs(r0.yxyy) <br> 64: lt r1.z, r1.y, r1.x <br> 65: movc r1.xy, r1.zzzz, r1.xyxx, r1.yxyy <br> 66: div r1.z, r1.y, r1.x <br> 67: div r0.xyz, r0.xyzx, r0.wwww <br> 68: sample_l(texture2d)(float,float,float,float) r0.w, r1.xzxx, t13.yzwx, s13, l(0) <br> 69: mul r0.xyz, r0.wwww, r0.xyzx <br> 70: mad o1.xyz, r0.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000), l(0.500000, 0.500000, 0.500000, 0.000000) <br> 71: mov o0.w, cb4[6].x <br> 72: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>pout.RT2.w = (cb4_v7.x &gt; 0.0) ? (16.5/255.0) : 0.0;</code> <br> <br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里没有镜面反射纹理。</font><font style="vertical-align: inherit;">让我们看一下负责这部分的汇编代码：</font><font style="vertical-align: inherit;">请注意，我们在这里使用了（1-反映能力）。</font><font style="vertical-align: inherit;">幸运的是，用HLSL编写此代码非常简单：</font><font style="vertical-align: inherit;">我要补充一点，在此版本中，包含材质数据的常量缓冲区会稍大。</font><font style="vertical-align: inherit;">在这里，这些附加值用于模拟镜面反射颜色。</font><font style="vertical-align: inherit;">着色器的其余部分与以前的版本相同。</font><font style="vertical-align: inherit;">在WinMerge中无法显示72行汇编程序代码，因此请相信：我的代码与原始代码几乎相同。</font><font style="vertical-align: inherit;">或者，您可以下载我的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">HLSLexplorer</font></a><font style="vertical-align: inherit;">并亲自查看！</font></font><br><br> <code>34: add r0.w, -r1.w, l(1.000000) <br> 35: log r1.xyz, cb4[3].xyzx <br> 36: mul r1.xyz, r1.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 37: exp r1.xyz, r1.xyzx <br> 38: mad r0.w, r0.w, cb4[4].x, cb4[5].x <br> 39: mul_sat r1.xyz, r0.wwww, r1.xyzx <br> 40: log r1.xyz, r1.xyzx <br> 41: mul r1.xyz, r1.xyzx, l(0.454545, 0.454545, 0.454545, 0.000000) <br> 42: exp r1.xyz, r1.xyzx</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>float oneMinusReflectivity = 1.0 - normalTex.a; <br> float3 specularTex = pow(cb4_v3.rgb, 2.2); <br> oneMinusReflectivity = oneMinusReflectivity * cb4_v4.x + cb4_v5.x; <br> specularTex = saturate(specularTex * oneMinusReflectivity); <br> specularTex = pow(specularTex, 1.0/2.2); <br> <br> //     ... <br> float specularMaxComponent = getMaxComponent( specularTex ); <br> ...</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 总结一下 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...如果您在这里阅读过，那么您可能想更深入一点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在现实生活中看起来简单的事情通常并非如此，并且将数据传输到gbuffer Witcher 3也不例外。</font><font style="vertical-align: inherit;">我仅向您展示了负责此功能的最简单版本的像素着色器，还提供了与一般延迟着色有关的常规观察结果。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于大多数患者，pastebin中的像素着色器有两个选项：</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项1-具有镜面纹理</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项2-不具有镜面纹理</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第10部分。远方的雨帘 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一部分中，我们将看到我真正喜欢的一种奇妙的大气效果- </font><font style="vertical-align: inherit;">地平线附近的</font><font style="vertical-align: inherit;">远处</font><font style="vertical-align: inherit;">雨/ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">光幕</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在游戏中，他们最容易在斯凯利格群岛见面。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VXt4PEEqV2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就个人而言，我真的很喜欢这种大气现象，并且很好奇CD Projekt Red图形程序员是如何实现的。</font><font style="vertical-align: inherit;">让我们弄清楚！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是应用雨帘前后的两个屏幕截图：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/62a/eb6/a9a62aeb6050efd2404f9d352fc89d33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到雨帘</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9aa/e43/fcf/9aae43fcf34413a4810778e101b8a209.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">雨后的窗帘</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几何形状 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我们将重点放在几何上。</font><font style="vertical-align: inherit;">这个想法是使用一个小圆柱体：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc4/df3/add/fc4df3addf2524bc18f91c46a42fcd6a.jpg"></div><br> <i><font style="vertical-align: inherit;"></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从</font><i><font style="vertical-align: inherit;">局部空间中</font></i><font style="vertical-align: inherit;">的位置来看，</font><i><font style="vertical-align: inherit;">圆柱体</font></i><font style="vertical-align: inherit;">非常小-位置在（0.0-1.0）范围内。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此绘图调用的输入电路如下所示：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1d/a35/c00/c1da35c0080225e7a47d8010c42aeab8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下对我们而言很重要：Texcoords和Instance_Transform。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texcoords的包装非常简单：上，下两个碱基的U在[0.02777-1.02734]区间内。较低基数的V为1.0，较高基数的V为0.0。如您所见，您甚至可以在过程上非常简单地创建此网格。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本地空间中收到了这个小圆柱体后，我们将其乘以为输入元素INSTANCE_TRANSFORM的每个实例提供的世界矩阵。让我们检查一下这个矩阵的值：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e88/791/17e/e8879117edb6f1dd9b53d3e7334a22df.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/fb8/697/adffb8697a86ac86b935a00d6ae23dda.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/608/599/f6c/608599f6cf3930889c92df1a256991af.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来很吓人吧？</font><font style="vertical-align: inherit;">但请放心，我们将分析此矩阵并查看其隐藏的内容！</font><font style="vertical-align: inherit;">结果非常有趣：</font><font style="vertical-align: inherit;">了解相机在此特定帧中的位置很重要：（-116.5338、234.8695、2.09）</font><font style="vertical-align: inherit;">如您所见，我们缩放了圆柱体以使其在世界空间中相当大（在TW3中Z轴朝上），相对于相机位置移动了圆柱体，然后转身。</font><font style="vertical-align: inherit;">使用顶点着色器进行转换后，圆柱体的外观如下：</font></font><br><br> <code>XMMATRIX mat( -227.7472, 159.8043, 374.0736, -116.4951, <br> -194.7577, -173.3836, -494.4982, 238.6908, <br> -14.16466, -185.4743, 784.564, -1.45565, <br> 0.0, 0.0, 0.0, 1.0 ); <br> <br> mat = XMMatrixTranspose( mat ); <br> <br> XMVECTOR vScale; <br> XMVECTOR vRotateQuat; <br> XMVECTOR vTranslation; <br> XMMatrixDecompose( &amp;vScale, &amp;vRotateQuat, &amp;vTranslation, mat ); <br> <br> //  ... <br> XMMATRIX matRotate = XMMatrixRotationQuaternion( vRotateQuat );</code> <br> <br><font style="vertical-align: inherit;"></font><br><br> <code>vRotateQuat: (0.0924987569, -0.314900011, 0.883411944, -0.334462732) <br> <br> vScale: (299.999969, 300.000000, 1000.00012) <br> <br> vTranslation: (-116.495102, 238.690796, -1.45564997)</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f60/457/ca6/f60457ca61dd2d15ec3805b387e71def.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顶点着色器转换后的圆柱体。</font><font style="vertical-align: inherit;">查看它相对于能见度金字塔的位置。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 顶点着色器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入几何图形和顶点着色器严格相互依赖。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们仔细看一下顶点着色器的汇编代码：</font><font style="vertical-align: inherit;">连同简单传递的Texcoords（第0行）和Instance_LOD_Params（第8行）一起，还需要两个元素来输出：SV_Position（这很明显）和Height（组件.z）在世界上的位置。</font><font style="vertical-align: inherit;">还记得本地空间在[0-1]范围内吗？因此，在应用世界矩阵之前，顶点着色器将使用比例和偏差来更改局部位置。聪明的举动！</font><font style="vertical-align: inherit;">在这种情况下，scale = float3（4，4，2），bias = float3（-2，-2，-1）&lt; </font><font style="vertical-align: inherit;">第9和28行之间值得注意的模式是两个行主矩阵的乘积。</font><font style="vertical-align: inherit;">让我们看一下HLSL上完成的顶点着色器：</font></font><br><br> <code>vs_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb1[7], immediateIndexed <br> dcl_constantbuffer cb2[6], immediateIndexed <br> dcl_input v0.xyz <br> dcl_input v1.xy <br> dcl_input v4.xyzw <br> dcl_input v5.xyzw <br> dcl_input v6.xyzw <br> dcl_input v7.xyzw <br> dcl_output o0.xyz <br> dcl_output o1.xyzw <br> dcl_output_siv o2.xyzw, position <br> dcl_temps 2 <br> 0: mov o0.xy, v1.xyxx <br> 1: mul r0.xyzw, v5.xyzw, cb1[6].yyyy <br> 2: mad r0.xyzw, v4.xyzw, cb1[6].xxxx, r0.xyzw <br> 3: mad r0.xyzw, v6.xyzw, cb1[6].zzzz, r0.xyzw <br> 4: mad r0.xyzw, cb1[6].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 5: mad r1.xyz, v0.xyzx, cb2[4].xyzx, cb2[5].xyzx <br> 6: mov r1.w, l(1.000000) <br> 7: dp4 o0.z, r1.xyzw, r0.xyzw <br> 8: mov o1.xyzw, v7.xyzw <br> 9: mul r0.xyzw, v5.xyzw, cb1[0].yyyy <br> 10: mad r0.xyzw, v4.xyzw, cb1[0].xxxx, r0.xyzw <br> 11: mad r0.xyzw, v6.xyzw, cb1[0].zzzz, r0.xyzw <br> 12: mad r0.xyzw, cb1[0].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 13: dp4 o2.x, r1.xyzw, r0.xyzw <br> 14: mul r0.xyzw, v5.xyzw, cb1[1].yyyy <br> 15: mad r0.xyzw, v4.xyzw, cb1[1].xxxx, r0.xyzw <br> 16: mad r0.xyzw, v6.xyzw, cb1[1].zzzz, r0.xyzw <br> 17: mad r0.xyzw, cb1[1].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 18: dp4 o2.y, r1.xyzw, r0.xyzw <br> 19: mul r0.xyzw, v5.xyzw, cb1[2].yyyy <br> 20: mad r0.xyzw, v4.xyzw, cb1[2].xxxx, r0.xyzw <br> 21: mad r0.xyzw, v6.xyzw, cb1[2].zzzz, r0.xyzw <br> 22: mad r0.xyzw, cb1[2].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 23: dp4 o2.z, r1.xyzw, r0.xyzw <br> 24: mul r0.xyzw, v5.xyzw, cb1[3].yyyy <br> 25: mad r0.xyzw, v4.xyzw, cb1[3].xxxx, r0.xyzw <br> 26: mad r0.xyzw, v6.xyzw, cb1[3].zzzz, r0.xyzw <br> 27: mad r0.xyzw, cb1[3].wwww, l(0.000000, 0.000000, 0.000000, 1.000000), r0.xyzw <br> 28: dp4 o2.w, r1.xyzw, r0.xyzw <br> 29: ret</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br> <code>cbuffer cbPerFrame : register (b1) <br> { <br> row_major float4x4 g_viewProjMatrix; <br> row_major float4x4 g_rainShaftsViewProjMatrix; <br> } <br> <br> cbuffer cbPerObject : register (b2) <br> { <br> float4x4 g_mtxWorld; <br> float4 g_modelScale; <br> float4 g_modelBias; <br> } <br> <br> struct VS_INPUT <br> { <br> float3 PositionW : POSITION; <br> float2 Texcoord : TEXCOORD; <br> float3 NormalW : NORMAL; <br> float3 TangentW : TANGENT; <br> float4 InstanceTransform0 : INSTANCE_TRANSFORM0; <br> float4 InstanceTransform1 : INSTANCE_TRANSFORM1; <br> float4 InstanceTransform2 : INSTANCE_TRANSFORM2; <br> float4 InstanceLODParams : INSTANCE_LOD_PARAMS; <br> }; <br> <br> struct VS_OUTPUT <br> { <br> float3 TexcoordAndZ : Texcoord0; <br> <br> float4 LODParams : LODParams; <br> float4 PositionH : SV_Position; <br> }; <br> <br> VS_OUTPUT RainShaftsVS( VS_INPUT Input ) <br> { <br> VS_OUTPUT Output = (VS_OUTPUT)0; <br> <br> //    <br> Output.TexcoordAndZ.xy = Input.Texcoord; <br> Output.LODParams = Input.InstanceLODParams; <br> <br> //   <br> float3 meshScale = g_modelScale.xyz; // float3( 4, 4, 2 ); <br> float3 meshBias = g_modelBias.xyz; // float3( -2, -2, -1 ); <br> float3 PositionL = Input.PositionW * meshScale + meshBias; <br> <br> //    instanceWorld  float4s: <br> float4x4 matInstanceWorld = float4x4(Input.InstanceTransform0, Input.InstanceTransform1, <br> Input.InstanceTransform2 , float4(0, 0, 0, 1) ); <br> <br> //     (.z) <br> float4x4 matWorldInstanceLod = mul( g_rainShaftsViewProjMatrix, matInstanceWorld ); <br> Output.TexcoordAndZ.z = mul( float4(PositionL, 1.0), transpose(matWorldInstanceLod) ).z; <br> <br> // SV_Posiiton <br> float4x4 matModelViewProjection = mul(g_viewProjMatrix, matInstanceWorld ); <br> Output.PositionH = mul( float4(PositionL, 1.0), transpose(matModelViewProjection) ); <br> <br> return Output; <br> }</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我的着色器（左）和原始着色器（右）的比较： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef3/4f3/4ed/ef34f34edbc63113a08f47b7cde00df0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差异不影响计算。</font><font style="vertical-align: inherit;">我将着色器注入框架，一切仍然很好！</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像素着色器 </font></font></h3><br> 终于！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我将向您展示输入：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处使用两个纹理：噪声纹理和深度缓冲区：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/83a/558/fc3/83a558fc3c8c7e723eb85308b12657d6.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/0da/111/db50da111880f6b934d8bed6b74491e6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 来自常量缓冲区的值： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a12/394/bdc/a12394bdc039e522beeff97b8e41cd80.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/37a/c47/485/37ac47485335960b2efbefc9f315ef14.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/e70/38a/4e7e7038a1bc956aadbb695d70b80ded.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/775/bc4/7ae775bc4a9388feceaa1ddf8c0a214a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 以及像素着色器的汇编代码： </font></font><br><br> <code>ps_5_0 <br> dcl_globalFlags refactoringAllowed <br> dcl_constantbuffer cb0[8], immediateIndexed <br> dcl_constantbuffer cb2[3], immediateIndexed <br> dcl_constantbuffer cb12[23], immediateIndexed <br> dcl_constantbuffer cb4[8], immediateIndexed <br> dcl_sampler s0, mode_default <br> dcl_sampler s15, mode_default <br> dcl_resource_texture2d (float,float,float,float) t0 <br> dcl_resource_texture2d (float,float,float,float) t15 <br> dcl_input_ps linear v0.xyz <br> dcl_input_ps linear v1.w <br> dcl_input_ps_siv v2.xy, position <br> dcl_output o0.xyzw <br> dcl_temps 1 <br> 0: mul r0.xy, cb0[0].xxxx, cb4[5].xyxx <br> 1: mad r0.xy, v0.xyxx, cb4[4].xyxx, r0.xyxx <br> 2: sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t0.xyzw, s0 <br> 3: add r0.y, -cb4[2].x, cb4[3].x <br> 4: mad_sat r0.x, r0.x, r0.y, cb4[2].x <br> 5: mul r0.x, r0.x, v0.y <br> 6: mul r0.x, r0.x, v1.w <br> 7: mul r0.x, r0.x, cb4[1].x <br> 8: mul r0.yz, v2.xxyx, cb0[1].zzwz <br> 9: sample_l(texture2d)(float,float,float,float) r0.y, r0.yzyy, t15.yxzw, s15, l(0) <br> 10: mad r0.y, r0.y, cb12[22].x, cb12[22].y <br> 11: mad r0.y, r0.y, cb12[21].x, cb12[21].y <br> 12: max r0.y, r0.y, l(0.000100) <br> 13: div r0.y, l(1.000000, 1.000000, 1.000000, 1.000000), r0.y <br> 14: add r0.y, r0.y, -v0.z <br> 15: mul_sat r0.y, r0.y, cb4[6].x <br> 16: mul_sat r0.x, r0.y, r0.x <br> 17: mad r0.y, cb0[7].y, r0.x, -r0.x <br> 18: mad r0.x, cb4[7].x, r0.y, r0.x <br> 19: mul r0.xyz, r0.xxxx, cb4[0].xyzx <br> 20: log r0.xyz, r0.xyzx <br> 21: mul r0.xyz, r0.xyzx, l(2.200000, 2.200000, 2.200000, 0.000000) <br> 22: exp r0.xyz, r0.xyzx <br> 23: mul r0.xyz, r0.xyzx, cb2[2].xyzx <br> 24: mul o0.xyz, r0.xyzx, cb2[2].wwww <br> 25: mov o0.w, l(0) <br> 26: ret</code> <br> <br> 哇！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数量很多，但实际上，一切还不错。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是怎么回事 </font><font style="vertical-align: inherit;">首先，我们使用从cbuffer（cb0 [0] .x）开始的时间和缩放/偏移量来计算动画UV。</font><font style="vertical-align: inherit;">这些texcoords用于从噪声纹理中采样（第2行）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从纹理接收到噪声值后，我们在最小值/最大值之间进行插值（通常为0和1）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后，我们通过乘以纹理V的坐标（请记住V坐标从1到0？）进行乘法（第5行）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们计算了“亮度蒙版”，它看起来像这样：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/1a8/801/0641a88012fb6ec18797c0b143fb5f27.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，远处的物体（灯塔，山脉...）已消失。</font><font style="vertical-align: inherit;">发生这种情况是因为圆柱体通过了深度测试-圆柱体不在远平面上，而是绘制在以下对象的顶部：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/8f5/ffd/1068f5ffde6b0efba2c4894b88d5ddf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度测试</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们想模拟雨幕更远（但不一定在远平面上）。</font><font style="vertical-align: inherit;">为此，我们计算了另一个蒙版，即“远处对象的蒙版”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它是通过以下公式计算的：（</font></font><br><br> <code>farObjectsMask = saturate( (FrustumDepth - CylinderWorldSpaceHeight) * 0.001 );</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从缓冲区中提取0.001），这为我们提供了所需的掩码：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/02a/153/9ff02a1534054fb27b370d5cd58e7a75.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在有关“锐化”效果的部分中，我已经简要地解释了如何从深度缓冲区中提取可见性金字塔的深度。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就我个人而言，如果不通过将可见性金字塔的深度乘以较小的数字来计算世界空间中的高度，就可以实现这种效果的成本更低。 0.0004。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当两个遮罩相乘时，获得最后一个：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/fb2/c1e/c49fb2c1e1dd2ee8d38d81c0cccb0daf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">收到此最终蒙版（第16行）后，我们执行另一次插值，该操作几乎不执行任何操作（至少在测试情况下如此），然后将最终蒙版乘以窗帘的颜色（第19行），执行伽玛校正（第20行） -22）和最终乘法（23-24）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，我们返回Alpha值为零的颜色。这是因为在此过程中启用了混合：</font></font><br><br> <code>FinalColor = SourceColor * 1.0 + (1.0 - SourceAlpha) * DestColor</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果您不太了解混合的工作方式，则简要说明一下：</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SourceColor是像素着色器的RGB输出，DestColor是渲染目标中像素的当前RGB颜色。 。由于SourceAlpha总是等于0.0，上述等式简化为：</font></font><code>FinalColor = SourceColor + DestColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简而言之，我们在这里进行添加剂混合。</font><font style="vertical-align: inherit;">如果像素着色器返回（0，0，0），则颜色将保持不变。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是完整的HLSL代码-我认为在解释之后，它会更容易理解：</font><font style="vertical-align: inherit;">我可以很高兴地说我的像素着色器创建的代码与原始代码相同。</font><font style="vertical-align: inherit;">希望您喜欢这篇文章。</font><font style="vertical-align: inherit;">感谢您的阅读！</font></font><br><br> <code>struct VS_OUTPUT <br> { <br> float3 TexcoordAndWorldspaceHeight : Texcoord0; <br> float4 LODParams : LODParams; // float4(1,1,1,1) <br> float4 PositionH : SV_Position; <br> }; <br> <br> float getFrustumDepth( in float depth ) <br> { <br> // from [1-0] to [0-1] <br> float d = depth * cb12_v22.x + cb12_v22.y; <br> <br> // special coefficents <br> d = d * cb12_v21.x + cb12_v21.y; <br> <br> // return frustum depth <br> return 1.0 / max(d, 1e-4); <br> } <br> <br> float4 EditedShaderPS( in VS_OUTPUT Input ) : SV_Target0 <br> { <br> // * Input from Vertex Shader <br> float2 InputUV = Input.TexcoordAndWorldspaceHeight.xy; <br> float WorldHeight = Input.TexcoordAndWorldspaceHeight.z; <br> float LODParam = Input.LODParams.w; <br> <br> // * Inputs <br> float elapsedTime = cb0_v0.x; <br> float2 uvAnimation = cb4_v5.xy; <br> float2 uvScale = cb4_v4.xy; <br> float minValue = cb4_v2.x; // 0.0 <br> float maxValue = cb4_v3.x; // 1.0 <br> float3 shaftsColor = cb4_v0.rgb; // RGB( 147, 162, 173 ) <br> <br> float3 finalColorFilter = cb2_v2.rgb; // float3( 1.175, 1.296, 1.342 ); <br> float finalEffectIntensity = cb2_v2.w; <br> <br> float2 invViewportSize = cb0_v1.zw; <br> <br> float depthScale = cb4_v6.x; // 0.001 <br> <br> // sample noise <br> float2 uvOffsets = elapsedTime * uvAnimation; <br> float2 uv = InputUV * uvScale + uvOffsets; <br> float disturb = texture0.Sample( sampler0, uv ).x; <br> <br> // * Intensity mask <br> float intensity = saturate( lerp(minValue, maxValue, disturb) ); <br> intensity *= InputUV.y; // transition from (0, 1) <br> intensity *= LODParam; // usually 1.0 <br> intensity *= cb4_v1.x; // 1.0 <br> <br> // Sample depth <br> float2 ScreenUV = Input.PositionH.xy * invViewportSize; <br> float hardwareDepth = texture15.SampleLevel( sampler15, ScreenUV, 0 ).x; <br> float frustumDepth = getFrustumDepth( hardwareDepth ); <br> <br> <br> // * Calculate mask covering distant objects behind cylinder. <br> <br> // Seems that the input really is world-space height (.z component, see vertex shader) <br> float depth = frustumDepth - WorldHeight; <br> float distantObjectsMask = saturate( depth * depthScale ); <br> <br> // * calculate final mask <br> float finalEffectMask = saturate( intensity * distantObjectsMask ); <br> <br> // cb0_v7.y and cb4_v7.x are set to 1.0 so I didn't bother with naming them :) <br> float paramX = finalEffectMask; <br> float paramY = cb0_v7.y * finalEffectMask; <br> float effectAmount = lerp(paramX, paramY, cb4_v7.x); <br> <br> // color of shafts comes from contant buffer <br> float3 effectColor = effectAmount * shaftsColor; <br> <br> // gamma correction <br> effectColor = pow(effectColor, 2.2); <br> <br> // final multiplications <br> effectColor *= finalColorFilter; <br> effectColor *= finalEffectIntensity; <br> <br> // return with zero alpha 'cause the blending used here is: <br> // SourceColor * 1.0 + (1.0 - SrcAlpha) * DestColor <br> return float4( effectColor, 0.0 ); <br> }</code> <br> <br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437100/">https://habr.com/ru/post/zh-CN437100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437088/index.html">在国外推广初创企业：如何通过中级受众吸引成千上万的英语读者</a></li>
<li><a href="../zh-CN437092/index.html">机器学习算法的安全性。 Python攻击</a></li>
<li><a href="../zh-CN437094/index.html">我们抽了Atlassian服务台-mitap的公告和现场直播</a></li>
<li><a href="../zh-CN437096/index.html">UDB。 这是什么 第4部分。数据路径ALU</a></li>
<li><a href="../zh-CN437098/index.html">2月6日，莫斯科，DI电报-产品设计中的大型QIWI厨房</a></li>
<li><a href="../zh-CN437102/index.html">新乐高冠军聚会：乐高助推器</a></li>
<li><a href="../zh-CN437104/index.html">Introscope：好，非常懒惰的单元测试</a></li>
<li><a href="../zh-CN437106/index.html">区域中的IT</a></li>
<li><a href="../zh-CN437108/index.html">互联网上的大多数文本都是疯子写的。</a></li>
<li><a href="../zh-CN437110/index.html">纳米材料正在改变我们的世界，我们仍然没有检查其安全性的程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>