<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåè üò¥ üëéüèΩ Shader n'est pas magique. √âcriture de shaders dans Unity. Vertex Shaders üñ•Ô∏è üëäüèæ üî•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Je m'appelle Grigory Dyadichenko et je suis le fondateur et directeur technique de Foxsys Studios. Aujourd'hui, nous allons parler des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shader n'est pas magique. √âcriture de shaders dans Unity. Vertex Shaders</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474812/">  Bonjour √† tous!  Je m'appelle Grigory Dyadichenko et je suis le fondateur et directeur technique de Foxsys Studios.  Aujourd'hui, nous allons parler des vertex shaders.  L'article examinera la pratique du point de vue de Unity, des exemples tr√®s simples, ainsi que de nombreux liens pour √©tudier des informations sur les shaders dans Unity.  Si vous savez √©crire des shaders, vous ne trouverez rien de nouveau pour vous.  Quiconque veut commencer √† √©crire des shaders dans Unity, bienvenue sur cat. <br><br><img src="https://habrastorage.org/webt/zr/9n/wy/zr9nwyvbjnky73iqvvuvvzxpyjs.jpeg"><br><a name="habracut"></a><br><h3>  Un peu de th√©orie </h3><br><br>  Pour mieux comprendre le processus du shader, jetons un coup d'≈ìil √† une petite th√©orie.  Un vertex shader ou vertex shader est une √©tape programmable d'un shader qui fonctionne avec des vertex individuels.  Les sommets stockent √† leur tour divers attributs qui sont trait√©s par cette partie du shader afin d'obtenir des attributs convertis √† la sortie. <br><br><h3>  Exemples d'utilisation de vertex shaders </h3><br><br><img src="https://habrastorage.org/webt/fk/ry/kc/fkrykcsixvzaihfaa4g6jajebk4.jpeg"><br><br>  <b>D√©formation des objets</b> - vagues r√©alistes, effet des ondulations de la pluie, d√©formation lorsqu'une balle frappe, tout cela peut √™tre fait avec des vertex shaders, et cela aura l'air plus r√©aliste que la m√™me chose faite via Bump Mapping dans la partie fragment du shader.  Puisqu'il s'agit d'un changement de g√©om√©trie.  Les shaders de niveau 3.0 sur ce sujet ont une technique appel√©e mappage de dispersion, car ils ont d√©sormais acc√®s aux textures dans la partie vertex du shader. <br><br><img src="https://habrastorage.org/webt/8e/tb/uu/8etbuufscvxpmvx3acs8irusgag.jpeg"><br><br>  <b>Animation d'objets.</b>  Les jeux semblent plus vivants et int√©ressants lorsque les plantes r√©agissent √† un personnage ou que les arbres se balancent au vent.  Pour cela, des vertex shaders sont √©galement utilis√©s. <br><br><img src="https://habrastorage.org/webt/cu/ov/vk/cuovvkcufzn0jn0351xjw9bzfso.jpeg"><br><br>  <b>√âclairage de dessin anim√© ou stylis√©.</b>  Dans de nombreux jeux, du point de vue du style, ce n'est pas l'√©clairage pbr qui semble beaucoup plus int√©ressant, mais la stylisation.  En m√™me temps, cela n'a aucun sens de calculer quoi que ce soit dans la partie fragment. <br><br><img src="https://habrastorage.org/webt/m1/8a/km/m18akmnn364xlwyrh_0r5pb_zjc.png"><br><br>  <b>D√©pouillement.</b>  √Ä un moment donn√© dans les moteurs de jeu, ce probl√®me est r√©solu, mais il est n√©anmoins utile de comprendre les vertex shaders afin de comprendre comment cela fonctionne. <br><br><h3>  Exemples simples de travail avec des sommets </h3><br><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"><br><br>  Je ne veux pas que cela se produise, comme dans les anciennes le√ßons sur la fa√ßon de dessiner un hibou, alors allons-y par √©tapes.  Cr√©ez un ombrage de surface standard.  Cela peut √™tre fait avec le bouton droit de la souris dans la vue du projet ou dans le panneau sup√©rieur de l'onglet Actifs.  Cr√©er-&gt; Shader-&gt; Shader de surface standard. <br><br>  Et nous obtenons un tel blanc standard. <br><br><div class="spoiler">  <b class="spoiler_title">Shader de surface</b> <div class="spoiler_text"><code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _MainTex ("Albedo (RGB)", 2D) = "white" {} <br> _Glossiness ("Smoothness", Range(0,1)) = 0.5 <br> _Metallic ("Metallic", Range(0,1)) = 0.0 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> // Physically based Standard lighting model, and enable shadows on all light types <br> #pragma surface surf Standard fullforwardshadows <br> <br> // Use shader model 3.0 target, to get nicer looking lighting <br> #pragma target 3.0 <br> <br> sampler2D _MainTex; <br> <br> struct Input <br> { <br> float2 uv_MainTex; <br> }; <br> <br> half _Glossiness; <br> half _Metallic; <br> fixed4 _Color; <br> <br> // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. <br> // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. <br> // #pragma instancing_options assumeuniformscaling <br> UNITY_INSTANCING_BUFFER_START(Props) <br> // put more per-instance properties here <br> UNITY_INSTANCING_BUFFER_END(Props) <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> // Albedo comes from a texture tinted by color <br> fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; <br> o.Albedo = c.rgb; <br> // Metallic and smoothness come from slider variables <br> o.Metallic = _Metallic; <br> o.Smoothness = _Glossiness; <br> o.Alpha = ca; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> }</code> </div> </div><br>  Comment cela fonctionne et en g√©n√©ral, nous allons l'analyser en d√©tail dans l'article apr√®s la pratique de base, plus nous le comprendrons partiellement lors de la mise en ≈ìuvre des shaders.  Pour l'instant, que certaines choses restent inchang√©es.  En bref, il n'y a pas de magie (en ce qui concerne la fa√ßon dont les param√®tres sont r√©cup√©r√©s, etc.) Juste pour certains mots cl√©s, l'unit√© g√©n√®re du code pour vous afin de ne pas l'√©crire √† partir de z√©ro.  Par cons√©quent, ce processus n'est pas assez √©vident.  Vous pouvez en savoir plus sur le shader de surface et ses propri√©t√©s dans Unity ici.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/Manual/SL-SurfaceShaders.html</a> <br><br>  Nous en retirerons tout ce qui est superflu pour ne pas le distraire, car √† un moment donn√© il n'est pas n√©cessaire.  Et obtenez un shader si court. <br><br><div class="spoiler">  <b class="spoiler_title">Shader simplifi√©</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/wg/po/iw/wgpoiwtso4uxmmipwrbvtnz1mek.jpeg"><br><br>  Juste la couleur du mod√®le avec √©clairage.  Dans ce cas, Unity est responsable du calcul de l'√©clairage. <br><br>  Tout d'abord, ajoutez l'effet le plus simple des exemples Unity.  L'extrusion est normale, et sur son exemple, nous analyserons son fonctionnement. <br><br>  Pour ce faire, ajoutez le modificateur <i>vertex: vert</i> √† la ligne <i>#pragma surface surf Standard fullforwardshadows</i> .  Si nous passons <i>inout appdata_full v en</i> tant que param√®tre √† une fonction, alors en substance cette fonction est un modificateur de sommet.  √Ä sa base, il fait partie du vertex shader, qui est cr√©√© par l'unit√© de g√©n√©ration de code, qui effectue un traitement pr√©liminaire des sommets.  Toujours dans le bloc <i>Propri√©t√©s</i> , ajoutez le champ <i>_Amount</i> acceptant des valeurs de 0 √† 1. Pour utiliser le champ <i>_Amount</i> dans le shader, nous devons √©galement le d√©finir √† cet <i>endroit</i> .  Dans la fonction, nous allons simplement passer √† la normale en fonction de <i>_Amount</i> , o√π 0 est la position standard du sommet (d√©calage z√©ro) et 1 est le d√©calage exactement √† la normale. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionShader</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amount ("Extrusion Amount", Range(0,1)) = 0.5 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amount; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amount; <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br>  Vous pouvez remarquer une caract√©ristique importante des shaders.  Bien que le shader soit ex√©cut√© √† chaque image, le r√©sultat obtenu lors de l'op√©ration du shader n'est pas stock√© dans le maillage, mais n'est utilis√© que pour le rendu.  Par cons√©quent, il est impossible de se rapporter aux fonctions du shader, ainsi qu'√† la <i>mise</i> √† <i>jour</i> dans les scripts.  Ils sont appliqu√©s √† chaque image sans changer les donn√©es du maillage, mais simplement en modifiant le maillage pour un rendu suppl√©mentaire. <br><br>  Par exemple, l'un des moyens les plus simples de cr√©er une animation consiste √† utiliser le temps pour modifier l'amplitude.  L'unit√© a des variables int√©gr√©es, dont une liste compl√®te peut √™tre trouv√©e ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a> Dans ce cas, nous √©crirons un nouveau shader bas√© sur notre shader pass√©.  Au lieu de <i>_Amount, faisons</i> la valeur flottante <i>_Amplitude</i> et utilisons la variable <i>int√©gr√©e</i> Unity <i>_SinTime</i> .  <i>_SinTime</i> est le sinus du temps, et donc il prend des valeurs de -1 √† 1. Cependant, n'oubliez pas que toutes les variables de temps int√©gr√©es dans les shaders unitaires sont des vecteurs <i>float4</i> .  Par exemple, <i>_SinTime est</i> d√©fini comme <i>(sin (t / 8), sin (t / 4), sin (t / 2), sin (t))</i> , o√π t est le temps.  Par cons√©quent, nous prenons le composant z pour que l'animation soit plus rapide.  Et nous obtenons: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionWithTime</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionWithTime" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amplitude ("Extrusion Amplitude", float) = 1 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amplitude; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amplitude * (1 - _SinTime.z); <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Votre navigateur ne prend pas en charge la vid√©o HTML5. <source src="https://i.giphy.com/media/U5UFh8tOZIAmDyZmzm/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Il s'agissait donc d'exemples simples.  Il est temps de dessiner un hibou! <br><br><h3>  D√©formation d'objets </h3><br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Votre navigateur ne prend pas en charge la vid√©o HTML5. <source src="https://media.giphy.com/media/pOwf43ETsackhG30CA/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  J'ai d√©j√† √©crit un article entier sur le sujet d'un effet de d√©formation avec une analyse d√©taill√©e des math√©matiques du processus et de la logique de la pens√©e lors du d√©veloppement d'un tel effet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">habr.com/en/post/435828</a> Ce sera notre chouette. <br><br>  Tous les shaders de l'article sont √©crits en hlsl.  Ce langage poss√®de en fait sa propre documentation volumineuse, dont beaucoup oublient et se demandent d'o√π viennent la moiti√© des fonctions c√¢bl√©es, bien qu'elles soient d√©finies dans HLSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl- fonctions intrins√®ques</a> <br><br>  Mais en fait, les shaders de surface dans une unit√© sont un sujet vaste et volumineux en soi.  De plus, vous ne voulez pas toujours jouer avec l'√©clairage Unity.  Parfois, vous devez tricher et √©crire le shader le plus rapide qui n'a que le bon ensemble d'effets pr√©d√©finis.  Dans l'unit√©, vous pouvez √©crire des shaders de niveau inf√©rieur. <br><br><h3>  Shaders de bas niveau </h3><br><br><img src="https://habrastorage.org/webt/k6/xx/bm/k6xxbmwnws5jw0bjy181o3q9ome.jpeg"><br><br>  Selon la bonne vieille tradition de travailler avec des shaders, nous tourmenterons ci-apr√®s le lapin de Stanford. <br><br>  En g√©n√©ral, le soi-disant Unity ShaderLab est essentiellement une visualisation d'un inspecteur avec des champs dans les mat√©riaux et une simplification de l'√©criture des shaders. <br><br>  Prenez la structure g√©n√©rale du shader Shaderlab: <br><br><div class="spoiler">  <b class="spoiler_title">Structure g√©n√©rale des shaders</b> <div class="spoiler_text"> <code>Shader "MyShaderName" <br> { <br> Properties <br> { <br> //   <br> } <br> SubShader //     (   ) <br> { <br> Pass <br> { <br> //   <br> } <br> //        <br> } <br> //     <br> FallBack "VertexLit" //         ,     <br> } <br></code> <br></div></div><br>  Directives de compilation telles que <br>  <i>#pragma vertex vert</i> <br>  <i>#pragma fragment frag</i> <br>  d√©terminer les fonctions de shader √† compiler en tant que vertex et fragment shaders, respectivement. <br><br>  Disons que nous prenons l'un des exemples les plus courants - un shader pour afficher la couleur des normales: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleNormalVisualization</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleNormalVisualization" <br> { <br> Properties <br> { <br> } <br> SubShader <br> { <br> Pass <br> { <br> CGPROGRAM <br> <br> #pragma vertex vert <br> #pragma fragment frag <br> <br> #include "UnityCG.cginc" <br> <br> struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> }; <br> <br> v2f vert (appdata_base v) <br> { <br> v2f o; <br> o.pos = UnityObjectToClipPos(v.vertex); <br> o.color = v.normal * 0.5 + 0.5; <br> return o; <br> } <br> <br> fixed4 frag (v2f i) : SV_Target <br> { <br> return fixed4 (i.color, 1); <br> } <br> ENDCG <br> } <br> } <br> FallBack "VertexLit" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/5t/oy/wv/5toywvw0cewffefffvw5xfvtj60.jpeg"><br><br>  Dans ce cas, dans la partie vertex, nous √©crivons la valeur normale convertie dans la couleur vertex, et dans la partie pixel, nous utilisons cette couleur comme couleur du mod√®le. <br><br>  La fonction <i>UnityObjectToClipPos</i> est une fonction auxiliaire Unity (du fichier <i>UnityCG.cginc</i> ) qui traduit les sommets de l'objet √† la position associ√©e √† la cam√©ra.  Sans lui, un objet, lorsqu'il entre dans la visibilit√© de la cam√©ra (frustrum), sera dessin√© dans les coordonn√©es de l'√©cran, quelle que soit la position de la transformation.  Puisque initialement les positions des sommets sont pr√©sent√©es dans les coordonn√©es de l'objet.  Juste des valeurs par rapport √† son pivot. <br><br>  Ce bloc. <br> <code>struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> };</code> <br>  Il s'agit de la d√©finition de la structure qui sera trait√©e dans la partie vertex et transf√©r√©e dans la partie fragment.  Dans ce cas, il est d√©termin√© que deux param√®tres sont pris dans le maillage - la position du sommet et la couleur du sommet.  Vous pouvez en savoir plus sur les donn√©es qui peuvent √™tre jet√©es dans une unit√© sur ce lien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/Manual/SL-VertexProgramInputs.html</a> <br><br>  Pr√©cision importante.  Peu importe le nom des attributs de maillage.  Autrement dit, disons que dans l'attribut de couleur, vous pouvez √©crire le vecteur de d√©viation par rapport √† la position d'origine (de cette fa√ßon, ils font parfois un effet lorsque le personnage s'en va pour que l'herbe ¬´s'en repousse¬ª).  La fa√ßon dont cet attribut sera trait√© d√©pend enti√®rement de votre shader. <br><br><h3>  Conclusion </h3><br><br>  Merci de votre attention!  Il est probl√©matique d'√©crire des effets complexes sans partie fragmentaire, pour cette raison, nous discuterons de similaires dans des articles s√©par√©s.  J'esp√®re qu'au cours de cet article, il est devenu un peu plus clair comment le code des vertex shaders est √©crit en g√©n√©ral, et o√π vous pouvez trouver des informations √† √©tudier, car les shaders sont un sujet tr√®s profond. <br><br>  Dans les prochains articles, nous analyserons les autres types de shaders, les effets individuels, et j'essaierai de d√©crire ma logique de pens√©e lors de la cr√©ation d'effets nouveaux ou complexes. <br><br>  Un r√©f√©rentiel a √©galement √©t√© cr√©√© o√π tous les r√©sultats de cette s√©rie d'articles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/Nox7atra/ShaderExamples</a> seront ajout√©s. J'esp√®re que ces informations seront utiles aux d√©butants qui commencent tout juste leur voyage dans l'√©tude de ce sujet. <br><br><h4>  Quelques liens utiles (y compris les sources): </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.khronos.org/opengl/wiki/Vertex_Shader</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-reference</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/en/current/Manual/SL-Reference.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/Manual/GraphicsTutorials.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.malbred.com/3d-grafika-3d-redaktory/sovremennaya-terminologiya-3d-grafiki/vertex-shader-vershinnyy-sheyder.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3dpapa.ru/accurate-displacement-workflow</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474812/">https://habr.com/ru/post/fr474812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474800/index.html">Performances dans .NET Core</a></li>
<li><a href="../fr474804/index.html">Progr√®s technologique russe dans le sport: interfaces neuronales, cam√©ras IP, CRM sportif et BigData √† partir d'une voiture de course</a></li>
<li><a href="../fr474806/index.html">UDP Flood de Google ou comment ne pas priver tout Youtube</a></li>
<li><a href="../fr474808/index.html">Version Rust 1.39.0: asynchrone / attente, attributs pour les param√®tres de fonction, nouvelles fonctions constantes</a></li>
<li><a href="../fr474810/index.html">Fonctionnement de la cryptographie √† courbe elliptique dans TLS 1.3</a></li>
<li><a href="../fr474814/index.html">Antiquit√©s: le messager de la d√©cadence ou de l'obsolescence non planifi√©e</a></li>
<li><a href="../fr474816/index.html">Projets pour animaux de compagnie - petite vie</a></li>
<li><a href="../fr474818/index.html">Y a-t-il des nombres al√©atoires dans CSS?</a></li>
<li><a href="../fr474822/index.html">WISE-PaaS - une plateforme cloud pour l'Internet industriel des objets</a></li>
<li><a href="../fr474826/index.html">Tables normales dans Markdown</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>