<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë‚Äçü§ù‚Äçüßë ü§® üêØ Machine Learning com Node.js usando a biblioteca Tensorflow.js üéüÔ∏è üë≠ üòΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal, colegas! 

 Talvez os f√£s da biblioteca Tensorflow, que j√° notaram este livro em nossa pr√©-encomenda, tamb√©m tenham analisado atentamente...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Machine Learning com Node.js usando a biblioteca Tensorflow.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432984/">  Ol√° pessoal, colegas! <br><br>  Talvez os f√£s da biblioteca Tensorflow, que j√° notaram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este livro</a> em nossa pr√©-encomenda, tamb√©m tenham analisado atentamente as possibilidades de aprendizado de m√°quina e profundo no navegador, principalmente porque o pr√≥prio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fran√ßois Schollet</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o ignorou o</a> t√≥pico.  Convidamos os interessados ‚Äã‚Äãno gato, que informa como as imagens s√£o reconhecidas usando a biblioteca Tensorflow.js. <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O TensorFlow.js</a> √© uma nova vers√£o da popular biblioteca de c√≥digo aberto que enriquece o JavaScript com recursos de aprendizado profundo.  Os desenvolvedores agora podem definir, treinar e executar modelos usando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API da biblioteca de alto n√≠vel</a> . <br><br>  Gra√ßas aos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelos pr√©-treinados, os</a> desenvolvedores agora podem resolver facilmente tarefas complexas, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reconhecimento de padr√µes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gera√ß√£o de m√∫sica</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">determina√ß√£o de posi√ß√µes humanas em</a> apenas algumas linhas de JavaScript. <br><br>  O Tensorflow.js come√ßou como uma biblioteca front-end para trabalhar em um navegador, mas este ano foi adicionado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">suporte experimental ao</a> Node.js.  Portanto, o TensorFlow.js tamb√©m pode ser usado em aplicativos de back-end JavaScript, o que evita completamente a necessidade de recorrer ao Python. <br><br>  <i>Lendo sobre esta biblioteca, decidi experiment√°-la em uma tarefa simples ...</i> <br><blockquote>  Use TensorFlow.js para reconhecimento visual de imagens em imagens ao usar JavaScript do Node.js. </blockquote>  Infelizmente, os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplos de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> descrevem principalmente o uso dessa biblioteca no navegador.Os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">utilit√°rios de projeto</a> projetados para simplificar o carregamento e o uso de modelos pr√©-treinados no momento da reda√ß√£o n√£o suportavam o Node.js.  Eu tive que gastar muito tempo para ler bem as fontes Typescript desta biblioteca. <br><br>  No entanto, depois de alguns dias de sacudidela, eu ainda consegui!  Viva! <br><br>  <i>Antes de passar para uma an√°lise detalhada do c√≥digo, vamos falar sobre outras implementa√ß√µes da biblioteca TensorFlow.</i> <br><br>  <b>Tensorflow</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O TensorFlow</a> √© uma biblioteca de software livre para aplicativos de aprendizado de m√°quina.  O TensorFlow pode ser usado para criar redes neurais e implementar outros algoritmos de aprendizado profundo. <br><br>  Esta √© uma biblioteca lan√ßada pelo Google em novembro de 2015, originalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrita em Python</a> .  Para treinamento e avalia√ß√£o de modelos criados, ele usa c√°lculos em uma CPU ou GPU.  Inicialmente, essa biblioteca foi criada para funcionar em servidores de alto desempenho usando GPUs com muitos recursos. <br><br>  Atualiza√ß√µes recentes tornaram poss√≠vel otimizar essa biblioteca e us√°-la em ambientes com recursos mais limitados - por exemplo, em dispositivos m√≥veis e navegadores da web. <br><br>  <b>TensorFlow Lite</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O Tensorflow Lite</a> , a vers√£o lite desta biblioteca para dispositivos m√≥veis e sistemas embarcados, foi lan√ßado em maio de 2017.  Juntamente com ele, √© fornecido um novo conjunto de modelos profundos pr√©-treinados para tarefas relacionadas ao reconhecimento de padr√µes;  essa cole√ß√£o √© chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MobileNet</a> .  Os modelos MobileNet foram projetados especificamente para opera√ß√£o eficiente em ambientes com uma quantidade limitada de recursos, como dispositivos m√≥veis. <br><br>  TensorFlow.js <br><br>  Ap√≥s o Tensorflow Lite, o TensorFlow.js foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anunciado</a> em mar√ßo de 2018.  Esta vers√£o da biblioteca foi projetada para ser executada em um navegador e √© baseada em um projeto anterior chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deeplearn.js</a> .  O WebGL fornece acesso de GPU √† biblioteca.  Os desenvolvedores usam a API JavaScript para treinar, carregar e executar modelos. <br><br>  Posteriormente, o TensorFlow.js foi expandido para funcionar com o Node.js, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">add</a> <code>tfjs-node</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca do</a> <code>tfjs-node</code> √© usado para isso. <br><br>  <b>Importar modelos existentes para o TensorFlow.js</b> <br><br>  Os modelos TensorFlow e Keras prontos para execu√ß√£o podem ser executados usando a biblioteca TensorFlow.js.  Antes de executar o modelo, voc√™ deve converter para um novo formato usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta ferramenta</a> .  Modelos pr√©-treinados e transformados para classificar imagens, definir poses e detectar vizinhos k-mais pr√≥ximos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">est√£o dispon√≠veis no Github</a> . <br><br>  <b>Usando TensorFlow.js com Node.js</b> <br><br>  Instalar bibliotecas do TensorFlow <br><br>  O TensorFlow.js pode ser instalado a partir do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">registro</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NPM</a> . <br><br><ul><li>  <code>@tensorflow/tfjs</code> - biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">principal do TensorFlow.js</a> </li><li>  <code>@tensorflow/tfjs-node</code> - extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TensorFlow.js Node.js</a> </li><li>  <code>@tensorflow/tfjs-node-gpu</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Extens√£o TensorFlow.js Node.js com suporte √† computa√ß√£o de GPU</a> </li></ul><br><pre> <code class="plaintext hljs">npm install @tensorflow/tfjs @tensorflow/tfjs-node // ... npm install @tensorflow/tfjs @tensorflow/tfjs-node-gpu</code> </pre> <br>  Ambas as extens√µes do Node.js usam depend√™ncias nativas, que ser√£o compiladas sob demanda. <br><br>  <b>Download de bibliotecas do TensorFlow</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A API JavaScript</a> para Tensorflow √© fornecida na biblioteca principal.  Nenhuma API de extens√£o √© fornecida nos m√≥dulos de extens√£o que oferecem suporte ao Node.js. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ( CPU) require('@tensorflow/tfjs-node') //    ( GPU) require('@tensorflow/tfjs-node-gpu')</span></span></code> </pre> <br>  <b>Download dos modelos TensorFlow</b> <br><br>  O TensorFlow.js fornece uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca NPM</a> ( <code>tfjs-models</code> ) que simplifica o carregamento de <code>tfjs-models</code> pr√©-treinados e transformados para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classificar imagens</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">definir poses</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">detectar os vizinhos mais pr√≥ximos</a> . <br><br>  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo de</a> classifica√ß√£o de imagens da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MobileNet</a> √© uma rede neural profunda treinada para distinguir entre <a href="">1000 classes diferentes de imagens</a> . <br><br>  No arquivo LEIA-ME para o projeto, o c√≥digo a seguir √© usado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como exemplo</a> , usado para carregar o modelo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mobilenet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   const model = await mobilenet.load();</span></span></code> </pre> <br>  Um dos primeiros problemas que encontrei √© que esse c√≥digo n√£o funciona com o Node.js. <br><br><pre> <code class="plaintext hljs">Error: browserHTTPRequest is not supported outside the web browser.</code> </pre> <br>  Ap√≥s examinar o <a href="">c√≥digo fonte</a> , vemos que a biblioteca mobilenet √© um inv√≥lucro para a classe <code>tf.Model</code> .  Quando chamado, o m√©todo <code>load()</code> baixa automaticamente os arquivos de modelo necess√°rios localizados em um endere√ßo HTTP externo e instancia o modelo TensorFlow. <br><br>  A extens√£o Node.js no momento da grava√ß√£o ainda n√£o suportava solicita√ß√µes HTTP para recupera√ß√£o de modelo din√¢mico.  Tudo o que restava era carregar manualmente os modelos no sistema de arquivos. <br><br>  <i>No entanto, depois de ler o c√≥digo fonte da biblioteca, encontrei uma solu√ß√£o alternativa ...</i> <br><br>  <b>Fazendo Download de Modelos do Sistema de Arquivos</b> <br><br>  Se a classe MobileNet for criada manualmente, n√£o ser√° poss√≠vel chamar o m√©todo de <code>load</code> do m√≥dulo, mas reescrever o <code>path</code> vari√°vel gerado automaticamente <code>path</code> cont√©m o endere√ßo HTTP do modelo, substituindo esse endere√ßo pelo caminho local no sistema de arquivos.  Depois disso, quando o m√©todo <code>load</code> for chamado na inst√¢ncia da classe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a</a> classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">loader do sistema de arquivos</a> ser√° acionada;  nesse caso, nos recusamos a usar um downloader HTTP baseado em navegador. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-string"><span class="hljs-string">"mobilenet/model.json"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load()</code> </pre> <br>  Legal, tudo funciona! <br><br>  Mas de onde v√™m os arquivos de modelo? <br><br>  <b>Modelos MobileNet</b> <br><br>  Modelos para TensorFlow.js consistem em dois tipos de arquivos: um arquivo de configura√ß√£o de modelo armazenado no formato JSON e os pesos do modelo armazenados no formato bin√°rio.  Os pesos do modelo geralmente s√£o fragmentados em v√°rias partes para otimizar o cache do navegador. <br><br>  Tendo considerado o <a href="">c√≥digo de download autom√°tico</a> dos modelos MobileNet, vemos que os modelos, suas configura√ß√µes e fragmentos de peso s√£o extra√≠dos do cont√™iner p√∫blico no seguinte endere√ßo. <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v${version}_${alpha}_${size}/</code> </pre> <br>  Os par√¢metros do modelo na URL descrevem as vers√µes do modelo listadas <a href="">aqui</a> .  A precis√£o da classifica√ß√£o resultante tamb√©m √© exibida na mesma p√°gina. <br><br>  O c√≥digo fonte indica que apenas os modelos do MobileNet v1 podem ser baixados usando a <code>tensorflow-models/mobilenet</code> . <br><br>  O c√≥digo de extra√ß√£o HTTP baixa o arquivo <code>model.json</code> do local de armazenamento e, em seguida, seleciona recursivamente todos os fragmentos de modelos com pesos referenciados.  Esses s√£o arquivos no formato <code>groupX-shard1of1</code> . <br><br>  <b>Download manual de modelos</b> <br><br>  Se desejar salvar todos os arquivos de modelo no sistema de arquivos, fa√ßa o seguinte: extraia o arquivo de configura√ß√£o do modelo, analise a sintaxe de todos os arquivos ponderados mencionados no arquivo de configura√ß√£o e fa√ßa o download manual de cada arquivo ponderado. <br>  <b>Eu usaria o m√≥dulo MobileNet V1 com um valor alfa de 1,0 e uma imagem de 224 pixels</b> .  Ent√£o, recebo o <a href="">seguinte URL</a> para o arquivo de configura√ß√£o do modelo. <br><br><pre> <code class="plaintext hljs">https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/model.json</code> </pre> <br>  Depois que o arquivo √© baixado localmente, voc√™ pode usar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ferramenta</a> <code>jq</code> para analisar os nomes de todos os arquivos ponderados. <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> group1-shard1of1 group2-shard1of1 group3-shard1of1 ...</code> </pre> <br>  Usando a ferramenta <code>sed</code> , voc√™ pode prefixar o nome de cada elemento HTTP com uma URL para gerar uma URL para cada arquivo de peso. <br><br><pre> <code class="javascript hljs">$ cat model.json | jq -r <span class="hljs-string"><span class="hljs-string">".weightsManifest[].paths[0]"</span></span> | sed <span class="hljs-string"><span class="hljs-string">'s/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//'</span></span> https:<span class="hljs-comment"><span class="hljs-comment">//storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group1-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group2-shard1of1 https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_1.0_224/group3-shard1of1 ...</span></span></code> </pre><br>  Os comandos <code>parallel</code> e <code>curl</code> permitem baixar todos esses arquivos no meu diret√≥rio local. <br><br><pre> <code class="plaintext hljs">cat model.json | jq -r ".weightsManifest[].paths[0]" | sed 's/^/https:\/\/storage.googleapis.com\/tfjs-models\/tfjs\/mobilenet_v1_1.0_224\//' | parallel curl -O</code> </pre> <br>  <b>Classifica√ß√£o da imagem</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Este c√≥digo de exemplo</a> fornecido com o TensorFlow.js demonstra como retornar o resultado da classifica√ß√£o da imagem. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> img = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'img'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   const predictions = await model.classify(img);</span></span></code> </pre> <br>  Isso n√£o funciona no Node.js devido √† falta de suporte do DOM. <br><br>  <a href="">O m√©todo</a> <code>classify</code> aceita v√°rios elementos DOM ( <code>canvas</code> , <code>video</code> , <code>image</code> ) e extrai e converte automaticamente os bytes "de imagem" desses elementos na classe <code>tf.Tensor3D</code> , usada como entrada de modelo.  Como alternativa, a <code>tf.Tensor3D</code> pode ser transmitida diretamente. <br><br>  <b>Decidi n√£o tentar usar um pacote externo para simular um elemento DOM manualmente, mas achei que <code>tf.Tensor3D</code> mais f√°cil de montar manualmente</b> . <br><br>  <b>Geramos Tensor3D a partir da imagem</b> <br><br>  Lendo o <a href="">c√≥digo fonte do</a> m√©todo usado para converter elementos DOM em classes Tensor3D, descobrimos que os seguintes par√¢metros de entrada s√£o usados ‚Äã‚Äãpara gerar a classe Tensor3D. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(image.height * image.width * numChannels); <span class="hljs-comment"><span class="hljs-comment">//     ,    const outShape = [image.height, image.width, numChannels]; const input = tf.tensor3d(values, outShape, 'int32');</span></span></code> </pre> <br>  <code>pixels</code> √© uma matriz bidimensional do tipo <code>(Int32Array)</code> cont√©m uma lista seq√ºencial de valores de canal para cada pixel.  <code>numChannels</code> √© o n√∫mero de valores de canal por pixel. <br><br>  <b>Criando valores de entrada para JPEG</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A biblioteca</a> <code>jpeg-js</code> √© um codificador / decodificador JPEG para Node.js escrito em JavaScript puro.  Usando esta biblioteca, voc√™ pode extrair valores RGB para cada pixel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buffer, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Como resultado, obtemos um Uint8Array com quatro valores de canal ( <code>RGBA</code> ) para cada pixel ( <code>width * height</code> ).  O modelo MobileNet usa apenas tr√™s canais de cores ( <code>RGB</code> ) para classifica√ß√£o, o canal alfa √© ignorado.  Esse c√≥digo converte uma matriz de quatro canais em uma vers√£o verdadeira de tr√™s canais. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numChannels = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } }</code> </pre> <br>  <b>Requisitos de entrada para modelos MobileNet</b> <br><br>  O <a href="">modelo MobileNet</a> usado aqui classifica imagens de 224 pixels de altura e largura.  Os tensores de entrada devem conter valores de ponto flutuante no intervalo de -1 a 1 para cada um dos tr√™s valores de canal de cada pixel. <br><br>  Os valores de entrada para imagens com uma dimens√£o diferente devem ser convertidos no tamanho correto antes da classifica√ß√£o.  Al√©m disso, os valores de pixel obtidos do decodificador JPEG est√£o no intervalo de 0 a 255, e n√£o de -1 a 1. Esses valores tamb√©m precisam ser convertidos antes da classifica√ß√£o. <br><br>  O TensorFlow.js possui m√©todos de biblioteca para simplificar esse processo, mas, melhor ainda, existe uma <b><code>tfjs-models/mobilenet</code> que <a href="">resolve automaticamente esse problema</a> !</b> <br><br>  O desenvolvedor pode transmitir Tensor3Ds de entrada do tipo <code>int32</code> , bem como v√°rias dimens√µes para o m√©todo <code>classify</code> , que converte os valores de entrada no formato correto antes da classifica√ß√£o.  Ou seja, n√£o temos nada a fazer aqui.  √ìtimo! <br><br>  <b>Obtendo previs√µes</b> <br><br>  Os modelos MobileNet da Tensorflow aprendem a reconhecer objetos das <a href="">1000 classes mais importantes</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto de</a> dados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do ImageNet</a> .  Na sa√≠da do modelo, forne√ßa valores probabil√≠sticos caracterizando quais s√£o as chances de encontrar esses objetos na imagem classificada. <br><br>  <i>Uma lista completa de classes treinadas para o modelo usado est√° <a href="">neste arquivo</a></i> . <br><br>  A <code>tfjs-models/mobilenet</code> oferece o m√©todo <code>classify</code> na classe <code>MobileNet</code> , que retorna o top-X das classes mais prov√°veis, com base no que √© mostrado na figura. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  <code>predictions</code> √© uma matriz de X classes e probabilidades no seguinte formato. <br><br><pre> <code class="javascript hljs"> { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'panda'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> }</code> </pre> <br>  <b>Exemplo</b> <br><br>  Ent√£o, descobrimos como usar a biblioteca TensorFlow.js e os modelos MobileNet no Node.js, e agora vamos ver como esse script classifica a imagem especificada como um argumento da linha de comando. <br><br>  <i>C√≥digo fonte</i> <br><br>  Salve este arquivo de script e o descritor de pacotes nos arquivos locais. <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"tf-js"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"script.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"@tensorflow-models/mobilenet"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.2.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.12.3"</span></span>, <span class="hljs-string"><span class="hljs-string">"@tensorflow/tfjs-node"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.1.9"</span></span>, <span class="hljs-string"><span class="hljs-string">"jpeg-js"</span></span>: <span class="hljs-string"><span class="hljs-string">"^0.3.4"</span></span> } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tf = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobilenet = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow-models/mobilenet'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@tensorflow/tfjs-node'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jpeg = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jpeg-js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> NUMBER_OF_CHANNELS = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> readImage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = fs.readFileSync(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = jpeg.decode(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pixels } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageByteArray = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pixels = image.data <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numPixels = image.width * image.height; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Int32Array</span></span>(numPixels * numChannels); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numPixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> channel = <span class="hljs-number"><span class="hljs-number">0</span></span>; channel &lt; numChannels; ++channel) { values[i * numChannels + channel] = pixels[i * <span class="hljs-number"><span class="hljs-number">4</span></span> + channel]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> values } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> imageToInput = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">image, numChannels</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> values = imageByteArray(image, numChannels) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> outShape = [image.height, image.width, numChannels]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = tf.tensor3d(values, outShape, <span class="hljs-string"><span class="hljs-string">'int32'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loadModel = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> path =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mobilenet.MobileNet(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); mn.path = <span class="hljs-string"><span class="hljs-string">`file://</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${path}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn.load() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mn } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classify = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (model, path) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = readImage(path) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = imageToInput(image, NUMBER_OF_CHANNELS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mn_model = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> loadModel(model) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> predictions = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> mn_model.classify(input) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'classification results:'</span></span>, predictions) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.argv.length !== <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'incorrect arguments: node script.js &lt;MODEL&gt; &lt;IMAGE_FILE&gt;'</span></span>) classify(process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>], process.argv[<span class="hljs-number"><span class="hljs-number">3</span></span>])</code> </pre> <br>  <b>Teste</b> <br><br>  Fa√ßa o download dos arquivos de modelo para o diret√≥rio mobilenet seguindo as instru√ß√µes acima. <br>  Definir depend√™ncias do projeto usando o NPM <br><br> <code>npm install</code> <br> <br>  Fa√ßa o download do arquivo JPEG de amostra para classifica√ß√£o <br><br> <code>wget http://bit.ly/2JYSal9 -O panda.jpg</code> <br> <br><img src="https://habrastorage.org/webt/vt/sm/-2/vtsm-2o5y-t3vhqx5-qaomhxnfw.jpeg"><br><br>  Execute o script, cujos argumentos ser√£o o arquivo de modelo e a imagem de entrada. <br><br> <code>node script.js mobilenet/model.json panda.jpg</code> <br> <br>  Se tudo funcionou corretamente, a seguinte sa√≠da deve aparecer no console. <br><br><pre> <code class="javascript hljs"> classification results: [ { <span class="hljs-attr"><span class="hljs-attr">className</span></span>: <span class="hljs-string"><span class="hljs-string">'giant panda, panda, panda bear, coon bear'</span></span>, <span class="hljs-attr"><span class="hljs-attr">probability</span></span>: <span class="hljs-number"><span class="hljs-number">0.9993536472320557</span></span> } ]</code> </pre> <br>  A imagem est√° corretamente classificada como contendo um panda com uma probabilidade de 99,93%! <br><br>  <b>Conclus√£o</b> <br><br>  A biblioteca TensorFlow.js abre oportunidades profundas de aprendizado para desenvolvedores de JavaScript.  O uso de modelos pr√©-treinados com a biblioteca TensorFlow.js permite criar facilmente em aplicativos JavaScript novos recursos para resolver problemas complexos de aprendizado de m√°quina, com esfor√ßo m√≠nimo e c√≥digo conciso. <br><br>  A biblioteca TensorFlow.js foi criada exclusivamente para trabalhar em um navegador, mas agora interage com o Node.js, embora nem todas as ferramentas e utilit√°rios suportem esse novo tempo de execu√ß√£o.  Tendo mexido com a biblioteca por v√°rios dias, aprendi a us√°-la com os modelos MobileNet para reconhecimento visual de imagens de um arquivo local. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt432984/">https://habr.com/ru/post/pt432984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt432972/index.html">Fonte: "Lei de Conway"</a></li>
<li><a href="../pt432976/index.html">Papai Noel an√¥nimo 2018 e 2019: p√≥s com presentes de ano novo</a></li>
<li><a href="../pt432978/index.html">John Romero: Reflex√£o DOOM</a></li>
<li><a href="../pt432980/index.html">VMware NSX para o menor. Parte 1</a></li>
<li><a href="../pt432982/index.html">A introdu√ß√£o mais curta √† cria√ß√£o do compilador</a></li>
<li><a href="../pt432986/index.html">Loops C vs Go e matem√°tica simples</a></li>
<li><a href="../pt432988/index.html">Oitavo Webmaster. Ao vivo em Habr√©</a></li>
<li><a href="../pt432990/index.html">Edison L√¢mpada de madeira ativada por voz. Pre√ßo de emiss√£o $ 5</a></li>
<li><a href="../pt432992/index.html">Ele colocou os fones de ouvido e morreu: lidamos com a estranha morte de um estudante em Rimbau</a></li>
<li><a href="../pt432994/index.html">Vivaldi 2.2 - Quantidade convertida em qualidade</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>