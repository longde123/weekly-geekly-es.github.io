<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò± üë®‚Äç‚öïÔ∏è ü•ë Once perlas ocultas de Java 11 üë©üèæ‚Äçüç≥ üçß üßòüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 11 no introdujo ninguna caracter√≠stica innovadora, pero contiene varias gemas de las que quiz√°s a√∫n no haya o√≠do hablar. ¬øYa viste lo √∫ltimo en S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Once perlas ocultas de Java 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441154/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java 11</a> no introdujo ninguna caracter√≠stica innovadora, pero contiene varias gemas de las que quiz√°s a√∫n no haya o√≠do hablar.  ¬øYa viste lo √∫ltimo en <code>String</code> , <code>Optional</code> , <code>Collection</code> y otros caballos de batalla?  Si no, ha llegado a la direcci√≥n: ¬°hoy veremos 11 gemas ocultas de Java 11! </p><a name="habracut"></a><br><h3 id="vyvod-tipov-dlya-lyambda-parametrov">  Inferencia de tipos para par√°metros lambda </h3><br><p>  Al escribir una expresi√≥n lambda, puede elegir entre especificar expl√≠citamente los tipos y omitirlos: </p><br><pre> <code class="java hljs">Function&lt;String, String&gt; append = string -&gt; string + <span class="hljs-string"><span class="hljs-string">" "</span></span>; Function&lt;String, String&gt; append = (String s) -&gt; s + <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java 10 introdujo</a> <code>var</code> , pero no se pudo usar en lambdas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Java 10 Function&lt;String, String&gt; append = (var string) -&gt; string + " ";</span></span></code> </pre> <br><p>  En Java 11 ya es posible.  Pero por que?  No parece que <code>var</code> dado m√°s que un simple pase de tipo.  Aunque este es el caso, el uso de <code>var</code> tiene dos ventajas menores: </p><br><ul><li>  hace que el uso de <code>var</code> m√°s universal al eliminar la excepci√≥n a la regla </li><li>  le permite agregar anotaciones al tipo de par√°metro sin recurrir al uso de su nombre completo </li></ul><br><p>  Aqu√≠ hay un ejemplo del segundo caso: </p><br><pre> <code class="java hljs">List&lt;EnterpriseGradeType&lt;With, Generics&gt;&gt; types = <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>; types .stream() <span class="hljs-comment"><span class="hljs-comment">// ,     @Nonnull   .filter(type -&gt; check(type)) //  Java 10    ~&gt;  .filter((@Nonnull EnterpriseGradeType&lt;With, Generics&gt; type) -&gt; check(type)) //  Java 11    ~&gt;   .filter((@Nonnull var type) -&gt; check(type))</span></span></code> </pre> <br><p>  Aunque se puede implementar la mezcla de tipos derivados, expl√≠citos e impl√≠citos en expresiones lambda de la forma <code>(var type, String option, index) -&gt; ...</code> , pero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el marco de JEP-323</a> ) este trabajo no se llev√≥ a cabo.  Por lo tanto, es necesario elegir uno de los tres enfoques y adherirse a √©l para todos los par√°metros de la expresi√≥n lambda.  La necesidad de especificar <code>var</code> para todos los par√°metros para agregar anotaciones para uno de ellos puede ser un poco molesto, pero generalmente tolerable. </p><br><h3 id="potokovaya-obrabotka-strok-s-stringlines">  Procesamiento continuo de cadenas con <code>'String::lines'</code> </h3><br><p>  ¬øTienes una cadena de varias l√≠neas?  ¬øQuieres hacer algo con cada l√≠nea?  Entonces <code>String::lines</code> es la elecci√≥n correcta: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiline = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n\r\n"</span></span>; multiline .lines() <span class="hljs-comment"><span class="hljs-comment">//Stream&lt;String&gt; .map(line -&gt; "// " + line) .forEach(System.out::println); // : //  //  //  // </span></span></code> </pre> <br><p>  Tenga en cuenta que la l√≠nea original usa los delimitadores de tornillo <code>\r\n</code> y aunque estoy en Linux, las <code>lines()</code> todav√≠a lo rompieron.  Esto se debe al hecho de que, a pesar del sistema operativo actual, este m√©todo interpreta <code>\r</code> , <code>\n</code> y <code>\r\n</code> como saltos de l√≠nea, incluso si se mezclan en la misma l√≠nea. </p><br><p>  Una secuencia de l√≠neas nunca contiene los propios separadores de l√≠nea.  Las l√≠neas pueden estar vac√≠as ( <code>"\n\n \n\n"</code> , que contiene 5 l√≠neas), pero la √∫ltima l√≠nea de la l√≠nea original se ignora si est√° vac√≠a ( <code>"\n\n"</code> ; 2 l√≠neas).  <em>(Nota del traductor: es conveniente para ellos tener <code>line</code> , pero tener <code>string</code> , y tenemos ambos).</em> </p><br><p>  A diferencia de la <code>split("\R")</code> , las <code>lines()</code> vagas y, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cito</a> , "proporciona un mejor rendimiento [...] al buscar m√°s r√°pidamente nuevos saltos de l√≠nea".  (Si alguien quiere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentar un</a> punto de referencia en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JMH</a> para verificaci√≥n, h√°gamelo saber).  Tambi√©n refleja mejor el algoritmo de procesamiento y utiliza una estructura de datos m√°s conveniente (flujo en lugar de matriz). </p><br><h3 id="udalenie-probelnyh-simvolov-s-stringstrip-i-tp">  Eliminando espacios en blanco con <code>'String::strip'</code> , etc. </h3><br><p>  Inicialmente, <code>String</code> ten√≠a un m√©todo de <code>trim</code> para eliminar espacios en blanco, que se consideraba todo con c√≥digos hasta <code>U+0020</code> .  S√≠, <code>BACKSPACE</code> ( <code>U+0008)</code> es un espacio en blanco como <code>BELL</code> ( <code>U+0007</code> ), pero <code>LINE SEPARATOR</code> ( <code>U+2028</code> ) ya no se considera como tal. </p><br><p>  Java 11 introdujo el m√©todo de la <code>strip</code> , cuyo enfoque tiene m√°s matices.  Utiliza el <code>Character::isWhitespace</code> de Java 5 para determinar qu√© necesita eliminarse exactamente.  De <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">su documentaci√≥n</a> queda claro que esto: </p><br><ul><li>  <code>SPACE SEPARATOR</code> <code>LINE SEPARATOR</code> <code>SPACE SEPARATOR</code> , <code>LINE SEPARATOR</code> , <code>LINE SEPARATOR</code> <code>PARAGRAPH SEPARATOR</code> , pero no es un espacio inextricable </li><li>  <code>HORIZONTAL TABULATION</code> ( <code>U+0009</code> ), <code>LINE FEED</code> ( <code>U+000A</code> ), <code>VERTICAL TABULATION</code> ( <code>U+000B</code> ), <code>FORM FEED</code> ( <code>U+000C</code> ), <code>CARRIAGE RETURN</code> ( <code>U+000D</code> ) </li><li>  <code>FILE SEPARATOR</code> ( <code>U+001C</code> ), <code>GROUP SEPARATOR</code> ( <code>U+001D</code> ), <code>RECORD SEPARATOR</code> ( <code>U+001E</code> ), <code>UNIT SEPARATOR</code> ( <code>U+001F</code> ) </li></ul><br><p>  Con la misma l√≥gica, hay dos m√©todos de limpieza m√°s, <code>stripLeading</code> y <code>stripTailing</code> , que hacen exactamente lo que se espera de ellos. </p><br><p>  Y finalmente, si solo necesita averiguar si la l√≠nea se vac√≠a despu√©s de eliminar el espacio en blanco, entonces no hay necesidad de eliminarlos realmente, solo use <code>isBlank</code> : </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span>.isBlank(); <span class="hljs-comment"><span class="hljs-comment">//  ~&gt; true " ".isBlank(); //   ~&gt; false</span></span></code> </pre> <br><h3 id="povtorenie-strok-s-stringrepeat">  Repetir cadenas con <code>'String::repeat'</code> </h3><br><p>  Captura la idea: </p><br><h6 id="shag-1-pristalno-sledim-za-razvitiem-jdk">  Paso 1: Vigilar JDK </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/874/8df/a06/8748dfa06086f57aae4b16686d9c6c04.png" alt="Vigilando de cerca el desarrollo de JDK"></p><br><h6 id="shag-2-razyskivaem-na-stackoverflow-svyazannye-voprosy">  Paso 2: B√∫squeda de preguntas relacionadas con StackOverflow </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df2/3f8/7ae/df23f87ae8d723f53beb5617017de913.png" alt="Buscando preguntas relacionadas en Stackoverflow"></p><br><h6 id="shag-3-priletaem-s-novym-otvetom-osnovannym-na-buduschih-izmeneniyah">  Paso 3: llegar con una nueva respuesta basada en cambios futuros </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b68/556/748/b685567487db2b1ea3cab180b8f39089.png" alt="Swoop in con nueva respuesta basada en los pr√≥ximos cambios"></p><br><h6 id="shag-4-">  Paso 4: ???? </h6><br><h6 id="shag-4-profit">  Paso 4: ganancia </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/695/015/36969501570588225baae6cd5dd3edb1.gif" alt="¬Ø \ _ („ÉÑ) _ / ¬Ø"></p><br><p>  Como puedes imaginar, <code>String</code> tiene un nuevo m√©todo de <code>repeat(int)</code> .  Funciona exactamente de acuerdo con las expectativas, y hay poco que discutir. </p><br><h3 id="sozdanie-putey-s-pathof">  Crear rutas con <code>'Path::of'</code> </h3><br><p>  Realmente me gusta la API de <code>Path</code> , pero convertir rutas entre diferentes vistas (como <code>Path</code> , <code>File</code> , <code>URL</code> , <code>URI</code> y <code>String</code> ) sigue siendo molesto.  Este punto se ha vuelto menos confuso en Java 11 copiando dos <code>Paths::get</code> method en <code>Path::of</code> method: </p><br><pre> <code class="java hljs">Path tmp = Path.of(<span class="hljs-string"><span class="hljs-string">"/home/nipa"</span></span>, <span class="hljs-string"><span class="hljs-string">"tmp"</span></span>); Path codefx = Path.of(URI.create(<span class="hljs-string"><span class="hljs-string">"http://codefx.org"</span></span>));</code> </pre> <br><p>  Pueden considerarse can√≥nicos, ya que los dos m√©todos antiguos de <code>Paths::get</code> utilizan nuevas opciones. </p><br><h3 id="chtenie-i-zapis-faylov-s-filesreadstring-i-fileswritestring">  Lectura y escritura de archivos con <code>'Files::readString'</code> y <code>'Files::writeString'</code> </h3><br><p>  Si necesito leer de un archivo grande, generalmente uso <code>Files::lines</code> para obtener un flujo lento de sus l√≠neas.  Del mismo modo, para escribir una gran cantidad de datos que pueden no almacenarse en la memoria en su totalidad, utilizo <code>Files::write</code> pas√°ndolos como <code>Iterable&lt;String&gt;</code> . </p><br><p>  Pero, ¬øqu√© pasa con el caso simple cuando quiero procesar el contenido de un archivo como una sola l√≠nea?  Esto no es muy conveniente, ya que <code>Files::readAllBytes</code> y las variantes apropiadas de <code>Files::write</code> operan en conjuntos de bytes. </p><br><p>  Y luego aparece Java 11, agregando <code>readString</code> y <code>writeString</code> a los <code>Files</code> : </p><br><pre> <code class="java hljs">String haiku = Files.readString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku.txt"</span></span>)); String modified = modify(haiku); Files.writeString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku-mod.txt"</span></span>), modified);</code> </pre> <br><p>  Claro y f√°cil de usar.  Si es necesario, puede pasar el <code>Charset</code> de <code>readString</code> a <code>readString</code> , y en <code>writeString</code> tambi√©n una matriz <code>OpenOptions</code> . </p><br><h3 id="pustoe-io-s-readernullreader-i-tp">  E / S vac√≠a con <code>'Reader::nullReader'</code> , etc. </h3><br><p>  ¬øNecesita un <code>OutputStream</code> que no escriba en ning√∫n lado?  ¬øO un <code>InputStream</code> vac√≠o?  ¬øQu√© pasa con <code>Reader</code> y <code>Writer</code> que no hacen nada?  Java 11 lo tiene todo: </p><br><pre> <code class="java hljs">InputStream input = InputStream.nullInputStream(); OutputStream output = OutputStream.nullOutputStream(); Reader reader = Reader.nullReader(); Writer writer = Writer.nullWriter();</code> </pre> <br><p>  <em>(Nota del traductor: en <code>commons-io</code> estas clases existen desde aproximadamente 2014).</em> </p><br><p>  Sin embargo, me sorprende: ¬øes <code>null</code> realmente el mejor prefijo?  No me gusta c√≥mo se usa para significar "ausencia intencional" ... ¬øQuiz√°s ser√≠a mejor usar <code>noOp</code> ?  <em>(Nota del traductor: lo m√°s probable es que este prefijo se haya elegido debido al uso com√∫n de <code>/dev/null</code> ).</em> </p><br><h3 id="-----s-collectiontoarray">  <code>{ } ~&gt; [ ]</code> con <code>'Collection::toArray'</code> </h3><br><p>  ¬øC√≥mo se convierten las colecciones en matrices? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Java 11 List&lt;String&gt; list = /*...*/; Object[] objects = list.toArray(); String[] strings_0 = list.toArray(new String[0]); String[] strings_size = list.toArray(new String[list.size()]);</span></span></code> </pre> <br><p>  La primera opci√≥n, <code>objects</code> , pierde toda la informaci√≥n sobre los tipos, por lo que est√° en fuga.  ¬øQu√© hay del resto?  Ambos son voluminosos, pero el primero es m√°s corto.  Este √∫ltimo crea una matriz del tama√±o requerido, para que se vea m√°s productivo (es decir, "parece m√°s productivo", ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">credibilidad</a> ).  ¬øPero es realmente m√°s productivo?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No, por el contrario, es m√°s lento</a> (por el momento). </p><br><p>  Pero, ¬øpor qu√© deber√≠a importarme esto?  ¬øNo hay una mejor manera de hacer esto?  En Java 11 hay: </p><br><pre> <code class="java hljs">String[] strings_fun = list.toArray(String[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br><p>  <code>Collection::toArray</code> una nueva variante de <code>Collection::toArray</code> , que acepta <code>IntFunction&lt;T[]&gt;</code> , es decir  una funci√≥n que recibe el tama√±o de la matriz y devuelve una matriz del tama√±o requerido.  Se puede expresar brevemente como una referencia a un constructor de la forma <code>T[]::new</code> (para un <code>T</code> conocido). </p><br><p>  Dato interesante, la implementaci√≥n predeterminada de <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code> siempre pasa <code>0</code> al generador de matriz.  Al principio, decid√≠ que esta soluci√≥n se basaba en el mejor rendimiento para matrices de longitud cero, pero ahora creo que la raz√≥n puede ser que para algunas colecciones, calcular el tama√±o puede ser una operaci√≥n muy costosa y no debe usar este enfoque en la implementaci√≥n predeterminada de <code>Collection</code> .  Sin embargo, las implementaciones de colecciones espec√≠ficas, como <code>ArrayList</code> , pueden cambiar este enfoque, pero no cambian en Java 11.  No vale la pena, supongo. </p><br><h3 id="proverka-otsutstviya-s-optionalisempty">  Verificaci√≥n de ausencia con <code>'Optional::isEmpty'</code> </h3><br><p>  Con el uso abundante de <code>Optional</code> , especialmente en proyectos grandes, donde a menudo encuentra un enfoque no <code>Optional</code> , a menudo tiene que verificar si tiene un valor.  Hay un m√©todo <code>Optional::isPresent</code> para esto.  Pero con la misma frecuencia necesita saber lo contrario: que <code>Optional</code> vac√≠o.  No hay problema, solo use <code>!opt.isPresent()</code> , ¬øverdad? </p><br><p>  Por supuesto, es posible de esa manera, pero casi siempre es m√°s f√°cil entender la l√≥gica <code>if</code> su condici√≥n no se invierte.  Y a veces, <code>Optional</code> aparece al final de una larga cadena de llamadas y si necesita verificarlo para nada, ¬°entonces tiene que apostar <code>!</code>  al principio </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isPresent(); }</code> </pre> <br><p>  En ese caso, ¬°s√°ltatelo <code>!</code>  Muy f√°cil  Comenzando con Java 11 hay una mejor opci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isEmpty(); }</code> </pre> <br><h3 id="invertirovanie-predikatov-s-predicatenot">  Invertir predicados con <code>'Predicate::not'</code> </h3><br><p>  Hablando de invertir ... La interfaz de <code>Predicate</code> tiene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un</a> <code>negate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instancia</a> <code>negate</code> : devuelve un nuevo predicado que realiza la misma verificaci√≥n, pero invierte su resultado.  Desafortunadamente, rara vez logro usarlo ... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Stream .of("a", "b", "", "c") // ,  ~&gt;        .filter(s -&gt; !s.isBlank()) //          ~&gt;  .filter((String::isBlank).negate()) // ,  ~&gt;       .filter(((Predicate&lt;String&gt;) String::isBlank).negate()) .forEach(System.out::println);</span></span></code> </pre> <br><p>  El problema es que rara vez tengo acceso a la instancia de <code>Predicate</code> .  M√°s a menudo, quiero obtener una instancia de este tipo a trav√©s de un enlace a un m√©todo (e invertirlo), pero para que esto funcione, el compilador debe saber a qu√© llevar la referencia del m√©todo; sin √©l, no puede hacer nada.  Y esto es exactamente lo que sucede si usa la <code>(String::isBlank).negate()</code> : el compilador ya no sabe qu√© <code>String::isBlank</code> deber√≠a estar en esto y se da por vencido.  Una casta correctamente especificada arregla esto, pero ¬øa qu√© costo? </p><br><p>  Aunque hay una soluci√≥n simple.  No use el <code>negate</code> instancia <code>negate</code> , pero use el nuevo m√©todo est√°tico <code>Predicate.not(Predicate&lt;T&gt;)</code> de Java 11: </p><br><pre> <code class="java hljs">Stream .of(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   `java.util.function.Predicate.not` .filter(not(String::isBlank)) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Ya mejor! </p><br><h3 id="regulyarnye-vyrazheniya-kak-predikat-s-patternasmatchpredicate">  Expresiones regulares como predicado con <code>'Pattern::asMatchPredicate'</code> </h3><br><p>  ¬øHay una expresi√≥n regular?  ¬øNecesita filtrar datos en √©l?  ¬øQu√© tal esto? </p><br><pre> <code class="java hljs">Pattern nonWordCharacter = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\W"</span></span>); Stream .of(<span class="hljs-string"><span class="hljs-string">"Metallica"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mot√∂rhead"</span></span>) .filter(nonWordCharacter.asPredicate()) .forEach(System.out::println);</code> </pre> <br><p>  ¬°Estaba muy feliz de encontrar este m√©todo!  Vale la pena agregar que este es un m√©todo de Java 8. Vaya, lo perd√≠ entonces.  Java 11 agreg√≥ otro m√©todo similar: <code>Pattern::asMatchPredicate</code> .  Cual es la diferencia </p><br><ul><li>  <code>asPredicate</code> comprueba que la cadena <strong>o parte de la cadena</strong> coincida con el patr√≥n (funciona como <code>s -&gt; this.matcher(s).find()</code> ) </li><li>  <code>asMatchPredicate</code> verifica que <strong>toda la cadena</strong> coincida con el patr√≥n (funciona como <code>s -&gt; this.matcher(s).matches()</code> ) </li></ul><br><p>  Por ejemplo, tenemos una expresi√≥n regular que verifica los n√∫meros de tel√©fono, pero no contiene <code>^</code> y <code>$</code> para rastrear el principio y el final de una l√≠nea.  Entonces el siguiente c√≥digo no funcionar√° como es de esperar: </p><br><pre> <code class="java hljs">prospectivePhoneNumbers .stream() .filter(phoneNumberPatter.asPredicate()) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::robocall);</code> </pre> <br><p>  ¬øNotaste un error?  Se <code>" -152 ? +1-202-456-1414"</code> una l√≠nea como <code>" -152 ? +1-202-456-1414"</code> , porque contiene un n√∫mero de tel√©fono v√°lido.  Por otro lado, <code>Pattern::asMatchPredicate</code> no permitir√° esto, porque <strong>toda la</strong> cadena ya <strong>no</strong> coincidir√° con el patr√≥n. </p><br><h3 id="samoproverka">  Auto prueba </h3><br><p>  Aqu√≠ hay una descripci√≥n general de las once perlas: ¬øtodav√≠a recuerda lo que hace cada m√©todo?  Si es as√≠, has pasado la prueba. </p><br><ul><li>  en <code>String</code> : <br><ul><li> <code>Stream&lt;String&gt; lines()</code> </li> <li> <code>String strip()</code> </li> <li> <code>String stripLeading()</code> </li> <li> <code>String stripTrailing()</code> </li> <li> <code>boolean isBlank()</code> </li> <li> <code>String repeat(int)</code> </li> </ul></li><li>  en el <code>Path</code> : <br><ul><li> <code>static Path of(String, String...)</code> </li> <li> <code>static Path of(URI)</code> </li> </ul></li><li>  en <code>Files</code> : <br><ul><li> <code>String readString(Path) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, OpenOption...) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, Charset, OpenOption...) throws IOException</code> </li> </ul></li><li>  en <code>InputStream</code> : <code>static InputStream nullInputStream()</code> </li><li>  en <code>OutputStream</code> : <code>static OutputStream nullOutputStream()</code> </li><li>  en el <code>Reader</code> : <code>Reader</code> <code>static Reader nullReader()</code> </li><li>  en <code>Writer</code> : <code>Writer</code> <code>static Writer nullWriter()</code> </li><li>  en la <code>Collection</code> : <code>T[] toArray(IntFunction&lt;T[]&gt;)</code> </li><li>  en <code>Optional</code> : <code>boolean isEmpty()</code> </li><li>  en <code>Predicate</code> : <code>Predicate</code> <code>static Predicate&lt;T&gt; not(Predicate&lt;T&gt;)</code> </li><li>  en <code>Pattern</code> : <code>Predicate&lt;String&gt; asMatchPredicate()</code> </li></ul><br><p>  ¬°Divi√©rtete con Java 11! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441154/">https://habr.com/ru/post/441154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441142/index.html">12 puntos de crecimiento de conversi√≥n o contenido que realmente vende</a></li>
<li><a href="../441146/index.html">Redes inal√°mbricas industriales: ¬øcu√°l elegir?</a></li>
<li><a href="../441148/index.html">C√≥mo manejar los errores correctamente: el silencio no siempre es bueno</a></li>
<li><a href="../441150/index.html">Primera introducci√≥n al protocolo HTTP escribiendo el servidor web Java m√°s simple</a></li>
<li><a href="../441152/index.html">C√≥mo minimizar los errores al integrarse con servicios externos: la experiencia de un corredor en l√≠nea</a></li>
<li><a href="../441158/index.html">C√≥mo la √©tica se convirti√≥ en el problema m√°s costoso de Silicon Valley, y la filosof√≠a se convirti√≥ en su soluci√≥n m√°s pr√°ctica</a></li>
<li><a href="../441160/index.html">C√≥mo aprender a determinar cu√°ndo decir no</a></li>
<li><a href="../441166/index.html">Obtenemos la contrase√±a maestra del administrador de contrase√±as bloqueadas 1 Contrase√±a 4</a></li>
<li><a href="../441168/index.html">Canales de datos QUIC: primeros pasos</a></li>
<li><a href="../441172/index.html">C√≥mo creci√≥ el mercado de la impresi√≥n 3D en 2018 y lo que significa para las empresas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>