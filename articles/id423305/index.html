<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≤üèª ‚òùÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèø Merusak kinerja üë©‚Äçüöí üè¢ ü•í</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan ini adalah versi tertulis dari laporan saya "Cara merusak kinerja dengan kode yang tidak efisien" dari konferensi JPoint 2018. Anda dapat meno...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merusak kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423305/"><p>  Catatan ini adalah versi tertulis dari laporan saya "Cara merusak kinerja dengan kode yang tidak efisien" dari konferensi JPoint 2018. Anda dapat menonton video dan slide di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman konferensi</a> .  Dalam jadwal, laporan ditandai dengan segelas smoothie ofensif, sehingga tidak akan ada yang super rumit, ini lebih cenderung untuk pemula. </p><br><p>  Subjek laporan: </p><br><ul><li>  cara melihat kode untuk menemukan kemacetan di dalamnya </li><li>  antipatterns umum </li><li>  menyapu tidak jelas </li><li>  menyapu memotong </li></ul><br><p>  Di sela-sela, mereka menunjukkan beberapa ketidakakuratan / kelalaian dalam laporan, mereka dicatat di sini.  Komentar juga diterima. </p><a name="habracut"></a><br><h2 id="vliyanie-poryadka-ispolneniya-na-proizvoditelnost">  Dampak Kinerja terhadap Kinerja </h2><br><p>  Ada kelas pengguna: </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  Kita perlu membandingkan objek satu sama lain, jadi kita mendeklarasikan metode <code>equals</code> dan <code>hashCode</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lombok.EqualsAndHashCode; <span class="hljs-meta"><span class="hljs-meta">@EqualsAndHashCode</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  Kode ini bisa diterapkan, pertanyaannya berbeda: apakah kinerja kode ini akan menjadi yang terbaik?  Untuk menjawabnya, mari kita mengingat fitur dari metode <code>Object::equals</code> : ia mengembalikan hasil positif hanya ketika semua bidang yang dibandingkan adalah sama, jika tidak hasilnya akan negatif.  Dengan kata lain, satu perbedaan sudah cukup untuk hasil negatif. </p><br><p>  Setelah melihat kode yang dihasilkan untuk <code>@EqualsAndHashCode</code> kita akan melihat sesuatu seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object that)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... if (name == null &amp;&amp; that.name != null) { return false; } if (name != null &amp;&amp; !name.equals(that.name)) { return false; } return age == that.age; }</span></span></code> </pre> <br><p>  Urutan memeriksa bidang sesuai dengan urutan deklarasi mereka, yang dalam kasus kami bukan solusi terbaik, karena membandingkan objek menggunakan <code>equals</code> "lebih sulit" daripada membandingkan tipe sederhana. </p><br><p>  Ok, mari kita coba membuat metode <code>equals/hashCode</code> menggunakan Idea: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } User that = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age == that.age &amp;&amp; Objects.equals(name, that.name); }</code> </pre> <br><p>  Suatu Ide menciptakan kode yang lebih cerdas yang mengetahui kerumitan membandingkan berbagai jenis data.  Nah, kita akan <code>@EqualsAndHashCode</code> dan kita akan secara eksplisit menulis <code>equals/hashCode</code> .  Sekarang mari kita lihat apa yang terjadi ketika kelas diperluas: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ List&lt;T&gt; props; String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; }</code> </pre> <br><p>  <code>equals/hashCode</code> rekreasi <code>equals/hashCode</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } User that = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> age == that.age &amp;&amp; Objects.equals(props, that.props) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- &amp;&amp; Objects.equals(name, that.name); }</span></span></code> </pre> <br><p>  Daftar dibandingkan sebelum string dibandingkan, yang tidak masuk akal ketika string berbeda.  Pada pandangan pertama, tidak ada banyak perbedaan, karena string dengan panjang yang sama dibandingkan dengan tanda (yaitu, waktu perbandingan tumbuh bersama dengan panjang string): </p><br><div class="spoiler">  <b class="spoiler_title">Ada ketidakakuratan</b> <div class="spoiler_text"><p>  Metode <code>java.lang.String::equals</code> <a href="">adalah intrusif</a> , jadi tidak ada perbandingan akses saat eksekusi. </p></div></div><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.String public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { // &lt;---- if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }</span></span></code> </pre> <br><p>  Sekarang pertimbangkan untuk membandingkan dua <code>ArrayList</code> (sebagai implementasi daftar yang paling umum digunakan).  Meneliti <code>ArrayList</code> , kami terkejut menemukan bahwa ia tidak memiliki implementasi yang <code>equals</code> , tetapi menggunakan implementasi yang diwarisi: </p><br><p><img src="https://habrastorage.org/webt/d4/hn/yg/d4hnyguezlpyxz3pgunk22ha1cm.png"></p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//AbstractList::equals public boolean equals(Object o) { if (o == this) { return true; } if (!(o instanceof List)) { return false; } ListIterator&lt;E&gt; e1 = listIterator(); ListIterator&lt;?&gt; e2 = ((List&lt;?&gt;) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) { // &lt;---- E o1 = e1.next(); Object o2 = e2.next(); if (!(o1 == null ? o2 == null : o1.equals(o2))) { return false; } } return !(e1.hasNext() || e2.hasNext()); }</span></span></code> </pre> <br><p>  Penting di sini adalah penciptaan dua iterator dan berpasangan melalui mereka.  Misalkan ada dua <code>ArrayList</code> : </p><br><ul><li>  dalam satu nomor dari 1 hingga 99 </li><li>  dalam angka kedua dari 1 hingga 100 </li></ul><br><p>  Idealnya, akan cukup untuk membandingkan ukuran kedua daftar dan jika mereka tidak bersamaan, segera kembalikan hasil negatif (seperti yang dilakukan <code>AbstractSet</code> ), dalam kenyataannya, 99 perbandingan akan dilakukan dan hanya pada keseratus akan menjadi jelas bahwa daftar tersebut berbeda. </p><br><h4 id="chyo-tam-u-kotlinovcev">  Ada apa dengan orang Kotlin? </h4><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>);</code> </pre> <br><p>  Di sini semuanya seperti Lombok - urutan perbandingan sesuai dengan urutan pengumuman: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> User) { User u = (User) o; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Intrinsics.areEqual(name, u.name) &amp;&amp; age == u.age) { <span class="hljs-comment"><span class="hljs-comment">// &lt;---- return true; } } return false; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara memperbaiki situasi?</b>  <b class="spoiler_title">- mengeluh!</b> <div class="spoiler_text"><p>  IDEA-170178 Perbandingan koleksi harus dieksekusi pada saat yang sama dengan yang dihasilkan oleh IDEA () <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-170178</a> </p><br><p>  Menyusun ulang perbandingan di @EqualsAndHashCode untuk kinerja yang lebih baik # 1543 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/rzwitserloot/lombok/issues/1543</a> </p><br><p>  KT-23184 yang dihasilkan secara otomatis sama dengan () dari kelas data tidak optimal <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/KT-23184</a> </p></div></div><br><p>  Sebagai solusinya, Anda bisa mengatur deklarasi lapangan secara manual. </p><br><h4 id="uslozhnim-zadachu">  Mari menyulitkan tugas </h4><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ SomeEntity entity = jpaRepository.findOne(dto.getId()); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> valid = dto.isValid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valid &amp;&amp; entity.hasGoodRating()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;---- //do smth } }</span></span></code> </pre> <br><p>  Kode ini melibatkan pengaksesan basis data bahkan ketika hasil dari pengecekan kondisi yang ditunjukkan oleh panah sudah dapat diprediksi sebelumnya.  Jika nilai variabel yang <code>valid</code> salah, maka kode di blok <code>if</code> tidak akan pernah dijalankan, yang berarti Anda bisa melakukannya tanpa permintaan: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> valid = dto.isValid(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valid &amp;&amp; hasGoodRating(dto)) { <span class="hljs-comment"><span class="hljs-comment">//do smth } } //       ,    boolean hasGoodRating(Dto dto) { SomeEntity entity = jpaRepository.findOne(dto.getId()); return entity.hasGoodRating(); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Catatan dari sela-sela</b> <div class="spoiler_text"><p>  Sinking bisa tidak signifikan ketika entitas kembali dari <code>JpaRepository::findOne</code> sudah ada di cache tingkat pertama - maka tidak akan ada permintaan. </p></div></div><br><p>  Contoh serupa tanpa bercabang eksplisit: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ Long id = dto.getId(); Entity entity = jpaRepository.findOne(id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dto.isValid() &amp;&amp; entity.hasChild(); }</code> </pre> <br><p>  Pengembalian cepat memungkinkan Anda untuk menunda permintaan: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dto dto)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dto.isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jpaRepository.findOne(dto.getId()).hasChild(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Tambahan yang cukup jelas yang tidak muncul dalam laporan</b> <div class="spoiler_text"><p>  Bayangkan bahwa cek tertentu menggunakan entitas yang serupa: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span>(fetch = LAZY) <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"CHILD_ID"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ChildEntity child; <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.String) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SomeType type;</code> </pre> <br><p>  Jika pemeriksaan menggunakan entitas yang sama, maka Anda harus memastikan bahwa panggilan ke entitas / koleksi anak "malas" dilakukan setelah panggilan ke bidang yang sudah dimuat.  Pada pandangan pertama, satu permintaan tambahan tidak akan memiliki dampak signifikan pada keseluruhan gambar, tetapi semuanya bisa berubah ketika suatu tindakan dilakukan dalam satu lingkaran. </p></div></div><br><p>  Kesimpulan: rantai tindakan / pemeriksaan harus dipesan dalam rangka meningkatkan kompleksitas operasi individu, mungkin beberapa dari mereka tidak harus dilakukan. </p><br><h2 id="cikly-i-massovaya-obrabotka">  Siklus dan Pemrosesan Massal </h2><br><p>  Contoh berikut tidak perlu penjelasan khusus: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enrollStudents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;Long&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Student student = jpaRepository.findOne(id); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- O(n) enroll(student); } }</span></span></code> </pre> <br><p>  Karena beberapa permintaan basis data, kode ini lambat. </p><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text"><p>  Kinerja dapat tenggelam lebih banyak lagi jika metode <code>enrollStudents</code> dijalankan di luar transaksi: maka <strong>setiap</strong> panggilan ke <code>osdjrJpaRepository::findOne</code> akan dieksekusi dalam transaksi baru (lihat <a href="">SimpleJpaRepository</a> ), yang berarti menerima dan mengembalikan koneksi ke database, serta membuat dan membilas cache tingkat pertama. </p></div></div><br><p>  Perbaiki: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enrollStudents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;Long&gt; ids)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Student student : jpaRepository.findAll(ids)) { enroll(student); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mari kita ukur runtime (dalam mikrodetik) untuk koleksi kunci (10 dan 100 buah)</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/p2/0b/zq/p20bzq2tlnp3-mj8zlx8c96411e.png"></p></div></div><br><p>  <a href="">Tolok ukur</a> </p><br><div class="spoiler">  <b class="spoiler_title">Komentar</b> <div class="spoiler_text"><p>  Jika Anda menggunakan Oracle dan memberikan lebih dari 1000 kunci untuk menemukanAll, maka Anda akan mendapatkan pengecualian <code>ORA-01795: maximum number of expressions in a list is 1000</code> . <br>  Juga, melakukan tugas yang berat (dengan banyak tombol) <code>in</code> kueri mungkin lebih buruk daripada n kueri.  Itu semua tergantung pada aplikasi spesifik, sehingga penggantian mekanis dari siklus ke pemrosesan massal dapat menurunkan kinerja. </p></div></div><br><h4 id="bolee-slozhnyy-primer-na-tu-zhe-temu">  Contoh yang lebih kompleks tentang topik yang sama </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Region region = jpaRepository.findOne(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----  region = new Region(); region.setId(id); } use(region); }</span></span></code> </pre> <br><p>  Dalam kasus ini, kami tidak dapat mengganti loop dengan <code>JpaRepository::findAll</code> , <code>JpaRepository::findAll</code> ini akan mematahkan logika: semua nilai yang diperoleh dari <code>JpaRepository::findAll</code> tidak akan menjadi <code>null</code> dan blok <code>if</code> tidak akan berfungsi. </p><br><p>  Fakta bahwa untuk setiap kunci basis data akan membantu kami mengatasi kesulitan ini <br>  mengembalikan nilai aktual atau ketidakhadirannya.  Dalam arti tertentu, basis data adalah kamus.  Java dari kotak memberi kami implementasi kamus yang sudah jadi - <code>HashMap</code> - di atasnya kami akan membangun logika untuk mengganti database: </p><br><pre> <code class="java hljs">Map&lt;Long, Region&gt; regionMap = jpaRepository.findAll(ids) .stream() .collect(Collectors.toMap(Region::getId, Function.identity())); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : ids) { Region region = map.get(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { region = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Region(); region.setId(id); } use(region); }</code> </pre> <br><h4 id="primer-v-obratnuyu-storonu">  Membalikkan contoh </h4><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// class Saver @Transactional(propagation = Propagation.REQUIRES_NEW) public void save(List&lt;AuditEntity&gt; entities) { jpaRepository.save(entities); }</span></span></code> </pre> <br><p>  Kode ini selalu membuat transaksi baru untuk menyimpan daftar entitas.  Kendor dimulai dengan beberapa panggilan ke metode yang membuka transaksi baru: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   @Transactional public void audit(List&lt;AuditDto&gt; inserts) { inserts.map(this::toEntities).forEach(saver::save); // &lt;---- } // class Saver @Transactional(propagation = Propagation.REQUIRES_NEW) // &lt;---- public void save(List&lt;AuditEntity&gt; entities) { jpaRepository.save(entities); }</span></span></code> </pre> <br><p>  Solusi: terapkan metode <code>Saver::save</code> segera untuk seluruh kumpulan data: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">audit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;AuditDto&gt; inserts)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;AuditEntity&gt; bulk = inserts .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::toEntities) .flatMap(List::stream) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- .collect(toList()); saver.save(bulk); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Banyak transaksi bergabung menjadi satu, yang memberikan peningkatan nyata (waktu dalam mikrodetik):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/f7/3r/n9/f73rn9gtjw7fdgiqrfwkq7tfme4.png"></p></div></div><br><p>  <a href="">Tolok ukur</a> </p><br><p>  Contoh dengan beberapa transaksi sulit diformalkan, yang tidak dapat dikatakan tentang memanggil <code>JpaRepository::findOne</code> dalam satu lingkaran. </p><br><div class="spoiler">  <b class="spoiler_title">Karena itu, kami akan mengambil tindakan</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-165730</a> <br>  IDEA-165730 Peringatkan tentang penggunaan JpaRepository yang tidak efisien </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-165942</a> <br><del>  IDEA-165942 </del>  Inspeksi untuk mengganti pemanggilan metode dalam satu lingkaran dengan operasi massal <br>  <strong>Diperbaiki pada 2017.1</strong> </p></div></div><br><p>  Pendekatan ini tidak hanya berlaku untuk basis data, jadi Tagir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">lany</a> Valeev melangkah lebih jauh.  Dan jika sebelumnya kita menulis seperti ini: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long id : items) { list.add(id); }</code> </pre> <br><p>  dan semuanya baik-baik saja, sekarang "Ide" menyarankan untuk memperbaiki dirinya sendiri: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.addAll(items);</code> </pre> <br><p>  Tetapi bahkan opsi ini tidak selalu memuaskannya, karena Anda dapat membuatnya lebih pendek dan lebih cepat: </p><br><pre> <code class="java hljs">List&lt;Long&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(items);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bandingkan (waktu dalam ns)</b> <div class="spoiler_text"><p>  Untuk ArrayList, peningkatan ini memberikan peningkatan yang nyata: </p><br><p><img src="https://habrastorage.org/webt/gi/6j/o8/gi6jo8xwigpdckqz6jtuw4cmane.png"></p><br><p>  Untuk HashSet, itu tidak begitu cerah: </p><br><p><img src="https://habrastorage.org/webt/u9/lo/fy/u9lofyf2wy2hffk8gd0uwvrmmke.png"></p></div></div><br><p>  <a href="">Tolok ukur</a> </p><br><div class="spoiler">  <b class="spoiler_title">Berguna untuk pengembang:</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-138456</a> <br><del>  IDEA-138456 </del>  Inspeksi baru: Collection.addAll () dapat diganti dengan konstruktor parametrized <br>  <strong>Diperbaiki pada 142.1217</strong> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-178761</a> <br><del>  IDEA-178761 </del>  Inspeksi 'Collection.addAll () dapat diganti dengan konstruktor parametrized' harus diaktifkan secara default <br>  <strong>Diperbaiki pada 2017.3</strong> </p></div></div><br><h4 id="udalenie-iz-arraylist-a">  Menghapus dari <code>ArrayList</code> </h4><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { list.remove(from); }</code> </pre> <br><p>  Masalahnya adalah dalam mengimplementasikan metode <code>List::remove</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ Objects.checkIndex(index, size); modCount++; E oldValue = elementData(index); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numMoved = size - index - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numMoved &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { System.arraycopy(array, index + <span class="hljs-number"><span class="hljs-number">1</span></span>, array, index, numMoved); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- } array[--size] = null; // clear to let GC do its work return oldValue; }</span></span></code> </pre> <br><p>  Solusi: </p><br><pre> <code class="java hljs">list.subList(from, to).clear();</code> </pre> <br><p>  Tetapi bagaimana jika nilai jarak jauh digunakan dalam kode sumber? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { E removed = list.remove(from); use(removed); }</code> </pre> <br><p>  Sekarang Anda harus melalui daftar yang dibersihkan terlebih dahulu: </p><br><pre> <code class="java hljs">List&lt;String&gt; removed = list.subList(from, to); removed.forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::use); removed.clear();</code> </pre> <br><p>  Jika Anda benar-benar ingin menghapus dalam siklus, maka perubahan dalam arah perjalanan melalui daftar akan membantu meringankan rasa sakit.  Artinya adalah untuk menggeser sejumlah kecil elemen setelah membersihkan sel: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   , . .       for (int i = from; i &lt; to; i++) { E removed = list.remove(from); use(removed, i); } //  , . .    for (int i = to - 1; i &gt;= from; i--) { E removed = list.remove(i); use(removed, reverseIndex(i)); }</span></span></code> </pre> <br><p>  Bandingkan ketiga metode (di bawah kolom adalah% item yang dihapus dari daftar ukuran 100): </p><br><div class="spoiler">  <b class="spoiler_title">Java 8</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/4h/ii/tq/4hiitqg5a7d3bk6lxi8od422yky.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Jawa 9</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ow/mo/ty/owmotysgwdqquagklf1yhlrquz0.png"></p></div></div><br><p>  Ngomong-ngomong, apakah seseorang memperhatikan anomali? </p><br><div class="spoiler">  <b class="spoiler_title">Untuk melihat</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/ni/s9/xmnis9jllk8rozgh8xacdneyhd8.png"></p><br><p>  Jika kami menghapus setengah dari semua data yang bergerak dari ujung, maka elemen terakhir selalu dihapus dan tidak ada perubahan: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ArrayList public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) { // &lt;----     System.arraycopy(elementData, index+1, elementData, index, numMoved); } elementData[--size] = null; // clear to let GC do its work return oldValue; }</span></span></code> </pre> </div></div><br><p>  <a href="">Tolok ukur</a> </p><br><div class="spoiler">  <b class="spoiler_title">Berguna untuk pengembang</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-177466</a> <br><del>  IDEA-177466 </del>  Detect List.remove (index) dipanggil dalam satu lingkaran <br>  <strong>Diperbaiki pada 2018.2</strong> </p></div></div><br><p>  Kesimpulan: operasi massal seringkali lebih cepat daripada operasi tunggal. </p><br><h2 id="oblast-vidimosti-i-proizvoditelnost">  Lingkup dan kinerja </h2><br><p>  Kode ini tidak memerlukan penjelasan khusus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaveForTheSecondYear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Student&gt; naughty = repository.findNaughty(); List&lt;Student&gt; underAchieving = repository.findUnderAchieving(); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- if (settings.leaveBothCategories()) { leaveForTheSecondYear(naughty, underAchieving); // &lt;---- return; } leaveForTheSecondYear(naughty); }</span></span></code> </pre> <br><p>  Kami mempersempit ruang lingkup, yang memberikan kueri minus 1: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leaveForTheSecondYear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Student&gt; naughty = repository.findNaughty(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Settings.leaveBothCategories()) { List&lt;Student&gt; underAchieving = repository.findUnderAchieving(); <span class="hljs-comment"><span class="hljs-comment">// &lt;---- leaveForTheSecondYear(naughty, underAchieving); // &lt;---- return; } leaveForTheSecondYear(naughty); }</span></span></code> </pre> <br><p>  Dan di sini pembaca yang penuh perhatian harus bertanya: bagaimana dengan analisis statis?  Mengapa Ide tidak memberi tahu kami tentang peningkatan yang terjadi di permukaan? </p><br><p>  Faktanya adalah bahwa kemungkinan analisis statis terbatas: jika metode ini kompleks (terutama berinteraksi dengan database) dan mempengaruhi keadaan umum, maka mentransfer pelaksanaannya dapat merusak aplikasi.  Analyzer statis dapat melaporkan eksekusi yang sangat sederhana, yang transfernya, katakanlah, di dalam blok tidak akan merusak apa pun. </p><br><p>  Anda dapat menggunakan penyorotan variabel sebagai variabel, tetapi sekali lagi, gunakan dengan hati-hati, karena efek samping selalu mungkin.  Anda dapat menggunakan anotasi <code>@org.jetbrains.annotations.Contract(pure = true)</code> , tersedia dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jetbrains-annotations</a> untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menunjukkan</a> metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stateless</a> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// com.intellij.util.ArrayUtil @Contract(pure = true) public static int find(@NotNull int[] src, int obj) { return indexOf(src, obj); }</span></span></code> </pre> <br><p>  Kesimpulan: lebih sering daripada tidak, kerja berlebihan hanya memengaruhi kinerja. </p><br><h2 id="samyy-neobychnyy-primer">  Contoh paling tidak biasa </h2><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RemoteService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ContractCounter contractCounter; <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span>(readOnly = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;---- public int countContracts(Dto dto) { if (dto.isInvalid()) { return -1; // &lt;---- } return contractCounter.countContracts(dto); } }</span></span></code> </pre> <br><p>  Implementasi ini membuka transaksi bahkan ketika transaksi tidak diperlukan (pengembalian cepat -1 dari metode). </p><br><p>  Yang perlu Anda lakukan adalah menghapus transaksionalitas di dalam metode <code>ContractCounter::countContracts</code> , di mana diperlukan, dan menghapusnya dari metode "eksternal". </p><br><div class="spoiler">  <b class="spoiler_title">Bandingkan waktu eksekusi untuk kasus ketika -1 (ns) dikembalikan:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8k/uu/lp/8kuulppcl4vli1c5ir-txozcemi.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Bandingkan konsumsi memori (byte):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xp/du/ke/xpdukewr4nnooj2vtaktok4ngnm.png"></p></div></div><br><p>  <a href="">Tolok ukur</a> </p><br><p>  Kesimpulan: pengontrol dan layanan yang tampak "keluar" perlu dibebaskan dari transaksionalitas (ini bukan tanggung jawab mereka) dan seluruh logika verifikasi data input, yang tidak memerlukan akses ke database dan komponen transaksional, harus diambil di sana. </p><br><h2 id="preobrazovanie-datyvremeni-v-stroku">  Ubah tanggal / waktu menjadi string </h2><br><p>  Salah satu tugas abadi adalah mengubah tanggal / waktu menjadi string.  Sebelum G8, kami melakukan ini: </p><br><pre> <code class="java hljs">SimpleDateFormat formatter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); String dateAsStr = formatter.format(date);</code> </pre> <br><p>  Dengan rilis JDK 8, kami mendapat <code>LocalDate/LocalDateTime</code> dan, karenanya, <code>DateTimeFormatter</code> </p><br><pre> <code class="java hljs">DateTimeFormatter formatter = ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); String dateAsStr = formatter.format(localDate);</code> </pre> <br><p>  Mari kita ukur kinerjanya: </p><br><pre> <code class="java hljs">Date date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(); LocalDate localDate = LocalDate.now(); SimpleDateFormat sdf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="hljs-string"><span class="hljs-string">"dd.MM.yyyy"</span></span>); <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simpleDateFormat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdf.format(date); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dateTimeFormatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dtf.format(localDate); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Waktu:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/zq/jq/sx/zqjqsxjevqpmuckdddvu4gysaoa.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Memori (byte):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9j/yq/sw/9jyqswjtyiwq3i8fkutenvyuj7g.png"></p></div></div><br><p>  Pertanyaan: misalkan layanan kami menerima data dari luar dan kami tidak bisa menolak <code>java.util.Date</code> .  Apakah bermanfaat bagi kita untuk mengonversi <code>Date</code> ke <code>LocalDate</code> jika yang terakhir lebih cepat dikonversi ke string?  Hitung: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureDateConverted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ LocalDate localDate = toLocalDate(data.date); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.dateTimeFormatter.format(localDate); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> LocalDate </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toLocalDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date date)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate(); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Waktu:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/j5/ob/mf/j5obmfec_kvfivo46wat9rmf8e8.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Memori (byte):</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hx/hm/on/hxhmon8ss12qyv9s4is6byoy164.png"></p></div></div><br><p>  Dengan demikian, <code>Date</code> konversi -&gt; <code>LocalDate</code> bermanfaat saat menggunakan "sembilan".  Di G8, biaya konversi akan melahap semua manfaat <code>DateTimeFormatter</code> -a. </p><br><p>  <a href="">Tolok ukur</a> </p><br><p>  Kesimpulan: manfaatkan solusi baru. </p><br><h2 id="eschyo-vosmyorka">  "Delapan" lainnya </h2><br><p>  Dalam kode ini, kita melihat redundansi yang jelas: </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items <span class="hljs-comment"><span class="hljs-comment">// ArrayList&lt;Integer&gt; .stream() .map(Long::valueOf) .collect(toList()) // &lt;----    ? .iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); }</span></span></code> </pre> <br><p>  Kami menghapusnya: </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items <span class="hljs-comment"><span class="hljs-comment">// ArrayList&lt;Integer&gt; .stream() .map(Long::valueOf) .iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mari kita lihat seberapa banyak peningkatan kinerja:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/un/mp/pf/unmppfr6sd8ybi3k7r7jrdsdfty.png"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Bandingkan dengan sembilan:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hc/rb/p9/hcrbp98qezjcm5fegv27cywcadu.png"></p></div></div><br><p>  Luar biasa bukan?  Saya berpendapat di atas bahwa kelebihan kerja menurunkan kinerja.  Tapi di sini kita menghapus kelebihan - dan (tiba-tiba) semakin buruk.  Untuk memahami apa yang terjadi, ambil dua iterator dan lihatlah di bawah kaca pembesar: </p><br><div class="spoiler">  <b class="spoiler_title">Diungkapkan</b> <div class="spoiler_text"><pre> <code class="java hljs">Iterator iterator1 = items.stream().collect(toList()).iterator(); Iterator iterator2 = items.stream().iterator();</code> </pre> <br><p><img src="https://habrastorage.org/webt/rn/ah/kf/rnahkfz2qdyuw0k_cjeorqawqki.png"></p></div></div><br><p>  Iterator pertama adalah <code>ArrayList$Itr</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Bagian yang melaluinya sederhana:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cursor != size; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> E </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ checkForComodification(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = cursor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= size) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NoSuchElementException(); } Object[] elementData = ArrayList.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= elementData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentModificationException(); } cursor = i + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (E) elementData[lastRet = i]; }</code> </pre> <br><p><img src="https://habrastorage.org/webt/ug/yb/pi/ugybpiiwmjj5-fbcazvmfdjd2tq.png"></p></div></div><br><p>  Yang kedua lebih menarik, itu adalah <code>Spliterators$Adapter</code> , yang didasarkan pada <code>ArrayList$ArrayListSpliterator</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Melewati itu lebih sulit</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// java.util.Spliterators$Adapter public boolean hasNext() { if (!valueReady) spliterator.tryAdvance(this); return valueReady; } public T next() { if (!valueReady &amp;&amp; !hasNext()) throw new NoSuchElementException(); else { valueReady = false; return nextElement; } }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/pf/5p/gj/pf5pgjkfhhfw__h8ie7m6oflxqq.png"></p></div></div><br><p>  Mari kita lihat iterator iteration melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">async-profiler</a> : </p><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">15.64</span></span>% juArrayList$ArrayListSpliterator.tryAdvance <span class="hljs-number"><span class="hljs-number">10.67</span></span>% jusSpinedBuffer.<span class="hljs-keyword"><span class="hljs-keyword">clear</span></span> <span class="hljs-number"><span class="hljs-number">9.86</span></span>% juSpliterators$1Adapter.hasNext <span class="hljs-number"><span class="hljs-number">8.81</span></span>% jusStreamSpliterators$AbstractWrappingSpliterator.fillBuffer <span class="hljs-number"><span class="hljs-number">6.01</span></span>% oojiBlackhole.consume <span class="hljs-number"><span class="hljs-number">5.71</span></span>% jusReferencePipeline$3$1.accept <span class="hljs-number"><span class="hljs-number">5.57</span></span>% jusSpinedBuffer.accept <span class="hljs-number"><span class="hljs-number">5.06</span></span>% cllbir.IteratorFromStreamBenchmark.iteratorFromStream <span class="hljs-number"><span class="hljs-number">4.80</span></span>% jlLong.valueOf <span class="hljs-number"><span class="hljs-number">4.53</span></span>% cllbiIteratorFromStreamBenchmark$$Lambda$8<span class="hljs-number"><span class="hljs-number">.885721577</span></span>.apply</code> </pre> <br><p>  Dapat dilihat bahwa sebagian besar waktu dihabiskan untuk melewati iterator, meskipun pada umumnya, kita tidak membutuhkannya, karena pencarian dapat dilakukan seperti ini: </p><br><pre> <code class="java hljs">items .stream() .map(Long::valueOf) .forEach(bh::consume);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Bandingkan dengan yang lain:</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rf/is/i0/rfisi0vsfoezlcvtd43h2lhlvfi.png"></p></div></div><br><p>  <code>Stream::forEach</code> jelas merupakan pemenang, tetapi ini aneh: masih berdasarkan <code>ArrayListSpliterator</code> , tetapi penggunaannya telah meningkat secara signifikan. </p><br><div class="spoiler">  <b class="spoiler_title">Mari kita lihat profilnya:</b> <div class="spoiler_text"><pre> <code class="hljs powershell"><span class="hljs-number"><span class="hljs-number">29.04</span></span>% oojiBlackhole.consume <span class="hljs-number"><span class="hljs-number">22.92</span></span>% juArrayList<span class="hljs-variable"><span class="hljs-variable">$ArrayListSpliterator</span></span>.forEachRemaining <span class="hljs-number"><span class="hljs-number">14.47</span></span>% jusReferencePipeline<span class="hljs-variable"><span class="hljs-variable">$3</span></span><span class="hljs-variable"><span class="hljs-variable">$1</span></span>.accept <span class="hljs-number"><span class="hljs-number">8.79</span></span>% jlLong.valueOf <span class="hljs-number"><span class="hljs-number">5.37</span></span>% cllbiIteratorFromStreamBenchmark<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$Lambda</span></span><span class="hljs-variable"><span class="hljs-variable">$9</span></span>.<span class="hljs-number"><span class="hljs-number">617691115</span></span>.accept <span class="hljs-number"><span class="hljs-number">4.84</span></span>% cllbiIteratorFromStreamBenchmark<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$Lambda</span></span><span class="hljs-variable"><span class="hljs-variable">$8</span></span>.<span class="hljs-number"><span class="hljs-number">1964917002</span></span>.apply <span class="hljs-number"><span class="hljs-number">4.43</span></span>% jusForEachOps<span class="hljs-variable"><span class="hljs-variable">$ForEachOp</span></span><span class="hljs-variable"><span class="hljs-variable">$OfRef</span></span>.accept <span class="hljs-number"><span class="hljs-number">4.17</span></span>% jusSink<span class="hljs-variable"><span class="hljs-variable">$ChainedReference</span></span>.end <span class="hljs-number"><span class="hljs-number">1.27</span></span>% jlInteger.longValue <span class="hljs-number"><span class="hljs-number">0.53</span></span>% jusReferencePipeline.map</code> </pre> </div></div><br><p>  Dalam profil ini, sebagian besar waktu dihabiskan untuk "menelan" nilai-nilai di dalam <code>Blackhole</code> .  Dibandingkan dengan iterator, sebagian besar waktu dihabiskan secara langsung untuk mengeksekusi kode Java.  Dapat diasumsikan bahwa alasannya adalah berat spesifik yang lebih rendah dari pengumpulan sampah, dibandingkan dengan kekuatan kasar iterator.  Periksa: </p><br><pre> <code class="java hljs">forEach:¬∑gc.alloc.rate.norm <span class="hljs-number"><span class="hljs-number">100</span></span> avgt <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">216</span></span>,<span class="hljs-number"><span class="hljs-number">001</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">002</span></span> B/op iteratorFromStream:¬∑gc.alloc.rate.norm <span class="hljs-number"><span class="hljs-number">100</span></span> avgt <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">416</span></span>,<span class="hljs-number"><span class="hljs-number">004</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">006</span></span> B/op</code> </pre> <br><p>  Memang, <code>Stream::forEach</code> menyediakan setengah konsumsi memori. </p><br><div class="spoiler">  <b class="spoiler_title">Kenapa lebih cepat?</b> <div class="spoiler_text"><p>  Rantai panggilan dari awal hingga lubang hitam terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/2f/5w/1y/2f5w1ydxlo5oomf8bfmhbqtynze.png"></p><br><p>  Seperti yang Anda lihat, panggilan ke <code>ArrayListSpliterator::tryAdvance</code> menghilang dari rantai, dan <code>ArrayListSpliterator::forEachRemaining</code> muncul <code>ArrayListSpliterator::forEachRemaining</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ArrayListSpliterator public void forEachRemaining(Consumer&lt;? super E&gt; action) { int i, hi, mc; // hoist accesses and checks from loop ArrayList&lt;E&gt; lst; Object[] a; if (action == null) throw new NullPointerException(); if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) { if ((hi = fence) &lt; 0) { mc = lst.modCount; hi = lst.size; } else mc = expectedModCount; if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) { for (; i &lt; hi; ++i) { @SuppressWarnings("unchecked") E e = (E) a[i]; // &lt;---- action.accept(e); } if (lst.modCount == mc) return; } } throw new ConcurrentModificationException(); }</span></span></code> </pre> <br><p>  <code>ArrayListSpliterator::forEachRemaining</code> kecepatan tinggi <code>ArrayListSpliterator::forEachRemaining</code> dicapai dengan menggunakan seluruh array dalam 1 metode panggilan.  Saat menggunakan iterator, bagian ini terbatas pada satu elemen, jadi kami selalu bersandar pada <code>ArrayListSpliterator::tryAdvance</code> . <br>  <code>ArrayListSpliterator::forEachRemaining</code> memiliki akses ke seluruh array dan <code>ArrayListSpliterator::forEachRemaining</code> dengan siklus penghitungan tanpa panggilan tambahan. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Pemberitahuan penting</b> <div class="spoiler_text"><p>  Harap dicatat bahwa penggantian mekanik </p><br><pre> <code class="java hljs">Iterator&lt;Long&gt; iterator = items .stream() .map(Long::valueOf) .collect(toList()) .iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iterator.hasNext()) { bh.consume(iterator.next()); }</code> </pre> <br><p>  pada </p><br><pre> <code class="java hljs">items .stream() .map(Long::valueOf) .forEach(bh::consume);</code> </pre> <br><p>  Itu tidak selalu setara, karena dalam kasus pertama kami menggunakan salinan data untuk bagian tanpa mempengaruhi aliran itu sendiri, dan dalam kasus kedua data diambil langsung dari aliran. </p></div></div><br><p>  <a href="">Tolok ukur</a> </p><br><p>  Kesimpulan: ketika berhadapan dengan representasi data yang kompleks, bersiaplah untuk fakta bahwa bahkan aturan "besi" (bahaya kerja ekstra) berhenti bekerja.  Contoh di atas menunjukkan bahwa daftar perantara yang tampaknya berlebihan memberikan keuntungan dari pelaksanaan enumerasi yang lebih cepat. </p><br><h4 id="dva-podvoha">  Dua trik </h4><br><pre> <code class="java hljs">StackTraceElement[] trace = th.getStackTrace(); StackTraceElement[] newTrace = Arrays .asList(trace) .subList(<span class="hljs-number"><span class="hljs-number">0</span></span>, depth) .toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StackTraceElement[newDepth]); <span class="hljs-comment"><span class="hljs-comment">// &lt;----</span></span></code> </pre> <br><p>  Hal pertama yang menarik perhatian Anda adalah "perbaikan" busuk, yaitu, melewatkan array dengan panjang nol ke metode <code>Collection::toArray</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini</a> menjelaskan dengan sangat terperinci mengapa ini berbahaya. </p><br><p>  Masalah kedua tidak begitu jelas, dan untuk pemahamannya kita dapat menarik paralel antara karya pengkaji dan sejarawan. </p><br><div class="spoiler">  <b class="spoiler_title">Inilah yang ditulis Robin Collingwood tentang ini:</b> <div class="spoiler_text"><p> , ,   []       ‚Äì  . <strong>             </strong> .   , <strong>    ,    </strong> ... </p></div></div><br><p>       <strong></strong>      .      : </p><br><p> 1)     <br> 2)    <br> 3)       </p><br><p>      ,      : </p><br><pre> <code class="java hljs">StackTraceElement[] trace = th.getStackTrace(); StackTraceElement[] newTrace = Arrays.copyOf(trace, depth); <span class="hljs-comment"><span class="hljs-comment">//    0 //  StackTraceElement[] newTrace = Arrays.copyOfRange(trace, 0, depth); //   0</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xg/ia/-8/xgia-8mdesgh-cpqm1cla0n8zz4.png"></p></div></div><br><p> <a href=""></a> </p><br><h4 id="strimoz-golovnogo-mozga">    </h4><br><pre> <code class="java hljs">List&lt;T&gt; list = getList(); Set&lt;T&gt; set = getSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list.stream().allMatch(set::contains); <span class="hljs-comment"><span class="hljs-comment">//     ?</span></span></code> </pre> <br><p>       ,      ,    : </p><br><pre> <code class="java hljs">List&lt;T&gt; list = getList(); Set&lt;T&gt; set = getSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set.containsAll(list);</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/3c/tc/pr/3ctcprq3scexhaaifc9hiywbj98.png"></p></div></div><br><p> <a href=""></a> </p><br><h4 id="nenuzhnye-obyortki">   </h4><br><p>  : </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileNameLoader</span></span></span><span class="hljs-class"> </span></span>{ String[] loadFileNames(); }</code> </pre> <br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileNameLoader loader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : asList(loader.loadFileNames())) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----   use(str); } }</span></span></code> </pre> <br><p>   ,   <code>forEach</code>    ,      : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileNameLoader loader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : loader.loadFileNames()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;----    use(str); } }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> ():</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/pa/kn/hc/paknhcvrp1cf7g-fw3cn4euxrse.png"></p></div></div><br><p> <a href=""></a> </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-182206</a> <br><del> IDEA-182206 </del> Simplification for Arrays.asList().subList().toArray() <br> <strong>  2018.1</strong> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-180847</a> <br><del> IDEA-180847 </del> Inspection 'Call to Collection.toArray with zero-length array argument' brings pessimization <br> <strong>  2018.1</strong> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-181928</a> <br><del> IDEA-181928 </del> Stream.allMatch(Collection::contains) can be simplified to Collection.containsAll() <br> <strong>  2018.1</strong> </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://youtrack.jetbrains.com/issue/IDEA-184240</a> <br><del> IDEA-184240 </del> Unnecessary array-to-collection wrapping should be detected <br> <strong>  2018.1</strong> </p></div></div><br><p> :       : </p><br><ul><li>  </li><li>  </li><li>    </li></ul><br><p>       ,   ,         ,     .  ,   :         "" (        ),       ""     (      ),        . </p><br><p> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> </p><br><p> ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423305/">https://habr.com/ru/post/id423305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423293/index.html">Bagaimana tidak menembak diri sendiri di kaki dengan mesin negara</a></li>
<li><a href="../id423295/index.html">Konferensi Pengembangan Seluler Paling Berguna</a></li>
<li><a href="../id423297/index.html">Dari Pengembang Android ke DevOps</a></li>
<li><a href="../id423299/index.html">Koordinator Aplikasi di aplikasi iOS</a></li>
<li><a href="../id423303/index.html">AI, tentu saja praktis. Transformasi Musik Berbasis Emosi</a></li>
<li><a href="../id423307/index.html">GitHub Tarik Permintaan dalam Kode Visual Studio</a></li>
<li><a href="../id423309/index.html">Transaksi DBMS</a></li>
<li><a href="../id423311/index.html">Naviaddress Kemitraan dan ACTUM</a></li>
<li><a href="../id423313/index.html">Sentuh I2C. Buat penganalisis logika sederhana</a></li>
<li><a href="../id423315/index.html">Teori Tautan Universal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>