<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏾 🛃 💆🏻 Node.JS上的自己动手DNS代理 🥂 👩🏽‍🏫 💑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在遥远的森林中颠簸的DNS数据包... 
 L. Kaganov“底部的哈姆雷特” 

 开发网络应用程序时，有时有必要在本地运行它，但要使用真实域名访问它。 经过验证的标准解决方案是在domains文件中注册域。 该方法的缺点是主机需要域名的明确对应关系，即 不支持星星。 即 如果存在以下形式的域...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.JS上的自己动手DNS代理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440050/"><blockquote>在遥远的森林中颠簸的DNS数据包... <br>  <em>L. Kaganov“底部的哈姆雷特”</em> </blockquote><p> 开发网络应用程序时，有时有必要在本地运行它，但要使用真实域名访问它。 经过验证的标准解决方案是在domains文件中注册域。 该方法的缺点是主机需要域名的明确对应关系，即 不支持星星。 即 如果存在以下形式的域： </p><br><pre><code class="plaintext hljs">dom1.example.com, dom2.example.com, dom3.example.com, ................ domN.example.com,</code> </pre> <br><p> 然后在主机中，您需要全部注册。 在某些情况下，事先不知道第三级域。 有一种愿望（我为自己写的，也许有人会说这很正常），希望通过这样的话： </p><br><pre> <code class="plaintext hljs">*.example.com</code> </pre> <br><p> 解决该问题的方法可能是使用您自己的DNS服务器，该服务器将根据指定的逻辑处理请求。 有这样的服务器，它们是完全免费的，并具有方便的图形界面，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CoreDNS</a> 。 您还可以更改路由器上的DNS记录。 最后，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">xip.io之</a>类的服务，它虽然不是完全成熟的DNS服务器，但是对于某些任务而言却是完美的。 简而言之，存在现成的解决方案，您可以使用，而不必费心。 </p><br><p> 但是本文介绍了另一种方式-编写自己的自行车，这是创建类似于上面所列工具的起点。 我们将编写我们的DNS代理，它将侦听传入的DNS查询，如果请求的域名在列表中，它将返回指定的IP，如果不是，它将请求更高的DNS服务器并转发接收到的响应，而无需更改请求的程序。 </p><a name="habracut"></a><br><p> 同时，您可以记录请求和收到的响应。 由于每个人都需要DNS，包括浏览器，通讯程序和防病毒软件以及操作系统服务等，因此它可能会提供很多信息。 </p><br><p> 原理很简单。 在IPv4的网络连接设置中，我们使用正在运行的自写DNS代理将DNS服务器地址更改为计算机的地址（如果不通过网络工作则为127.0.0.1），并在其设置中指定较高DNS服务器的地址。 而且，看来，仅此而已！ </p><br><p> 我们将不使用标准函数来解析<em>nslookup</em>和<em>nsresolve</em>域名，因此DNS系统设置和<em>hosts文件</em>的内容不会影响程序的运行。 根据情况，它可能有用或无效，您只需要记住这一点即可。 为简单起见，我们将自己限于基本功能本身的实现： </p><br><ul><li>  IP欺骗仅适用于A类（主机地址）和IN类（Internet）的记录 </li><li> 欺骗性IP地址（仅版本4） </li><li> 仅通过UDP连接本地传入请求 </li><li> 通过UDP或TLS连接到上游DNS服务器 </li><li> 如果有多个网络接口，则将在任何一个接口上接受传入的本地请求 </li><li> 不支持EDNS </li></ul><br><div class="spoiler">  <b class="spoiler_title">谈到测试</b> <div class="spoiler_text"><p> 项目中几乎没有单元测试。 没错，它们是按照以下原则工作的：我启动了它，如果控制台中显示了一些理智的东西，那么一切都很好，但是如果有异常发生，那么就有问题了。 但是，即使这样笨拙的方法也可以使您成功地定位问题，因此使用Unit。 </p></div></div><br><h2 id="nachalo--server-na-53-m-portu"> 启动-端口53上的服务器 </h2><br><p> 让我们开始吧。 首先，您需要教会应用程序接受传入的DNS查询。 我们正在编写一个简单的TCP服务器，该服务器仅侦听端口53并记录传入的连接。 在网络连接的属性中，我们编写DNS服务器127.0.0.1的地址，启动应用程序，进入浏览器以查看多个页面-并在控制台中保持静音，浏览器将正常显示该页面。 好了，我们将TCP更改为UDP，我们开始，我们通过浏览器-在浏览器中存在连接错误，一些二进制数据被注入控制台。 因此，系统通过UDP发送请求，我们将在端口53上通过UDP监听传入的连接。 半小时的工作，其中15分钟是谷歌如何在NodeJS上启动TCP和UDP服务器-我们已经解决了该项目的基础任务，该任务确定了未来应用程序的结构。 代码如下： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dgram = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'dgram'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = dgram.createSocket(<span class="hljs-string"><span class="hljs-string">'udp4'</span></span>); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">function</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">server</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">on</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'error'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, (err</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`server error:\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${err.stack}</span></span></span><span class="hljs-string">`</span></span>); server.close(); }); server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(localReq); <span class="hljs-comment"><span class="hljs-comment">//            }); server.on('listening', () =&gt; { const address = server.address(); console.log(`server listening ${address.address}:${address.port}`); }); const localListenPort = 53; const localListenAddress = 'localhost'; server.bind(localListenPort, localListenAddress); // server listening 0.0.0.0:53 }());</span></span></code> </pre> <br><p>  <em>清单1.接收本地DNS查询所需的最低代码</em> </p><br><p> 接下来的一点是阅读消息，以了解是需要返回我们的IP来响应它，还是直接传递它。 </p><br><h2 id="dns-soobschenie">  DNS消息 </h2><br><p>  DNS消息的结构在RFC-1035中描述。 请求和响应都遵循此结构，并且原则上在消息头中只有一位标志（QR字段）不同。 该消息包括五个部分： </p><br><pre> <code class="plaintext hljs">+---------------------+ | Header | +---------------------+ | Question | the question for the name server +---------------------+ | Answer | RRs answering the question +---------------------+ | Authority | RRs pointing toward an authority +---------------------+ | Additional | RRs holding additional information +---------------------+</code> </pre> <br><p>  <em>常规DNS消息结构<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1</a></em> </p><br><p>  DNS消息以固定长度的标头（即所谓的<em>标头</em>部分） <em>开头</em> ，该<em>标头</em>包含从1位到两个字节长的字段（因此，标头中的一个字节可以包含多个字段）。 标头以ID字段开头-这是16位请求标识符，响应必须具有相同的ID。 接下来是描述请求类型，请求执行结果以及消息的每个后续部分中的记录数的字段。 长时间描述它们，所以谁在乎-RFC： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//tools.ietf.org/html/rfc1035#section-4.1.1</a> 。  <em>标头</em>部分始终存在于DNS消息中。 </p><br><pre> <code class="plaintext hljs"> 1 1 1 1 1 1 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ID | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ |QR| Opcode |AA|TC|RD|RA| Z | RCODE | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | QDCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ANCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | NSCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+ | ARCOUNT | +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</code> </pre> <br><p>  <em>DNS邮件标头结构<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc1035#section-4.1.1</a></em> </p><br><h3 id="sekciya-question"> 问题部分 </h3><br><p>  <em>问题</em>部分包含一个条目，告诉服务器确切需要从服务器中获取什么信息。 从理论上讲，在此类记录的部分中可以有一个或多个，它们的编号在消息头的QDCOUNT字段中指示，并且可以为0、1或更大。 但实际上，“问题”部分只能包含一个条目。 如果“ <em>问题”</em>部分包含多个记录，并且其中一个记录在服务器上处理请求时会导致错误，则将出现不确定的情况。 尽管服务器将在响应消息的RCODE字段中返回错误代码，但它无法指示何时处理记录问题的记录，但规范并未对此进行描述。 记录也没有包含指示错误及其类型的字段。 因此，有一个协议（未记录），根据该协议， <em>Question</em>部分只能包含一个记录，并且QDCOUNT字段的值为1。如果它仍然包含<em>Question</em>中的多个记录，那么还不清楚如何在服务器端处理请求。 有人建议返回带有请求错误的消息。 并且，例如，Google DNS仅处理“ <em>问题”</em>部分中的第一条记录，而只是忽略其余部分。 显然，这仍由DNS服务的开发人员自行决定。 </p><br><p> 在来自服务器的响应DNS消息中，“ <em>问题”</em>部分也存在，并且应完全复制请求的“ <em>问题”</em> （为了避免冲突，以防一个ID字段不够用）。 </p><br><p>  <em>问题</em>部分中的唯一条目包含以下字段：QNAME（域名），QTYPE（类型），QCLASS（类）。  QTYPE和QCLASS是双字节数字，指示请求的类型和类别。 可能的类型和类在RFC-1035 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2中</a>进行了描述，在那里一切都清楚了。 但是，在记录域名的方法上，我们将在“记录域名的格式”部分中详细介绍。 </p><br><p> 对于查询，DNS消息通常以“ <em>问题”</em>部分结尾，有时可以在“ <em>附加”</em>部分之后。 </p><br><p> 如果在服务器上处理请求时发生错误（例如，错误地生成了传入请求），则响应消息也将以<em>Question</em>或<em>Additional</em>部分结尾，并且响应消息头的RCODE字段将包含错误代码。 </p><br><h3 id="sekcii-answer-authority-i-additional">  <em>答案</em> ， <em>权限</em>和<em>其他</em>部分 </h3><br><p> 以下各节分别是<em>Answer</em> ， <em>Authority</em>和<em>Additional</em> （ <em>Answer</em>和<em>Authority</em>只包含在响应DNS消息中， <em>Additional</em>可能会出现在请求和响应中）。 它们是可选的，即 根据要求，它们中的任何一个都可以存在或不存在。 这些部分具有相同的结构，并包含所谓的“资源记录”（ <em>资源记录</em>或RR）格式的信息。 形象地说，这些部分中的每个部分都是资源记录的数组，而记录是具有字段的对象。 每个部分可以包含一个或多个记录，它们的编号在消息标题的相应字段中分别指示（分别为ANCOUNT，NSCOUNT和ARCOUNT）。 例如，对域“ google.com”的IP请求将返回多个IP地址，因此“ <em>答案”</em>部分还将有多个条目，每个地址一个。 如果该部分不存在，则相应的标题字段包含0。 </p><br><p> 每个<em>资源记录</em> （RR）以包含域名的NAME字段开头。 该字段的格式与“ <em>问题”</em>部分的“ QNAME”字段相同。 <br>  NAME旁边是TYPE（记录类型）和CLASS（其类）字段，两个字段均为16位数字，表示记录的类型和类。 这也类似于“ <em>问题”</em>部分，不同之处在于其QTYPE和QCLASS可以具有与TYPE和CLASS相同的所有值，以及它们自己唯一的其他值。 也就是说，用枯燥的科学语言，QTYPE和QCLASS值的集合是TYPE和CLASS值的超集。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc1035#section-3.2.2上</a>了解有关差异的更多信息。 <br> 其余字段为： </p><br><ul><li>  TTL是一个32位数字，指示记录的持续时间（以秒为单位）。 </li><li>  RDLENGTH是一个16位数字，指示下一个RDATA字段的长度（以字节为单位）。 </li><li>  RDATA实际上是有效载荷，其格式取决于记录的类型。 例如，对于类型A（主机地址）和类IN（互联网）的记录，它们是4个字节，代表一个IPv4地址。 </li></ul><br><h2 id="format-zapisi-domennyh-imyon"> 域名记录格式 </h2><br><p> 如果QNAME和NAME字段以及RDATA字段的域名记录格式是相同的（如果它是CNAME，MX，NS或其他假定域名为域名的类记录）。 </p><br><p> 域名是一系列标签（名称的各个部分，子域-这是原始<strong>标签</strong> ，我没有找到更好的翻译）。 标签是一个长度为一个字节的字节，其中包含一个数字-标签内容的长度（以字节为单位），后跟一个指定长度的字节序列。 标签一个接一个地跟随，直到找到一个长度为0的字节为止，第一个标签的长度立即为零，这表示根域（Root Domain）的域名为空（有时写为“”）。 </p><br><p> 在早期版本的DNS中，标签中的字节可以具有（0到255）之间的任何值。 有一些紧急建议的规则：标签以字母开头，以字母或数字结尾，并且仅包含7位ASCII编码的字母，数字或连字符，且最高有效位为零。 当前的EDNS规范已经明确要求遵守这些规则，并且没有偏差。 </p><br><p> 长度字节的两个最高有效位用作标签类型属性。 如果它们为零（ <em>0b00xxxxxx</em> ），则这是一个常规标签，长度字节的其余位指示其组成中包含的数据字节数。 标签的最大长度为63个字符。 二进制编码中的63只是<em>0b00111111</em> 。 </p><br><p> 如果两个最高有效位分别为0和1（ <em>0b01xxxxxx</em> ），则这是EDNS标准的扩展类型标签（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc2671#section-3.1</a> ），该标签于2019年2月1日发布。 低六位将包含标签值。 我们不在本文中讨论EDNS，但是知道这也会发生是很有用的。 </p><br><p> 保留等于1和0（ <em>0b10xxxxxx</em> ）的两个最高有效位的组合，以供将来使用。 </p><br><p> 如果两个高位都等于1（ <em>0b11xxxxxx</em> ），则意味着域名被压缩（ <em>compression</em> ），我们将在下面详细介绍。 </p><br><h3 id="szhatie-domennyh-imyon"> 域名压缩 </h3><br><p> 因此，如果一个字节的长度具有等于1（ <em>0b11xxxxxx</em> ）的两个高位，则表明域名压缩。 压缩用于使消息更短，更简洁。 当使用UDP处理DNS消息的总长度限制为512字节时（尤其是这是旧标准，请参阅<em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc1035#section-2.3.4</a>大小限制</em> ，新的EDNS）允许发送UPD消息及更长的消息）。 该过程的本质是，如果DNS消息包含具有相同顶级子域的域名（例如， <em>mail.yandex.ru</em>和<em>yandex.ru</em> ），则<em>与其</em>重新指定整个域名， <em>不如</em>从DNS消息中提取字节数继续阅读域名。 这可以是DNS消息的任何字节，不仅可以在当前记录或部分中，还可以是域标签长度的一个字节。 您不能参考标记的中间。 假设消息中有一个<em>mail.yandex.ru</em>域，那么在压缩的帮助下，还可以指定<em>yandex.ru</em> ， <em>ru</em>和root“”域（当然，根无需压缩就更容易编写，但是从技术上讲，可以通过压缩来做到这一点），并且在这里使<em>ndex.ru</em>无法正常工作。 同样，所有派生域名都将以根域结尾，也就是说，写，例如<em>mail.yandex</em>也将失败。 </p><br><p> 域名可以： </p><br><ul><li> 被完整记录而无需压缩， </li><li> 从使用压缩的地方开始 </li><li> 从一个或多个未压缩的标签开始，然后切换到压缩， </li><li> 为空（对于根域）。 </li></ul><br><p> 例如，我们正在编译DNS消息，并且已经在其中遇到了名称“ dom3.example.com”，现在我们需要指定“ dom4.dom3.example.com”。 在这种情况下，您可以记录“ dom4”部分而不进行压缩，然后切换到压缩，即添加指向“ dom3.example.com”的链接。 反之亦然，如果以前曾遇到名称“ dom4.dom3.example.com”，则要表示“ dom3.example.com”，您可以通过引用其中的标签“ dom3”立即使用压缩。 正如我们已经说过的，我们不能通过压缩来指示“ dom4.dom3”的一部分，因为名称必须以顶层部分结尾。 如果您突然需要从中间指定片段，则无需压缩即可简单地指示它们。 </p><br><p> 为简单起见，我们的程序不知道如何通过压缩来写域名，它只能读取。 该标准允许这样做，阅读必须一定要实现，写作是可选的。 从技术上讲，读取是这样实现的：如果一个字节长度的两个最高有效位包含1，则我们读取紧随其后的字节，并将这两个字节视为16位无符号整数，并按Big Endian位的顺序进行处理。 我们丢弃两个最高有效位（包含1），读取结果14位数字，并继续从DNS消息中与该数字对应的数字的字节中读取域名。 </p><br><p> 域名读取功能的代码如下： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readDomainName</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf, startOffset, objReturnValue = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> currentByteIndex = startOffset; <span class="hljs-comment"><span class="hljs-comment">//    ,  DNS- ,      let initOctet = buf.readUInt8(currentByteIndex); let domain = ''; //      , ..       0, //  ,      // "the root domain name has no labels." (c) RFC-1035, p. 4.1.4. Message compression objReturnValue['endOffset'] = currentByteIndex; let lengthOctet = initOctet; while (lengthOctet &gt; 0) { //     var label; if (lengthOctet &gt;= 192) { //   :  0b1100 0000   const pointer = buf.readUInt16BE(currentByteIndex) - 49152; // 49152 === 0b1100 0000 0000 0000 === 192 * 256 const returnValue = {} label = readDomainName(buf, pointer, returnValue); domain += ('.' + label); objReturnValue['endOffset'] = currentByteIndex + 1; //      ,      break; } else { currentByteIndex++; label = buf.toString('ascii', currentByteIndex, currentByteIndex + lengthOctet); domain += ('.' + label); currentByteIndex += lengthOctet; lengthOctet = buf.readUInt8(currentByteIndex); objReturnValue['endOffset'] = currentByteIndex; } } return domain.substring(1); //    —  "." }</span></span></code> </pre> <br><p>  <em>清单2.从DNS查询中读取域名</em> </p><br><p> 从二进制缓冲区读取DNS记录的功能的完整代码： </p><br><div class="spoiler">  <b class="spoiler_title">清单3.从二进制缓冲区读取DNS记录</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseDnsMessageBytes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">buf</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> msgFields = {}; <span class="hljs-comment"><span class="hljs-comment">// (c) RFC 1035 p. 4.1.1. Header section format msgFields['ID'] = buf.readUInt16BE(0); const byte_2 = buf.readUInt8(2); //  #2 (starting from 0) const mask_QR = 0b10000000; msgFields['QR'] = !!(byte_2 &amp; mask_QR); //  : 0 "false" =&gt; , 1 "true" =&gt;  const mask_Opcode = 0b01111000; const opcode = (byte_2 &amp; mask_Opcode) &gt;&gt;&gt; 3; //   (): 0, 1, 2,   msgFields['Opcode'] = opcode; const mask_AA = 0b00000100; msgFields['AA'] = !!(byte_2 &amp; mask_AA); const mask_TC = 0b00000010; msgFields['TC'] = !!(byte_2 &amp; mask_TC); const mask_RD = 0b00000001; msgFields['RD'] = !!(byte_2 &amp; mask_RD); const byte_3 = buf.readUInt8(3); //  #3 const mask_RA = 0b10000000; msgFields['RA'] = !!(byte_3 &amp; mask_RA); const mask_Z = 0b01110000; msgFields['Z'] = (byte_3 &amp; mask_Z) &gt;&gt;&gt; 4; //  0,  const mask_RCODE = 0b00001111; msgFields['RCODE'] = (byte_3 &amp; mask_RCODE); // 0 =&gt; no error; (dec) 1, 2, 3, 4, 5 - errors, see RFC msgFields['QDCOUNT'] = buf.readUInt16BE(4); //     Question,   0  1 msgFields['ANCOUNT'] = buf.readUInt16BE(6); //     Answer msgFields['NSCOUNT'] = buf.readUInt16BE(8); //     Authority msgFields['ARCOUNT'] = buf.readUInt16BE(10); //     Additional //    Question let currentByteIndex = 12; //  Question   12-  DNS- (c) RFC 1035 p. 4.1.2. Question section format msgFields['questions'] = []; for (let qdcount = 0; qdcount &lt; msgFields['QDCOUNT']; qdcount++) { const question = {}; const resultByteIndexObj = { endOffset: undefined }; const domain = readDomainName(buf, currentByteIndex, resultByteIndexObj); currentByteIndex = resultByteIndexObj.endOffset + 1; question['domainName'] = domain; question['qtype'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; question['qclass'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; msgFields['questions'].push(question); } // (c) RFC 1035 p. 4.1.3. Resource record format //    (Resourse Records, RR)  Answer, Authority, Additional ['answer', 'authority', 'additional'].forEach(function(section, i, arr) { let msgFieldsName, countFieldName; switch(section) { case 'answer': msgFieldsName = 'answers'; countFieldName = 'ANCOUNT'; break; case 'authority': msgFieldsName = 'authorities'; countFieldName = 'NSCOUNT'; break; case 'additional': msgFieldsName = 'additionals'; countFieldName = 'ARCOUNT'; break; } msgFields[msgFieldsName] = []; for (let recordsCount = 0; recordsCount &lt; msgFields[countFieldName]; recordsCount++) { let record = {}; const objReturnValue = {}; const domain = readDomainName(buf, currentByteIndex, objReturnValue); currentByteIndex = objReturnValue['endOffset'] + 1; record['domainName'] = domain; record['type'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "A" record currentByteIndex += 2; record['class'] = buf.readUInt16BE(currentByteIndex); // 1 =&gt; "IN" Internet currentByteIndex += 2; // TTL  4  record['ttl'] = buf.readUIntBE(currentByteIndex, 4); currentByteIndex += 4; record['rdlength'] = buf.readUInt16BE(currentByteIndex); currentByteIndex += 2; const rdataBinTempBuf = buf.slice(currentByteIndex, currentByteIndex + record['rdlength']); record['rdata_bin'] = Buffer.alloc(record['rdlength'], rdataBinTempBuf); if (record['type'] === 1 &amp;&amp; record['class'] === 1) { //      IPv4,      let ipStr = ''; for (ipv4ByteIndex = 0; ipv4ByteIndex &lt; 4; ipv4ByteIndex++) { ipStr += '.' + buf.readUInt8(currentByteIndex).toString(); currentByteIndex++; } record['IPv4'] = ipStr.substring(1); //    '.' } else { //    ,   currentByteIndex += record['rdlength']; } msgFields[msgFieldsName].push(record); } }); return msgFields; }</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单3.从二进制缓冲区读取DNS记录</font></font></em> </p></div></div><br><p> ,       . ,     ,   ,    .   ,     DNS-,     ,   .  ,       . </p><br><p>  ,        - <code>server.on("message", () =&gt; {})</code>   1.   : </p><br><div class="spoiler"> <b class="spoiler_title"> 4.    DNS-</b> <div class="spoiler_text"><pre> <code class="javascript hljs">server.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (localReq, linfo) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dnsRequest = functions.parseDnsMessageBytes(localReq); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> question = dnsRequest.questions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// currently, only one question per query is supported by DNS implementations let forgingHostParams = undefined; // ,         IP for (let i = 0; i &lt; config.requestsToForge.length; i++) { const requestToForge = config.requestsToForge[i]; const targetDomainName = requestToForge.hostName; if (functions.domainNameMatchesTemplate(question.domainName, targetDomainName) &amp;&amp; question.qclass === 1 &amp;&amp; question.qtype === 1) { forgingHostParams = requestToForge; break; } } //  ,    DNS-      if (!!forgingHostParams) { const forgeIp = forgingHostParams.ip; const answers = []; answers.push({ domainName: question.domainName, type: question.qtype, class: question.qclass, ttl: forgedRequestsTTL, rdlength: 4, rdata_bin: functions.ip4StringToBuffer(forgeIp), IPv4: forgeIp }); const localDnsResponse = { ID: dnsRequest.ID, QR: dnsRequest.QR, Opcode: dnsRequest.Opcode, AA: dnsRequest.AA, TC: false, // dnsRequest.TC, RD: dnsRequest.RD, RA: true, Z: dnsRequest.Z, RCODE: 0, // dnsRequest.RCODE, 0 - no errors, look in RFC-1035 for other error conditions QDCOUNT: dnsRequest.QDCOUNT, ANCOUNT: answers.length, NSCOUNT: dnsRequest.NSCOUNT, ARCOUNT: dnsRequest.ARCOUNT, questions: dnsRequest.questions, answers: answers } //     DNS-    const responseBuf = functions.composeDnsMessageBin(localDnsResponse); console.log('response composed for: ', localDnsResponse.questions[0]); server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); } // ,     DNS-,         else { //     DNS-  UDP,     const responseBuf = await functions.getRemoteDnsResponseBin(localReq, upstreamDnsIP, upstreamDnsPort); //        server.send(responseBuf, linfo.port, linfo.address, (err, bytes) =&gt; {}); //     DNS-  TLS,   , .  9 } });</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单4.处理传入的本地DNS查询</font></font></em> </p></div></div><br><h2 id="dobavlyaem-podderzhku-tls">   TLS </h2><br><p>        DNS-.    ,      DNS-   TLS (HTTPS    ).  DNS-  TLS     TCP,    ,   TLS    .          TCP,   RFC-7766 DNS Transport over TCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://tools.ietf.org/html/rfc7766</a> ).    ,  :      TLS,   TCP   ( ,       DNS  TCP,      TLS-  TCP-,     ). </p><br><h3 id="ustanovka-tls-soedineniya">  TLS- </h3><br><p>  TLS-           ,       ,   .  ,         TLS-,       .  RFC-7858 -        : </p><br><pre> <code class="plaintext hljs">In order to amortize TCP and TLS connection setup costs, clients and servers SHOULD NOT immediately close a connection after each response. Instead, clients and servers SHOULD reuse existing connections for subsequent queries as long as they have sufficient resources. In some cases, this means that clients and servers may need to keep idle connections open for some amount of time. () https://tools.ietf.org/html/rfc7858#section-3.4</code> </pre> <br><p>       ,   TLS-,   ,     ,   ,   ,       .   ,        30 ,   ,      ,        DNS-.  30  ~  ~   ,   15  60 ,         .        ,         .   - . </p><br><p> TLS-     NodeJS.    ,    TLS-     : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'tls'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TLS_SOCKET_IDLE_TIMEOUT = <span class="hljs-number"><span class="hljs-number">30000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     TLS- function Module(connectionOptions, funcOnData, funcOnError, funcOnClose, funcOnEnd) { let socket; function connect() { socket = tls.connect(connectionOptions, () =&gt; { console.log('client connection established:', socket.authorized ? 'authorized' : 'unauthorized'); }); socket.on('data', funcOnData); // connection.on('end', () =&gt; {}); socket.on('close', (hasTransmissionError) =&gt; { //   ,     . //   ,     console.log('connection closed; transmission error:', hasTransmissionError); }); socket.on('end', () =&gt; { console.log('remote TLS server connection closed.') }); socket.on('error', (err) =&gt; { console.log('connection error:', err); console.log('\tmessage:', err.message); console.log('\tstack:', err.stack); }) socket.setTimeout(TLS_SOCKET_IDLE_TIMEOUT); socket.on('timeout', () =&gt; { console.log('socket idle timeout, disconnected.'); socket.end(); }); } this.write = function (dataBuf) { if (socket &amp;&amp; socket.writable) { //  ,     } else { connect(); } socket.write(dataBuf); } return this; } module.exports = Module;</span></span></code> </pre> <br><p> <em> 5. ,   TLS-</em> </p><br><p>       DNS-over-TLS ,   Google DNS.        ,               <code>socket = tls.connect(connectionOptions, () =&gt; {})</code> .     NodeJS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://nodejs.org/api/tls.html#tls_tls_connect_options_callback</a> ,       . </p><br><p>  TLS-   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">port</span></span>: config.upstreamDnsTlsPort, <span class="hljs-comment"><span class="hljs-comment">//        host: config.upstreamDnsTlsHost } const onData = (data) =&gt; { //     , .       7 }; remoteTlsClient = new TlsClient(options, onData);</span></span></code> </pre> <br><p> <em> 6.  TLS-</em> </p><br><p>     ,        TCP-.   TCP/TLS-      DNS-,     ,    ,     ,   .    TCP (  TLS),  DNS-   512 ,    UDP (,  EDNS    UDP  ).  ,  DNS-    UDP,             .       <strong>onData()</strong>   6. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    DNS-,       TLS-   //    ,     2 ,       let dataCurrentPos = 0; try { while (dataCurrentPos &lt; data.length) { const respLen = data.readUInt16BE(dataCurrentPos); respBuf = data.slice(dataCurrentPos + 2, dataCurrentPos + 2 + respLen); const respData = functions.parseDnsMessageBytes(respBuf); const requestKey = functions.getRequestIdentifier(respData); const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {}); dataCurrentPos += 2 + respLen; } } catch (err) { console.error(err); //   ,     throw err; } };</span></span></code> </pre> <br><p> <em> 7.   TLS-   DNS-   6</em> </p><br><h3 id="poryadok-otvetov-ot-udalyonnogo-dns-servera">     DNS- </h3><br><p>  ,            ,     .   ,         ID     QNAME, QTYPE  QCLASS  <em>Question</em> : </p><br><pre> <code class="plaintext hljs">Since pipelined responses can arrive out of order, clients MUST match responses to outstanding queries on the same TLS connection using the Message ID. If the response contains a Question Section, the client MUST match the QNAME, QCLASS, and QTYPE fields. () https://tools.ietf.org/html/rfc7858#section-3.3</code> </pre> <br><p>     ,  ,    ,   ID   <em>Question</em> (   ,      ). </p><br><p>        UDP (.  4),    ,         -,    ,   UDP-     .        ,       DNS-,       .          ,       -.  ,         ,      UDP-         -.  ,  ,    . </p><br><p>      TLS,               .         (IP  ),    ,       . </p><br><p>        IP      "-".   ,    ,   ,     DNS-.   ,    ,         IP  ,     .        7: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const requestKey = functions.getRequestIdentifier(respData); //    IP    ,   const localResponseParams = localRequestsAwaiting.get(requestKey); localRequestsAwaiting.delete(requestKey); //      IP   server.send(respBuf, localResponseParams.port, localResponseParams.address, (err, bytesNum) =&gt; {});</span></span></code> </pre> <br><p> <em> 8.        7</em> </p><br><p>      TLS-: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     const localReqParams = { address: linfo.address, port: linfo.port }; //        const requestKey = functions.getRequestIdentifier(dnsRequest); //       localRequestsAwaiting.set(requestKey, localReqParams); //       ,      const lenBuf = Buffer.alloc(2); lenBuf.writeUInt16BE(localReq.length); const prepReqBuf = Buffer.concat([lenBuf, localReq], 2 + localReq.length); remoteTlsClient.write(prepReqBuf); //  RFC-7766 p.8, 2               </span></span></code> </pre> <br><p> <em> 9.    DNS-  TLS- (  .  4)</em> </p><br><h2 id="chtenie-konfiguracii-iz-fayla-i-eyo-obnovlenie">        </h2><br><p>   ,   ,      .     JSON,    ,   NodeJS   JSON-      .  JSON —      ,      .  ,    JSON-  "comment" (  )       . ,  ,  ,    ,  .  ,        ,     .      ,   -  ,    ,            NodeJS.    ,   ,     .  ,         ,       ;   ,   .           ,     - . </p><br><div class="spoiler"> <b class="spoiler_title"> 10.     </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CONFIG_FILE_PATH = path.resolve(<span class="hljs-string"><span class="hljs-string">'./config.json'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Module</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// config  -,       . //    config        , //         . ,    : // const conf = config; //   conf     ,    : // const requestsToForge = config.requestsToForge; //    , requestsToForge   . const config = {}; Object.defineProperty(this, 'config', { get() { return config; }, enumerable: true }) this.initConfig = async function() { const fileContents = await readConfigFile(CONFIG_FILE_PATH); console.log('initConfig:'); console.log(fileContents); console.log('fileContents logged ^^'); const parsedConfigData = parseConfig(fileContents); Object.assign(config, parsedConfigData); }; async function readConfigFile(configPath) { const promise = new Promise((resolve, reject) =&gt; { fs.readFile(configPath, { encoding: 'utf8', flag: 'r' }, (err, data) =&gt; { if (err) { console.log('readConfigFile err to throw'); throw err; } resolve(data); }); }) .then( fileContents =&gt; { return fileContents; } ) .catch(err =&gt; { console.log('readConfigFile error: ', err); }); return promise; } function parseConfig(fileContents) { const configData = JSON.parse(fileContents); return configData; } //   ,       . //  Windows,    fs.watch     , //      ,   configReadInProgress let configReadInProgress = false; fs.watch(CONFIG_FILE_PATH, async () =&gt; { if(!configReadInProgress) { configReadInProgress = true; console.log('===== config changed, run initConfig() ====='); try { await this.initConfig(); } catch (err) { console.log('===== error initConfig(), skip =====,', err); configReadInProgress = false; } configReadInProgress = false; } else { console.log('===== config changed, initConfig() already running, skip ====='); } }); } let instance; async function getInstance() { if(!instance) { instance = new Module(); await instance.initConfig(); } return instance; } module.exports = getInstance;</span></span></code> </pre> <br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单10.阅读器和配置更新模块</font></font></em> </p></div></div><br><h2 id="itogo"> 合计 </h2><br><p>    DNS-  NodeJS,     <em>npm</em>   .    ,        ,   ,  ,         . </p><br><p> <strong><a href="">   GitHub</a></strong> </p><br><h3 id="istochniki"> : </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC-1035</a> DOMAIN NAMES — IMPLEMENTATION AND SPECIFICATION </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC-7858</a> Specification for DNS over Transport Layer Security (TLS) </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RFC-7766</a> DNS Transport over TCP — Implementation Requirements </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://stackoverflow.com/questions/4082081/requesting-a-and-aaaa-records-in-single-dns-query/4083071#4083071</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440050/">https://habr.com/ru/post/zh-CN440050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440036/index.html">触摸打字</a></li>
<li><a href="../zh-CN440040/index.html">在发展中-各自为战。 但是有时候这会导致死胡同。</a></li>
<li><a href="../zh-CN440044/index.html">高通详细历史</a></li>
<li><a href="../zh-CN440046/index.html">公开课“在Spring上创建REST客户端”</a></li>
<li><a href="../zh-CN440048/index.html">最喜欢的指标：每个销售团队都必须遵循的5个指标</a></li>
<li><a href="../zh-CN440052/index.html">静态BIOS / UEFI分析或如何获取依赖关系图</a></li>
<li><a href="../zh-CN440054/index.html">使用AWS将Web服务传输到Yandex.Cloud</a></li>
<li><a href="../zh-CN440058/index.html">2018-2019年互联网问题和可用性报告</a></li>
<li><a href="../zh-CN440060/index.html">Apache Ignite上的TensorFlow</a></li>
<li><a href="../zh-CN440062/index.html">规划愉快。 我们如何在没有经理的情况下建立流程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>