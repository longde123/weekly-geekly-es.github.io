<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö° üîñ ‚ûñ Presentaci√≥n del modelo de controlador simple NodeMCU (SDM): interfaz de usuario din√°mica üëåüèæ ‚úãüèø üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="NodeMCU es un firmware interactivo que permite ejecutar el int√©rprete de Lua en el microcontrolador ESP8266 (el soporte ESP32 est√° en desarrollo). Jun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presentaci√≥n del modelo de controlador simple NodeMCU (SDM): interfaz de usuario din√°mica</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449992/"><p><img src="https://habrastorage.org/webt/45/dq/e8/45dqe8yvyxvpg_kcien-88xslei.jpeg" alt="imagen"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NodeMCU</a> es un <em>firmware interactivo</em> que permite ejecutar el int√©rprete de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lua</a> en el microcontrolador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ESP8266</a> (el soporte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ESP32</a> est√° en desarrollo).  Junto con todas las interfaces de hardware normales, tiene un m√≥dulo WiFi y un sistema de archivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SPIFFS</a> . </p><br><p>  Este art√≠culo describe el nuevo m√≥dulo para NodeMCU - sdm.  SDM significa modelo de controlador simple y proporciona abstracci√≥n del modelo de controlador de dispositivo para el sistema.  En la primera parte de este art√≠culo discutiremos el modelo en s√≠ y en la segunda parte se mostrar√° una interfaz de usuario web creada din√°micamente usando sdm con algunos comentarios. </p><a name="habracut"></a><br><h1 id="driver-model-basics">  Conceptos b√°sicos del modelo de controlador </h1><br><p>  Dos componentes principales del modelo son <em>dispositivos</em> y <em>controladores</em> .  Dispositivo es una representaci√≥n abstracta de alg√∫n hardware o dispositivo virtual.  Tiene sentido colocar dispositivos en la jerarqu√≠a de √°rboles, con el microcontrolador en la parte superior, los autobuses en el medio y los sensores como hojas. </p><br><pre><code class="plaintext hljs">DEVICES + DRIVERS | +-----+ | +-----+ |1WIRE&lt;----------------------+1WIRE| ++-+-++ | +-----+ | | | | +---------+ | +--------+ | +------+ | | | +------+DS1820| +---v----+ +---v----+ +---v----+ | | +------+ |DS1820|0| |DS1820|1| |DS1822|0| | | +---^----+ +---^----+ +---^----+ | | +------+ | | +--------------+DS1822| | | | | +------+ +-----------+------------------+ +</code> </pre> <br><p>  El controlador de dispositivo es una pieza l√≥gica asociada con un dispositivo dado.  Las funciones proporcionadas por el controlador se denominan <em>m√©todos</em> , los contenedores de datos asociados con el controlador se denominan <em>atributos</em> .  Ambos m√©todos y atributos viven dentro del controlador. </p><br><p>  Los atributos tienen dos funciones asociadas con ellos: ganchos <em>getter</em> y <em>setter</em> .  Por lo tanto, atribuye la funcionalidad del m√©todo de superconjunto, pero tambi√©n ocupan m√°s memoria (la memoria del microcontrolador es escasa, ¬ørecuerdas?). </p><br><pre> <code class="lua hljs">sdm.attr_add(drv, <span class="hljs-comment"><span class="hljs-comment">-- device handle "ref", -- attribute name "Reference voltage", -- attribute description 5, function(dev) -- this is a getter function return sdm.attr_data(sdm.attr_handle(dev, "ref")) end, function(dev, value) -- this is a setter function sdm.attr_set(sdm.attr_handle(dev, "ref"), value) end )</span></span></code> </pre> <br><h2 id="device-binding">  Dispositivo vinculante </h2><br><p>  La parte dif√≠cil del modelo de controlador es el enlace dispositivo-controlador.  El proceso en s√≠ es bastante simple: hacemos coincidir el dispositivo con cada controlador disponible hasta que encaje.  Solo faltan dos partes: l√≥gica coincidente y algunos datos con los que coincidir. </p><br><p>  En la l√≥gica de coincidencia SDM vive en los controladores bajo el nombre <code>_poll()</code> .  Es un m√©todo regular que se llama con el identificador del dispositivo como par√°metro y devuelve <code>true</code> o <code>false</code> si el dispositivo podr√≠a o no conectarse al controlador respectivamente. </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_poll"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_data(sdm.local_attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- get device attribute "id" if attr == nil then return false end -- if it does not have one, driver does not match -- parent name must be "ESP8266_1W" and first byte of "id" must be "0x28" return (sdm.device_name(par) == "ESP8266_1W") and (attr:byte(1) == 0x28) end )</span></span></code> </pre> <br><p>  Como se ve en el ejemplo anterior, el controlador coincide con el dispositivo mediante el atributo  Pero como se se√±al√≥ anteriormente, los atributos se asocian solo con el controlador.  En general es cierto, pero hay algunos atributos que no se pueden recuperar a trav√©s del software.  Estas son ID de chip, pines usados, etc.  Para ellos, se agreg√≥ un tipo especial de atributo al sdm - <em>atributo local</em> .  Este atributo est√° asociado con una instancia del dispositivo y generalmente es inmutable. </p><br><p>  Lo √∫nico que queda por decir sobre el enlace del controlador.  Por lo general, los dispositivos requieren alg√∫n tipo de inicializaci√≥n en el inicio y la limpieza despu√©s del uso.  Para este prop√≥sito, SDM utiliza los <code>_init()</code> y <code>_free()</code> . <br>  Si el controlador tiene el m√©todo <code>_init()</code> , se llamar√° autom√°ticamente despu√©s del enlace del dispositivo.  Lo mismo con <code>_free()</code> . </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_init"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> sdm.device_rename(dev, sdm.request_name(<span class="hljs-string"><span class="hljs-string">"DS18B20"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- rename device sdm.attr_copy(dev, "temp") -- copy attribute sdm.attr_copy(dev, "precision") -- copy attribute local met = sdm.method_dev_handle(par, "setup") -- get 1Wire bus pin init function .. local func = sdm.method_func(met) -- .. and .. func(par, dev) -- .. call it end ) sdm.method_add(drv, "_free", nil, function(dev, drv, par) local met = sdm.method_dev_handle(par, "free") -- get 1Wire bus pin free function .. local func = sdm.method_func(met) -- .. and .. func(par, dev) -- .. call it end )</span></span></code> </pre> <br><p>  Un lector atento probablemente pregunte: ¬øqu√© significa "copiar atributo" en el ejemplo anterior?  Y tendr√≠a raz√≥n, porque esto tiene que ver con el tercer tipo de atributo que a√∫n no hemos discutido: <em>el atributo privado</em> .  No tiene mucho sentido compartir todos los datos de atributos entre todas las instancias de dispositivos.  Para este prop√≥sito, SDM proporciona un mecanismo para copiar el atributo del controlador y asociarlo con el dispositivo.  Esto hace que el atributo del controlador sea un prototipo o plantilla. </p><br><p>  Un resumen r√°pido: </p><br><ul><li>  <em>Los atributos locales</em> se utilizan para datos que el software no puede recuperar.  Como ID de dispositivo, pines conectados, etc. </li><li>  <em>Los atributos del controlador</em> se utilizan para los datos compartidos entre todas las instancias de dispositivos conectados a este controlador. </li><li>  <em>Los atributos privados</em> se copian de los atributos del controlador y contienen datos asociados con una sola instancia del dispositivo.  Este tipo es el m√°s com√∫n. </li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Propiedad </th><th>  Atributo local </th><th>  Atributo privado </th><th>  Atributo del controlador (p√∫blico) </th></tr></thead><tbody><tr><td>  Almacenado en </td><td>  dispositivo </td><td>  dispositivo </td><td>  chofer </td></tr><tr><td>  Accesible usando la manija del conductor </td><td>  - </td><td>  - </td><td>  + </td></tr><tr><td>  Accesible usando el asa del dispositivo </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td>  Compartido entre dispositivos </td><td>  - </td><td>  - </td><td>  + </td></tr><tr><td>  Persistir en la separaci√≥n del conductor </td><td>  + </td><td>  - </td><td>  + </td></tr></tbody></table></div><br><h1 id="web-user-interface-implementation">  Implementaci√≥n de interfaz de usuario web </h1><br><h2 id="server-code">  C√≥digo del servidor </h2><br><p>  Hay un hermoso proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/marcoskirsch/nodemcu-">nodemcu-httpserver</a> que implementa el c√≥digo del servidor para NudeMCU.  Lamentablemente parece estar muerto.  Fue utilizado como base para el servidor.  En primer lugar, las funciones del servidor se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://gitlab.com/matsievskiysv/nodemcu-">movieron a LFS</a> y luego se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://gitlab.com/matsievskiysv/nodemcu-pseudo">modificaron ligeramente</a> para servir una p√°gina est√°tica para cada llamada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vue.js</a> es una opci√≥n perfecta para p√°ginas web basadas en plantillas.  Entonces se us√≥ para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">frontend</a> .  Vale la pena se√±alar que NodeMCU puede no estar conectado a Internet.  Debido a esto, la biblioteca <code>vue.js</code> debe estar presente localmente y servida por el servidor NodeMCU. </p><br><p>  Como todos los dispositivos est√°n organizados en estructura de √°rbol, se accede a ellos como un directorio: <code>/ESP8266/ESP8266_1W/DS18S20-0</code> .  Aqu√≠ <code>/ESP8266</code> es una p√°gina NodeMCU, <code>/ESP8266/ESP8266_1W</code> es una p√°gina de bus <em>1Wire</em> y finalmente <code>/ESP8266/ESP8266_1W/DS18S20-0</code> es un sensor de temperatura. </p><br><p>  Como se mencion√≥ anteriormente, todas las p√°ginas del dispositivo se crean a partir de una p√°gina de plantilla que se sirve en cada llamada.  <em>El</em> c√≥digo <em>JS</em> dentro de esta p√°gina realiza una solicitud a la misma URL, antepuesta con <code>/api</code> .  Para el ejemplo anterior, la URL de la llamada ser√≠a <code>/api/ESP8266/ESP8266_1W/DS18S20-0</code> .  En tales solicitudes, el servidor responde con datos espec√≠ficos del dispositivo codificados con <em>JSON</em> , que pueblan la p√°gina.  Por supuesto, la solicitud de p√°gina <em>HTML</em> puede omitirse si solo se necesitan datos sin procesar. </p><br><h2 id="device-tree">  √Årbol de dispositivos </h2><br><p>  La configuraci√≥n inicial del dispositivo se realiza utilizando <em>una</em> estructura de <em>√°rbol de dispositivo simple</em> .  Es como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√°rbol de dispositivos</a> , pero m√°s simple.  Describe la configuraci√≥n del hardware, incluidos los atributos locales del dispositivo. </p><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> root={ <span class="hljs-comment"><span class="hljs-comment">-- local_attributes={}, children={ { name="ESP8266_1W", -- local_attributes={}, children = { { name="DS18S20-0", -- static declaration alternative to 1Wire poll method local_attributes={ { name="id", desc=nil, -- empty description to save space data=string.char(16) .. string.char(221) .. string.char(109) .. string.char(104) .. string.char(3) .. string.char(8) .. string.char(0) .. string.char(150) -- ugly way to create byte array }, { datapin=2 } } }, } }, { name="ESP8266_SPI", -- local_attributes={}, children = { { name="MCP3208-0" }, } }, } }</span></span></code> </pre> <br><h2 id="hardware-setup">  Configuraci√≥n de hardware </h2><br><p>  Aqu√≠ comienza el escaparate.  Para este prop√≥sito, se conectaron un grupo de sensores al NodeMCU: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sensor de</a> temperatura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DS18B20</a> </li><li>  Sensor de temperatura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DS18S20</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MCP3208</a> ADC </li></ul><br><p>  <em>1Los</em> sensores de <em>cable</em> est√°n conectados al mismo pin. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fb/sw/zi/fbswzi7xav_pj4waz6g19hktrso.jpeg"></a> </p><br><h2 id="web-pages-and-drivers">  P√°ginas web y controladores </h2><br><h3 id="root-device">  dispositivo ra√≠z </h3><br><p>  El objetivo principal del dispositivo ra√≠z (tambi√©n conocido como ESP8266) es proporcionar un lugar para que sus hijos se conecten.  Sin embargo, no est√° restringido tener m√©todos o atributos asociados con √©l. </p><br><p>  Este fragmento de c√≥digo es de <a href="">aqu√≠</a> : </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_init"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- get device "id" attribute sdm.attr_set(attr, node.chipid()) -- set "id" value attr = sdm.attr_handle(dev, "float") -- get device "float" attribute sdm.attr_set(attr, 3 / 2 ~= 1) -- set to true if firmware supports floating point instructions end ) sdm.attr_add(drv, "float", "Floating point build", false, function(drv) -- attribute value is set inside "_init" function local attr = sdm.attr_drv_handle(drv, "float") return sdm.attr_data(attr) -- just return stored value end, nil )</span></span></code> </pre> <br><p>  Este c√≥digo agrega <code>float</code> atributo que se utiliza para contener el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo de compilaci√≥n de</a> firmware.  Su valor se inicializa en el <code>_init()</code> que es una funci√≥n especial, que se ejecuta una vez cuando el controlador se conecta al dispositivo. </p><br><p>  Esta es la p√°gina generada para el dispositivo ra√≠z. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/mg/5q/lo/mg5qlog3-nwjkl6itrfw6ynyvuo.png"></a> </p><br><p>  Aqu√≠ podemos ver que el dispositivo ra√≠z tiene un <code>heap</code> m√©todos, dos atributos de controlador <code>float</code> e <code>id</code> .  Finalmente, tiene dos dispositivos conectados: <em>los</em> buses <em>SPI</em> y <em>1Wire</em> . </p><br><h3 id="spi">  SPI </h3><br><p>  <a href=""><em>El</em> controlador <em>SPI</em></a> no es muy interesante.  Simplemente asigna funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NodeMCU SPI</a> . </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qx/mx/g8/qxmxg8mnkmnl5aglfq7q5zhpnv0.png"></a> </p><br><h3 id="mcp3208">  Mcp3208 </h3><br><p>  <em>MCP3208</em> es un chip <em>ADC</em> .  Mide voltajes de cero a <em>ref</em> y devuelve un c√≥digo de 12 bits.  Lo interesante de esta implementaci√≥n de <a href="">controlador</a> es que la <code>ref</code> atributo estar√≠a presente compilaci√≥n solo si el firmware admite aritm√©tica de punto flotante.  Si no es compatible, en lugar de voltaje absoluto, el c√≥digo de voltaje se devuelve por m√©todos <code>single</code> y <code>differential</code> . </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"single"</span></span>, <span class="hljs-string"><span class="hljs-string">"Single ended measure 0|1|2|3|4|5|6|7"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, channel)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- ... if ref ~= nil then -- this part is executed only if floating point arithmetic is enabled rv = ref * rv / 4096 end return rv end ) if 3/2~=1 then -- other alternative is to access ESP8266 "float" method sdm.attr_add(drv, "ref", "Reference voltage", 5, function(dev) return sdm.attr_data(sdm.attr_handle(dev, "ref")) end, function(dev, value) sdm.attr_set(sdm.attr_handle(dev, "ref"), value) end ) end</span></span></code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/m_/_l/cc/m__lccntxwsrorrujvky3opbm0s.png"></a> </p><br><p>  Tambi√©n tenga en cuenta que este dispositivo tiene el atributo <code>ref</code> marcado como <em>privado</em> .  Se establece por dispositivo. </p><br><h3 id="1wire">  1 cable </h3><br><p>  <a href=""><em>1</em> Driver driver</a> implementa el m√©todo de <code>poll</code> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">b√∫squeda din√°mica de dispositivos</a> . </p><br><p>  Inmediatamente despu√©s del descubrimiento del dispositivo, se desconoce su tipo.  Por lo tanto, su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">direcci√≥n √∫nica</a> <em>1Wire</em> se usa como un nuevo nombre de dispositivo (bytes representados como n√∫meros separados por <code>_</code> caracteres). </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"poll"</span></span>, <span class="hljs-string"><span class="hljs-string">"Poll for devices"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bus, pin)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> children = sdm.device_children(bus) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {} <span class="hljs-comment"><span class="hljs-comment">-- already attached local ids = {} -- get IDs of attached devices for name, handle in pairs(children) do local dpin = sdm.attr_data(sdm.local_attr_handle(handle, "pin")) if dpin == pin then ids[sdm.attr_data(sdm.local_attr_handle(handle, "id"))] = true end end ow.reset_search(pin) -- reset previous search while true do -- for all found devices local id = ow.search(pin) if id == nil then break end if ids[id] == nil then -- if not already present local name = "" for i=1,#id do name = name .. tostring(id:byte(i)) .. "_" end name = name:sub(1,-2) -- add to system with their ID used as name local device = sdm.device_add(name, bus) -- add "pin" attribute local rv = sdm.local_attr_add(device, "datapin", nil, pin, nil, nil) -- add "id" attribute local rv = sdm.local_attr_add(device, "id", nil, id, nil, nil) -- poll for driver local rv = sdm.device_poll(device) end end end )</span></span></code> </pre> <br><p>  Esta es la p√°gina inicial para el controlador <em>1Wire</em> . </p><br><p> <a href=""><img src="https://habrastorage.org/webt/j2/uq/ax/j2uqaxkhqilv0k1fmwaq2hn0iwq.png"></a> </p><br><p>  Despu√©s de emitir una llamada de <code>poll</code> con el argumento <code>2</code> y actualizar la p√°gina, aparece la secci√≥n secundaria.  Tenga en cuenta que los nombres de los ni√±os son legibles por humanos.  Esto se debe a que la funci√≥n <code>device_rename()</code> fue llamada durante su <code>_init</code> . </p><br><p> <a href=""><img src="https://habrastorage.org/webt/_z/2x/na/_z2xnadqlt_qgyokfxomwivtwkq.png"></a> </p><br><h3 id="ds18s20">  DS18S20 </h3><br><p>  Tras la inicializaci√≥n, el <a href="">controlador DS18S20</a> comprueba que la <em>ID del</em> dispositivo comienza con <code>0x10</code> , que es un c√≥digo de familia del dispositivo.  Cuando el dispositivo se conecta al controlador, se renombra a <code>DS18S20-X</code> , donde <code>DS18S20</code> es un nombre base y <code>X</code> es un n√∫mero de instancia. </p><br><pre> <code class="lua hljs">sdm.method_add(drv, <span class="hljs-string"><span class="hljs-string">"_poll"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, drv, par)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_data(sdm.local_attr_handle(dev, <span class="hljs-string"><span class="hljs-string">"id"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> attr == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (sdm.device_name(par) == <span class="hljs-string"><span class="hljs-string">"ESP8266_1W"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (attr:<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0x10</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- check family ID end ) sdm.method_add(drv, "_init", nil, function(dev, drv, par) sdm.device_rename(dev, sdm.request_name("DS18S20")) -- rename device sdm.attr_copy(dev, "temp") -- copy attribute to device local met = sdm.method_dev_handle(par, "setup") local func = sdm.method_func(met) -- use parent "setup" method on the device func(par, dev) end )</span></span></code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/bm/pk/41/bmpk419dphexm-xlvnxq7hw2jxc.png"></a> </p><br><p>  Los atributos locales <code>id</code> y <code>datapin</code> no tienen ganchos <code>getter</code> y <code>setter</code> , por lo que solo sus nombres son visibles. </p><br><h3 id="ds18b20">  DS18B20 </h3><br><p>  <a href="">El controlador DS18B20</a> es casi lo mismo que el <a href="">controlador DS18S20</a> .  La √∫nica diferencia es el m√©todo de <code>precision</code> .  Ambos controladores <em>DS18-20</em> asumen la construcci√≥n de enteros y no utilizan la divisi√≥n de punto flotante. </p><br><pre> <code class="lua hljs">sdm.attr_add(drv, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>, <span class="hljs-string"><span class="hljs-string">"Precision (9|10|11|12)"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, precision)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_dev_handle(dev, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdm.attr_data(attr) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dev, precision)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> par = sdm.device_parent(dev) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attr = sdm.attr_dev_handle(dev, <span class="hljs-string"><span class="hljs-string">"precision"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ex = sdm.method_func(sdm.method_dev_handle(par, <span class="hljs-string"><span class="hljs-string">"exchange"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> modes = {[<span class="hljs-number"><span class="hljs-number">9</span></span>]=<span class="hljs-number"><span class="hljs-number">0x1f</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span>]=<span class="hljs-number"><span class="hljs-number">0x3f</span></span>, [<span class="hljs-number"><span class="hljs-number">11</span></span>]=<span class="hljs-number"><span class="hljs-number">0x5f</span></span>, [<span class="hljs-number"><span class="hljs-number">12</span></span>]=<span class="hljs-number"><span class="hljs-number">0x7f</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> modes[precision] ~= <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ex(par, dev, {<span class="hljs-number"><span class="hljs-number">0x4e</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, modes[precision]}) sdm.attr_set(attr, precision) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> )</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/er/lj/gb/erljgbs9zby8767izkmsunyhdd8.png"></a> </p><br><h2 id="memory-usage">  Uso de la memoria </h2><br><p>  <em>La</em> memoria libre <em>ESP8266</em> es de aproximadamente <em>40k</em> .  El c√≥digo del servidor se mueve a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://gitlab.com/matsievskiysv/nodemcu-">LFS</a> , por lo que no ocupa espacio RAM en el momento de la inicializaci√≥n (el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/marcoskirsch/nodemcu-">c√≥digo original</a> tard√≥ aproximadamente <em>10k</em> ). </p><br><p>  <em>SDM</em> ocupa aproximadamente <em>10k</em> para 5 controladores de dispositivo y 5 dispositivos.  Ligeramente menor para la compilaci√≥n de firmware no flotante.  Por lo tanto, es preferible seleccionar en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manifiesto del</a> controlador solo los controladores necesarios para la tarea en cuesti√≥n.  La tarea que consume m√°s memoria es servir la biblioteca <code>vue.js</code> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yy/u-/_i/yyu-_idkp2osapmg3-jy5z2r8ly.png"></a> </p><br><p>  En caso de solicitar datos sin codificar <em>JSON</em> (usando <code>curl</code> ), el consumo m√°ximo de memoria puede reducirse significativamente. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/w_/hu/xx/w_huxxzt4w2wszdqq04bgbonbt0.png"></a> </p><br><h2 id="instead-of-an-epilogue">  En lugar de un ep√≠logo </h2><br><p>  Uno de los primeros m√©todos que implement√© con sdm fue el enlace para <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>node.restart()</code></a> . <br>  Probarlo usando la interfaz de usuario web produjo un resultado curioso.  Justo despu√©s de que el navegador web emiti√≥ la solicitud, el chip se reinici√≥ como se esperaba.  Pero debido a que NodeMCU no respondi√≥ correctamente a la solicitud HTTP, el navegador web intent√≥ la misma solicitud nuevamente.  Cuando el servidor NodeMCU se reinici√≥ y volvi√≥ a funcionar, el navegador se conect√≥ a √©l, restableci√≥ el contador interno de <em>prueba nuevamente</em> y llam√≥ al m√©todo <code>node.restart()</code> , comenzando as√≠ un bucle infinito de reinicio de NodeMCU. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449992/">https://habr.com/ru/post/449992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449976/index.html">Contenedores asociativos multiproceso en C ++. Informe Yandex</a></li>
<li><a href="../449978/index.html">Igor Antarov del Tesla Club de Mosc√∫ lucha con 20 mitos sobre Tesla y los autos el√©ctricos</a></li>
<li><a href="../449984/index.html">Google News y Leo Tolstoy: visualizando incrustaciones de palabras de Word2Vec usando t-SNE</a></li>
<li><a href="../449986/index.html">Blockchain: ¬øqu√© debemos construir un caso?</a></li>
<li><a href="../449990/index.html">¬øC√≥mo hacer amigos l√°tex, f√≥rmulas y Habr?</a></li>
<li><a href="../449994/index.html">Las ocho reglas de oro de Schneiderman te ayudar√°n a crear una mejor interfaz</a></li>
<li><a href="../449996/index.html">Comprensi√≥n del algoritmo FFT</a></li>
<li><a href="../449998/index.html">Preguntas frecuentes: lo que un viajero geek necesita saber sobre las vacunas antes de viajar</a></li>
<li><a href="../450000/index.html">(De derecha a izquierda (a trav√©s del espejo</a></li>
<li><a href="../450002/index.html">Encontrar errores en LLVM 8 con PVS-Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>