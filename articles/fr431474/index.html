<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏾 🌦️ 🛃 Architecture de microservice sur une pile moderne de technologies Java 👸 🔽 🛀🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avions JDK 11, Kotlin, Spring 5 et Spring Boot 2, Gradle 5 avec Kotlin DSL prêt pour la production, JUnit 5 et une douzaine de bibliothèques de p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architecture de microservice sur une pile moderne de technologies Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431474/">  <i>Nous avions JDK 11, Kotlin, Spring 5 et Spring Boot 2, Gradle 5 avec Kotlin DSL prêt pour la production, JUnit 5 et une douzaine de bibliothèques de pile Spring Cloud pour la découverte de services, la création d'API de passerelle, l'équilibrage client et l'implémentation d'un disjoncteur l'écriture de clients HTTP déclaratifs, le traçage distribué et tout ça.</i>  <i>Non pas que tout cela ait été nécessaire pour créer une architecture de microservices - juste pour le plaisir ...</i> <br><a name="habracut"></a><br><h1>  Entrée </h1><br>  Dans cet article, vous verrez un exemple d'architecture de microservices utilisant des technologies pertinentes dans le monde Java, dont les principales sont données ci-dessous (ces versions sont utilisées dans le projet au moment de la publication): <br><div class="scrollable-table"><table><tbody><tr><th>  Type de technologie </th><th>  Le titre </th><th>  La version </th></tr><tr><td>  Plateforme </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Jdk</a> </td><td>  11.0.1 </td></tr><tr><td>  Langage de programmation </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Kotlin</a> </td><td>  1.3.10 </td></tr><tr><td rowspan="2">  Cadre d'application </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Cadre de printemps</a> </td><td>  5.0.9 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Botte de printemps</a> </td><td>  2.0.5 </td></tr><tr><td rowspan="2">  Système de construction </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Gradle</a> </td><td>  5,0 </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Gradle Kotlin DSL</a> </td><td>  1.0.4 </td></tr><tr><td>  Cadre de tests unitaires </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Junit</a> </td><td>  5.1.1 </td></tr><tr><td colspan="3" align="center">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Nuage de printemps</a> </td></tr><tr><td>  Point d'accès unique (passerelle API) </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Passerelle de nuage de printemps</a> </td><td rowspan="7">  Inclus dans la version Release Train du projet Finchley SR2 Spring Cloud </td></tr><tr><td>  Configuration centralisée </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Configuration de nuage de printemps</a> </td></tr><tr><td>  Traçage des demandes (traçage distribué) </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Détective des nuages ​​de printemps</a> </td></tr><tr><td>  Client HTTP déclaratif </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Spring Cloud OpenFeign</a> </td></tr><tr><td>  Découverte de service </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Spring Cloud Netflix Eureka</a> </td></tr><tr><td>  Disjoncteur </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Spring Cloud Netflix Hystrix</a> </td></tr><tr><td>  Équilibrage de charge côté client </td><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Ruban Netflix Spring Cloud</a> </td></tr></tbody></table></div><br>  Le projet comprend 5 microservices: 3 infrastructures (serveur de configuration, serveur de découverte de services, passerelle d'interface utilisateur) et des exemples de front-end (UI d'articles) et de back-end (service d'articles): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jz/rw/ia/jzrwiaehuhksnkj2dzmjea-43fy.png"></div><br>  Tous seront examinés séquentiellement ci-dessous.  Dans un projet de «combat», évidemment, il y aura beaucoup plus de microservices qui implémenteront toutes les fonctionnalités métier.  Les ajouter à une architecture similaire se fait techniquement de la même manière que l'interface utilisateur Items et le service Items. <br><br><h3>  Clause de non-responsabilité </h3><br>  L'article ne considère pas les instruments de conteneurisation et d'orchestration, car à l'heure actuelle, ils ne sont pas utilisés dans le projet. <br><br><h1>  Serveur de configuration </h1><br>  Spring Cloud Config a été utilisé pour créer un référentiel centralisé des configurations d'application.  Les configurations peuvent être lues à partir de diverses sources, par exemple, un référentiel git séparé;  dans ce projet, pour plus de simplicité et de clarté, ils sont dans les ressources applicatives: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sm/35/af/sm35aft9609348sicenfjgosw1k.png"></div><br>  Dans ce cas, la configuration du serveur de configuration ( <code>application.yml</code> ) elle-même ressemble à ceci: <br><br><pre> <code class="plaintext hljs">spring: profiles: active: native cloud: config: server: native: search-locations: classpath:/config server: port: 8888</code> </pre> <br>  L'utilisation du port 8888 permet aux clients du serveur de configuration de ne pas spécifier explicitement son port dans leur <code>bootstrap.yml</code> .  Au démarrage, ils téléchargent leur configuration en exécutant une demande GET sur le serveur HTTP API Config. <br><br>  Le code du programme pour ce microservice se compose d'un seul fichier, qui contient la déclaration de la classe d'application et la méthode principale, qui, contrairement au code Java équivalent, est une fonction de niveau supérieur: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableConfigServer</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigServerApplication</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span></span>(args: Array&lt;String&gt;) { runApplication&lt;ConfigServerApplication&gt;(*args) }</code> </pre> <br>  Les classes d'application et les méthodes principales des autres microservices ont une apparence similaire. <br><br><h1>  Serveur de découverte de services </h1><br>  La découverte de service est un modèle d'architecture de microservice qui vous permet de simplifier l'interaction entre les applications face à un changement possible du nombre de leurs instances et de l'emplacement réseau.  Un élément clé de cette approche est le registre des services - une base de données des microservices, de leurs instances et des emplacements réseau (plus de détails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ). <br><br>  Dans ce projet, la découverte de service est basée sur Netflix Eureka, qui est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">découverte de service côté client</a> : le serveur Eureka exécute la fonction du registre de service et le client Eureka, avant d'exécuter une demande vers un microservice, contacte le serveur Eureka pour obtenir une liste des instances de l'application appelée et effectue indépendamment l'équilibrage charger (en utilisant le ruban Netflix).  Netflix Eureka, comme certains autres composants de pile Netflix OSS (tels que Hystrix et Ribbon) s'intègre aux applications Spring Boot à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Spring Cloud Netflix</a> . <br><br>  Dans la configuration du serveur de découverte de services située dans ses ressources ( <code>bootstrap.yml</code> ), seuls le nom de l'application et le paramètre indiquant que le démarrage du microservice sera interrompu s'il est impossible de se connecter au serveur de configuration sont indiqués: <br><br><pre> <code class="plaintext hljs">spring: application: name: eureka-server cloud: config: fail-fast: true</code> </pre> <br>  Le reste de la configuration de l'application se trouve dans le <code>eureka-server.yml</code> dans les ressources du serveur de configuration: <br><br><pre> <code class="plaintext hljs">server: port: 8761 eureka: client: register-with-eureka: true fetch-registry: false</code> </pre> <br>  Le serveur Eureka utilise le port 8761, ce qui permet à tous les clients Eureka de ne pas le spécifier en utilisant la valeur par défaut.  La valeur du <code>register-with-eureka</code> (indiquée pour plus de clarté, car elle est également utilisée par défaut) signifie que l'application elle-même, comme les autres microservices, sera enregistrée sur le serveur Eureka.  Le paramètre <code>fetch-registry</code> détermine si le client Eureka recevra des données du registre de service. <br><br>  Une liste des demandes enregistrées et d'autres informations est disponible sur <code>http://localhost:8761/</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sh/co/lz/shcolza08r8j3qkdmgb42exawqs.png"></div><br>  Les alternatives pour implémenter la découverte de services sont Consul, Zookeeper et autres. <br><br><h1>  Service d'articles </h1><br>  Cette application est un exemple de back-end avec une API REST implémentée en utilisant le framework WebFlux qui est apparu dans Spring 5 (la documentation est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ), ou plutôt Kotlin DSL pour cela: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">itemsRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handler: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ItemHandler</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = router { path(<span class="hljs-string"><span class="hljs-string">"/items"</span></span>).nest { GET(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handler::getAll) POST(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, handler::add) GET(<span class="hljs-string"><span class="hljs-string">"/{id}"</span></span>, handler::getOne) PUT(<span class="hljs-string"><span class="hljs-string">"/{id}"</span></span>, handler::update) } }</code> </pre> <br>  Le traitement des requêtes HTTP reçues est délégué au <code>ItemHandler</code> classe <code>ItemHandler</code> .  Par exemple, une méthode pour obtenir une liste d'objets d'une entité ressemble à ceci: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServerRequest</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = ServerResponse.ok() .contentType(APPLICATION_JSON_UTF8) .body(fromObject(itemRepository.findAll()))</code> </pre> <br>  L'application devient le client du serveur Eureka, c'est-à-dire qu'elle enregistre et reçoit des données du registre de service, en raison de la présence de la <code>spring-cloud-starter-netflix-eureka-client</code> .  Après l'enregistrement, l'application envoie des hartbits au serveur Eureka avec une certaine fréquence, et si pendant un certain temps le pourcentage de hartbits reçus par le serveur Eureka par rapport à la valeur maximale possible tombe en dessous d'un certain seuil, l'application sera supprimée du registre du service. <br><br>  Examinez l'une des façons d'envoyer des métadonnées supplémentaires au serveur Eureka: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@PostConstruct</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = aim.registerAppMetadata(mapOf(<span class="hljs-string"><span class="hljs-string">"description"</span></span> to <span class="hljs-string"><span class="hljs-string">"Some description"</span></span>))</code> </pre> <br>  Assurez-vous que ces données sont reçues par le serveur Eureka en allant sur <code>http://localhost:8761/eureka/apps/items-service</code> via Postman: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/0v/xg/5l0vxgolfgjzyuceskxhmdv-0kc.png"></div><br><br><h1>  Interface utilisateur </h1><br>  Ce microservice, en plus de démontrer l'interaction avec la passerelle UI (sera montré dans la section suivante), exécute la fonction front-end pour le service Items, qui peut interagir avec l'API REST de plusieurs manières: <br><br><ol><li>  API client vers REST écrite à l'aide d'OpenFeign: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@FeignClient(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"items-service"</span></span></span><span class="hljs-meta">, fallbackFactory = ItemsServiceFeignClient.ItemsServiceFeignClientFallbackFactory::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemsServiceFeignClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GetMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/items/{id}"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@PathVariable(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"id"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String <span class="hljs-meta"><span class="hljs-meta">@GetMapping(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/not-existing-path"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHystrixFallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemsServiceFeignClientFallbackFactory</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FallbackFactory</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ItemsServiceFeignClient</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> log = LoggerFactory.getLogger(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">override</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fun</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span></span>(cause: Throwable) = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ItemsServiceFeignClient { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String { log.error(<span class="hljs-string"><span class="hljs-string">"Cannot get item with id=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ItemsUiException(cause) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHystrixFallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { log.error(<span class="hljs-string"><span class="hljs-string">"This is expected error"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{\"error\" : \"Some error\"}"</span></span> } } } }</code> </pre> </li><li>  <code>RestTemplate</code> Bean <br>  Un bac est créé dans la configuration java: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@LoadBalanced</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = RestTemplate()</code> </pre> <br>  Et utilisé de cette façon: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestWithRestTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String = restTemplate.getForEntity(<span class="hljs-string"><span class="hljs-string">"http://items-service/items/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>, String::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">body</span></span></span><span class="hljs-class"> ?: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">"No result"</span></span></span></span></code> </pre> </li><li>  <code>WebClient</code> classe <code>WebClient</code> (méthode spécifique au framework WebFlux) <br>  Un bac est créé dans la configuration java: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">webClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loadBalancerClient: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LoadBalancerClient</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = WebClient.builder() .filter(LoadBalancerExchangeFilterFunction(loadBalancerClient)) .build()</code> </pre> <br>  Et utilisé de cette façon: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestWithWebClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Mono&lt;String&gt; = webClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>().uri(<span class="hljs-string"><span class="hljs-string">"http://items-service/items/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$id</span></span></span><span class="hljs-string">"</span></span>).retrieve().bodyToMono(String::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">)</span></span></code> </pre> </li></ol><br>  Le fait que les trois méthodes renvoient le même résultat peut être vérifié en allant sur <code>http://localhost:8081/example</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/c8/oz/mac8ozz07cju5mitffz_qiew9mc.png"></div><br>  Je préfère l'option utilisant OpenFeign, car elle permet de développer un contrat d'interaction avec le microservice appelé, dont la mise en œuvre est entreprise par Spring.  Un objet qui implémente ce contrat est injecté et utilisé comme un bean standard: <br><br><pre> <code class="kotlin hljs">itemsServiceFeignClient.getItem(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Si la demande échoue pour une raison quelconque, la méthode correspondante de la classe qui implémente l'interface <code>FallbackFactory</code> sera appelée, dans laquelle vous devez traiter l'erreur et renvoyer la réponse par défaut (ou lever une exception plus loin).  En cas d'échec d'un certain nombre d'appels consécutifs, le fusible ouvrira le circuit (en savoir plus sur le disjoncteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ), donnant le temps de récupérer le microservice tombé. <br><br>  Pour utiliser le client Feign, vous devez annoter la <code>@EnableFeignClients</code> application <code>@EnableFeignClients</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableFeignClients(clients = [ItemsServiceFeignClient::class])</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ItemsUiApplication</span></span></span></span></code> </pre> <br>  Pour que la solution de secours Hystrix fonctionne dans le client Feign, vous devez ajouter les éléments suivants à la configuration de l'application: <br><br><pre> <code class="plaintext hljs">feign: hystrix: enabled: true</code> </pre> <br>  Pour tester le fonctionnement du repli Hystrix dans le client Feign, rendez-vous simplement sur <code>http://localhost:8081/hystrix-fallback</code> .  Le client Feign essaiera d'exécuter la demande sur un chemin qui n'existe pas dans le service Items, ce qui conduira au retour de la réponse: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"error"</span></span> : <span class="hljs-string"><span class="hljs-string">"Some error"</span></span>}</code> </pre> <br><h1>  Passerelle UI </h1><br>  Le modèle de passerelle API vous permet de créer un point d'entrée unique pour l'API fourni par d'autres microservices (plus de détails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ).  Une application qui implémente ce modèle effectue le routage (routage) des demandes vers les microservices et peut également effectuer des fonctions supplémentaires, par exemple, l'authentification. <br><br>  Dans ce projet, pour plus de clarté, une passerelle d'interface utilisateur est implémentée, c'est-à-dire un point d'entrée unique pour différentes interfaces utilisateur;  évidemment, l'API de passerelle est implémentée de la même manière.  Le microservice est implémenté sur la base du framework Spring Cloud Gateway.  Une alternative est Netflix Zuul, qui fait partie de Netflix OSS et est intégré à Spring Boot à l'aide de Spring Cloud Netflix. <br>  La passerelle UI s'exécute sur le port 443 à l'aide du certificat SSL généré (situé dans le projet).  SSL et HTTPS sont configurés comme suit: <br><br><pre> <code class="plaintext hljs">server: port: 443 ssl: key-store: classpath:keystore.p12 key-store-password: qwerty key-alias: test_key key-store-type: PKCS12</code> </pre> <br>  Les identifiants et les mots de passe des utilisateurs sont stockés dans une implémentation basée sur une carte de l'interface <code>ReactiveUserDetailsService</code> spécifique à WebFlux: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reactiveUserDetailsService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ReactiveUserDetailsService { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> user = User.withDefaultPasswordEncoder() .username(<span class="hljs-string"><span class="hljs-string">"john_doe"</span></span>).password(<span class="hljs-string"><span class="hljs-string">"qwerty"</span></span>).roles(<span class="hljs-string"><span class="hljs-string">"USER"</span></span>) .build() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> admin = User.withDefaultPasswordEncoder() .username(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>).password(<span class="hljs-string"><span class="hljs-string">"admin"</span></span>).roles(<span class="hljs-string"><span class="hljs-string">"ADMIN"</span></span>) .build() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MapReactiveUserDetailsService(user, admin) }</code> </pre> <br>  Les paramètres de sécurité sont configurés comme suit: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">springWebFilterChain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(http: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ServerHttpSecurity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: SecurityWebFilterChain = http .formLogin().loginPage(<span class="hljs-string"><span class="hljs-string">"/login"</span></span>) .and() .authorizeExchange() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/login"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/static/**"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/favicon.ico"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/webjars/**"</span></span>).permitAll() .pathMatchers(<span class="hljs-string"><span class="hljs-string">"/actuator/**"</span></span>).permitAll() .anyExchange().authenticated() .and() .csrf().disable() .build()</code> </pre> <br>  La configuration donnée détermine qu'une partie des ressources Web (par exemple, la statique) est disponible pour tous les utilisateurs, y compris ceux qui ne se sont pas authentifiés, et tout le reste ( <code>.anyExchange()</code> ) est uniquement authentifié.  Si vous essayez de saisir une URL nécessitant une authentification, elle sera redirigée vers la page de connexion ( <code>https://localhost/login</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vz/eu/yx/vzeuyxohx_kfb17mrg4llnv4n8q.png"></div><br>  Cette page utilise les outils du framework Bootstrap, qui est connecté au projet à l'aide de Webjars, ce qui permet de gérer les bibliothèques côté client comme des dépendances régulières.  Thymeleaf est utilisé pour former des pages HTML.  L'accès à la page de connexion est configuré à l'aide de WebFlux: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = router { GET(<span class="hljs-string"><span class="hljs-string">"/login"</span></span>) { ServerResponse.ok().contentType(MediaType.TEXT_HTML).render(<span class="hljs-string"><span class="hljs-string">"login"</span></span>) } }</code> </pre> <br>  Le routage Spring Cloud Gateway peut être configuré dans une configuration YAML ou java.  Les itinéraires vers les microservices sont attribués manuellement ou sont créés automatiquement en fonction des données reçues du registre du service.  Avec un nombre suffisamment important d'interfaces utilisateur vers lesquelles le routage est requis, il sera plus pratique d'utiliser l'intégration avec le registre de service: <br><br><pre> <code class="plaintext hljs">spring: cloud: gateway: discovery: locator: enabled: true lower-case-service-id: true include-expression: serviceId.endsWith('-UI') url-expression: "'lb:http://'+serviceId"</code> </pre> <br>  La valeur du paramètre <code>include-expression</code> indique que les routes seront créées uniquement pour les microservices dont les noms se terminent par <i>-UI</i> , et la valeur du paramètre <code>url-expression</code> est qu'elles sont accessibles via le protocole HTTP, contrairement à la passerelle UI qui fonctionne via HTTPS, et lorsqu'elles sont accédées ils utiliseront l'équilibrage de la charge client (implémenté à l'aide du ruban Netflix). <br><br>  Prenons l'exemple de la création manuelle de routes dans la configuration java (sans intégration avec le registre de service): <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">routeLocator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(builder: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">RouteLocatorBuilder</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = builder.routes { route(<span class="hljs-string"><span class="hljs-string">"eureka-gui"</span></span>) { path(<span class="hljs-string"><span class="hljs-string">"/eureka"</span></span>) filters { rewritePath(<span class="hljs-string"><span class="hljs-string">"/eureka"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>) } uri(<span class="hljs-string"><span class="hljs-string">"lb:http://eureka-server"</span></span>) } route(<span class="hljs-string"><span class="hljs-string">"eureka-internals"</span></span>) { path(<span class="hljs-string"><span class="hljs-string">"/eureka/**"</span></span>) uri(<span class="hljs-string"><span class="hljs-string">"lb:http://eureka-server"</span></span>) } }</code> </pre> <br>  La première route route vers la page d'accueil du serveur Eureka précédemment affichée ( <code>http://localhost:8761</code> ), la seconde est nécessaire pour charger les ressources sur cette page. <br><br>  Toutes les routes créées par l'application sont disponibles sur <code>https://localhost/actuator/gateway/routes</code> . <br><br>  Dans les microservices sous-jacents, il peut être nécessaire d'accéder à la connexion et / ou aux rôles de l'utilisateur authentifié dans la passerelle UI.  Pour ce faire, j'ai créé un filtre qui ajoute les en-têtes appropriés à la demande: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddCredentialsGlobalFilter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GlobalFilter { private val loggedInUserHeader = "logged-in-user" private val loggedInUserRolesHeader = "logged-in-user-roles" override fun filter</span></span></span></span>(exchange: ServerWebExchange, chain: GatewayFilterChain) = exchange.getPrincipal&lt;Principal&gt;() .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> request = exchange.request.mutate() .header(loggedInUserHeader, it.name) .header(loggedInUserRolesHeader, (it <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Authentication).authorities?.joinToString(<span class="hljs-string"><span class="hljs-string">";"</span></span>) ?: <span class="hljs-string"><span class="hljs-string">""</span></span>) .build() chain.filter(exchange.mutate().request(request).build()) } }</code> </pre> <br>  Passons maintenant à l'interface utilisateur des éléments à l'aide de la passerelle d'interface utilisateur - <code>https://localhost/items-ui/greeting</code> , en supposant à juste titre que le traitement de ces en-têtes a déjà été implémenté dans l'interface utilisateur des éléments: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/sl/_s/rcsl_sdjuf6vkxkite5h3rgzoui.png"></div><br>  Spring Cloud Sleuth est une solution pour le suivi des requêtes dans un système distribué.  Les identifiants Trace Id (identifiant d'intercommunication) et Span Id (identifiant d'unité d'oeuvre) sont ajoutés aux en-têtes de la demande passant par plusieurs microservices (pour une meilleure compréhension, j'ai simplifié le schéma; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">voici une</a> explication plus détaillée): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/1q/em/sp1qem4a6silx9bo3kh83enn_mu.png"></div><br>  Cette fonctionnalité est connectée en ajoutant simplement la <code>spring-cloud-starter-sleuth</code> . <br><br>  En spécifiant les paramètres de journalisation appropriés, dans la console des microservices correspondants, vous pouvez voir quelque chose comme ceci (l'ID de trace et l'ID de plage sont affichés après le nom du microservice): <br><br><pre> <code class="plaintext hljs">DEBUG [ui-gateway,009b085bfab5d0f2,009b085bfab5d0f2,false] oscghRoutePredicateHandlerMapping : Route matched: CompositeDiscoveryClient_ITEMS-UI DEBUG [items-ui,009b085bfab5d0f2,947bff0ce8d184f4,false] oswrfunction.server.RouterFunctions : Predicate "(GET &amp;&amp; /example)" matches against "GET /example" DEBUG [items-service,009b085bfab5d0f2,dd3fa674cd994b01,false] oswrfunction.server.RouterFunctions : Predicate "(GET &amp;&amp; /{id})" matches against "GET /1"</code> </pre> <br>  Pour une représentation graphique d'une trace distribuée, vous pouvez utiliser, par exemple, Zipkin, qui agira comme un serveur qui agrège les informations sur les requêtes HTTP provenant d'autres microservices (plus de détails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ici</a> ). <br><br><h1>  Assemblage </h1><br>  En fonction du système d'exploitation, la <code>gradlew clean build</code> <code>./gradlew clean build</code> ou la <code>./gradlew clean build</code> . <br><br>  Étant donné la possibilité d'utiliser le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">wrapper Gradle</a> , il n'est pas nécessaire d'avoir un Gradle installé localement. <br><br>  La génération et le lancement ultérieur passent avec succès le JDK 11.0.1.  Avant cela, le projet fonctionnait sur JDK 10, donc je suppose que sur cette version, il n'y aura pas de problèmes d'assemblage et de lancement.  Je n'ai pas de données sur les versions antérieures du JDK.  Gardez également à l'esprit que le Gradle 5 utilisé nécessite au moins JDK 8. <br><br><h1>  Lancement </h1><br>  Je recommande de démarrer les applications dans l'ordre dans lequel elles sont décrites dans cet article.  Si vous utilisez Intellij IDEA avec Run Dashboard activé, vous devriez obtenir quelque chose comme ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7h/yb/t0/7hybt0ljfcfnrkckajkikwctj-g.png"></div><br><h1>  Conclusion </h1><br>  L'article a examiné un exemple d'architecture de microservices sur la pile technologique actuelle dans le monde Java, ses principaux composants et certaines fonctionnalités.  J'espère que pour quelqu'un le matériel sera utile.  Merci de votre attention! <br><br><h1>  Les références </h1><br><ul><li>  Code source du projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Articles sur le microservice</a> Chris Richardson </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Un article sur les microservices de</a> Martin Fowler </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Guide des</a> microservices Martin Fowler </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431474/">https://habr.com/ru/post/fr431474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431460/index.html">"Calendrier des testeurs" pour novembre. Test de paire raisonnable</a></li>
<li><a href="../fr431462/index.html">Comment nous avons fabriqué un scanner de livres pour les navires</a></li>
<li><a href="../fr431466/index.html">Comment arrêter de viser l'excellence et atteindre une productivité maximale</a></li>
<li><a href="../fr431468/index.html">Une implémentation pratique du générateur de commutation à l'aide de Verilog HDL</a></li>
<li><a href="../fr431470/index.html">Cela, vous pouvez (ordinateur). Une histoire d'une émission de télévision oubliée</a></li>
<li><a href="../fr431478/index.html">Conférence de Roskomnadzor "Protection des données personnelles"</a></li>
<li><a href="../fr431480/index.html">Magento a publié une nouvelle version de plate-forme majeure - 2.3.0 GA</a></li>
<li><a href="../fr431482/index.html">Et toi, Yota ...</a></li>
<li><a href="../fr431486/index.html">Mouches invisibles: une nouvelle méthode pour étudier le système nerveux par la dépigmentation tissulaire</a></li>
<li><a href="../fr431488/index.html">Modulation sonore</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>