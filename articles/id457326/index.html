<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁷󠁬󠁳󠁿 💢 🏜️ Failover Cluster PostgreSQL + Patroni. Pengalaman Implementasi 🗳️ ☀️ 👼🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini, saya akan memberi tahu Anda bagaimana kami mendekati masalah toleransi kesalahan PostgreSQL, mengapa ini menjadi penting bagi kami,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Failover Cluster PostgreSQL + Patroni. Pengalaman Implementasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/miro/blog/457326/">  Dalam artikel ini, saya akan memberi tahu Anda bagaimana kami mendekati masalah toleransi kesalahan PostgreSQL, mengapa ini menjadi penting bagi kami, dan apa yang terjadi pada akhirnya. <br><br>  Kami memiliki layanan yang sangat dimuat: 2,5 juta pengguna di seluruh dunia, 50K + pengguna aktif setiap hari.  Server terletak di Amazone di satu wilayah Irlandia: selalu ada 100+ server berbeda yang beroperasi, yang hampir 50 di antaranya menggunakan basis data. <br><br>  Seluruh backend adalah aplikasi Java stateful monolitik besar yang membuat koneksi websocket konstan ke klien.  Dengan kerja simultan dari beberapa pengguna di satu papan, mereka semua melihat perubahan secara real time, karena kami mencatat setiap perubahan dalam database.  Kami memiliki sekitar 10 ribu kueri per detik ke basis data kami.  Saat beban puncak di Redis, kami menulis di 80-100K kueri per detik. <br><img src="https://habrastorage.org/webt/ef/pn/er/efpner_0rhtuim1zt0gwrhff3b8.png"><br><a name="habracut"></a><br><br><h2>  Mengapa kami beralih dari Redis ke PostgreSQL </h2><br>  Awalnya, layanan kami bekerja dengan Redis, repositori kunci-nilai yang menyimpan semua data dalam RAM server. <br><br>  Pro Redis: <br><br><ol><li>  Tingkat respons tinggi, seperti  semuanya disimpan dalam memori; </li><li>  Kenyamanan cadangan dan replikasi. </li></ol><br>  Cons Redis untuk kita: <br><br><ol><li> Tidak ada transaksi nyata.  Kami mencoba mensimulasikan mereka di tingkat aplikasi kami.  Sayangnya, ini tidak selalu berhasil dan diperlukan penulisan kode yang sangat kompleks. </li><li>  Jumlah data dibatasi oleh jumlah memori.  Ketika jumlah data bertambah, memori akan bertambah, dan pada akhirnya, kita akan bertemu dengan karakteristik instance yang dipilih, yang dalam AWS mengharuskan penghentian layanan kami untuk mengubah jenis instance. </li><li>  Penting untuk terus mempertahankan tingkat latensi rendah, seperti  Kami memiliki sejumlah besar permintaan.  Level delay optimal bagi kami adalah 17-20 ms.  Pada level 30-40 ms, kami mendapatkan jawaban panjang untuk permintaan aplikasi kami dan degradasi layanan.  Sayangnya, ini terjadi pada kami pada bulan September 2018, ketika salah satu contoh Redis karena alasan tertentu menerima latensi 2 kali lebih tinggi dari biasanya.  Untuk mengatasi masalah tersebut, kami menghentikan layanan di tengah hari karena pemeliharaan tidak terjadwal dan mengganti instance Redis yang bermasalah. </li><li>  Sangat mudah untuk mendapatkan ketidakkonsistenan data bahkan dengan kesalahan kecil dalam kode dan kemudian menghabiskan banyak waktu menulis kode untuk memperbaiki data ini. </li></ol><br>  Kami memperhitungkan kerugian dan menyadari bahwa kami perlu pindah ke sesuatu yang lebih nyaman, dengan transaksi normal dan lebih sedikit ketergantungan pada latensi.  Melakukan penelitian, menganalisis banyak opsi dan memilih PostgreSQL. <br><br>  Kami telah pindah ke database baru selama 1,5 tahun dan hanya mentransfer sebagian kecil dari data, jadi sekarang kami bekerja secara bersamaan dengan Redis dan PostgreSQL.  Informasi lebih lanjut tentang tahapan pemindahan dan pemindahan data antara basis data ditulis dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh rekan saya</a> . <br><br>  Ketika kami baru saja mulai bergerak, aplikasi kami bekerja secara langsung dengan database dan beralih ke wizard Redis dan PostgreSQL.  Cluster PostgreSQL terdiri dari master dan replika asinkron.  Beginilah tampilan skema operasi basis data: <br><img src="https://habrastorage.org/webt/wc/wg/ef/wcwgefzqham9mw7hm-5xc37pfp0.png"><br><br><h2>  Penerapan PgBuncer </h2><br>  Sementara kami bergerak, produk juga berkembang: jumlah pengguna dan jumlah server yang bekerja dengan PostgreSQL meningkat, dan kami mulai kehilangan koneksi.  PostgreSQL menciptakan proses terpisah untuk setiap koneksi dan menghabiskan sumber daya.  Anda dapat meningkatkan jumlah koneksi hingga titik tertentu, jika tidak, ada peluang untuk mendapatkan operasi basis data yang tidak optimal.  Pilihan ideal dalam situasi ini adalah pilihan manajer koneksi yang akan berdiri di depan pangkalan. <br><br>  Kami memiliki dua opsi untuk manajer koneksi: Pgpool dan PgBouncer.  Tetapi yang pertama tidak mendukung mode transaksional bekerja dengan database, jadi kami memilih PgBouncer. <br><br>  Kami telah menyiapkan skema kerja berikut: aplikasi kami mengakses satu PgBouncer, diikuti oleh Masters PostgreSQL, dan di belakang setiap master, satu replika dengan replikasi asinkron. <br><img src="https://habrastorage.org/webt/ql/uq/vh/qluqvh64yeyzwvow79wc3tt0nm0.png"><br><br>  Pada saat yang sama, kami tidak dapat menyimpan seluruh jumlah data dalam PostgreSQL, dan kecepatan bekerja dengan basis data penting bagi kami, jadi kami mulai membagikan PostgreSQL pada tingkat aplikasi.  Skema yang dijelaskan di atas relatif mudah untuk ini: ketika menambahkan shard PostgreSQL baru, cukup untuk memperbarui konfigurasi PgBouncer dan aplikasi dapat segera bekerja dengan shard baru. <br><br><h3>  Toleransi Kesalahan PgBouncer </h3><br>  Skema ini bekerja sampai satu-satunya instance PgBuncer meninggal.  Kami berlokasi di AWS, di mana semua instance berjalan pada perangkat keras yang mati secara berkala.  Dalam kasus seperti itu, instance hanya bergerak ke perangkat keras baru dan bekerja lagi.  Ini terjadi dengan PgBouncer, tetapi menjadi tidak tersedia.  Hasil musim gugur ini adalah tidak dapat diaksesnya layanan kami selama 25 menit.  AWS merekomendasikan penggunaan redundansi di sisi pengguna untuk situasi seperti itu, yang tidak diterapkan bersama kami pada saat itu. <br><br>  Setelah itu, kami dengan serius memikirkan toleransi kesalahan cluster PgBouncer dan PostgreSQL, karena situasi serupa dapat terjadi lagi dengan contoh apa pun di akun AWS kami. <br><br>  Kami membangun skema toleransi kesalahan PgBouncer sebagai berikut: semua server aplikasi mengakses Network Load Balancer, di belakangnya terdapat dua PgBouncer.  Setiap PgBouncer melihat master PostgreSQL yang sama dari setiap pecahan.  Jika instance AWS mogok lagi, semua lalu lintas dialihkan melalui PgBouncer lain.  Toleransi kesalahan Network Load Balancer menyediakan AWS. <br><br>  Skema ini memungkinkan Anda untuk dengan mudah menambahkan server PgBouncer baru. <br><img src="https://habrastorage.org/webt/05/uc/da/05ucdayudomunfsxjc_gggs5abe.png"><br><br><h2>  Membuat Cluster Failover PostgreSQL </h2><br>  Dalam mengatasi masalah ini, kami mempertimbangkan berbagai opsi: failover yang ditulis sendiri, repmgr, AWS RDS, Patroni. <br><br><h3>  Skrip yang ditulis sendiri </h3><br>  Mereka dapat memantau pekerjaan master dan, jika jatuh, mempromosikan replika ke master dan memperbarui konfigurasi PgBouncer. <br><br>  Kelebihan dari pendekatan ini adalah kesederhanaan maksimum, karena Anda sendiri yang menulis skrip dan memahami persis cara kerjanya. <br><br>  Cons: <br><br><ul><li>  Master mungkin tidak mati, sebaliknya, kegagalan jaringan dapat terjadi.  Failover, tanpa mengetahui hal ini, akan memajukan replika ke master, dan master lama akan terus bekerja.  Akibatnya, kami mendapatkan dua server sebagai master dan kami tidak tahu yang mana dari mereka yang memiliki data aktual terkini.  Situasi ini juga disebut otak-terpisah; </li><li>  Kami dibiarkan tanpa replika.  Dalam konfigurasi kami, master dan satu replika, setelah beralih replika, itu pindah ke master dan kami tidak lagi memiliki replika, jadi kami harus secara manual menambahkan replika baru; </li><li>  Kami membutuhkan pemantauan tambahan untuk operasi failover, sementara kami memiliki 12 pecahan PostgreSQL, yang berarti kami harus memantau 12 cluster.  Jika Anda menambah jumlah pecahan, Anda harus tetap ingat untuk memperbarui failover. </li></ul><br>  Kegagalan menulis sendiri terlihat sangat rumit dan membutuhkan dukungan non-sepele.  Dengan satu cluster PostgreSQL, ini akan menjadi pilihan termudah, tetapi tidak menskala, jadi tidak cocok untuk kita. <br><br><h3>  Repmgr </h3><br>  Manajer Replikasi untuk cluster PostgreSQL, yang dapat mengelola operasi cluster PostgreSQL.  Pada saat yang sama, tidak ada kegagalan otomatis "di luar kotak" di dalamnya, jadi untuk pekerjaan Anda perlu menulis "bungkus" sendiri di atas solusi yang sudah jadi.  Jadi semuanya bisa menjadi lebih rumit daripada dengan skrip yang ditulis sendiri, jadi kami bahkan tidak mencoba Repmgr. <br><br><h3>  AWS RDS </h3><br>  Ini mendukung semua yang Anda butuhkan untuk kami, tahu cara membuat cadangan dan mendukung kumpulan koneksi.  Ini memiliki peralihan otomatis: setelah kematian master, replika menjadi master baru, dan AWS mengubah catatan dns ke master baru, sementara replika dapat berada di AZ yang berbeda. <br><br>  Kerugiannya termasuk kurangnya pengaturan halus.  Sebagai contoh penyesuaian: pada contoh kami ada batasan untuk koneksi tcp, yang, sayangnya, tidak dapat dilakukan di RDS: <br><br><pre><code class="python hljs">net.ipv4.tcp_keepalive_time=<span class="hljs-number"><span class="hljs-number">10</span></span> net.ipv4.tcp_keepalive_intvl=<span class="hljs-number"><span class="hljs-number">1</span></span> net.ipv4.tcp_keepalive_probes=<span class="hljs-number"><span class="hljs-number">5</span></span> net.ipv4.tcp_retries2=<span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Selain itu, harga AWS RDS hampir dua kali lebih tinggi dari harga contoh biasa, yang merupakan alasan utama untuk menolak keputusan ini. <br><br><h3>  Patroni </h3><br>  Ini adalah template python untuk mengelola PostgreSQL dengan dokumentasi yang baik, failover otomatis, dan kode sumber github. <br><br>  Pro dari Patroni: <br><br><ul><li>  Setiap parameter konfigurasi dicat, jelas cara kerjanya; </li><li>  Kegagalan otomatis bekerja di luar kotak; </li><li>  Itu ditulis dalam python, dan karena kita menulis banyak dalam python sendiri, akan lebih mudah bagi kita untuk mengatasi masalah dan, mungkin, bahkan membantu pengembangan proyek; </li><li>  Ini sepenuhnya mengontrol PostgreSQL, memungkinkan Anda untuk mengubah konfigurasi pada semua node cluster sekaligus, dan jika sebuah cluster restart diperlukan untuk menerapkan konfigurasi baru, maka ini dapat dilakukan lagi menggunakan Patroni. </li></ul><br>  Cons: <br><br><ul><li>  Dari dokumentasi itu tidak jelas cara bekerja dengan PgBouncer.  Meskipun sulit untuk menyebutnya minus, karena tugas Patroni adalah mengelola PostgreSQL, dan bagaimana koneksi ke Patroni akan menjadi masalah kita; </li><li>  Ada beberapa contoh implementasi Patroni pada volume besar, sementara banyak contoh implementasi dari awal. </li></ul><br>  Akibatnya, untuk membuat kluster failover, kami memilih Patroni. <br><br><h2>  Proses Implementasi Patroni </h2><br>  Sebelum Patroni, kami memiliki 12 pecahan PostgreSQL dalam konfigurasi, satu master dan satu replika dengan replikasi asinkron.  Server aplikasi mengakses database melalui Network Load Balancer, di belakangnya terdapat dua instance dengan PgBouncer, dan di belakangnya semua adalah server PostgreSQL. <br><img src="https://habrastorage.org/webt/05/uc/da/05ucdayudomunfsxjc_gggs5abe.png"><br><br>  Untuk mengimplementasikan Patroni, kami perlu memilih repositori konfigurasi cluster terdistribusi.  Patroni bekerja dengan sistem penyimpanan konfigurasi terdistribusi seperti etcd, Zookeeper, Consul.  Kami hanya memiliki cluster Konsul lengkap di prod yang berfungsi bersama Vault dan kami tidak menggunakannya lagi.  Alasan yang bagus untuk mulai menggunakan Konsul untuk tujuan yang dimaksud. <br><br><h3>  Bagaimana Patroni Bekerja dengan Konsul </h3><br>  Kami memiliki sebuah cluster Konsul, yang terdiri dari tiga node, dan sebuah cluster Patroni, yang terdiri dari seorang pemimpin dan sebuah replika (dalam Patroni, seorang master disebut pemimpin cluster, dan budak disebut replika).  Setiap instance dari cluster Patroni secara konstan mengirimkan informasi status cluster ke Konsul.  Oleh karena itu, dari Konsul Anda selalu dapat mengetahui konfigurasi saat ini dari gugus Patroni dan siapa pemimpinnya saat ini. <br><br><img src="https://habrastorage.org/webt/jx/j5/is/jxj5ispkzoegn8x80dw-qtynw3q.png"><br><br>  Untuk menghubungkan Patroni ke Konsul, cukup mempelajari dokumentasi resmi, yang mengatakan bahwa Anda perlu menentukan host dalam format http atau https, tergantung pada bagaimana kami bekerja dengan Konsul, dan skema koneksi, secara opsional: <br><br><pre> <code class="plaintext hljs">host: the host:port for the Consul endpoint, in format: http(s)://host:port scheme: (optional) http or https, defaults to http</code> </pre> <br>  Ini terlihat sederhana, tetapi di sini jebakan dimulai.  Dengan Konsul kami bekerja pada koneksi yang aman melalui https dan konfigurasi koneksi kami akan terlihat seperti ini: <br><br><pre> <code class="python hljs">consul: host: https://server.production.consul:<span class="hljs-number"><span class="hljs-number">8080</span></span> verify: true cacert: {{ consul_cacert }} cert: {{ consul_cert }} key: {{ consul_key }}</code> </pre> <br>  Tapi itu tidak berhasil.  Pada awalnya, Patroni tidak dapat terhubung ke Konsul, karena ia tetap mencoba mengikuti http. <br><br>  Kode sumber untuk Patroni membantu mengatasi masalah tersebut.  Untung itu ditulis dalam python.  Ternyata parameter host tidak diuraikan sama sekali, dan protokol harus ditentukan dalam skema.  Berikut ini adalah blok konfigurasi kerja untuk bekerja dengan Konsul bersama kami: <br><br><pre> <code class="python hljs">consul: host: server.production.consul:<span class="hljs-number"><span class="hljs-number">8080</span></span> scheme: https verify: true cacert: {{ consul_cacert }} cert: {{ consul_cert }} key: {{ consul_key }}</code> </pre> <br><h3>  Konsul-templat </h3><br>  Jadi, kami telah memilih penyimpanan untuk konfigurasi.  Sekarang Anda perlu memahami bagaimana PgBouncer akan mengubah konfigurasinya ketika mengubah pemimpin di kluster Patroni.  Dokumentasi tidak menjawab pertanyaan ini, karena  di sana, pada prinsipnya, bekerja dengan PgBouncer tidak dijelaskan. <br><br>  Dalam mencari solusi, kami menemukan sebuah artikel (sayangnya, saya tidak ingat namanya), di mana ada tertulis bahwa template-Konsul banyak membantu dalam menghubungkan PgBouncer dan Patroni.  Ini mendorong kami untuk mempelajari karya Templat Konsul. <br><br>  Ternyata template-Consul secara konstan memonitor konfigurasi cluster PostgreSQL di Consul.  Ketika pemimpin berubah, ia memperbarui konfigurasi PgBouncer dan mengirimkan perintah untuk mem-boot ulang. <br><br><img src="https://habrastorage.org/webt/iv/_f/j-/iv_fj-sjbnqtfabqlnmu986sa0o.png"><br><br>  Kelebihan besar templat adalah bahwa ia disimpan sebagai kode, jadi ketika menambahkan pecahan baru, cukup membuat komit baru dan memperbarui templat dalam mode otomatis, mendukung prinsip Infrastruktur sebagai kode. <br><br><h3>  Arsitektur baru dengan Patroni </h3><br>  Hasilnya, kami mendapat skema kerja ini: <br><img src="https://habrastorage.org/webt/7b/-m/-v/7b-m-vyorrbbuognzt2qx2-fymm.png"><br><br>  Semua server aplikasi mengakses penyeimbang → dua instance PgBuncuncer berada di belakangnya → pada setiap contoh, onsul-templat diluncurkan, yang memantau status masing-masing cluster Patroni dan memantau relevansi konfigurasi PgBouncer, yang mengirimkan permintaan kepada pemimpin saat ini masing-masing cluster. <br><br><h3>  Pengujian manual </h3><br>  Sebelum meluncurkan program, kami meluncurkan sirkuit ini pada lingkungan uji kecil dan memeriksa operasi switching otomatis.  Mereka membuka papan, memindahkan stiker dan pada saat itu "membunuh" pemimpin gugus itu.  Di AWS, matikan instance melalui konsol. <br><br><img src="https://habrastorage.org/webt/ly/yf/aj/lyyfaj6bxodfoaqrsds5j00ycnw.gif"><br><br>  Stiker kembali kembali dalam 10-20 detik, dan kemudian mulai bergerak dengan normal.  Ini berarti bahwa kluster Patroni bekerja dengan benar: itu mengubah pemimpin, mengirim informasi ke Konsul, dan template-Konsul segera mengambil informasi ini, mengganti konfigurasi PgBouncer dan mengirim perintah untuk memuat ulang. <br><br><h2>  Bagaimana cara bertahan hidup di bawah beban tinggi dan mempertahankan downtime minimum? </h2><br>  Semuanya bekerja dengan baik!  Tetapi muncul pertanyaan baru: Bagaimana cara kerjanya di bawah beban tinggi?  Bagaimana cara menggulung semuanya dengan cepat dan aman ke dalam produksi? <br><br>  Lingkungan pengujian tempat kami melakukan pengujian beban membantu kami menjawab pertanyaan pertama.  Ini benar-benar identik dengan produksi dalam arsitektur dan telah menghasilkan data uji, yang kira-kira sama volumenya dengan produksi.  Kami memutuskan untuk hanya "membunuh" salah satu penyihir PostgreSQL selama pengujian dan melihat apa yang terjadi.  Tetapi sebelum itu, penting untuk memeriksa penggulungan otomatis, karena pada lingkungan ini kami memiliki beberapa pecahan PostgreSQL, jadi kami akan mendapatkan pengujian skrip konfigurasi yang sangat baik sebelum menjual. <br><br>  Kedua tugas terlihat ambisius, tetapi kami memiliki PostgreSQL 9.6.  Mungkin kita akan segera meningkatkan ke 11.2? <br><br>  Kami memutuskan untuk melakukan ini dalam 2 tahap: upgrade pertama ke 11.2, lalu luncurkan Patroni. <br><br><h3>  Pembaruan PostgreSQL </h3><br>  Untuk meningkatkan versi PostgreSQL dengan cepat, Anda harus menggunakan opsi <b>-k</b> , yang menciptakan tautan keras pada disk dan tidak perlu menyalin data Anda.  Dengan basis 300-400 GB, pembaruan membutuhkan waktu 1 detik. <br><br>  Kami memiliki banyak pecahan, sehingga pembaruan perlu dilakukan secara otomatis.  Untuk melakukan ini, kami menulis buku pedoman Ansible, yang melakukan seluruh proses pembaruan untuk kami: <br><br><pre> <code class="plaintext hljs">/usr/lib/postgresql/11/bin/pg_upgrade \ &lt;b&gt;--link \&lt;/b&gt; --old-datadir='' --new-datadir='' \ --old-bindir='' --new-bindir='' \ --old-options=' -c config_file=' \ --new-options=' -c config_file='</code> </pre> <br>  Penting untuk dicatat di sini bahwa sebelum memulai pemutakhiran, perlu untuk mengeksekusinya dengan parameter <b>--check</b> untuk memastikan kemungkinan peningkatan.  Script kami juga membuat substitusi konfigurasi untuk peningkatan.  Script yang kami selesaikan dalam 30 detik, ini adalah hasil yang sangat baik. <br><br><h3>  Luncurkan Patroni </h3><br>  Untuk mengatasi masalah kedua, lihat saja konfigurasi Patroni.  Dalam repositori resmi ada contoh konfigurasi dengan initdb, yang bertanggung jawab untuk menginisialisasi database baru ketika Patroni pertama kali diluncurkan.  Tetapi karena kami memiliki database yang sudah jadi, kami baru saja menghapus bagian ini dari konfigurasi. <br><br>  Ketika kami mulai menginstal Patroni pada cluster PostgreSQL yang sudah jadi dan menjalankannya, kami menghadapi masalah baru: kedua server mulai sebagai pemimpin.  Patroni tidak tahu apa-apa tentang keadaan awal cluster dan mencoba memulai kedua server sebagai dua cluster terpisah dengan nama yang sama.  Untuk mengatasi masalah ini, hapus direktori data pada slave: <br><br><pre> <code class="plaintext hljs">rm -rf /var/lib/postgresql/</code> </pre> <br>  <b>Ini harus dilakukan hanya pada budak!</b> <br><br>  Saat menghubungkan replika bersih, Patroni membuat pemimpin cadangan dan mengembalikannya ke replika, dan kemudian mengejar status saat ini dengan wal-log. <br><br>  Kesulitan lain yang kami temui adalah bahwa semua cluster PostgreSQL disebut main secara default.  Ketika setiap cluster tidak tahu apa-apa tentang yang lain, ini normal.  Tetapi ketika Anda ingin menggunakan Patroni, maka semua cluster harus memiliki nama yang unik.  Solusinya adalah mengubah nama cluster di konfigurasi PostgreSQL. <br><br><h3>  Uji beban </h3><br>  Kami meluncurkan tes yang mensimulasikan pekerjaan pengguna di papan tulis.  Ketika beban mencapai nilai rata-rata harian kami, kami mengulangi tes yang sama persis, kami mematikan satu contoh dengan pemimpin PostgreSQL.  Kegagalan otomatis berfungsi seperti yang kami harapkan: Patroni mengubah pemimpin, Konsul-templat memperbarui konfigurasi PgBouncer dan mengirim perintah untuk memuat ulang.  Menurut grafik kami di Grafana, jelas bahwa ada keterlambatan 20-30 detik dan sejumlah kecil kesalahan dari server terkait dengan koneksi ke database.  Ini adalah situasi yang normal, nilai-nilai tersebut berlaku untuk kegagalan kami dan jelas lebih baik daripada downtime layanan. <br><br><h2>  Output Patroni untuk produksi </h2><br>  Hasilnya, kami mendapat paket berikut: <br><br><ul><li>  Menyebarkan Templat-Konsul ke server PgBouncer dan meluncurkan; </li><li>  Pembaruan PostgreSQL ke versi 11.2; </li><li>  Perubahan nama cluster; </li><li>  Memulai cluster Patroni. </li></ul><br>  Pada saat yang sama, skema kami memungkinkan Anda untuk membuat item pertama di hampir setiap saat, kami dapat bergantian menghapus setiap PgBouncer dari pekerjaan dan menjalankan penyebaran di atasnya dan menjalankan template konsul.  Jadi kami melakukannya. <br><br>  Untuk pengguliran cepat, kami menggunakan Ansible, karena kami telah memeriksa semua buku pedoman pada lingkungan pengujian, dan waktu eksekusi skrip lengkap adalah 1,5 hingga 2 menit untuk setiap pecahan.  Kami dapat meluncurkan semuanya secara bergantian untuk setiap beling tanpa menghentikan layanan kami, tetapi kami harus mematikan setiap PostgreSQL selama beberapa menit.  Dalam hal ini, pengguna yang datanya di beling ini tidak dapat sepenuhnya bekerja saat ini, dan ini tidak dapat diterima oleh kami. <br><br>  Jalan keluar dari situasi ini adalah pemeliharaan terencana, yang berlangsung setiap 3 bulan.  Ini adalah jendela untuk pekerjaan terjadwal ketika kami sepenuhnya mematikan layanan kami dan memperbarui instance database.  Masih ada satu minggu tersisa sampai jendela berikutnya, dan kami memutuskan untuk hanya menunggu dan mempersiapkan lebih lanjut.  Selama menunggu, kami juga memastikan: untuk setiap beling PostgreSQL, kami mengangkat replika cadangan jika terjadi kegagalan untuk menyimpan data terbaru, dan menambahkan contoh baru untuk setiap beling, yang seharusnya menjadi replika baru dalam gugus Patroni, agar tidak mengeksekusi perintah untuk menghapus data. .  Semua ini membantu meminimalkan risiko kesalahan. <br><img src="https://habrastorage.org/webt/ps/ge/yh/psgeyhvrazg-zd1nrochwhl1hag.png"><br><br>  Kami memulai kembali layanan kami, semuanya berjalan sebagaimana mestinya, pengguna terus bekerja, tetapi pada grafik kami melihat beban tinggi yang tidak normal pada server Konsul. <br><img src="https://habrastorage.org/webt/uk/b9/gu/ukb9guaj4wfabq60v262qe098am.png"><br><br>  Mengapa kita tidak melihatnya di lingkungan pengujian?  Masalah ini menggambarkan dengan sangat baik bahwa perlu untuk mengikuti prinsip Infrastruktur sebagai kode dan memperbaiki seluruh infrastruktur, dimulai dengan lingkungan pengujian dan diakhiri dengan produksi.  Kalau tidak, sangat mudah untuk mendapatkan jenis masalah yang kita dapatkan.  Apa yang terjadi  Konsul pertama kali muncul pada produksi, dan kemudian pada lingkungan pengujian, sebagai hasilnya, pada lingkungan pengujian, versi Konsul lebih tinggi daripada pada produksi.  Hanya di salah satu rilis, kebocoran CPU terpecahkan saat bekerja dengan konsul-template.  Karena itu, kami baru saja memperbarui Konsul, sehingga menyelesaikan masalah. <br><br><h3>  Mulai kembali kluster Patroni </h3><br>  Namun, kami mendapat masalah baru yang bahkan tidak kami sadari.  Saat memperbarui Konsul, kami cukup menghapus simpul Konsul dari kluster menggunakan perintah cuti konsul → Patroni terhubung ke server Konsul lain → semuanya berfungsi.  Tetapi ketika kami mencapai contoh terakhir dari cluster Konsul dan mengirim perintah cuti konsul untuk itu, semua cluster Patroni hanya restart, dan dalam log kami melihat kesalahan berikut: <br><br><pre> <code class="plaintext hljs">ERROR: get_cluster Traceback (most recent call last): ... RetryFailedError: 'Exceeded retry deadline' ERROR: Error communicating with DCS &lt;b&gt;LOG: database system is shut down&lt;/b&gt;</code> </pre> <br>  Cluster Patroni tidak dapat memperoleh informasi tentang clusternya dan memulai kembali. <br><br>  Untuk menemukan solusi, kami menghubungi penulis Patroni melalui masalah di github.  Mereka menyarankan peningkatan pada file konfigurasi kami: <br><br><pre> <code class="python hljs">consul: consul.checks: [] bootstrap: dcs: retry_timeout: <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre> <br>  Kami dapat mengulangi masalah pada lingkungan pengujian dan menguji parameter ini di sana, tetapi, sayangnya, mereka tidak berhasil. <br><br>  Masalahnya masih belum terselesaikan.  Kami berencana untuk mencoba solusi berikut: <br><br><ul><li>  Gunakan Konsul-agen pada setiap instance dari cluster Patroni; </li><li>  Perbaiki masalah dalam kode. </li></ul><br>  Kami memahami tempat terjadinya kesalahan: masalahnya mungkin menggunakan batas waktu default, yang tidak ditimpa melalui file konfigurasi.  Ketika server Konsul terakhir dihapus dari cluster, seluruh cluster Konsul membeku selama lebih dari satu detik, karena Patroni ini tidak bisa mendapatkan keadaan cluster dan sepenuhnya me-restart seluruh cluster. <br><br>  Untungnya, kami tidak menemukan kesalahan lagi. <br><br><h2>  Hasil menggunakan Patroni </h2><br>  Setelah peluncuran Patroni yang berhasil, kami menambahkan replika tambahan di setiap kluster.  Sekarang di setiap cluster ada kemiripan kuorum: satu pemimpin dan dua replika - untuk memastikan terhadap kasus otak-terpisah ketika beralih. <br><img src="https://habrastorage.org/webt/ef/pn/er/efpner_0rhtuim1zt0gwrhff3b8.png"><br><br>  Patroni telah bekerja di produksi selama lebih dari tiga bulan.  Selama waktu ini, dia sudah berhasil membantu kami.  Baru-baru ini, pemimpin salah satu cluster meninggal di AWS, kegagalan otomatis bekerja, dan pengguna terus bekerja.  Patroni menyelesaikan tugas utamanya. <br><br>  <b>Ringkasan kecil tentang penggunaan Patroni:</b> <br><br><ul><li>  Kemudahan perubahan konfigurasi.  Cukup untuk mengubah konfigurasi pada satu instance dan akan ditarik ke seluruh cluster.  Jika reboot diperlukan untuk menerapkan konfigurasi baru, Patroni akan melaporkan ini.  Patroni dapat me-restart seluruh cluster dengan satu perintah, yang juga sangat nyaman. </li><li>  Kegagalan otomatis berfungsi dan telah berhasil membantu kami. </li><li>  Pembaruan PostgreSQL tanpa downtime aplikasi.  Pertama-tama Anda harus memutakhirkan replika ke versi baru, kemudian mengubah pemimpin di kluster Patroni dan memperbarui pemimpin lama.  Dalam hal ini, pengujian yang diperlukan untuk kegagalan otomatis terjadi. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457326/">https://habr.com/ru/post/id457326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457308/index.html">Di jalan Sergey Pavlovich Korolev. Proyek berawak Rusia modern. Bagian 2. Rocket</a></li>
<li><a href="../id457310/index.html">Biologi Ketergantungan Informasi</a></li>
<li><a href="../id457312/index.html">Pengantar Teori Set</a></li>
<li><a href="../id457316/index.html">Bagaimana permainan peran di dunia nyata diatur untuk tamu-tamu Armenia dengan perjalanan sekitar setengah dari negara</a></li>
<li><a href="../id457324/index.html">Acara digital di Moskow dari 24 hingga 30 Juni</a></li>
<li><a href="../id457328/index.html">Kategori bukan direktori, atau sistem file Semantic untuk Linux</a></li>
<li><a href="../id457330/index.html">Bagaimana cara cepat memeriksa peringatan menarik yang diberikan oleh alat analisa PVS-Studio untuk kode C dan C ++?</a></li>
<li><a href="../id457332/index.html">Bagaimana cara cepat melihat peringatan menarik yang dihasilkan oleh alat analisa PVS-Studio untuk kode C dan C ++?</a></li>
<li><a href="../id457334/index.html">TacacsGUI, Manajer Konfigurasi</a></li>
<li><a href="../id457336/index.html">Konsekuensi dari pencabutan gigi bungsu sebelum waktunya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>