<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏾 👆🏼 🚓 WMS的离散数学：对库存批次进行聚类 🤱🏻 💃🏼 ✡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本文介绍了在引入WMS系统时如何面对非标准集群问题以及解决该问题的算法。 我们将告诉您如何应用系统，科学的方法解决问题，遇到的困难以及从中学到的教训。 

 该出版物开始了一系列文章，在这些文章中，我们分享了在仓库流程中实施优化算法的成功经验。 该系列文章的目的是使读者熟悉几乎在任何大中型仓库中出现...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WMS的离散数学：对库存批次进行聚类</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463289/"><img src="https://habrastorage.org/webt/pk/sw/xk/pkswxkfx_bl-w83edqla_aaq9vq.jpeg"><br><br> 本文介绍了在引入<i>WMS</i>系统时如何面对非标准集群问题以及解决该问题的算法。 我们将告诉您如何应用系统，科学的方法解决问题，遇到的困难以及从中学到的教训。 <br><br> 该出版物开始了一系列文章，在这些文章中，我们分享了在仓库流程中实施优化算法的成功经验。 该系列文章的目的是使读者熟悉几乎在任何大中型仓库中出现的优化仓库操作的任务类型，并讲述我们在解决此类问题方面的经验以及通过这种方法遇到的陷阱。 这些文章对在仓库物流行业工作，实施<i>WMS</i>系统的人员以及对企业中的数学应用程序和企业流程优化感兴趣的程序员很有用。 <br><br><a name="habracut"></a><h4> 工艺瓶颈 </h4><br>  2018年，我们在车里雅宾斯克LD Trading House公司的仓库中实施了一个引入<i>WMS</i>系统的项目。 推出了产品“ 1C物流：仓库管理3”，该产品可用于20个工作： <i>WMS</i>操作员，仓库管理员，叉车司机。 仓库平均约4000平方米，单元数为5000，SKU为4500。仓库存储自己生产的球形阀，尺寸从1千克到400千克不等。 由于需要根据FIFO和产品放置的“在线”详细信息来选择商品，因此仓库中的库存是按批次存储的（以下说明）。 <br><br> 在为仓库流程设计自动化方案时，我们面临着存货非最优存储的问题。 正如我们已经说过的，起重机的堆放和存储具有“行”的细节。 也就是说，单元中的产品一排又一排地堆叠在一起，通常不存在将一块放在一块上的能力（它们只是掉下来，重量也不小）。 因此，事实证明，一个存储单元中只能定位一个批次的一个命名法，否则，如果不“铲除”整个单元，则旧的命名法不能从新的命名法下拔出。 <br><br> 产品每天到达仓库，每次到达都是一个单独的批次。 尽管每个仓库都应存放在一个单独的单元中，但由于仓库运营1个月，总共创建了30个单独的仓库。 通常不是在整个托盘中而是在整件货物中选择货物，因此，在件选择区域中，在许多单元格中可以看到以下图片：在一个容积大于1 m3的单元格中，有几台起重机占据了单元格体积的不到5-10％（见图1）。 ） <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/qf/bx/hxqfbxlkzhrwql3k0hmcz9l2cem.jpeg"></div>  <i>图1.单元格中几件商品的照片</i> <br><br> 面对存储容量使用不足的问题。 可以想象一下灾难的严重程度，我可以举几个数字：在仓库运营的不同时期内，平均有100到300个这样的单元，其中的残留物很少。 由于仓库相对较小，因此在仓库的装载季节中，该因素成为“瓶颈”，极大地限制了仓库的流程。 <br><br><h4> 解决问题的想法 </h4><br> 这个想法出现了：将日期最近的一批残渣放到一个批次中，然后将这些天平与一个统一的批次紧密地放在一个单元格中，如果没有足够的空间容纳天平总数，则将它们放在几个单元中。 <br><br><img src="https://habrastorage.org/webt/c-/cx/0g/c-cx0gs5mwn14uwupmefgmytzto.jpeg"><br>  <i>图2。</i>  <i>信元压缩方案</i> <br><br> 这使您可以显着减少将用于新放置货物的仓库占用空间。 在仓库容量超负荷的情况下，这种措施是非常必要的，否则可能根本没有足够的可用空间来放置新货物，这将导致仓库在放置和补货过程中受阻。 以前，在实施<i>WMS</i>系统之前，这种操作是手动执行的，因为在细胞中寻找合适残基的过程相当长，所以这种方法是无效的。 现在，随着WMS系统的推出，他们决定实现流程自动化，加速并使其智能化。 <br><br> 解决此问题的过程分为两个阶段： <br><br><ul><li> 在第一阶段，我们发现已关闭日期的各方团体； </li><li> 在第二阶段，对于每组批次，我们计算单元中产品残留的最紧凑放置。 </li></ul><br> 在当前文章中，我们将专注于算法的第一阶段，而下一篇文章将覆盖第二阶段的内容。 <br><br><h4> 搜索问题的数学模型 </h4><br> 在我们坐下来编写代码和发明自行车之前，我们决定科学地解决这个问题，即：将其数学化，将其简化为众所周知的离散优化问题，并使用有效的现有算法进行求解，或者以这些现有算法为基础进行修改。根据要解决的实际任务的具体情况。 <br><br> 由于它显然是从我们要处理集合的问题的业务陈述中得出的，因此我们根据集合理论来阐述这样的问题。 <br><br> 让 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> P </script>  -库存中某些商品的所有剩余部分的集合。 让 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> C </script>  -给定的天数常数。 让 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.066ex" height="2.057ex" viewBox="0 -780.1 889.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-4B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> K </script>  -批次的子集，其中子集的所有成对批次的日期差不超过常数 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> C </script>  。 查找不连续子集的最小数量 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.066ex" height="2.057ex" viewBox="0 -780.1 889.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-4B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math></span></span><script type="math/tex" id="MathJax-Element-5"> K </script> 这样所有子集 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>K</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.066ex" height="2.057ex" viewBox="0 -780.1 889.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-4B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> K </script> 集体会给很多 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-7"> P </script>  。 <br><br> 此外，我们不仅需要找到最小数量的子集，还需要找到尽可能大的子集。 这是由于以下事实：在对批次进行聚类之后，我们将“压缩”在单元格中找到的批次的剩余部分。 让我们举例说明。 假设在时间轴上分布有很多参与者，如图3所示。 <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/-1/yt/zt-1ytuw7m6jtb4x6qtjafowvt8.jpeg"></div>  <i>图3。</i>  <i>多个分区选项</i> <br><br> 在用相同数量的子集分割集合P的两个选项中，第一个分区<b>（a）</b>对我们的任务最有利。 由于组中的参与方越多，出现的压缩组合越多，因此找到最紧凑的压缩的可能性就越大。 当然，这样的规则无非是一种启发式和我们的推测性假设。 尽管，如计算实验所示，如果考虑到这种最大化条件，则残差后续压缩的紧密度将比不考虑此类条件而构造的压缩平均高出5–10％。 <br><br> 换句话说，简而言之，我们需要找到相似方的组或集群，其中相似性的标准由一个常数确定。 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> C </script>  。 该任务使我们想起了众所周知的集群问题。 重要的是，所考虑的问题与聚类问题不同，因为在我们的问题中，有一个严格定义的条件，用于由常量确定的聚类元素相似性准则 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-9"> C </script>  ，并且在聚类问题中没有这种情况。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关群集问题的说明以及有关此任务的信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 因此，我们设法提出问题，并以类似的表达方式找到经典问题。 现在，您需要考虑采用众所周知的算法来解决该问题，以免重新发明轮子，而是采取最佳实践并加以应用。 为了解决聚类问题，我们考虑了最流行的算法，即： <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-10"> k </script>  -意味着 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.007ex" height="1.455ex" viewBox="0 -520.7 433.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-63" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math></span></span><script type="math/tex" id="MathJax-Element-11"> c </script>  -装置，用于选择连接组件的算法，最小生成树算法。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到此类算法的描述和分析<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 为了解决我们的问题，聚类算法 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-12"> k </script>  -表示和 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>c</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.007ex" height="1.455ex" viewBox="0 -520.7 433.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-63" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math></span></span><script type="math/tex" id="MathJax-Element-13"> c </script>  -means根本不适用，因为簇的数量事先无法得知 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6B" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span><script type="math/tex" id="MathJax-Element-14"> k </script> 并且这种算法没有考虑天常数的限制。 这种算法最初被丢弃。 <br> 为了解决我们的问题，选择连接组件的算法和最小生成树算法更合适，但是事实证明，它们不能“直接”应用于要解决的问题并获得良好的解决方案。 为了澄清这一点，我们考虑将此类算法的操作逻辑应用于我们的问题。 <br><br> 考虑图 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>G</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.827ex" height="2.057ex" viewBox="0 -780.1 786.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-47" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi></math></span></span><script type="math/tex" id="MathJax-Element-15"> G </script> 顶上有很多派对 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-16"> P </script> 以及顶点之间的边缘 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.313ex" height="1.817ex" viewBox="-38.5 -520.7 995.9 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMAIN-31" x="712" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>p</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-17"> p_1 </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mn>2</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.313ex" height="1.817ex" viewBox="-38.5 -520.7 995.9 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMAIN-32" x="712" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>p</mi><mn>2</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-18"> p_2 </script> 重量等于批次之间的天数差 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.313ex" height="1.817ex" viewBox="-38.5 -520.7 995.9 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMAIN-31" x="712" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>p</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-19"> p_1 </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>p</mi><mn>2</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.313ex" height="1.817ex" viewBox="-38.5 -520.7 995.9 782.1" role="img" focusable="false" style="vertical-align: -0.607ex; margin-left: -0.089ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-70" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMAIN-32" x="712" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>p</mi><mn>2</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-20"> p_2 </script>  。 在选择连接组件的算法中，指定了输入参数 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-52" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi></math></span></span><script type="math/tex" id="MathJax-Element-21"> R </script> 在哪里 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>e</mi><mi>q</mi><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.957ex" height="2.419ex" viewBox="0 -780.1 2995.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-52" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6C" x="1009" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-65" x="1308" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-71" x="1774" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="2235" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>e</mi><mi>q</mi><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-22"> R \ leq C </script>  ，并在图中 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>G</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.827ex" height="2.057ex" viewBox="0 -780.1 786.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-47" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi></math></span></span><script type="math/tex" id="MathJax-Element-23"> G </script> 去除了重量的所有边缘均被去除 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-52" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi></math></span></span><script type="math/tex" id="MathJax-Element-24"> R </script>  。 只有最接近的对象对保持连接。 该算法的含义是选择一个这样的值 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>R</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.764ex" height="2.057ex" viewBox="0 -780.1 759.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-52" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi></math></span></span><script type="math/tex" id="MathJax-Element-25"> R </script>  ，其中图“分解”为几个相连的组件，其中属于这些组件的当事方满足我们的相似性标准，该标准由常数 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-26"> C </script>  。 生成的组件是群集。 <br><br> 最小生成树算法首先建立在图上 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>G</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.827ex" height="2.057ex" viewBox="0 -780.1 786.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-47" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi></math></span></span><script type="math/tex" id="MathJax-Element-27"> G </script> 最小的生成树，然后依次删除权重最大的边缘，直到图形“分解”为几个相连的组件，其中属于这些组件的批次也将满足我们的相似性标准。 生成的组件将是群集。 <br><br> 当使用这样的算法来解决所考虑的问题时，可能会出现如图4所示的情况。 <br><br><img src="https://habrastorage.org/webt/px/c_/7g/pxc_7gzeqrp-gra6ahc_wostrac.jpeg"><br>  <i>图4.聚类算法在解决问题中的应用。</i> <br><br> 假设我们双方的天数恒定为20天。 数 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>G</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.827ex" height="2.057ex" viewBox="0 -780.1 786.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-47" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>G</mi></math></span></span><script type="math/tex" id="MathJax-Element-28"> G </script> 为了方便视觉感知，以空间形式进行了描绘。 两种算法都给出了具有3个群集的解决方案，可以通过将放置在单独群集中的批处理相互组合轻松地进行改进！ 显然，需要根据要解决的问题的具体情况进一步开发此类算法，将其单纯用于解决我们的问题将产生较差的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lt/6v/ul/lt6vulnpbkgvkiaqoklpzfyrlde.jpeg"></div><br> 因此，在开始编写针对我们的任务修改的图形算法代码并发明自己的自行车（已经在其轮廓中猜出了方形车轮的轮廓）之前，我们再次决定科学地解决此问题，即：尝试将其简化为另一个离散问题进行优化，以期无需修改即可应用其解决方案的现有算法。 <br><br> 下次搜索类似的经典问题成功了！ 可以找到一个离散的优化问题，该问题的陈述与我们的陈述几乎是1比1一致。 这个问题原来<b>是覆盖布景</b>的<b>问题</b> 。 我们提出了适用于我们具体情况的问题说明。 <br><br> 有一个有限集 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-29"> P </script> 和家人 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-30"> S </script> 的所有不相交的缔约方子集，这样每个子集的所有缔约方对的日期差 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6211;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>我</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-31">我</script> 来自家庭 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-32"> S </script> 不超过常数 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-33"> C </script>  。 涂料被称为家庭 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline"> 元素所属的最小功率 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-34"> S </script> 这样集合的并集 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6211;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>我</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-35">我</script> 来自家庭 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline"> 应该给所有各方 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-36"> P </script>  。 <br><br> 有关此问题的详细分析可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到有关覆盖率问题及其修改的实际应用的其他选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br> 所考虑的问题和覆盖集合的经典问题之间的唯一细微差别是需要最大化子集中元素的数量。 当然，可以寻找考虑了这种特殊情况的文章，并且很可能会找到它们。 但是，从下一次搜索文章开始，我们就被一个事实解决了，即解决经典的覆盖集合问题的“贪婪”算法仅考虑子集中元素数量的最大化就建立了一个分区。 因此，我们向前走了一点，现在一切正常。 <br><br><h4> 解决问题的算法 </h4><br> 我们已经决定了要解决的问题的数学模型。 现在我们开始考虑该算法的解决方案。 子集 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6211;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>我</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-37">我</script> 来自家庭 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.499ex" height="2.057ex" viewBox="0 -780.1 645.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-53" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span><script type="math/tex" id="MathJax-Element-38"> S </script> 例如，可以通过这样的过程容易地找到。 <br><br><ol><li>  <b>步骤0。</b>从集合中安排批次 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-39"> P </script> 按日期升序排列。 我们认为，各方均未标记为已查看。 </li><li>  <b>步骤1.</b>从尚未查看的聚会中查找日期最少的聚会。 </li><li>  <b>步骤2.</b>对于找到的一方，向右移动，我们将其包括在子集中 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6211;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>我</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-40">我</script> 日期与当前日期相差不超过 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-41"> C </script> 天。 套装中包含的所有批次 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6211;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>我</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-42">我</script> 标记为已查看。 </li><li>  <b>步骤3.</b>如果在向右移动时不能将下一个批次包含在其中 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x6211;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>我</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-43">我</script>  ，然后转到步骤1。 </li></ol><br> 覆盖集合的问题是 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>N</mi><mi>P</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.809ex" height="2.057ex" viewBox="0 -780.1 1640 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-50" x="888" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>N</mi><mi>P</mi></math></span></span><script type="math/tex" id="MathJax-Element-44"> NP </script>  -困难，这意味着对它的解决方案没有快速的算法（运算时间等于输入数据中的多项式）。 因此，为了解决覆盖集合的问题，选择了一种快速贪婪算法，该算法当然不精确，但具有以下优点： <br><br><ul><li> 对于小尺寸的问题（这只是我们的情况），它计算的解决方案足够接近最佳值。 随着问题规模的扩大，解决方案的质量下降，但仍然相当缓慢。 </li><li> 非常容易实现； </li><li> 快速，因为估计其运行时间为 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF08;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x767E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4E07;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#xFF09;</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.484ex" height="2.298ex" viewBox="0 -780.1 4083.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-4F" x="0" y="0"></use><g transform="translate(763,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">（</text></g><g transform="translate(1593,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">百</text></g><g transform="translate(2423,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">万</text></g><g transform="translate(3253,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">）</text></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mrow class="MJX-TeXAtom-ORD"><mo>（</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>百</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>万</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo>）</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-45"> O（百万）</script>  。 </li></ul><br> 贪心算法根据以下规则选择集合：在每个阶段，选择一个集合，该集合覆盖尚未覆盖的最大元素数。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到该算法及其伪代码的详细说明<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> 在扰流器中以<i>1C</i>语言实现该算法的可能性较低（有关在下一章中为什么他们开始以“黄色”语言实现该算法的信息）。 <br><br><div class="spoiler">  <b class="spoiler_title">1C算法代码</b> <div class="spoiler_text"><pre><code class="1c hljs"><span class="hljs-comment"><span class="hljs-comment">//        //       ()   =  ;  .() &gt; 0   = (); .();       .(.()); ; ;  ;   ()  = 60*60*24;  = ._.();  =  ;  = 0;        = . + *;  = 0;  =  ; //           = .()  .() - 1   = .();  . &lt;=   .();  =  + 1;  //     ; ; ; //       &gt;    = ;  =  ;       .(); ; ; ;  ; </span></span></code> </pre> </div></div><br> 当然，这种算法的最佳性是不可能的-启发式算法，更不用说了。 您可以拿出这样的例子，说明这种算法是错误的。 当在某些迭代中，我们发现多个具有相同元素数量的集合并选择出现的第一个元素时，就会出现此类错误，因为该策略是贪婪的：我注意到了第一件事，而“贪婪”得到了满足。 <br><br> 这样的选择很可能会导致随后的迭代结果欠佳。 但是，在大多数情况下，这种简单算法的准确性仍然很高。 如果要更准确地解决问题，则需要使用更复杂的算法，例如在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工作中</a> ：概率贪婪算法，蚁群算法等。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在工作中</a>可以找到将此类算法与生成的随机数据进行比较的结果<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br><h4> 算法的实现与实现 </h4><br> 这种算法以<i>1C</i>语言实现，并包含在与“ <i>WMS</i>系统”相连的称为“残渣压缩”的外部处理中。 我们没有在<i>C ++中</i>实现该算法，而是从外部Native组件使用该算法，这会更正确，因为<i>C ++代码</i>的速度是<i>1C</i>中类似代码速度的几倍，在某些示例中甚至是十倍。 在<i>1C中，</i>实施了<i>该</i>算法，以节省开发时间并简化客户工作基础上的调试。 该算法的结果如图6所示。 <br><br><img src="https://habrastorage.org/webt/_y/8g/gg/_y8gggbigigzrjh4lpra5fwwlcc.jpeg"><br>  <i>图6。</i>  <i>残渣压缩处理</i> <br><br> 图6显示，在指定的仓库中，存储单元中的当前货物库存被分为几类，其中托运日期相差不超过30天。 由于客户生产和存储金属球阀的保质期为数年，因此可以忽略此日期差异。 请注意，当前此类处理已系统地用于生产中，并且<i>WMS</i>操作员确认批次​​群集的良好质量。 <br><br><h4> 结论和续 </h4><br> 我们从解决这样一个实际问题中获得的主要经验是确认使用范例Mat的有效性。 任务陈述 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.845ex" height="2.419ex" viewBox="0 -780.1 5100 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-69" x="701" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-67" x="1047" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-68" x="1527" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-74" x="2104" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-61" x="2465" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="2995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="3446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6F" x="3898" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-77" x="4383" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-46"> \ rightarrow </script> 著名的垫子。 模型 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.845ex" height="2.419ex" viewBox="0 -780.1 5100 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-69" x="701" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-67" x="1047" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-68" x="1527" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-74" x="2104" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-61" x="2465" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="2995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="3446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6F" x="3898" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-77" x="4383" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-47"> \ rightarrow </script> 著名算法 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.845ex" height="2.419ex" viewBox="0 -780.1 5100 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-69" x="701" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-67" x="1047" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-68" x="1527" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-74" x="2104" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-61" x="2465" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="2995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-72" x="3446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-6F" x="3898" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhjSUkwaU_pmmIuTZ6tDjIQMEk0-SQ#MJMATHI-77" x="4383" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-48"> \ rightarrow </script> 算法考虑了任务的细节。 离散优化已经有300多年的历史，在此期间，人们设法考虑了很多问题并获得了解决这些问题的丰富经验。 首先，建议您先体验一下这种体验，然后再开始重新发明您的自行车。 <br><br> 同样重要的是，可以不将聚类问题的解决方案与压缩其余批次的问题的解决方案分开考虑，而是一起解决此类问题。 也就是说，选择这样的各方划分到可以提供最佳压缩效果的群集中。 但是出于以下原因，决定对这些问题的解决方案进行划分： <br><br><ul><li> 算法开发<b>预算有限</b> 。 开发这种通用的，因此更复杂的算法将更加耗时。 </li><li>  <b>调试和测试的复杂性。</b> 通用算法在验收阶段将更加难以测试和调试，并且其中的错误将在实时操作中更加困难且调试时间更长。 例如，发生了一个错误，并且不清楚在哪里挖掘：屋面毛毡趋向聚集，屋面毛毡趋向压缩？ </li><li>  <b>透明度和可管理性。</b> 这两个任务的分离使压缩过程更加透明，因此对于最终用户-WMS运营商而言更易于管理。 他们可以出于某些原因从压缩中删除某些单元格或编辑可压缩量。 </li></ul><br> 在下一篇文章中，我们将继续讨论优化算法，并考虑最有趣，更复杂的问题：“压缩”单元格中残差的最佳算法，该算法使用从批次聚类算法接收的输入作为输入。 <br><br>  <i>准备了一篇文章</i> <i><br></i>  <i>Roman Shanin，项目部程序员，</i> <i><br></i>  <i>第一家BIT公司，车里雅宾斯克</i> <br><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463289/">https://habr.com/ru/post/zh-CN463289/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463275/index.html">上周第375期（2019年8月5日至11日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN463277/index.html">自我发展分配：带有随机字符串列表并由其选择的HTML表单</a></li>
<li><a href="../zh-CN463279/index.html">PHP摘要162号（2019年8月1日至12日）</a></li>
<li><a href="../zh-CN463281/index.html">为什么Google Play上很少有创新的应用程序，或者为什么有时编程很神奇</a></li>
<li><a href="../zh-CN463285/index.html">ShIoTiny：绘图程序的节点，链接和事件或功能</a></li>
<li><a href="../zh-CN463291/index.html">骰子或骨头</a></li>
<li><a href="../zh-CN463293/index.html">垃圾收集器。 全程+从BOTR转移</a></li>
<li><a href="../zh-CN463295/index.html">C ++和CMake-永远的兄弟，第二部分</a></li>
<li><a href="../zh-CN463297/index.html">忠于您的品味</a></li>
<li><a href="../zh-CN463299/index.html">Kubernetes技巧和窍门：如何提高生产力</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>