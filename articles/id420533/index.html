<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏻 ✨ 📙 Meniru literal properti dengan Java 8 Method Reference 👧🏾 🍀 🥦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari seorang penerjemah: pelanggaran karena kurangnya operator nameOf di Jawa mendorong saya untuk menerjemahkan artikel ini. Untuk yang tidak sabar -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meniru literal properti dengan Java 8 Method Reference</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420533/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rx/cy/ut/rxcyutfwkaqvjicfkhp78xtv_ts.png"></div><br>  <i>Dari seorang penerjemah: pelanggaran karena kurangnya operator nameOf di Jawa mendorong saya untuk menerjemahkan artikel ini.</i>  <i>Untuk yang tidak sabar - di akhir artikel ada implementasi yang sudah jadi di sumber dan binari.</i> <br><br>  Salah satu hal yang kurang dimiliki oleh pengembang perpustakaan di Jawa adalah literal properti.  Dalam posting ini, saya akan menunjukkan bagaimana Anda dapat secara kreatif menggunakan Referensi Metode dari Java 8 untuk mengemulasi literal properti menggunakan generasi bytecode. <br><br>  Sejalan dengan literal kelas (mis., <code>Customer.class</code> ), literal properti memungkinkan untuk merujuk ke properti safe-type kelas kacang.  Ini akan berguna untuk mendesain API di mana ada kebutuhan untuk melakukan tindakan pada properti atau mengonfigurasinya. <br><br>  <i>Dari penerjemah: Di bawah potongan, kami menganalisis bagaimana menerapkan ini dari cara improvisasi.</i> <br><a name="habracut"></a><br>  Misalnya, pertimbangkan API konfigurasi pemetaan indeks di Pencarian Hibernate: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchMapping().entity(Address.class) .indexed() .property(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, ElementType.METHOD) .field();</code> </pre><br>  Atau metode <code>validateValue()</code> dari API Validasi Bean, yang memungkinkan Anda memeriksa nilainya terhadap pembatasan properti: <br><br><pre> <code class="java hljs">Set&lt;ConstraintViolation&lt;Address&gt;&gt; violations = validator.validateValue(Address.class, <span class="hljs-string"><span class="hljs-string">"city"</span></span>, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span> );</code> </pre><br>  Dalam kedua kasus, tipe <code>String</code> digunakan untuk merujuk ke properti <code>city</code> dari objek <code>Address</code> . <br><br>  Ini dapat menyebabkan kesalahan: <br><ul><li>  kelas Address mungkin tidak memiliki properti <code>city</code> sama sekali.  Atau, seseorang mungkin lupa memperbarui nama string properti setelah mengganti nama metode get / set saat refactoring. </li><li>  dalam kasus <code>validateValue()</code> , kami tidak memiliki cara untuk memverifikasi bahwa jenis nilai yang diteruskan cocok dengan jenis properti. </li></ul><br>  Pengguna API ini hanya dapat mempelajari tentang masalah ini dengan meluncurkan aplikasi.  Bukankah lebih keren jika sistem kompiler dan tipe mencegah penggunaan seperti itu dari awal?  Jika Java memiliki literal properti, maka kita bisa melakukan ini (kode ini tidak dikompilasi): <br><br><pre> <code class="java hljs">mapping.entity(Address.class) .indexed() .property(Address::city, ElementType.METHOD ) .field();</code> </pre><br>  Dan: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::city, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Kami dapat menghindari masalah yang disebutkan di atas: kesalahan ketik apa pun pada nama properti akan menyebabkan kesalahan kompilasi, yang dapat dilihat langsung di IDE Anda.  Ini akan memungkinkan kami untuk merancang API konfigurasi Pencarian Hibernate sehingga hanya menerima properti dari kelas Address ketika kami mengkonfigurasi entitas Address.  Dan dalam kasus Validasi <code>validateValue()</code> literal properti akan membantu memastikan bahwa kami memberikan nilai dari tipe yang benar. <br><br><h2>  Referensi Metode Java 8 </h2><br>  Java 8 tidak mendukung literal properti (dan tidak direncanakan untuk mendukungnya di Java 11), tetapi pada saat yang sama, Java menyediakan cara yang menarik untuk meniru mereka: Metode Referensi (metode referensi).  Awalnya, Referensi Metode ditambahkan untuk menyederhanakan bekerja dengan ekspresi lambda, tetapi mereka dapat digunakan sebagai literal properti untuk orang miskin. <br><br>  Pertimbangkan gagasan untuk menggunakan referensi ke metode pengambil sebagai literal properti: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::getCity, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Jelas, ini hanya akan berfungsi jika Anda memiliki seorang pengambil.  Tetapi jika kelas Anda sudah mengikuti konvensi JavaBeans, yang paling sering terjadi, maka itu tidak masalah. <br><br>  Seperti apa deklarasi metode <code>validateValue()</code> ?  Poin kuncinya adalah penggunaan tipe <code>Function</code> baru: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value);</code> </pre><br>  Dengan menggunakan dua parameter pengetikan, kita dapat memverifikasi bahwa tipe bin, properti, dan nilai yang diteruskan sudah benar.  Dari sudut pandang API, kami mendapatkan apa yang kami butuhkan: aman untuk menggunakannya dan IDE bahkan akan secara otomatis menambah nama metode yang dimulai dengan <code>Address::</code> .  Tetapi bagaimana cara mendapatkan nama properti dari objek <code>Function</code> dalam implementasi metode <code>validateValue()</code> ? <br><br>  Dan kemudian kesenangan dimulai, karena antarmuka fungsional Fungsi hanya menyatakan satu metode - <code>apply()</code> , yang mengeksekusi kode fungsi untuk instance <code>T</code> diteruskan.  Ini sepertinya bukan yang kami butuhkan. <br><br><h2>  ByteBuddy untuk menyelamatkan </h2><br>  Ternyata, triknya adalah dalam menerapkan fungsi!  Dengan membuat instance proxy dari tipe T, kami memiliki tujuan memanggil metode dan mendapatkan namanya di pengendali panggilan Proxy.  (Dari penerjemah: selanjutnya kita berbicara tentang proksi Java dinamis - java.lang.reflect.Proxy). <br><br>  Java mendukung proxy dinamis di luar kotak, tetapi dukungan ini hanya terbatas pada antarmuka.  Karena API kami harus bekerja dengan kacang apa pun, termasuk kelas nyata, saya akan menggunakan alat yang hebat, ByteBuddy, bukan Proxy.  ByteBuddy menyediakan DSL sederhana untuk membuat kelas dengan cepat, itulah yang kami butuhkan. <br><br>  Mari kita mulai dengan mendefinisikan antarmuka yang memungkinkan kita untuk menyimpan dan mengambil nama properti yang diekstrak dari Referensi Metode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String propertyName)</span></span></span></span>; }</code> </pre> <br>  Sekarang kita menggunakan ByteBuddy untuk secara terprogram membuat kelas proksi yang kompatibel dengan jenis minat kepada kita (misalnya: Alamat) dan mengimplementasikan <code>PropertyNameCapturer</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; T <span class="hljs-comment"><span class="hljs-comment">/* &amp; PropertyNameCapturer */</span></span> getPropertyNameCapturer(Class&lt;T&gt; type) { DynamicType.Builder&lt;?&gt; builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuddy() (<span class="hljs-number"><span class="hljs-number">1</span></span>) .subclass( type.isInterface() ? Object.class : type ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.isInterface()) { (<span class="hljs-number"><span class="hljs-number">2</span></span>) builder = builder.implement(type); } Class&lt;?&gt; proxyType = builder .implement(PropertyNameCapturer.class) (<span class="hljs-number"><span class="hljs-number">3</span></span>) .defineField(<span class="hljs-string"><span class="hljs-string">"propertyName"</span></span>, String.class, Visibility.PRIVATE) .method( ElementMatchers.any()) (<span class="hljs-number"><span class="hljs-number">4</span></span>) .intercept(MethodDelegation.to( PropertyNameCapturingInterceptor.class )) .method(named(<span class="hljs-string"><span class="hljs-string">"setPropertyName"</span></span>).or(named(<span class="hljs-string"><span class="hljs-string">"getPropertyName"</span></span>))) (<span class="hljs-number"><span class="hljs-number">5</span></span>) .intercept(FieldAccessor.ofBeanProperty()) .make() .load( (<span class="hljs-number"><span class="hljs-number">6</span></span>) PropertyNameCapturer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER ) .getLoaded(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) Class&lt;T&gt; typed = (Class&lt;T&gt;) proxyType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typed.newInstance(); (<span class="hljs-number"><span class="hljs-number">7</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InstantiationException | IllegalAccessException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HibernateException( <span class="hljs-string"><span class="hljs-string">"Couldn't instantiate proxy for method name retrieval"</span></span>, e ); } }</code> </pre><br>  Kode mungkin tampak sedikit membingungkan, jadi izinkan saya menjelaskannya.  Pertama kita mendapatkan instance ByteBuddy (1), yang merupakan titik masuk DSL.  Ini digunakan untuk membuat tipe dinamis yang memperluas tipe yang diinginkan (jika itu adalah kelas) atau mewarisi objek dan mengimplementasikan tipe yang diinginkan (jika itu adalah antarmuka) (2). <br><br>  Kemudian, kami menunjukkan bahwa tipe mengimplementasikan antarmuka PropertyNameCapturer dan menambahkan bidang untuk menyimpan nama properti yang diinginkan (3).  Kemudian kami mengatakan bahwa panggilan ke semua metode harus dicegat oleh PropertyNameCapturingInterceptor (4).  Hanya setPropertyName () dan getPropertyName () (dari antarmuka PropertyNameCapturer) yang dapat mengakses properti real yang dibuat sebelumnya (5).  Akhirnya, kelas dibuat, dimuat (6) dan instantiated (7). <br><br>  Itu saja yang kita butuhkan untuk membuat tipe proxy, terima kasih ByteBuddy, ini dapat dilakukan dalam beberapa baris kode.  Sekarang mari kita lihat pencegat panggilan: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturingInterceptor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@RuntimeType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@This PropertyNameCapturer capturer, @Origin Method method)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">1</span></span>) capturer.setPropertyName(getPropertyName(method)); (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getReturnType() == <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>.class) { (<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ... ) { } <span class="hljs-comment"><span class="hljs-comment">// ... handle all primitve types // ... } else { return null; } } private static String getPropertyName(Method method) { (4) final boolean hasGetterSignature = method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() != null; String name = method.getName(); String propName = null; if (hasGetterSignature) { if (name.startsWith("get") &amp;&amp; hasGetterSignature) { propName = name.substring(3, 4).toLowerCase() + name.substring(4); } else if (name.startsWith("is") &amp;&amp; hasGetterSignature) { propName = name.substring(2, 3).toLowerCase() + name.substring(3); } } else { throw new HibernateException( "Only property getter methods are expected to be passed"); (5) } return propName; } }</span></span></code> </pre><br>  Metode intersept () menerima Metode yang dipanggil dan target untuk panggilan (1).  <code>@Origin</code> dan <code>@This</code> digunakan untuk menentukan parameter yang sesuai sehingga ByteBuddy dapat menghasilkan panggilan intersep () yang benar dalam proxy dinamis. <br><br>  Perhatikan bahwa tidak ada ketergantungan ketat dari reseptor pada tipe ByteBuddy, karena ByteBuddy hanya digunakan untuk membuat proksi dinamis, tetapi tidak ketika menggunakannya. <br><br>  Dengan memanggil <code>getPropertyName()</code> (4) kita bisa mendapatkan nama properti yang sesuai dengan Referensi Metode yang diteruskan, dan menyimpannya di <code>PropertyNameCapturer</code> (2).  Jika metode ini bukan pengambil, maka kode akan melempar pengecualian (5).  Jenis pengembalian pengambil tidak masalah, jadi kami mengembalikan nol dengan mempertimbangkan jenis properti (3). <br><br>  Sekarang kita siap untuk mendapatkan nama properti dalam metode <code>validateValue()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value) { T capturer = getPropertyNameCapturer(type); property.apply(capturer); String propertyName = ((PropertyLiteralCapturer) capturer).getPropertyName(); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre><br>  Setelah menerapkan fungsi ke proksi yang dibuat, kami melemparkan tipe ke PropertyNameCapturer dan mendapatkan nama dari Metode. <br><br>  Jadi, menggunakan beberapa keajaiban menghasilkan bytecode, kami menggunakan Referensi Metode dari Java 8 untuk meniru properti literal. <br><br>  Tentu saja, jika kita memiliki literal properti nyata dalam bahasa tersebut, kita semua akan lebih baik.  Saya bahkan akan mengizinkan bekerja dengan properti pribadi dan, mungkin, properti dapat dirujuk dari anotasi.  Literal real estate akan lebih rapi (tanpa awalan "get") dan tidak akan terlihat seperti retasan. <br><br><h2>  Dari penerjemah </h2><br>  Perlu dicatat bahwa bahasa-bahasa bagus lain sudah mendukung (atau hampir) mekanisme serupa: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pernyataan</a> C # - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nameOf</a> </li><li>  Groovy dan Scala - ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hack metaprogram</a> terkenal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dan makro</a> </li><li>  Kotlin - ada <code>User::login.name</code> sintaks normal <code>User::login.name</code> </li></ul><br>  Jika Anda tiba-tiba menggunakan proyek Lombok dengan Java, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">generator waktu kompilasi bytecode</a> ditulis untuk itu. <br><br>  Terinspirasi oleh pendekatan yang dijelaskan dalam artikel, hamba Anda yang sederhana mengumpulkan perpustakaan kecil yang mengimplementasikan nameOfProperty () untuk Java 8: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Binari</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420533/">https://habr.com/ru/post/id420533/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420521/index.html">Sekarang secara resmi: TLS 1.3 diakui sebagai standar</a></li>
<li><a href="../id420523/index.html">Analisis grafik opsi biner atau bagaimana saya sekali lagi membuktikan pada diri saya bahwa gratis tidak ada</a></li>
<li><a href="../id420525/index.html">Jaringan untuk yang paling berpengalaman. Bagian lima belas. QoS</a></li>
<li><a href="../id420527/index.html">Senyum bisa terdengar dan menular</a></li>
<li><a href="../id420529/index.html">Penggunaan Geeta tingkat lanjut atau bagaimana pensiun enam bulan sebelumnya?</a></li>
<li><a href="../id420537/index.html">Kisah lain tentang bagaimana uang secara relatif diambil dengan megaphone</a></li>
<li><a href="../id420539/index.html">Pendekatan khusus untuk menormalkan dan mengatur ulang gaya (custom-reset.css)</a></li>
<li><a href="../id420541/index.html">Para peneliti dari Carnegie Mellon telah menciptakan "deepfakes" yang paling dipercaya</a></li>
<li><a href="../id420547/index.html">Seperti yang saya tulis dan pertahankan ijazah dalam DEVOPS dan praktik-praktik teknik di 1C dari awal</a></li>
<li><a href="../id420549/index.html">Template FreeMarker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>