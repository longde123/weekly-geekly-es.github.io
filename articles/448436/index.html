<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èπÔ∏è üëà üôÇ Capa de convoluci√≥n: t√©cnicas de optimizaci√≥n de multiplicaci√≥n matricial üõåüèæ üîª üë©üèø‚Äçü§ù‚Äçüë©üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Este art√≠culo es una continuaci√≥n de una serie de art√≠culos que describen los algoritmos subyacentes. 
 Synet es un marco para lanzar r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Capa de convoluci√≥n: t√©cnicas de optimizaci√≥n de multiplicaci√≥n matricial</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448436/"><h2>  Introduccion </h2><br>  Este art√≠culo es una continuaci√≥n de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie de art√≠culos que</a> describen los algoritmos subyacentes. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Synet</a> es un marco para lanzar redes neuronales pre-entrenadas en la CPU. <br><br>  Si observa la distribuci√≥n del tiempo del procesador que se dedica a la propagaci√≥n directa de la se√±al en las redes neuronales, resulta que a menudo m√°s del 90% de todo el tiempo se gasta en capas convolucionales.  Por lo tanto, si queremos obtener un algoritmo r√°pido para una red neuronal, necesitamos, en primer lugar, un algoritmo r√°pido para una capa convolucional.  En este art√≠culo, quiero describir m√©todos para optimizar la propagaci√≥n de se√±al directa en una capa convolucional.  Y quiero comenzar con los m√©todos m√°s utilizados basados ‚Äã‚Äãen la multiplicaci√≥n de matrices.  Tratar√© de mantener la presentaci√≥n en la forma m√°s accesible para que el art√≠culo sea interesante no solo para los especialistas (ya lo saben todo), sino tambi√©n para un c√≠rculo m√°s amplio de lectores.  No pretendo ser una revisi√≥n completa, por lo que cualquier comentario y adici√≥n son bienvenidos. <br><a name="habracut"></a><br><h2>  Opciones de capa de convoluci√≥n </h2><br>  Me gustar√≠a comenzar la descripci√≥n con una descripci√≥n de los par√°metros que est√°n en la capa convolucional.  Los expertos pueden saltarse esta secci√≥n de manera segura. <br><br><h4>  Tama√±os de imagen de entrada y salida </h4><br>  En primer lugar, una capa convolucional se caracteriza por una imagen de entrada y una imagen de salida, que se caracterizan por los siguientes par√°metros: <br><br><img src="https://habrastorage.org/webt/tg/-_/c1/tg-_c1xgj4vbobu3_7l8rcp5u_0.png" alt="imagen"><br><br><ul><li>  <b>srcC / dstC</b> : el n√∫mero de canales en la imagen de entrada y salida.  Notaci√≥n alternativa: <b>C / D.</b> </li><li>  <b>srcH / dstH</b> : altura de la imagen de entrada y salida.  Designaci√≥n alternativa: <b>H.</b> </li><li>  <b>srcW / dstW</b> : ancho de la imagen de entrada y salida.  Designaci√≥n alternativa: <b>W.</b> </li><li>  <b>lote</b> : la cantidad de im√°genes de entrada (salida): la capa puede procesar un lote completo de im√°genes a la vez.  Designaci√≥n alternativa: <b>N.</b> </li></ul><br><h4>  Tama√±os centrales de convoluci√≥n </h4><br>  La operaci√≥n de convoluci√≥n es inherentemente una suma ponderada de cierto vecindario de un punto dado en la imagen.  El tama√±o del n√∫cleo de convoluci√≥n: caracteriza el tama√±o de este vecindario y se describe mediante dos par√°metros: <br><br><img src="https://habrastorage.org/webt/2y/kj/z5/2ykjz5xeebrq6p2dmhrqxxk1pqu.png" alt="imagen"><br><br><ul><li>  <b>kernelY</b> es la altura del kernel de convoluci√≥n.  Designaci√≥n alternativa: <b>Y.</b> </li><li>  <b>kernelX</b> es el ancho del n√∫cleo de convoluci√≥n.  Designaci√≥n alternativa: <b>X.</b> </li></ul><br>  Las convoluciones m√°s comunes con un tama√±o de n√∫cleo de <b>1x1</b> y <b>3x3</b> .  Los tama√±os <b>5x5</b> y <b>7x7</b> son mucho menos comunes.  A veces tambi√©n se encuentran grandes tama√±os de convoluci√≥n, as√≠ como convoluciones con un n√∫cleo que no sea cuadrado, pero esto es m√°s ex√≥tico. <br><br><h4>  Paso de convoluci√≥n </h4><br>  Otro par√°metro importante es el paso de convoluci√≥n: <br><br><img src="https://habrastorage.org/webt/ya/wn/qb/yawnqbziijnefknaqbjalqkzzgu.png" alt="imagen"><br><br><ul><li>  <b>zancada</b> es el paso de convoluci√≥n vertical. </li><li>  <b>strideX</b> - paso de convoluci√≥n horizontal. </li></ul><br>  Si el paso es diferente de <b>1x1</b> , por ejemplo, <b>2x2</b> , la imagen de salida ser√° la mitad (la convoluci√≥n se calcular√° solo en la vecindad de los puntos pares). <br><br><h4>  Convoluci√≥n de estiramiento </h4><br>  El n√∫cleo de convoluci√≥n se puede estirar (aumentar el tama√±o efectivo de la ventana, mientras se mantiene el n√∫mero de operaciones) utilizando los siguientes par√°metros: <br><br><img src="https://habrastorage.org/webt/vb/sv/ev/vbsvevdr2qioxy8htvhxwzx2e4k.png" alt="imagen"><br><br><ul><li>  <b>dilataci√≥n Y</b> : estiramiento vertical de la convoluci√≥n. </li><li>  <b>dilataci√≥n X</b> : estiramiento horizontal de la convoluci√≥n. </li></ul><br>  Vale la pena se√±alar que los casos de estiramiento que no sean <b>1x1 son</b> bastante raros (nunca he encontrado algo as√≠ en mi carrera). <br><br><h4>  Imagen de entrada de relleno </h4><br>  Si aplica una convoluci√≥n con una ventana que es diferente de una sola a la imagen, entonces la imagen de salida ser√° menor en la cantidad de <b>kernel - 1</b> .  El paquete, por as√≠ decirlo, "se come" los bordes.  Para preservar el tama√±o de la imagen, la imagen de entrada a menudo se rellena alrededor de los bordes con ceros.  Cuatro par√°metros m√°s son responsables de esto: <br><br><img src="https://habrastorage.org/webt/p7/px/n0/p7pxn0rfwa2zhinvydqg7gu0-si.png" alt="imagen"><br><br><ul><li>  <b>padY / padX</b> - <b>acolchado</b> frontal vertical y horizontal. </li><li>  <b>padH / padW</b> - <b>acolchado</b> trasero vertical y horizontal. </li></ul><br><h4>  Grupos de canales </h4><br>  T√≠picamente, cada canal de salida es la suma de las convoluciones en todos los canales de entrada.  Sin embargo, este no es siempre el caso.  Es posible dividir los canales de entrada y salida en grupos, la suma se lleva a cabo solo dentro de los grupos: <br><br><img src="https://habrastorage.org/webt/pz/uu/xp/pzuuxpq0grj9zxpmz_oft_eacnm.png" alt="imagen"><br><br><ul><li>  <b>grupo</b> : el n√∫mero de grupos. </li></ul><br>  En la pr√°ctica, las situaciones con <b>group = 1</b> y <b>group = srcC = dstC</b> , la llamada <b>convoluci√≥n profunda, se</b> encuentran con mayor frecuencia. <br><br><h4>  Desplazamiento y funci√≥n de activaci√≥n </h4><br>  Aunque formalmente el desplazamiento y la funci√≥n de activaci√≥n no est√°n incluidos en la convoluci√≥n, con mucha frecuencia estas dos operaciones siguen la capa convolucional, por lo que generalmente tambi√©n se incluyen en ella.  En vista de la variedad de posibles funciones de activaci√≥n y sus par√°metros, no las describir√© aqu√≠ en detalle. <br><br><h2>  Implementaci√≥n b√°sica del algoritmo. </h2><br>  Para empezar, me gustar√≠a dar una implementaci√≥n b√°sica del algoritmo: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">relu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * weight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bias, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; batch; ++b) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dc = <span class="hljs-number"><span class="hljs-number">0</span></span>; dc &lt; dstC / group; ++dc) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = <span class="hljs-number"><span class="hljs-number">0</span></span>; dy &lt; dstH; ++dy) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; dx &lt; dstW; ++dx) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sc = <span class="hljs-number"><span class="hljs-number">0</span></span>; sc &lt; srcC / group; ++sc) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ky = <span class="hljs-number"><span class="hljs-number">0</span></span>; ky &lt; kernelY; ky++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kx = <span class="hljs-number"><span class="hljs-number">0</span></span>; kx &lt; kernelX; kx++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sy = dy * strideY + ky * dilationY - padY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sx = dx * strideX + kx * dilationX - padX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sy &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sy &lt; srcH &amp;&amp; sx &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sx &lt; srcW) sum += src[((b * srcC + sc)*srcH + sy)*srcW + sx] * weight[((dc * srcC / group + sc)*kernelY + ky)*kernelX + kx]; } } } dst[((b * dstC + dc)*dstH + dy)*dstW + dx] = relu(sum + bias[dc]); } } } } } }</code> </pre> <br>  En esta implementaci√≥n, asum√≠ que la imagen de entrada y salida est√° en formato <b>NCHW</b> : <br><br><img src="https://habrastorage.org/webt/rv/qn/4u/rvqn4uc1mdjt_ltl0wlrzyf8ows.png" alt="imagen"><br><br>  los pesos de convoluci√≥n se almacenan en formato <b>DCYX</b> , y nuestra funci√≥n de activaci√≥n es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">ReLU</a> .  En el caso general, esto no es as√≠, pero para la implementaci√≥n b√°sica, tales suposiciones son bastante apropiadas: debe comenzar desde algo. <br><br>  Tenemos 8 ciclos anidados y el n√∫mero total de operaciones: <br><br><pre> <code class="cpp hljs">batch * kernelY * kernelX * srcC * dstH * dstW * dstC / group * <span class="hljs-number"><span class="hljs-number">2</span></span>,</code> </pre><br>  mientras que la cantidad de datos en la entrada: <br><br><pre> <code class="cpp hljs">batch * srcC * srcH * srcW,</code> </pre><br>  y la imagen de salida: <br><br><pre> <code class="cpp hljs">batch * dstC * dstH * dstW,</code> </pre><br>  y la cantidad de pesos: <br><br><pre> <code class="cpp hljs">kernelY * kernelX * srcC * dstC / group.</code> </pre><br>  Si el <b>grupo &lt;&lt; srcC</b> (el n√∫mero de grupos es mucho menor que el n√∫mero de canales), as√≠ como con par√°metros suficientemente grandes <b>srcC</b> , <b>srcH</b> , <b>srcW</b> y <b>dstC</b> , obtenemos un problema inform√°tico cl√°sico cuando el n√∫mero de c√°lculos excede significativamente la cantidad de datos de entrada y salida.  Es decir  La operaci√≥n de convoluci√≥n con una implementaci√≥n adecuada debe descansar en los recursos inform√°ticos del procesador y no en el ancho de banda de la memoria.  Solo queda encontrar esta implementaci√≥n. <br><br><h2>  Reducci√≥n del problema a la multiplicaci√≥n de matrices. </h2><br>  La operaci√≥n principal en la convoluci√≥n es obtener una suma ponderada, y los pesos son los mismos para todos los puntos de la imagen de salida.  Si reorganiza la imagen de entrada de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">im2col</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sc = <span class="hljs-number"><span class="hljs-number">0</span></span>; sc &lt; srcC; ++sc) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ky = <span class="hljs-number"><span class="hljs-number">0</span></span>; ky &lt; kernelY; ky++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kx = <span class="hljs-number"><span class="hljs-number">0</span></span>; kx &lt; kernelX; kx++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = <span class="hljs-number"><span class="hljs-number">0</span></span>; dy &lt; dstH; ++dy) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; dx &lt; dstW; ++dx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sy = dy * strideY + ky * dilationY - padY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sx = dx * strideX + kx * dilationX - padX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sy &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sy &lt; srcH &amp;&amp; sx &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sx &lt; srcW) *buf++ = src[((b * srcC + sc)*srcH + sy)*srcW + sx]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *buf++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } } }</code> </pre><br>  Luego <b>cambiaremos</b> del formato <b>srcC - srcH - srcW</b> y <b>cambiaremos</b> al formato <b>srcC - kernelY - kernelX - dstH - dstW</b> .  La figura siguiente muestra c√≥mo se convierte la imagen con relleno <b>1</b> y n√∫cleo <b>3x3</b> : <br><br><img src="https://habrastorage.org/webt/mn/lz/rw/mnlzrw76nnibv73tcjn2yuzsfhk.png" alt="imagen"><br><br>  En este caso, todos los puntos de la vecindad de la imagen que se requieren para la operaci√≥n de convoluci√≥n se alinean a lo largo de las columnas de la matriz resultante (de ah√≠ su nombre, es decir, las columnas). <br><br>  La nueva representaci√≥n de la imagen de entrada es interesante porque ahora la operaci√≥n de convoluci√≥n en nosotros se reduce a la multiplicaci√≥n de matrices: <br><br><img src="https://habrastorage.org/webt/2l/cm/lp/2lcmlpitdsgjyztxnyylyqi62jo.png" alt="imagen"><br><br>  Ahora el c√≥digo de convoluci√≥n se ver√° as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gemm_nn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lda, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ldb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * C, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ldc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j) { C[i*ldc + j] = beta; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; K; ++k) C[i*ldc + j] += alpha * A[i*lda + k] * B[k*ldb + j]; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * weight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bias, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> M = dstC / group; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = dstH * dstW; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K = srcC * kernelY * kernelX / group; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; batch; ++b) { im2col(src, srcC, srcH, srcW, kernelY, kernelX, dilationY, dilationY, strideY, strideX, padY, padX, padH, padW, buf); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) gemm_nn(M, N, K, <span class="hljs-number"><span class="hljs-number">1</span></span>, weight + M * K * g, K, <span class="hljs-number"><span class="hljs-number">0</span></span>, buf + N * K * g, N, dst + M * N * g, N)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j) dst[i*N+ j] = relu(dst[i*N + j] + bias[i]); src += srcC*srcH*srcW; dst += dstC*dstH*dstW; } }</code> </pre><br>  Aqu√≠ la implementaci√≥n trivial de la multiplicaci√≥n de matrices se da solo como un ejemplo.  Podemos reemplazarlo con cualquier otra implementaci√≥n.  Afortunadamente, la multiplicaci√≥n de matrices es una operaci√≥n establecida desde hace mucho tiempo que ya se ha implementado en muchas bibliotecas con una eficiencia muy alta (hasta el 90% del rendimiento de CPU te√≥ricamente posible).  Sobre el tema de c√≥mo se logra esta eficiencia, incluso tengo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo separado</a> . <br><br><h2>  Usando la multiplicaci√≥n de matrices para el formato NHWC </h2><br>  Junto con el formato <b>NCHW</b> , <b>NHWC se</b> usa a menudo en el aprendizaje autom√°tico: <br><br><img src="https://habrastorage.org/webt/9x/rk/j6/9xrkj6vqbrmdiamgfpmkmkxsaoo.png" alt="imagen"><br><br>  Como ejemplo, tenga en cuenta que <b>NHWC</b> es el formato nativo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Tensorflow</a> . <br><br>  Es de destacar que para este formato, la operaci√≥n de convoluci√≥n tambi√©n puede conducir a la multiplicaci√≥n de matrices.  Para hacer esto, desde el formato <b>srcH - srcW - srcC</b> traducimos la imagen original al formato <b>dstH - dstW - kernelY - kernelX - srcC</b> usando la funci√≥n <b>im2row</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">im2row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = <span class="hljs-number"><span class="hljs-number">0</span></span>; dy &lt; dstH; ++dy) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; dx &lt; dstW; ++dx) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ky = <span class="hljs-number"><span class="hljs-number">0</span></span>; ky &lt; kernelY; ky++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kx = <span class="hljs-number"><span class="hljs-number">0</span></span>; kx &lt; kernelX; kx++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sy = dy * strideY + ky * dilationY - padY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sx = dx * strideX + kx * dilationX - padX; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sc = <span class="hljs-number"><span class="hljs-number">0</span></span>; sc &lt; srcC; ++sc) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sy &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sy &lt; srcH &amp;&amp; sx &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sx &lt; srcW) *buf++ = src[(sy * srcW + sx)*srcC + sc]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *buf++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } } src += srcC / group; } }</code> </pre><br>  Adem√°s, todos los puntos de la vecindad de la imagen que se requieren para la operaci√≥n de convoluci√≥n se alinean a lo largo de las filas de la matriz resultante (de ah√≠ su nombre - imagen <b>a la</b> <b>fila</b> s).  Tambi√©n debemos cambiar el formato de almacenamiento de las escalas de convoluci√≥n del formato <b>DCYX al</b> formato <b>YXCD</b> .  Ahora podemos aplicar la multiplicaci√≥n de matrices: <br><br><img src="https://habrastorage.org/webt/6p/k-/q-/6pk-q-wqfe060sq1y_vrstkw3ea.png" alt="imagen"><br><br>  A diferencia del formato <b>NCHW</b> , multiplicamos la matriz de imagen por la matriz de peso, y no al rev√©s.  El siguiente es un c√≥digo de funci√≥n de convoluci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * weight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bias, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> M = dstH * dstW; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = dstC / group; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K = srcC * kernelY * kernelX / group; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; batch; ++b) { im2row(src, srcC, srcH, srcW, kernelY, kernelX, dilationY, dilationY, strideY, strideX, padY, padX, padH, padW, group, buf); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) gemm_nn(M, N, K, <span class="hljs-number"><span class="hljs-number">1</span></span>, buf + M * K * g, K * group, <span class="hljs-number"><span class="hljs-number">0</span></span>, weight + N * g, dstC, dst + N * g, dstC)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j) dst[i*N+ j] = relu(dst[i*N + j] + bias[i]); src += srcC*srcH*srcW; dst += dstC*dstH*dstW; } }</code> </pre><br><h2>  Ventajas y desventajas del m√©todo. </h2><br>  Desde el principio, me gustar√≠a enumerar las ventajas de este enfoque: <br><br><ul><li>  Este m√©todo tiene una implementaci√≥n muy simple.  No en vano, se usa en casi todas las bibliotecas que conozco. </li><li>  La efectividad del m√©todo para muchos casos es muy alta: desde unidades de porcentaje en la versi√≥n b√°sica alcanzamos m√°s del 80% del m√°ximo te√≥rico. </li><li>  El enfoque es universal: tenemos un c√≥digo para todos los par√°metros posibles de la capa convolucional (¬°y hay muchos de ellos!).  Por lo tanto, este m√©todo a menudo funciona en casos donde los enfoques m√°s efectivos (y por lo tanto m√°s especializados) tienen limitaciones. </li><li>  El enfoque funciona para los principales formatos de tensores de imagen: <b>NCHW</b> y <b>NHWC</b> . </li></ul><br>  Ahora sobre las desventajas: <br><br><ul><li>  Desafortunadamente, la multiplicaci√≥n matricial est√°ndar es efectiva siempre que los valores de los par√°metros <b>M, N, K</b> sean lo suficientemente grandes y, adem√°s, tengan aproximadamente el mismo orden de magnitud (la eficiencia se basa en el hecho de que el n√∫mero requerido de c√°lculos es <b>~ O (N ^ 3)</b> y el rendimiento requerido capacidad de memoria <b>~ O (N ^ 2)</b> ).  Por lo tanto, si alguno de los par√°metros <b>M, N, K es</b> peque√±o, la eficiencia del m√©todo cae bruscamente. </li><li>  El m√©todo requiere la conversi√≥n de datos de entrada.  Y esto est√° lejos de ser una operaci√≥n gratuita.  Solo puede ser descuidada si <b>K</b> es lo suficientemente grande.  Y si tenemos en cuenta que dentro de la multiplicaci√≥n de matriz est√°ndar todav√≠a hay una transformaci√≥n interna de los datos de entrada, entonces la situaci√≥n se vuelve a√∫n m√°s triste. </li><li>  Basado en el hecho de que <b>K = srcC * kernelY * kernelX / group</b> , la eficiencia del m√©todo es especialmente baja para las capas convolucionales de entrada.  Y para <b>una convoluci√≥n profunda, el</b> m√©todo de <b>la</b> matriz generalmente pierde con la implementaci√≥n trivial. </li><li>  El m√©todo requiere un procesamiento adicional de los datos de salida para la operaci√≥n de cambio y el c√°lculo de la funci√≥n de activaci√≥n. </li><li>  Existen m√©todos matem√°ticos m√°s eficientes para calcular la convoluci√≥n, que requieren menos operaciones. </li></ul><br><h2>  Conclusiones </h2><br>  El m√©todo de c√°lculo de convoluci√≥n basado en la multiplicaci√≥n de matrices es simple de implementar y tiene una alta eficiencia.  Lamentablemente, no es universal.  Para una serie de casos especiales, hay enfoques m√°s r√°pidos, cuya descripci√≥n me gustar√≠a posponer para los pr√≥ximos art√≠culos de esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie</a> .  Esperando comentarios y comentarios de los lectores.  ¬°Espero que te haya interesado! <br><br>  <b>PD:</b> Este y otros enfoques son implementados por m√≠ en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Marco de Convoluci√≥n</a> como parte de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Simd</a> . <br>  Este marco subyace a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Synet</a> , un marco para ejecutar redes neuronales pre-entrenadas en la CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448436/">https://habr.com/ru/post/448436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448422/index.html">E-Dobavki es un servicio de b√∫squeda de suplementos alimenticios Java y Spring Boot escrito por mis alumnos</a></li>
<li><a href="../448424/index.html">55 a√±os despu√©s: ic√≥nicas consolas de culto de sistema principal IBM System / 360</a></li>
<li><a href="../448430/index.html">Pro Content 2019: tres informes duros y ditty</a></li>
<li><a href="../448432/index.html">Radiaci√≥n adhesiva: radiactividad inducida, contaminaci√≥n radiactiva, descontaminaci√≥n ...</a></li>
<li><a href="../448434/index.html">Principales empresas de desarrollo de aplicaciones m√≥viles</a></li>
<li><a href="../448438/index.html">Limitar la velocidad de procesamiento de solicitudes o c√≥mo no organizar un ataque DDoS en su cliente</a></li>
<li><a href="../448440/index.html">Cientos de miles de pagos realizados por ciudadanos al STSI y al FSSP eran de dominio p√∫blico.</a></li>
<li><a href="../448442/index.html">SSD GIGABYTE Aorus RGB M.2: peque√±o, incluso remoto para LED RGB (1 parte)</a></li>
<li><a href="../448444/index.html">Deshacerse del miedo al primer empleo</a></li>
<li><a href="../448448/index.html">Informe SWIFT: el volumen de fondos robados por los piratas inform√°ticos de los bancos disminuy√≥ diez veces tres a√±os despu√©s del ataque en $ 100 millones</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>