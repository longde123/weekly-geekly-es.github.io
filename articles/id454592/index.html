<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏾 👨🏿‍💻 🈳 WAF melalui mata para peretas ♏️ ♾ 🏇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang salah satu mekanisme keamanan modern untuk aplikasi web, yaitu Web Application Firewall (WAF). Kami akan membahas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAF melalui mata para peretas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/454592/"><img align="left" src="https://habrastorage.org/webt/nx/mm/yz/nxmmyzb6nr39jk_zmiu5wcnylbm.png">  Hari ini kita akan berbicara tentang salah satu mekanisme keamanan modern untuk aplikasi web, yaitu Web Application Firewall (WAF).  Kami akan membahas WAF modern dan apa yang menjadi dasarnya, serta teknik memotong, cara menggunakannya, dan mengapa Anda tidak boleh sepenuhnya bergantung pada WAF.  Kita berbicara dari perspektif pentester;  kami tidak pernah mengembangkan WAF dan hanya mengumpulkan data dari sumber terbuka.  Dengan demikian, kita hanya bisa merujuk pada pengalaman kita sendiri dan mungkin tidak menyadari beberapa kekhasan WAF. <br clear="left"><a name="habracut"></a><br><hr><br><br>  <i>Penafian: ini adalah terjemahan dari artikel dari Bahasa Rusia ke Bahasa Inggris, artikel ini dirilis pada akhir 2017, masing-masing, beberapa informasi bisa menjadi usang.</i> <br><br><h4>  Isi </h4><br><ol><li>  Pendahuluan </li><li>  WAF modern </li><li>  Mengidentifikasi WAF </li><li>  WAF memotong cheatsheet </li><li>  Bypass WAF dalam praktek </li><li>  Kesimpulan </li></ol><br>  <i>Jika Anda tahu mengapa WAF digunakan dan bagaimana cara kerjanya, Anda bisa langsung melompat ke bagian bypass.</i> <br><br><h2>  Pendahuluan </h2><br>  WAF telah menjadi sangat populer baru-baru ini.  Vendor menawarkan berbagai solusi dalam rentang harga yang berbeda, kit distribusi, dan opsi, menargetkan pelanggan yang berbeda, dari bisnis kecil hingga perusahaan besar.  WAF populer karena merupakan solusi kompleks untuk melindungi aplikasi web, yang mencakup seluruh spektrum tugas.  Itu sebabnya pengembang aplikasi web dapat mengandalkan WAF dalam beberapa aspek keamanan.  Meskipun, WAF tidak dapat memberikan keamanan total. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395af93092095133873.png"><br><br>  Jadi, apa yang harus WAF mampu untuk membenarkan implementasinya dalam suatu proyek?  Fungsi utamanya adalah mendeteksi dan memblokir setiap permintaan yang, menurut analisis WAF, memiliki anomali atau vektor serangan.  Analisis tidak boleh menghalangi interaksi antara pengguna yang sah dan aplikasi web sementara pada saat yang sama, harus secara akurat dan tepat waktu mendeteksi setiap upaya serangan.  Untuk mengimplementasikan fungsi tersebut, pengembang WAF menggunakan ekspresi reguler, tokenizer, analisis perilaku, analisis reputasi, dan tentu saja pembelajaran mesin.  Seringkali, semua teknologi ini digunakan bersama.  WAF juga dapat mengimplementasikan fungsi-fungsi lain: perlindungan DDoS, larangan IP penyerang, pemantauan IP yang mencurigakan, menambahkan tajuk keamanan (X-XSS-Protection, X-Frame-Options, dll.), Menambahkan hanya bendera http ke cookie, implementasi dari mekanisme HSTS dan token CSRF.  Juga, beberapa WAF memiliki modul sisi klien JavaScript untuk situs web. <br><br>  Tentu saja, WAF menciptakan beberapa kendala bagi peretas dan pentester.  WAF membuat kerentanan menemukan dan mengeksploitasi lebih banyak sumber daya-intensif (kecuali jika penyerang tahu metode bypass 0 hari yang efektif untuk WAF tertentu).  Pemindai otomatis praktis tidak berguna ketika menganalisis aplikasi web yang dilindungi WAF.  WAF adalah perlindungan yang andal terhadap "scriptkiddies".  Padahal, peretas berpengalaman atau peneliti tanpa motivasi yang cukup mungkin tidak akan mau membuang waktu untuk mencari cara untuk memotongnya.  Perlu dicatat bahwa aplikasi web yang lebih kompleks adalah semakin besar permukaan serangannya, dan semakin mudah untuk menemukan metode memotong. <br><br>  Dalam audit terbaru kami, kami sering menemukan WAF yang berbeda.  Kami akan membicarakan beberapa di antaranya nanti.  Kami telah menguji dua WAF eksklusif dalam dua skenario utama: <br><br><ul><li>  Kami tahu ada kerentanan tertentu dalam aplikasi web dan kami mencoba memotong WAF untuk mengeksploitasinya; </li><li>  Kami tidak tahu tentang kerentanan apa pun, jadi kami harus menemukannya di samping WAF dan kemudian memanfaatkannya dengan melewati WAF. </li></ul><br>  Tapi pertama-tama, mari kita melihat lebih dekat mekanisme dasar di balik WAF dan melihat masalah apa yang mereka miliki. <br><br><h2>  WAF modern </h2><br>  Untuk dapat secara efektif menemukan berbagai cara untuk memotong WAF, pertama, kita perlu mengetahui mekanisme klasifikasi permintaan yang modern.  Setiap WAF dibuat khusus dan unik, tetapi ada beberapa metode analisis umum.  Mari kita lihat itu. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395af93c4f468367566.png"><br><br><h4>  Aturan berdasarkan pada ekspresi reguler </h4><br>  Mayoritas WAF yang ada menggunakan aturan berdasarkan ekspresi reguler.  Pengembang meneliti serangkaian serangan yang diketahui untuk mengidentifikasi struktur sintaksis kunci yang dapat menunjukkan serangan.  Berdasarkan data ini, pengembang membuat ekspresi reguler yang menemukan struktur sintaksis tersebut.  Kedengarannya sederhana, tetapi metode ini memiliki kelemahan tertentu.  Pertama, ekspresi reguler dapat diterapkan hanya pada satu permintaan, atau bahkan parameter permintaan tunggal, yang jelas-jelas mengurangi efisiensi aturan tersebut dan meninggalkan beberapa titik buta.  Kedua, sintaks ekspresi reguler dan logika kompleks dari protokol teks, yang memungkinkan penggantian ke struktur yang setara dan menggunakan representasi simbol yang berbeda, menyebabkan kesalahan saat membuat aturan ini. <br><br>
<h4>  Membangun kembali bangunan </h4><br>  Mereka yang tahu cara kerja firewall jaringan dan anti-virus harus terbiasa dengan mekanisme ini.  Itu tidak mendeteksi serangan tetapi melengkapi mekanisme lain yang membuatnya lebih tepat dan fleksibel.  Masalahnya adalah bahwa struktur "mencurigakan" dalam permintaan bukanlah kondisi yang cukup untuk mendeteksi serangan dan dapat menyebabkan banyak kesalahan positif.  Masalah ini diselesaikan dengan menerapkan sistem penilaian.  Setiap aturan berdasarkan ekspresi reguler dilengkapi dengan informasi tentang kekritisannya;  setelah semua aturan yang dipicu diidentifikasi, kekritisannya dirangkum.  Jika kekritisan total mencapai nilai ambang, serangan terdeteksi dan permintaan diblokir.  Terlepas dari kesederhanaannya, mekanisme ini terbukti efisien dan banyak digunakan untuk tugas-tugas tersebut. <br><br><h4>  Tokenizer </h4><br>  Metode deteksi ini disajikan di Black Hat 2012 sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libinjeksi</a> perpustakaan C / C +, yang memungkinkan untuk mengidentifikasi injeksi SQL dengan cepat dan dengan presisi.  Pada saat ini, ada banyak port libinjection untuk berbagai bahasa pemrograman, seperti PHP, Lua, Python, dll.  Mekanisme ini mencari tanda tangan yang disajikan sebagai satu set token.  Sejumlah tanda tangan tertentu dimasukkan dalam daftar hitam, dan dianggap tidak diinginkan dan berbahaya.  Dengan kata lain, sebelum beberapa permintaan dianalisis, itu diterjemahkan ke dalam satu set token.  Token dibagi menjadi beberapa tipe tertentu, seperti variabel, string, operator reguler, tidak diketahui, angka, komentar, operator seperti serikat, fungsi, koma, dll.  Salah satu kelemahan utama dari metode ini adalah kemungkinan untuk membangun struktur yang mengarah pada pembentukan token yang salah, maka tanda tangan permintaan akan berbeda dari yang diharapkan.  Struktur ini biasanya disebut sebagai token breaker, dan kita akan membahasnya nanti <br><br><h4>  Analisis perilaku </h4><br>  Mendeteksi dan memblokir upaya eksploitasi dalam permintaan bukan satu-satunya tugas WAF.  Penting juga untuk mengidentifikasi proses pencarian kerentanan dan WAF harus bereaksi sesuai.  Ini mungkin memanifestasikan dirinya sebagai upaya pemindaian, kekuatan kasar direktori, pembelahan parameter, dan metode otomatis lainnya.  WAF canggih dapat membangun rantai permintaan yang tipikal untuk perilaku normal normal dan memblokir upaya untuk mengirim permintaan yang tidak biasa.  Metode ini tidak begitu banyak mendeteksi serangan, karena menghambat proses pencarian kerentanan.  Membatasi jumlah permintaan per menit tidak akan memengaruhi pengguna biasa tetapi akan menjadi penghambat serius bagi pemindai, yang bekerja di banyak utas. <br><br><h4>  Analisis reputasi </h4><br>  Ini adalah mekanisme lain yang secara langsung diwarisi dari firewall dan anti-virus.  Saat ini, hampir semua WAF termasuk daftar alamat VPN, anonim, Tor node, dan botnet untuk memblokir permintaan dari mereka.  WAF lanjutan dapat secara otomatis memperbarui basis mereka dan melengkapinya dengan entri tambahan berdasarkan lalu lintas yang dianalisis. <br><br><h4>  Pembelajaran mesin </h4><br>  Ini adalah salah satu aspek WAF yang paling dipertanyakan.  Mari kita perhatikan bahwa istilah "pembelajaran mesin" cukup luas dan mencakup banyak teknologi dan metode.  Selain itu, itu hanya salah satu kelas AI.  "Implementasi" pembelajaran mesin, atau "penggunaan AI" adalah ungkapan pemasaran yang sangat populer.  Tidak selalu jelas algoritma mana yang digunakan dengan tepat, dan kadang-kadang terlihat seperti omong kosong belaka.  Vendor yang benar-benar menggunakan pembelajaran mesin dan melakukannya secara efektif tidak mau berbagi pengalaman mereka.  Itu membuat sulit bagi orang luar untuk mencoba mencari tahu situasinya.  Namun demikian, mari kita coba membuat beberapa poin berdasarkan informasi yang tersedia. <br><br>  Pertama, pembelajaran mesin sepenuhnya tergantung pada data yang dilatihnya, yang menimbulkan masalah tertentu.  Pengembang harus memiliki basis serangan terkini dan lengkap, yang sulit dicapai.  Itu sebabnya banyak pengembang secara menyeluruh mencatat hasil WAF mereka dan bekerja sama dengan vendor yang menyediakan sistem IDS dan SIEM untuk mendapatkan contoh serangan dunia nyata.  Kedua, model yang dilatih pada aplikasi web abstrak mungkin ternyata sama sekali tidak efektif pada aplikasi web nyata.  Untuk kualitas yang lebih baik, direkomendasikan untuk melatih model pada tahap implementasi, yang membutuhkan banyak sumber daya dan memakan waktu dan masih tidak memberikan hasil terbaik. <br><br><h2>  Mengidentifikasi WAF </h2><br>  Pengembang WAF menggunakan berbagai cara untuk memberi tahu pengguna bahwa permintaan diblokir.  Dengan demikian, kami dapat mengidentifikasi WAF dengan menganalisis respons terhadap permintaan serangan kami.  Ini biasanya disebut sebagai WAF Fingerprint.  Sidik jari dapat membantu jika WAF tidak diperbarui karena alasan tertentu (kebanyakan berlaku untuk proyek open source).  Para pengembang WAFs eksklusif merawat klien mereka dan mengimplementasikan pembaruan otomatis.  Juga, setelah kami mengidentifikasi WAF, yang ternyata diperbarui, kami masih dapat menggunakan informasi tentangnya untuk mempelajari sesuatu tentang logikanya. <br><br>  Berikut daftar kemungkinan sidik jari WAF: <br><br><ul><li>  Cookie tambahan </li><li>  Header tambahan untuk setiap respons atau permintaan </li><li>  Isi respons (jika permintaan diblokir) </li><li>  Kode respons (jika permintaan diblokir) </li><li>  Alamat IP (Cloud WAF) </li><li>  Modul sisi klien JS (Sisi klien WAF) </li></ul><br>  Mari kita ilustrasikan dengan beberapa contoh <br><br>  <b>PT AF</b> <br>  Kode respons untuk permintaan yang diblokir: 403 <br>  Dapat memasukkan modul klien waf.js ke halaman respons <br>  Tubuh tanggapan: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span>Request ID: 2017-07-31-13-59-56-72BCA33A11EC3784<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Header tambahan yang ditambahkan oleh waf.js: <br><br><pre> <code class="xml hljs">X-RequestId: cbb8ff9a-4e91-48b4-8ce6-1beddc197a30</code> </pre> <br>  <b>Nemesida waf</b> <br>  Kode respons untuk permintaan yang diblokir: 403 <br>  Tubuh tanggapan: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"font-size: 16px; align: center;"</span></span></span><span class="hljs-tag">&gt;</span></span> Suspicious activity detected. Access to the site is blocked. If you think that is's an erroneous blocking, please email us at <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"mailto:nwaf@pentestit.ru"</span></span></span><span class="hljs-tag">&gt;</span></span>nwaf@pentestit.ru<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> and specify your IP-address. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <b>Wallarm</b> <br>  Kode respons untuk permintaan yang diblokir: 403 <br>  Header tambahan: nginx-wallarm <br><br>  <b>Citrix NetScaler AppFirewall</b> <br>  Cookie tambahan: <br><br><pre> <code class="xml hljs">ns_af=31+LrS3EeEOBbxBV7AWDFIEhrn8A000; ns_af_.target.br_%2F_wat=QVNQU0VTU0lP TklEQVFRU0RDU0Nf?6IgJizHRbTRNuNoOpbBOiKRET2gA</code> </pre> <br>  <b>Mod_Security ver.</b>  <b>2.9</b> <br>  Kode respons untuk permintaan yang diblokir: 403 <br>  Badan tanggapan: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>403 Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Forbidden<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>You don't have permission to access /form.php on this server.<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag"> /&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <b>Mod_Security ver.</b>  <b>&lt;2.9</b> <br>  Kode respons untuk permintaan yang diblokir: 406 atau 501 <br>  Di badan respons, Anda dapat menemukan mod_security, Mod_Security, atau NOYB <br><br>  <b>Firewall pernis</b> <br>  Menambahkan tajuk berikut ke respons: <br><br><pre> <code class="plaintext hljs">X-Varnish: 127936309 131303037. X-Varnish: 435491096 Via: 1.1 varnish-v4</code> </pre> <br>  Pengembang WAF memutuskan sendiri kode respons mana yang akan dikembalikan jika ada permintaan yang diblokir;  ada beberapa kode spesifik juga.  Misalnya, Web_Knight WAF mengembalikan kode 999, dan dotDefender mengembalikan kode 200 dengan badan respons kosong atau dengan pesan kesalahan.  Selain itu, pengembang dapat membuat halaman respons khusus dengan beberapa konten lainnya. <br><br>  WAF, seperti aplikasi lain, berkembang dan berubah.  Itu sebabnya penting untuk terus memeriksa relevansi sidik jari yang Anda miliki. <br><br><h2>  Lembar cheat bypass WAF </h2><br>  Gagasan umum di balik menemukan cara untuk memotong WAF adalah untuk mengubah permintaan yang kami butuhkan sehingga itu masih berlaku untuk aplikasi web tetapi tidak untuk WAF atau tampaknya tidak berbahaya.  Sangat penting bagi satu jenis WAF untuk dapat melayani berbagai jenis server, termasuk yang "eksotis", seperti Unicorn, Tornado, Weblogic, Lighttpd, dll.  Setiap server dapat melihat kasus-kasus eksklusif permintaan HTTP yang diuraikan dengan cara yang berbeda, yang juga harus dipertimbangkan oleh WAF.  Dengan demikian, seorang penyerang dapat menggunakan spesifik server dari permintaan HTTP parsing untuk menemukan cara untuk memotong WAF. <br><br><img src="https://habrastorage.org/webt/59/e3/95/59e395afb9650235665851.png"><br><br>  Sulit untuk mengklasifikasikan semua cara yang mungkin untuk memotong WAF baik oleh mekanisme keamanan WAF atau oleh bidang penggunaan.  Cara memotong yang sama dapat berinteraksi dan secara simultan mempengaruhi berbagai komponen WAF.  Teknik-teknik yang dijelaskan di bawah ini dikumpulkan dari sumber terbuka atau ditemukan selama penelitian kami sendiri dan terbukti menjadi yang paling efektif. <br><br><h4>  Menambahkan simbol khusus </h4><br>  Berbagai simbol khusus dapat melanggar logika analisis WAF dan pada saat yang sama dapat ditafsirkan oleh server.  Variasi dari simbol-simbol ini mungkin berbeda: mereka dapat diubah menjadi urlencode (walaupun sebagian besar WAF dapat mengatasinya) atau pengkodean lainnya.  Dimungkinkan juga untuk memasukkan simbol khusus ke dalam permintaan tanpa pengkodean apa pun, dalam format mentah, yang mungkin mengejutkan bagi WAF.  Misalnya, <b>\ r \ n \ r \ n</b> dalam presentasi ini dapat dianggap sebagai akhir dari badan permintaan HTTP, dan null byte dapat melanggar logika analisis ekspresi reguler dan pengurai data secara bersamaan.  Juga, simbol khusus lainnya dari dua puluh simbol pertama dari tabel ASCII dapat digunakan. <br>  Contoh: <br><br><ul><li>  0x00 - Null byte; </li><li>  0x0D - Pengembalian gerbong; </li><li>  0x0A - Umpan baris; </li><li>  0x0B - Tab Vertikal; </li><li>  0x09 - Tab horizontal; </li><li>  0x0C - Halaman baru </li></ul><br>  Saat mencari bypass, sangat berguna untuk menyisipkan simbol khusus di berbagai tempat di badan permintaan dan tidak hanya ke dalam nilai parameter.  Misalnya, jika permintaan dalam format JSON, kami dapat menyisipkan NULL-byte baik ke dalam parameter maupun di antara parameter, baik di awal maupun di akhir JSON.  Hal yang sama berlaku untuk format lain dari tubuh permintaan POST.  Secara umum, kami sarankan untuk melakukan penelitian dan bersenang-senang, untuk mencari tempat yang dapat dipantau dan diuraikan oleh WAF, dan coba gunakan simbol khusus yang berbeda di sana. <br><br>  Sebagai contoh: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string0x00"</span></span>:<span class="hljs-string"><span class="hljs-string">"test' or sleep(9)#"</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>:<span class="hljs-string"><span class="hljs-string">"test'/*0x00*/ or sleep(9)#"</span></span>} {<span class="hljs-attr"><span class="hljs-attr">"id"</span></span>:<span class="hljs-number"><span class="hljs-number">1337</span></span>,<span class="hljs-attr"><span class="hljs-attr">"string"</span></span>0x0A0x0D:<span class="hljs-string"><span class="hljs-string">"test' or sleep(9)#"</span></span>}</code> </pre> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ja0x09vas0x0A0x0Dcript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0x00</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0x00</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="sql hljs">id=1337<span class="hljs-comment"><span class="hljs-comment">/*0x0C*/</span></span>1 UNION <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>() <span class="hljs-comment"><span class="hljs-comment">--</span></span></code> </pre> <br>  <i>Untuk lebih jelasnya, kami telah mengganti simbol khusus dengan presentasi hex mereka.</i> <br><br><h4>  Mengganti simbol ruang </h4><br>  Dalam kebanyakan sintaksis, kata-kata kunci dan operator harus dipisahkan, tetapi simbol spasi yang lebih disukai tidak ditentukan.  Dengan demikian, alih-alih <b>0x20</b> (Spasi) umum, Anda dapat menggunakan <b>0x0B</b> (Tab Vertikal) atau <b>0x09</b> (tab Horizontal).  Mengganti ruang dengan struktur pemisah tanpa maknanya sendiri termasuk dalam kategori yang sama.  Dalam SQL, itu adalah <b>/ ** /</b> (komentar SQL multi-baris), <b># \ r \ n</b> (komentar SQL satu-baris, diakhiri dengan umpan baris), <b>- \ r \ n</b> (alternatif komentar satu-baris SQL, berakhir dengan umpan baris).  Berikut ini beberapa contohnya: <br><br><pre> <code class="html hljs xml">http://test.com/test?id=1%09union/**/select/**/1,2,3 http://test.com/test?id=1%09union%23%0A%0Dselect%2D%2D%0A%0D1,2,3</code> </pre> <br>  Selain itu, kami dapat mengubah ekspresi untuk menghilangkan spasi menggunakan sintaks bahasa.  Misalnya, dalam SQL, kita bisa menggunakan tanda kurung: <br><br><pre> <code class="sql hljs">UNION(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>),<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,(<span class="hljs-number"><span class="hljs-number">6</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Users</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span>(login=<span class="hljs-string"><span class="hljs-string">'admin'</span></span>))</code> </pre> <br>  Dan di JS, gunakan <b>/</b> : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">confirm(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  Mengubah penyandian </h4><br>  Metode ini didasarkan pada penggunaan pengkodean yang berbeda untuk menjaga WAF dari penguraian data di tempat-tempat tertentu.  Misalnya, jika simbol diganti dengan kode-URL-nya, WAF tidak akan dapat memahami bahwa simbol harus mendekode data dan akan melewati permintaan.  Pada saat yang sama, parameter yang sama akan diterima dan berhasil diterjemahkan oleh aplikasi web. <br><br>  Bentuk desimal dari simbol HTML adalah <b>&amp; # 106</b> atau <b>&amp; # 0000106</b> .WAF mungkin tahu tentang versi pendek dan tidak tahu tentang versi dengan nol tambahan (tidak boleh ada total lebih dari 7 simbol).  Dengan cara yang sama, bentuk hex simbol HTML adalah <b>&amp; # x6A</b> atau <b>&amp; # x000006A</b> . <br><br>  Ada juga trik melarikan diri karakter dengan backslash <b>\</b> , misalnya: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on</span></span></span><span class="hljs-tag">\</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">load</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">a\lert(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Padahal, itu tergantung pada bagaimana aplikasi web memproses data input tersebut.  Jadi, urutan <b>\ l</b> akan diproses sebagai <b>l</b> dan diubah menjadi simbol tunggal;  WAF dapat memproses masing-masing simbol secara terpisah dan dapat merusak ekspresi reguler atau logika WAF lainnya.  Dengan demikian, WAF akan kehilangan kata kunci.  Dengan menggunakan teknik ini kita tidak dapat melarikan diri karakter <b>\ n</b> , <b>\ r</b> , <b>\ t</b> , karena mereka akan diubah menjadi karakter yang berbeda: baris baru, carriage return, dan tab. <br><br>  HTML-encode dapat digunakan di dalam atribut tag, misalnya: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript&amp;colon;alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onmouseover</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript&amp;colon;confirm&amp;lpar;1rpar;"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Karakter-karakter ini dapat dengan mudah diganti oleh representasi HTML lain dari karakter target.  Anda dapat melihat berbagai transformasi karakter di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Selain penyandian HTML, kami dapat menyisipkan karakter dengan <b>\ u</b> : <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javascript:\u0061lert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>Clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onload</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">confir\u006d(1)</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Mari kita juga melihat vektor yang terkait dengan memasukkan karakter khusus.  Mari pecahkan payload dengan HTML encode: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ja&amp;Tab;vas&amp;#x0000A;cript:alert(1)"</span></span></span><span class="hljs-tag">&gt;</span></span>clickme<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dalam hal ini, kita juga dapat menempatkan karakter pemisah lainnya. <br><br>  Jadi, kami menyarankan untuk menggabungkan penyandian yang berbeda dengan metode lain, misalnya, untuk menyandikan karakter khusus. <br><br><h4>  Cari struktur sintaksis setara atipikal </h4><br>  Metode ini bertujuan untuk menemukan cara eksploitasi yang tidak dipertimbangkan oleh pengembang WAF, atau vektor yang tidak ada dalam sampel pelatihan pembelajaran mesin.  Contoh sederhana adalah fungsi JavaScript: <b>ini, diri teratas, orang tua, bingkai;</b>  atribut tag: <b>data-bind, ontoggle, onfilterchange, onbeforescriptexecute, onpointerover, srcdoc;</b>  dan operator SQL: <b>lpad, bidang, bit_count</b> . <br><br>  Berikut ini beberapa contohnya: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">window</span></span></span><span class="javascript">[</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'alert'</span></span></span><span class="javascript">](</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">parent[</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'alert'</span></span></span><span class="actionscript">](</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript">self[</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'alert'</span></span></span><span class="actionscript">](</span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">2</span></span></span><span class="actionscript">)</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">LPAD</span></span>(<span class="hljs-string"><span class="hljs-string">' '</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>())=<span class="hljs-string"><span class="hljs-string">'5.7'</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>),<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre> <br>  Anda juga dapat menggunakan representasi non-simbolik dari ekspresi JavaScript: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSFuck</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jjencode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xchars.js</a> . </li></ul><br>  Masalah yang jelas dengan itu adalah payload yang panjang. <br><br>  Bypass WAF dengan teknik ini tergantung pada serangan dan tumpukan teknologi yang dieksploitasi.  Eksploitasi ImageTragick yang terkenal adalah contoh yang bagus untuk itu.  Sebagian besar WAF yang melindungi dari serangan ini memasukkan kata kunci hitam seperti <b>url</b> , <b>kapasitas</b> , dan <b>label</b> karena kata-kata tersebut disebutkan di sebagian besar makalah dan PoC yang menggambarkan kerentanan ini.  Meskipun segera terungkap bahwa kata kunci lain dapat digunakan juga, misalnya, <b>singkat</b> dan <b>pango</b> .  Akibatnya, WAF dapat dilewati dengan penggunaan kata kunci ini. <br><br><h4>  HTTP Parameter Pollution (HPP) dan HTTP Parameter Fragmentation (HPF) </h4><br>  Serangan HPP didasarkan pada bagaimana server menginterpretasikan parameter dengan nama yang sama.  Berikut beberapa kemungkinan bypass: <br><br><ul><li>  Server menggunakan parameter yang terakhir diterima, dan WAF hanya memeriksa yang pertama; </li><li>  Server menyatukan nilai dari parameter yang sama, dan WAF memeriksanya secara terpisah. </li></ul><br>  Anda dapat membandingkan bagaimana berbagai server memproses parameter yang sama dalam tabel di bawah ini: <br><br><img src="https://habrastorage.org/webt/59/e3/77/59e3770e949f3269504620.png"><br><br>  Pada gilirannya, serangan HPF didasarkan pada prinsip yang berbeda.  Jika logika aplikasi web menyatukan dua dan lebih parameter dalam permintaan, musuh dapat membagi permintaan untuk mem-bypass pemeriksaan WAF tertentu. <br>  Injeksi SQL berikut adalah contoh serangan seperti itu: <br><br><pre> <code class="html hljs xml">http://test.com/url?a=1+select&amp;b=1+from&amp;c=base</code> </pre> <br>  HPF dan HPP sangat mirip, tetapi yang pertama menargetkan aplikasi web, dan yang terakhir adalah lingkungan tempat ia beroperasi.  Menggabungkan teknik-teknik ini meningkatkan kemungkinan melewati WAF. <br><br><h4>  Normalisasi Unicode </h4><br>  Normalisasi Unicode adalah fitur Unicode yang dimaksudkan untuk membandingkan simbol Unicode yang mirip.  Misalnya, simbol <b>'ª'</b> dan <b>'ᵃ'</b> memiliki kode yang berbeda tetapi sangat mirip sebaliknya, jadi setelah normalisasi mereka berdua akan terlihat seperti <b>'a' yang</b> sederhana dan dianggap sama.  Normalisasi memungkinkan transformasi beberapa simbol Unicode kompleks menjadi alternatifnya yang lebih sederhana.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel normalisasi Unicode</a> dengan semua simbol Unicode dan kemungkinan normalisasi mereka.  Dengan menggunakannya, Anda dapat membuat berbagai muatan dan menggabungkannya dengan metode lain.  Meskipun, itu tidak berfungsi untuk semua aplikasi web dan sangat tergantung pada lingkungan. <br><br>  Sebagai contoh, pada tabel di atas, kita dapat melihat bahwa simbol <b><code>＜</code></b> dan <b><code>﹤</code></b> berubah menjadi sederhana <b><code>&lt;</code></b> .  Jika aplikasi menggunakan penyandian HTML setelah normalisasi, maka kemungkinan besar simbol yang dinormalisasi <b><code>&lt;</code></b> akan disandikan ke <b><code>&amp;lt;</code></b>  .  Namun, dalam kasus lain, pengembang mungkin mengabaikan fitur ini dan tidak menyandikan simbol Unicode.  Dengan demikian, kita mendapatkan simbol yang tidak dikodekan HTML <b>&lt;</b> dan <b>&gt;</b> , yang dapat diubah menjadi serangan XSS.  WAF mungkin mengalami kesulitan dalam memahami simbol Unicode - itu mungkin tidak memiliki aturan untuk trik seperti itu, dan pembelajaran mesin mungkin juga tidak berguna.  Saat menemukan bypass di aplikasi web dengan normalisasi Unicode, kita dapat mengganti tidak hanya <b>&lt;&gt;</b> tetapi simbol lain dari payload juga. <br><br>  Sebagai contoh: <br><br><pre> <code class="html hljs xml">＜img src﹦x onerror＝alert︵1)&gt;</code> </pre> <br>  Baru-baru ini, masalah ini ditemukan di program Rockstar BugBounty di HackerOne.  Tidak ada WAF, hanya penyaringan input pengguna yang ketat: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hackerone.com/reports/231444</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hackerone.com/reports/231389</a> <br><br><h4>  Pemecah tanda </h4><br>  Serangan pada tokenizers berusaha untuk mematahkan logika pemisahan permintaan menjadi token dengan bantuan yang disebut token breaker.  Token breakers adalah simbol yang memungkinkan memengaruhi korespondensi antara elemen string dan token tertentu, dan dengan demikian mem-bypass pencarian dengan tanda tangan.  Tetapi saat menggunakan token breaker, permintaan harus tetap valid.  Permintaan berikut adalah contoh serangan menggunakan token breaker <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span>-@<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">version</span></span>()</code> </pre> <br>  dimana <b>- @</b> adalah token breaker. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lembar chear</a> yang diakuisisi oleh mysql fuzzing dan memeriksa hasilnya di libinjection. <br><br>  Lebih lanjut tentang menemukan masalah dalam libinjection: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fuzzer lain</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fuzz untuk memotong</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara memintas libinjection</a> <br><br><h4>  Menggunakan fitur RFC </h4><br>  Dalam spesifikasi untuk protokol HTTP / 1.1 dan berbagai jenis permintaan (mis. Multipart / formulir-data), kita dapat menemukan beberapa hal aneh terkait dengan kasus batas dan trik pemrosesan header dan parameter.  Pengembang WAF sering tidak mempertimbangkan masalah seperti itu, maka WAF dapat menguraikan permintaan secara salah dan melewatkan bagian data, tempat vektor serangan disembunyikan.  Sebagian besar masalah dalam WAF terkait dengan pemrosesan multipart / formulir-data dan nilai-nilai spesifik dari parameter batas, yang menentukan batas parameter dalam permintaan tersebut.  Selain itu, pengembang server mungkin juga melakukan kesalahan dan tidak mendukung spesifikasi sepenuhnya, sehingga mungkin ada fitur tidak berdokumen dalam pengurai HTTP server. <br><br>  Dalam permintaan HTTP dengan data multi-bagian / formulir, batas parameter bertanggung jawab atas pemisahan parameter yang berbeda di badan permintaan.  Menurut RFC, batas yang ditentukan sebelumnya dengan awalan yang mengandung "-" harus diletakkan sebelum setiap parameter POST baru, sehingga server dapat membedakan parameter yang berbeda dari permintaan. <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Connection: close Content-Type: multipart/form-data; boundary=1049989664 Content-Length: 192 --1049989664 Content-Disposition: form-data; name="id" 287356 --1049989664--</code> </pre> <br>  Serangan juga dapat didasarkan pada kenyataan bahwa server dan WAF berbeda menangani situasi di mana batas dibiarkan kosong.  Menurut RFC, dalam hal ini, "-" adalah batas antara parameter.  Namun demikian, WAF dapat menggunakan parser yang tidak mempertimbangkan hal itu, dan, sebagai akibatnya, WAF akan meneruskan permintaan tersebut karena data dari parameter permintaan POST tidak akan muncul di penganalisa.  Server web dapat mengurai permintaan seperti itu tanpa masalah dan menyerahkan data untuk diproses lebih lanjut. <br>  Berikut ini beberapa contoh yang lebih menarik. <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Connection: close Content-Type: multipart/form-data; boundary= Content-Length: 192 -- Content-Disposition: form-data; name="id" 123' or sleep(20)# ----</code> </pre> <br>  Kami akan memberikan beberapa contoh yang lebih menarik dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">slide</a> oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bo0oM</a> di ZeroNights 2016 dan menjelaskannya: <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Content-Type: multipart/form-data; boundary=FIRST; Content-Type: multipart/form-data; boundary=SECOND; Content-Type: multipart/form-data; boundary=THIRD; --THIRD Content-Disposition: form-data; name=param UNION SELECT version() --THIRD--</code> </pre><br>  Dalam serangan ini, kami mencoba menentukan salah satu parameter batas yang akan diterima oleh WAF dan yang oleh server web.  Dengan demikian, jika mereka akan menerima parameter yang berbeda, dimungkinkan untuk melakukan serangan dengan menentukan batas yang WAF tidak akan lihat.  Serangan ini agak mirip HPP. <br><br><pre> <code class="plaintext hljs">POST /vuln.php HTTP/1.1 Host: test.com Content-Type: multipart/form-data; xxxboundaryxxx=FIRST; boundary=SECOND; --FIRST Content-Disposition: form-data; name=param UNION SELECT version() --FIRST--</code> </pre><br>  Serangan ini didasarkan pada asumsi bahwa ada perbedaan dalam penguraian permintaan HTTP oleh WAF dan oleh server web.  Yaitu, pengurai server web mencari entri 'batas' pertama, dan kemudian untuk simbol '=', dan hanya setelah itu mendefinisikan nilai batas.  Pengurai WAF, pada gilirannya, hanya mencari entri "boundary =" dan kemudian mendefinisikan batas.  Jika kondisi ini terpenuhi, WAF tidak akan menemukan batas dalam permintaan, dan karenanya tidak akan dapat menemukan dan menganalisis parameter.  Sebaliknya, server web akan mendapatkan permintaan dan memproses parameter.  Serangan ini juga akan bekerja sebaliknya: parser server web mencari "boundary =", dan parser WAF hanya mencari 'batas'.  Dalam hal ini, kita hanya perlu mengubah batas nyata dari PERTAMA ke DETIK. <br><br><pre> <code class="plaintext hljs">POST /somepage.php HTTP/1.1 Host: test.com Content-Type: multipart/form-data; boundary=Test0x00othertext; --Test Content-Disposition: form-data; name=param Attack --Test--</code> </pre><br>  Serangan ini juga menggunakan karakter khusus.  Pada parameter batas, kami menambahkan NULL-byte sehingga server web akan memotongnya, tetapi WAF akan menerimanya secara penuh.  Dalam hal ini, WAF tidak dapat menganalisis parameter karena tidak dapat menemukan batasannya. <br><br><h4>  Melewati pembelajaran mesin </h4><br>  Logikanya sederhana: kita harus menyusun serangan yang akan memenuhi parameter model statistik terlatih.  Tapi itu sangat tergantung pada bagaimana WAF dilatih dan model pelatihan apa yang digunakan.  Terkadang mungkin untuk menemukan celah, dan terkadang tidak.  Biasanya, pada tahap implementasi, WAF dengan pembelajaran mesin membutuhkan pelatihan tambahan berdasarkan permintaan ke aplikasi web klien.  Itu menimbulkan masalah bagi pentester: parameter yang mirip dan tidak banyak berubah dari permintaan ke permintaan tidak dapat diuji, karena setiap penyimpangan dari bentuk parameter biasa akan dianggap sebagai anomali.  Katakanlah cara memiliki permintaan ke <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">api.test.com/getuser?id=123</a></b> .  Parameter id selalu numerik, dan itu numerik dalam sampel pelatihan.  Jika modul pembelajaran mesin menemukan sesuatu selain angka dalam parameter ini, kemungkinan besar akan memutuskan bahwa itu adalah anomali.  Contoh lain: misalkan WAF dilatih untuk mengklasifikasikan permintaan POST ke <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">api.test.com/setMarkDown</a></b> dengan parameter POST yang memiliki teks penurunan harga.  Jelas, mungkin ada tanda kutip, simbol khusus, dan pada dasarnya apa pun yang ada di bawah.  Dalam hal ini, jauh lebih mudah untuk mem-bypass modul pembelajaran mesin karena WAF mentoleransi kutipan dan simbol khusus. <br><br>  Selain itu, pada contoh dari praktik kami, kami akan menunjukkan bahwa itu tidak selalu sejauh modul pembelajaran mesin karena masalah dengan penguraian parameter yang disebabkan oleh metode memotong yang dijelaskan di atas. <br><br>  Secara umum, kami harus mempertimbangkan secara spesifik permintaan yang diuji dan parameternya, mengandaikan opsi yang memungkinkan dari nilai parameter, yang WAF mungkin toleran terhadapnya, dan membangunnya. <br><br><h4>  Kapan WAF tidak berguna? </h4><br>  WAF menganalisis permintaan dan mencari perilaku aneh di dalamnya, tetapi ada beberapa kelas kerentanan yang tidak dapat ditemukan.  Misalnya, kerentanan logika, yang tidak memiliki anomali tetapi memiliki beberapa tindakan yang mengganggu logika aplikasi web.  Kemungkinan besar, WAF juga tidak berguna jika kondisi ras, IDOR, dan otentikasi pengguna tidak aman. <br><br><h4>  Utilitas yang ada </h4><br>  Ada beberapa alat otomatis untuk menemukan bypass WAF, yang ditulis oleh para penggemar di bidang ini.  Inilah yang paling terkenal dan layak: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lightbulb-framework</a> - seluruh kerangka kerja untuk menguji aplikasi web yang dilindungi dengan WAF.  Ini ditulis dengan Python dan juga porting sebagai plugin untuk Burp Suite.  Fitur utamanya adalah dua algoritma ini: <br><br><ul><li>  GOFA - algoritma pembelajaran mesin aktif yang memungkinkan menganalisis penyaringan dan sanitasi parameter di aplikasi web. </li><li>  SFADiff - algoritma pengujian kotak hitam deferential, berdasarkan pelatihan dengan automate terbatas simbolik (SFA).  Ini memungkinkan menemukan perbedaan dalam perilaku aplikasi web yang membantu mengidentifikasi WAF dan menemukan bypass. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bypass WAF</a> - sebuah plugin untuk Burp Suite, yang memungkinkan pengaturan perubahan elemen secara otomatis di tubuh permintaan sesuai dengan aturan yang berbeda dan penyandian perubahan.  Itu juga dapat mengotomatiskan serangan HPP. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAFW00F</a> - alat untuk identifikasi WAF, ditulis dengan Python.  Ini memiliki basis WAF yang layak dan masih diperbarui.  Meskipun, hasilnya mungkin tidak tepat karena banyak WAF diperbarui lebih sering daripada proyek itu sendiri. <br><br><h2>  Memotong waf dalam praktik </h2><br><img src="https://habrastorage.org/webt/59/e4/fc/59e4fc4eee061363676501.png"><br><br>  Kami telah menjalankan uji penetrasi toko online, yang dilindungi oleh <b>PT AF</b> (Positive Technologies Application Firewall).  Sulit menemukan titik lemah, yang bisa menjadi basis untuk memotong.  Namun segera kami menemukan perilaku yang tidak biasa di sisi aplikasi web, yang tidak difilter oleh WAF.  Anomali itu ditemukan dalam pencarian dalam sejarah barang yang dibeli.  Permintaan dikirim dalam format JSON dan terlihat seperti itu: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"request"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-attr"><span class="hljs-attr">"Offset"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"ItemName"</span></span>:<span class="hljs-string"><span class="hljs-string">"Phone"</span></span>}}</code> </pre> <br>  Kami menempatkan <b>Telepon '</b> dan <b>Telepon' + '</b> , nilai ke dalam parameter <b>ItemName</b> dan menemukan bahwa server mengembalikan respons yang berbeda untuk dua permintaan ini.  Dalam kasus pertama, responsnya kosong;  dalam kasus kedua, itu berisi data tentang barang lain dengan kata <b>Phone</b> dalam nama mereka, seolah-olah parameter <b>ItemName</b> memiliki <b>Telepon</b> sebagai nilainya.  Perilaku semacam ini sangat dikenal di kalangan peretas dan pentester dan menunjuk ke masalah aplikasi dengan penyaringan input pengguna, yang mengarah ke injeksi SQL antara lain. <br><br>  Mari kita lihat mengapa ini terjadi dengan contoh injeksi SQL.  Jika perilaku seperti itu ditemukan dalam aplikasi web, maka sangat mungkin bahwa data untuk permintaan SQL sesuai dengan permintaan itu sendiri.  Dalam kasus pertama, dengan parameter <b>Phone '</b> , kita akan memiliki kueri SQL berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item_name=<span class="hljs-string"><span class="hljs-string">'Phone''</span></span></code> </pre> <br>  Jelas, itu tidak akan dieksekusi karena sintaks yang salah dan tidak akan mengembalikan hasil apa pun.  Permintaan kedua, dengan parameter <b>Ponsel '+'</b> , akan terlihat seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item_name=<span class="hljs-string"><span class="hljs-string">'Phone'</span></span>+<span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre> <br>  Sintaksnya benar, sehingga akan memilih barang dengan nama <b>Telepon</b> .  Metode mendeteksi kerentanan ini memiliki keuntungan besar saat menguji aplikasi web yang dilindungi oleh WAF.  Simbol kutipan tunggal tidak dianggap sebagai anomali yang cukup dalam suatu parameter oleh sebagian besar WAF modern, sehingga mereka menyampaikan permintaan dengannya. <br><br>  Kami telah menjelaskan deteksi kerentanan, tetapi bagaimana dengan melewati WAF dan mengeksploitasi kerentanan?  Setelah melewati beberapa bypass, kami menemukan masalah di WAF.  Ternyata WAF ini rentan terhadap karakter khusus yang ditambahkan ke parameter JSON.  Bahkan, jika kita menambahkan simbol JSON <b>0x0A, 0x0D</b> (\ r \ n atau carrige reutrn dan baris baru) dalam format mentah, tanpa pengkodean apa pun, ke bidang teks apa pun, WAF akan meneruskannya, dan aplikasi web akan mempertimbangkannya untuk menjadi benar dan memprosesnya.  Kemungkinan besar, masalahnya adalah di parser JSON, yang tidak dibuat untuk simbol khusus dan diurai JSON sampai tempat di mana simbol-simbol ini akan muncul.  Dengan demikian, penganalisa WAF tidak akan mendapatkan permintaan penuh, jadi kami dapat memasukkan vektor serangan apa pun setelah karakter khusus.  Selain jeda baris, karakter lain (misalnya NULL-byte) juga akan berfungsi.  Sebagai hasilnya, kami dapat menulis permintaan berikut, yang akan mematikan WAF ketika mencoba memeriksa permintaan ini (penghentian baris dan carriage return digantikan dengan representasi tekstual mereka): <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"request"</span></span>:{<span class="hljs-attr"><span class="hljs-attr">"kill-waf"</span></span>:<span class="hljs-string"><span class="hljs-string">"die0x0A0x0D"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Count"</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-attr"><span class="hljs-attr">"Offset"</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-attr"><span class="hljs-attr">"ItemName"</span></span>:[<span class="hljs-string"><span class="hljs-string">"'+(SELECT 'Phone'+CHAR(ASCII(substring(@@version,1,1))-24))+'"</span></span>]}}</code> </pre> <br>  <i>0x0A dan 0x0D adalah byte mentah.</i> <br><br>  Dengan demikian, kami dapat dengan mudah dan cepat menguji semua parameter untuk kerentanan apa pun (beberapa di antaranya ditemukan di parameter lain).  Memotong WAF dan mengeksploitasi injeksi ini memungkinkan kami untuk benar-benar membahayakan semua pengguna aplikasi web. <br><br>  Masalah yang sama juga ditemukan di <b>Nemesida WAF</b> .  Satu-satunya perbedaan adalah, permintaan itu tidak dalam pengkodean JSON, tapi itu adalah permintaan POST biasa dengan parameter, dan parameter disatukan dengan permintaan SQL sebagai angka.  Jika beberapa simbol ditempatkan dalam permintaan dalam url-encode, misalnya, <b>% 03% 04</b> lalu WAF memblokir permintaan, tetapi jika simbol ditempatkan dalam bentuk mentah tanpa pengkodean url maka WAF mengabaikan permintaan ini.  Perlu dicatat, bahwa ekspresi-SQL normal ditempatkan untuk meminta serta dalam WAF sebelumnya.  Ekspresi SQL sederhana <b>'UNION SELECT'</b> tanpa kebingungan tambahan, yang berarti bahwa WAF tidak bisa menguraikan permintaan dengan benar dan meneruskan analisis lebih lanjut.  Tetapi ada satu masalah - bagaimana cara membuat sintaks SQL-query benar?  Karena menggunakan karakter khusus seperti <b>% 03% 04</b> di SQL-query tidak benar.  Jawabannya sederhana - kita hanya perlu menggunakan komentar / ** /.  Jadi, permintaan hasil tampak seperti: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*0x03 0x04*/</span></span>1 UNION <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>() <span class="hljs-comment"><span class="hljs-comment">--</span></span></code> </pre> <br>  <i>0x03 dan 0x04 adalah byte mentah.</i> <br><br>  Juga, masalah lain ditemukan di Nemesida WAF.  Itu terkait dengan pemrosesan yang salah dari permintaan POST dengan multipart / formulir-data.  Seperti yang kami jelaskan di bawah ini, dalam permintaan HTTP dengan multipart / form-data, <b>batas</b> parameter bertanggung jawab atas pemisahan parameter yang berbeda di badan permintaan.  Menurut RFC, batas yang ditentukan sebelumnya dengan awalan yang mengandung <b>"-"</b> harus diletakkan sebelum setiap parameter POST baru, sehingga server dapat membedakan parameter yang berbeda dari permintaan. <br>  Jadi, masalahnya adalah bahwa server dan WAF menangani situasi secara berbeda ketika parameter batas kosong.  Berdasarkan RFC, dalam situasi seperti itu batas antara parameter akan menjadi urutan karakter <b>"-"</b> .  Namun, WAF menggunakan parser yang tidak memperhitungkan fitur ini, itulah sebabnya WAF sekali lagi meneruskan permintaan, karena data dari parameter permintaan POST tidak masuk ke modul penganalisa, dan server mem-parsing situasi ini tanpa masalah dan mentransfer data lebih lanjut ke pemrosesan.  Ini adalah contoh permintaan untuk serangan ini: <br><br><pre> <code class="plaintext hljs">POST /wp-content/plugins/answer-my-question/modal.php HTTP/1.1 Host: example.com Content-Type: multipart/form-data; boundary= Content-Length: 209 -- Content-Disposition: form-data; name="id" 1 UNION SELECT 1,2,3,CONVERT(version() USING utf8) AS name,CONVERT(user() USING utf8) AS name,6,7,8,9,10,11,12 FROM wp_users WHERE id=1 ----</code> </pre><br>  Kedua masalah itu dilaporkan ke Pentestit, orang-orang membayar hadiah untuk program karunia bug mereka untuk Nemesida WAF, dan memperbaiki masalah sesegera mungkin.  Terima kasih untuk itu. <br><br>  Seperti yang bisa kita lihat, WAF mungkin modern dan cerdas, tetapi kadang-kadang dimungkinkan untuk memotongnya hanya dengan menambahkan satu karakter khusus.  Hari ini kita tidak dapat melihat semua jenis input data yang mungkin untuk semua server pada tahap pengembangan, dan pembelajaran mesin, dilaksanakan untuk melakukan hal itu, menemukan parser yang terjebak dengan karakter khusus. <br><br><h2>  Kesimpulan </h2><br><img align="left" src="https://habrastorage.org/webt/59/e5/54/59e55464f2331285132470.png">  Jadi, haruskah kita sepenuhnya mengandalkan WAF?  <b>Jawabannya adalah TIDAK.</b> <br><br>  Dalam salah satu audit kami, kami telah menemukan bypass WAF yang memungkinkan kami untuk mengeksploitasi beberapa kerentanan.  Ternyata, para pengembang sudah melakukan audit aplikasi web, sebelum dilindungi oleh WAF, dan itu mengungkapkan kerentanan yang sama.  Alih-alih memperbaikinya, mereka memutuskan untuk membeli WAF modern yang dilengkapi dengan pembelajaran mesin.  Sangat disayangkan bahwa vendor WAF tidak bersikeras untuk memperbaiki kerentanan terlebih dahulu;  atau mungkin para pengembang sendiri berpikir bahwa WAF akan menjadi pilihan yang lebih baik.  Kami tidak tahu pasti.  Either way, ini adalah contoh praktik yang sangat buruk, pada bagian dari pengembang dan vendor.  Perlu juga dicatat bahwa pembelajaran mesin masih berupa kotak hitam dan lebih mirip alat pemasaran daripada pertahanan nyata. <br><br>  Secara umum, WAF adalah solusi keamanan modern, dan tidak ada salahnya dengan aplikasi web Anda.  Meskipun saat ini, itu hanya dapat menghambat proses pencarian kerentanan dan eksploitasi, tetapi tidak dapat melindungi mereka sama sekali.  Sudah barang tentu, ini adalah keadaan seni untuk sementara waktu.  Kerentanan dalam aplikasi web hanya dapat diperbaiki dengan memperbaiki kode yang terkait dengannya, dan itulah satu-satunya solusi yang sangat mudah. <br><br>  <b>Kontributor</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ilia Bulatov</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">barracud4</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Denis Rybin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">thefaeriedragon</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Romanov</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">web_rock</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454592/">https://habr.com/ru/post/id454592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454582/index.html">Haruskah panjang array disimpan ke variabel lokal di C #?</a></li>
<li><a href="../id454584/index.html">Sekolah pengembangan antarmuka: analisis tugas untuk Minsk dan perangkat baru di Moskow</a></li>
<li><a href="../id454586/index.html">Memecahkan Teka-Teki Silang Jepang dengan P̶y̶t̶h̶o̶̶n̶ Rust dan WebAssembly</a></li>
<li><a href="../id454588/index.html">Gazprom Neft mengundang Anda untuk mengunjungi: GPN Data Science Meetup</a></li>
<li><a href="../id454590/index.html">Zimbra Collaboration Suite dan Kontrol Seluler dengan ABQ</a></li>
<li><a href="../id454596/index.html">Model mental dalam keamanan informasi</a></li>
<li><a href="../id454598/index.html">Arsitektur tanpa server dan layanan mikro: pasangan sempurna?</a></li>
<li><a href="../id454600/index.html">Bagaimana kami membuat kesepakatan yang aman pada Freelansim: memberikan pilihan, memotong fitur, membandingkan komisi</a></li>
<li><a href="../id454604/index.html">Membuat Aplikasi Bereaksi dengan Backend GraphQL dalam Menit</a></li>
<li><a href="../id454606/index.html">Fitur dari atribut inputmode untuk OS dan browser seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>