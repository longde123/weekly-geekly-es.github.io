<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😩 🧒🏽 👩🏽‍⚕️ Container für Erwachsene (Teil 01): Ein praktischer Leitfaden zur Terminologie 🙋 🥧 👩🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie fragen sich vielleicht, warum Sie sich mit Terminologie befassen sollten, wenn das Konzept der Container recht einfach und unkompliziert aussieht....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Container für Erwachsene (Teil 01): Ein praktischer Leitfaden zur Terminologie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  Sie fragen sich vielleicht, warum Sie sich mit Terminologie befassen sollten, wenn das Konzept der Container recht einfach und unkompliziert aussieht.  Die falsche Verwendung von Begriffen behindert jedoch häufig die Entwicklung von Containern.  Beispielsweise denken die Leute oft, dass die Begriffe „Container“ und „Bilder“ synonym verwendet werden, obwohl es tatsächlich wichtige konzeptionelle Unterschiede zwischen ihnen gibt.  Ein weiteres Beispiel: In der Containerwelt bedeutet ein „Repository“ nicht, was Sie denken.  Darüber hinaus ist die Containertechnologie viel mehr als nur ein Docker. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Ohne Kenntnis der Terminologie wird es schwierig sein zu verstehen, wie sich Docker von CRI-O, rkt oder lxc / lxd unterscheidet.  oder bewerten Sie die Rolle der Open Container Initiative bei der Standardisierung von Containertechnologien. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Der Einstieg in Linux-Container ist sehr einfach, aber es stellt sich bald heraus, dass diese Einfachheit irreführend ist.  Dies geschieht normalerweise folgendermaßen: Nachdem Sie nur ein paar Minuten mit der Installation eines Dockers oder einer anderen Container-Engine verbracht haben, geben Sie bereits Ihre ersten Befehle ein.  Nur ein paar Minuten - und Sie haben bereits Ihr erstes Bild des Containers erstellt und öffentlich zugänglich gemacht.  Dann wechseln Sie gewöhnlich zur Architektur der Produktionsumgebung, und plötzlich wird Ihnen klar, dass Sie sich dafür zunächst mit der Masse der Begriffe und Technologien befassen müssen, die dahinter stehen.  Schlimmer noch, viele der unten aufgeführten Begriffe werden synonym verwendet, was für Anfänger viel Verwirrung stiftet. <br><br><ul><li>  Behälter </li><li>  Bild </li><li>  Behälterbild </li><li>  Bildebene </li><li>  Registrierung </li><li>  Repository </li><li>  Tag </li><li>  Basisbild </li><li>  Plattformbild </li><li>  Schicht </li></ul><br>  Wenn Sie die in diesem Dokument beschriebene Terminologie beherrschen, werden Sie die technologischen Grundlagen von Containern besser verstehen.  Darüber hinaus können Sie und Ihre Kollegen dieselbe Sprache sprechen und die Architektur von Containerumgebungen bewusst und zielgerichtet gemäß den Besonderheiten der zu lösenden Aufgaben gestalten.  Aus Sicht der IT-Community und der gesamten Branche trägt eine allgemeine Verbesserung des Verständnisses der Containertechnologien wiederum zur Entstehung neuer Architekturen und Lösungen bei.  Beachten Sie, dass dieser Artikel für Leser gedacht ist, die bereits eine Vorstellung davon haben, wie Container ausgeführt werden. <br><br><h3>  Container: Grundlagen </h3><br>  Bevor wir mit der Terminologie von Containern fortfahren, werden wir bestimmen, was tatsächlich der Container selbst ist.  Der Begriff "Container" bedeutet zwei Dinge gleichzeitig.  Wie ein normales Linux-Programm kann sich ein Container in einem von zwei Zuständen befinden: funktionierend und nicht funktionierend.  Im Ruhezustand ist der Container eine Datei oder eine Reihe von Dateien, die auf der Festplatte gespeichert sind.  In diesem Zustand beziehen sich die Begriffe Container Image und Container Repository.  Wenn Sie den Befehl zum Starten des Containers eingeben, entpackt die Container-Engine die erforderlichen Dateien und Metadaten und überträgt sie an den Linux-Kernel.  Das Starten eines Containers ist dem Starten eines regulären Linux-Prozesses sehr ähnlich und erfordert einen API-Aufruf des Linux-Kernels.  Dieser API-Aufruf initiiert normalerweise eine zusätzliche Isolation und stellt eine Kopie der Dateien bereit, die sich im Container-Image befinden.  Nach dem Start des Containers handelt es sich nur um einen Linux-Prozess.  Das Verfahren zum Starten von Containern sowie das Format der Bilder von Containern, die auf der Festplatte gespeichert sind, werden durch Standards definiert und geregelt. <br><br>  Es gibt verschiedene Formate für Container-Images ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LXD</a> ), aber die Branche bewegt sich allmählich in Richtung eines einzigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Container Initiative-</a> Standards, der manchmal als Open Containers oder einfach als OCI bezeichnet wird.  Dieser Standard definiert die <a href="">Spezifikation des Container-Image-Formats</a> , das das Festplattenformat zum Speichern von Container-Images definiert, sowie Metadaten, die wiederum Dinge wie die Hardwarearchitektur und das Betriebssystem (Linux, Windows usw.) definieren.  Ein einziges branchenübliches Bildformat ist der Schlüssel zur Schaffung eines Software-Ökosystems, mit dem Entwickler, Open Source-Projekte und Softwareanbieter kompatible Bilder und verschiedene Tools wie elektronische Signatur, Scannen, Zusammenstellen, Starten, Verschieben und Verwalten von Container-Bildern erstellen können. <br><br>  Darüber hinaus gibt es mehrere Containermotoren wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LXC</a> .  Die Containermaschine nimmt ein Bild des Containers auf und verwandelt ihn in einen Container (d. H. Ein laufenden Prozess).  Der Konvertierungsprozess wird auch durch den OCI-Standard definiert, der eine Container-Laufzeitspezifikation und eine Laufzeitreferenzimplementierung namens RunC enthält, ein Open-Source-Modell, das von der entsprechenden Entwicklergemeinschaft reguliert wird.  Viele Container-Engines verwenden dieses Modell, um beim Erstellen von Containern mit dem Host-Kernel zu interagieren. <br><br>  Tools, die die Spezifikationen des <a href="">Container-Image-Formats</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Container-Ausführungsumgebung des</a> OCI-Standards unterstützen, bieten Portabilität innerhalb des Ökosystems verschiedener Container-Plattformen, Container-Engines und unterstützender Tools auf verschiedenen Cloud-Plattformen und lokalen Architekturen.  Wenn Sie die Terminologie, Standards und Architektur von Containersystemen kennen, können Sie fruchtbar mit anderen Spezialisten kommunizieren und skalierbare und unterstützte containerisierte Anwendungen und Umgebungen entwerfen, die die effiziente Nutzung von Containern über Jahre hinweg sicherstellen. <br><br><h3>  Grundwortschatz </h3><br><h4>  Containerbild </h4><br>  In der einfachsten Definition ist ein Container-Image eine Datei, die vom Registrierungsserver heruntergeladen und beim Starten des Containers lokal als Einhängepunkt verwendet wird.  Trotz der Tatsache, dass der Begriff „Container-Image“ häufig verwendet wird, kann er verschiedene Bedeutungen haben.  Tatsache ist, dass Docker, RKT und sogar LXD zwar nach dem eben beschriebenen Prinzip arbeiten, dh gelöschte Dateien herunterladen und als Container ausführen. Jede dieser Technologien interpretiert das Container-Image auf ihre eigene Weise.  LXD arbeitet mit monolithischen (einschichtigen) Bildern, während Docker und RKT OCI-Bilder verwenden, die mehrere Schichten enthalten können. <br><br>  Genau genommen ist ein Container-Image auf einem Registrierungsserver weit von einer einzelnen Datei entfernt.  Wenn Benutzer den Begriff „Container-Image“ verwenden, meinen sie häufig das Repository und eine Reihe mehrerer Ebenen des Container-Images sowie Metadaten, die zusätzliche Informationen zu diesen Ebenen enthalten. <br><br>  Darüber hinaus impliziert das Konzept eines Containerbildes implizit die Existenz eines Formats für ein solches Bild. <br><br><h4>  Container-Bildformat </h4><br>  Anfänglich hatte jede Container-Engine, einschließlich LXD, RKT und Docker, ein eigenes Bildformat.  Einige dieser Formate erlauben nur eine Ebene, während andere eine Baumstruktur aus mehreren Ebenen unterstützen.  Heutzutage haben fast alle wichtigen Container-Tools und Engines auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCI-</a> Format umgestellt, das festlegt, wie Ebenen und Metadaten im Container-Image angeordnet werden sollen.  Im Wesentlichen definiert das OCI-Format ein Container-Image, das aus separaten TAR-Dateien für jede Ebene und einer gemeinsamen manifest.json-Datei mit Metadaten besteht. <br><br>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Container Initiative (OCI)</a> -Standard, der ursprünglich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Docker V2-Bildformat</a> basierte, hat ein großes Ökosystem von Container-Engines, Cloud-Plattformen und -Tools (Sicherheitsscanner, Signiertools, Erstellen und Verschieben von Containern) erfolgreich kombiniert und ermöglicht es Ihnen, Ihre Investitionen in Wissen und Wissen zu schützen Werkzeuge. <br><br><h4>  Containermotor </h4><br>  Die Container-Engine ist der Teil der Software, der Benutzeranforderungen einschließlich Befehlszeilenparametern akzeptiert, Bilder herunterlädt und aus Sicht des Endbenutzers Container startet.  Es gibt viele Container-Engines, darunter Docker, RKT, CRI-O und LXD.  Darüber hinaus verfügen viele Cloud-Plattformen, PaaS-Dienste und Container-Plattformen über eigene Engines, die Bilder im Docker- oder OCI-Format verstehen.  Ein Industriestandard für das Bildformat gewährleistet die Interoperabilität all dieser Plattformen. <br><br>  Wenn wir eine Ebene tiefer gehen, können wir sagen, dass die meisten Container-Engines Container nicht selbst starten, sondern über eine OCI-kompatible Laufzeit wie runc.  In der Regel führt eine Container-Laufzeit die folgenden Aktionen aus: <br><br><ul><li>  Behandelt Parameter, Benutzereingaben </li><li>  Behandelt die über die API übergebenen Parameter (meistens das Container-Orchestrierungssystem) </li><li>  Laden Sie Container-Images vom Registrierungsserver herunter </li><li>  Entpackt und speichert das Container-Image mithilfe des Grafiktreibers (Block oder Datei, je nach Treiber) auf der Festplatte. </li><li>  Bereitet einen Einhängepunkt für den Container vor, normalerweise im Copy-on-Write-Speicher (wiederum Block oder Datei, je nach Treiber) </li><li>  Bereitet Metadaten vor, die an die Laufzeit übergeben werden, um den Container korrekt auszuführen: <br><ul><li>  Spezifische Standardeinstellungen, die für das Container-Image impliziert sind (z. B. <a href="">ArchX86</a> ) </li><li>  Benutzereingabe zum Überschreiben der im Container-Image enthaltenen Standardwerte (z. B. CMD, ENTRYPOINT) </li><li>  Vom Container-Image angegebene Standardparameter (z. B. <a href="">SECCOM-</a> Regeln) </li></ul></li><li>  Ruft die Container-Laufzeit auf </li></ul><br><h4>  Behälter </h4><br>  Container gibt es in Betriebssystemen schon seit geraumer Zeit, da dies nur eine laufende Instanz eines Container-Images ist.  Ein Container ist ein Standard-Linux-Prozess, der normalerweise mit dem Systemaufruf clone () anstelle von fork () oder exec () erstellt wird.  Darüber hinaus werden häufig zusätzliche Isolierungsmaßnahmen auf Container angewendet, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SELinux</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppArmor verwenden</a> . <br><br><h4>  Container-Host </h4><br>  Ein Container-Host ist ein System, auf dem containerisierte Prozesse ausgeführt werden, die der Einfachheit halber häufig als Container bezeichnet werden.  Dies kann beispielsweise eine virtuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RHEL Atomic Host-</a> Maschine sein, die sich in einer öffentlichen Cloud befindet oder in einem Unternehmens-Rechenzentrum auf Bare-Metal-Basis ausgeführt wird.  Wenn das Container-Image (mit anderen Worten das Repository) vom Registrierungsserver auf den lokalen Container-Host heruntergeladen wird, heißt es, dass es in den lokalen Cache fällt. <br><br>  Mit dem folgenden Befehl können Sie bestimmen, welche Repositorys mit dem lokalen Cache synchronisiert werden: <br><br><pre>  [root @ rhel7 ~] # Docker-Bilder -a<font></font>
<font></font>
 REPOSITORY TAG IMAGE ID ERSTELLTE VIRTUELLE GRÖSSE
 registry.access.redhat.com/rhel7 aktuell 6883d5422f4e vor 3 Wochen 201.7 MB </pre><br><h4>  Registrierungsserver </h4><br>  Ein Registrierungsserver ist im Wesentlichen ein Dateiserver, auf dem Docker-Repositorys gespeichert werden.  In der Regel wird der Registrierungsserver durch den DNS-Namen und optional die Portnummer angegeben.  Die meisten Vorteile des Docker-Ökosystems beruhen auf der Möglichkeit, Repositorys herunterzuladen und auf Registrierungsserver hochzuladen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Wenn der Docker-Daemon keine Kopie des Repositorys im lokalen Cache findet, lädt er diese automatisch vom Registrierungsserver herunter.  Bei den meisten Linux-Distributionen verwendet der Docker-Daemon die docker.io-Site dafür, bei einigen Distributionen kann sie jedoch auf eigene Weise konfiguriert werden.  Beispielsweise versucht Red Hat Enterprise Linux zuerst, von registry.access.redhat.com und erst dann von docker.io (Docker Hub) herunterzuladen. <br><br>  Hier muss betont werden, dass der Registrierungsserver implizit als vertrauenswürdig gilt.  Daher müssen Sie entscheiden, wie sehr Sie dem Inhalt einer Registrierung vertrauen und ihn zulassen bzw. ablehnen.  Neben der Sicherheit sollten noch weitere Aspekte im Voraus behandelt werden, z. B. Probleme mit der Softwarelizenzierung oder die Überwachung der Einhaltung von Vorschriften.  Die Einfachheit, mit der Docker Benutzern das Herunterladen von Software ermöglicht, macht das Thema Vertrauen äußerst wichtig. <br><br>  Mit Red Hat Enterprise Linux können Sie die Standard-Docker-Registrierung konfigurieren.  Darüber hinaus können Sie mit RHEL7 und RHEL7 Atomic Registrierungsserver über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konfigurationsdatei</a> hinzufügen oder sperren: <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 und RHEL 7 Atomic verwenden standardmäßig den Red Hat-Registrierungsserver: <br><br><pre>  ADD_REGISTRY = '- add-registry registry.access.redhat.com'
</pre><br>  In einigen Fällen ist es aus Sicherheitsgründen sinnvoll, öffentliche Docker-Register wie DockerHub zu blockieren: <br><br><pre>  # BLOCK_REGISTRY = '- Blockregistrierung'
</pre><br>  Red Hat bietet auch seinen integrierten Registrierungsserver als Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenShift Container Platform</a> sowie den eigenständigen Unternehmensregistrierungsserver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quay Enterprise</a> und Cloud-, private und öffentliche Repositorys <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quay.io an.</a> <br><br><h4>  Container-Orchestrierung </h4><br>  Normalerweise installieren die Benutzer zunächst einen Container-Host und laden zunächst nur die benötigten Container-Images herunter.  Anschließend erstellen sie ihre eigenen Bilder und laden sie auf den Registrierungsserver hoch, um sie dem Rest des Teams zur Verfügung zu stellen.  Nach einiger Zeit müssen mehrere Container kombiniert werden, damit sie als eine Einheit bereitgestellt werden können.  Und schließlich müssen diese Einheiten irgendwann Teil des Produktionsförderers sein (Entwicklungs-QS-Produktion).  Auf diese Weise stellen die Menschen normalerweise fest, dass sie ein Orchestrierungssystem benötigen. <br><br>  <b>Das Container-Orchestrierungssystem implementiert nur zwei Dinge:</b> <br><br><ol><li>  Containerladungen dynamisch über Clustercomputer verteilen (dies wird häufig als „verteiltes Computing“ bezeichnet) </li><li>  Bietet eine Standard-Anwendungsbeschreibungsdatei (kube yaml, docker compose usw.) </li></ol><br>  Diese beiden Dinge bieten tatsächlich eine Reihe von Vorteilen: <br><br><ol><li>  Die Möglichkeit, die Container, aus denen die Anwendung besteht, unabhängig voneinander zu verwalten, sodass Sie die folgenden Aufgaben effektiv lösen können: <br><ul><li>  Entsorgung großer Container-Host-Cluster </li><li>  Fehler auf der Ebene einzelner Container (nicht mehr reagierende Prozesse, Speicherauslastung) </li><li>  Failover auf Container-Host-Ebene (Laufwerke, Netzwerk, Neustart) </li><li>  Failover auf Containermotorebene (Beschädigung, Neustart) </li><li>  Individuelle Skalierung von Containern nach oben und unten </li></ul></li><li>  Einfache Bereitstellung neuer Instanzen derselben Anwendung in neuen Umgebungen, sowohl in der Cloud als auch in herkömmlichen Umgebungen, zum Beispiel: <br><ul><li>  Auf Entwicklercomputern, die von einem Orchestrierungssystem gesteuert werden </li><li>  In einer gemeinsam genutzten Entwicklungsumgebung in einem privaten Namespace </li><li>  In einer gemeinsamen Entwicklungsumgebung in einem internen öffentlichen Namespace, um Transparenz und Testleistung sicherzustellen </li><li>  In der internen Umgebung der Qualitätssicherung </li><li>  In einer Testladeumgebung, die dynamisch in der Cloud bereitgestellt und widerrufen wird </li><li>  In einer Referenzumgebung, um die Kompatibilität mit der Produktionsumgebung zu überprüfen </li><li>  In der Produktionsumgebung </li><li>  In einer Disaster Recovery-Umgebung </li><li>  In einer neuen Produktionsumgebung mit aktualisierten Container-Hosts, Container-Engines oder Orchestrierungs-Tools </li><li>  In der neuen Produktionsumgebung, die sich nicht von der Hauptumgebung unterscheidet, sondern sich in einer anderen Region befindet </li></ul></li></ol><br>  Open Source-Communities und Softwareanbieter bieten viele verschiedene Orchestrierungswerkzeuge an.  Zu den drei großen dieser Tools gehörten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ursprünglich</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesos</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> . Heute ist Kubernetes jedoch zum Industriestandard geworden, da sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesosphere</a> ihre Unterstützung angekündigt haben, ganz zu schweigen von fast allen großen Dienstleistern.  Wenn Sie jedoch nach einem Corporate Orchestration-System suchen, empfehlen wir Ihnen, sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat OpenShift</a> genauer anzusehen. <br><br><h3>  Erweitertes Wörterbuch </h3><br><h4>  Container-Laufzeit </h4><br>  Die Container-Laufzeit ist eine Low-Level-Komponente, die normalerweise als Teil einer Container-Engine verwendet wird, aber auch manuell zum Testen von Containern verwendet werden kann.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der OCI-Standard</a> definiert eine Referenzimplementierung der als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">runc bezeichneten</a> Laufzeit.  Dies ist die am weitesten verbreitete Implementierung, es gibt jedoch auch andere OCI-kompatible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufzeiten</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Triebwagen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Katacontainer</a> .  Docker, CRI-O und viele andere Container-Engines verwenden runc. <br><br>  Die Container-Laufzeit ist für folgende Dinge verantwortlich: <br><br><ul><li>  Ruft den Einhängepunkt des Containers ab, der von der Container-Engine bereitgestellt wird (zum Testen kann es sich nur um ein Verzeichnis handeln). </li><li>  Ruft die von der Container-Engine bereitgestellten Container-Metadaten ab (beim Testen kann es sich um eine manuell zusammengestellte Datei config.json handeln). </li><li>  Kommuniziert mit dem Betriebssystemkern, um containerisierte Prozesse zu starten (über den Klonsystemaufruf). </li><li>  Konfiguriert cgroups </li><li>  Konfiguriert die SELinux-Richtlinie </li><li>  Konfiguriert App-Rüstungsregeln </li></ul><br>  Ein kleiner historischer Exkurs: Als die Docker-Engine zum ersten Mal erschien, verwendete sie den LXC als Laufzeitumgebung.  Docker-Entwickler haben dann ihre eigene Bibliothek zum Ausführen von Containern namens libcontainer geschrieben.  Es wurde in der Golang-Sprache geschrieben und wurde Teil der Docker-Engine.  Nach dem Aufbau der OCI-Organisation führte Docker den Quellcode libcontainer in dieses Projekt ein und veröffentlichte diese Bibliothek als separates Dienstprogramm namens runc, das dann zur Referenzimplementierung der Containerlaufzeit innerhalb des OCI-Standards wurde und in anderen Container-Engines wie CRI-O verwendet wird .  Runc ist ein sehr einfaches Dienstprogramm, das nur darauf wartet, dass ein Mountpunkt (Verzeichnis) und Metadaten (config.json) an ihn übergeben werden.  Weitere Informationen zu runc finden Sie <a href="">hier</a> . <br><br>  Weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu Containerstandards</a> und zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container-Laufzeit</a> . <br><br><h4>  Bildebenen </h4><br>  Repositorys werden häufig als Bilder oder Bilder von Containern bezeichnet, obwohl Repositorys tatsächlich aus einer oder mehreren Ebenen bestehen.  Die Bildebenen im Repository sind durch die Eltern-Kind-Beziehungen miteinander verbunden, und jede Bildebene enthält Unterschiede zur übergeordneten Ebene. <br><br>  Schauen wir uns die Repository-Ebenen auf dem lokalen Container-Host an.  Da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> ab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 1.7 kein integriertes Tool zum Anzeigen von Bildebenen</a> im lokalen Repository hat (es gibt jedoch Tools für Online-Registrierungen), verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockviz-</a> Dienstprogramm.  Beachten Sie, dass jede Ebene ein Tag und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">universelle eindeutige Kennung (UUID) hat</a> .  Um abgekürzte UUIDs anzuzeigen, die normalerweise auf demselben Computer eindeutig sind, verwenden wir den folgenden Befehl (wenn Sie eine vollständige UUID benötigen, verwenden Sie denselben Befehl mit der Option -no-trunc): <br><br>  docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock nate / dockviz images -t <br><br><pre>  32─2332d8973c93 Virtuelle Größe: 187,7 MB
  │ └ea358092da77 Virtuelle Größe: 187,9 MB
  │ └ a467a7c6794f Virtuelle Größe: 187,9 MB
  │ └ca4d7b1b9a51 Virtuelle Größe: 187,9 MB
  │ └ 4084976dd96d Virtuelle Größe: 384,2 MB
  │ └943128b20e28 Virtuelle Größe: 386,7 MB
  │ └db20cc018f56 Virtuelle Größe: 386,7 MB
  │ └ 45b3c59b9130 Virtuelle Größe: 398,2 MB
  │ └ 91275de1a5d7 Virtuelle Größe: 422,8 MB
  │ └e7a97058d51f Virtuelle Größe: 422,8 MB
  │ └d5c963edfcb2 Virtuelle Größe: 422,8 MB
  │ └5cfc0ce98e02 Virtuelle Größe: 422,8 MB
  │ 777728f71a4bcd Virtuelle Größe: 422,8 MB
  │ └0542f67da01b Virtuelle Größe: 422,8 MB Tags: docker.io/registry:latest
</pre><br>  Wie Sie sehen können, besteht das Repository docker.io/registry tatsächlich aus vielen Ebenen.  Noch wichtiger ist jedoch, dass der Benutzer den Container im Prinzip von jedem Schritt in dieser Schrittleiter aus „starten“ kann, indem er beispielsweise den folgenden Befehl eingibt (er ist völlig korrekt, aber niemand kann garantieren, dass er getestet wurde oder überhaupt richtig funktioniert).  In der Regel markiert der Bildersammler (erstellt Namen) die Ebenen, die als Ausgangspunkt verwendet werden sollen: <br><br><pre>  Docker-Run -it 45b3c59b9130 Bash
</pre><br>  Repositorys sind auf ähnliche Weise angeordnet, da die Unterschiede jedes Mal, wenn der Kollektor ein neues Bild erstellt, als weitere Ebene gespeichert werden.  Es gibt zwei Möglichkeiten, neue Ebenen im Repository zu erstellen.  Wenn Sie ein Bild manuell erstellen, erstellt jede Änderungsbestätigung zunächst eine neue Ebene.  Wenn der Kollektor ein Bild mithilfe einer Docker-Datei erstellt, erstellt jede Anweisung in der Datei eine neue Ebene.  Daher ist es immer nützlich zu sehen, was sich zwischen den Ebenen im Repository geändert hat. <br><br><h4>  Tags </h4><br>  Obwohl der Benutzer selbst die Startschicht zum Mounten und Starten des Containers im Repository angeben kann, muss er dies überhaupt nicht tun.  Wenn der Bildkollektor ein neues Repository erstellt, markiert er normalerweise die am besten geeigneten Ebenen für diese Rolle.  Diese Markierungen werden als Tags bezeichnet und stellen ein Werkzeug dar, mit dem der Bildsammler dem Bildverbraucher mitteilen kann, welche Ebenen am besten verwendet werden.  In der Regel werden Tags verwendet, um Softwareversionen innerhalb eines Repositorys anzugeben.   OCI,  -       ,          .      ,         . <br><br>  ,     – latest,     ,      .       ,     ,      . <br><br>       ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> jq</a>    ): <br><br><pre> curl -s registry.access.redhat.com/v1/repositories/rhel7/tags | jq
  {<font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font>
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",<font></font>
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",<font></font>
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",<font></font>
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",<font></font>
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "latest": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"<font></font>
  }}
</pre><br><h4>  </h4><br>    docker     ,   . ,     «rhel7» –  . <br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      «» (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
 registry.access.redhat.com/rhel6/rhel latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
  ...
</pre><br>     ,            .      docker ( ,    )      ,      «rhel7»    . <br><br>         ,    docker     URL.  ,   ,   URL   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br>  ,    : <br><br><pre> REGISTRY/NAMESPACE/REPOSITORY[:TAG]
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine vollständige URL besteht aus einem Servernamen, einem Namespace und optional einem Tag. </font><font style="vertical-align: inherit;">Tatsächlich gibt es viele Nuancen bei der Angabe einer URL, und wenn Sie das Docker-Ökosystem erkunden, werden Sie feststellen, dass viele Dinge optional sind. </font><font style="vertical-align: inherit;">Schauen Sie sich insbesondere die folgenden Befehle an: Alle sind korrekt und führen zum gleichen Ergebnis:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Docker ziehen registry.access.redhat.com/rhel7/rhel:latest</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Docker ziehen registry.access.redhat.com/rhel7/rhel</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Docker ziehen registry.access.redhat.com/rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Docker ziehen rhel7 / rhel: spätestens</font></font><font></font>
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Namespaces </font></font></h4><br>   –       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DockerHub</a>       ,     ,         . <br><br> Red Hat         ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat Federated Registry</a> .     registry.access.redhat.com  .  ,            .    ,  Red Hat   ,     -  : <br><br><pre> registry.access.redhat.com/rhel7/rhel<font></font>
registry.access.redhat.com/openshift3/mongodb-24-rhel7<font></font>
registry.access.redhat.com/rhscl/mongodb-26-rhel7<font></font>
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7<font></font>
registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0<font></font>
</pre><br>  ,    URL    .           .       fedora,         latest.           : <br><br><pre> docker pull fedora<font></font>
docker pull docker.io/fedora<font></font>
docker pull docker.io/library/fedora:latest<font></font>
</pre><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exec()</a> .    ,       ,  docker,   docker          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">clone()</a> .   clone ()     ,          ,  ,  ,  ,    .. <br><br> ,   Linux   -      ,            clone (). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b> …</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416169/">https://habr.com/ru/post/de416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416157/index.html">In den Armen von Python (nur für Frauen)</a></li>
<li><a href="../de416159/index.html">Wie wir beauftragt wurden, einen Igel mit einer Schlange zu vergleichen</a></li>
<li><a href="../de416161/index.html">10 Gründe, k8s nicht zu verwenden</a></li>
<li><a href="../de416163/index.html">Lerne OpenGL. Lektion 5.6 - Parallaxenzuordnung</a></li>
<li><a href="../de416167/index.html">Peter Norwig: Programmieren lernen in ... 10 Jahren</a></li>
<li><a href="../de416171/index.html">Visual Studio Coded UI Tests: Theorie und Praxis der Anwendung in unserem Unternehmen</a></li>
<li><a href="../de416175/index.html">Ergebnisse des Wettbewerbs junger Entwickler von AR-Anwendungen Epson Moverio BT-300</a></li>
<li><a href="../de416177/index.html">Tupper-Formel und Implementierung des Algorithmus in Python</a></li>
<li><a href="../de416179/index.html">Eine Tür, die uns mit Namen begrüßt und sich nur für Abteilungsmitarbeiter öffnet</a></li>
<li><a href="../de416181/index.html">Amplitudenmodulation an den Fingern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>