<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜© ğŸ§’ğŸ½ ğŸ‘©ğŸ½â€âš•ï¸ Container fÃ¼r Erwachsene (Teil 01): Ein praktischer Leitfaden zur Terminologie ğŸ™‹ ğŸ¥§ ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie fragen sich vielleicht, warum Sie sich mit Terminologie befassen sollten, wenn das Konzept der Container recht einfach und unkompliziert aussieht....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Container fÃ¼r Erwachsene (Teil 01): Ein praktischer Leitfaden zur Terminologie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  Sie fragen sich vielleicht, warum Sie sich mit Terminologie befassen sollten, wenn das Konzept der Container recht einfach und unkompliziert aussieht.  Die falsche Verwendung von Begriffen behindert jedoch hÃ¤ufig die Entwicklung von Containern.  Beispielsweise denken die Leute oft, dass die Begriffe â€Containerâ€œ und â€Bilderâ€œ synonym verwendet werden, obwohl es tatsÃ¤chlich wichtige konzeptionelle Unterschiede zwischen ihnen gibt.  Ein weiteres Beispiel: In der Containerwelt bedeutet ein â€Repositoryâ€œ nicht, was Sie denken.  DarÃ¼ber hinaus ist die Containertechnologie viel mehr als nur ein Docker. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Ohne Kenntnis der Terminologie wird es schwierig sein zu verstehen, wie sich Docker von CRI-O, rkt oder lxc / lxd unterscheidet.  oder bewerten Sie die Rolle der Open Container Initiative bei der Standardisierung von Containertechnologien. <br><a name="habracut"></a><br><h3>  EinfÃ¼hrung </h3><br>  Der Einstieg in Linux-Container ist sehr einfach, aber es stellt sich bald heraus, dass diese Einfachheit irrefÃ¼hrend ist.  Dies geschieht normalerweise folgendermaÃŸen: Nachdem Sie nur ein paar Minuten mit der Installation eines Dockers oder einer anderen Container-Engine verbracht haben, geben Sie bereits Ihre ersten Befehle ein.  Nur ein paar Minuten - und Sie haben bereits Ihr erstes Bild des Containers erstellt und Ã¶ffentlich zugÃ¤nglich gemacht.  Dann wechseln Sie gewÃ¶hnlich zur Architektur der Produktionsumgebung, und plÃ¶tzlich wird Ihnen klar, dass Sie sich dafÃ¼r zunÃ¤chst mit der Masse der Begriffe und Technologien befassen mÃ¼ssen, die dahinter stehen.  Schlimmer noch, viele der unten aufgefÃ¼hrten Begriffe werden synonym verwendet, was fÃ¼r AnfÃ¤nger viel Verwirrung stiftet. <br><br><ul><li>  BehÃ¤lter </li><li>  Bild </li><li>  BehÃ¤lterbild </li><li>  Bildebene </li><li>  Registrierung </li><li>  Repository </li><li>  Tag </li><li>  Basisbild </li><li>  Plattformbild </li><li>  Schicht </li></ul><br>  Wenn Sie die in diesem Dokument beschriebene Terminologie beherrschen, werden Sie die technologischen Grundlagen von Containern besser verstehen.  DarÃ¼ber hinaus kÃ¶nnen Sie und Ihre Kollegen dieselbe Sprache sprechen und die Architektur von Containerumgebungen bewusst und zielgerichtet gemÃ¤ÃŸ den Besonderheiten der zu lÃ¶senden Aufgaben gestalten.  Aus Sicht der IT-Community und der gesamten Branche trÃ¤gt eine allgemeine Verbesserung des VerstÃ¤ndnisses der Containertechnologien wiederum zur Entstehung neuer Architekturen und LÃ¶sungen bei.  Beachten Sie, dass dieser Artikel fÃ¼r Leser gedacht ist, die bereits eine Vorstellung davon haben, wie Container ausgefÃ¼hrt werden. <br><br><h3>  Container: Grundlagen </h3><br>  Bevor wir mit der Terminologie von Containern fortfahren, werden wir bestimmen, was tatsÃ¤chlich der Container selbst ist.  Der Begriff "Container" bedeutet zwei Dinge gleichzeitig.  Wie ein normales Linux-Programm kann sich ein Container in einem von zwei ZustÃ¤nden befinden: funktionierend und nicht funktionierend.  Im Ruhezustand ist der Container eine Datei oder eine Reihe von Dateien, die auf der Festplatte gespeichert sind.  In diesem Zustand beziehen sich die Begriffe Container Image und Container Repository.  Wenn Sie den Befehl zum Starten des Containers eingeben, entpackt die Container-Engine die erforderlichen Dateien und Metadaten und Ã¼bertrÃ¤gt sie an den Linux-Kernel.  Das Starten eines Containers ist dem Starten eines regulÃ¤ren Linux-Prozesses sehr Ã¤hnlich und erfordert einen API-Aufruf des Linux-Kernels.  Dieser API-Aufruf initiiert normalerweise eine zusÃ¤tzliche Isolation und stellt eine Kopie der Dateien bereit, die sich im Container-Image befinden.  Nach dem Start des Containers handelt es sich nur um einen Linux-Prozess.  Das Verfahren zum Starten von Containern sowie das Format der Bilder von Containern, die auf der Festplatte gespeichert sind, werden durch Standards definiert und geregelt. <br><br>  Es gibt verschiedene Formate fÃ¼r Container-Images ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LXD</a> ), aber die Branche bewegt sich allmÃ¤hlich in Richtung eines einzigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Container Initiative-</a> Standards, der manchmal als Open Containers oder einfach als OCI bezeichnet wird.  Dieser Standard definiert die <a href="">Spezifikation des Container-Image-Formats</a> , das das Festplattenformat zum Speichern von Container-Images definiert, sowie Metadaten, die wiederum Dinge wie die Hardwarearchitektur und das Betriebssystem (Linux, Windows usw.) definieren.  Ein einziges branchenÃ¼bliches Bildformat ist der SchlÃ¼ssel zur Schaffung eines Software-Ã–kosystems, mit dem Entwickler, Open Source-Projekte und Softwareanbieter kompatible Bilder und verschiedene Tools wie elektronische Signatur, Scannen, Zusammenstellen, Starten, Verschieben und Verwalten von Container-Bildern erstellen kÃ¶nnen. <br><br>  DarÃ¼ber hinaus gibt es mehrere Containermotoren wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LXC</a> .  Die Containermaschine nimmt ein Bild des Containers auf und verwandelt ihn in einen Container (d. H. Ein laufenden Prozess).  Der Konvertierungsprozess wird auch durch den OCI-Standard definiert, der eine Container-Laufzeitspezifikation und eine Laufzeitreferenzimplementierung namens RunC enthÃ¤lt, ein Open-Source-Modell, das von der entsprechenden Entwicklergemeinschaft reguliert wird.  Viele Container-Engines verwenden dieses Modell, um beim Erstellen von Containern mit dem Host-Kernel zu interagieren. <br><br>  Tools, die die Spezifikationen des <a href="">Container-Image-Formats</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Container-AusfÃ¼hrungsumgebung des</a> OCI-Standards unterstÃ¼tzen, bieten PortabilitÃ¤t innerhalb des Ã–kosystems verschiedener Container-Plattformen, Container-Engines und unterstÃ¼tzender Tools auf verschiedenen Cloud-Plattformen und lokalen Architekturen.  Wenn Sie die Terminologie, Standards und Architektur von Containersystemen kennen, kÃ¶nnen Sie fruchtbar mit anderen Spezialisten kommunizieren und skalierbare und unterstÃ¼tzte containerisierte Anwendungen und Umgebungen entwerfen, die die effiziente Nutzung von Containern Ã¼ber Jahre hinweg sicherstellen. <br><br><h3>  Grundwortschatz </h3><br><h4>  Containerbild </h4><br>  In der einfachsten Definition ist ein Container-Image eine Datei, die vom Registrierungsserver heruntergeladen und beim Starten des Containers lokal als EinhÃ¤ngepunkt verwendet wird.  Trotz der Tatsache, dass der Begriff â€Container-Imageâ€œ hÃ¤ufig verwendet wird, kann er verschiedene Bedeutungen haben.  Tatsache ist, dass Docker, RKT und sogar LXD zwar nach dem eben beschriebenen Prinzip arbeiten, dh gelÃ¶schte Dateien herunterladen und als Container ausfÃ¼hren. Jede dieser Technologien interpretiert das Container-Image auf ihre eigene Weise.  LXD arbeitet mit monolithischen (einschichtigen) Bildern, wÃ¤hrend Docker und RKT OCI-Bilder verwenden, die mehrere Schichten enthalten kÃ¶nnen. <br><br>  Genau genommen ist ein Container-Image auf einem Registrierungsserver weit von einer einzelnen Datei entfernt.  Wenn Benutzer den Begriff â€Container-Imageâ€œ verwenden, meinen sie hÃ¤ufig das Repository und eine Reihe mehrerer Ebenen des Container-Images sowie Metadaten, die zusÃ¤tzliche Informationen zu diesen Ebenen enthalten. <br><br>  DarÃ¼ber hinaus impliziert das Konzept eines Containerbildes implizit die Existenz eines Formats fÃ¼r ein solches Bild. <br><br><h4>  Container-Bildformat </h4><br>  AnfÃ¤nglich hatte jede Container-Engine, einschlieÃŸlich LXD, RKT und Docker, ein eigenes Bildformat.  Einige dieser Formate erlauben nur eine Ebene, wÃ¤hrend andere eine Baumstruktur aus mehreren Ebenen unterstÃ¼tzen.  Heutzutage haben fast alle wichtigen Container-Tools und Engines auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OCI-</a> Format umgestellt, das festlegt, wie Ebenen und Metadaten im Container-Image angeordnet werden sollen.  Im Wesentlichen definiert das OCI-Format ein Container-Image, das aus separaten TAR-Dateien fÃ¼r jede Ebene und einer gemeinsamen manifest.json-Datei mit Metadaten besteht. <br><br>  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Open Container Initiative (OCI)</a> -Standard, der ursprÃ¼nglich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Docker V2-Bildformat</a> basierte, hat ein groÃŸes Ã–kosystem von Container-Engines, Cloud-Plattformen und -Tools (Sicherheitsscanner, Signiertools, Erstellen und Verschieben von Containern) erfolgreich kombiniert und ermÃ¶glicht es Ihnen, Ihre Investitionen in Wissen und Wissen zu schÃ¼tzen Werkzeuge. <br><br><h4>  Containermotor </h4><br>  Die Container-Engine ist der Teil der Software, der Benutzeranforderungen einschlieÃŸlich Befehlszeilenparametern akzeptiert, Bilder herunterlÃ¤dt und aus Sicht des Endbenutzers Container startet.  Es gibt viele Container-Engines, darunter Docker, RKT, CRI-O und LXD.  DarÃ¼ber hinaus verfÃ¼gen viele Cloud-Plattformen, PaaS-Dienste und Container-Plattformen Ã¼ber eigene Engines, die Bilder im Docker- oder OCI-Format verstehen.  Ein Industriestandard fÃ¼r das Bildformat gewÃ¤hrleistet die InteroperabilitÃ¤t all dieser Plattformen. <br><br>  Wenn wir eine Ebene tiefer gehen, kÃ¶nnen wir sagen, dass die meisten Container-Engines Container nicht selbst starten, sondern Ã¼ber eine OCI-kompatible Laufzeit wie runc.  In der Regel fÃ¼hrt eine Container-Laufzeit die folgenden Aktionen aus: <br><br><ul><li>  Behandelt Parameter, Benutzereingaben </li><li>  Behandelt die Ã¼ber die API Ã¼bergebenen Parameter (meistens das Container-Orchestrierungssystem) </li><li>  Laden Sie Container-Images vom Registrierungsserver herunter </li><li>  Entpackt und speichert das Container-Image mithilfe des Grafiktreibers (Block oder Datei, je nach Treiber) auf der Festplatte. </li><li>  Bereitet einen EinhÃ¤ngepunkt fÃ¼r den Container vor, normalerweise im Copy-on-Write-Speicher (wiederum Block oder Datei, je nach Treiber) </li><li>  Bereitet Metadaten vor, die an die Laufzeit Ã¼bergeben werden, um den Container korrekt auszufÃ¼hren: <br><ul><li>  Spezifische Standardeinstellungen, die fÃ¼r das Container-Image impliziert sind (z. B. <a href="">ArchX86</a> ) </li><li>  Benutzereingabe zum Ãœberschreiben der im Container-Image enthaltenen Standardwerte (z. B. CMD, ENTRYPOINT) </li><li>  Vom Container-Image angegebene Standardparameter (z. B. <a href="">SECCOM-</a> Regeln) </li></ul></li><li>  Ruft die Container-Laufzeit auf </li></ul><br><h4>  BehÃ¤lter </h4><br>  Container gibt es in Betriebssystemen schon seit geraumer Zeit, da dies nur eine laufende Instanz eines Container-Images ist.  Ein Container ist ein Standard-Linux-Prozess, der normalerweise mit dem Systemaufruf clone () anstelle von fork () oder exec () erstellt wird.  DarÃ¼ber hinaus werden hÃ¤ufig zusÃ¤tzliche IsolierungsmaÃŸnahmen auf Container angewendet, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SELinux</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppArmor verwenden</a> . <br><br><h4>  Container-Host </h4><br>  Ein Container-Host ist ein System, auf dem containerisierte Prozesse ausgefÃ¼hrt werden, die der Einfachheit halber hÃ¤ufig als Container bezeichnet werden.  Dies kann beispielsweise eine virtuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RHEL Atomic Host-</a> Maschine sein, die sich in einer Ã¶ffentlichen Cloud befindet oder in einem Unternehmens-Rechenzentrum auf Bare-Metal-Basis ausgefÃ¼hrt wird.  Wenn das Container-Image (mit anderen Worten das Repository) vom Registrierungsserver auf den lokalen Container-Host heruntergeladen wird, heiÃŸt es, dass es in den lokalen Cache fÃ¤llt. <br><br>  Mit dem folgenden Befehl kÃ¶nnen Sie bestimmen, welche Repositorys mit dem lokalen Cache synchronisiert werden: <br><br><pre>  [root @ rhel7 ~] # Docker-Bilder -a<font></font>
<font></font>
 REPOSITORY TAG IMAGE ID ERSTELLTE VIRTUELLE GRÃ–SSE
 registry.access.redhat.com/rhel7 aktuell 6883d5422f4e vor 3 Wochen 201.7 MB </pre><br><h4>  Registrierungsserver </h4><br>  Ein Registrierungsserver ist im Wesentlichen ein Dateiserver, auf dem Docker-Repositorys gespeichert werden.  In der Regel wird der Registrierungsserver durch den DNS-Namen und optional die Portnummer angegeben.  Die meisten Vorteile des Docker-Ã–kosystems beruhen auf der MÃ¶glichkeit, Repositorys herunterzuladen und auf Registrierungsserver hochzuladen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Wenn der Docker-Daemon keine Kopie des Repositorys im lokalen Cache findet, lÃ¤dt er diese automatisch vom Registrierungsserver herunter.  Bei den meisten Linux-Distributionen verwendet der Docker-Daemon die docker.io-Site dafÃ¼r, bei einigen Distributionen kann sie jedoch auf eigene Weise konfiguriert werden.  Beispielsweise versucht Red Hat Enterprise Linux zuerst, von registry.access.redhat.com und erst dann von docker.io (Docker Hub) herunterzuladen. <br><br>  Hier muss betont werden, dass der Registrierungsserver implizit als vertrauenswÃ¼rdig gilt.  Daher mÃ¼ssen Sie entscheiden, wie sehr Sie dem Inhalt einer Registrierung vertrauen und ihn zulassen bzw. ablehnen.  Neben der Sicherheit sollten noch weitere Aspekte im Voraus behandelt werden, z. B. Probleme mit der Softwarelizenzierung oder die Ãœberwachung der Einhaltung von Vorschriften.  Die Einfachheit, mit der Docker Benutzern das Herunterladen von Software ermÃ¶glicht, macht das Thema Vertrauen Ã¤uÃŸerst wichtig. <br><br>  Mit Red Hat Enterprise Linux kÃ¶nnen Sie die Standard-Docker-Registrierung konfigurieren.  DarÃ¼ber hinaus kÃ¶nnen Sie mit RHEL7 und RHEL7 Atomic Registrierungsserver Ã¼ber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konfigurationsdatei</a> hinzufÃ¼gen oder sperren: <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 und RHEL 7 Atomic verwenden standardmÃ¤ÃŸig den Red Hat-Registrierungsserver: <br><br><pre>  ADD_REGISTRY = '- add-registry registry.access.redhat.com'
</pre><br>  In einigen FÃ¤llen ist es aus SicherheitsgrÃ¼nden sinnvoll, Ã¶ffentliche Docker-Register wie DockerHub zu blockieren: <br><br><pre>  # BLOCK_REGISTRY = '- Blockregistrierung'
</pre><br>  Red Hat bietet auch seinen integrierten Registrierungsserver als Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenShift Container Platform</a> sowie den eigenstÃ¤ndigen Unternehmensregistrierungsserver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quay Enterprise</a> und Cloud-, private und Ã¶ffentliche Repositorys <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quay.io an.</a> <br><br><h4>  Container-Orchestrierung </h4><br>  Normalerweise installieren die Benutzer zunÃ¤chst einen Container-Host und laden zunÃ¤chst nur die benÃ¶tigten Container-Images herunter.  AnschlieÃŸend erstellen sie ihre eigenen Bilder und laden sie auf den Registrierungsserver hoch, um sie dem Rest des Teams zur VerfÃ¼gung zu stellen.  Nach einiger Zeit mÃ¼ssen mehrere Container kombiniert werden, damit sie als eine Einheit bereitgestellt werden kÃ¶nnen.  Und schlieÃŸlich mÃ¼ssen diese Einheiten irgendwann Teil des ProduktionsfÃ¶rderers sein (Entwicklungs-QS-Produktion).  Auf diese Weise stellen die Menschen normalerweise fest, dass sie ein Orchestrierungssystem benÃ¶tigen. <br><br>  <b>Das Container-Orchestrierungssystem implementiert nur zwei Dinge:</b> <br><br><ol><li>  Containerladungen dynamisch Ã¼ber Clustercomputer verteilen (dies wird hÃ¤ufig als â€verteiltes Computingâ€œ bezeichnet) </li><li>  Bietet eine Standard-Anwendungsbeschreibungsdatei (kube yaml, docker compose usw.) </li></ol><br>  Diese beiden Dinge bieten tatsÃ¤chlich eine Reihe von Vorteilen: <br><br><ol><li>  Die MÃ¶glichkeit, die Container, aus denen die Anwendung besteht, unabhÃ¤ngig voneinander zu verwalten, sodass Sie die folgenden Aufgaben effektiv lÃ¶sen kÃ¶nnen: <br><ul><li>  Entsorgung groÃŸer Container-Host-Cluster </li><li>  Fehler auf der Ebene einzelner Container (nicht mehr reagierende Prozesse, Speicherauslastung) </li><li>  Failover auf Container-Host-Ebene (Laufwerke, Netzwerk, Neustart) </li><li>  Failover auf Containermotorebene (BeschÃ¤digung, Neustart) </li><li>  Individuelle Skalierung von Containern nach oben und unten </li></ul></li><li>  Einfache Bereitstellung neuer Instanzen derselben Anwendung in neuen Umgebungen, sowohl in der Cloud als auch in herkÃ¶mmlichen Umgebungen, zum Beispiel: <br><ul><li>  Auf Entwicklercomputern, die von einem Orchestrierungssystem gesteuert werden </li><li>  In einer gemeinsam genutzten Entwicklungsumgebung in einem privaten Namespace </li><li>  In einer gemeinsamen Entwicklungsumgebung in einem internen Ã¶ffentlichen Namespace, um Transparenz und Testleistung sicherzustellen </li><li>  In der internen Umgebung der QualitÃ¤tssicherung </li><li>  In einer Testladeumgebung, die dynamisch in der Cloud bereitgestellt und widerrufen wird </li><li>  In einer Referenzumgebung, um die KompatibilitÃ¤t mit der Produktionsumgebung zu Ã¼berprÃ¼fen </li><li>  In der Produktionsumgebung </li><li>  In einer Disaster Recovery-Umgebung </li><li>  In einer neuen Produktionsumgebung mit aktualisierten Container-Hosts, Container-Engines oder Orchestrierungs-Tools </li><li>  In der neuen Produktionsumgebung, die sich nicht von der Hauptumgebung unterscheidet, sondern sich in einer anderen Region befindet </li></ul></li></ol><br>  Open Source-Communities und Softwareanbieter bieten viele verschiedene Orchestrierungswerkzeuge an.  Zu den drei groÃŸen dieser Tools gehÃ¶rten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ursprÃ¼nglich</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesos</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes</a> . Heute ist Kubernetes jedoch zum Industriestandard geworden, da sogar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mesosphere</a> ihre UnterstÃ¼tzung angekÃ¼ndigt haben, ganz zu schweigen von fast allen groÃŸen Dienstleistern.  Wenn Sie jedoch nach einem Corporate Orchestration-System suchen, empfehlen wir Ihnen, sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat OpenShift</a> genauer anzusehen. <br><br><h3>  Erweitertes WÃ¶rterbuch </h3><br><h4>  Container-Laufzeit </h4><br>  Die Container-Laufzeit ist eine Low-Level-Komponente, die normalerweise als Teil einer Container-Engine verwendet wird, aber auch manuell zum Testen von Containern verwendet werden kann.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der OCI-Standard</a> definiert eine Referenzimplementierung der als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">runc bezeichneten</a> Laufzeit.  Dies ist die am weitesten verbreitete Implementierung, es gibt jedoch auch andere OCI-kompatible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufzeiten</a> wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Triebwagen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Katacontainer</a> .  Docker, CRI-O und viele andere Container-Engines verwenden runc. <br><br>  Die Container-Laufzeit ist fÃ¼r folgende Dinge verantwortlich: <br><br><ul><li>  Ruft den EinhÃ¤ngepunkt des Containers ab, der von der Container-Engine bereitgestellt wird (zum Testen kann es sich nur um ein Verzeichnis handeln). </li><li>  Ruft die von der Container-Engine bereitgestellten Container-Metadaten ab (beim Testen kann es sich um eine manuell zusammengestellte Datei config.json handeln). </li><li>  Kommuniziert mit dem Betriebssystemkern, um containerisierte Prozesse zu starten (Ã¼ber den Klonsystemaufruf). </li><li>  Konfiguriert cgroups </li><li>  Konfiguriert die SELinux-Richtlinie </li><li>  Konfiguriert App-RÃ¼stungsregeln </li></ul><br>  Ein kleiner historischer Exkurs: Als die Docker-Engine zum ersten Mal erschien, verwendete sie den LXC als Laufzeitumgebung.  Docker-Entwickler haben dann ihre eigene Bibliothek zum AusfÃ¼hren von Containern namens libcontainer geschrieben.  Es wurde in der Golang-Sprache geschrieben und wurde Teil der Docker-Engine.  Nach dem Aufbau der OCI-Organisation fÃ¼hrte Docker den Quellcode libcontainer in dieses Projekt ein und verÃ¶ffentlichte diese Bibliothek als separates Dienstprogramm namens runc, das dann zur Referenzimplementierung der Containerlaufzeit innerhalb des OCI-Standards wurde und in anderen Container-Engines wie CRI-O verwendet wird .  Runc ist ein sehr einfaches Dienstprogramm, das nur darauf wartet, dass ein Mountpunkt (Verzeichnis) und Metadaten (config.json) an ihn Ã¼bergeben werden.  Weitere Informationen zu runc finden Sie <a href="">hier</a> . <br><br>  Weitere Informationen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu Containerstandards</a> und zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Container-Laufzeit</a> . <br><br><h4>  Bildebenen </h4><br>  Repositorys werden hÃ¤ufig als Bilder oder Bilder von Containern bezeichnet, obwohl Repositorys tatsÃ¤chlich aus einer oder mehreren Ebenen bestehen.  Die Bildebenen im Repository sind durch die Eltern-Kind-Beziehungen miteinander verbunden, und jede Bildebene enthÃ¤lt Unterschiede zur Ã¼bergeordneten Ebene. <br><br>  Schauen wir uns die Repository-Ebenen auf dem lokalen Container-Host an.  Da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> ab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Version 1.7 kein integriertes Tool zum Anzeigen von Bildebenen</a> im lokalen Repository hat (es gibt jedoch Tools fÃ¼r Online-Registrierungen), verwenden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockviz-</a> Dienstprogramm.  Beachten Sie, dass jede Ebene ein Tag und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">universelle eindeutige Kennung (UUID) hat</a> .  Um abgekÃ¼rzte UUIDs anzuzeigen, die normalerweise auf demselben Computer eindeutig sind, verwenden wir den folgenden Befehl (wenn Sie eine vollstÃ¤ndige UUID benÃ¶tigen, verwenden Sie denselben Befehl mit der Option -no-trunc): <br><br>  docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock nate / dockviz images -t <br><br><pre>  32â”€2332d8973c93 Virtuelle GrÃ¶ÃŸe: 187,7 MB
  â”‚ â””ea358092da77 Virtuelle GrÃ¶ÃŸe: 187,9 MB
  â”‚ â”” a467a7c6794f Virtuelle GrÃ¶ÃŸe: 187,9 MB
  â”‚ â””ca4d7b1b9a51 Virtuelle GrÃ¶ÃŸe: 187,9 MB
  â”‚ â”” 4084976dd96d Virtuelle GrÃ¶ÃŸe: 384,2 MB
  â”‚ â””943128b20e28 Virtuelle GrÃ¶ÃŸe: 386,7 MB
  â”‚ â””db20cc018f56 Virtuelle GrÃ¶ÃŸe: 386,7 MB
  â”‚ â”” 45b3c59b9130 Virtuelle GrÃ¶ÃŸe: 398,2 MB
  â”‚ â”” 91275de1a5d7 Virtuelle GrÃ¶ÃŸe: 422,8 MB
  â”‚ â””e7a97058d51f Virtuelle GrÃ¶ÃŸe: 422,8 MB
  â”‚ â””d5c963edfcb2 Virtuelle GrÃ¶ÃŸe: 422,8 MB
  â”‚ â””5cfc0ce98e02 Virtuelle GrÃ¶ÃŸe: 422,8 MB
  â”‚ 777728f71a4bcd Virtuelle GrÃ¶ÃŸe: 422,8 MB
  â”‚ â””0542f67da01b Virtuelle GrÃ¶ÃŸe: 422,8 MB Tags: docker.io/registry:latest
</pre><br>  Wie Sie sehen kÃ¶nnen, besteht das Repository docker.io/registry tatsÃ¤chlich aus vielen Ebenen.  Noch wichtiger ist jedoch, dass der Benutzer den Container im Prinzip von jedem Schritt in dieser Schrittleiter aus â€startenâ€œ kann, indem er beispielsweise den folgenden Befehl eingibt (er ist vÃ¶llig korrekt, aber niemand kann garantieren, dass er getestet wurde oder Ã¼berhaupt richtig funktioniert).  In der Regel markiert der Bildersammler (erstellt Namen) die Ebenen, die als Ausgangspunkt verwendet werden sollen: <br><br><pre>  Docker-Run -it 45b3c59b9130 Bash
</pre><br>  Repositorys sind auf Ã¤hnliche Weise angeordnet, da die Unterschiede jedes Mal, wenn der Kollektor ein neues Bild erstellt, als weitere Ebene gespeichert werden.  Es gibt zwei MÃ¶glichkeiten, neue Ebenen im Repository zu erstellen.  Wenn Sie ein Bild manuell erstellen, erstellt jede Ã„nderungsbestÃ¤tigung zunÃ¤chst eine neue Ebene.  Wenn der Kollektor ein Bild mithilfe einer Docker-Datei erstellt, erstellt jede Anweisung in der Datei eine neue Ebene.  Daher ist es immer nÃ¼tzlich zu sehen, was sich zwischen den Ebenen im Repository geÃ¤ndert hat. <br><br><h4>  Tags </h4><br>  Obwohl der Benutzer selbst die Startschicht zum Mounten und Starten des Containers im Repository angeben kann, muss er dies Ã¼berhaupt nicht tun.  Wenn der Bildkollektor ein neues Repository erstellt, markiert er normalerweise die am besten geeigneten Ebenen fÃ¼r diese Rolle.  Diese Markierungen werden als Tags bezeichnet und stellen ein Werkzeug dar, mit dem der Bildsammler dem Bildverbraucher mitteilen kann, welche Ebenen am besten verwendet werden.  In der Regel werden Tags verwendet, um Softwareversionen innerhalb eines Repositorys anzugeben.   OCI,  -       ,          .      ,         . <br><br>  ,     â€“ latest,     ,      .       ,     ,      . <br><br>       ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> jq</a>    ): <br><br><pre> curl -s registry.access.redhat.com/v1/repositories/rhel7/tags | jq
  {<font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font>
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",<font></font>
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",<font></font>
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",<font></font>
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",<font></font>
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "latest": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"<font></font>
  }}
</pre><br><h4>  </h4><br>    docker     ,   . ,     Â«rhel7Â» â€“  . <br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      Â«Â» (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
 registry.access.redhat.com/rhel6/rhel latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
  ...
</pre><br>     ,            .      docker ( ,    )      ,      Â«rhel7Â»    . <br><br>         ,    docker     URL.  ,   ,   URL   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br>  ,    : <br><br><pre> REGISTRY/NAMESPACE/REPOSITORY[:TAG]
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine vollstÃ¤ndige URL besteht aus einem Servernamen, einem Namespace und optional einem Tag. </font><font style="vertical-align: inherit;">TatsÃ¤chlich gibt es viele Nuancen bei der Angabe einer URL, und wenn Sie das Docker-Ã–kosystem erkunden, werden Sie feststellen, dass viele Dinge optional sind. </font><font style="vertical-align: inherit;">Schauen Sie sich insbesondere die folgenden Befehle an: Alle sind korrekt und fÃ¼hren zum gleichen Ergebnis:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Docker ziehen registry.access.redhat.com/rhel7/rhel:latest</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Docker ziehen registry.access.redhat.com/rhel7/rhel</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Docker ziehen registry.access.redhat.com/rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Docker ziehen rhel7 / rhel: spÃ¤testens</font></font><font></font>
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Namespaces </font></font></h4><br>   â€“       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DockerHub</a>       ,     ,         . <br><br> Red Hat         ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat Federated Registry</a> .     registry.access.redhat.com  .  ,            .    ,  Red Hat   ,     -  : <br><br><pre> registry.access.redhat.com/rhel7/rhel<font></font>
registry.access.redhat.com/openshift3/mongodb-24-rhel7<font></font>
registry.access.redhat.com/rhscl/mongodb-26-rhel7<font></font>
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7<font></font>
registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0<font></font>
</pre><br>  ,    URL    .           .       fedora,         latest.           : <br><br><pre> docker pull fedora<font></font>
docker pull docker.io/fedora<font></font>
docker pull docker.io/library/fedora:latest<font></font>
</pre><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exec()</a> .    ,       ,  docker,   docker          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">clone()</a> .   clone ()     ,          ,  ,  ,  ,    .. <br><br> ,   Linux   -      ,            clone (). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b> â€¦</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416169/">https://habr.com/ru/post/de416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416157/index.html">In den Armen von Python (nur fÃ¼r Frauen)</a></li>
<li><a href="../de416159/index.html">Wie wir beauftragt wurden, einen Igel mit einer Schlange zu vergleichen</a></li>
<li><a href="../de416161/index.html">10 GrÃ¼nde, k8s nicht zu verwenden</a></li>
<li><a href="../de416163/index.html">Lerne OpenGL. Lektion 5.6 - Parallaxenzuordnung</a></li>
<li><a href="../de416167/index.html">Peter Norwig: Programmieren lernen in ... 10 Jahren</a></li>
<li><a href="../de416171/index.html">Visual Studio Coded UI Tests: Theorie und Praxis der Anwendung in unserem Unternehmen</a></li>
<li><a href="../de416175/index.html">Ergebnisse des Wettbewerbs junger Entwickler von AR-Anwendungen Epson Moverio BT-300</a></li>
<li><a href="../de416177/index.html">Tupper-Formel und Implementierung des Algorithmus in Python</a></li>
<li><a href="../de416179/index.html">Eine TÃ¼r, die uns mit Namen begrÃ¼ÃŸt und sich nur fÃ¼r Abteilungsmitarbeiter Ã¶ffnet</a></li>
<li><a href="../de416181/index.html">Amplitudenmodulation an den Fingern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>