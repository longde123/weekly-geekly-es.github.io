<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≥ üë©üèæ‚Äçüíª üò° Primeiro, observe o FoundationDB da Apple üõåüèº üïå üë∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No √∫ltimo artigo, examinamos as limita√ß√µes e obst√°culos que surgem quando voc√™ precisa escalar dados horizontalmente e ter uma garantia das propriedad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeiro, observe o FoundationDB da Apple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441270/"> No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltimo artigo,</a> examinamos as limita√ß√µes e obst√°culos que surgem quando voc√™ precisa escalar dados horizontalmente e ter uma garantia das propriedades ACID das transa√ß√µes.  Neste artigo, falamos sobre a tecnologia FoundationDB e entendemos como isso ajuda a superar essas limita√ß√µes ao desenvolver aplicativos de miss√£o cr√≠tica. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O FoundationDB</a> √© um banco de dados distribu√≠do NoSQL com transa√ß√µes ACID serializ√°veis ‚Äã‚Äãque armazena pares de armazenamento de valores-chave classificados.  Chaves e valores podem ser seq√º√™ncias arbitr√°rias de bytes.  Ele n√£o tem um √∫nico ponto de incid√™ncia - todas as m√°quinas de cluster s√£o iguais.  Ele pr√≥prio distribui os dados entre os servidores de cluster e as escalas em tempo real: quando voc√™ precisa adicionar recursos ao cluster, basta adicionar o endere√ßo da nova m√°quina nos servidores de configura√ß√£o e o banco de dados os seleciona. <a name="habracut"></a><br><br>  No FoundationDB, as transa√ß√µes nunca se bloqueiam.  A leitura √© implementada atrav√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do controle de vers√£o multivers√£o</a> (MVCC), e a leitura √© implementada atrav√©s do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controle de concorr√™ncia otimista</a> (OCC).  Os desenvolvedores afirmam que, quando todas as m√°quinas do cluster est√£o no mesmo datacenter, a lat√™ncia de grava√ß√£o √© de 2 a 3 ms e a lat√™ncia de leitura √© menor que um milissegundo.  A documenta√ß√£o cont√©m estimativas de 10 a 15 ms, o que provavelmente est√° mais pr√≥ximo dos resultados em condi√ß√µes reais. <br><br><img src="https://habrastorage.org/webt/ob/9m/jt/ob9mjtfiyqpvxfjpjc1tp48ujho.png">  <font color="#777777">* N√£o suporta propriedades ACID em v√°rios shards.</font> <br><br>  O FoundationDB tem uma vantagem √∫nica - o compartilhamento autom√°tico novamente.  O pr√≥prio DBMS garante o carregamento uniforme de m√°quinas no cluster: quando um servidor est√° cheio, ele redistribui dados para os vizinhos em segundo plano.  Ao mesmo tempo, a garantia do n√≠vel de serializa√ß√£o para todas as transa√ß√µes √© preservada, e o √∫nico efeito percept√≠vel para os clientes √© um ligeiro aumento na lat√™ncia das respostas.  O banco de dados garante que a quantidade de dados nos servidores de cluster mais e menos carregados n√£o seja superior a 5%. <br><br><h2>  Arquitetura </h2><br>  Logicamente, um cluster FoundationDB √© um conjunto de processos do mesmo tipo em diferentes m√°quinas f√≠sicas.  Os processos n√£o possuem seus pr√≥prios arquivos de configura√ß√£o e, portanto, s√£o intercambi√°veis.  V√°rios processos fixos t√™m uma fun√ß√£o dedicada - Coordenadores, e cada processo de cluster na inicializa√ß√£o conhece seus endere√ßos.  √â importante que as falhas dos coordenadores sejam o mais independentes poss√≠vel, portanto, √© melhor coloc√°-las em m√°quinas f√≠sicas diferentes ou mesmo em data centers diferentes. <br><br><img src="https://habrastorage.org/webt/ai/sx/qv/aisxqvwfakb618b27cl_vyjnc5a.png"><br><br>  Os coordenadores concordam entre si atrav√©s do algoritmo de consenso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Paxos</a> .  Eles selecionam o processo do Cluster Controller, que atribui fun√ß√µes ao restante dos processos do cluster.  O Controlador de Cluster informa continuamente a todos os Coordenadores que ele est√° vivo.  Se a maioria dos coordenadores pensa que ele est√° morto, eles apenas escolhem um novo.  Nem o Controlador de Cluster nem os Coordenadores est√£o envolvidos no processamento de transa√ß√µes; sua principal tarefa √© eliminar a situa√ß√£o do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√©rebro dividido</a> . <br><br>  Quando um cliente deseja se conectar ao banco de dados, ele imediatamente entra em contato com todos os coordenadores para o endere√ßo do atual Cluster Controller.  Se a maioria das respostas corresponder, ele receber√° do Cluster Controller a configura√ß√£o atual completa do cluster (se n√£o corresponder, chamar√° novamente os coordenadores). <br><br><img src="https://habrastorage.org/webt/ig/g6/qq/igg6qqffqlxbbrd-cpchddyktbu.png"><br><br>  O Cluster Controller conhece o n√∫mero total de processos dispon√≠veis e distribui fun√ß√µes: esses 5 ser√£o Proxy, esses 2 ser√£o Resolver, este ser√° Master.  E se algum deles morrer, ele encontrar√° imediatamente um substituto para ele, atribuindo a fun√ß√£o necess√°ria a um processo livre arbitr√°rio.  Isso tudo acontece em segundo plano, invis√≠vel para o programador de aplicativos. <br><br>  O processo Master √© respons√°vel pelo n√∫mero da vers√£o atual do conjunto de dados (aumenta a cada registro no banco de dados), bem como pela distribui√ß√£o de muitas chaves nos servidores de armazenamento e pela otimiza√ß√£o da taxa (desempenho artificialmente mais baixo sob cargas pesadas: se o cluster souber que o cliente far√° muitos pedidos pequenos, ele ir√° esperar, agrup√°-los e responder ao pacote inteiro de uma s√≥ vez). <br><br>  O log de transa√ß√µes e o armazenamento s√£o dois subsistemas de armazenamento independentes.  O primeiro √© o armazenamento tempor√°rio para gravar rapidamente dados no disco na ordem de recebimento, o segundo √© o armazenamento permanente, onde os dados no disco s√£o classificados em ordem crescente de chaves.  Cada transa√ß√£o confirmada, pelo menos tr√™s processos tLog devem salvar dados antes que o cluster relate sucesso para o cliente.  Paralelamente, os dados em segundo plano passam dos servidores tLog para os servidores de armazenamento (armazenamento no qual tamb√©m √© redundante). <br><br><h2>  Processamento de solicita√ß√£o </h2><br>  Todas as solicita√ß√µes do cliente processam processos de proxy.  Ao abrir uma transa√ß√£o, o cliente acessa qualquer Proxy, pesquisa todos os outros Proxies e retorna o n√∫mero da vers√£o atual dos dados do cluster.  Todas as leituras subsequentes ocorrem neste n√∫mero de vers√£o.  Se outro cliente anotou os dados depois que eu abri a transa√ß√£o, simplesmente n√£o vou ver suas altera√ß√µes. <br><br>  Gravar uma transa√ß√£o √© um pouco mais complicado, pois voc√™ precisa resolver conflitos.  Isso inclui o processo do Resolver, que armazena na mem√≥ria todas as chaves modificadas por um determinado per√≠odo de tempo.  Quando o cliente conclui a transa√ß√£o de confirma√ß√£o, o Resolver verifica se os dados que estavam lendo est√£o desatualizados.  (Ou seja, se a transa√ß√£o que foi aberta depois da minha foi conclu√≠da e alterou as chaves que eu li.) Se isso acontecer, a transa√ß√£o ser√° revertida e a pr√≥pria biblioteca do cliente (!) Far√° uma segunda tentativa de confirma√ß√£o.  A √∫nica coisa em que o desenvolvedor deve pensar √© que as transa√ß√µes s√£o idempotentes, ou seja, o uso repetido deve fornecer um resultado id√™ntico.  Uma maneira de conseguir isso √© salvar algum valor exclusivo dentro da transa√ß√£o e, no in√≠cio da transa√ß√£o, verificar sua presen√ßa no banco de dados. <br><br><img src="https://habrastorage.org/webt/h6/sl/tn/h6sltnc7mmauiguiymix7msytv0.png"><br><br>  Como em qualquer sistema cliente-servidor, h√° situa√ß√µes em que a transa√ß√£o √© conclu√≠da com √™xito, mas o cliente n√£o recebeu confirma√ß√£o devido a uma desconex√£o.  A biblioteca cliente os trata como qualquer outro erro - simplesmente tenta novamente.  Isso pode levar √† reexecu√ß√£o de toda a transa√ß√£o.  No entanto, se a transa√ß√£o for idempotente, n√£o h√° problema com isso - ela n√£o afetar√° o resultado final. <br><br><h2>  Dimensionamento </h2><br>  Pode haver milhares de servidores em um subsistema de armazenamento.  Qual deles um cliente deve entrar em contato quando precisar de dados em uma determinada chave?  No Cluster Controller, o cliente conhece a configura√ß√£o completa de todo o cluster e inclui intervalos de chaves em cada servidor de Armazenamento.  Portanto, ele simplesmente acessa os servidores de armazenamento desejados diretamente, sem solicita√ß√µes intermedi√°rias. <br><br>  Se o servidor de armazenamento desejado n√£o estiver dispon√≠vel, a biblioteca do cliente obter√° uma nova configura√ß√£o do Cluster Controller.  Se, como resultado de uma falha no servidor, o cluster entender que a redund√¢ncia √© insuficiente, ele imediatamente come√ßar√° a coletar um novo n√≥ de partes de outro armazenamento. <br><br>  Suponha que voc√™ salve um gigabyte de dados em uma transa√ß√£o.  Como voc√™ pode fornecer uma resposta r√°pida?  De maneira alguma e, portanto, o FoundationDB simplesmente limitou o tamanho de uma transa√ß√£o a 10 megabytes.  Al√©m disso, essa √© uma restri√ß√£o a todos os dados que a transa√ß√£o <i>diz respeito</i> - l√™ ou grava.  Cada entrada no banco de dados tamb√©m √© limitada - a chave n√£o pode exceder 10 kilobytes, o valor √© 100 kilobytes.  (Ao mesmo tempo, para um desempenho ideal, os desenvolvedores recomendam chaves de 32 bytes e 10 kilobytes.) <br><br>  Qualquer transa√ß√£o pode potencialmente se tornar uma fonte de conflito e, em seguida, ter√° que ser revertida.  Portanto, por uma quest√£o de velocidade, at√© que o comando commit chegue, faz sentido manter as altera√ß√µes atuais na RAM e n√£o no disco.  Suponha que voc√™ esteja gravando dados em um banco de dados com uma carga de 1 GB / segundo.  Em um caso extremo, seu cluster alocar√° 3 GB de RAM a cada segundo (gravamos transa√ß√µes em 3 m√°quinas).  Como limitar um crescimento t√£o semelhante a uma avalanche de mem√≥ria usada?  √â muito simples limitar o tempo m√°ximo de transa√ß√£o.  No FoundationDB, uma transa√ß√£o n√£o pode durar mais de 5 segundos.  Se o cliente tentar acessar o banco de dados 5 segundos ap√≥s a transa√ß√£o ser aberta, o cluster ignorar√° todos os seus comandos at√© abrir um novo. <br><br><h2>  √çndices </h2><br>  Suponha que voc√™ mantenha uma lista de pessoas, cada pessoa tenha um identificador exclusivo, que seja usado como chave e, no valor, escreva todos os outros atributos - nome, sexo, idade etc. <br><table><tbody><tr><td>  Key </td><td>  Valor </td></tr><tr><td>  12345 </td><td>  (Ivanov Ivan Ivanovich, M, 35 anos) </td></tr></tbody></table><br>  Como obter uma lista de todas as pessoas com 30 anos de idade sem pesquisa exaustiva?  Geralmente, um √≠ndice √© criado no banco de dados para isso.  Um √≠ndice √© outra visualiza√ß√£o de dados projetada para procurar rapidamente atributos adicionais.  Podemos simplesmente adicionar entradas do formul√°rio: <br><table><tbody><tr><td>  Key </td><td>  Valor </td></tr><tr><td>  (35, 12345) </td><td>  '' </td></tr></tbody></table><br>  Agora, para obter a lista que voc√™ precisa, basta pesquisar o intervalo de teclas (30, *).  Como o FoundationDB armazena dados classificados por chave, essa consulta ser√° executada muito rapidamente.  Obviamente, o √≠ndice ocupa espa√ßo em disco adicional, mas muito pouco.  Observe que nem todos os atributos s√£o duplicados, mas apenas a idade e o identificador. <br><br>  √â importante que as opera√ß√µes de adi√ß√£o do pr√≥prio registro e do √≠ndice sejam executadas em uma transa√ß√£o. <br><br><h2>  Confiabilidade </h2><br>  O FoundationDB √© escrito em C ++.  Os autores come√ßaram a trabalhar nele em 2009, a primeira vers√£o foi lan√ßada em 2013 e, em mar√ßo de 2015, a Apple os comprou.  Tr√™s anos depois, a Apple abriu inesperadamente o c√≥digo fonte.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">H√° rumores de</a> que a Apple o usa, entre outras coisas, para armazenar dados de servi√ßo do iCloud. <br><br>  Desenvolvedores experientes geralmente n√£o confiam imediatamente em novas solu√ß√µes.  Pode levar anos at√© que a tecnologia se estabele√ßa de forma confi√°vel e comece a ser usada maci√ßamente em prod.  Para reduzir esse tempo, os autores fizeram uma extens√£o interessante da linguagem C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Flow</a> .  Ele permite emular normalmente o trabalho com componentes externos n√£o confi√°veis, com a possibilidade de uma repeti√ß√£o previs√≠vel completa da execu√ß√£o do programa.  Cada chamada para uma rede ou disco √© agrupada em algum wrapper (Actor) e cada ator possui v√°rias implementa√ß√µes.  A implementa√ß√£o padr√£o grava dados no disco ou na rede, conforme pretendido.  E o outro grava no disco 999 vezes em 1000 e perde 1 vez em 1000.  Uma implementa√ß√£o de rede alternativa pode, por exemplo, trocar bytes em pacotes de rede.  Existem at√© atores que imitam o trabalho de um administrador de sistema descuidado.  Isso pode excluir a pasta de dados ou trocar duas pastas.  Os desenvolvedores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conduzem milhares de simula√ß√µes</a> , substituindo diferentes atores e usando o Flow atingem 100% de reprodutibilidade: se algum teste falhar, eles podem reiniciar a simula√ß√£o e sofrer uma falha no mesmo local.  Em particular, para eliminar a incerteza introduzida pelos threads de altern√¢ncia do agendador do SO, cada processo do FoundationDB √© estritamente de thread √∫nico. <br><br>  Quando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisador</a> , que descobriu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cen√°rios de perda de dados em quase todas as solu√ß√µes NoSQL populares</a> , foi convidado a testar o FoundationDB, ele se recusou, observando que n√£o entendia o motivo, porque os autores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fizeram um trabalho gigantesco</a> e os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">testaram</a> muito mais profundamente e mais profundamente que o seu. <br><br>  √â habitual pensar que as falhas do cluster s√£o aleat√≥rias, mas os devops experientes sabem que isso est√° longe de ser o caso.  Se voc√™ tiver 10 mil discos do mesmo fabricante e o mesmo n√∫mero de outros, a taxa de falhas ser√° diferente.  No FoundationDB, √© poss√≠vel uma configura√ß√£o chamada de reconhecimento de m√°quina, na qual √© poss√≠vel informar ao cluster quais m√°quinas est√£o no mesmo datacenter e quais processos est√£o na mesma m√°quina.  O banco de dados levar√° isso em considera√ß√£o ao distribuir a carga entre as m√°quinas.  E m√°quinas em um cluster geralmente t√™m caracter√≠sticas diferentes.  O FoundationDB tamb√©m leva isso em considera√ß√£o, analisa a dura√ß√£o das filas de solicita√ß√µes e redistribui a carga de maneira equilibrada: m√°quinas mais fracas recebem menos solicita√ß√µes. <br><br>  Portanto, o FoundationDB fornece transa√ß√µes ACID e o mais alto n√≠vel de isolamento, serializ√°vel, em um cluster de milhares de m√°quinas.  Juntamente com incr√≠vel flexibilidade e alto desempenho, parece m√°gica.  Mas voc√™ tem que pagar por tudo, ent√£o existem algumas limita√ß√µes tecnol√≥gicas. <br><br><h2>  Limita√ß√µes </h2><br>  Al√©m dos limites j√° mencionados sobre o tamanho e a dura√ß√£o da transa√ß√£o, √© importante observar os seguintes recursos: <br><br><ul><li>  A linguagem de consulta n√£o √© SQL, ou seja, os desenvolvedores com experi√™ncia em SQL ter√£o que reaprender. <br></li><li>  A biblioteca do cliente suporta apenas 5 linguagens de alto n√≠vel (Phyton, Ruby, Java, Golang e C).  Ainda n√£o h√° um cliente oficial para C #.  Como n√£o h√° API REST, a √∫nica maneira de oferecer suporte a outro idioma √© escrever um wrapper sobre ele na parte superior da biblioteca C padr√£o. <br></li><li>  N√£o h√° mecanismos de compartilhamento, toda essa l√≥gica deve ser fornecida pelo seu aplicativo. <br></li><li>  O formato de armazenamento de dados n√£o est√° documentado (embora geralmente tamb√©m n√£o esteja documentado em bancos de dados comerciais).  Isso √© um risco, porque, de repente, o cluster n√£o √© montado, ent√£o n√£o est√° claro o que fazer e ser√° necess√°rio investigar os arquivos de origem. <br></li><li>  Um modelo de programa√ß√£o estritamente ass√≠ncrono pode parecer complicado para desenvolvedores iniciantes. <br></li><li>  Voc√™ precisa pensar constantemente na idempot√™ncia das transa√ß√µes. <br></li><li>  Se voc√™ precisar dividir transa√ß√µes longas em pequenas, precisar√° cuidar da integridade em n√≠vel global. <br></li></ul><br>  Traduzido do ingl√™s, "Foundation" significa "Foundation" e os autores deste DBMS veem seu papel desta maneira: fornecer um alto n√≠vel de confiabilidade no n√≠vel de registros simples, e qualquer outro banco de dados pode ser implementado como um complemento da funcionalidade b√°sica.  Assim, no topo do FoundationDB, voc√™ pode criar diferentes outras camadas - documentos, gr√°ficos etc.  A quest√£o permanece como essas camadas ser√£o dimensionadas sem perder o desempenho.  Por exemplo, os autores do CockroachDB j√° adotaram esse caminho - construindo uma camada SQL no topo do RocksDB (armazenamento de valor da chave local) e eles t√™m problemas de desempenho inerentes √†s jun√ß√µes relacionais. <br><br>  At√© o momento, a Apple desenvolveu e publicou duas camadas sobre o FoundationDB: a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camada de documentos</a> (suporta API MongoDB) e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Camada de</a> registros (armazena registros como conjuntos de campos no formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Protocol Buffers</a> , suporta √≠ndices, est√° dispon√≠vel apenas em Java).  √â agrad√°vel e surpreendentemente surpreendente que a empresa historicamente fechada da Apple hoje siga os passos do Google e da Microsoft e publique o c√≥digo fonte das tecnologias usadas no interior. <br><br><h2>  Perspectivas </h2><br>  Existe um conflito existencial no desenvolvimento de software: a empresa constantemente quer mudan√ßas, melhorias do produto.  Mas, ao mesmo tempo, ele quer um software confi√°vel.  E esses dois requisitos se contradizem, porque quando o software muda, os bugs aparecem e os neg√≥cios sofrem com isso.  Portanto, se voc√™ puder confiar em alguma tecnologia comprovada e confi√°vel e escrever menos c√≥digo por conta pr√≥pria, sempre vale a pena fazer isso.  Nesse sentido, apesar de certas limita√ß√µes, √© legal poder n√£o esculpir muletas em diferentes bancos de dados NoSQL, mas usar uma solu√ß√£o comprovada em produ√ß√£o com propriedades ACID. <br><br>  H√° um ano, est√°vamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">otimistas</a> com outra tecnologia - o CockroachDB, mas ela n√£o atendeu √†s nossas expectativas de desempenho.  Desde ent√£o, perdemos o apetite pela id√©ia de uma camada SQL em rela√ß√£o a um armazenamento de valor-chave distribu√≠do e, portanto, n√£o examinamos cuidadosamente, por exemplo, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TiDB</a> .  Planejamos experimentar cuidadosamente o FoundationDB como um banco de dados secund√°rio para os maiores conjuntos de dados em nosso projeto.  Se voc√™ j√° tem experi√™ncia no uso real do FoundationDB ou TiDB na produ√ß√£o, teremos o maior prazer em ouvir sua opini√£o nos coment√°rios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441270/">https://habr.com/ru/post/pt441270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441260/index.html">Como os gr√°ficos de rede neural ajudaram</a></li>
<li><a href="../pt441262/index.html">Tarefas simples e longas eliminam os candidatos melhor do que os curtos e complexos</a></li>
<li><a href="../pt441264/index.html">Guia do Usu√°rio Kibana. Visualiza√ß√£o. Parte 2</a></li>
<li><a href="../pt441266/index.html">Como o framework tiOPF para delphi / lazarus funciona. Modelo de visitante</a></li>
<li><a href="../pt441268/index.html">Testes de Ceedling + Eclipse ou de unidade para microcontroladores</a></li>
<li><a href="../pt441274/index.html">Como se tornar um testador - o conhecimento e as habilidades necess√°rias</a></li>
<li><a href="../pt441278/index.html">Como criar uma linda paleta de cores</a></li>
<li><a href="../pt441280/index.html">Configura√ß√£o da GAL no Zimbra Collaboration Suite</a></li>
<li><a href="../pt441282/index.html">√ìtima entrevista com o criador de Jenkins, Kohsuke Kawaguchi</a></li>
<li><a href="../pt441284/index.html">Carregamento de dados em massa ou Como alimentar uma vila chinesa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>