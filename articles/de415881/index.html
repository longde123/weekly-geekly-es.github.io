<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéâ üë®üèª‚Äçüíª üëºüèΩ Funktionsweise von JS: Shadow DOM-Technologie und Webkomponenten üôãüèæ ü§∞üèº üë©‚Äçüë©‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Lesen empfehlen] Die anderen 19 Teile des Zyklus  Teil 1: √úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel 
 Teil 2: Informationen zu V8-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von JS: Shadow DOM-Technologie und Webkomponenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415881/"><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberblick √ºber die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und f√ºnf M√∂glichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich w√§hlen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und f√ºnf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie √Ñnderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines f√ºr Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxb√§ume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br>  In der √úbersetzung von 17 Teilen der Materialien, die sich mit den Funktionen von allem befassen, was irgendwie mit JavaScript verbunden ist, werden wir heute √ºber Webkomponenten und verschiedene Standards sprechen, die darauf abzielen, mit ihnen zu arbeiten.  Besonderes Augenmerk wird auf die Shadow DOM-Technologie gelegt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/8k/li/z5/8kliz5q5jcynt6ggr2rqa-fancc.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">R√ºckblick</font> </h2><br>  Webkomponenten sind eine Familie von APIs, mit denen neue DOM-Elemente beschrieben werden, die zur Wiederverwendung geeignet sind.  Die Funktionalit√§t solcher Elemente ist vom Rest des Codes getrennt, sie k√∂nnen in Webanwendungen unseres eigenen Designs verwendet werden. <br><br>  Es gibt vier Technologien f√ºr Webkomponenten: <br><br><ul><li>  Schatten-DOM (Schatten-DOM) </li><li>  HTML-Vorlagen (HTML-Vorlagen) </li><li>  Benutzerdefinierte Elemente </li><li>  HTML-Importe (HTML-Import) </li></ul><br>  In diesem Artikel werden wir √ºber die Shadow DOM-Technologie sprechen, mit der komponentenbasierte Anwendungen erstellt werden k√∂nnen.  Es bietet M√∂glichkeiten zur L√∂sung h√§ufig auftretender Probleme bei der Webentwicklung, auf die Sie m√∂glicherweise bereits gesto√üen sind: <br><br><ul><li> DOM-Isolation: Die Komponente verf√ºgt √ºber einen isolierten DOM-Baum (dies bedeutet, dass der Befehl <code>document.querySelector()</code> keinen Zugriff auf den Knoten im Schatten-DOM der Komponente erm√∂glicht).  Dar√ºber hinaus vereinfacht es das CSS-Auswahlsystem in Webanwendungen, da die DOM-Komponenten isoliert sind, sodass der Entwickler dieselben universellen Bezeichner und Klassennamen in verschiedenen Komponenten verwenden kann, ohne sich √ºber m√∂gliche Namenskonflikte Gedanken machen zu m√ºssen. </li><li>  CSS-Isolation: Die im Schatten-DOM beschriebenen CSS-Regeln sind darauf beschr√§nkt.  Diese Stile verlassen das Element nicht und werden nicht mit anderen Seitenstilen gemischt. </li><li>  Zusammensetzung: Entwicklung einer deklarativen API f√ºr Markup-basierte Komponenten. </li></ul><br><h2>  <font color="#3AC1EF">Shadow DOM-Technologie</font> </h2><br>  Es wird davon ausgegangen, dass Sie bereits mit dem Konzept des DOM und den zugeh√∂rigen APIs vertraut sind.  Wenn dies nicht der Fall ist, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material lesen. <br><br>  Das Shadow-DOM ist im Grunde dasselbe wie ein normales DOM, jedoch mit zwei Unterschieden: <br><br><ul><li>  Das erste ist, wie das Schatten-DOM erstellt und verwendet wird, insbesondere geht es um die Beziehung des Schatten-DOM zum Rest der Seite. </li><li>  Das zweite ist das Verhalten des Schatten-DOM in Bezug auf die Seite. </li></ul><br>  Bei der Arbeit mit dem DOM werden DOM-Knoten erstellt, die als untergeordnete Elemente mit anderen Elementen der Seite verkn√ºpft werden.  Bei der Shadow-DOM-Technologie wird ein isolierter DOM-Baum erstellt, der das Element verbindet, jedoch von seinen normalen untergeordneten Elementen getrennt ist. <br><br>  Dieser isolierte Teilbaum wird als Schattenbaum bezeichnet.  Das Element, an das ein solcher Baum angeh√§ngt ist, wird als Schattenhost bezeichnet.  Alles, was dem Schatten-DOM-Teilbaum hinzugef√ºgt wird, ist lokal f√ºr das Element, an das es angeh√§ngt ist, einschlie√ülich der mit <code>&lt;style&gt;</code> -Tags beschriebenen <code>&lt;style&gt;</code> .  Auf diese Weise wird die CSS-Isolierung durch die Shadow DOM-Technologie bereitgestellt. <br><br><h2>  <font color="#3AC1EF">Erstellen eines Schatten-DOM</font> </h2><br>  Die Schattenwurzel ist ein Teil des Dokuments, das an das Hostelement angeh√§ngt wird.  Ein Element erh√§lt ein Schatten-DOM, wenn ein Schattenwurzelelement daran angeh√§ngt ist.  Um ein Schatten-DOM f√ºr ein bestimmtes Element zu erstellen, m√ºssen Sie einen Befehl des Formulars <code>element.attachShadow()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowRoot = header.attachShadow({<span class="hljs-attr"><span class="hljs-attr">mode</span></span>: <span class="hljs-string"><span class="hljs-string">'open'</span></span>}); shadowRoot.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'&lt;p&gt; Shadow DOM &lt;/p&gt;'</span></span>);</code> </pre> <br>  Es ist zu beachten, dass in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> Shadow-DOM- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> eine Liste von Elementen enthalten ist, mit denen DOM-Shadow-Teilb√§ume nicht verbunden werden k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Komposition im Schatten DOM</font> </h2><br>  Die Komposition ist eine der wichtigsten Funktionen des Shadow DOM. Auf diese Weise k√∂nnen Webanwendungen erstellt werden, die beim Schreiben von HTML-Code verwendet werden.  W√§hrend dieses Vorgangs kombiniert der Programmierer die verschiedenen Bausteine ‚Äã‚Äã(Elemente), aus denen die Seite besteht, und verschachtelt sie gegebenenfalls ineinander.  Dies sind beispielsweise Elemente wie <code>&lt;div&gt;</code> , <code>&lt;header&gt;</code> , <code>&lt;form&gt;</code> und andere, die zum Erstellen von Webanwendungsschnittstellen verwendet werden, einschlie√ülich solcher, die als Container f√ºr andere Elemente dienen. <br><br>  Die Komposition bestimmt die F√§higkeit von Elementen wie <code>&lt;select&gt;</code> , <code>&lt;form&gt;</code> , <code>&lt;video&gt;</code> , andere HTML-Elemente als untergeordnete Elemente einzuschlie√üen, und die F√§higkeit, das spezielle Verhalten solcher Strukturen zu organisieren, die aus verschiedenen Elementen bestehen. <br><br>  Beispielsweise verf√ºgt das <code>&lt;select&gt;</code> -Element √ºber Mittel zum Rendern von <code>&lt;option&gt;</code> -Elementen in Form einer Dropdown-Liste mit dem vorbestimmten Inhalt der Elemente einer solchen Liste. <br><br>  Betrachten Sie einige der Funktionen des Shadow DOM, die beim Erstellen von Elementen verwendet werden. <br><br><h2>  <font color="#3AC1EF">Licht dom</font> </h2><br>  Light DOM ist das vom Benutzer Ihrer Komponente erstellte Markup.  Dieses DOM befindet sich au√üerhalb des Schatten-DOM der Komponente und ist ein untergeordnetes Element der Komponente.  Stellen Sie sich vor, Sie haben eine benutzerdefinierte Komponente mit dem Namen <code>&lt;better-button&gt;</code> , die die Funktionen des Standard-HTML-Elements <code>&lt;button&gt;</code> , und der Benutzer muss diesem neuen Element ein Bild und Text hinzuf√ºgen.  So sieht es aus: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  img  span -  Light DOM  extended-button --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Das <code>&lt;extended-button&gt;</code> -Element ist eine benutzerdefinierte Komponente, die vom Programmierer selbst beschrieben wird, und der HTML-Code in dieser Komponente ist das Light DOM - was der Benutzer dieser Komponente hinzugef√ºgt hat. <br><br>  Das Schatten-DOM in diesem Beispiel ist die Komponente <code>&lt;extended-button&gt;</code> .  Dies ist ein lokales Objektmodell einer Komponente, das ihre interne Struktur beschreibt, von der Au√üenwelt von CSS isoliert ist und die Implementierungsdetails der Komponente kapselt. <br><br><h2>  <font color="#3AC1EF">Abgeflachter Dom</font> </h2><br>  Der abgeflachte DOM-Baum zeigt an, wie der Browser die Komponente auf dem Bildschirm anzeigt, wobei das Licht-DOM und das Schatten-DOM kombiniert werden.  Es ist ein solcher DOM-Baum, der in den Entwicklertools angezeigt wird und auf der Seite angezeigt wird.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">‚Ä¶</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Muster</font> </h2><br>  Wenn Sie im HTML-Markup von Webseiten st√§ndig dieselben Strukturen verwenden m√ºssen, ist es hilfreich, eine bestimmte Vorlage zu verwenden, anstatt immer wieder denselben Code zu schreiben.  Dies war fr√ºher m√∂glich, aber jetzt wurde alles dank des HTML- <code>&lt;template&gt;</code> , das moderne Browser hervorragend unterst√ºtzt, erheblich vereinfacht.  Dieses Element und sein Inhalt werden nicht im DOM angezeigt, aber Sie k√∂nnen mit JavaScript damit arbeiten.  Betrachten Sie ein einfaches Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn Sie dieses Design in das HTML-Markup der Seite aufnehmen, wird der Inhalt des von ihm beschriebenen <code>&lt;p&gt;</code> -Tags erst auf dem Bildschirm angezeigt, wenn es explizit an das DOM des Dokuments angeh√§ngt wird.  Zum Beispiel k√∂nnte es so aussehen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-paragraph'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> templateContent = template.content; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(templateContent);</code> </pre> <br>  Es gibt andere M√∂glichkeiten, um den gleichen Effekt zu erzielen, aber wie bereits erw√§hnt, sind Vorlagen ein sehr praktisches Standardwerkzeug, das eine gute Browserunterst√ºtzung bietet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5dc/501/54c/5dc50154ca3bc462d1e9285334fe462e.png"></div><br>  <i><font color="#999999">HTML-Browser-Unterst√ºtzung f√ºr moderne Browser</font></i> <br><br>  Vorlagen sind an und f√ºr sich n√ºtzlich, aber ihre Funktionen werden bei Verwendung mit benutzerdefinierten Elementen vollst√§ndig offengelegt.  Benutzerdefinierte Elemente sind ein Thema f√ºr ein separates Material. <code>customElement</code> zu verstehen, was gerade passiert, muss ber√ºcksichtigt werden, dass der Programmierer mit der <code>customElement</code> Browser- <code>customElement</code> seine eigenen HTML-Tags beschreiben und angeben kann, wie die mit diesen Tags erstellten Elemente auf dem Bildschirm aussehen sollen. <br><br>  Definieren Sie eine Webkomponente, die unsere Vorlage als Inhalt f√ºr ihr Schatten-DOM verwendet.  Nennen Sie dieses neue Element <code>&lt;my-paragraph&gt;</code> : <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{  constructor() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();    let template = document.getElementById(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph');    let templateContent = template.content;    const shadowRoot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.attachShadow({mode: <span class="hljs-symbol"><span class="hljs-symbol">'ope</span></span>n'}).appendChild(templateContent.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } });</code> </pre> <br>  Das Wichtigste, worauf Sie achten sollten, ist, dass wir einen Klon des Vorlageninhalts, der mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.cloneNode ()</a> -Methode erstellt wurde, an die Schattenwurzel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeh√§ngt haben</a> . <br><br>  Da wir den Inhalt der Vorlage an das Schatten-DOM anh√§ngen, k√∂nnen wir einige Stilinformationen in die Vorlage im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">&lt;style&gt;</a> -Element aufnehmen, die dann im Benutzerelement gekapselt werden.  Dieses gesamte Schema funktioniert nicht wie erwartet, wenn Sie mit dem regul√§ren DOM anstelle des Schatten-DOM arbeiten. <br><br>  Beispielsweise kann eine Vorlage wie folgt ge√§ndert werden, indem Stilinformationen hinzugef√ºgt werden: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css">   </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">p</span></span></span><span class="css"> {     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: white;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background-color</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">#666</span></span></span><span class="css">;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">padding</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">5px</span></span></span><span class="css">;   } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Jetzt kann das von uns beschriebene Benutzerelement auf normalen Webseiten wie folgt verwendet werden: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Slots</font> </h2><br>  HTML-Vorlagen weisen mehrere Nachteile auf. Der Hauptnachteil besteht darin, dass die Vorlagen statische Markups enthalten, die es beispielsweise nicht erm√∂glichen, den Inhalt bestimmter Variablen mit ihrer Hilfe anzuzeigen, um mit ihnen auf die gleiche Weise wie mit Standard-HTML zu arbeiten Muster.  Hier kommt das <code>&lt;slot&gt;</code> -Tag ins Spiel. <br><br>  Slots k√∂nnen als Platzhalter wahrgenommen werden, mit denen Sie Ihren eigenen HTML-Code in die Vorlage aufnehmen k√∂nnen.  Auf diese Weise k√∂nnen Sie universelle HTML-Vorlagen erstellen und diese dann anpassbar machen, indem Sie ihnen Slots hinzuf√ºgen. <br><br>  Sehen Sie sich mit dem <code>&lt;slot&gt;</code> an, wie die obige Vorlage aussehen wird: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Default text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn der Inhalt des Slots nicht angegeben wird, wenn das Element im Markup enthalten ist, oder wenn der Browser die Arbeit mit Slots nicht unterst√ºtzt, enth√§lt das Element <code>&lt;my-paragraph&gt;</code> nur den Standardinhalt des <code>Default text</code> . <br><br>  Um den Inhalt des Slots festzulegen, m√ºssen Sie HTML-Code mit dem <code>slot</code> Attribut in das Element <code>&lt;my-paragraph&gt;</code> einf√ºgen, dessen Wert dem Namen des Slots entspricht, in dem Sie diesen Code platzieren m√∂chten. <br><br>  Nach wie vor kann es alles geben.  Zum Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Elemente, die in Slots platziert werden k√∂nnen, werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slotable-</a> Elemente bezeichnet. <br><br>  Bitte beachten Sie, dass wir im vorherigen Beispiel das <code>&lt;span&gt;</code> -Element zum Steckplatz hinzugef√ºgt haben, es ist das sogenannte Schlitzelement.  Es hat ein <code>slot</code> Attribut, dem der Wert <code>my-text</code> zugewiesen ist, dh derselbe Wert, der im <code>name</code> Attribut des in der Vorlage beschriebenen Slots verwendet wird. <br><br>  Nach der Verarbeitung des obigen Markups erstellt der Browser den folgenden abgeflachten DOM-Baum: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Achten Sie auf das Element <code>#shadow-root</code> .  Dies ist nur ein Indikator f√ºr die Existenz des Schatten-DOM. <br><br><h2>  <font color="#3AC1EF">Stilisierung</font> </h2><br>  Komponenten, die die Shadow DOM-Technologie verwenden, k√∂nnen auf einer gemeinsamen Basis gestaltet werden, sie k√∂nnen ihre eigenen Stile definieren oder Hooks in Form von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten CSS-Eigenschaften</a> bereitstellen, mit denen Komponentenbenutzer die Standardstile √ºberschreiben k√∂nnen. <br><br><h3>  <font color="#3AC1EF">‚ñç In Komponenten beschriebene Stile</font> </h3><br>  Die CSS-Isolierung ist eines der bemerkenswertesten Merkmale der Shadow DOM-Technologie.  Wir sprechen n√§mlich √ºber Folgendes: <br><br><ul><li>  CSS-Selektoren der Seite, auf der die entsprechende Komponente platziert ist, haben keinen Einfluss darauf, was sie enth√§lt. </li><li>  Die in der Komponente beschriebenen Stile wirken sich nicht auf die Seite aus.  Sie sind im Host-Element isoliert. </li></ul><br>  CSS-Selektoren, die im Schatten-DOM verwendet werden, gelten lokal f√ºr den Komponenteninhalt.  In der Praxis bedeutet dies die M√∂glichkeit, dieselben Bezeichner und Klassennamen in verschiedenen Komponenten wiederzuverwenden, ohne sich um Namenskonflikte sorgen zu m√ºssen.  Einfache CSS-Selektoren bedeuten auch eine bessere Leistung f√ºr die L√∂sungen, in denen sie verwendet werden. <br><br>  Schauen Sie sich das Element <code>#shadow-root</code> , das einige Stile definiert: <br><br><pre> <code class="hljs xml">#shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: white; } </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container-items</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: inline-flex; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container-items"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Alle oben genannten Stile sind lokal f√ºr <code>#shadow-root</code> . <br><br>  Dar√ºber hinaus k√∂nnen Sie das <code>&lt;link&gt;</code> -Tag verwenden, um externe Stylesheets in <code>#shadow-root</code> .  Solche Stile werden auch lokal sein. <br><br><h3>  <font color="#3AC1EF">‚ñçPseudoklasse: Host</font> </h3><br>  Mit der Pseudoklasse <code>:host</code> k√∂nnen Sie auf ein Element zugreifen, das einen Schatten-DOM-Baum enth√§lt, und dieses Element formatieren: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: block; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*       display: inline */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Denken Sie bei der Verwendung der Pseudoklasse <code>:host</code> daran, dass die Regeln der √ºbergeordneten Seite eine h√∂here Priorit√§t haben als diejenigen, die im Element unter Verwendung dieser Pseudoklasse angegeben sind.  Auf diese Weise k√∂nnen Benutzer die darin definierten Hostkomponentenstile von au√üen √ºberschreiben.  Dar√ºber hinaus funktioniert die Pseudoklasse <code>:host</code> nur im Kontext des Schattenstammelements, Sie k√∂nnen sie jedoch nicht au√üerhalb des Schatten-DOM-Baums verwenden. <br><br>  Mit der Funktionsform der Pseudoklasse: <code>:host(&lt;selector&gt;)</code> k√∂nnen Sie auf das Host-Element zugreifen, wenn es mit dem angegebenen <code>&lt;selector&gt;</code> -Element √ºbereinstimmt.  Auf diese Weise k√∂nnen Komponenten Verhalten kapseln, das auf Benutzeraktionen oder √Ñnderungen im Status einer Komponente reagiert, und interne Knoten basierend auf der Hostkomponente formatieren: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:hover)</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-attr"><span class="css"><span class="hljs-selector-attr">[disabled]</span></span></span><span class="css">) { </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*      -  disabled. */</span></span></span><span class="css">   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: grey;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">pointer-events</span></span></span><span class="css">: none;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(.pink)</span></span></span><span class="css"> &gt; </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#tabs</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: pink; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*     #tabs   -  class="pink". */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçThemen und Elemente mit einer Pseudoklasse: Host-Kontext (&lt;Selektor&gt;)</font> </h3><br>  Die <code>:host-context(&lt;selector&gt;)</code> mit dem Host-Element <code>:host-context(&lt;selector&gt;)</code> , wenn es oder einer seiner Vorfahren mit dem angegebenen <code>&lt;selector&gt;</code> -Element √ºbereinstimmt. <br><br>  Ein h√§ufiger Anwendungsfall f√ºr diese Funktion ist das Stylen von Elementen mit Themen.  Beispielsweise werden Themen h√§ufig verwendet, indem den Tags <code>&lt;html&gt;</code> oder <code>&lt;body&gt;</code> die entsprechende Klasse zugewiesen wird: <br><br><pre> <code class="hljs javascript">&lt;body <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"lightheme"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ‚Ä¶ </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Die <code>:host-context(.lightheme)</code> wird auf <code>&lt;fancy-tabs&gt;</code> angewendet, wenn dieses Element ein Nachkomme von <code>.lightteme</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host-context(.lightheme)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br>  Das Konstrukt <code>:host-context()</code> kann n√ºtzlich sein, um Themen anzuwenden. Zu diesem Zweck ist es jedoch besser, Hooks mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten CSS-Eigenschaften zu verwenden</a> . <br><br><h3>  <font color="#3AC1EF">‚ñç Gestalten Sie das Host-Element der Komponente von au√üen</font> </h3><br>  Das Host-Element der Komponente kann extern mit dem Namen des Tags als Selektor gestaltet werden: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre> <br>  Externe Stile haben Vorrang vor im Schatten-DOM definierten Stilen. <br>  Angenommen, ein Benutzer erstellt den folgenden Selektor: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">500px</span></span>; }</code> </pre> <br>  Die in der Komponente selbst definierte Regel wird √ºberschrieben: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">300px</span></span>; }</code> </pre> <br>  Mit diesem Ansatz k√∂nnen Sie nur die Komponente selbst stilisieren.  Wie kann die interne Struktur einer Komponente stilisiert werden?  Zu diesem Zweck werden benutzerdefinierte CSS-Eigenschaften verwendet. <br><br><h3>  <font color="#3AC1EF">‚ñçErstellen von Style-Hooks mithilfe benutzerdefinierter CSS-Eigenschaften</font> </h3><br>  Benutzer k√∂nnen die Stile der internen Strukturen von Komponenten anpassen, wenn der Autor der Komponente ihnen mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten CSS-Eigenschaften</a> Stil-Hooks zur Verf√ºgung stellt. <br><br>  Dieser Ansatz basiert auf einem √§hnlichen Mechanismus wie bei der Arbeit mit <code>&lt;slot&gt;</code> -Tags, gilt jedoch in diesem Fall f√ºr Stile. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- main page --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> custom-container {   margin-bottom: 60px;    - custom-container-bg: black; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">background</span></span></span><span class="hljs-tag">&gt;</span></span>‚Ä¶<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Folgendes befindet sich im Schatten-DOM-Baum: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host(</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[background]</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">var</span></span>( - custom-container-bg, #CECECE); <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre> <br>  In diesem Fall verwendet die Komponente Schwarz als Hintergrundfarbe, da der Benutzer dies angegeben hat.  Andernfalls <code>#CECECE</code> die Hintergrundfarbe <code>#CECECE</code> . <br><br>  Als Autor der Komponente sind Sie daf√ºr verantwortlich, den Benutzern mitzuteilen, welche spezifischen CSS-Eigenschaften sie verwenden k√∂nnen.  Betrachten Sie diesen Teil der offenen Oberfl√§che Ihrer Komponente. <br><br><h2>  <font color="#3AC1EF">JavaScript-API f√ºr die Arbeit mit Slots</font> </h2><br>  Die Shadow DOM-API bietet die M√∂glichkeit, mit Slots zu arbeiten. <br><br><h3>  <font color="#3AC1EF">‚ñçEvent Slotchange</font> </h3><br>  Das <code>slotchange</code> Ereignis <code>slotchange</code> , wenn sich die im Slot platzierten Knoten √§ndern.  Wenn ein Benutzer beispielsweise untergeordnete Knoten im Light DOM hinzuf√ºgt oder entfernt: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#some_slot'</span></span>); slot.addEventListener(<span class="hljs-string"><span class="hljs-string">'slotchange'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Light DOM change'</span></span>); });</code> </pre> <br>  Um andere Arten von √Ñnderungen im Light DOM zu verfolgen, k√∂nnen Sie <code>MutationObserver</code> im Konstruktor des Elements verwenden.  Lesen Sie hier mehr dar√ºber. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode zugewiesenNodes ()</font> </h3><br>  Die Methode <code>assignedNodes()</code> kann hilfreich sein, wenn Sie wissen m√ºssen, welche Elemente dem Steckplatz zugeordnet sind.  Durch Aufrufen der Methode <code>slot.assignedNodes()</code> k√∂nnen Sie genau herausfinden, welche Elemente vom Steckplatz angezeigt werden.  Mit der Option <code>{flatten: true}</code> k√∂nnen Sie den Standardinhalt des Steckplatzes abrufen (angezeigt, wenn keine Knoten daran angeschlossen waren). <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'slot1'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Default content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Stellen Sie sich vor, dieser Steckplatz befindet sich in der Komponente <code>&lt;my-container&gt;</code> . <br><br>  Werfen wir einen Blick auf die verschiedenen Verwendungszwecke dieser Komponente und darauf, was zur√ºckgegeben wird, wenn die Methode <code>assignedNodes()</code> aufgerufen wird. <br><br>  Im ersten Fall f√ºgen wir dem Slot unseren eigenen Inhalt hinzu: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slot1"</span></span></span><span class="hljs-tag">&gt;</span></span> container text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In diesem Fall gibt der Aufruf von <code>assignedNodes()</code> <code>[ container text ]</code> .  Beachten Sie, dass dieser Wert ein Array von Knoten ist. <br><br>  Im zweiten Fall f√ºllen wir den Slot nicht mit unserem eigenen Inhalt: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Der Aufruf von <code>assignedNodes()</code> gibt ein leeres Array zur√ºck - <code>[]</code> . <br><br>  Wenn Sie jedoch den Parameter <code>{flatten: true}</code> an diese Methode √ºbergeben, gibt der Aufruf f√ºr dasselbe Element den Standardinhalt zur√ºck: <code>[ Default content ]</code> <p> <code>[ Default content ]</code> </p>  <code>[ Default content ]</code> . <br><br>  Um auf ein Element innerhalb des Steckplatzes zuzugreifen, k√∂nnen Sie au√üerdem <code>assignedNodes()</code> aufrufen, um zu erfahren, welchem ‚Äã‚ÄãKomponentensteckplatz Ihr Element zugewiesen ist. <br><br><h2>  <font color="#3AC1EF">Ereignismodell</font> </h2><br>  Lassen Sie uns dar√ºber sprechen, was passiert, wenn ein Ereignis im Schatten-DOM-Baum angezeigt wird.  Der Zweck des Ereignisses wird unter Ber√ºcksichtigung der von der Shadow DOM-Technologie unterst√ºtzten Kapselung festgelegt.  Wenn ein Ereignis umgeleitet wird, sieht es so aus, als stamme es von der Komponente selbst und nicht von ihrem internen Element, das sich im Schatten-DOM-Baum befindet und Teil dieser Komponente ist. <br><br>  Hier ist eine Liste von Ereignissen, die vom DOM-Schattenbaum √ºbergeben werden (dieses Verhalten ist f√ºr einige Ereignisse nicht charakteristisch): <br><br><ul><li>  <code>focusin</code> : <code>blur</code> , <code>focus</code> , <code>focusin</code> , <code>focusout</code> . </li><li>  <code>dblclick</code> s: <code>click</code> , <code>dblclick</code> , <code>mousedown</code> , <code>mouseenter</code> , <code>mousemove</code> und andere. </li><li>  Rad Ereignisse: <code>wheel</code> . </li><li>  <code>beforeinput</code> : vor <code>beforeinput</code> , <code>input</code> . </li><li>  Tastaturereignisse: <code>keydown</code> , <code>keyup</code> . </li><li>  Kompositionsereignisse: <code>compositionstart</code> , <code>compositionupdate</code> , <code>compositionend</code> . </li><li>  Drag Events: <code>dragstart</code> , <code>drag</code> , <code>dragend</code> , <code>drop</code> und so weiter. </li></ul><br><h2>  <font color="#3AC1EF">Benutzerdefinierte Ereignisse</font> </h2><br>  Benutzerereignisse verlassen standardm√§√üig nicht den DOM-Schattenbaum.  Wenn Sie ein Ereignis ausl√∂sen m√∂chten und m√∂chten, dass es das Schatten-DOM verl√§sst, m√ºssen Sie ihm die Parameter <code>bubbles: true</code> bereitstellen <code>bubbles: true</code> und <code>composed: true</code> .  So sieht die Herausforderung einer √§hnlichen Veranstaltung aus: <br><br><pre> <code class="hljs axapta">var <span class="hljs-keyword"><span class="hljs-keyword">container</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#container'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">container</span></span>.dispatchEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">'containerchanged'</span></span>, {bubbles: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, composed: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}));</code> </pre> <br><h2>  <font color="#3AC1EF">Unterst√ºtzung f√ºr Shadow DOM-Browser</font> </h2><br>  Um herauszufinden, ob der Browser die Shadow DOM-Technologie unterst√ºtzt, k√∂nnen Sie das Vorhandensein von <code>attachShadow</code> : <br><br><pre> <code class="hljs erlang-repl">const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;</code> </pre> <br>  Hier finden Sie Informationen dar√ºber, wie verschiedene Browser diese Technologie unterst√ºtzen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/d78/c47/bead78c47c464b5059576df077613803.png"></div><br>  <i><font color="#999999">Unterst√ºtzung f√ºr die Shadow DOM-Technologie in Browsern</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Schatten-DOM-Baum verh√§lt sich nicht wie ein normaler DOM-Baum.  Laut dem Autor dieses Materials dr√ºckt sich dies in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack-</a> Bibliothek insbesondere in der Komplikation des Verfahrens zum Verfolgen von DOM-√Ñnderungen aus, deren Informationen erforderlich sind, um zu reproduzieren, was mit der Seite passiert ist.  <code>MutationObserver</code> verwendet, um √Ñnderungen zu verfolgen.  In diesem Fall l√∂st der DOM-Schattenbaum das <code>MutationObserver</code> Ereignis nicht im globalen Bereich aus, was dazu f√ºhrt, dass spezielle Ans√§tze f√ºr die Arbeit mit Komponenten verwendet werden m√ºssen, die das Schatten-DOM verwenden. <br><br>  ,     -  Shadow DOM,     ,   , ,     . <br><br>  <b>Liebe Leser!</b>    -,     Shadow DOM? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415881/">https://habr.com/ru/post/de415881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415865/index.html">Markdown-Wissensdatenbank (oder Blog oder Projektdokumentation)</a></li>
<li><a href="../de415867/index.html">Y Combinator Investor School: Ron Conway</a></li>
<li><a href="../de415871/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 321 (25. Juni - 1. Juli 2018)</a></li>
<li><a href="../de415875/index.html">Ein Wort an den Linguisten: Was ist, wenn Computer besser sprechen?</a></li>
<li><a href="../de415879/index.html">Digitale Veranstaltungen in Moskau vom 2. bis 8. Juli</a></li>
<li><a href="../de415887/index.html">Welche Art von Spinnenrobotern fliegen √ºber Stadien und schie√üen Fu√üball. Interview mit dem Sch√∂pfer von Robycam</a></li>
<li><a href="../de415891/index.html">Was sind die coolen Fortsetzungsspiele?</a></li>
<li><a href="../de415893/index.html">So machen Sie Java-Prozesse unter Linux / Docker einfach und unkompliziert</a></li>
<li><a href="../de415895/index.html">Das wichtigste Muster in der Programmierung</a></li>
<li><a href="../de415897/index.html">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil zwei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>