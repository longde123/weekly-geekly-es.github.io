<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎉 👨🏻‍💻 👼🏽 Funktionsweise von JS: Shadow DOM-Technologie und Webkomponenten 🙋🏾 🤰🏼 👩‍👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Lesen empfehlen] Die anderen 19 Teile des Zyklus  Teil 1: Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel 
 Teil 2: Informationen zu V8-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionsweise von JS: Shadow DOM-Technologie und Webkomponenten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415881/"><div class="spoiler">  <b class="spoiler_title">[Lesen empfehlen] Die anderen 19 Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überblick über die Engine, Laufzeitmechanismen, Aufrufstapel</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu V8-Interna und Codeoptimierung</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwalten des Speichers, vier Arten von Speicherlecks und Umgang mit ihnen</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Async und fünf Möglichkeiten zur Verbesserung Ihres Codes mit Async / Warten</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSocket und HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was soll ich wählen?</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Funktionen und Umfang von WebAssembly</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Worker und fünf Nutzungsszenarien</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Servicemitarbeiter</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Push-Benachrichtigungen</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verfolgen Sie Änderungen im DOM mit MutationObserver</a> <br>  Teil 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Engines für Webseiten und Tipps zur Optimierung ihrer Leistung</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 12: Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerksubsystem von Browsern, um dessen Leistung und Sicherheit zu optimieren</a> <br>  Teil 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Animation mit CSS und JavaScript</a> <br>  Teil 14: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Abstrakte Syntaxbäume, Analyse und deren Optimierung</a> <br>  Teil 15: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Klassen und Vererbung, Transpilation in Babel und TypeScript</a> <br>  Teil 16: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Speicher</a> <br>  Teil 17: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Shadow DOM-Technologie und Webkomponenten</a> <br>  Teil 18: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: WebRTC- und P2P-Kommunikationsmechanismen</a> <br>  Teil 19: Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JS: Benutzerdefinierte Elemente</a> </div></div><br>  In der Übersetzung von 17 Teilen der Materialien, die sich mit den Funktionen von allem befassen, was irgendwie mit JavaScript verbunden ist, werden wir heute über Webkomponenten und verschiedene Standards sprechen, die darauf abzielen, mit ihnen zu arbeiten.  Besonderes Augenmerk wird auf die Shadow DOM-Technologie gelegt. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/8k/li/z5/8kliz5q5jcynt6ggr2rqa-fancc.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Rückblick</font> </h2><br>  Webkomponenten sind eine Familie von APIs, mit denen neue DOM-Elemente beschrieben werden, die zur Wiederverwendung geeignet sind.  Die Funktionalität solcher Elemente ist vom Rest des Codes getrennt, sie können in Webanwendungen unseres eigenen Designs verwendet werden. <br><br>  Es gibt vier Technologien für Webkomponenten: <br><br><ul><li>  Schatten-DOM (Schatten-DOM) </li><li>  HTML-Vorlagen (HTML-Vorlagen) </li><li>  Benutzerdefinierte Elemente </li><li>  HTML-Importe (HTML-Import) </li></ul><br>  In diesem Artikel werden wir über die Shadow DOM-Technologie sprechen, mit der komponentenbasierte Anwendungen erstellt werden können.  Es bietet Möglichkeiten zur Lösung häufig auftretender Probleme bei der Webentwicklung, auf die Sie möglicherweise bereits gestoßen sind: <br><br><ul><li> DOM-Isolation: Die Komponente verfügt über einen isolierten DOM-Baum (dies bedeutet, dass der Befehl <code>document.querySelector()</code> keinen Zugriff auf den Knoten im Schatten-DOM der Komponente ermöglicht).  Darüber hinaus vereinfacht es das CSS-Auswahlsystem in Webanwendungen, da die DOM-Komponenten isoliert sind, sodass der Entwickler dieselben universellen Bezeichner und Klassennamen in verschiedenen Komponenten verwenden kann, ohne sich über mögliche Namenskonflikte Gedanken machen zu müssen. </li><li>  CSS-Isolation: Die im Schatten-DOM beschriebenen CSS-Regeln sind darauf beschränkt.  Diese Stile verlassen das Element nicht und werden nicht mit anderen Seitenstilen gemischt. </li><li>  Zusammensetzung: Entwicklung einer deklarativen API für Markup-basierte Komponenten. </li></ul><br><h2>  <font color="#3AC1EF">Shadow DOM-Technologie</font> </h2><br>  Es wird davon ausgegangen, dass Sie bereits mit dem Konzept des DOM und den zugehörigen APIs vertraut sind.  Wenn dies nicht der Fall ist, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Material lesen. <br><br>  Das Shadow-DOM ist im Grunde dasselbe wie ein normales DOM, jedoch mit zwei Unterschieden: <br><br><ul><li>  Das erste ist, wie das Schatten-DOM erstellt und verwendet wird, insbesondere geht es um die Beziehung des Schatten-DOM zum Rest der Seite. </li><li>  Das zweite ist das Verhalten des Schatten-DOM in Bezug auf die Seite. </li></ul><br>  Bei der Arbeit mit dem DOM werden DOM-Knoten erstellt, die als untergeordnete Elemente mit anderen Elementen der Seite verknüpft werden.  Bei der Shadow-DOM-Technologie wird ein isolierter DOM-Baum erstellt, der das Element verbindet, jedoch von seinen normalen untergeordneten Elementen getrennt ist. <br><br>  Dieser isolierte Teilbaum wird als Schattenbaum bezeichnet.  Das Element, an das ein solcher Baum angehängt ist, wird als Schattenhost bezeichnet.  Alles, was dem Schatten-DOM-Teilbaum hinzugefügt wird, ist lokal für das Element, an das es angehängt ist, einschließlich der mit <code>&lt;style&gt;</code> -Tags beschriebenen <code>&lt;style&gt;</code> .  Auf diese Weise wird die CSS-Isolierung durch die Shadow DOM-Technologie bereitgestellt. <br><br><h2>  <font color="#3AC1EF">Erstellen eines Schatten-DOM</font> </h2><br>  Die Schattenwurzel ist ein Teil des Dokuments, das an das Hostelement angehängt wird.  Ein Element erhält ein Schatten-DOM, wenn ein Schattenwurzelelement daran angehängt ist.  Um ein Schatten-DOM für ein bestimmtes Element zu erstellen, müssen Sie einen Befehl des Formulars <code>element.attachShadow()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowRoot = header.attachShadow({<span class="hljs-attr"><span class="hljs-attr">mode</span></span>: <span class="hljs-string"><span class="hljs-string">'open'</span></span>}); shadowRoot.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'&lt;p&gt; Shadow DOM &lt;/p&gt;'</span></span>);</code> </pre> <br>  Es ist zu beachten, dass in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> Shadow-DOM- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> eine Liste von Elementen enthalten ist, mit denen DOM-Shadow-Teilbäume nicht verbunden werden können. <br><br><h2>  <font color="#3AC1EF">Komposition im Schatten DOM</font> </h2><br>  Die Komposition ist eine der wichtigsten Funktionen des Shadow DOM. Auf diese Weise können Webanwendungen erstellt werden, die beim Schreiben von HTML-Code verwendet werden.  Während dieses Vorgangs kombiniert der Programmierer die verschiedenen Bausteine ​​(Elemente), aus denen die Seite besteht, und verschachtelt sie gegebenenfalls ineinander.  Dies sind beispielsweise Elemente wie <code>&lt;div&gt;</code> , <code>&lt;header&gt;</code> , <code>&lt;form&gt;</code> und andere, die zum Erstellen von Webanwendungsschnittstellen verwendet werden, einschließlich solcher, die als Container für andere Elemente dienen. <br><br>  Die Komposition bestimmt die Fähigkeit von Elementen wie <code>&lt;select&gt;</code> , <code>&lt;form&gt;</code> , <code>&lt;video&gt;</code> , andere HTML-Elemente als untergeordnete Elemente einzuschließen, und die Fähigkeit, das spezielle Verhalten solcher Strukturen zu organisieren, die aus verschiedenen Elementen bestehen. <br><br>  Beispielsweise verfügt das <code>&lt;select&gt;</code> -Element über Mittel zum Rendern von <code>&lt;option&gt;</code> -Elementen in Form einer Dropdown-Liste mit dem vorbestimmten Inhalt der Elemente einer solchen Liste. <br><br>  Betrachten Sie einige der Funktionen des Shadow DOM, die beim Erstellen von Elementen verwendet werden. <br><br><h2>  <font color="#3AC1EF">Licht dom</font> </h2><br>  Light DOM ist das vom Benutzer Ihrer Komponente erstellte Markup.  Dieses DOM befindet sich außerhalb des Schatten-DOM der Komponente und ist ein untergeordnetes Element der Komponente.  Stellen Sie sich vor, Sie haben eine benutzerdefinierte Komponente mit dem Namen <code>&lt;better-button&gt;</code> , die die Funktionen des Standard-HTML-Elements <code>&lt;button&gt;</code> , und der Benutzer muss diesem neuen Element ein Bild und Text hinzufügen.  So sieht es aus: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  img  span -  Light DOM  extended-button --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Das <code>&lt;extended-button&gt;</code> -Element ist eine benutzerdefinierte Komponente, die vom Programmierer selbst beschrieben wird, und der HTML-Code in dieser Komponente ist das Light DOM - was der Benutzer dieser Komponente hinzugefügt hat. <br><br>  Das Schatten-DOM in diesem Beispiel ist die Komponente <code>&lt;extended-button&gt;</code> .  Dies ist ein lokales Objektmodell einer Komponente, das ihre interne Struktur beschreibt, von der Außenwelt von CSS isoliert ist und die Implementierungsdetails der Komponente kapselt. <br><br><h2>  <font color="#3AC1EF">Abgeflachter Dom</font> </h2><br>  Der abgeflachte DOM-Baum zeigt an, wie der Browser die Komponente auf dem Bildschirm anzeigt, wobei das Licht-DOM und das Schatten-DOM kombiniert werden.  Es ist ein solcher DOM-Baum, der in den Entwicklertools angezeigt wird und auf der Seite angezeigt wird.  Es könnte ungefähr so ​​aussehen: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">…</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"boot.png"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>Launch<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">extended-button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Muster</font> </h2><br>  Wenn Sie im HTML-Markup von Webseiten ständig dieselben Strukturen verwenden müssen, ist es hilfreich, eine bestimmte Vorlage zu verwenden, anstatt immer wieder denselben Code zu schreiben.  Dies war früher möglich, aber jetzt wurde alles dank des HTML- <code>&lt;template&gt;</code> , das moderne Browser hervorragend unterstützt, erheblich vereinfacht.  Dieses Element und sein Inhalt werden nicht im DOM angezeigt, aber Sie können mit JavaScript damit arbeiten.  Betrachten Sie ein einfaches Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn Sie dieses Design in das HTML-Markup der Seite aufnehmen, wird der Inhalt des von ihm beschriebenen <code>&lt;p&gt;</code> -Tags erst auf dem Bildschirm angezeigt, wenn es explizit an das DOM des Dokuments angehängt wird.  Zum Beispiel könnte es so aussehen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> template = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'my-paragraph'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> templateContent = template.content; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(templateContent);</code> </pre> <br>  Es gibt andere Möglichkeiten, um den gleichen Effekt zu erzielen, aber wie bereits erwähnt, sind Vorlagen ein sehr praktisches Standardwerkzeug, das eine gute Browserunterstützung bietet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5dc/501/54c/5dc50154ca3bc462d1e9285334fe462e.png"></div><br>  <i><font color="#999999">HTML-Browser-Unterstützung für moderne Browser</font></i> <br><br>  Vorlagen sind an und für sich nützlich, aber ihre Funktionen werden bei Verwendung mit benutzerdefinierten Elementen vollständig offengelegt.  Benutzerdefinierte Elemente sind ein Thema für ein separates Material. <code>customElement</code> zu verstehen, was gerade passiert, muss berücksichtigt werden, dass der Programmierer mit der <code>customElement</code> Browser- <code>customElement</code> seine eigenen HTML-Tags beschreiben und angeben kann, wie die mit diesen Tags erstellten Elemente auf dem Bildschirm aussehen sollen. <br><br>  Definieren Sie eine Webkomponente, die unsere Vorlage als Inhalt für ihr Schatten-DOM verwendet.  Nennen Sie dieses neue Element <code>&lt;my-paragraph&gt;</code> : <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{  constructor() {    <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();    let template = document.getElementById(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-paragraph');    let templateContent = template.content;    const shadowRoot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.attachShadow({mode: <span class="hljs-symbol"><span class="hljs-symbol">'ope</span></span>n'}).appendChild(templateContent.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } });</code> </pre> <br>  Das Wichtigste, worauf Sie achten sollten, ist, dass wir einen Klon des Vorlageninhalts, der mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.cloneNode ()</a> -Methode erstellt wurde, an die Schattenwurzel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angehängt haben</a> . <br><br>  Da wir den Inhalt der Vorlage an das Schatten-DOM anhängen, können wir einige Stilinformationen in die Vorlage im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">&lt;style&gt;</a> -Element aufnehmen, die dann im Benutzerelement gekapselt werden.  Dieses gesamte Schema funktioniert nicht wie erwartet, wenn Sie mit dem regulären DOM anstelle des Schatten-DOM arbeiten. <br><br>  Beispielsweise kann eine Vorlage wie folgt geändert werden, indem Stilinformationen hinzugefügt werden: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css">   </span><span class="hljs-selector-tag"><span class="css"><span class="hljs-selector-tag">p</span></span></span><span class="css"> {     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: white;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background-color</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">#666</span></span></span><span class="css">;     </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">padding</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">5px</span></span></span><span class="css">;   } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Paragraph content. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Jetzt kann das von uns beschriebene Benutzerelement auf normalen Webseiten wie folgt verwendet werden: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Slots</font> </h2><br>  HTML-Vorlagen weisen mehrere Nachteile auf. Der Hauptnachteil besteht darin, dass die Vorlagen statische Markups enthalten, die es beispielsweise nicht ermöglichen, den Inhalt bestimmter Variablen mit ihrer Hilfe anzuzeigen, um mit ihnen auf die gleiche Weise wie mit Standard-HTML zu arbeiten Muster.  Hier kommt das <code>&lt;slot&gt;</code> -Tag ins Spiel. <br><br>  Slots können als Platzhalter wahrgenommen werden, mit denen Sie Ihren eigenen HTML-Code in die Vorlage aufnehmen können.  Auf diese Weise können Sie universelle HTML-Vorlagen erstellen und diese dann anpassbar machen, indem Sie ihnen Slots hinzufügen. <br><br>  Sehen Sie sich mit dem <code>&lt;slot&gt;</code> an, wie die obige Vorlage aussehen wird: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-paragraph"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Default text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Wenn der Inhalt des Slots nicht angegeben wird, wenn das Element im Markup enthalten ist, oder wenn der Browser die Arbeit mit Slots nicht unterstützt, enthält das Element <code>&lt;my-paragraph&gt;</code> nur den Standardinhalt des <code>Default text</code> . <br><br>  Um den Inhalt des Slots festzulegen, müssen Sie HTML-Code mit dem <code>slot</code> Attribut in das Element <code>&lt;my-paragraph&gt;</code> einfügen, dessen Wert dem Namen des Slots entspricht, in dem Sie diesen Code platzieren möchten. <br><br>  Nach wie vor kann es alles geben.  Zum Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Elemente, die in Slots platziert werden können, werden als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slotable-</a> Elemente bezeichnet. <br><br>  Bitte beachten Sie, dass wir im vorherigen Beispiel das <code>&lt;span&gt;</code> -Element zum Steckplatz hinzugefügt haben, es ist das sogenannte Schlitzelement.  Es hat ein <code>slot</code> Attribut, dem der Wert <code>my-text</code> zugewiesen ist, dh derselbe Wert, der im <code>name</code> Attribut des in der Vorlage beschriebenen Slots verwendet wird. <br><br>  Nach der Verarbeitung des obigen Markups erstellt der Browser den folgenden abgeflachten DOM-Baum: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-text"</span></span></span><span class="hljs-tag">&gt;</span></span>Let's have some different text!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-paragraph</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Achten Sie auf das Element <code>#shadow-root</code> .  Dies ist nur ein Indikator für die Existenz des Schatten-DOM. <br><br><h2>  <font color="#3AC1EF">Stilisierung</font> </h2><br>  Komponenten, die die Shadow DOM-Technologie verwenden, können auf einer gemeinsamen Basis gestaltet werden, sie können ihre eigenen Stile definieren oder Hooks in Form von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten CSS-Eigenschaften</a> bereitstellen, mit denen Komponentenbenutzer die Standardstile überschreiben können. <br><br><h3>  <font color="#3AC1EF">▍ In Komponenten beschriebene Stile</font> </h3><br>  Die CSS-Isolierung ist eines der bemerkenswertesten Merkmale der Shadow DOM-Technologie.  Wir sprechen nämlich über Folgendes: <br><br><ul><li>  CSS-Selektoren der Seite, auf der die entsprechende Komponente platziert ist, haben keinen Einfluss darauf, was sie enthält. </li><li>  Die in der Komponente beschriebenen Stile wirken sich nicht auf die Seite aus.  Sie sind im Host-Element isoliert. </li></ul><br>  CSS-Selektoren, die im Schatten-DOM verwendet werden, gelten lokal für den Komponenteninhalt.  In der Praxis bedeutet dies die Möglichkeit, dieselben Bezeichner und Klassennamen in verschiedenen Komponenten wiederzuverwenden, ohne sich um Namenskonflikte sorgen zu müssen.  Einfache CSS-Selektoren bedeuten auch eine bessere Leistung für die Lösungen, in denen sie verwendet werden. <br><br>  Schauen Sie sich das Element <code>#shadow-root</code> , das einige Stile definiert: <br><br><pre> <code class="hljs xml">#shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: white; } </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#container-items</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: inline-flex; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container-items"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Alle oben genannten Stile sind lokal für <code>#shadow-root</code> . <br><br>  Darüber hinaus können Sie das <code>&lt;link&gt;</code> -Tag verwenden, um externe Stylesheets in <code>#shadow-root</code> .  Solche Stile werden auch lokal sein. <br><br><h3>  <font color="#3AC1EF">▍Pseudoklasse: Host</font> </h3><br>  Mit der Pseudoklasse <code>:host</code> können Sie auf ein Element zugreifen, das einen Schatten-DOM-Baum enthält, und dieses Element formatieren: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">display</span></span></span><span class="css">: block; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*       display: inline */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Denken Sie bei der Verwendung der Pseudoklasse <code>:host</code> daran, dass die Regeln der übergeordneten Seite eine höhere Priorität haben als diejenigen, die im Element unter Verwendung dieser Pseudoklasse angegeben sind.  Auf diese Weise können Benutzer die darin definierten Hostkomponentenstile von außen überschreiben.  Darüber hinaus funktioniert die Pseudoklasse <code>:host</code> nur im Kontext des Schattenstammelements, Sie können sie jedoch nicht außerhalb des Schatten-DOM-Baums verwenden. <br><br>  Mit der Funktionsform der Pseudoklasse: <code>:host(&lt;selector&gt;)</code> können Sie auf das Host-Element zugreifen, wenn es mit dem angegebenen <code>&lt;selector&gt;</code> -Element übereinstimmt.  Auf diese Weise können Komponenten Verhalten kapseln, das auf Benutzeraktionen oder Änderungen im Status einer Komponente reagiert, und interne Knoten basierend auf der Hostkomponente formatieren: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="css"> </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:hover)</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">1</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(</span></span></span><span class="hljs-selector-attr"><span class="css"><span class="hljs-selector-attr">[disabled]</span></span></span><span class="css">) { </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*      -  disabled. */</span></span></span><span class="css">   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">background</span></span></span><span class="css">: grey;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">pointer-events</span></span></span><span class="css">: none;   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">opacity</span></span></span><span class="css">: </span><span class="hljs-number"><span class="css"><span class="hljs-number">0.4</span></span></span><span class="css">; } </span><span class="hljs-selector-pseudo"><span class="css"><span class="hljs-selector-pseudo">:host(.pink)</span></span></span><span class="css"> &gt; </span><span class="hljs-selector-id"><span class="css"><span class="hljs-selector-id">#tabs</span></span></span><span class="css"> {   </span><span class="hljs-attribute"><span class="css"><span class="hljs-attribute">color</span></span></span><span class="css">: pink; </span><span class="hljs-comment"><span class="css"><span class="hljs-comment">/*     #tabs   -  class="pink". */</span></span></span><span class="css"> } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Themen und Elemente mit einer Pseudoklasse: Host-Kontext (&lt;Selektor&gt;)</font> </h3><br>  Die <code>:host-context(&lt;selector&gt;)</code> mit dem Host-Element <code>:host-context(&lt;selector&gt;)</code> , wenn es oder einer seiner Vorfahren mit dem angegebenen <code>&lt;selector&gt;</code> -Element übereinstimmt. <br><br>  Ein häufiger Anwendungsfall für diese Funktion ist das Stylen von Elementen mit Themen.  Beispielsweise werden Themen häufig verwendet, indem den Tags <code>&lt;html&gt;</code> oder <code>&lt;body&gt;</code> die entsprechende Klasse zugewiesen wird: <br><br><pre> <code class="hljs javascript">&lt;body <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"lightheme"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> … </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">body</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Die <code>:host-context(.lightheme)</code> wird auf <code>&lt;fancy-tabs&gt;</code> angewendet, wenn dieses Element ein Nachkomme von <code>.lightteme</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host-context(.lightheme)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br>  Das Konstrukt <code>:host-context()</code> kann nützlich sein, um Themen anzuwenden. Zu diesem Zweck ist es jedoch besser, Hooks mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten CSS-Eigenschaften zu verwenden</a> . <br><br><h3>  <font color="#3AC1EF">▍ Gestalten Sie das Host-Element der Komponente von außen</font> </h3><br>  Das Host-Element der Komponente kann extern mit dem Namen des Tags als Selektor gestaltet werden: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre> <br>  Externe Stile haben Vorrang vor im Schatten-DOM definierten Stilen. <br>  Angenommen, ein Benutzer erstellt den folgenden Selektor: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">custom-container</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">500px</span></span>; }</code> </pre> <br>  Die in der Komponente selbst definierte Regel wird überschrieben: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">300px</span></span>; }</code> </pre> <br>  Mit diesem Ansatz können Sie nur die Komponente selbst stilisieren.  Wie kann die interne Struktur einer Komponente stilisiert werden?  Zu diesem Zweck werden benutzerdefinierte CSS-Eigenschaften verwendet. <br><br><h3>  <font color="#3AC1EF">▍Erstellen von Style-Hooks mithilfe benutzerdefinierter CSS-Eigenschaften</font> </h3><br>  Benutzer können die Stile der internen Strukturen von Komponenten anpassen, wenn der Autor der Komponente ihnen mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten CSS-Eigenschaften</a> Stil-Hooks zur Verfügung stellt. <br><br>  Dieser Ansatz basiert auf einem ähnlichen Mechanismus wie bei der Arbeit mit <code>&lt;slot&gt;</code> -Tags, gilt jedoch in diesem Fall für Stile. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- main page --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> custom-container {   margin-bottom: 60px;    - custom-container-bg: black; } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">background</span></span></span><span class="hljs-tag">&gt;</span></span>…<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">custom-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Folgendes befindet sich im Schatten-DOM-Baum: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:host(</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[background]</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">var</span></span>( - custom-container-bg, #CECECE); <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre> <br>  In diesem Fall verwendet die Komponente Schwarz als Hintergrundfarbe, da der Benutzer dies angegeben hat.  Andernfalls <code>#CECECE</code> die Hintergrundfarbe <code>#CECECE</code> . <br><br>  Als Autor der Komponente sind Sie dafür verantwortlich, den Benutzern mitzuteilen, welche spezifischen CSS-Eigenschaften sie verwenden können.  Betrachten Sie diesen Teil der offenen Oberfläche Ihrer Komponente. <br><br><h2>  <font color="#3AC1EF">JavaScript-API für die Arbeit mit Slots</font> </h2><br>  Die Shadow DOM-API bietet die Möglichkeit, mit Slots zu arbeiten. <br><br><h3>  <font color="#3AC1EF">▍Event Slotchange</font> </h3><br>  Das <code>slotchange</code> Ereignis <code>slotchange</code> , wenn sich die im Slot platzierten Knoten ändern.  Wenn ein Benutzer beispielsweise untergeordnete Knoten im Light DOM hinzufügt oder entfernt: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> slot = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#some_slot'</span></span>); slot.addEventListener(<span class="hljs-string"><span class="hljs-string">'slotchange'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Light DOM change'</span></span>); });</code> </pre> <br>  Um andere Arten von Änderungen im Light DOM zu verfolgen, können Sie <code>MutationObserver</code> im Konstruktor des Elements verwenden.  Lesen Sie hier mehr darüber. <br><br><h3>  <font color="#3AC1EF">▍ Methode zugewiesenNodes ()</font> </h3><br>  Die Methode <code>assignedNodes()</code> kann hilfreich sein, wenn Sie wissen müssen, welche Elemente dem Steckplatz zugeordnet sind.  Durch Aufrufen der Methode <code>slot.assignedNodes()</code> können Sie genau herausfinden, welche Elemente vom Steckplatz angezeigt werden.  Mit der Option <code>{flatten: true}</code> können Sie den Standardinhalt des Steckplatzes abrufen (angezeigt, wenn keine Knoten daran angeschlossen waren). <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'slot1'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Default content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Stellen Sie sich vor, dieser Steckplatz befindet sich in der Komponente <code>&lt;my-container&gt;</code> . <br><br>  Werfen wir einen Blick auf die verschiedenen Verwendungszwecke dieser Komponente und darauf, was zurückgegeben wird, wenn die Methode <code>assignedNodes()</code> aufgerufen wird. <br><br>  Im ersten Fall fügen wir dem Slot unseren eigenen Inhalt hinzu: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"slot1"</span></span></span><span class="hljs-tag">&gt;</span></span> container text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  In diesem Fall gibt der Aufruf von <code>assignedNodes()</code> <code>[ container text ]</code> .  Beachten Sie, dass dieser Wert ein Array von Knoten ist. <br><br>  Im zweiten Fall füllen wir den Slot nicht mit unserem eigenen Inhalt: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-container</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Der Aufruf von <code>assignedNodes()</code> gibt ein leeres Array zurück - <code>[]</code> . <br><br>  Wenn Sie jedoch den Parameter <code>{flatten: true}</code> an diese Methode übergeben, gibt der Aufruf für dasselbe Element den Standardinhalt zurück: <code>[ Default content ]</code> <p> <code>[ Default content ]</code> </p>  <code>[ Default content ]</code> . <br><br>  Um auf ein Element innerhalb des Steckplatzes zuzugreifen, können Sie außerdem <code>assignedNodes()</code> aufrufen, um zu erfahren, welchem ​​Komponentensteckplatz Ihr Element zugewiesen ist. <br><br><h2>  <font color="#3AC1EF">Ereignismodell</font> </h2><br>  Lassen Sie uns darüber sprechen, was passiert, wenn ein Ereignis im Schatten-DOM-Baum angezeigt wird.  Der Zweck des Ereignisses wird unter Berücksichtigung der von der Shadow DOM-Technologie unterstützten Kapselung festgelegt.  Wenn ein Ereignis umgeleitet wird, sieht es so aus, als stamme es von der Komponente selbst und nicht von ihrem internen Element, das sich im Schatten-DOM-Baum befindet und Teil dieser Komponente ist. <br><br>  Hier ist eine Liste von Ereignissen, die vom DOM-Schattenbaum übergeben werden (dieses Verhalten ist für einige Ereignisse nicht charakteristisch): <br><br><ul><li>  <code>focusin</code> : <code>blur</code> , <code>focus</code> , <code>focusin</code> , <code>focusout</code> . </li><li>  <code>dblclick</code> s: <code>click</code> , <code>dblclick</code> , <code>mousedown</code> , <code>mouseenter</code> , <code>mousemove</code> und andere. </li><li>  Rad Ereignisse: <code>wheel</code> . </li><li>  <code>beforeinput</code> : vor <code>beforeinput</code> , <code>input</code> . </li><li>  Tastaturereignisse: <code>keydown</code> , <code>keyup</code> . </li><li>  Kompositionsereignisse: <code>compositionstart</code> , <code>compositionupdate</code> , <code>compositionend</code> . </li><li>  Drag Events: <code>dragstart</code> , <code>drag</code> , <code>dragend</code> , <code>drop</code> und so weiter. </li></ul><br><h2>  <font color="#3AC1EF">Benutzerdefinierte Ereignisse</font> </h2><br>  Benutzerereignisse verlassen standardmäßig nicht den DOM-Schattenbaum.  Wenn Sie ein Ereignis auslösen möchten und möchten, dass es das Schatten-DOM verlässt, müssen Sie ihm die Parameter <code>bubbles: true</code> bereitstellen <code>bubbles: true</code> und <code>composed: true</code> .  So sieht die Herausforderung einer ähnlichen Veranstaltung aus: <br><br><pre> <code class="hljs axapta">var <span class="hljs-keyword"><span class="hljs-keyword">container</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.shadowRoot.querySelector(<span class="hljs-string"><span class="hljs-string">'#container'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">container</span></span>.dispatchEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Event(<span class="hljs-string"><span class="hljs-string">'containerchanged'</span></span>, {bubbles: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, composed: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>}));</code> </pre> <br><h2>  <font color="#3AC1EF">Unterstützung für Shadow DOM-Browser</font> </h2><br>  Um herauszufinden, ob der Browser die Shadow DOM-Technologie unterstützt, können Sie das Vorhandensein von <code>attachShadow</code> : <br><br><pre> <code class="hljs erlang-repl">const supportsShadowDOMV1 = !!HTMLElement.prototype.attachShadow;</code> </pre> <br>  Hier finden Sie Informationen darüber, wie verschiedene Browser diese Technologie unterstützen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bea/d78/c47/bead78c47c464b5059576df077613803.png"></div><br>  <i><font color="#999999">Unterstützung für die Shadow DOM-Technologie in Browsern</font></i> <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Schatten-DOM-Baum verhält sich nicht wie ein normaler DOM-Baum.  Laut dem Autor dieses Materials drückt sich dies in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SessionStack-</a> Bibliothek insbesondere in der Komplikation des Verfahrens zum Verfolgen von DOM-Änderungen aus, deren Informationen erforderlich sind, um zu reproduzieren, was mit der Seite passiert ist.  <code>MutationObserver</code> verwendet, um Änderungen zu verfolgen.  In diesem Fall löst der DOM-Schattenbaum das <code>MutationObserver</code> Ereignis nicht im globalen Bereich aus, was dazu führt, dass spezielle Ansätze für die Arbeit mit Komponenten verwendet werden müssen, die das Schatten-DOM verwenden. <br><br>  ,     -  Shadow DOM,     ,   , ,     . <br><br>  <b>Liebe Leser!</b>    -,     Shadow DOM? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415881/">https://habr.com/ru/post/de415881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415865/index.html">Markdown-Wissensdatenbank (oder Blog oder Projektdokumentation)</a></li>
<li><a href="../de415867/index.html">Y Combinator Investor School: Ron Conway</a></li>
<li><a href="../de415871/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 321 (25. Juni - 1. Juli 2018)</a></li>
<li><a href="../de415875/index.html">Ein Wort an den Linguisten: Was ist, wenn Computer besser sprechen?</a></li>
<li><a href="../de415879/index.html">Digitale Veranstaltungen in Moskau vom 2. bis 8. Juli</a></li>
<li><a href="../de415887/index.html">Welche Art von Spinnenrobotern fliegen über Stadien und schießen Fußball. Interview mit dem Schöpfer von Robycam</a></li>
<li><a href="../de415891/index.html">Was sind die coolen Fortsetzungsspiele?</a></li>
<li><a href="../de415893/index.html">So machen Sie Java-Prozesse unter Linux / Docker einfach und unkompliziert</a></li>
<li><a href="../de415895/index.html">Das wichtigste Muster in der Programmierung</a></li>
<li><a href="../de415897/index.html">Funktionen zum Dokumentieren von PostgreSQL-Datenbanken. Teil zwei</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>