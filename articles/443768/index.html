<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¶ üò≠ üëãüèΩ Monolito para cientos de versiones de clientes: c√≥mo escribimos y respaldamos las pruebas ‚õèÔ∏è üí• ‚ÜîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Soy un desarrollador de backend en el equipo del servidor Badoo. En la conferencia HighLoad del a√±o pasado, hice una presentaci√≥n , u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monolito para cientos de versiones de clientes: c√≥mo escribimos y respaldamos las pruebas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/443768/"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Hola a todos! <br><br>  Soy un desarrollador de backend en el equipo del servidor Badoo.  En la conferencia HighLoad del a√±o pasado, hice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una presentaci√≥n</a> , una versi√≥n de texto que quiero compartir con ustedes.  Esta publicaci√≥n ser√° m√°s √∫til para aquellos que escriben pruebas para el backend y experimentan problemas con las pruebas de c√≥digo heredado, as√≠ como para aquellos que desean probar la l√≥gica empresarial compleja. <br><br>  ¬øDe qu√© hablaremos?  Primero, hablar√© brevemente sobre nuestro proceso de desarrollo y c√≥mo afecta nuestra necesidad de pruebas y el deseo de escribir estas pruebas.  Luego, subiremos y bajaremos la pir√°mide de automatizaci√≥n de pruebas, discutiremos los tipos de pruebas que usamos, hablaremos sobre las herramientas dentro de cada una de ellas y qu√© problemas resolvemos con su ayuda.  Al final, considere c√≥mo mantener y ejecutar todo esto. <br><a name="habracut"></a><br><h2>  Nuestro proceso de desarrollo </h2><br>  Hemos ilustrado nuestro proceso de desarrollo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  Un golfista es un desarrollador de backend.  En alg√∫n momento, una tarea de desarrollo se traslada a √©l, generalmente en forma de dos documentos: requisitos del lado comercial y un documento t√©cnico que describe los cambios en nuestro protocolo de interacci√≥n entre el servidor y los clientes (aplicaciones m√≥viles y el sitio). <br><br>  El desarrollador escribe el c√≥digo y lo pone en funcionamiento, y antes que todas las aplicaciones cliente.  Toda la funcionalidad est√° protegida por algunos indicadores de caracter√≠sticas o pruebas A / B, esto se prescribe en un documento t√©cnico.  Despu√©s de eso, de acuerdo con las prioridades actuales y la hoja de ruta del producto, se lanzan las aplicaciones del cliente.  Para nosotros, los desarrolladores de back-end, es completamente impredecible cu√°ndo se implementar√° una caracter√≠stica particular en los clientes.  El ciclo de lanzamiento para las aplicaciones del cliente es algo m√°s complicado y m√°s largo que el nuestro, por lo que nuestros gerentes de producto literalmente hacen malabares con las prioridades. <br><br>  La cultura de desarrollo adoptada por la compa√±√≠a es de gran importancia: el desarrollador de back-end es responsable de la caracter√≠stica desde el momento de su implementaci√≥n en el back-end hasta la √∫ltima integraci√≥n en la √∫ltima plataforma en la que originalmente se plane√≥ implementar esta caracter√≠stica. <br><br>  Esta situaci√≥n es bastante posible: hace seis meses, implement√≥ alguna caracter√≠stica, los equipos de clientes no la implementaron durante mucho tiempo, porque las prioridades de la empresa han cambiado, ya est√° ocupado trabajando en otras tareas, tiene nuevos plazos, prioridades, y aqu√≠ vienen sus colegas y dicen: "¬øRecuerdas esto que te lavaste hace seis meses?  Ella no est√° trabajando ".  Y en lugar de involucrarse en nuevas tareas, apaga los incendios. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Por lo tanto, nuestros desarrolladores tienen una motivaci√≥n inusual para los programadores de PHP: asegurarse de que haya la menor cantidad de problemas posible durante la fase de integraci√≥n. <br><br>  ¬øQu√© quiere hacer en primer lugar para asegurarse de que la funci√≥n funcione? <br><br>  Por supuesto, lo primero que viene a la mente es realizar pruebas manuales.  Recoge la aplicaci√≥n, pero no sabe c√≥mo: debido a que la funci√≥n es nueva, los clientes se ocupar√°n de ella en seis meses.  Bueno, las pruebas manuales no garantizan que, durante el tiempo que transcurrir√° desde el lanzamiento del backend hasta el inicio de la integraci√≥n, nadie romper√° nada con los clientes. <br><br>  Y aqu√≠ las pruebas automatizadas vienen en nuestra ayuda. <br><br><h2>  Pruebas unitarias </h2><br>  Las pruebas m√°s simples que escribimos son pruebas unitarias.  Usamos PHP como lenguaje principal para el backend, y PHPUnit como marco para pruebas unitarias.  Mirando hacia el futuro, dir√© que todas nuestras pruebas de back-end est√°n escritas sobre la base de este marco. <br><br>  Las pruebas unitarias a menudo cubrimos algunos peque√±os fragmentos de c√≥digo aislados, verificamos el rendimiento de m√©todos o funciones, es decir, estamos hablando de peque√±as unidades de l√≥gica de negocios.  Nuestras pruebas unitarias no deben interactuar con nada, acceder a bases de datos o servicios. <br><br><h3>  Softmocks </h3><br>  La principal dificultad que enfrentan los desarrolladores al escribir pruebas unitarias es el c√≥digo no comprobable, y este suele ser el c√≥digo heredado. <br><br>  Un simple ejemplo.  Badoo tiene 12 a√±os, una vez fue una startup muy peque√±a, que fue desarrollada por varias personas.  El inicio existi√≥ con bastante √©xito sin ninguna prueba en absoluto.  Luego nos volvimos lo suficientemente grandes y nos dimos cuenta de que no puedes vivir sin pruebas.  Pero para entonces se hab√≠a escrito mucho c√≥digo que funcionaba.  ¬°No lo reescribas solo por probar!  Eso no ser√≠a muy razonable desde el punto de vista comercial. <br><br>  Por lo tanto, desarrollamos una peque√±a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de c√≥digo abierto SoftMocks</a> , que hace que nuestro proceso de escritura de pruebas sea m√°s barato y m√°s r√°pido.  Intercepta todos los archivos PHP de incluir / requerir y sobre la marcha reemplaza el archivo fuente con contenido modificado, es decir, c√≥digo reescrito.  Esto nos permite crear talones para cualquier c√≥digo.  Detalla c√≥mo funciona la biblioteca. <br><br>  Esto es lo que parece para un desarrollador: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  Con la ayuda de construcciones tan simples, podemos redefinir globalmente todo lo que queramos.  En particular, nos permiten sortear las limitaciones del creador est√°ndar de PHPUnit.  Es decir, podemos burlarnos de m√©todos est√°ticos y privados, redefinir constantes y hacer mucho m√°s, lo cual es imposible en PHPUnit ordinario. <br><br>  Sin embargo, nos encontramos con un problema: a los desarrolladores les parece que si hay SoftMocks, no hay necesidad de escribir el c√≥digo probado; siempre se puede "peinar" el c√≥digo con nuestros simulacros globales, y todo funcionar√° bien.  Pero este enfoque conduce a un c√≥digo m√°s complejo y a la acumulaci√≥n de "muletas".  Por lo tanto, adoptamos varias reglas que nos permiten mantener la situaci√≥n bajo control: <br><br><ol><li>  Todo el c√≥digo nuevo debe probarse f√°cilmente con simulacros est√°ndar de PHPUnit.  Si se cumple esta condici√≥n, entonces el c√≥digo es comprobable y puede seleccionar f√°cilmente una pieza peque√±a y probarla solo. <br></li><li>  SoftMocks se puede usar con c√≥digo antiguo que est√° escrito de una manera que no es adecuada para pruebas unitarias, as√≠ como en casos donde es demasiado costoso / largo / dif√≠cil de hacer de otra manera (enfatice lo necesario). <br></li></ol><br>  El cumplimiento de estas reglas se supervisa cuidadosamente en la etapa de revisi√≥n del c√≥digo. <br><br><h3>  Prueba de mutaci√≥n </h3><br>  Por separado, quiero decir sobre la calidad de las pruebas unitarias.  Creo que muchos de ustedes usan m√©tricas como la cobertura de c√≥digo.  Pero ella, desafortunadamente, no responde una pregunta: "¬øHe escrito una buena prueba de unidad?"  Es posible que haya escrito una prueba de este tipo, que en realidad no verifica nada, no contiene una sola afirmaci√≥n, pero genera una excelente cobertura de c√≥digo.  Por supuesto, el ejemplo es exagerado, pero la situaci√≥n no est√° tan lejos de la realidad. <br><br>  Recientemente, comenzamos a introducir pruebas mutacionales.  Este es un concepto bastante antiguo, pero no muy conocido.  El algoritmo para tales pruebas es bastante simple: <br><br><ul><li>  tomar el c√≥digo y la cobertura del c√≥digo; <br></li><li>  parsim y comenzar a cambiar el c√≥digo: verdadero a falso,&gt; a&gt; =, + a - (en general, da√±o en todos los sentidos); <br></li><li>  para cada cambio de mutaci√≥n, ejecute conjuntos de pruebas que cubran la cadena modificada; <br></li><li>  si las pruebas caen, entonces son buenas y realmente no nos permiten romper el c√≥digo; <br></li><li>  si las pruebas han pasado, lo m√°s probable es que no sean lo suficientemente efectivas, a pesar de la cobertura, y puede valer la pena mirarlas m√°s de cerca, para afirmar algo (o hay un √°rea no cubierta por la prueba). <br></li></ul><br>  Hay varios frameworks listos para PHP, como Humbug e Infection.  Desafortunadamente, no nos conven√≠an, porque son incompatibles con SoftMocks.  Por lo tanto, escribimos nuestra propia peque√±a consola, que hace lo mismo, pero usa nuestro formato de cobertura de c√≥digo interno y es amigo de SoftMocks.  Ahora el desarrollador lo inicia manualmente y analiza las pruebas escritas por √©l, pero estamos trabajando para introducir la herramienta en nuestro proceso de desarrollo. <br><br><h2>  Pruebas de integraci√≥n </h2><br>  Con la ayuda de pruebas de integraci√≥n, verificamos la interacci√≥n con varios servicios y bases de datos. <br><br>  Para comprender mejor la historia, desarrollemos una promoci√≥n ficticia y c√∫brala con pruebas.  Imagine que nuestros gerentes de producto decidieron distribuir boletos de conferencia a nuestros usuarios m√°s dedicados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  La promoci√≥n debe mostrarse si: <br><br><ul><li>  el usuario en el campo "Trabajo" indica "programador", <br></li><li>  el usuario participa en la prueba A / B HL18_promo, <br></li><li>  El usuario est√° registrado hace m√°s de dos a√±os. <br></li></ul><br>  Al hacer clic en el bot√≥n "Obtener un boleto", debemos guardar los datos de este usuario en una lista para transferirlos a nuestros gerentes que distribuyen los boletos. <br><br>  Incluso en este ejemplo bastante simple, hay algo que no se puede verificar mediante pruebas unitarias: la interacci√≥n con la base de datos.  Para hacer esto, necesitamos usar pruebas de integraci√≥n. <br><br>  Considere la forma est√°ndar de probar la interacci√≥n de la base de datos ofrecida por PHPUnit: <br><br><ol><li>  Eleve la base de datos de prueba. <br></li><li>  Preparamos DataTables y DataSets. <br></li><li>  Ejecute la prueba <br></li><li>  Limpiamos la base de datos de prueba. <br></li></ol><br>  ¬øQu√© dificultades acechan con este enfoque? <br><br><ul><li>  Debe admitir las estructuras de DataTables y DataSets.  Si cambiamos el dise√±o de la tabla, entonces es necesario reflejar estos cambios en la prueba, lo que no siempre es conveniente y requiere tiempo adicional. <br></li><li>  Lleva tiempo preparar la base de datos.  Cada vez que configuramos la prueba, necesitamos cargar algo all√≠, crear algunas tablas, y esto es largo y problem√°tico si hay muchas pruebas. <br></li><li>  Y el inconveniente m√°s importante: ejecutar estas pruebas en paralelo las hace inestables.  Comenzamos la prueba A, √©l comenz√≥ a escribir en la tabla de prueba, que √©l cre√≥.  Al mismo tiempo, lanzamos la prueba B, que quiere trabajar con la misma tabla de prueba.  Como resultado, surgen bloqueos mutuos y otras situaciones imprevistas. <br></li></ul><br>  Para evitar estos problemas, desarrollamos nuestra propia biblioteca peque√±a DBMocks. <br><br><h3>  DBMocks </h3><br>  El principio de funcionamiento es el siguiente: <br><br><ol><li>  Con la ayuda de SoftMocks, interceptamos todos los contenedores a trav√©s de los cuales trabajamos con bases de datos. <br></li><li>  Cuando <br>  la consulta pasa por simulacro, analiza la consulta SQL y extrae DB + TableName de ella, y obtiene el host de la conexi√≥n. <br></li><li>  En el mismo host en tmpfs creamos una tabla temporal con la misma estructura que la original (copiamos la estructura usando SHOW CREATE TABLE). <br></li><li>  Despu√©s de eso, redirigiremos todas las solicitudes que pasar√°n por simulacro a esta tabla a una temporal reci√©n creada. <br></li></ol><br>  ¬øQu√© nos da esto? <br><br><ul><li>  no es necesario cuidar constantemente las estructuras; <br></li><li>  las pruebas ya no pueden da√±ar los datos en las tablas de origen, porque los redirigimos a tablas temporales sobre la marcha; <br></li><li>  todav√≠a estamos probando la compatibilidad con la versi√≥n de MySQL con la que estamos trabajando, y si la solicitud deja de ser compatible con la nueva versi√≥n, nuestra prueba lo ver√° y la bloquear√°. <br></li><li>  y lo m√°s importante, las pruebas ahora est√°n aisladas, e incluso si las ejecuta en paralelo, los subprocesos se dispersar√°n en diferentes tablas temporales, ya que agregamos una clave √∫nica para cada prueba en los nombres de las tablas de prueba. <br></li></ul><br><h2>  Pruebas de API </h2><br>  La diferencia entre las pruebas unitarias y API est√° bien ilustrada en este GIF: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>La cerradura funciona bien, pero est√° unida a la puerta equivocada.</i> <br><br>  Nuestras pruebas simulan una sesi√≥n de cliente, pueden enviar solicitudes al backend, siguiendo nuestro protocolo, y el backend responde a ellas como un cliente real. <br><br><h3>  Probar grupo de usuarios </h3><br>  ¬øQu√© necesitamos para escribir con √©xito tales pruebas?  Volvamos a las condiciones del espect√°culo de nuestra promoci√≥n: <br><br><ul><li>  el usuario en el campo "Trabajo" indica "programador", <br></li><li>  el usuario participa en la prueba A / B HL18_promo, <br></li><li>  El usuario est√° registrado hace m√°s de dos a√±os. <br></li></ul><br>  Aparentemente, aqu√≠ todo se trata del usuario.  Y en realidad, el 99% de las pruebas de API requieren un usuario registrado autorizado, que est√° presente en todos los servicios y bases de datos. <br><br>  ¬øD√≥nde conseguirlo?  Puede intentar registrarlo en el momento de la prueba, pero: <br><br><ul><li>  es largo y consume muchos recursos; <br></li><li>  despu√©s de completar la prueba, este usuario debe ser eliminado de alguna manera, lo cual es una tarea bastante trivial si hablamos de proyectos grandes; <br></li><li>  finalmente, como en muchos otros proyectos altamente cargados, realizamos muchas operaciones en segundo plano (agregando un usuario a varios servicios, replicaci√≥n a otros centros de datos, etc.);  Las pruebas no saben nada sobre tales procesos, pero si se basan impl√≠citamente en los resultados de su ejecuci√≥n, existe el riesgo de inestabilidad. <br></li></ul><br><br>  Desarrollamos una herramienta llamada Test Users Pool.  Se basa en dos ideas: <br><br><ol><li>  No registramos usuarios cada vez, pero lo usamos muchas veces. <br></li><li>  Despu√©s de la prueba, restablecemos los datos del usuario a su estado original (en el momento del registro).  Si no se hace esto, las pruebas se volver√°n inestables con el tiempo, porque los usuarios estar√°n "contaminados" con la informaci√≥n de otras pruebas. <br></li></ol><br><br>  Funciona algo como esto: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  En alg√∫n momento, quer√≠amos ejecutar nuestras pruebas de API en un entorno de producci√≥n.  ¬øPor qu√© queremos esto?  Porque la infraestructura de desarrollo no es lo mismo que la producci√≥n. <br><br>  Aunque estamos tratando de repetir constantemente la infraestructura de producci√≥n en un tama√±o reducido, el desarrollo nunca ser√° una copia completa de la misma.  Para estar absolutamente seguro de que la nueva compilaci√≥n cumple con las expectativas y no hay problemas, cargamos el nuevo c√≥digo en el cl√∫ster de preproducci√≥n, que funciona con datos y servicios de producci√≥n, y ejecutamos nuestras pruebas de API all√≠. <br><br>  En este caso, es muy importante pensar en c√≥mo aislar a los usuarios de prueba de los reales. <br><br><div class="spoiler">  <b class="spoiler_title">Qu√© suceder√° si los usuarios de prueba comienzan a aparecer reales en nuestra aplicaci√≥n.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  ¬øC√≥mo aislar?  Cada uno de nuestros usuarios tiene una bandera <code>is_test_user</code> .  En la etapa de registro, se convierte en <code>yes</code> o <code>no</code> , y ya no cambia.  Con esta bandera, aislamos a los usuarios en todos los servicios.  Tambi√©n es importante que excluyamos a los usuarios de prueba del an√°lisis empresarial y los resultados de las pruebas A / B para no distorsionar las estad√≠sticas. <br><br>  Puede ir de una manera m√°s simple: comenzamos con el hecho de que todos los usuarios de prueba fueron "reubicados" en la Ant√°rtida.  Si tiene un geoservicio, esta es una forma completamente funcional. <br><br><h3>  API de control de calidad </h3><br>  No solo necesitamos un usuario, lo necesitamos con ciertos par√°metros: para trabajar como programador, participar en una determinada prueba A / B y fue registrado hace m√°s de dos a√±os.  Para los usuarios de prueba, podemos asignar f√°cilmente una profesi√≥n usando nuestra API de back-end, pero entrar en las pruebas A / B es probabil√≠stico.  Y la condici√≥n de registro hace m√°s de dos a√±os es generalmente dif√≠cil de cumplir, porque no sabemos cu√°ndo apareci√≥ el usuario en el grupo. <br><br>  Para resolver estos problemas, tenemos una API de control de calidad.  Esto, de hecho, es una puerta trasera para las pruebas, que es un m√©todo API bien documentado que le permite administrar r√°pida y f√°cilmente los datos del usuario y cambiar su estado sin pasar por el protocolo principal de nuestra comunicaci√≥n con los clientes.  Los desarrolladores de backend escriben los m√©todos para ingenieros de control de calidad y para su uso en pruebas de interfaz de usuario y API. <br><br>  QA API solo se puede aplicar en el caso de usuarios de prueba: si no hay un indicador correspondiente, la prueba caer√° inmediatamente.  Este es uno de nuestros m√©todos de API de control de calidad que le permite cambiar la fecha de registro del usuario a una arbitraria: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  Por lo tanto, se ver√°n como tres llamadas que le permitir√°n cambiar r√°pidamente los datos del usuario de prueba para que cumplan las condiciones para mostrar la promoci√≥n: <br><br><ul><li>  En el campo "Trabajo" se indica el "programador": <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  El usuario participa en la prueba A / B HL18_promo: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Registrado hace m√°s de dos a√±os: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Como se trata de una puerta trasera, es imperativo pensar en la seguridad.  Protegimos nuestro servicio de varias maneras: <br><br><ul><li>  aislado a nivel de red: solo se puede acceder a los servicios desde la red de la oficina; <br></li><li>  con cada solicitud pasamos un secreto, sin el cual es imposible acceder a la API de QA incluso desde la red de la oficina; <br></li><li>  Los m√©todos solo funcionan con usuarios de prueba. <br></li></ul><br><br><h3>  Remotemocks </h3><br>  Para trabajar con el back-end remoto de las pruebas API, es posible que necesitemos simulacros.  Para que?  Por ejemplo, si la prueba de API en el entorno de producci√≥n comienza a acceder a la base de datos, debemos asegurarnos de que los datos en ella se borren de los datos de prueba.  Adem√°s, los simulacros ayudan a que la respuesta de la prueba sea m√°s adecuada para la prueba. <br><br>  Tenemos tres textos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  Badoo es una aplicaci√≥n multiling√ºe, tenemos un componente complejo de localizaci√≥n que le permite traducir y recibir traducciones r√°pidamente para la ubicaci√≥n actual del usuario.  Nuestros localizadores trabajan constantemente para mejorar las traducciones, realizar pruebas A / B con tokens y buscar formulaciones m√°s exitosas.  Y, mientras realizamos la prueba, no podemos saber qu√© texto devolver√° el servidor; puede cambiar en cualquier momento.  Pero podemos usar RemoteMocks para verificar si se accede correctamente al componente de localizaci√≥n. <br><br>  ¬øC√≥mo funcionan los RemoteMocks?  La prueba le pide al servidor que los inicialice para su sesi√≥n, y al recibir todas las solicitudes posteriores, el servidor comprueba si hay simulacros para la sesi√≥n actual.  Si lo son, simplemente los inicializa usando SoftMocks. <br><br>  Si queremos crear una simulaci√≥n remota, indicamos qu√© clase o m√©todo necesita ser reemplazado y con qu√©.  Todas las solicitudes de backend posteriores se ejecutar√°n teniendo en cuenta este simulacro: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Bueno, ahora recopilemos nuestra prueba de API: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; ‚Ä¶ //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  De una manera tan simple, podemos probar cualquier funcionalidad que se desarrolle en el backend y requiera cambios en el protocolo m√≥vil. <br><br><h3>  Reglas de uso de prueba de API </h3><br>  Todo parece estar bien, pero nuevamente encontramos un problema: las pruebas de API resultaron ser demasiado convenientes para el desarrollo y hubo la tentaci√≥n de usarlas en todas partes.  Como resultado, una vez que nos dimos cuenta de que est√°bamos empezando a resolver problemas con la ayuda de las pruebas API para las cuales no estaban destinados. <br><br>  ¬øPor qu√© es esto malo?  Porque las pruebas de API son muy lentas.  Se conectan a la red, se dirigen al backend, que recoge la sesi√≥n, va a la base de datos y a un conjunto de servicios.  Por lo tanto, desarrollamos un conjunto de reglas para usar pruebas API: <br><ul><li>  El prop√≥sito de las pruebas de API es verificar el protocolo de interacci√≥n entre el cliente y el servidor, as√≠ como la correcta integraci√≥n del nuevo c√≥digo; <br><br></li><li>  est√° permitido cubrir procesos complejos con ellos, por ejemplo, cadenas de acciones; <br></li><li>  no pueden usarse para probar la peque√±a variabilidad de la respuesta del servidor; esta es la tarea de las pruebas unitarias; <br></li><li>  durante la revisi√≥n del c√≥digo, verificamos las pruebas incluidas. <br></li></ul><br><h2>  Pruebas de IU </h2><br>  Como estamos considerando una pir√°mide de automatizaci√≥n, te contar√© un poco sobre las pruebas de IU. <br><br>  Los desarrolladores de backend en Badoo no escriben pruebas de interfaz de usuario; para esto tenemos un equipo dedicado en el departamento de control de calidad.  Cubrimos la funci√≥n con las pruebas de IU cuando ya se nos viene a la mente y se estabiliza, porque creemos que no es razonable gastar recursos en una automatizaci√≥n bastante costosa de la funci√≥n, que, tal vez, no vaya m√°s all√° de la prueba A / B. <br><br>  Utilizamos Calabash para pruebas autom√°ticas m√≥viles y Selenium para la web.  Habla sobre nuestra plataforma de automatizaci√≥n y pruebas. <br><br><h2>  Prueba de funcionamiento </h2><br>  Ahora tenemos 100,000 pruebas unitarias, 6,000 - pruebas de integraci√≥n y 14,000 pruebas API.  Si intenta ejecutarlos en un hilo, incluso en nuestra m√°quina m√°s poderosa, una ejecuci√≥n completa de todos tomar√°: modular - 40 minutos, integraci√≥n - 90 minutos, pruebas API - diez horas.  Es muy largo <br><br><h3>  Paralelizaci√≥n </h3><br>  <i>Hablamos sobre nuestra experiencia de paralelizar pruebas unitarias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este art√≠culo</a> .</i> <br><br>  La primera soluci√≥n, que parece obvia, es ejecutar pruebas en m√∫ltiples hilos.  Pero fuimos m√°s all√° e hicimos una nube para el lanzamiento paralelo para poder escalar los recursos de hardware.  Simplificado, su trabajo se ve as√≠: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  La tarea m√°s interesante aqu√≠ es la distribuci√≥n de pruebas entre hilos, es decir, su desglose en trozos. <br><br>  Puede dividirlos por igual, pero las pruebas son diferentes, por lo que puede haber un fuerte sesgo en el tiempo de ejecuci√≥n de un hilo: todos los hilos ya han llegado y uno se cuelga durante media hora, ya que fue "afortunado" con pruebas muy lentas. <br><br>  Puede iniciar varios subprocesos y alimentarlos con pruebas de uno en uno.  En este caso, el inconveniente es menos obvio: existen costos generales para inicializar el entorno, que, con una gran cantidad de pruebas y este enfoque, comienzan a desempe√±ar un papel importante. <br><br>  Que hemos hecho  Comenzamos a recopilar estad√≠sticas sobre el tiempo necesario para ejecutar cada prueba, y luego comenzamos a componer fragmentos de tal manera que, seg√∫n las estad√≠sticas, un subproceso se ejecute por no m√°s de 30 segundos.  Al mismo tiempo, empaquetamos las pruebas bastante bien en trozos para hacerlas m√°s peque√±as. <br><br>  Sin embargo, nuestro enfoque tambi√©n tiene un inconveniente.  Est√° asociado con las pruebas de API: son muy lentas y consumen muchos recursos, evitando que se ejecuten pruebas r√°pidas. <br><br>  Por lo tanto, dividimos la nube en dos partes: en la primera, solo se lanzan pruebas r√°pidas, y en la segunda, se pueden iniciar tanto r√°pido como lento.  Con este enfoque, siempre tenemos una parte de la nube que puede manejar pruebas r√°pidas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  Como resultado, las pruebas unitarias comenzaron a ejecutarse en un minuto, las pruebas de integraci√≥n en cinco minutos y las pruebas de API en 15 minutos.  Es decir, una carrera completa en lugar de 12 horas no lleva m√°s de 22 minutos. <br><br><h3>  Ejecuci√≥n de prueba de cobertura de c√≥digo </h3><br>  Tenemos un gran monolito complejo y, en el buen sentido, necesitamos ejecutar constantemente todas las pruebas, ya que un cambio en un lugar puede romper algo en otro.  Esta es una de las principales desventajas de la arquitectura monol√≠tica. <br><br>  En alg√∫n momento, llegamos a la conclusi√≥n de que no es necesario ejecutar todas las pruebas cada vez; puede realizar ejecuciones basadas en la cobertura del c√≥digo: <br><br><ol><li>  Toma nuestra rama diff. <br></li><li>  Creamos una lista de archivos modificados. <br></li><li>  Para cada archivo obtenemos una lista de pruebas, <br>  que lo cubren <br></li><li>  A partir de estas pruebas, creamos un conjunto y lo ejecutamos en una nube de prueba. <br></li></ol><br>  ¬øD√≥nde obtener cobertura?  Recopilamos datos una vez al d√≠a cuando la infraestructura del entorno de desarrollo est√° inactiva.  El n√∫mero de pruebas ejecutadas ha disminuido notablemente, la velocidad de recibir comentarios de ellos, por el contrario, ha aumentado significativamente.  Beneficio! <br><br>  Una ventaja adicional fue la capacidad de ejecutar pruebas para parches.  A pesar del hecho de que Badoo no ha sido una startup durante mucho tiempo, a√∫n podemos implementar r√°pidamente cambios en la producci√≥n, verter soluciones r√°pidas, implementar caracter√≠sticas y cambiar la configuraci√≥n.  Como regla general, la velocidad de implementaci√≥n de parches es muy importante para nosotros.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nuevo enfoque dio un gran aumento en la velocidad de retroalimentaci√≥n de las pruebas, porque ahora no necesitamos esperar mucho para una ejecuci√≥n completa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero sin los defectos en ninguna parte. </font><font style="vertical-align: inherit;">Lanzaremos el back-end dos veces al d√≠a, y la cobertura es relevante solo para la primera versi√≥n, hasta la primera compilaci√≥n, despu√©s de lo cual comienza a retrasarse una compilaci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, para las compilaciones, ejecutamos un conjunto de pruebas completo. </font><font style="vertical-align: inherit;">Para nosotros, esto es una garant√≠a de que la cobertura del c√≥digo no se queda atr√°s y que se han completado todas las pruebas necesarias. </font><font style="vertical-align: inherit;">Lo peor que puede suceder es que atraparemos algunas pruebas fallidas en la etapa de construcci√≥n de la construcci√≥n, y no en las etapas anteriores. </font><font style="vertical-align: inherit;">Pero esto sucede muy raramente.</font></font><br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Conclusi√≥n </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ‚â† .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  12:00,  ‚Äî   YouTube-</a></b> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443768/">https://habr.com/ru/post/443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443754/index.html">Sobre la idoneidad de Selenium WebDriverWait</a></li>
<li><a href="../443756/index.html">Dise√±o de clase: ¬øqu√© es bueno?</a></li>
<li><a href="../443758/index.html">Quick Draw Doodle Recognition: C√≥mo hacer amigos R, C ++ y cuadr√≠culas neuronales</a></li>
<li><a href="../443764/index.html">Lo que el dise√±ador fum√≥: un arma de fuego inusual</a></li>
<li><a href="../443766/index.html">Probar la programaci√≥n de contratos de C ++ 20 ahora</a></li>
<li><a href="../443770/index.html">Dise√±o dirigido por dominio: objetos de valor y marco de entidad b√°sico en la pr√°ctica</a></li>
<li><a href="../443772/index.html">Antig√ºedades: IBM ThinkPad T40, la primera conexi√≥n inal√°mbrica</a></li>
<li><a href="../443774/index.html">C√≥mo la neurobiolog√≠a interfiere en las elecciones presidenciales de EE. UU.</a></li>
<li><a href="../443776/index.html">China introduce un sistema experimental de reconocimiento facial al pagar el metro</a></li>
<li><a href="../443780/index.html">Proyecto MCDM. Parte 1. Concepto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>