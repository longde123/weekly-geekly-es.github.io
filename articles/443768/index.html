<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏦 😭 👋🏽 Monolito para cientos de versiones de clientes: cómo escribimos y respaldamos las pruebas ⛏️ 💥 ↔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Soy un desarrollador de backend en el equipo del servidor Badoo. En la conferencia HighLoad del año pasado, hice una presentación , u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monolito para cientos de versiones de clientes: cómo escribimos y respaldamos las pruebas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/443768/"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Hola a todos! <br><br>  Soy un desarrollador de backend en el equipo del servidor Badoo.  En la conferencia HighLoad del año pasado, hice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una presentación</a> , una versión de texto que quiero compartir con ustedes.  Esta publicación será más útil para aquellos que escriben pruebas para el backend y experimentan problemas con las pruebas de código heredado, así como para aquellos que desean probar la lógica empresarial compleja. <br><br>  ¿De qué hablaremos?  Primero, hablaré brevemente sobre nuestro proceso de desarrollo y cómo afecta nuestra necesidad de pruebas y el deseo de escribir estas pruebas.  Luego, subiremos y bajaremos la pirámide de automatización de pruebas, discutiremos los tipos de pruebas que usamos, hablaremos sobre las herramientas dentro de cada una de ellas y qué problemas resolvemos con su ayuda.  Al final, considere cómo mantener y ejecutar todo esto. <br><a name="habracut"></a><br><h2>  Nuestro proceso de desarrollo </h2><br>  Hemos ilustrado nuestro proceso de desarrollo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  Un golfista es un desarrollador de backend.  En algún momento, una tarea de desarrollo se traslada a él, generalmente en forma de dos documentos: requisitos del lado comercial y un documento técnico que describe los cambios en nuestro protocolo de interacción entre el servidor y los clientes (aplicaciones móviles y el sitio). <br><br>  El desarrollador escribe el código y lo pone en funcionamiento, y antes que todas las aplicaciones cliente.  Toda la funcionalidad está protegida por algunos indicadores de características o pruebas A / B, esto se prescribe en un documento técnico.  Después de eso, de acuerdo con las prioridades actuales y la hoja de ruta del producto, se lanzan las aplicaciones del cliente.  Para nosotros, los desarrolladores de back-end, es completamente impredecible cuándo se implementará una característica particular en los clientes.  El ciclo de lanzamiento para las aplicaciones del cliente es algo más complicado y más largo que el nuestro, por lo que nuestros gerentes de producto literalmente hacen malabares con las prioridades. <br><br>  La cultura de desarrollo adoptada por la compañía es de gran importancia: el desarrollador de back-end es responsable de la característica desde el momento de su implementación en el back-end hasta la última integración en la última plataforma en la que originalmente se planeó implementar esta característica. <br><br>  Esta situación es bastante posible: hace seis meses, implementó alguna característica, los equipos de clientes no la implementaron durante mucho tiempo, porque las prioridades de la empresa han cambiado, ya está ocupado trabajando en otras tareas, tiene nuevos plazos, prioridades, y aquí vienen sus colegas y dicen: "¿Recuerdas esto que te lavaste hace seis meses?  Ella no está trabajando ".  Y en lugar de involucrarse en nuevas tareas, apaga los incendios. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Por lo tanto, nuestros desarrolladores tienen una motivación inusual para los programadores de PHP: asegurarse de que haya la menor cantidad de problemas posible durante la fase de integración. <br><br>  ¿Qué quiere hacer en primer lugar para asegurarse de que la función funcione? <br><br>  Por supuesto, lo primero que viene a la mente es realizar pruebas manuales.  Recoge la aplicación, pero no sabe cómo: debido a que la función es nueva, los clientes se ocuparán de ella en seis meses.  Bueno, las pruebas manuales no garantizan que, durante el tiempo que transcurrirá desde el lanzamiento del backend hasta el inicio de la integración, nadie romperá nada con los clientes. <br><br>  Y aquí las pruebas automatizadas vienen en nuestra ayuda. <br><br><h2>  Pruebas unitarias </h2><br>  Las pruebas más simples que escribimos son pruebas unitarias.  Usamos PHP como lenguaje principal para el backend, y PHPUnit como marco para pruebas unitarias.  Mirando hacia el futuro, diré que todas nuestras pruebas de back-end están escritas sobre la base de este marco. <br><br>  Las pruebas unitarias a menudo cubrimos algunos pequeños fragmentos de código aislados, verificamos el rendimiento de métodos o funciones, es decir, estamos hablando de pequeñas unidades de lógica de negocios.  Nuestras pruebas unitarias no deben interactuar con nada, acceder a bases de datos o servicios. <br><br><h3>  Softmocks </h3><br>  La principal dificultad que enfrentan los desarrolladores al escribir pruebas unitarias es el código no comprobable, y este suele ser el código heredado. <br><br>  Un simple ejemplo.  Badoo tiene 12 años, una vez fue una startup muy pequeña, que fue desarrollada por varias personas.  El inicio existió con bastante éxito sin ninguna prueba en absoluto.  Luego nos volvimos lo suficientemente grandes y nos dimos cuenta de que no puedes vivir sin pruebas.  Pero para entonces se había escrito mucho código que funcionaba.  ¡No lo reescribas solo por probar!  Eso no sería muy razonable desde el punto de vista comercial. <br><br>  Por lo tanto, desarrollamos una pequeña <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca de código abierto SoftMocks</a> , que hace que nuestro proceso de escritura de pruebas sea más barato y más rápido.  Intercepta todos los archivos PHP de incluir / requerir y sobre la marcha reemplaza el archivo fuente con contenido modificado, es decir, código reescrito.  Esto nos permite crear talones para cualquier código.  Detalla cómo funciona la biblioteca. <br><br>  Esto es lo que parece para un desarrollador: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  Con la ayuda de construcciones tan simples, podemos redefinir globalmente todo lo que queramos.  En particular, nos permiten sortear las limitaciones del creador estándar de PHPUnit.  Es decir, podemos burlarnos de métodos estáticos y privados, redefinir constantes y hacer mucho más, lo cual es imposible en PHPUnit ordinario. <br><br>  Sin embargo, nos encontramos con un problema: a los desarrolladores les parece que si hay SoftMocks, no hay necesidad de escribir el código probado; siempre se puede "peinar" el código con nuestros simulacros globales, y todo funcionará bien.  Pero este enfoque conduce a un código más complejo y a la acumulación de "muletas".  Por lo tanto, adoptamos varias reglas que nos permiten mantener la situación bajo control: <br><br><ol><li>  Todo el código nuevo debe probarse fácilmente con simulacros estándar de PHPUnit.  Si se cumple esta condición, entonces el código es comprobable y puede seleccionar fácilmente una pieza pequeña y probarla solo. <br></li><li>  SoftMocks se puede usar con código antiguo que está escrito de una manera que no es adecuada para pruebas unitarias, así como en casos donde es demasiado costoso / largo / difícil de hacer de otra manera (enfatice lo necesario). <br></li></ol><br>  El cumplimiento de estas reglas se supervisa cuidadosamente en la etapa de revisión del código. <br><br><h3>  Prueba de mutación </h3><br>  Por separado, quiero decir sobre la calidad de las pruebas unitarias.  Creo que muchos de ustedes usan métricas como la cobertura de código.  Pero ella, desafortunadamente, no responde una pregunta: "¿He escrito una buena prueba de unidad?"  Es posible que haya escrito una prueba de este tipo, que en realidad no verifica nada, no contiene una sola afirmación, pero genera una excelente cobertura de código.  Por supuesto, el ejemplo es exagerado, pero la situación no está tan lejos de la realidad. <br><br>  Recientemente, comenzamos a introducir pruebas mutacionales.  Este es un concepto bastante antiguo, pero no muy conocido.  El algoritmo para tales pruebas es bastante simple: <br><br><ul><li>  tomar el código y la cobertura del código; <br></li><li>  parsim y comenzar a cambiar el código: verdadero a falso,&gt; a&gt; =, + a - (en general, daño en todos los sentidos); <br></li><li>  para cada cambio de mutación, ejecute conjuntos de pruebas que cubran la cadena modificada; <br></li><li>  si las pruebas caen, entonces son buenas y realmente no nos permiten romper el código; <br></li><li>  si las pruebas han pasado, lo más probable es que no sean lo suficientemente efectivas, a pesar de la cobertura, y puede valer la pena mirarlas más de cerca, para afirmar algo (o hay un área no cubierta por la prueba). <br></li></ul><br>  Hay varios frameworks listos para PHP, como Humbug e Infection.  Desafortunadamente, no nos convenían, porque son incompatibles con SoftMocks.  Por lo tanto, escribimos nuestra propia pequeña consola, que hace lo mismo, pero usa nuestro formato de cobertura de código interno y es amigo de SoftMocks.  Ahora el desarrollador lo inicia manualmente y analiza las pruebas escritas por él, pero estamos trabajando para introducir la herramienta en nuestro proceso de desarrollo. <br><br><h2>  Pruebas de integración </h2><br>  Con la ayuda de pruebas de integración, verificamos la interacción con varios servicios y bases de datos. <br><br>  Para comprender mejor la historia, desarrollemos una promoción ficticia y cúbrala con pruebas.  Imagine que nuestros gerentes de producto decidieron distribuir boletos de conferencia a nuestros usuarios más dedicados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  La promoción debe mostrarse si: <br><br><ul><li>  el usuario en el campo "Trabajo" indica "programador", <br></li><li>  el usuario participa en la prueba A / B HL18_promo, <br></li><li>  El usuario está registrado hace más de dos años. <br></li></ul><br>  Al hacer clic en el botón "Obtener un boleto", debemos guardar los datos de este usuario en una lista para transferirlos a nuestros gerentes que distribuyen los boletos. <br><br>  Incluso en este ejemplo bastante simple, hay algo que no se puede verificar mediante pruebas unitarias: la interacción con la base de datos.  Para hacer esto, necesitamos usar pruebas de integración. <br><br>  Considere la forma estándar de probar la interacción de la base de datos ofrecida por PHPUnit: <br><br><ol><li>  Eleve la base de datos de prueba. <br></li><li>  Preparamos DataTables y DataSets. <br></li><li>  Ejecute la prueba <br></li><li>  Limpiamos la base de datos de prueba. <br></li></ol><br>  ¿Qué dificultades acechan con este enfoque? <br><br><ul><li>  Debe admitir las estructuras de DataTables y DataSets.  Si cambiamos el diseño de la tabla, entonces es necesario reflejar estos cambios en la prueba, lo que no siempre es conveniente y requiere tiempo adicional. <br></li><li>  Lleva tiempo preparar la base de datos.  Cada vez que configuramos la prueba, necesitamos cargar algo allí, crear algunas tablas, y esto es largo y problemático si hay muchas pruebas. <br></li><li>  Y el inconveniente más importante: ejecutar estas pruebas en paralelo las hace inestables.  Comenzamos la prueba A, él comenzó a escribir en la tabla de prueba, que él creó.  Al mismo tiempo, lanzamos la prueba B, que quiere trabajar con la misma tabla de prueba.  Como resultado, surgen bloqueos mutuos y otras situaciones imprevistas. <br></li></ul><br>  Para evitar estos problemas, desarrollamos nuestra propia biblioteca pequeña DBMocks. <br><br><h3>  DBMocks </h3><br>  El principio de funcionamiento es el siguiente: <br><br><ol><li>  Con la ayuda de SoftMocks, interceptamos todos los contenedores a través de los cuales trabajamos con bases de datos. <br></li><li>  Cuando <br>  la consulta pasa por simulacro, analiza la consulta SQL y extrae DB + TableName de ella, y obtiene el host de la conexión. <br></li><li>  En el mismo host en tmpfs creamos una tabla temporal con la misma estructura que la original (copiamos la estructura usando SHOW CREATE TABLE). <br></li><li>  Después de eso, redirigiremos todas las solicitudes que pasarán por simulacro a esta tabla a una temporal recién creada. <br></li></ol><br>  ¿Qué nos da esto? <br><br><ul><li>  no es necesario cuidar constantemente las estructuras; <br></li><li>  las pruebas ya no pueden dañar los datos en las tablas de origen, porque los redirigimos a tablas temporales sobre la marcha; <br></li><li>  todavía estamos probando la compatibilidad con la versión de MySQL con la que estamos trabajando, y si la solicitud deja de ser compatible con la nueva versión, nuestra prueba lo verá y la bloqueará. <br></li><li>  y lo más importante, las pruebas ahora están aisladas, e incluso si las ejecuta en paralelo, los subprocesos se dispersarán en diferentes tablas temporales, ya que agregamos una clave única para cada prueba en los nombres de las tablas de prueba. <br></li></ul><br><h2>  Pruebas de API </h2><br>  La diferencia entre las pruebas unitarias y API está bien ilustrada en este GIF: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>La cerradura funciona bien, pero está unida a la puerta equivocada.</i> <br><br>  Nuestras pruebas simulan una sesión de cliente, pueden enviar solicitudes al backend, siguiendo nuestro protocolo, y el backend responde a ellas como un cliente real. <br><br><h3>  Probar grupo de usuarios </h3><br>  ¿Qué necesitamos para escribir con éxito tales pruebas?  Volvamos a las condiciones del espectáculo de nuestra promoción: <br><br><ul><li>  el usuario en el campo "Trabajo" indica "programador", <br></li><li>  el usuario participa en la prueba A / B HL18_promo, <br></li><li>  El usuario está registrado hace más de dos años. <br></li></ul><br>  Aparentemente, aquí todo se trata del usuario.  Y en realidad, el 99% de las pruebas de API requieren un usuario registrado autorizado, que está presente en todos los servicios y bases de datos. <br><br>  ¿Dónde conseguirlo?  Puede intentar registrarlo en el momento de la prueba, pero: <br><br><ul><li>  es largo y consume muchos recursos; <br></li><li>  después de completar la prueba, este usuario debe ser eliminado de alguna manera, lo cual es una tarea bastante trivial si hablamos de proyectos grandes; <br></li><li>  finalmente, como en muchos otros proyectos altamente cargados, realizamos muchas operaciones en segundo plano (agregando un usuario a varios servicios, replicación a otros centros de datos, etc.);  Las pruebas no saben nada sobre tales procesos, pero si se basan implícitamente en los resultados de su ejecución, existe el riesgo de inestabilidad. <br></li></ul><br><br>  Desarrollamos una herramienta llamada Test Users Pool.  Se basa en dos ideas: <br><br><ol><li>  No registramos usuarios cada vez, pero lo usamos muchas veces. <br></li><li>  Después de la prueba, restablecemos los datos del usuario a su estado original (en el momento del registro).  Si no se hace esto, las pruebas se volverán inestables con el tiempo, porque los usuarios estarán "contaminados" con la información de otras pruebas. <br></li></ol><br><br>  Funciona algo como esto: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  En algún momento, queríamos ejecutar nuestras pruebas de API en un entorno de producción.  ¿Por qué queremos esto?  Porque la infraestructura de desarrollo no es lo mismo que la producción. <br><br>  Aunque estamos tratando de repetir constantemente la infraestructura de producción en un tamaño reducido, el desarrollo nunca será una copia completa de la misma.  Para estar absolutamente seguro de que la nueva compilación cumple con las expectativas y no hay problemas, cargamos el nuevo código en el clúster de preproducción, que funciona con datos y servicios de producción, y ejecutamos nuestras pruebas de API allí. <br><br>  En este caso, es muy importante pensar en cómo aislar a los usuarios de prueba de los reales. <br><br><div class="spoiler">  <b class="spoiler_title">Qué sucederá si los usuarios de prueba comienzan a aparecer reales en nuestra aplicación.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  ¿Cómo aislar?  Cada uno de nuestros usuarios tiene una bandera <code>is_test_user</code> .  En la etapa de registro, se convierte en <code>yes</code> o <code>no</code> , y ya no cambia.  Con esta bandera, aislamos a los usuarios en todos los servicios.  También es importante que excluyamos a los usuarios de prueba del análisis empresarial y los resultados de las pruebas A / B para no distorsionar las estadísticas. <br><br>  Puede ir de una manera más simple: comenzamos con el hecho de que todos los usuarios de prueba fueron "reubicados" en la Antártida.  Si tiene un geoservicio, esta es una forma completamente funcional. <br><br><h3>  API de control de calidad </h3><br>  No solo necesitamos un usuario, lo necesitamos con ciertos parámetros: para trabajar como programador, participar en una determinada prueba A / B y fue registrado hace más de dos años.  Para los usuarios de prueba, podemos asignar fácilmente una profesión usando nuestra API de back-end, pero entrar en las pruebas A / B es probabilístico.  Y la condición de registro hace más de dos años es generalmente difícil de cumplir, porque no sabemos cuándo apareció el usuario en el grupo. <br><br>  Para resolver estos problemas, tenemos una API de control de calidad.  Esto, de hecho, es una puerta trasera para las pruebas, que es un método API bien documentado que le permite administrar rápida y fácilmente los datos del usuario y cambiar su estado sin pasar por el protocolo principal de nuestra comunicación con los clientes.  Los desarrolladores de backend escriben los métodos para ingenieros de control de calidad y para su uso en pruebas de interfaz de usuario y API. <br><br>  QA API solo se puede aplicar en el caso de usuarios de prueba: si no hay un indicador correspondiente, la prueba caerá inmediatamente.  Este es uno de nuestros métodos de API de control de calidad que le permite cambiar la fecha de registro del usuario a una arbitraria: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  Por lo tanto, se verán como tres llamadas que le permitirán cambiar rápidamente los datos del usuario de prueba para que cumplan las condiciones para mostrar la promoción: <br><br><ul><li>  En el campo "Trabajo" se indica el "programador": <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  El usuario participa en la prueba A / B HL18_promo: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Registrado hace más de dos años: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Como se trata de una puerta trasera, es imperativo pensar en la seguridad.  Protegimos nuestro servicio de varias maneras: <br><br><ul><li>  aislado a nivel de red: solo se puede acceder a los servicios desde la red de la oficina; <br></li><li>  con cada solicitud pasamos un secreto, sin el cual es imposible acceder a la API de QA incluso desde la red de la oficina; <br></li><li>  Los métodos solo funcionan con usuarios de prueba. <br></li></ul><br><br><h3>  Remotemocks </h3><br>  Para trabajar con el back-end remoto de las pruebas API, es posible que necesitemos simulacros.  Para que?  Por ejemplo, si la prueba de API en el entorno de producción comienza a acceder a la base de datos, debemos asegurarnos de que los datos en ella se borren de los datos de prueba.  Además, los simulacros ayudan a que la respuesta de la prueba sea más adecuada para la prueba. <br><br>  Tenemos tres textos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  Badoo es una aplicación multilingüe, tenemos un componente complejo de localización que le permite traducir y recibir traducciones rápidamente para la ubicación actual del usuario.  Nuestros localizadores trabajan constantemente para mejorar las traducciones, realizar pruebas A / B con tokens y buscar formulaciones más exitosas.  Y, mientras realizamos la prueba, no podemos saber qué texto devolverá el servidor; puede cambiar en cualquier momento.  Pero podemos usar RemoteMocks para verificar si se accede correctamente al componente de localización. <br><br>  ¿Cómo funcionan los RemoteMocks?  La prueba le pide al servidor que los inicialice para su sesión, y al recibir todas las solicitudes posteriores, el servidor comprueba si hay simulacros para la sesión actual.  Si lo son, simplemente los inicializa usando SoftMocks. <br><br>  Si queremos crear una simulación remota, indicamos qué clase o método necesita ser reemplazado y con qué.  Todas las solicitudes de backend posteriores se ejecutarán teniendo en cuenta este simulacro: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Bueno, ahora recopilemos nuestra prueba de API: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; … //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  De una manera tan simple, podemos probar cualquier funcionalidad que se desarrolle en el backend y requiera cambios en el protocolo móvil. <br><br><h3>  Reglas de uso de prueba de API </h3><br>  Todo parece estar bien, pero nuevamente encontramos un problema: las pruebas de API resultaron ser demasiado convenientes para el desarrollo y hubo la tentación de usarlas en todas partes.  Como resultado, una vez que nos dimos cuenta de que estábamos empezando a resolver problemas con la ayuda de las pruebas API para las cuales no estaban destinados. <br><br>  ¿Por qué es esto malo?  Porque las pruebas de API son muy lentas.  Se conectan a la red, se dirigen al backend, que recoge la sesión, va a la base de datos y a un conjunto de servicios.  Por lo tanto, desarrollamos un conjunto de reglas para usar pruebas API: <br><ul><li>  El propósito de las pruebas de API es verificar el protocolo de interacción entre el cliente y el servidor, así como la correcta integración del nuevo código; <br><br></li><li>  está permitido cubrir procesos complejos con ellos, por ejemplo, cadenas de acciones; <br></li><li>  no pueden usarse para probar la pequeña variabilidad de la respuesta del servidor; esta es la tarea de las pruebas unitarias; <br></li><li>  durante la revisión del código, verificamos las pruebas incluidas. <br></li></ul><br><h2>  Pruebas de IU </h2><br>  Como estamos considerando una pirámide de automatización, te contaré un poco sobre las pruebas de IU. <br><br>  Los desarrolladores de backend en Badoo no escriben pruebas de interfaz de usuario; para esto tenemos un equipo dedicado en el departamento de control de calidad.  Cubrimos la función con las pruebas de IU cuando ya se nos viene a la mente y se estabiliza, porque creemos que no es razonable gastar recursos en una automatización bastante costosa de la función, que, tal vez, no vaya más allá de la prueba A / B. <br><br>  Utilizamos Calabash para pruebas automáticas móviles y Selenium para la web.  Habla sobre nuestra plataforma de automatización y pruebas. <br><br><h2>  Prueba de funcionamiento </h2><br>  Ahora tenemos 100,000 pruebas unitarias, 6,000 - pruebas de integración y 14,000 pruebas API.  Si intenta ejecutarlos en un hilo, incluso en nuestra máquina más poderosa, una ejecución completa de todos tomará: modular - 40 minutos, integración - 90 minutos, pruebas API - diez horas.  Es muy largo <br><br><h3>  Paralelización </h3><br>  <i>Hablamos sobre nuestra experiencia de paralelizar pruebas unitarias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en este artículo</a> .</i> <br><br>  La primera solución, que parece obvia, es ejecutar pruebas en múltiples hilos.  Pero fuimos más allá e hicimos una nube para el lanzamiento paralelo para poder escalar los recursos de hardware.  Simplificado, su trabajo se ve así: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  La tarea más interesante aquí es la distribución de pruebas entre hilos, es decir, su desglose en trozos. <br><br>  Puede dividirlos por igual, pero las pruebas son diferentes, por lo que puede haber un fuerte sesgo en el tiempo de ejecución de un hilo: todos los hilos ya han llegado y uno se cuelga durante media hora, ya que fue "afortunado" con pruebas muy lentas. <br><br>  Puede iniciar varios subprocesos y alimentarlos con pruebas de uno en uno.  En este caso, el inconveniente es menos obvio: existen costos generales para inicializar el entorno, que, con una gran cantidad de pruebas y este enfoque, comienzan a desempeñar un papel importante. <br><br>  Que hemos hecho  Comenzamos a recopilar estadísticas sobre el tiempo necesario para ejecutar cada prueba, y luego comenzamos a componer fragmentos de tal manera que, según las estadísticas, un subproceso se ejecute por no más de 30 segundos.  Al mismo tiempo, empaquetamos las pruebas bastante bien en trozos para hacerlas más pequeñas. <br><br>  Sin embargo, nuestro enfoque también tiene un inconveniente.  Está asociado con las pruebas de API: son muy lentas y consumen muchos recursos, evitando que se ejecuten pruebas rápidas. <br><br>  Por lo tanto, dividimos la nube en dos partes: en la primera, solo se lanzan pruebas rápidas, y en la segunda, se pueden iniciar tanto rápido como lento.  Con este enfoque, siempre tenemos una parte de la nube que puede manejar pruebas rápidas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  Como resultado, las pruebas unitarias comenzaron a ejecutarse en un minuto, las pruebas de integración en cinco minutos y las pruebas de API en 15 minutos.  Es decir, una carrera completa en lugar de 12 horas no lleva más de 22 minutos. <br><br><h3>  Ejecución de prueba de cobertura de código </h3><br>  Tenemos un gran monolito complejo y, en el buen sentido, necesitamos ejecutar constantemente todas las pruebas, ya que un cambio en un lugar puede romper algo en otro.  Esta es una de las principales desventajas de la arquitectura monolítica. <br><br>  En algún momento, llegamos a la conclusión de que no es necesario ejecutar todas las pruebas cada vez; puede realizar ejecuciones basadas en la cobertura del código: <br><br><ol><li>  Toma nuestra rama diff. <br></li><li>  Creamos una lista de archivos modificados. <br></li><li>  Para cada archivo obtenemos una lista de pruebas, <br>  que lo cubren <br></li><li>  A partir de estas pruebas, creamos un conjunto y lo ejecutamos en una nube de prueba. <br></li></ol><br>  ¿Dónde obtener cobertura?  Recopilamos datos una vez al día cuando la infraestructura del entorno de desarrollo está inactiva.  El número de pruebas ejecutadas ha disminuido notablemente, la velocidad de recibir comentarios de ellos, por el contrario, ha aumentado significativamente.  Beneficio! <br><br>  Una ventaja adicional fue la capacidad de ejecutar pruebas para parches.  A pesar del hecho de que Badoo no ha sido una startup durante mucho tiempo, aún podemos implementar rápidamente cambios en la producción, verter soluciones rápidas, implementar características y cambiar la configuración.  Como regla general, la velocidad de implementación de parches es muy importante para nosotros.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nuevo enfoque dio un gran aumento en la velocidad de retroalimentación de las pruebas, porque ahora no necesitamos esperar mucho para una ejecución completa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero sin los defectos en ninguna parte. </font><font style="vertical-align: inherit;">Lanzaremos el back-end dos veces al día, y la cobertura es relevante solo para la primera versión, hasta la primera compilación, después de lo cual comienza a retrasarse una compilación. </font><font style="vertical-align: inherit;">Por lo tanto, para las compilaciones, ejecutamos un conjunto de pruebas completo. </font><font style="vertical-align: inherit;">Para nosotros, esto es una garantía de que la cobertura del código no se queda atrás y que se han completado todas las pruebas necesarias. </font><font style="vertical-align: inherit;">Lo peor que puede suceder es que atraparemos algunas pruebas fallidas en la etapa de construcción de la construcción, y no en las etapas anteriores. </font><font style="vertical-align: inherit;">Pero esto sucede muy raramente.</font></font><br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Conclusión </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ≠ .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  12:00,  —   YouTube-</a></b> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443768/">https://habr.com/ru/post/443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443754/index.html">Sobre la idoneidad de Selenium WebDriverWait</a></li>
<li><a href="../443756/index.html">Diseño de clase: ¿qué es bueno?</a></li>
<li><a href="../443758/index.html">Quick Draw Doodle Recognition: Cómo hacer amigos R, C ++ y cuadrículas neuronales</a></li>
<li><a href="../443764/index.html">Lo que el diseñador fumó: un arma de fuego inusual</a></li>
<li><a href="../443766/index.html">Probar la programación de contratos de C ++ 20 ahora</a></li>
<li><a href="../443770/index.html">Diseño dirigido por dominio: objetos de valor y marco de entidad básico en la práctica</a></li>
<li><a href="../443772/index.html">Antigüedades: IBM ThinkPad T40, la primera conexión inalámbrica</a></li>
<li><a href="../443774/index.html">Cómo la neurobiología interfiere en las elecciones presidenciales de EE. UU.</a></li>
<li><a href="../443776/index.html">China introduce un sistema experimental de reconocimiento facial al pagar el metro</a></li>
<li><a href="../443780/index.html">Proyecto MCDM. Parte 1. Concepto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>