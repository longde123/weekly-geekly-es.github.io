<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏻 👨‍👧 👊🏾 Cara kerja JS: kelas dan pewarisan, transpilasi dalam Babel dan TypeScript 📤 👽 👊🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kelas adalah salah satu cara paling populer untuk menyusun proyek perangkat lunak dewasa ini. Pendekatan pemrograman ini juga digunakan dalam JavaScri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja JS: kelas dan pewarisan, transpilasi dalam Babel dan TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415377/">  Kelas adalah salah satu cara paling populer untuk menyusun proyek perangkat lunak dewasa ini.  Pendekatan pemrograman ini juga digunakan dalam JavaScript.  Hari ini kami menerbitkan terjemahan bagian 15 dari seri ekosistem JS.  Artikel ini akan membahas berbagai pendekatan untuk mengimplementasikan kelas dalam JavaScript, mekanisme pewarisan, dan transpirasi.  Kami akan mulai dengan memberi tahu Anda bagaimana prototipe bekerja dan dengan menganalisis berbagai cara untuk mensimulasikan pewarisan berbasis kelas di perpustakaan populer.  Selanjutnya, kita akan berbicara tentang bagaimana, berkat transpilasi, dimungkinkan untuk menulis program JS yang menggunakan fitur yang tidak tersedia dalam bahasa atau, meskipun mereka ada dalam bentuk standar baru atau proposal yang berada pada tahap persetujuan yang berbeda, belum dilaksanakan di JS- mesin.  Secara khusus, kita akan berbicara tentang Babel dan TypeScript dan kelas ECMAScript 2015. Setelah itu, kita akan melihat beberapa contoh yang menunjukkan fitur implementasi internal kelas di mesin V8 JS. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/196/736/c87/196736c87449034c2354db7c52f1cd08.png" alt="gambar"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">[Nasihat membaca] 19 bagian siklus lainnya</b> <div class="spoiler_text"> Bagian 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinjauan umum mesin, mekanisme runtime, panggilan stack</a> <br>  Bagian 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentang V8 internal dan optimasi kode</a> <br>  Bagian 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola memori, empat jenis memori bocor dan berurusan dengannya</a> <br>  Bagian 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Event Loop, Async, dan Five Ways untuk Meningkatkan Kode Anda dengan async / menunggu</a> <br>  Bagian 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebSocket dan HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa yang harus dipilih?</a> <br>  Bagian 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fitur dan ruang lingkup WebAssembly</a> <br>  Bagian 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Web dan Lima Skenario Penggunaan</a> <br>  Bagian 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pekerja Layanan</a> <br>  Bagian 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemberitahuan push web</a> <br>  Bagian 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lacak perubahan di DOM dengan MutationObserver</a> <br>  Bagian 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin rendering halaman web dan tip untuk mengoptimalkan kinerja mereka</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 12: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Subsistem jaringan browser, mengoptimalkan kinerja dan keamanannya</a> <br>  Bagian 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi dengan CSS dan JavaScript</a> <br>  Bagian 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Pohon Sintaks Abstrak, Parsing dan Optimalisasi nya</a> <br>  Bagian 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kerja JS: kelas dan warisan, transpilasi dalam Babel dan TypeScript</a> <br>  Bagian 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Penyimpanan</a> <br>  Bagian 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Shadow DOM Technology dan Komponen Web</a> <br>  Bagian 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana JS Bekerja: Mekanisme Komunikasi WebRTC dan P2P</a> <br>  Bagian 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Kerja JS: Elemen Kustom</a> </div></div><br><h2>  <font color="#3AC1EF">Ulasan</font> </h2><br>  Dalam JavaScript, kami terus-menerus dihadapkan dengan objek, bahkan ketika tampaknya kami bekerja dengan tipe data primitif.  Misalnya, buat string literal: <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>;</code> </pre> <br>  Setelah itu, kita dapat langsung beralih ke <code>name</code> untuk memanggil berbagai metode objek bertipe <code>String</code> , yang string literal yang kita buat akan secara otomatis dikonversi. <br><br><pre> <code class="hljs pgsql">console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">2</span></span>)); // SessionStackSessionStack console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>.toLowerCase()); // sessionstack</code> </pre> <br>  Tidak seperti bahasa lain, dalam JavaScript, setelah membuat variabel yang berisi, misalnya, string atau angka, kita dapat, tanpa melakukan konversi eksplisit, bekerja dengan variabel ini seolah-olah awalnya dibuat menggunakan kata kunci <code>new</code> dan konstruktor yang sesuai.  Akibatnya, karena penciptaan objek secara otomatis yang merangkum nilai-nilai primitif, Anda dapat bekerja dengan nilai-nilai seperti jika mereka objek, khususnya, merujuk pada metode dan properti mereka. <br><br>  Fakta penting lainnya mengenai sistem tipe JavaScript adalah bahwa, misalnya, array juga objek.  Jika Anda melihat output dari perintah <code>typeof</code> untuk array, Anda dapat melihat bahwa itu melaporkan bahwa entitas yang diselidiki memiliki tipe data <code>object</code> .  Akibatnya, ternyata indeks elemen-elemen array hanya properti dari objek tertentu.  Oleh karena itu, ketika kita mengakses elemen array dengan indeks, ia akan bekerja dengan properti objek bertipe <code>Array</code> dan mendapatkan nilai properti ini.  Jika kita berbicara tentang bagaimana data disimpan di dalam objek dan array biasa, maka dua konstruksi berikut mengarah pada pembuatan struktur data yang hampir identik: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = [<span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> names = { <span class="hljs-string"><span class="hljs-string">"0"</span></span>: <span class="hljs-string"><span class="hljs-string">"SessionStack"</span></span>, <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Akibatnya, akses ke elemen-elemen array dan ke properti objek dilakukan pada kecepatan yang sama.  Penulis artikel ini mengatakan bahwa ia menemukan jalan untuk menyelesaikan satu masalah kompleks.  Yaitu, begitu ia perlu melakukan optimasi serius terhadap sepotong kode yang sangat penting dalam proyek tersebut.  Setelah mencoba banyak pendekatan sederhana, ia memutuskan untuk mengganti semua objek yang digunakan dalam kode ini dengan array.  Secara teori, mengakses elemen array lebih cepat daripada bekerja dengan kunci tabel hash.  Yang mengejutkan, penggantian ini tidak mempengaruhi kinerja dengan cara apa pun, karena bekerja dengan array dan bekerja dengan objek dalam JavaScript turun untuk berinteraksi dengan kunci-kunci tabel hash, yang, dalam kedua kasus, membutuhkan jumlah waktu yang sama. <br><br><h2>  <font color="#3AC1EF">Mensimulasikan kelas menggunakan prototipe</font> </h2><br>  Ketika kita berpikir tentang objek, hal pertama yang terlintas dalam pikiran adalah kelas.  Mungkin masing-masing dari mereka yang terlibat dalam pemrograman hari ini menciptakan aplikasi yang strukturnya didasarkan pada kelas dan pada hubungan di antara mereka.  Meskipun objek dalam JavaScript dapat ditemukan secara harfiah di mana-mana, bahasanya tidak menggunakan sistem pewarisan berbasis kelas tradisional.  JavaScript menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prototipe</a> untuk memecahkan masalah serupa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/ba7/cab/633ba7cabdf251ed3747fb2a3764b344.png"></div><br>  <i><font color="#999999">Obyek dan prototipe-nya</font></i> <br><br>  Dalam JavaScript, setiap objek dikaitkan dengan objek lain - dengan prototipe sendiri.  Ketika Anda mencoba mengakses properti atau metode objek, pencarian apa yang Anda butuhkan pertama kali dilakukan di objek itu sendiri.  Jika pencarian tidak berhasil, ia melanjutkan prototipe objek. <br><br>  Pertimbangkan contoh sederhana yang menjelaskan fungsi konstruktor untuk kelas dasar <code>Component</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } Component.prototype.render = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content); }</code> </pre> <br>  Di sini kita menetapkan fungsi <code>render()</code> ke metode prototipe, karena kita membutuhkan setiap instance dari kelas <code>Component</code> untuk menggunakan metode ini.  Ketika, dalam setiap instance dari <code>Component</code> , metode <code>render</code> dipanggil, pencariannya dimulai pada objek itu sendiri yang dipanggil.  Kemudian pencarian berlanjut di prototipe, di mana sistem menemukan metode ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/553/6d8/74d/5536d874d81cc44b164174953614f725.png"></div><br>  <i><font color="#999999">Prototipe dan dua contoh kelas Komponen</font></i> <br><br>  Sekarang mari kita coba memperluas kelas <code>Component</code> .  Mari kita buat konstruktor untuk kelas baru - <code>InputField</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   this.content = `&lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{value}"</span></span> /&gt;`; }</code> </pre> <br>  Jika kita membutuhkan kelas <code>InputField</code> memperluas fungsionalitas kelas <code>Component</code> dan dapat memanggil metode <code>InputField</code> , kita perlu mengubah prototipe.  Ketika suatu metode dipanggil pada turunan kelas anak, tidak masuk akal untuk mencarinya dalam prototipe kosong.  Kita perlu, dalam pencarian metode ini, ditemukan di kelas <code>Component</code> .  Karena itu, kita perlu melakukan hal berikut: <br><br><pre> <code class="hljs pgsql">InputField.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Component());</code> </pre> <br>  Sekarang, ketika bekerja dengan turunan dari kelas <code>InputField</code> dan memanggil metode kelas <code>Component</code> , metode ini akan ditemukan dalam prototipe kelas <code>Component</code> .  Untuk menerapkan sistem warisan, Anda harus menghubungkan prototipe <code>InputField</code> ke turunan dari kelas <code>Component</code> .  Banyak perpustakaan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Object.setPrototypeOf ()</a> untuk menyelesaikan masalah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5c/c43/ba8/f5cc43ba8e7a66cf1bb5c8aecec04572.png"></div><br>  <i><font color="#999999">Memperluas Kelas Komponen dengan Kelas InputField</font></i> <br><br>  Namun, tindakan di atas tidak cukup untuk menerapkan mekanisme yang mirip dengan warisan tradisional.  Setiap kali kami memperluas kelas, kami perlu melakukan tindakan berikut: <br><br><ul><li>  Jadikan prototipe kelas turunan sebagai turunan dari kelas induk. </li><li>  Panggil, di konstruktor kelas turunan, konstruktor kelas induk untuk memastikan bahwa kelas induk diinisialisasi dengan benar. </li><li>  Berikan mekanisme untuk memanggil metode dari kelas induk dalam situasi di mana kelas turunan menimpa metode induk, tetapi ada kebutuhan untuk memanggil implementasi asli dari metode ini dari kelas induk. </li></ul><br>  Seperti yang Anda lihat, jika pengembang JS ingin menggunakan kemampuan warisan berbasis kelas, ia harus terus melakukan langkah-langkah di atas.  Jika Anda perlu membuat banyak kelas, semua ini bisa dibuat dalam bentuk fungsi yang cocok untuk digunakan kembali. <br><br>  Bahkan, tugas mengatur warisan berdasarkan kelas awalnya diselesaikan dalam praktik pengembangan JS dengan cara ini.  Secara khusus, menggunakan berbagai perpustakaan.  Solusi semacam itu menjadi sangat populer, yang dengan jelas menunjukkan bahwa ada sesuatu yang jelas hilang dalam JavaScript.  Itulah sebabnya ECMAScript 2015 memperkenalkan konstruksi sintaksis baru yang bertujuan mendukung pekerjaan dengan kelas dan menerapkan mekanisme pewarisan yang sesuai. <br><br><h2>  <font color="#3AC1EF">Transilasi kelas</font> </h2><br>  Setelah fitur baru ECMAScript 2015 (ES6) diusulkan, komunitas JS ingin memanfaatkannya sesegera mungkin, tanpa menunggu penyelesaian proses panjang untuk menambahkan dukungan untuk fitur-fitur ini di mesin dan browser JS.  Dalam memecahkan masalah seperti itu, transpilasi itu baik.  Dalam hal ini, kompilasi dikurangi menjadi mentransformasikan kode JS yang ditulis sesuai dengan aturan ES6 ke tampilan yang dapat dimengerti oleh browser yang sejauh ini tidak mendukung kemampuan ES6.  Sebagai hasilnya, misalnya, dimungkinkan untuk mendeklarasikan kelas dan menerapkan mekanisme pewarisan berbasis kelas sesuai dengan aturan ES6 dan mengubah konstruksi ini menjadi kode yang berfungsi di browser apa pun.  Secara skematis, proses ini, menggunakan contoh memproses fungsi panah oleh transpiler (fitur bahasa baru lain yang membutuhkan waktu untuk mendukung), dapat direpresentasikan seperti yang ditunjukkan pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/37b/f2c/80237bf2c453fb8f9d7913c310a21384.png"></div><br>  <i><font color="#999999">Transpilasi</font></i> <br><br>  Salah satu pengalih JavaScript yang paling populer adalah Babel.js.  Mari kita lihat cara kerjanya dengan melakukan kompilasi kode deklarasi kelas <code>Component</code> , yang kita bicarakan di atas.  Jadi di sini adalah kode ES6: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Component(<span class="hljs-string"><span class="hljs-string">'SessionStack'</span></span>); component.render();</code> </pre> <br>  Dan inilah kode ini setelah transformasi: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Component = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Component</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Component);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } _createClass(Component, [{   <span class="hljs-attr"><span class="hljs-attr">key</span></span>: <span class="hljs-string"><span class="hljs-string">'render'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content);   } }]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Component; }();</code> </pre> <br>  Seperti yang Anda lihat, ECMAScript 5-code diperoleh pada output transpiler, yang dapat dijalankan di lingkungan apa pun.  Selain itu, panggilan ke beberapa fungsi yang merupakan bagian dari perpustakaan standar Babel ditambahkan di sini. <br><br>  Kita berbicara tentang fungsi <code>_classCallCheck()</code> dan <code>_createClass()</code> termasuk dalam kode yang ditranskrip.  Fungsi pertama, <code>_classCallCheck()</code> , dirancang untuk mencegah fungsi konstruktor dipanggil seperti fungsi biasa.  Untuk melakukan ini, ia memeriksa apakah konteks di mana fungsi dipanggil adalah konteks instance dari kelas <code>Component</code> .  Kode memeriksa untuk melihat apakah kata kunci ini menunjuk ke contoh yang sama.  Fungsi kedua, <code>_createClass()</code> , membuat properti objek yang diteruskan kepadanya sebagai array objek yang berisi kunci dan nilainya. <br><br>  Untuk memahami cara kerja pewarisan, kami menganalisis kelas <code>InputField</code> , yang merupakan turunan dari kelas <code>Component</code> .  Inilah cara hubungan kelas bersatu dalam ES6: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Berikut adalah hasil pengubahan kode ini menggunakan Babel: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_Component</span></span></span><span class="hljs-function">) </span></span>{ _inherits(InputField, _Component); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{   _classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, InputField);   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">'&lt;input type="text" value="'</span></span> + value + <span class="hljs-string"><span class="hljs-string">'" /&gt;'</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _possibleConstructorReturn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, (InputField.__proto__ || <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(InputField)).call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component);</code> </pre> <br>  Dalam contoh ini, logika mekanisme pewarisan dienkapsulasi dalam panggilan ke fungsi <code>_inherits()</code> .  Itu melakukan tindakan yang sama yang kami jelaskan di atas, terkait, khususnya, dengan menulis ke prototipe kelas turunan dari kelas induk. <br><br>  Untuk mengubah kode, Babel melakukan beberapa transformasi.  Pertama, kode ES6 diuraikan dan dikonversi ke representasi perantara yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon sintaksis abstrak</a> .  Kemudian pohon sintaksis abstrak yang dihasilkan dikonversi ke pohon lain, setiap node yang ditransformasikan menjadi setara ES5.  Akibatnya, pohon ini dikonversi ke kode JS. <br><br><h2>  <font color="#3AC1EF">Pohon sintaksis abstrak di Babel</font> </h2><br>  Pohon sintaksis abstrak berisi node, yang masing-masing hanya memiliki satu simpul induk.  Babel memiliki tipe dasar untuk node.  Ini berisi informasi tentang apa simpul itu dan di mana ia dapat ditemukan dalam kode.  Ada berbagai jenis node, misalnya, node untuk mewakili literal, seperti string, angka, nilai <code>null</code> , dan sebagainya.  Selain itu, ada node untuk mewakili ekspresi yang digunakan untuk mengontrol aliran eksekusi program ( <code>if</code> membangun), dan node untuk loop ( <code>for</code> , <code>while</code> ).  Ada juga tipe simpul khusus untuk mewakili kelas.  Ini adalah turunan dari kelas dasar <code>Node</code> .  Dia memperluas kelas ini dengan menambahkan bidang untuk menyimpan referensi ke kelas dasar dan ke tubuh kelas sebagai simpul yang terpisah. <br>  Ubah fragmen kode berikut ke struktur sintaksis abstrak: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content; } render() {   console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content) } }</code> </pre> <br>  Inilah tampilan representasi skematisnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8b/4c5/c1d/a8b4c5c1d077388bac770d1b452e51ed.png"></div><br>  <i><font color="#999999">Pohon sintaksis abstrak</font></i> <br><br>  Setelah membuat pohon, masing-masing node ditransformasikan menjadi simpul ES5 yang sesuai, setelah itu pohon baru ini dikonversi menjadi kode yang sesuai dengan standar ECMAScript 5. Selama proses konversi, pertama-tama cari node yang letaknya paling jauh dari node root, setelah itu node ini dikonversi ke kode menggunakan potongan yang dihasilkan untuk setiap node.  Setelah itu, proses diulang.  Teknik ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian dalam</a> . <br><br>  Dalam contoh di atas, kode untuk dua node <code>MethodDefinition</code> akan dihasilkan terlebih dahulu, setelah itu kode untuk node <code>ClassBody</code> akan dihasilkan, dan akhirnya, kode untuk node <code>ClassDeclaration</code> . <br><br><h2>  <font color="#3AC1EF">Transparansi TypeScript</font> </h2><br>  Sistem populer lain yang menggunakan transpilasi adalah TypeScript.  Ini adalah bahasa pemrograman yang kodenya ditransformasikan menjadi kode ECMAScript 5 yang dapat dimengerti oleh mesin JS.  Ini menawarkan sintaks baru untuk menulis aplikasi JS.  Berikut cara menerapkan kelas <code>Component</code> pada TypeScript: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   content: string;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(content: string) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = content;   }   render() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content)   } }</code> </pre> <br>  Berikut adalah sintaksis abstrak untuk kode ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/332/806/ad0/332806ad0bd9882f32c58c0280a8ae40.png"></div><br>  <i><font color="#999999">Pohon sintaksis abstrak</font></i> <br><br>  TypeScript mendukung warisan. <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputField</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   constructor(value: string) {       const content = `&lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> value=<span class="hljs-string"><span class="hljs-string">"${value}"</span></span> /&gt;`;       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(content);   } }</code> </pre> <br>  Berikut ini adalah hasil dari transpilasi kode ini: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> InputField = <span class="hljs-comment"><span class="hljs-comment">/** @class */</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_super)</span></span></span><span class="hljs-function"> </span></span>{   __extends(InputField, _super);   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InputField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-string"><span class="hljs-string">"&lt;input type=\"text\" value=\""</span></span> + value + <span class="hljs-string"><span class="hljs-string">"\" /&gt;"</span></span>;       _this = _super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, content) || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _this;   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InputField; }(Component));</code> </pre> <br>  Seperti yang Anda lihat, ini lagi-lagi kode ES5, di mana, di samping konstruksi standar, ada panggilan ke beberapa fungsi dari pustaka TypeScript.  Kemampuan fungsi <code>__extends()</code> mirip dengan yang kami bicarakan di awal materi ini. <br><br>  Berkat adopsi Babel dan TypeScript yang meluas, mekanisme untuk mendeklarasikan kelas dan mengatur warisan berbasis kelas telah menjadi alat standar untuk menyusun aplikasi JS.  Ini berkontribusi pada penambahan dukungan untuk mekanisme ini di browser. <br><br><h2>  <font color="#3AC1EF">Dukungan Kelas Peramban</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dukungan kelas</a> muncul di browser Chrome pada 2014.  Ini memungkinkan browser untuk bekerja dengan deklarasi kelas tanpa menggunakan transpilasi atau pustaka bantu apa pun. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/860/a55/ad5860a550c7956d6bbf17cd1b0afbb6.png"></div><br>  <i><font color="#999999">Bekerja dengan kelas di konsol Chrome JS</font></i> <br><br>  Faktanya, dukungan browser untuk mekanisme ini tidak lebih dari gula sintaksis.  Konstruksi ini dikonversi ke struktur dasar yang sama yang sudah didukung oleh bahasa.  Akibatnya, bahkan jika Anda menggunakan sintaks baru, pada level yang lebih rendah, semuanya akan terlihat seperti membuat konstruktor dan memanipulasi prototipe objek: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/d1c/a5b/b61d1ca5b3d35b3b1f431ae8e82c48bd.png"></div><br>  <i><font color="#999999">Dukungan kelas adalah gula sintaksis</font></i> <br><br><h2>  <font color="#3AC1EF">Dukungan Kelas di V8</font> </h2><br>  Mari kita bicara tentang bagaimana dukungan kelas ES6 bekerja di mesin V8 JS.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi sebelumnya yang</a> dikhususkan untuk pohon sintaksis abstrak, kami berbicara tentang fakta bahwa ketika mempersiapkan JS-code untuk dieksekusi, sistem mem-parsingnya dan membentuk pohon sintaksis abstrak pada dasarnya.  Ketika parsing konstruksi deklarasi kelas, node tipe <a href="">ClassLiteral</a> jatuh ke pohon sintaksis abstrak. <br><br>  Node-node ini menyimpan beberapa hal menarik.  Pertama, itu adalah konstruktor sebagai fungsi terpisah, dan kedua, itu adalah daftar properti kelas.  Ini bisa berupa metode, getter, setter, bidang publik atau pribadi.  Node seperti itu, di samping itu, menyimpan referensi ke kelas induk, yang memperluas kelas yang membentuk simpul, yang, sekali lagi, menyimpan konstruktor, daftar properti dan tautan ke kelas induknya sendiri. <br><br>  Setelah node <code>ClassLiteral</code> baru <a href="">ditransformasikan menjadi kode</a> , itu dikonversi menjadi konstruksi yang terdiri dari fungsi dan prototipe. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Penulis materi ini mengatakan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SessionStack</a> berusaha untuk mengoptimalkan kode perpustakaannya semaksimal mungkin, karena harus menyelesaikan tugas-tugas sulit mengumpulkan informasi tentang segala sesuatu yang terjadi di halaman web.  Dalam menyelesaikan masalah ini, perpustakaan seharusnya tidak memperlambat pekerjaan halaman yang dianalisis.  Optimalisasi tingkat ini memerlukan memperhitungkan detail terkecil dari ekosistem JavaScript yang memengaruhi kinerja, khususnya, dengan mempertimbangkan fitur bagaimana kelas dan mekanisme pewarisan diatur dalam ES6. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan konstruksi sintaks ES6 untuk bekerja dengan kelas dalam JavaScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415377/">https://habr.com/ru/post/id415377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415367/index.html">Bagaimana jika alien berubah menjadi mesin dengan kecerdasan buatan?</a></li>
<li><a href="../id415369/index.html">Harga Refactoring</a></li>
<li><a href="../id415371/index.html">Privasi Cryptocurrency</a></li>
<li><a href="../id415373/index.html">NumPy dengan Python. Bagian 4</a></li>
<li><a href="../id415375/index.html">Domba Tersembunyi dan Tipografi Arkeologi</a></li>
<li><a href="../id415381/index.html">Bermain dengan Kubernetes - layanan untuk kenalan praktis dengan K8s</a></li>
<li><a href="../id415383/index.html">Pedagang pemula membuat kesepakatan € 5,5 miliar karena kesalahan dalam sistem broker Inggris</a></li>
<li><a href="../id415385/index.html">Situasi DCIM: Bagaimana Manajemen Infrastruktur Pusat Data Berubah dalam Beberapa Tahun Terakhir</a></li>
<li><a href="../id415387/index.html">Setiap pengembang ingin tahu cara masuk ke phishing.</a></li>
<li><a href="../id415389/index.html">Hari ini, sistem pembayaran "VKontakte"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>