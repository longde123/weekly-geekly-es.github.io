<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏽 🙏🏽 🎺 ConfigureAwait: Pertanyaan yang Sering Diajukan ☀️ 🚢 📵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya hadir untuk Anda terjemahan artikel FAQ ConfigureAwait oleh Stephen Taub. 



 Async / await ditambahkan ke .NET lebih dari tujuh tah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait: Pertanyaan yang Sering Diajukan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/"> Halo, Habr!  Saya hadir untuk Anda terjemahan artikel <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">FAQ ConfigureAwait</a> oleh Stephen Taub. <br><br><img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="gambar"><br><br>  <code>Async</code> / <code>await</code> ditambahkan ke .NET lebih dari tujuh tahun yang lalu.  Keputusan ini memiliki dampak signifikan tidak hanya pada ekosistem .NET - juga tercermin dalam banyak bahasa dan kerangka kerja lainnya.  Saat ini, banyak perbaikan dalam .NET telah diimplementasikan dalam hal konstruksi bahasa tambahan menggunakan asinkron, API dengan dukungan asinkron telah diimplementasikan, perbaikan mendasar telah dibuat dalam infrastruktur karena <code>async</code> / <code>await</code> berfungsi seperti jam (khususnya, kinerja dan kemampuan diagnostik telah ditingkatkan dalam. NET Core). <br><br>  <code>ConfigureAwait</code> adalah salah satu aspek <code>async</code> / <code>await</code> yang terus menimbulkan pertanyaan.  Saya harap saya bisa menjawab banyak dari mereka.  Saya akan mencoba membuat artikel ini dapat dibaca dari awal hingga akhir, dan pada saat yang sama mengeksekusi dengan gaya jawaban untuk pertanyaan yang sering diajukan (FAQ) sehingga dapat direferensikan di masa depan. <a name="habracut"></a><br><br>  Untuk benar-benar berurusan dengan <code>ConfigureAwait</code> , kami akan kembali sedikit. <br><br><h3>  Apa itu SynchronizationContext? </h3><br>  Menurut dokumentasi <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext%3Fview%3Dnetframework-4.8" rel="nofollow">System.Threading.SynchronizationContext</a> "Menyediakan fungsionalitas dasar untuk mendistribusikan konteks sinkronisasi dalam berbagai model sinkronisasi."  Definisi ini tidak sepenuhnya jelas. <br><br>  Dalam 99,9% kasus, <code>SynchronizationContext</code> digunakan hanya sebagai jenis dengan metode virtual <code>Post</code> , yang menerima delegasi untuk eksekusi asynchronous (ada anggota virtual lainnya di <code>SynchronizationContext</code> , tetapi mereka kurang umum dan tidak akan dibahas dalam artikel ini).  Metode <code>Post</code> dari tipe dasar secara harfiah <a href="" rel="nofollow">hanya memanggil</a> <code>ThreadPool.QueueUserWorkItem</code> untuk secara asinkron mengeksekusi delegasi yang disediakan.  Tipe turunan menimpa <code>Post</code> sehingga delegasi dapat mengeksekusi di tempat yang tepat pada waktu yang tepat. <br><br>  Misalnya, Windows Forms memiliki <a href="" rel="nofollow">tipe</a> yang diturunkan dari SynchronizationContext yang mendefinisikan kembali <code>Post</code> untuk membuat yang setara dengan <code>Control.BeginInvoke</code> .  Ini berarti bahwa setiap panggilan ke metode <code>Post</code> ini akan menghasilkan panggilan ke delegasi pada tahap selanjutnya di utas yang terkait dengan Kontrol yang sesuai - yang disebut utas UI.  Di jantung Windows Forms adalah pemrosesan pesan Win32.  Loop pesan dieksekusi di utas UI yang hanya menunggu pesan baru untuk diproses.  Pesan-pesan ini dipicu oleh gerakan mouse, klik, input keyboard, peristiwa sistem yang tersedia untuk dieksekusi oleh delegasi, dll. Oleh karena itu, jika Anda memiliki instance <code>SynchronizationContext</code> untuk utas UI di aplikasi Windows Forms, Anda harus meneruskan delegasi ke metode <code>Post</code> untuk melakukan operasi di dalamnya. <br><br>  Windows Presentation Foundation (WPF) juga memiliki <a href="" rel="nofollow">tipe yang</a> diturunkan dari <code>SynchronizationContext</code> dengan metode <code>Post</code> diganti yang juga “mengarahkan” delegasi ke aliran UI (menggunakan <code>Dispatcher.BeginInvoke</code> ), dengan kontrol WPF Dispatcher, bukan kontrol Windows Forms. <br><br>  Dan Windows RunTime (WinRT) memiliki <a href="" rel="nofollow">jenis</a> turunan <code>SynchronizationContext</code> -nya sendiri, yang juga menempatkan delegasi dalam <code>CoreDispatcher</code> utas UI menggunakan <code>CoreDispatcher</code> . <br><br>  Inilah yang ada di balik frasa “run delegate in UI thread”.  Anda juga dapat mengimplementasikan <code>SynchronizationContext</code> Anda dengan metode <code>Post</code> dan beberapa implementasi.  Misalnya, saya tidak perlu khawatir tentang utas mana yang dijalankan oleh delegasi, tetapi saya ingin memastikan bahwa setiap delegasi metode <code>Post</code> di <code>SynchronizationContext</code> saya berjalan dengan beberapa derajat paralelisme yang terbatas.  Anda dapat menerapkan Context <code>SynchronizationContext</code> kustom dengan cara ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _semaphore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxConcurrencyLevel</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(maxConcurrencyLevel); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskContinuationOptions.None, TaskScheduler.Default); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _semaphore.Wait(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } } }</code> </pre> <br>  Kerangka kerja xUnit memiliki <a href="" rel="nofollow">implementasi yang</a> sama <a href="" rel="nofollow">dari</a> SynchronizationContext.  Di sini digunakan untuk mengurangi jumlah kode yang terkait dengan tes paralel. <br><br>  Keuntungan di sini adalah sama dengan abstraksi apa pun: API tunggal disediakan yang dapat digunakan untuk mengantri delegasi untuk dieksekusi dengan cara yang diinginkan programmer, tanpa harus mengetahui detail implementasi.  Misalkan saya menulis perpustakaan di mana saya perlu melakukan beberapa pekerjaan dan kemudian mengantri delegasi kembali ke konteks aslinya.  Untuk melakukan ini, saya perlu menangkap <code>SynchronizationContext</code> -nya, dan ketika saya menyelesaikan apa yang diperlukan, saya hanya perlu memanggil metode <code>Post</code> dari konteks ini dan mengirimkannya delegasi untuk dieksekusi.  Saya tidak perlu tahu bahwa untuk Formulir Windows Anda harus mengambil <code>Control</code> dan menggunakan <code>BeginInvoke</code> -nya, untuk WPF menggunakan <code>BeginInvoke</code> dari <code>Dispatcher</code> , atau entah bagaimana mendapatkan konteks dan antriannya untuk xUnit.  Yang perlu saya lakukan adalah mengambil <code>SynchronizationContext</code> saat ini dan menggunakannya nanti.  Untuk melakukan ini, <code>SynchronizationContext</code> memiliki properti <code>Current</code> .  Ini dapat diimplementasikan sebagai berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action worker, Action completion</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; ThreadPool.QueueUserWorkItem(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { worker(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }); }</code> </pre> <br>  Anda dapat mengatur konteks khusus dari properti <code>Current</code> menggunakan metode <code>SynchronizationContext.SetSynchronizationContext</code> . <br><br><h3>  Apa itu Penjadwal Tugas? </h3><br>  <code>SynchronizationContext</code> adalah abstraksi umum untuk "scheduler".  Beberapa kerangka kerja menggunakan abstraksi mereka sendiri untuk itu, dan <code>System.Threading.Tasks</code> tidak terkecuali.  Ketika ada delegasi di <code>Task</code> yang dapat antri dan dieksekusi, mereka terkait dengan <code>System.Threading.Tasks.TaskScheduler</code> .  Ada juga metode <code>Post</code> virtual untuk mengantri delegasi (panggilan delegasi diimplementasikan menggunakan mekanisme standar), <code>TaskScheduler</code> menyediakan metode <code>QueueTask</code> abstrak (panggilan tugas diimplementasikan menggunakan metode <code>ExecuteTask</code> ). <br><br>  Penjadwal default yang mengembalikan <code>TaskScheduler.Default</code> adalah kumpulan utas.  Dari <code>TaskScheduler</code> juga dimungkinkan untuk mendapatkan dan mengganti metode untuk mengatur waktu dan tempat pemanggilan <code>Task</code> .  Misalnya, pustaka inti menyertakan tipe <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> .  Sebuah instance dari kelas ini menyediakan dua properti <code>TaskScheduler</code> : <code>ExclusiveScheduler</code> dan <code>ConcurrentScheduler</code> .  Tugas-tugas yang dijadwalkan di <code>ConcurrentScheduler</code> dapat dilakukan secara paralel, tetapi dengan mempertimbangkan batasan yang ditetapkan oleh <code>ConcurrentExclusiveSchedulerPair</code> ketika dibuat (mirip dengan <code>MaxConcurrencySynchronizationContext</code> ).  Tidak ada tugas <code>ConcurrentScheduler</code> akan dieksekusi jika tugas dieksekusi dalam <code>ExclusiveScheduler</code> dan hanya satu tugas eksklusif yang diizinkan untuk dijalankan pada suatu waktu.  Perilaku ini sangat mirip dengan kunci baca / tulis. <br><br>  Seperti <code>SynchronizationContext</code> , <code>TaskScheduler</code> memiliki properti <code>Current</code> yang mengembalikan <code>TaskScheduler</code> saat ini.  Namun, tidak seperti <code>SynchronizationContext</code> , ia tidak memiliki metode untuk mengatur penjadwal saat ini.  Sebagai gantinya, penjadwal dikaitkan dengan tugas saat ini.  Jadi, misalnya, program ini akan menampilkan <code>True</code> , karena lambda yang digunakan di <code>StartNew</code> dieksekusi dalam instance <code>ExclusiveScheduler</code> dari <code>ConcurrentExclusiveSchedulerPair</code> , dan <code>TaskScheduler.Current</code> diinstal pada penjadwal ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cesp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentExclusiveSchedulerPair(); Task.Factory.StartNew(() =&gt; { Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler); }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait(); } }</code> </pre> <br>  Menariknya, <code>TaskScheduler</code> menyediakan metode <code>FromCurrentSynchronizationContext</code> statis.  Metode ini membuat <code>TaskScheduler</code> baru dan itu <code>TaskScheduler</code> tugas untuk dieksekusi dalam konteks <code>SynchronizationContext.Current</code> kembali menggunakan metode <code>Post</code> . <br><br><h3>  Bagaimana SynchronizationContext dan TaskScheduler terkait dengan menunggu? </h3><br>  Katakanlah Anda perlu menulis aplikasi UI dengan tombol.  Menekan tombol akan memulai pengunduhan teks dari situs web dan menetapkannya ke tombol <code>Content</code> .  Tombol harus dapat diakses hanya dari UI aliran di mana ia berada, oleh karena itu, ketika kami berhasil memuat tanggal dan waktu dan ingin menempatkannya di <code>Content</code> tombol, kami perlu melakukan ini dari aliran yang memiliki kendali atasnya.  Jika kondisi ini tidak terpenuhi, kami akan mendapatkan pengecualian: <br><br><pre> <code class="cs hljs">System.InvalidOperationException: <span class="hljs-string"><span class="hljs-string">'        ,     .'</span></span></code> </pre><br>  Kami dapat secara manual menggunakan <code>SynchronizationContext</code> untuk mengatur <code>Content</code> dalam konteks sumber, misalnya melalui <code>TaskScheduler</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { downloadBtn.Content = downloadTask.Result; }, TaskScheduler.FromCurrentSynchronizationContext()); }</code> </pre> <br>  Dan kita dapat menggunakan <code>SynchronizationContext</code> secara langsung: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { sc.Post(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { downloadBtn.Content = downloadTask.Result; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre> <br>  Namun, kedua opsi ini secara eksplisit menggunakan callback.  Sebagai gantinya, kita dapat menggunakan <code>async</code> / <code>await</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  Semua ini "hanya berfungsi" dan berhasil mengkonfigurasi <code>Content</code> di utas UI, karena dalam kasus versi yang diterapkan secara manual di atas, secara default, menunggu tugas mengacu pada <code>SynchronizationContext.Current</code> dan <code>TaskScheduler.Current</code> .  Ketika Anda "mengharapkan" sesuatu dalam C #, kompiler mengubah kode untuk polling (dengan memanggil <code>GetAwaiter</code> ) "diharapkan" (dalam hal ini, Tugas) menjadi "menunggu" ( <code>TaskAwaiter</code> ).  "Menunggu" bertanggung jawab untuk melampirkan panggilan balik (sering disebut "kelanjutan") yang memanggil kembali ke mesin negara ketika menunggu selesai.  Dia mengimplementasikan ini menggunakan konteks / penjadwal yang dia tangkap selama pendaftaran panggilan balik.  Kami akan mengoptimalkan dan mengonfigurasi sedikit, ini seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; }</code> </pre> <br>  Di sini, pertama kali diperiksa apakah <code>SynchronizationContext</code> , dan jika tidak, apakah <code>TaskScheduler</code> standar.  Jika ada, maka ketika callback siap untuk panggilan, scheduler yang ditangkap akan digunakan;  jika tidak, panggilan balik akan dieksekusi sebagai bagian dari operasi yang menyelesaikan tugas yang diharapkan. <br><br><h3>  Apa yang dilakukan ConfigureAwait (false) </h3><br>  Metode <code>ConfigureAwait</code> tidak spesial: tidak dikenali dengan cara tertentu oleh kompiler atau runtime.  Ini adalah metode normal yang mengembalikan struktur ( <code>ConfiguredTaskAwaitable</code> - membungkus tugas asli) dan mengambil nilai Boolean.  Ingat bahwa <code>await</code> dapat digunakan dengan jenis apa pun yang menerapkan pola yang benar.  Jika tipe lain dikembalikan, itu berarti ketika kompiler mendapatkan akses ke metode <code>GetAwaiter</code> (bagian dari pola) dari instance, tetapi apakah itu dari tipe yang dikembalikan dari <code>ConfigureAwait</code> , dan bukan dari tugas secara langsung.  Ini memungkinkan Anda untuk mengubah perilaku <code>await</code> untuk penunggu khusus ini. <br><br>  Menunggu tipe yang dikembalikan oleh <code>ConfigureAwait(continueOnCapturedContext: false)</code> alih-alih menunggu <code>Task</code> secara langsung memengaruhi implementasi penangkapan konteks / penjadwal yang dibahas di atas.  Logikanya menjadi seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continueOnCapturedContext) { scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; } }</code> </pre> <br>  Dengan kata lain, menentukan <code>false</code> , bahkan jika ada konteks saat ini atau penjadwal untuk panggilan balik, menyiratkan bahwa itu tidak ada. <br><br><h3>  Mengapa saya perlu menggunakan ConfigureAwait (false)? </h3><br>  <code>ConfigureAwait(continueOnCapturedContext: false)</code> digunakan untuk mencegah panggilan balik dipaksa memanggil dalam konteks sumber atau penjadwal.  Ini memberi kita beberapa keuntungan: <br><br>  <b>Peningkatan kinerja.</b>  Ada overhead antrian panggilan balik, tidak seperti hanya menelepon, karena ini membutuhkan pekerjaan tambahan (dan biasanya alokasi tambahan).  Selain itu, kami tidak dapat menggunakan optimasi saat runtime (kami dapat mengoptimalkan lebih banyak ketika kami tahu persis bagaimana panggilan balik akan dipanggil, tetapi jika itu diteruskan ke implementasi abstraksi yang sewenang-wenang, kadang-kadang ini memberlakukan batasan).  Untuk bagian yang sarat muatan, bahkan biaya tambahan untuk memeriksa <code>SynchronizationContext</code> saat ini dan <code>TaskScheduler</code> saat ini (keduanya menyiratkan akses ke aliran statis) dapat secara signifikan meningkatkan overhead.  Jika kode setelah <code>await</code> tidak memerlukan eksekusi dalam konteks asli, menggunakan <code>ConfigureAwait(false)</code> , semua biaya ini dapat dihindari, karena tidak perlu diantrekan secara tidak perlu, dapat menggunakan semua optimasi yang tersedia, dan juga dapat menghindari akses yang tidak perlu ke statika aliran. <br><br>  <b>Pencegahan kebuntuan.</b>  Pertimbangkan metode pustaka yang <code>await</code> digunakan untuk mengunduh sesuatu dari jaringan.  Anda memanggil metode ini dan secara sinkron memblokir, menunggu Tugas selesai, misalnya, menggunakan <code>.Wait()</code> atau <code>.Result</code> atau <code>.GetAwaiter()</code> <code>.GetResult()</code> .  Sekarang pertimbangkan apa yang terjadi jika panggilan terjadi ketika <code>SynchronizationContext</code> saat ini membatasi jumlah operasi di dalamnya untuk 1 secara eksplisit menggunakan <code>MaxConcurrencySynchronizationContext</code> , atau secara implisit, jika itu adalah konteks dengan utas tunggal untuk digunakan (misalnya, utas UI).  Dengan demikian, Anda memanggil metode dalam utas tunggal, dan kemudian memblokirnya, menunggu operasi selesai.  Pengunduhan dimulai melalui jaringan dan menunggu penyelesaiannya.  Secara default, menunggu <code>Task</code> menangkap <code>SynchronizationContext</code> saat ini (dan dalam hal ini), dan ketika unduhan dari jaringan selesai, itu akan diantrikan kembali ke callback <code>SynchronizationContext</code> , yang akan memanggil sisa operasi.  Tetapi satu-satunya utas yang dapat menangani panggilan balik dalam antrian saat ini diblokir sambil menunggu operasi selesai.  Dan operasi ini tidak akan selesai sampai callback diproses.  Kebuntuan!  Itu dapat terjadi bahkan ketika konteksnya tidak membatasi konkurensi ke 1, tetapi sumber daya terbatas dalam beberapa cara.  Bayangkan situasi yang sama, hanya dengan nilai 4 untuk <code>MaxConcurrencySynchronizationContext</code> .  Alih-alih mengeksekusi operasi sekali, kami mengantri 4 panggilan ke konteks.  Setiap panggilan dibuat dan terkunci untuk mengantisipasi penyelesaiannya.  Semua sumber daya sekarang diblokir menunggu penyelesaian metode asinkron, dan satu-satunya hal yang akan memungkinkan mereka untuk menyelesaikan adalah jika panggilan balik mereka diproses oleh konteks ini.  Namun, dia sudah sepenuhnya sibuk.  Jalan buntu lagi.  Jika metode pustaka menggunakan <code>ConfigureAwait(false)</code> sebagai gantinya, itu tidak akan mengantri panggilan balik ke konteks asli, yang akan menghindari skrip kebuntuan. <br><br><h3>  Apakah saya perlu menggunakan ConfigureAwait (true)? </h3><br>  Tidak, kecuali Anda perlu secara eksplisit menunjukkan bahwa Anda tidak menggunakan <code>ConfigureAwait(false)</code> (misalnya, untuk menyembunyikan peringatan analisis statis, dll.).  <code>ConfigureAwait(true)</code> tidak melakukan apa pun yang signifikan.  Jika Anda membandingkan <code>await task</code> dan <code>await task</code> <code>await task.ConfigureAwait(true)</code> , mereka akan identik secara fungsional.  Dengan demikian, jika <code>ConfigureAwait(true)</code> ada dalam kode, itu dapat dihapus tanpa konsekuensi negatif. <br><br>  Metode <code>ConfigureAwait</code> mengambil nilai boolean, karena dalam beberapa situasi mungkin perlu melewati variabel untuk mengontrol konfigurasi.  Namun dalam 99% kasus, nilai ditetapkan ke false, <code>ConfigureAwait(false)</code> . <br><br><h3>  Kapan menggunakan ConfigureAwait (false)? </h3><br>  Itu tergantung pada apakah Anda menerapkan kode tingkat aplikasi atau kode perpustakaan tujuan umum. <br><br>  Saat menulis aplikasi, beberapa perilaku default biasanya diperlukan.  Jika model / lingkungan aplikasi (misalnya, Windows Forms, WPF, ASP.NET Core) menerbitkan Konteks <code>SynchronizationContext</code> khusus, hampir pasti ada alasan bagus untuk ini: ini berarti bahwa kode memungkinkan Anda untuk menjaga konteks sinkronisasi untuk interaksi yang tepat dengan model / lingkungan aplikasi.  Misalnya, jika Anda menulis event handler di aplikasi Windows Forms, tes di xUnit, atau kode di pengontrol ASP.NET MVC, terlepas dari apakah model aplikasi telah menerbitkan <code>SynchronizationContext</code> , Anda perlu menggunakan <code>SynchronizationContext</code> jika ada.  Ini berarti jika <code>ConfigureAwait(true)</code> dan <code>await</code> , panggilan balik / lanjutan dikirim kembali ke konteks asli - semuanya berjalan sebagaimana mestinya.  Dari sini Anda dapat merumuskan aturan umum: <b>jika Anda menulis kode tingkat aplikasi, <i>jangan gunakan</i> <code>ConfigureAwait(false)</code></b> .  Mari kita kembali ke penangan klik: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  <code>downloadBtn.Content = text</code> harus dijalankan dalam konteks asli.  Jika kode melanggar aturan ini dan menggunakan <code>ConfigureAwait (false)</code> , maka itu tidak akan digunakan dalam konteks asli: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  downloadBtn.Content = text; }</span></span></code> </pre> <br>  ini akan mengarah pada perilaku yang tidak pantas.  Hal yang sama berlaku untuk kode dalam aplikasi ASP.NET klasik yang bergantung pada <code>HttpContext.Current</code> .  Saat menggunakan <code>ConfigureAwait(false)</code> upaya berikutnya untuk menggunakan fungsi <code>Context.Current</code> cenderung menyebabkan masalah. <br><br>  Inilah yang membedakan perpustakaan tujuan umum.  Mereka universal sebagian karena mereka tidak peduli dengan lingkungan di mana mereka digunakan.  Anda dapat menggunakannya dari aplikasi web, dari aplikasi klien atau dari tes - tidak masalah, karena kode pustaka adalah agnostik untuk model aplikasi yang dapat digunakan.  Agnostik juga berarti bahwa perpustakaan tidak akan melakukan apa pun untuk berinteraksi dengan model aplikasi, misalnya, itu tidak akan mendapatkan akses ke kontrol antarmuka pengguna, karena perpustakaan tujuan umum tidak tahu apa-apa tentang mereka.  Karena tidak perlu menjalankan kode di lingkungan tertentu, kami dapat menghindari memaksa kelanjutan / panggilan balik untuk dipaksa ke konteks asli, dan kami melakukan ini menggunakan <code>ConfigureAwait(false)</code> , yang memberi kami keuntungan kinerja dan meningkatkan keandalan.  Ini membawa kita pada yang berikut: <b>jika Anda menulis kode perpustakaan untuk keperluan umum, gunakan <code>ConfigureAwait(false)</code></b> .  Inilah sebabnya mengapa setiap (atau hampir setiap) menunggu di pustaka runtime .NET Core menggunakan ConfigureAwait (false);  Dengan beberapa pengecualian, yang kemungkinan besar adalah bug, mereka akan diperbaiki.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, </font></font><a href="https://github.com/dotnet/corefx/pull/38610" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PR ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memperbaiki panggilan yang tidak </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masuk </font></font><code>HttpClient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, ini tidak masuk akal di mana-mana. Misalnya, salah satu pengecualian besar (atau setidaknya kasus di mana Anda perlu memikirkannya) di perpustakaan tujuan umum adalah ketika perpustakaan ini memiliki API yang menerima delegasi untuk panggilan. Dalam kasus seperti itu, perpustakaan menerima kode tingkat aplikasi potensial dari pemanggil, yang membuat asumsi untuk perpustakaan tujuan umum sangat kontroversial. Bayangkan, misalnya, versi asinkron metode Where LINQ: </font></font><code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haruskah itu </font></font><code>predicate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipanggil dalam sumber </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode panggilan? Itu tergantung pada implementasi </font></font><code>WhereAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan inilah alasan mengapa ia mungkin memutuskan untuk tidak menggunakan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan dalam kasus khusus, ikuti rekomendasi umum: gunakan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika Anda menulis perpustakaan tujuan umum / aplikasi-model-kode agnostik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah ConfigureAwait (false) menjamin bahwa callback tidak akan dieksekusi dalam konteks asli? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak, ini memastikan bahwa itu tidak akan masuk ke konteks asli. </font><font style="vertical-align: inherit;">Tetapi ini tidak berarti bahwa kode setelahnya </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan dieksekusi dalam konteks aslinya. </font><font style="vertical-align: inherit;">Ini disebabkan oleh fakta bahwa operasi yang telah selesai dikembalikan secara serempak, dan tidak secara paksa dikembalikan ke antrian. </font><font style="vertical-align: inherit;">Karenanya, jika Anda mengharapkan tugas yang telah selesai pada saat Anda menunggu, terlepas dari apakah Anda menggunakannya </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kode segera setelah itu akan terus dieksekusi di utas saat ini dalam konteks yang masih valid.</font></font><br><br><h3>    ConfigureAwait (false)       ,    — ? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, tidak. Ingat FAQ sebelumnya. Jika itu </font></font><code>await task.ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">termasuk tugas yang telah selesai pada saat menunggu (yang sebenarnya cukup sering terjadi), maka penggunaan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menjadi tidak berarti, karena utas terus mengeksekusi kode berikut dalam metode dan masih dalam konteks yang sama seperti sebelumnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu pengecualian penting adalah bahwa yang pertama </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan selalu berakhir secara tidak sinkron, dan operasi yang diharapkan akan memanggilnya kembali di lingkungan yang bebas dari </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font><font style="vertical-align: inherit;">khusus </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Misalnya, </font></font><code>CryptoStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di pustaka runtime, .NET memverifikasi bahwa kode berpotensi intensif komputasi tidak dieksekusi sebagai bagian dari permintaan kode panggilan pemanggilan yang sinkron. Untuk melakukan ini, ia menggunakan khusus</font></font><code><a href="" rel="nofollow">awaiter</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memastikan bahwa kode setelah menunggu pertama dijalankan di utas thread pool. </font><font style="vertical-align: inherit;">Namun, bahkan dalam kasus ini, Anda akan melihat bahwa penantian selanjutnya masih menggunakan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">Secara teknis, ini tidak perlu, tetapi sangat menyederhanakan tinjauan kode, karena tidak perlu memahami mengapa itu tidak digunakan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah mungkin menggunakan Task.Run untuk menghindari penggunaan ConfigureAwait (false)? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ya, jika Anda menulis: </font></font><br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br>  <code>ConfigureAwait(false)</code>  <code>SomethingAsync()</code>  ,   ,   <code>Task.Run</code>      ,       , <code>SynchronizationContext.Current</code>   <code>null</code> .  , <code>Task.Run</code>   <code>TaskScheduler.Default</code> ,  <code>TaskScheduler.Current</code>      <code>Default</code> .  ,  <code>await</code>        ,    <code>ConfigureAwait(false)</code> .        ,       .     : <br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeCoolSyncCtx()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//    SomeCoolSyncCtx });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maka kode di dalamnya </font></font><code>SomethingAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan benar-benar melihat </font></font><code>SynchronizationContext.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instance </font></font><code>SomeCoolSyncCtx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. dan ini </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan setiap harapan yang tidak dikonfigurasi di dalam SomethingAsync akan dikembalikan ke konteks ini. Jadi, untuk menggunakan pendekatan ini, perlu dipahami apa yang dapat dilakukan atau tidak dilakukan oleh semua kode yang Anda masukkan dalam antrian, dan apakah tindakannya dapat menjadi penghalang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan ini juga terjadi karena kebutuhan untuk membuat / mengantri objek tugas tambahan. Ini mungkin atau mungkin tidak penting bagi aplikasi / perpustakaan, tergantung pada persyaratan kinerja.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga perlu diingat bahwa solusi semacam itu dapat menyebabkan lebih banyak masalah daripada manfaat dan memiliki konsekuensi yang tidak diinginkan yang berbeda. </font><font style="vertical-align: inherit;">Misalnya, beberapa alat analisis statis menandai harapan yang tidak menggunakan </font></font><code>ConfigureAwait(false)</code> <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CA2007</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda menghidupkan penganalisis, dan kemudian menggunakan trik semacam itu untuk menghindari penggunaan </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ada kemungkinan besar bahwa penganalisa akan menandainya. </font><font style="vertical-align: inherit;">Ini mungkin memerlukan lebih banyak pekerjaan, misalnya, Anda mungkin ingin menonaktifkan analyzer karena sifatnya yang penting, dan ini akan memerlukan melewatkan tempat-tempat lain dalam basis kode di mana Anda benar-benar perlu menggunakannya </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah mungkin menggunakan SynchronizationContext.SetSynchronizationContext untuk menghindari penggunaan ConfigureAwait (false)? </font></font></h3><br>  Tidak.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun itu mungkin. </font><font style="vertical-align: inherit;">Itu tergantung pada implementasi yang digunakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa pengembang melakukan ini:</font></font><br><br><pre> <code class="cs hljs">Task t; SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment"><span class="hljs-comment">// await'      } finally { SynchronizationContext.SetSynchronizationContext(old); } await t; //  -    </span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan harapan ini akan memaksa kode di dalam untuk </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melihat konteks saat ini sebagai </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Memang akan begitu. </font><font style="vertical-align: inherit;">Namun, opsi ini tidak akan memengaruhi yang </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dilihatnya </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Oleh karena itu, jika kode dieksekusi dalam spesial </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di dalamnya </font></font><code>CallCodeThatUsesAwaitAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan melihat dan mengantri untuk spesial itu </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti dalam </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FAQ, peringatan yang sama berlaku di sini: ada konsekuensi tertentu dari pendekatan ini, dan kode di dalam blok </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga dapat mengganggu upaya ini dengan menetapkan konteks yang berbeda (atau memanggil kode menggunakan penjadwal tugas yang tidak standar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan templat ini, Anda juga perlu berhati-hati dengan perubahan kecil:</font></font><br><br><pre> <code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { SynchronizationContext.SetSynchronizationContext(old); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat apa masalahnya? </font><font style="vertical-align: inherit;">Agak sulit untuk diperhatikan, tetapi itu mengesankan. </font><font style="vertical-align: inherit;">Tidak ada jaminan bahwa menunggu pada akhirnya akan menyebabkan panggilan balik / melanjutkan di utas asli. </font><font style="vertical-align: inherit;">Ini berarti bahwa pengembalian </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke sumber asli mungkin tidak terjadi di utas asli, yang dapat mengarah pada fakta bahwa item kerja berikutnya di utas ini akan melihat konteks yang salah. </font><font style="vertical-align: inherit;">Untuk mengatasi hal ini, model aplikasi yang ditulis dengan baik yang menetapkan konteks khusus biasanya menambahkan kode untuk meresetnya secara manual sebelum memanggil kode kustom tambahan. </font><font style="vertical-align: inherit;">Dan bahkan jika ini terjadi dalam satu utas, mungkin butuh beberapa waktu di mana konteksnya mungkin tidak dipulihkan dengan benar. </font><font style="vertical-align: inherit;">Dan jika itu bekerja di utas yang berbeda, ini dapat menyebabkan pemasangan konteks yang salah.</font></font> Dan sebagainya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cukup jauh dari ideal. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apakah saya perlu menggunakan ConfigureAwait (false) jika saya menggunakan GetAwaiter () .GetResult ()? </font></font></h3><br>  Tidak. <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya memengaruhi panggilan balik. </font><font style="vertical-align: inherit;">Secara khusus, templat </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengharuskan Anda </font></font><code>awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberikan properti </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, metode, </font></font><code>GetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(opsional dengan metode UnsafeOnCompleted). </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya mempengaruhi perilaku </font></font><code>{Unsafe}OnCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi jika Anda langsung menelepon </font></font><code>GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, terlepas dari apakah Anda melakukannya </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau tidak </font></font><code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada perbedaan dalam perilaku. </font><font style="vertical-align: inherit;">Karena itu, jika Anda melihat </font></font><code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menggantinya dengan </font></font><code>task.GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(selain itu, pikirkan apakah Anda benar-benar membutuhkan implementasi seperti itu).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tahu bahwa kode berjalan di lingkungan di mana tidak akan pernah ada SynchronizationContext khusus atau TaskScheduler khusus. </font><font style="vertical-align: inherit;">Bisakah saya tidak menggunakan ConfigureAwait (false)?</font></font></h3><br>  Mungkin<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu tergantung pada seberapa yakin Anda tentang "tidak pernah." </font><font style="vertical-align: inherit;">Seperti disebutkan dalam pertanyaan sebelumnya, hanya karena model aplikasi yang sedang Anda kerjakan tidak menentukan yang khusus </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tidak memanggil kode Anda dalam yang khusus </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak berarti bahwa kode dari pengguna atau pustaka lain tidak menggunakannya. </font><font style="vertical-align: inherit;">Jadi, Anda harus yakin akan hal ini, atau setidaknya mengakui risiko bahwa opsi semacam itu mungkin.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mendengar bahwa di .NET Core tidak perlu menerapkan ConfigureAwait (false). </font><font style="vertical-align: inherit;">Benarkah begitu?</font></font></h3><br>  Tidak seperti itu.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diperlukan saat bekerja di .NET Core untuk alasan yang sama seperti ketika bekerja di .NET Framework. Tidak ada yang berubah dalam hal ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu telah mengubah apakah lingkungan tertentu mempublikasikan lingkungan mereka </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Secara khusus, sementara ASP.NET klasik di .NET Framework memiliki sendiri </font></font><code><a href="" rel="nofollow">SynchronizationContext</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ASP.NET Core tidak. Ini berarti bahwa kode yang berjalan di aplikasi Core ASP.NET tidak akan melihat kode khusus secara default </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang mengurangi kebutuhan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk lingkungan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ini tidak berarti bahwa tidak akan pernah ada kebiasaan </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau</font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika ada kode pengguna (atau kode perpustakaan lain yang digunakan oleh aplikasi) menetapkan konteks pengguna dan memanggil kode Anda atau memanggil kode Anda dalam Tugas yang dijadwalkan dalam penjadwal tugas khusus, maka </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core ASP.NET akan melihat konteks atau penjadwal non-standar, yang mungkin mengharuskan penggunaan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tentu saja, dalam situasi di mana Anda menghindari kunci sinkron (yang perlu Anda lakukan dalam aplikasi web) dan jika Anda tidak menentang overhead kinerja kecil dalam beberapa kasus, Anda dapat melakukannya tanpa menggunakan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisakah saya menggunakan ConfigureAwait ketika "menunggu foreach selesai" pada IAsyncEnumerable? </font></font></h3><br>  Ya<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lihat </font></font><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel MSDN sebagai</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contoh </font><font style="vertical-align: inherit;">. </font></font><br><br> <code>Await foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini sesuai dengan pola dan dengan demikian dapat digunakan untuk daftar </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Itu juga dapat digunakan untuk membuat daftar elemen yang mewakili cakupan API yang benar. </font><font style="vertical-align: inherit;">NET runtime perpustakaan termasuk metode </font></font><a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ekspansi</font></font></a> <code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengembalikan tipe khusus, yang membungkus </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berkorespondensi ke template yang benar. </font><font style="vertical-align: inherit;">Ketika kompiler menghasilkan panggilan ke </font></font><code>MoveNextAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enumerator. </font><font style="vertical-align: inherit;">Panggilan-panggilan ini terkait dengan jenis struktur enumerator yang dikonfigurasi yang dikembalikan, yang pada gilirannya memenuhi harapan sebagaimana diperlukan.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisakah saya menggunakan ConfigureAwait dengan 'menunggu menggunakan' IAsyncDisposable? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, meski dengan sedikit kerumitan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti halnya </font></font><code>IAsyncEnumerable&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, perpustakaan .NET runtime menyediakan metode ekstensi </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>await using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan berfungsi dengan baik karena mengimplementasikan template yang sesuai (yaitu, ia menyediakan metode yang sesuai </font></font><code>DisposeAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya di sini adalah bahwa jenisnya </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang bukan </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, melainkan </font></font><code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang dikembalikan dari metode ekstensi </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk </font></font><code>IAsyncDisposable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menyiasatinya, tambahkan baris:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (c.ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jenis yang </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diinginkan lagi </font></font><code>MyAsyncDisposableClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Yang juga memiliki efek meningkatkan ruang lingkup untuk </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">jika perlu, Anda bisa membungkusnya dengan kawat gigi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menggunakan ConfigureAwait (false), tetapi AsyncLocal saya masih mengalir ke kode setelah menunggu. </font><font style="vertical-align: inherit;">Apakah ini bug?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak, ini cukup diharapkan. </font><font style="vertical-align: inherit;">Aliran data </font></font><code>AsyncLocal&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah bagian </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang terpisah dari </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kecuali jika Anda secara eksplisit menonaktifkan aliran </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan </font></font><code>ExecutionContext.SuppressFlow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ExecutionContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dan dengan demikian data </font></font><code>AsyncLocal &lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) akan selalu melalui </font></font><code>awaits</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, terlepas dari apakah itu digunakan untuk </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghindari pengambilan yang asli </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Rincian lebih lanjut dibahas dalam </font></font><a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bisakah alat bahasa membantu saya menghindari kebutuhan untuk secara eksplisit menggunakan ConfigureAwait (false) di perpustakaan saya? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengembang perpustakaan terkadang mengeluh tentang perlunya menggunakan </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan meminta alternatif yang kurang invasif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini mereka tidak, setidaknya mereka tidak dibangun ke dalam bahasa / kompiler / runtime. </font><font style="vertical-align: inherit;">Namun, ada banyak saran tentang bagaimana ini dapat diimplementasikan, misalnya: </font></font><a href="https://github.com/dotnet/csharplang/issues/645" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2542" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2649" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://github.com/dotnet/csharplang/issues/2746" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika topik yang Anda minati, jika Anda memiliki ide-ide baru dan menarik, penulis </font></font><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel asli</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengundang Anda untuk berdiskusi.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482354/">https://habr.com/ru/post/id482354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482340/index.html">Dari Junior'a ke Middle'a: Parser</a></li>
<li><a href="../id482344/index.html">Bersiaplah untuk pengenalan peringkat sosial di Rusia</a></li>
<li><a href="../id482346/index.html">ASP.NET MVC - bekerja dengan MySQL melalui ADO.NET</a></li>
<li><a href="../id482348/index.html">Topologi dan analisis komprehensif untuk pengembang game yang tidak curiga: mengompresi vektor 3D tunggal</a></li>
<li><a href="../id482352/index.html">Ketika saya hampir melemparkan 150k ke angin atau sejarah pemasangan ventilasi paksa di apartemen</a></li>
<li><a href="../id482356/index.html">Menggunakan Windows Server tanpa explorer dari sudut pandang pengguna Windows biasa</a></li>
<li><a href="../id482358/index.html">Bagaimana panik bekerja di Rust</a></li>
<li><a href="../id482360/index.html">Detektif Habra: mereka berteman dengan UFO</a></li>
<li><a href="../id482362/index.html">Nearly Anarchy: Sejarah Singkat Fidonet, Proyek yang Tidak Peduli Menang Melalui Internet</a></li>
<li><a href="../id482364/index.html">Hal-hal yang [Mungkin] Tidak Anda Ketahui tentang Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>