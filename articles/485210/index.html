<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ó üòç üôá Simple zombie shooter en Unity üë©üèΩ‚Äçü§ù‚Äçüë©üèª ü§¶ üë©üèæ‚Äçüè´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Pronto, las clases comenzar√°n en el primer grupo del curso Unity Games Developer . En previsi√≥n del comienzo del curso, se llev√≥ a cabo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Simple zombie shooter en Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/485210/">  <i>Hola a todos!</i>  <i>Pronto, las clases comenzar√°n en el primer grupo del curso <a href="https://otus.pw/sW0V/">Unity Games Developer</a> .</i>  <i>En previsi√≥n del comienzo del curso, se llev√≥ a cabo <a href="https://www.youtube.com/watch%3Fv%3D6OTvr4e9PRY">una lecci√≥n abierta</a> sobre la creaci√≥n de un zombie shooter en Unity.</i>  <i>El seminario <a href="https://otus.pw/xfXx/">web</a> fue organizado por <a href="https://otus.pw/xfXx/">Nikolai Zapolnov</a> , desarrollador s√©nior de juegos de Rovio Entertainment Corporation.</i>  <i>Tambi√©n escribi√≥ un art√≠culo detallado, que llamamos su atenci√≥n.</i> <br><br><img src="https://habrastorage.org/webt/z6/pk/iv/z6pkiv4cismrguzozecv51foouk.jpeg"><br><br>  En este art√≠culo, me gustar√≠a mostrar lo f√°cil que es crear juegos en Unity.  Si tiene conocimientos b√°sicos de programaci√≥n, puede comenzar a trabajar r√°pidamente con este motor y crear su primer juego. <br><br><hr><br>  <i>Descargo de responsabilidad # 1: Este art√≠culo es para principiantes.</i>  <i>Si te comiste un perro en Unity, entonces te puede parecer aburrido.</i> <br><br>  <i>Descargo de responsabilidad # 2: Para leer este art√≠culo, necesita al menos conocimientos b√°sicos de programaci√≥n.</i>  <i>Como m√≠nimo, las palabras "clase" y "m√©todo" no deber√≠an asustarlo.</i> <br><br>  <b>¬°Atenci√≥n, tr√°fico bajo el corte!</b> <br><a name="habracut"></a><br><h2>  Introducci√≥n a la unidad </h2><br>  <i>Si ya est√° familiarizado con el editor de Unity, puede omitir la introducci√≥n e ir directamente a la secci√≥n "Creaci√≥n de un mundo de juegos".</i> <br><br>  La unidad estructural b√°sica en Unity es la "escena".  Una escena suele ser un nivel del juego, aunque en algunos casos puede haber varios niveles a la vez en una escena o, por el contrario, un gran nivel puede dividirse en varias escenas cargadas din√°micamente.  Las escenas est√°n llenas de objetos del juego y, a su vez, est√°n llenas de componentes.  Son los componentes los que implementan diversas funciones del juego: dibujar objetos, animaci√≥n, f√≠sica, etc.  Este modelo le permite ensamblar la funcionalidad a partir de bloques simples, como un juguete del constructor de Lego. <br><br>  Puede escribir componentes usted mismo, utilizando el lenguaje de programaci√≥n C # para esto.  As√≠ es como se escribe la l√≥gica del juego.  A continuaci√≥n veremos c√≥mo se hace esto, pero por ahora echemos un vistazo al motor en s√≠. <br><br>  Cuando arranque el motor y cree un nuevo proyecto, ver√° una ventana frente a usted donde puede seleccionar cuatro elementos principales: <br><br><img src="https://habrastorage.org/webt/5m/0o/9j/5m0o9jxwps3qwz3pbmvlchxveau.png"><br><br>  En la esquina superior izquierda de la captura de pantalla se encuentra la ventana "Jerarqu√≠a".  Aqu√≠ podemos ver la jerarqu√≠a de los objetos del juego en la escena abierta actual.  Unity cre√≥ dos objetos del juego para nosotros: una c√°mara ("C√°mara principal") a trav√©s de la cual el jugador ver√° nuestro mundo del juego y una "Luz direccional" que iluminar√° nuestra escena.  Sin √©l, solo ver√≠amos un cuadrado negro. <br><br>  En el centro est√° la ventana de edici√≥n de escena ("Escena").  Aqu√≠ vemos nuestro nivel y podemos editarlo visualmente: mover y rotar objetos con el mouse y ver qu√© sucede.  Cerca puedes ver la pesta√±a "Juego", que actualmente est√° inactiva;  si cambias a √©l, puedes ver c√≥mo se ve el juego desde la c√°mara.  Y si comienzas el juego (usando el bot√≥n con el √≠cono de jugar en la barra de herramientas), Unity cambiar√° a esta pesta√±a, donde jugaremos el juego lanzado. <br><br>  En la parte superior derecha est√° la ventana "Inspector".  En esta ventana, Unity muestra los par√°metros del objeto seleccionado y podemos editarlos.  En particular, podemos ver que la c√°mara seleccionada tiene dos componentes: "Transformar", que establece la posici√≥n de la c√°mara en el mundo del juego, y, de hecho, "C√°mara", que implementa la funcionalidad de la c√°mara. <br><br>  Por cierto, el componente Transformar est√° en una forma u otra en todos los objetos del juego en Unity. <br><br>  Y finalmente, en la parte inferior est√° la pesta√±a "Proyecto", donde podemos ver todos los llamados activos que est√°n en nuestro proyecto.  Los activos son archivos de datos como texturas, sprites, modelos 3D, animaciones, sonidos y m√∫sica, archivos de configuraci√≥n.  Es decir, cualquier dato que podamos usar para crear niveles o la interfaz de usuario.  Unity comprende una gran cantidad de formatos est√°ndar (por ejemplo, png y jpg para im√°genes, o fbx para modelos 3D), por lo que no habr√° problemas para cargar datos en un proyecto.  Y si usted, como yo, no sabe c√≥mo dibujar, los activos se pueden descargar de la Unidad de activos de Unity, que contiene una gran colecci√≥n de todo tipo de recursos: tanto gratuitos como vendidos por dinero. <br><br>  A la derecha de la pesta√±a "Proyecto", la pesta√±a inactiva "Consola" est√° visible.  Unity escribe advertencias y mensajes de error en la consola, as√≠ que aseg√∫rese de revisar peri√≥dicamente.  Especialmente si algo no funciona, lo m√°s probable es que la consola indique la causa del problema.  Adem√°s, la consola puede mostrar mensajes del c√≥digo del juego, para la depuraci√≥n. <br><br><h2>  Crea un mundo de juego </h2><br>  Como soy programador y dibujo peor que la pata de pollo, para los gr√°ficos tom√© algunos activos gratuitos de la Unidad de activos de Unity.  Puede encontrar enlaces a ellos al final de este art√≠culo. <br><br>  De estos activos, reun√≠ un nivel simple con el que trabajaremos: <br><br><img src="https://habrastorage.org/webt/07/y-/cr/07y-crxk0zc6zywqh8vga90qg-s.jpeg"><br><br>  Sin magia, simplemente arrastr√© los objetos que me gustaron desde la ventana del Proyecto y con el mouse los arregl√© como me gusta: <br><br><img src="https://habrastorage.org/webt/ll/xb/ca/llxbca3cdunouswhcy2b4jgpgha.gif"><br><br>  Por cierto, Unity le permite agregar objetos est√°ndar a la escena con un solo clic, como un cubo, esfera o plano.  Para hacer esto, simplemente haga clic derecho en la ventana Jerarqu√≠a y seleccione, por ejemplo, 3D Object‚á®Plane.  Entonces, el asfalto en mi nivel simplemente se ensambla a partir de un conjunto de planos sobre el que "extraje" una textura de un conjunto de activos. <br><br>  Nota: si se pregunta por qu√© us√© muchos planos, y no uno con valores a gran escala, la respuesta es bastante simple: un plano con una escala grande tendr√° una textura muy ampliada, que se ver√° poco natural con respecto a otros objetos en la escena (esto se puede arreglar con los par√°metros material, pero estamos tratando de hacer todo lo m√°s simple posible, ¬øverdad?) <br><br><h2>  Zombis en busca de un camino </h2><br>  Entonces, tenemos un nivel de juego, pero todav√≠a no est√° sucediendo nada.  En nuestro juego, los zombis perseguir√°n al jugador y lo atacar√°n, y para ello deben poder moverse hacia el jugador y sortear obst√°culos. <br><br>  Para implementar esto, usaremos la herramienta "Malla de navegaci√≥n".  En funci√≥n de los datos de la escena, esta herramienta calcula las √°reas donde puede moverse y genera un conjunto de datos que se pueden utilizar para buscar la ruta √≥ptima desde cualquier punto del nivel a cualquier otro durante el juego.  Estos datos se almacenan en el activo y no se pueden cambiar en el futuro; este proceso se denomina "horneado".  Si necesita cambiar din√°micamente los obst√°culos, puede usar el componente NavMeshObstacle, pero esto no es necesario para nuestro juego. <br><br>  Un punto importante: para que Unity sepa qu√© objetos deben incluirse en el c√°lculo, en el Inspector para cada objeto (puede seleccionar todo a la vez en la ventana Jerarqu√≠a), haga clic en la flecha hacia abajo junto a la opci√≥n "Est√°tica" y marque "Est√°tica de navegaci√≥n": <br><br><img src="https://habrastorage.org/webt/d9/us/wk/d9uswkd5hafxmqqxlr3ujr0ed_u.jpeg"><br><br>  En general, los puntos restantes tambi√©n son √∫tiles y ayudan a Unity a optimizar la representaci√≥n de la escena.  No nos detendremos en ellos hoy, pero cuando termine de aprender los conceptos b√°sicos del motor, le recomiendo encarecidamente que tambi√©n se ocupe de otros par√°metros.  A veces, una sola marca de verificaci√≥n puede aumentar significativamente la velocidad de fotogramas. <br><br>  Ahora usaremos el elemento de men√∫ Ventana‚á®AI‚á®Navegaci√≥n y en la ventana que se abre, seleccione la pesta√±a ‚ÄúHornear‚Äù.  Aqu√≠, Unity nos ofrecer√° establecer par√°metros tales como la altura y el radio del personaje, el √°ngulo m√°ximo de inclinaci√≥n de la tierra sobre el que a√∫n puede caminar, la altura m√°xima de los escalones, etc.  Todav√≠a no cambiaremos nada y simplemente presione el bot√≥n "Hornear". <br><br><img src="https://habrastorage.org/webt/zs/my/uo/zsmyuoqaopw11zon8bua6arf9aa.gif"><br><br>  Unity har√° los c√°lculos necesarios y nos mostrar√° el resultado: <br><br><img src="https://habrastorage.org/webt/3q/lg/t6/3qlgt6ze2hkj5sv8npdlr6ohkk8.jpeg"><br><br>  Aqu√≠, el azul indica el √°rea donde puedes caminar.  Como puede ver, Unity dej√≥ un peque√±o lado alrededor de los obst√°culos: el ancho de este lado depende del radio del personaje.  Por lo tanto, si el centro del personaje est√° en la zona azul, entonces no "caer√°" los obst√°culos. <br><br>  Con una cuadr√≠cula de navegaci√≥n calculada, podemos usar el componente NavMeshAgent para buscar la ruta de movimiento y controlar el movimiento de los objetos del juego a nuestro nivel. <br><br>  Creemos un objeto de juego "Zombie", agreguemos un modelo 3D de zombies a partir de activos, y tambi√©n el componente NavMeshAgent: <br><br><img src="https://habrastorage.org/webt/ij/jy/cb/ijjycbpwk8kjyyhkhter8jrbu7g.gif"><br><br>  Si comienzas el juego ahora, no pasar√° nada.  Necesitamos decirle al componente NavMeshAgent a d√≥nde ir.  Para hacer esto, crearemos nuestro primer componente en C #. <br><br>  En la ventana del proyecto, seleccione el directorio ra√≠z (se llama "Activos") y en la lista de archivos, haga clic con el bot√≥n derecho para crear el directorio "Scripts".  Almacenaremos todos nuestros scripts para que el proyecto tenga orden.  Ahora, dentro de los "Scripts", creemos un script "Zombie" y a√±√°dalo al objeto del juego zombie: <br><br><img src="https://habrastorage.org/webt/dz/_d/a1/dz_da1d0ybbvslw1g3tvkq8vgau.gif"><br><br>  Al hacer doble clic en el script, se abrir√° en el editor.  Veamos qu√© ha creado Unity para nosotros. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Este es un componente est√°ndar en blanco.  Como podemos ver, Unity conect√≥ las bibliotecas System.Collections y System.Collections.Generic (ahora no son necesarias, pero a menudo son necesarias en el c√≥digo de juegos de Unity, por lo que est√°n incluidas en la plantilla est√°ndar), as√≠ como la biblioteca UnityEngine, que contiene todos API del motor central. <br><br>  Adem√°s, Unity cre√≥ la clase Zombie para nosotros (el nombre coincide con el nombre del archivo; esto es importante: si no coinciden, Unity no podr√° hacer coincidir el script con el componente en la escena).  La clase se hereda de MonoBehaviour: esta es la clase base para los componentes creados por el usuario. <br><br>  Dentro de la clase, Unity cre√≥ dos m√©todos para nosotros: Inicio y Actualizaci√≥n.  El motor llamar√° a estos m√©todos: Iniciar - inmediatamente despu√©s de que se haya cargado la escena, y Actualizar - cada cuadro.  De hecho, hay muchas de estas funciones llamadas por el motor, pero la mayor√≠a de ellas no las necesitaremos hoy.  La lista completa, as√≠ como la secuencia de su llamada, siempre se pueden encontrar en la documentaci√≥n: <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a> <br><br>  ¬°Hagamos que los zombies se muevan en el mapa! <br><br>  Primero, necesitamos conectar la biblioteca UnityEngine.AI.  Contiene la clase NavMeshAgent y otras clases relacionadas con la cuadr√≠cula de navegaci√≥n.  Para hacer esto, agregue la directiva using UnityEngine.AI al comienzo del archivo. <br><br>  Luego, necesitamos acceder al componente NavMeshAgent.  Para hacer esto, podemos usar el m√©todo GetComponent est√°ndar.  Le permite obtener un enlace a cualquier componente en el mismo objeto del juego en el que se encuentra el componente desde el que llamamos este m√©todo (en nuestro caso, es el objeto del juego "Zombie").  Crearemos el campo NavMeshAgent navMeshAgent en la clase, en el m√©todo Start obtendremos un enlace a NavMeshAgent y le pediremos que se mueva al punto (0, 0, 0).  Deber√≠amos obtener este script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); navMeshAgent.SetDestination(Vector3.zero); } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Al comenzar el juego, veremos c√≥mo el zombi se mueve al centro del mapa: <br><br><img src="https://habrastorage.org/webt/dx/uz/u1/dxuzu157nhtqaj85o0afxbm_s7k.gif"><br><br><h2>  Zombis persiguiendo a una v√≠ctima </h2><br>  Genial  Pero nuestros zombis est√°n aburridos y solitarios, agreguemos la <s>v√≠ctima de un</s> jugador al juego para √©l. <br><br>  Por analog√≠a con zombies, crearemos un objeto de juego "Player" (esta vez seleccionaremos un modelo 3D de un oficial de polic√≠a), tambi√©n agregaremos el componente NavMeshAgent y el script Player reci√©n creado.  Todav√≠a no tocaremos el contenido del script de Player, pero necesitaremos hacer cambios en el script de Zombie.  Adem√°s, recomiendo establecer el valor de propiedad Prioridad del jugador en 10 en el componente NavMeshAgent (o cualquier otro valor menor que el 50 est√°ndar, es decir, darle al jugador una prioridad m√°s alta).  En este caso, si el jugador y los zombis se encuentran en el mapa, los zombis no podr√°n mover al jugador, mientras que el jugador podr√° expulsar a los zombis. <br><br>  Para perseguir a un jugador, un zombie necesita saber su posici√≥n.  Y para esto necesitamos obtener un enlace en nuestra clase Zombie usando el m√©todo est√°ndar FindObjectOfType.  Recordando el enlace, podemos recurrir al componente de transformaci√≥n del jugador y pedirle el valor de la posici√≥n.  Y para que el zombie persiga al jugador siempre, y no solo al comienzo del juego, estableceremos un objetivo para NavMeshAgent en el m√©todo de actualizaci√≥n.  Obtiene el siguiente script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Player player; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); player = FindObjectOfType&lt;Player&gt;(); } // Update is called once per frame void Update() { navMeshAgent.SetDestination(player.transform.position); } }</span></span></code> </pre> <br>  Ejecuta el juego y aseg√∫rate de que el zombi haya encontrado a su v√≠ctima: <br><br><img src="https://habrastorage.org/webt/j3/lv/vc/j3lvvcaltksjiu44tzh-rijewi4.gif"><br><br><h2>  Escape Escape </h2><br>  Nuestro jugador est√° parado como un √≠dolo.  Claramente, esto no lo ayudar√° a sobrevivir en un mundo tan agresivo, por lo que debes ense√±arle a moverse por el mapa. <br><br>  Para hacer esto, necesitamos obtener informaci√≥n sobre las teclas presionadas desde Unity.  ¬°El m√©todo GetKey de la clase de entrada est√°ndar solo proporciona dicha informaci√≥n! <br><br>  Nota: en general, esta forma de obtener informaci√≥n no es totalmente can√≥nica.  Es mejor usar Input.GetAxis y enlazar a trav√©s de Project Settings‚á®Input Manager.  Mejor a√∫n, <a href="https://blogs.unity3d.com/ru/2019/10/14/introducing-the-new-input-system/">nuevo sistema de entrada</a> .  Pero este art√≠culo result√≥ ser demasiado largo y, por lo tanto, hag√°moslo de la manera m√°s simple. <br><br>  Abra el script del reproductor y c√°mbielo de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Player</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); } // Update is called once per frame void Update() { Vector3 dir = Vector3.zero; if (Input.GetKey(KeyCode.LeftArrow)) dir.z = -1.0f; if (Input.GetKey(KeyCode.RightArrow)) dir.z = 1.0f; if (Input.GetKey(KeyCode.UpArrow)) dir.x = -1.0f; if (Input.GetKey(KeyCode.DownArrow)) dir.x = 1.0f; navMeshAgent.velocity = dir.normalized * moveSpeed; } }</span></span></code> </pre> <br>  Como en el caso de los zombis, en el m√©todo de Inicio obtenemos un enlace al componente NavMeshAgent del jugador y lo almacenamos en el campo de clase.  Pero ahora tambi√©n agregamos el campo moveSpeed. <br>  ¬°Debido a que este campo es p√∫blico, su valor se puede editar directamente en el Inspector en Unity!  Si tienes un dise√±ador de juegos en tu equipo, estar√° muy contento de no necesitar ingresar el c√≥digo para editar los par√°metros del jugador. <br><br>  Establecer 10 como velocidad: <br><br><img src="https://habrastorage.org/webt/o9/ro/cx/o9rocx0w0v3djxjgdt35ca59aug.gif"><br><br>  En el m√©todo de actualizaci√≥n usaremos Input.GetKey para verificar si alguna de las flechas del teclado est√° presionada y formar un vector de direcci√≥n para el jugador.  Tenga en cuenta que usamos las coordenadas X y Z. Esto se debe al hecho de que en Unity el eje Y mira hacia el cielo y la tierra se encuentra en el plano XZ. <br><br>  Despu√©s de haber formado un vector de direcci√≥n para el directorio de direcci√≥n de movimiento, lo normalizamos (de lo contrario, si el jugador quiere moverse en diagonal, el vector ser√° un poco m√°s largo que uno solo y este movimiento ser√° m√°s r√°pido que moverse directamente) y se multiplicar√° por la velocidad de movimiento dada.  El resultado se pasa a navMeshAgent.velocity y el agente har√° el resto. <br><br>  Al iniciar el juego, finalmente podemos intentar escapar de los zombies a un lugar seguro: <br><br><img src="https://habrastorage.org/webt/mn/gv/7w/mngv7wimzjqsdlfja2ghro-ovn8.gif"><br><br>  Para hacer que la c√°mara se mueva con el jugador, escriba otro gui√≥n simple.  Llam√©moslo "PlayerCamera": <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Player player; Vector3 offset; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { player = FindObjectOfType&lt;Player&gt;(); offset = transform.position - player.transform.position; } // Update is called once per frame void LateUpdate() { transform.position = player.transform.position + offset; } }</span></span></code> </pre> <br>  El significado de este script debe entenderse en gran medida.  De las caracter√≠sticas: aqu√≠, en lugar de Actualizar, usamos LateUpdate.  Este m√©todo es similar a Update, pero siempre se llama estrictamente despu√©s de que Update se haya completado para todos los scripts en la escena.  En este caso, usamos LateUpdate, porque es importante para nosotros que NavMeshAgent calcule la nueva posici√≥n del reproductor antes de mover la c√°mara.  De lo contrario, puede producirse un desagradable efecto de "sacudidas". <br><br>  Si ahora adjuntas este componente al objeto del juego "C√°mara principal" y comienzas el juego, ¬°el personaje del jugador siempre estar√° en el centro de atenci√≥n! <br><br><h2>  Momento de animaci√≥n </h2><br>  Por un momento nos apartamos de los problemas de supervivencia en las condiciones de un apocalipsis zombie y pensamos en lo eterno, en el arte.  Nuestros personajes ahora parecen estatuas animadas, puestas en movimiento por una fuerza desconocida (posiblemente imanes debajo del asfalto).  Y me gustar√≠a que parecieran personas reales, vivas (y no muy): movieron sus brazos y piernas.  El componente Animator y una herramienta llamada Animator Controller nos ayudar√°n con esto. <br><br>  Animator Controller es una m√°quina de estados finitos (m√°quina de estados), donde establecemos ciertos estados (el personaje est√° de pie, el personaje est√° encendido, el personaje est√° muriendo, etc.), les adjuntamos animaciones y establecemos las reglas para la transici√≥n de un estado a otro.  Unity cambiar√° autom√°ticamente de una animaci√≥n a otra tan pronto como funcione la regla correspondiente. <br><br>  Creemos un controlador Animator para zombies.  Para hacer esto, cree el directorio de Animaciones en el proyecto (recuerde el orden en el proyecto), y en √©l, con el bot√≥n derecho, Animator Controller.  Y llam√©mosle "Zombi".  Haga doble clic y el editor aparecer√° ante nosotros: <br><br><img src="https://habrastorage.org/webt/t1/54/ak/t154aknnrk7f0lwdlcmvj69uxqo.png"><br><br>  No hay estados aqu√≠ hasta ahora, pero hay dos puntos de entrada ("Entrada" y "Cualquier estado") y un punto de salida ("Salida").  Arrastre un par de animaciones desde los activos: <br><br><img src="https://habrastorage.org/webt/xg/cx/gw/xgcxgwkbtqsbqux7cj9y5qnwnk0.gif"><br><br>  Como puede ver, tan pronto como arrastramos la primera animaci√≥n, Unity la vincula autom√°ticamente al punto de entrada de entrada.  Esta es la llamada animaci√≥n predeterminada.  Se jugar√° inmediatamente despu√©s del inicio del nivel. <br><br>  Para cambiar a un estado diferente (y reproducir otra animaci√≥n), necesitamos crear reglas de transici√≥n.  Y para esto, antes que nada, necesitaremos agregar un par√°metro que estableceremos desde el c√≥digo para administrar las animaciones. <br><br>  Hay dos botones en la esquina superior izquierda de la ventana del editor: "Capas" y "Par√°metros".  Por defecto, la pesta√±a "Capas" est√° seleccionada, pero necesitamos cambiar a "Par√°metros".  Ahora podemos agregar un nuevo par√°metro de tipo float usando el bot√≥n "+".  Llam√©moslo "velocidad": <br><br><img src="https://habrastorage.org/webt/po/is/nj/poisnjmj39qel2ofz_meiyginsw.gif"><br><br>  Ahora tenemos que decirle a Unity que la animaci√≥n "Z_run" debe reproducirse cuando la velocidad es mayor que 0 y "Z_idle_A" cuando la velocidad es cero.  Para hacer esto, debemos crear dos transiciones: una de ‚ÄúZ_idle_A‚Äù a ‚ÄúZ_run‚Äù, y la otra en la direcci√≥n opuesta. <br><br>  Comencemos con la transici√≥n de inactivo a ejecutar.  Haga clic derecho en el rect√°ngulo "Z_idle_A" y seleccione "Realizar transici√≥n".  Aparecer√° una flecha, haciendo clic en la cual puede configurar sus par√°metros.  Primero, debe desmarcar "Tiene tiempo de salida".  Si esto no se hace, la animaci√≥n cambiar√° no seg√∫n nuestra condici√≥n, sino cuando la anterior termine de reproducirse.  No necesitamos esto en absoluto, as√≠ que lo desmarcamos.  En segundo lugar, en la parte inferior, en la lista de condiciones ("Condiciones") debe hacer clic en "+" y Unity nos agregar√° una condici√≥n.  Los valores predeterminados en este caso son exactamente lo que necesitamos: el par√°metro "velocidad" debe ser mayor que cero para cambiar de inactivo a ejecutar. <br><br><img src="https://habrastorage.org/webt/vt/rw/qy/vtrwqy-jyfhgrai9ruymphu_mwi.gif"><br><br>  Por analog√≠a, creamos una transici√≥n en la direcci√≥n opuesta, pero como condici√≥n ahora especificamos "velocidad" menor que 0.0001.  No hay verificaciones de igualdad para los par√°metros de tipo flotante, solo se pueden comparar por m√°s / menos: <br><br><img src="https://habrastorage.org/webt/vz/ki/bu/vzkibunzaoxqfdfysekucvcqepa.png"><br><br>  Ahora debes vincular el controlador al objeto del juego.  Seleccionaremos el modelo 3D del zombie en la escena (este es un elemento secundario del objeto "Zombie") y arrastraremos el controlador con el mouse al campo correspondiente en el componente Animator: <br><br><img src="https://habrastorage.org/webt/lr/pv/pq/lrpvpqbl__neecouj3uyxdepqka.gif"><br><br>  ¬°Solo queda escribir un script que controle el par√°metro de velocidad! <br><br>  Cree el script de MotionAnimator con los siguientes contenidos: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementAnimator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Animator animator; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); } // Update is called once per frame void Update() { animator.SetFloat("speed", navMeshAgent.velocity.magnitude); } }</span></span></code> </pre> <br>  Aqu√≠, como en otras secuencias de comandos, en el m√©todo de Inicio tenemos acceso a NavMeshAgent.  Tambi√©n tenemos acceso al componente Animator, pero dado que adjuntaremos el componente "MovementAnimator" al objeto del juego "Zombie" y el Animator est√° en el objeto secundario, en lugar de GetComponent necesitamos usar el m√©todo GetComponentInChildren est√°ndar. <br><br>  En el m√©todo de actualizaci√≥n, le pedimos a NavMeshAgent su vector de velocidad, calcule su longitud y se lo pase al animador como par√°metro de velocidad.  ¬°Sin magia, todo en ciencia! <br><br>  Ahora agregue el componente MotionAnimator al objeto del juego Zombie y, si el juego comienza, vemos que los zombies ahora est√°n animados: <br><br><img src="https://habrastorage.org/webt/uz/da/yt/uzdaytgsxzstqj8rnzx11rfa8ti.gif"><br><br>  Tenga en cuenta que, dado que hemos colocado el c√≥digo de control del animador en un componente separado de MotionAnimation, se puede agregar f√°cilmente para el jugador.  Ni siquiera necesitamos crear un controlador desde cero: puede copiar un controlador zombie (esto se puede hacer seleccionando el archivo "Zombie" y presionando Ctrl + D) y reemplazar las animaciones en los rect√°ngulos de estado con "m_idle_" y "m_run".  Todo lo dem√°s es como un zombie.  Lo dejar√© para usted como ejercicio (bueno, o descargue el c√≥digo al final del art√≠culo). <br><br>  Una peque√±a adici√≥n que es √∫til hacer es agregar las siguientes l√≠neas a la clase Zombie: <br><br>  En el m√©todo de Inicio: <br><br><pre> <code class="cs hljs">navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  En el m√©todo de actualizaci√≥n: <br><br><pre> <code class="cs hljs">transform.rotation = Quaternion.LookRotation(navMeshAgent.velocity.normalized);</code> </pre> <br>  La primera l√≠nea le dice a NavMeshAgent que no debe controlar la rotaci√≥n del personaje, lo haremos nosotros mismos.  La segunda l√≠nea establece el giro del personaje en la misma direcci√≥n donde se dirige su movimiento.  NavMeshAgent por defecto interpola el √°ngulo de rotaci√≥n del personaje y esto no se ve muy bien (el zombi gira m√°s lentamente que cambia la direcci√≥n del movimiento).  Agregar estas l√≠neas elimina este efecto. <br><br>  NB Usamos el cuaterni√≥n para especificar la rotaci√≥n.  En los gr√°ficos tridimensionales, las principales formas de especificar la rotaci√≥n de un objeto son los √°ngulos de Euler, las matrices de rotaci√≥n y los cuaterniones.  Los dos primeros no siempre son convenientes de usar, y tambi√©n est√°n sujetos a un efecto tan desagradable como "Gimbal Lock".  Los cuaterniones se ven privados de este inconveniente y ahora se usan casi universalmente.  Unity proporciona herramientas convenientes para trabajar con cuaterniones (as√≠ como tambi√©n con matrices y √°ngulos de Euler), lo que le permite no entrar en detalles del dispositivo de este aparato matem√°tico. <br><br><h2>  Veo el gol </h2><br>  Genial, ahora podemos escapar de los zombies.  Pero esto no es suficiente, tarde o temprano aparecer√° un segundo zombie, luego un tercero, quinto, d√©cimo ... pero no puedes huir de la multitud.  Para sobrevivir, tienes que matar.  Adem√°s, el jugador ya tiene una pistola en la mano. <br><br>  Para que el jugador pueda disparar, debes darle la oportunidad de elegir un objetivo.  Para hacer esto, coloque el cursor controlado por el mouse en el suelo. <br><br>  En la pantalla, el cursor del mouse se mueve en un espacio bidimensional: la superficie del monitor.  Al mismo tiempo, nuestra escena del juego es tridimensional.  El observador ve la escena a trav√©s de su ojo, donde todos los rayos de luz convergen en un punto.  Combinando todos estos rayos, obtenemos una pir√°mide de visibilidad: <br><br><img src="https://habrastorage.org/webt/hl/bg/p5/hlbgp55snbpv2cxacycfmxbd_hw.png"><br><br>  El ojo del observador solo ve lo que cae dentro de esta pir√°mide.  Adem√°s, el motor trunca espec√≠ficamente esta pir√°mide desde dos lados: en primer lugar, desde el lado del observador hay una pantalla de monitor, el llamado "plano cercano" (en la figura est√° pintado en amarillo).  El monitor no puede mostrar f√≠sicamente objetos m√°s cerca que la pantalla, por lo que el motor los interrumpe.  En segundo lugar, dado que la computadora tiene una cantidad finita de recursos, el motor no puede extender los rayos hasta el infinito (por ejemplo, se debe establecer un cierto rango de valores posibles para el b√∫fer de profundidad; adem√°s, cuanto m√°s ancho es, menor es la precisi√≥n), por lo que la pir√°mide se corta detr√°s de la llamada "Plano lejano". <br><br>  Dado que el cursor del mouse se mueve a lo largo del plano cercano, podemos liberar el rayo desde el punto donde se encuentra profundamente en la escena.  El primer objeto con el que se cruza ser√° el objeto al que apunta el cursor del mouse desde el punto de vista del observador. <br><br><img src="https://habrastorage.org/webt/rd/xf/kn/rdxfkn9vevlzr8qz5qtronl05vi.png"><br><br>  Para construir dicho rayo y encontrar su intersecci√≥n con los objetos en la escena, puede usar el m√©todo est√°ndar Raycast de la clase F√≠sica.  Pero si usamos este m√©todo, encontrar√° la intersecci√≥n con todos los objetos en la escena: tierra, paredes, zombis ... Pero queremos que el cursor se mueva solo en el suelo, por lo que debemos explicarle a Unity de alguna manera que la b√∫squeda de intersecci√≥n debe ser limitada solamente un conjunto dado de objetos (en nuestro caso, solo los planos de la tierra). <br><br>  Si selecciona cualquier objeto del juego en la escena, en la parte superior del inspector puede ver la lista desplegable "Capa".  Por defecto habr√° un valor de "Predeterminado".  Al abrir la lista desplegable, puede encontrar el elemento "Agregar capa ...", que abrir√° la ventana del editor de capas.  En el editor necesita agregar una nueva capa (llam√©mosla "Ground"): <br><br><img src="https://habrastorage.org/webt/3w/5g/pc/3w5gpczarjjyhhtombqxbxq68wk.gif"><br><br>  Ahora puede seleccionar todos los planos de tierra en la escena y usar esta lista desplegable para asignarles la capa de tierra.  Esto nos permitir√° indicar en el script al m√©todo Physics.Raycast que es necesario verificar la intersecci√≥n del haz solo con estos objetos. <br><br>  Ahora arrastremos el cursor del cursor desde los activos a la escena (uso Spags Assets‚á®Textures‚á®Demo‚á®white_hip‚á®white_hip_14): <br><br><img src="https://habrastorage.org/webt/ha/mw/aa/hamwaarhcaodn7q-y-e5qkps5kc.gif"><br><br>  Agregu√© una rotaci√≥n de 90 grados alrededor del eje X al cursor para que quede horizontalmente en el suelo, establezca la escala en 0.25 para que no sea tan grande y establezca la coordenada Y en 0.01.  Esto √∫ltimo es importante para que no haya un efecto llamado "Z-fighting".  La tarjeta de video utiliza c√°lculos de coma flotante para determinar qu√© objetos est√°n m√°s cerca de la c√°mara.  Si establece el cursor en 0 (es decir, el mismo que el del plano de tierra), entonces, debido a errores en estos c√°lculos, para algunos p√≠xeles, la tarjeta de video decidir√° que el cursor est√° m√°s cerca, y para otros, que la tierra.  Adem√°s, en diferentes cuadros, los conjuntos de p√≠xeles ser√°n diferentes, lo que crear√° un efecto desagradable de brillar las piezas del cursor a trav√©s del suelo y "parpadear" cuando se mueve.  El valor de 0.01 es lo suficientemente grande como para compensar los errores en el c√°lculo de la tarjeta de video, pero no tan grande como para que el ojo note que el cursor est√° suspendido en el aire. <br><br>  Ahora cambie el nombre del objeto del juego a Cursor y cree un script con el mismo nombre y el siguiente contenido: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cursor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { SpriteRenderer spriteRenderer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> layerMask; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { spriteRenderer = GetComponent&lt;SpriteRenderer&gt;(); layerMask = LayerMask.GetMask("Ground"); } // Update is called once per frame void Update() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (!Physics.Raycast(ray, out hit, 1000, layerMask)) spriteRenderer.enabled = false; else { transform.position = new Vector3(hit.point.x, transform.position.y, hit.point.z); spriteRenderer.enabled = true; } } }</span></span></code> </pre> <br>  Como el cursor es un sprite (dibujo bidimensional), Unity usa el componente SpriteRenderer para representarlo.  Obtenemos un enlace a este componente en el m√©todo de Inicio para poder activarlo / desactivarlo seg√∫n sea necesario. <br><br>  Tambi√©n en el m√©todo de Inicio, convertimos el nombre de la capa "Ground" que creamos anteriormente en una m√°scara de bits.  Unity utiliza operaciones bit a bit para filtrar objetos cuando busca intersecciones, y el m√©todo LayerMask.GetMask devuelve la m√°scara de bits correspondiente a la capa especificada. <br><br>  En el m√©todo Actualizar, accedemos a la c√°mara principal de la escena usando Camera.main y le pedimos que recalcule las coordenadas bidimensionales del mouse (obtenidas usando Input.mousePosition) en un rayo tridimensional.  Luego, pasamos este rayo al m√©todo Physics.Raycast y verificamos si se cruza con alg√∫n objeto en la escena.  Un valor de 1000 es la distancia m√°xima.  En matem√°ticas, los rayos son infinitos, pero los recursos inform√°ticos y la memoria de una computadora no lo son.  Por lo tanto, Unity nos pide que determinemos una distancia m√°xima razonable. <br><br>  Si no hubo intersecci√≥n, apagamos el SpriteRenderer y la imagen del cursor desaparece de la pantalla.  Si se encontr√≥ la intersecci√≥n, entonces movemos el cursor al punto de intersecci√≥n.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que no cambiamos la coordenada Y, ya que el punto de intersecci√≥n del rayo con el suelo tendr√° Y igual a cero y al asignarlo a nuestro cursor nuevamente obtendremos el efecto de lucha Z, del cual tratamos de deshacernos arriba. </font><font style="vertical-align: inherit;">Por lo tanto, tomamos solo las coordenadas X y Z desde el punto de intersecci√≥n, e Y permanece igual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue el componente Cursor al objeto del juego Cursor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, finalicemos la secuencia de comandos del reproductor: primero, agregue el campo del cursor del cursor. </font><font style="vertical-align: inherit;">Luego, en el m√©todo de Inicio, agregue las siguientes l√≠neas:</font></font><br><br><pre> <code class="cs hljs">cursor = FindObjectOfType&lt;Cursor&gt;(); navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y finalmente, para que el jugador siempre gire hacia el cursor, en el m√©todo Actualizar, agregue: </font></font><br><br><pre> <code class="cs hljs">Vector3 forward = cursor.transform.position - transform.position; transform.rotation = Quaternion.LookRotation(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(forward.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, forward.z));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqu√≠ tampoco tenemos en cuenta la coordenada Y. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dispara para sobrevivir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El mero hecho de girar hacia el cursor no nos proteger√° de los zombis, sino que solo aliviar√° al personaje del jugador del efecto de la sorpresa: ahora no puede acercarse sigilosamente detr√°s de √©l. Para que realmente pueda sobrevivir en las duras realidades de nuestro juego, debes ense√±arle a disparar. ¬øY qu√© tipo de disparo es si no es visible? Todo el mundo sabe que cualquier tirador respetable siempre dispara balas trazadoras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cree un objeto de juego Shot y agregue el componente LineRenderer est√°ndar. Usando el campo "Ancho" en el editor, dele un ancho peque√±o, por ejemplo, 0.04. Como podemos ver, Unity lo pinta con un color p√∫rpura brillante, de esta manera se resaltan los objetos sin material.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los materiales son un elemento importante de cualquier motor tridimensional. El uso de materiales describe la apariencia del objeto. Todos los par√°metros de iluminaci√≥n, texturas, sombreadores: todo esto lo describe el material. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos el directorio de Materiales en el proyecto y dentro de √©l el material, llam√©moslo Amarillo. Como sombreador, seleccione Apagado / Color. Este sombreador est√°ndar no incluye iluminaci√≥n, por lo que nuestra bala ser√° visible incluso en la oscuridad. Seleccione el color amarillo: </font></font><br><br><img src="https://habrastorage.org/webt/en/pt/im/enptimmi5wn6-9f5ssbqzh2fxko.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora que el material est√° creado, puede asignarlo a LineRenderer: </font></font><br><br><img src="https://habrastorage.org/webt/ow/qr/31/owqr314ai0hyyfx-hswunci5lzs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crear una secuencia de comandos Shot:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Shot</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { LineRenderer lineRenderer; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> visible; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { lineRenderer = GetComponent&lt;LineRenderer&gt;(); } // Update is called once per frame void FixedUpdate() { if (visible) visible = false; else gameObject.SetActive(false); } public void Show(Vector3 from, Vector3 to) { lineRenderer.SetPositions(new Vector3[]{ from, to }); visible = true; gameObject.SetActive(true); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este script, como probablemente ya has adivinado, debe agregarse al objeto del juego Shot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ us√© un peque√±o truco para mostrar una toma en la pantalla para exactamente un cuadro con un m√≠nimo de c√≥digo. Primero, uso FixedUpdate en lugar de Update. El m√©todo FixedUpdate se llama a la frecuencia especificada (por defecto, 60 cuadros por segundo), incluso si la velocidad de cuadros real es inestable. En segundo lugar, configuro la variable visible, que configuro en verdadero cuando visualizo la toma en la pantalla. En el siguiente FixedUpdate, lo restablezco a falso, y solo en el siguiente cuadro apago el objeto del juego. Esencialmente, uso una variable booleana como contador de 1 a 0.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo gameObject.SetActive activa o desactiva todo el objeto del juego en el que se encuentra nuestro componente. Los objetos apagados del juego no se dibujan en la pantalla y sus componentes no llaman a los m√©todos Actualizar, FixedUpdate, etc. El uso de este m√©todo le permite hacer que el disparo sea invisible cuando el jugador no est√° disparando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n hay un m√©todo Show p√∫blico en el script, que usaremos en el script Player para mostrar realmente la vi√±eta cuando se dispara.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero primero debe poder obtener las coordenadas del ca√±√≥n de la pistola para que el disparo provenga del orificio correcto. </font><font style="vertical-align: inherit;">Para hacer esto, encuentre el objeto Bip001‚á®Bip001 Pelvis‚á®Bip001 Spine‚á®Bip001 R Clav√≠cula‚á®Bip001 R UpperArm‚á®Bip001 R Forearm‚á®Bip001 R Hand‚á®R_hand_container‚á®w_handgun en el modelo 3D del jugador y agregue el objeto secundario GunBarrel. </font><font style="vertical-align: inherit;">Col√≥quelo de manera que est√© justo al lado del ca√±√≥n de la pistola: </font></font><br><br><img src="https://habrastorage.org/webt/kc/qc/ix/kcqcixwjeh_nf2qxqa6c7iriekk.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora en el script del jugador, agregue los campos:</font></font><br><br><pre> <code class="cs hljs">Shot shot; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform gunBarrel;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue al m√©todo de inicio del script del reproductor: </font></font><br><br><pre> <code class="cs hljs">shot = FindObjectOfType&lt;Shot&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y en el m√©todo de actualizaci√≥n: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = gunBarrel.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = cursor.transform.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(target.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, target.z); shot.Show(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede adivinar, el campo p√∫blico gunBarrel agregado, como moveSpeed ‚Äã‚Äãanteriormente, estar√° disponible en el Inspector. Vamos a asignarle el objeto real del juego que creamos: </font></font><br><br><img src="https://habrastorage.org/webt/r2/3p/6g/r23p6g9wgzes9qh_fg8l41txjqs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si ahora comenzamos el juego, ¬°finalmente podremos disparar a los zombis! </font></font><br><br><img src="https://habrastorage.org/webt/gj/ek/sx/gjeksxqnsbieryc_qrv07cyqm44.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo est√° mal aqu√≠! Parece que los disparos no matan zombies, ¬°sino que simplemente vuelan a trav√©s de ellos! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, por supuesto, si miras nuestro c√≥digo de disparo, no rastreamos de ninguna manera si nuestro disparo golpe√≥ al enemigo o no. Simplemente dibuja una l√≠nea en el cursor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto es bastante f√°cil de arreglar. En el c√≥digo para procesar clics del mouse en la clase Player, despu√©s de la l√≠nea var to = ... y antes de la l√≠nea shot.Show (...), agregue las siguientes l√≠neas:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> direction = (to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>).normalized; RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit, <span class="hljs-number"><span class="hljs-number">100</span></span>)) to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(hit.point.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, hit.point.z); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> + direction * <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ usamos el conocido Physics.Raycast para dejar salir el rayo del ca√±√≥n de una pistola y determinar si se cruza con alg√∫n objeto del juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠, sin embargo, hay una advertencia: la bala todav√≠a volar√° a trav√©s de los zombies. El hecho es que el autor del activo agreg√≥ un colisionador a los objetos del nivel (edificios, cajas, etc.). Y el autor del activo con los personajes no lo hizo. Arreglemos este molesto malentendido.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un colisionador es un componente con el cual el motor de f√≠sica determina las colisiones entre objetos. </font><font style="vertical-align: inherit;">Por lo general, se usan formas geom√©tricas simples como colisionadores: cubos, esferas, etc. </font><font style="vertical-align: inherit;">Aunque este enfoque proporciona colisiones menos precisas, las f√≥rmulas de intersecci√≥n entre tales objetos son bastante simples y no requieren grandes recursos computacionales. </font><font style="vertical-align: inherit;">Por supuesto, si necesita la m√°xima precisi√≥n, siempre puede sacrificar el rendimiento y usar MeshCollider. </font><font style="vertical-align: inherit;">Pero no necesitamos una alta precisi√≥n, por lo que utilizaremos el componente CapsuleCollider: </font></font><br><br><img src="https://habrastorage.org/webt/wp/t3/qo/wpt3qo9lebty_w7hlawpe11le9u.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora la bala no volar√° a trav√©s de los zombies. </font><font style="vertical-align: inherit;">Sin embargo, los zombis siguen siendo inmortales.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies - Zombie Death! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero agreguemos una animaci√≥n de muerte al controlador de animaci√≥n zombie. </font><font style="vertical-align: inherit;">Para hacer esto, arrastre la animaci√≥n AssetPacks‚á®ToonyTinyPeople‚á®TT_demo‚á®animation‚á®zombie‚á®Z_death_A. </font><font style="vertical-align: inherit;">Para activarlo, cree un nuevo par√°metro muerto con el tipo de disparador. </font><font style="vertical-align: inherit;">A diferencia de otros par√°metros (bool, float, etc.), los disparadores no recuerdan su estado y se parecen m√°s a una llamada de funci√≥n: activaron un disparador: la transici√≥n funcion√≥ y el disparador se restableci√≥. </font><font style="vertical-align: inherit;">Y dado que un zombie puede morir en cualquier estado, y si se detiene, y si se est√° ejecutando, agregaremos la transici√≥n desde el estado Cualquier estado: </font></font><br><br><img src="https://habrastorage.org/webt/-a/je/6j/-aje6jc9oteg-glqdrtckbjhv1o.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregue los siguientes campos al script Zombie:</font></font><br><br><pre> <code class="cs hljs">CapsuleCollider capsuleCollider; Animator animator; MovementAnimator movementAnimator; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dead;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En el m√©todo de Inicio de la clase Zombie, inserte: </font></font><br><br><pre> <code class="cs hljs">capsuleCollider = GetComponent&lt;CapsuleCollider&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); movementAnimator = GetComponent&lt;MovementAnimator&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al comienzo del m√©todo de actualizaci√≥n, debe agregar una verificaci√≥n: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dead) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y finalmente, agregue el m√©todo p√∫blico Kill a la clase Zombie: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dead) { dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Destroy(capsuleCollider); Destroy(movementAnimator); Destroy(navMeshAgent); animator.SetTrigger(<span class="hljs-string"><span class="hljs-string">"died"</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La asignaci√≥n de nuevos campos, creo, es bastante obvia. En cuanto al m√©todo Kill, en √©l (si no estamos muertos) establecemos la bandera de muerte zombie y eliminamos los componentes CapsuleCollider, MovementAnimator y NavMeshAgent de nuestro objeto de juego, despu√©s de lo cual activamos la reproducci√≥n de la animaci√≥n de muerte desde el controlador de animaci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© eliminar componentes? De modo que tan pronto como muere un zombi, deja de moverse por el mapa y ya no es un obst√°culo para las balas. Para bien, a√∫n necesitas deshacerte del cuerpo de alguna manera hermosa despu√©s de que se haya reproducido la animaci√≥n de la muerte. De lo contrario, los zombis muertos seguir√°n consumiendo recursos y, cuando haya demasiados cad√°veres, el juego se ralentizar√° notablemente. La forma m√°s f√°cil es agregar la llamada Destroy (gameObject, 3) aqu√≠. Esto har√° que Unity elimine este objeto del juego 3 segundos despu√©s de esta llamada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que todo esto finalmente funcionara, el √∫ltimo toque permaneci√≥. En la clase Player, en el m√©todo Update, donde llamamos Physics.Raycast, en la rama para el caso en que se encontr√≥ una intersecci√≥n, agregamos un cheque:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit.transform != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zombie = hit.transform.GetComponent&lt;Zombie&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zombie != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) zombie.Kill(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physics.Raycast llama a la informaci√≥n de intersecci√≥n en la variable de hit. En particular, en el campo de transformaci√≥n habr√° un enlace al componente Transformar del objeto del juego con el que se cruz√≥ el rayo. Si este objeto del juego tiene un componente Zombie, entonces es un zombie y lo matamos. Elemental! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bueno, para que la muerte del enemigo se vea espectacular, agregamos un sistema de part√≠culas simple a los zombis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los sistemas de part√≠culas le permiten controlar una gran cantidad de objetos peque√±os (generalmente sprites) de acuerdo con alg√∫n tipo de ley f√≠sica o f√≥rmula matem√°tica. </font><font style="vertical-align: inherit;">Por ejemplo, puede hacer que se separen o que vuelen hacia abajo a cierta velocidad. </font><font style="vertical-align: inherit;">Con la ayuda de los sistemas de part√≠culas en los juegos, se realizan todo tipo de efectos: fuego, humo, chispas, lluvia, nieve, suciedad debajo de las ruedas, etc. </font><font style="vertical-align: inherit;">Utilizaremos un sistema de part√≠culas para que, en el momento de la muerte, la sangre salpique de un zombi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un sistema de part√≠culas al objeto del juego Zombie (haga clic derecho sobre √©l y seleccione Efectos‚á®Sistema de part√≠culas): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sugiero las siguientes opciones: </font></font><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformar:</font></font></u> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posici√≥n: Y 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rotaci√≥n: X -90 </font></font></li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de part√≠culas</font></font></u> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Duraci√≥n: 0.2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bucle: falso </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicio de la vida: 0.8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tama√±o de inicio: 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color de inicio: verde </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modificador de gravedad: 1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jugar en despierto: falso </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emisi√≥n: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tasa a lo largo del tiempo: 100 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forma: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Radio: 0.25 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deber√≠a verse as√≠: </font></font><br><br><img src="https://habrastorage.org/webt/nk/rz/mj/nkrzmjt9wu6gyqt6twhgfkldivo.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queda por activarlo en el m√©todo Kill de la clase Zombie:</font></font><br><br><pre> <code class="cs hljs">GetComponentInChildren&lt;ParticleSystem&gt;().Play();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬°Y ahora un asunto completamente diferente! </font></font><br><br><img src="https://habrastorage.org/webt/av/sl/mf/avslmfkniyguq6m4hxma0j4sqek.gif"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ataque de zombis en reba√±o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, luchar contra un solo zombie es aburrido. </font><font style="vertical-align: inherit;">Lo mataste y eso es todo. </font><font style="vertical-align: inherit;">¬øD√≥nde est√° el drama? </font><font style="vertical-align: inherit;">¬øD√≥nde est√° el miedo a morir joven? </font><font style="vertical-align: inherit;">Para crear una verdadera atm√≥sfera de apocalipsis y desesperanza, debe haber muchos zombis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afortunadamente, esto es bastante simple. </font><font style="vertical-align: inherit;">Como habr√°s adivinado, necesitamos otro script. </font><font style="vertical-align: inherit;">Ll√°malo EnemySpawner y ll√©nalo con los siguientes contenidos:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawner</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Period; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject Enemy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TimeUntilNextSpawn; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { TimeUntilNextSpawn = Random.Range(0, Period); } // Update is called once per frame void Update() { TimeUntilNextSpawn -= Time.deltaTime; if (TimeUntilNextSpawn &lt;= 0.0f) { TimeUntilNextSpawn = Period; Instantiate(Enemy, transform.position, transform.rotation); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando el campo p√∫blico Periodo, el dise√±ador del juego puede establecer en el Inspector con qu√© frecuencia se debe crear un nuevo enemigo. En el campo Enemigo, indicamos qu√© enemigo crear (hasta ahora solo tenemos un enemigo, pero en el futuro podemos agregar m√°s). Bueno, entonces todo es simple: usando TimeUntilNextSpawn contamos cu√°nto tiempo queda hasta la pr√≥xima aparici√≥n del enemigo y, tan pronto como llegue el momento, agregamos un nuevo zombie a la escena usando el m√©todo est√°ndar de instanciaci√≥n. Ah, s√≠, en el m√©todo de Inicio, asignamos un valor aleatorio al campo TimeUntilNextSpawn, de modo que si tenemos varios reproductores con el mismo retraso en el nivel, no agregar√°n zombis al mismo tiempo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queda una pregunta: ¬øc√≥mo preguntarle al enemigo en el campo Enemigo? Para hacer esto, utilizaremos una herramienta de Unity como "Prefabs". De hecho, un prefabricado es una parte de la escena guardada en un archivo separado. Luego, podemos insertar este archivo en otras escenas (o en la misma) y no es necesario volver a recopilarlo en partes cada vez. Por ejemplo, recolectamos, de los objetos de paredes, piso, techo, ventanas y puertas, una hermosa casa y la guardamos como una casa prefabricada. Ahora puede insertar esta casa en otras tarjetas con un simple movimiento de mu√±eca. Al mismo tiempo, si edita el archivo prefabricado (por ejemplo, agrega una puerta trasera a la casa), el objeto cambiar√° en todas las escenas. A veces es muy conveniente. Tambi√©n podemos usar prefabricados como plantillas para Instantiate, y aprovecharemos esta oportunidad ahora mismo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear un prefabricado, simplemente arrastre el objeto del juego desde la ventana de jerarqu√≠a a la ventana del proyecto, Unity har√° el resto. Creemos una casa prefabricada de zombies y luego agreguemos un generador de enemigos a la escena: </font></font><br><br><img src="https://habrastorage.org/webt/4i/ka/kx/4ikakx3ollmpndbgcqco8341e8y.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregu√© tres reproductores m√°s en el proyecto para un cambio (as√≠ que, al final, tengo 4 de ellos). Y entonces, qu√© pas√≥: </font></font><br><br><img src="https://habrastorage.org/webt/6h/0p/_f/6h0p_fo52j6zqydyml6z9aqlcu0.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Aqu√≠! ¬°Ya parece un apocalipsis zombie!</font></font></b> <br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, esto est√° lejos de ser un juego completo. </font><font style="vertical-align: inherit;">No consideramos muchos problemas, como la creaci√≥n de una interfaz de usuario, sonidos, vidas y muerte de un jugador; todo esto queda fuera del alcance de este art√≠culo. </font><font style="vertical-align: inherit;">Pero me parece que este art√≠culo ser√° una introducci√≥n digna a Unity para aquellos que no est√°n familiarizados con esta herramienta. </font><font style="vertical-align: inherit;">¬øO tal vez alguien experimentado podr√° sacar alg√∫n truco de eso? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, amigos, espero que hayan disfrutado mi art√≠culo. </font><font style="vertical-align: inherit;">Escribe tus preguntas en los comentarios, intentar√© responderte. </font><font style="vertical-align: inherit;">El c√≥digo fuente del proyecto se puede descargar en el github: </font></font><a href="https://github.com/zapolnov/otus_zombies"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/zapolnov/otus_zombies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Necesitar√° Unity 2019.3.0f3 o superior, se puede descargar de forma totalmente gratuita y sin SMS desde el sitio web oficial: </font></font><a href="https://store.unity.com/download"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://store.unity.com/download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enlaces a los activos utilizados en el art√≠culo: </font></font><br><br><ul><li> <a href="https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679">https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679</a> </li><li> <a href="https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188">https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188</a> </li><li> <a href="https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902">https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902</a> </li></ul></div></div><p>Source: <a href="https://habr.com/ru/post/485210/">https://habr.com/ru/post/485210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485200/index.html">Desordenar al principio: autopsia sobre la velocidad de lanzamiento de una aplicaci√≥n iOS</a></li>
<li><a href="../485202/index.html">Sistema de supresi√≥n</a></li>
<li><a href="../485204/index.html">Volver al principio: por qu√© la capitalizaci√≥n de Amazon pronto volver√° a superar los $ 1 bill√≥n</a></li>
<li><a href="../485206/index.html">¬øC√≥mo me decepcion√≥ Typecript y vale la pena?</a></li>
<li><a href="../485208/index.html">Creaci√≥n de infraestructura de TI tolerante a fallas. Parte 2. Instalaci√≥n y configuraci√≥n del cl√∫ster oVirt 4.3</a></li>
<li><a href="../485214/index.html">CLRium # 7: Pr√°ctico. Seminario, tarea con verificaci√≥n, tutor√≠a</a></li>
<li><a href="../485218/index.html">Reserva de constantes y ganchos Git en C #</a></li>
<li><a href="../485220/index.html">La evoluci√≥n del cortafuegos de aplicaciones web: de cortafuegos a sistemas de seguridad basados ‚Äã‚Äãen la nube de aprendizaje autom√°tico</a></li>
<li><a href="../485222/index.html">¬øC√≥mo trabajar con l√≠deres de opini√≥n en China? Cinco consejos pr√°cticos</a></li>
<li><a href="../485224/index.html">¬øC√≥mo es la entrega de bienes dentro del l√≠mite aduanero del 1 de enero de 2020?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>