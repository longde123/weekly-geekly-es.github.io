<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👪 👩🏾‍🤝‍👩🏼 🐤 Aplikasi Asli Windows dan Acronis Active Restore 🚳 🤱🏿 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami melanjutkan kisah tentang bagaimana kami, bersama dengan orang-orang dari Universitas Innopolis, sedang mengembangkan teknologi Active R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi Asli Windows dan Acronis Active Restore</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/481382/">  Hari ini kami melanjutkan kisah tentang bagaimana kami, bersama dengan orang-orang dari Universitas Innopolis, sedang mengembangkan teknologi Active Restore untuk memungkinkan pengguna untuk mulai bekerja pada mesin mereka sesegera mungkin setelah kegagalan.  Kami akan berbicara tentang aplikasi Windows asli, termasuk fitur pembuatan dan peluncurannya.  Di bawah potongan - sedikit tentang proyek kami, serta panduan praktis tentang cara menulis aplikasi asli. <br><br><img src="https://habrastorage.org/webt/rc/bv/yl/rcbvylee_0ylshzywkrdlip0c9o.jpeg"><br><a name="habracut"></a><br>  Dalam posting sebelumnya, kita sudah berbicara tentang apa itu <a href="https://habr.com/ru/company/acronis/blog/477658/">Active Restore</a> dan bagaimana siswa dari Innopolis mengembangkan <a href="https://habr.com/ru/company/acronis/blog/479524/">layanan</a> .  Hari ini saya ingin fokus pada aplikasi asli, ke tingkat yang kami ingin "mengubur" layanan pemulihan aktif kami.  Jika semuanya berhasil, maka kita dapat: <br><br><ul><li>  Jauh lebih awal untuk memulai layanan itu sendiri </li><li>  Jauh lebih awal untuk menghubungi cloud tempat cadangan berada </li><li>  Jauh lebih awal untuk memahami mode apa yang ada di sistem - boot normal atau pemulihan </li><li>  Untuk memulihkan lebih sedikit file di muka </li><li>  Izinkan pengguna memulai lebih cepat. </li></ul><br><h3>  Apa yang dimaksud dengan aplikasi asli secara umum? </h3><br>  Untuk menjawab pertanyaan ini, mari kita lihat urutan panggilan yang dibuat oleh sistem, misalnya, jika seorang programmer dalam aplikasinya mencoba membuat file. <br><br><img src="https://habrastorage.org/webt/gb/d_/a7/gbd_a7c7l1d-6dlo4zh-fygf5dm.jpeg"><br>  <i>Pavel Yosifovich - Pemrograman Kernel Windows (2019)</i> <br><br>  Programmer menggunakan fungsi <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">CreateFile</a> , yang dideklarasikan dalam file header fileapi.h dan diimplementasikan dalam Kernel32.dll.  Namun, fungsi ini sendiri tidak membuat file, hanya memeriksa argumen pada input dan memanggil fungsi <a href="https://docs.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile">NtCreateFile</a> (awalan Nt hanya menunjukkan bahwa fungsi tersebut asli).  Fungsi ini dideklarasikan dalam file header winternl.h dan diimplementasikan dalam ntdll.dll.  Dia bersiap untuk melompat ke ruang nuklir, setelah itu dia membuat panggilan sistem untuk membuat file.  Dalam kasus ini, ternyata Kernel32 hanyalah pembungkus untuk Ntdll.  Salah satu alasan mengapa hal ini dilakukan, Microsoft dengan demikian memiliki kemampuan untuk mengubah fungsi dunia asli, tetapi tidak menyentuh antarmuka standar.  Microsoft tidak merekomendasikan langsung menjalankan fungsi asli dan tidak mendokumentasikan sebagian besar dari mereka.  Omong-omong, fitur tidak berdokumen dapat ditemukan di <a href="http://undocumented.ntinternals.net/">sini</a> . <br><br>  Keuntungan utama dari aplikasi asli adalah bahwa ntdll memuat ke dalam sistem lebih awal dari kernel32.  Ini logis, karena kernel32 membutuhkan ntdll untuk berfungsi.  Akibatnya, aplikasi yang menggunakan fungsi asli dapat mulai bekerja lebih awal. <br><br>  Dengan demikian, Aplikasi Asli Windows adalah program yang dapat berjalan pada tahap awal dalam mem-boot Windows.  Mereka menggunakan fungsi HANYA dari ntdll.  Contoh aplikasi semacam itu: <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/autochk">autochk</a> yang menjalankan <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/chkdsk">utilitas chkdisk</a> untuk memeriksa kesalahan pada disk sebelum memulai layanan utama.  Pada level ini kami ingin melihat Pemulihan Aktif kami. <br><br><h3>  Apa yang kita butuhkan </h3><br><ul><li> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit), sekarang juga dikenal sebagai WDK 7 (Windows Driver Kit). </li><li>  Mesin virtual (mis. Windows 7 x64) </li><li>  Tidak harus, tetapi file header bisa diunduh di <a href="https://github.com/arizvisa/ndk">sini.</a> </li></ul><br><h3>  Apa yang ada dalam kode? </h3><br>  Mari kita berlatih sedikit dan sebagai contoh kita akan menulis aplikasi kecil yang: <br><br><ol><li>  Menampilkan pesan di layar. </li><li>  Mengalokasikan sedikit memori </li><li>  Menunggu input keyboard </li><li>  Membebaskan memori yang sibuk </li></ol><br>  Dalam aplikasi asli, titik masuknya bukan main atau winmain, tetapi fungsi NtProcessStartup, karena kita sebenarnya langsung memulai proses baru dalam sistem. <br><br>  Mari kita mulai dengan menampilkan pesan di layar.  Untuk melakukan ini, kami memiliki fungsi asli <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FError%252FNtDisplayString.html">NtDisplayString</a> , yang mengambil sebagai argumen penunjuk ke objek struktur UNICODE_STRING.  RtlInitUnicodeString akan membantu kami menginisialisasi itu.  Akibatnya, untuk menampilkan teks di layar, kita dapat menulis fungsi sekecil itu: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//usage: WriteLn(L"Here is my text\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); }</span></span></code> </pre> <br>  Karena hanya fungsi-fungsi dari ntdll yang tersedia untuk kita, dan tidak ada perpustakaan lain di memori, kita pasti akan memiliki masalah dengan bagaimana mengalokasikan memori.  Operator baru belum ada (karena berasal dari dunia C ++ tingkat tinggi), juga tidak ada fungsi malloc (perlu pustaka runtime C).  Tentu saja Anda hanya dapat menggunakan tumpukan.  Tetapi jika kita perlu mengalokasikan memori secara dinamis, kita harus melakukan ini di heap (mis. Heap).  Karena itu, mari kita buat banyak untuk diri kita sendiri dan kita akan mengambil memori darinya ketika kita membutuhkannya. <br><br>  Fungsi <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtlcreateheap">RtlCreateHeap</a> cocok untuk tugas ini.  Selanjutnya, menggunakan RtlAllocateHeap dan RtlFreeHeap, kami akan mengisi dan membebaskan memori saat kami membutuhkannya. <br><br><pre> <code class="cpp hljs">PVOID memory = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PVOID buffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ULONG bufferSize = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory);</span></span></code> </pre> <br>  Ayo beralih untuk menunggu input keyboard. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //... HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } }</span></span></code> </pre> <br>  Yang perlu kita lakukan adalah menggunakan <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FFile%252FNtReadFile.html">NtReadFile</a> pada perangkat yang terbuka, dan tunggu sampai keyboard mengembalikan klik kepada kita.  Jika tombol ESC ditekan, kami akan terus bekerja.  Untuk membuka perangkat, kita perlu memanggil fungsi NtCreateFile (Anda harus membuka \ Device \ KeyboardClass0).  Kami juga akan memanggil <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FEvent%252FNtCreateEvent.html">NtCreateEvent</a> untuk menginisialisasi objek untuk menunggu.  Kami akan mendeklarasikan secara independen struktur KEYBOARD_INPUT_DATA yang mewakili data keyboard.  Ini akan memudahkan pekerjaan kita. <br><br>  Aplikasi asli diakhiri dengan panggilan ke fungsi <a href="https://undocumented.ntinternals.net/index.html%3Fpage%3DUserMode%252FUndocumented%2520Functions%252FNT%2520Objects%252FProcess%252FNtTerminateProcess.html">NtTerminateProcess</a> , karena kita baru saja mematikan proses kita sendiri. <br><br>  Semua kode aplikasi kecil kami: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntifs.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// \WinDDK\7600.16385.1\inc\ddk #include "ntdef.h" //------------------------------------ // Following function definitions can be found in native development kit // but I am too lazy to include `em so I declare it here //------------------------------------ NTSYSAPI NTSTATUS NTAPI NtTerminateProcess( IN HANDLE ProcessHandle OPTIONAL, IN NTSTATUS ExitStatus ); NTSYSAPI NTSTATUS NTAPI NtDisplayString( IN PUNICODE_STRING String ); NTSTATUS NtWaitForSingleObject( IN HANDLE Handle, IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout ); NTSYSAPI NTSTATUS NTAPI NtCreateEvent( OUT PHANDLE EventHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL, IN EVENT_TYPE EventType, IN BOOLEAN InitialState ); // https://docs.microsoft.com/en-us/windows/win32/api/ntddkbd/ns-ntddkbd-keyboard_input_data typedef struct _KEYBOARD_INPUT_DATA { USHORT UnitId; USHORT MakeCode; USHORT Flags; USHORT Reserved; ULONG ExtraInformation; } KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA; //---------------------------------------------------------- // Our code goes here //---------------------------------------------------------- // usage: WriteLn(L"Hello Native World!\n"); void WriteLn(LPWSTR Message) { UNICODE_STRING string; RtlInitUnicodeString(&amp;string, Message); NtDisplayString(&amp;string); } void NtProcessStartup(void* StartupArgument) { // it is important to declare all variables at the beginning HANDLE hKeyBoard, hEvent; UNICODE_STRING skull, keyboard; OBJECT_ATTRIBUTES ObjectAttributes; IO_STATUS_BLOCK Iosb; LARGE_INTEGER ByteOffset; KEYBOARD_INPUT_DATA kbData; PVOID memory = NULL; PVOID buffer = NULL; ULONG bufferSize = 42; //use it if debugger connected to break //DbgBreakPoint(); WriteLn(L"Hello Native World!\n"); // inialize variables RtlInitUnicodeString(&amp;keyboard, L"\\Device\\KeyboardClass0"); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;keyboard, OBJ_CASE_INSENSITIVE, NULL, NULL); // open keyboard device NtCreateFile(&amp;hKeyBoard, SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;Iosb, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,FILE_DIRECTORY_FILE, NULL, 0); // create event to wait on InitializeObjectAttributes(&amp;ObjectAttributes, NULL, 0, NULL, NULL); NtCreateEvent(&amp;hEvent, EVENT_ALL_ACCESS, &amp;ObjectAttributes, 1, 0); WriteLn(L"Keyboard ready\n"); // create heap in order to allocate memory later memory = RtlCreateHeap( HEAP_GROWABLE, NULL, 1000, 0, NULL, NULL ); WriteLn(L"Heap ready\n"); // allocate buffer of size bufferSize buffer = RtlAllocateHeap( memory, HEAP_ZERO_MEMORY, bufferSize ); WriteLn(L"Buffer allocated\n"); // free buffer (actually not needed because we destroy heap in next step) RtlFreeHeap(memory, 0, buffer); RtlDestroyHeap(memory); WriteLn(L"Heap destroyed\n"); WriteLn(L"Press ESC to continue...\n"); while (TRUE) { NtReadFile(hKeyBoard, hEvent, NULL, NULL, &amp;Iosb, &amp;kbData, sizeof(KEYBOARD_INPUT_DATA), &amp;ByteOffset, NULL); NtWaitForSingleObject(hEvent, TRUE, NULL); if (kbData.MakeCode == 0x01) // if ESC pressed { break; } } NtTerminateProcess(NtCurrentProcess(), 0); }</span></span></span></span></code> </pre> <br>  <b>PS:</b> Kita dapat dengan mudah menggunakan fungsi DbgBreakPoint () dalam kode untuk berhenti di debugger.  Benar, Anda harus menghubungkan WinDbg ke mesin virtual untuk debugging kernel.  Petunjuk tentang cara melakukan ini dapat ditemukan di <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/setting-up-kernel-mode-debugging-in-windbg--cdb--or-ntsd">sini</a> atau cukup gunakan <a href="http://sysprogs.com/legacy/virtualkd/">VirtualKD</a> . <br><br><h3>  Kompilasi dan perakitan </h3><br>  Cara termudah untuk membangun aplikasi asli adalah dengan menggunakan <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/other-wdk-downloads">DDK</a> (Driver Development Kit).  Kami membutuhkan versi ketujuh yang lama, karena versi selanjutnya memiliki pendekatan yang sedikit berbeda dan bekerja sama dengan Visual Studio.  Jika kita menggunakan DDK, maka proyek kita hanya membutuhkan Makefile dan sumber. <br><br>  <i>Makefile</i> <br><pre> <code class="bash hljs">!INCLUDE $(NTMAKEENV)\makefile.def</code> </pre> <br>  <i>sumber:</i> <br><pre> <code class="bash hljs">TARGETNAME = MyNative TARGETTYPE = PROGRAM UMTYPE = nt BUFFER_OVERFLOW_CHECKS = 0 MINWIN_SDK_LIB_PATH = $(SDK_LIB_PATH) SOURCES = source.c INCLUDES = $(DDK_INC_PATH); \ C:\WinDDK\7600.16385.1\ndk; TARGETLIBS = $(DDK_LIB_PATH)\ntdll.lib \ $(DDK_LIB_PATH)\nt.lib USE_NTDLL = 1</code> </pre> <br>  Makefile Anda akan persis sama, tetapi marilah kita memikirkan sumbernya lebih terinci.  File ini berisi sumber program Anda (file .c), opsi pembuatan dan parameter lainnya. <br><br><ul><li>  TARGETNAME - nama file yang dapat dieksekusi, yang seharusnya hasilnya. </li><li>  TARGETTYPE - jenis file yang dapat dieksekusi, dapat berupa driver (.sys), maka nilai field harus DRIVER, jika perpustakaan (.lib), maka nilainya adalah PERPUSTAKAAN.  Dalam kasus kami, kami memerlukan file yang dapat dieksekusi (.exe), jadi kami menetapkan nilainya ke PROGRAM. </li><li>  UMTYPE - nilai yang mungkin untuk bidang ini: konsol untuk aplikasi konsol, jendela untuk beroperasi dalam mode berjendela.  Tetapi kita perlu menentukan nt untuk mendapatkan aplikasi asli. </li><li>  BUFFER_OVERFLOW_CHECKS - memeriksa stack untuk buffer overflow, sayangnya bukan pada kasus kami, matikan. </li><li>  MINWIN_SDK_LIB_PATH - nilai ini merujuk ke variabel SDK_LIB_PATH, jangan khawatir bahwa Anda belum mendeklarasikan variabel sistem seperti itu, saat kami menjalankan bangunan yang diperiksa dari DDK, variabel ini akan dideklarasikan dan akan mengarah ke perpustakaan yang diperlukan. </li><li>  SUMBER - daftar sumber program Anda. </li><li>  TERMASUK - file header yang diperlukan untuk perakitan.  Mereka biasanya menunjukkan path ke file yang datang dengan DDK, tetapi Anda dapat secara opsional menentukan yang lain. </li><li>  TARGETLIBS - daftar perpustakaan yang perlu ditautkan. </li><li>  USE_NTDLL adalah bidang wajib yang harus disetel ke posisi 1. Untuk alasan yang jelas. </li><li>  USER_C_FLAGS - bendera apa pun yang dapat Anda gunakan dalam arahan preprosesor saat menyiapkan kode aplikasi. </li></ul><br>  Jadi untuk membangun, kita perlu menjalankan x86 (atau x64) Checked Build, ubah direktori kerja ke folder proyek dan jalankan perintah Build.  Hasil dalam tangkapan layar menunjukkan bahwa kami telah mengumpulkan satu file yang dapat dieksekusi. <br><br><img src="https://habrastorage.org/webt/9a/aj/hp/9aajhpa858ohtthlkjnenl1nnic.jpeg" alt="Membangun"><br><br>  File ini tidak dapat dijalankan dengan mudah, sistem bersumpah dan mengirim kami untuk memikirkan perilakunya dengan kesalahan berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/ev/zu/zwevzuxrc6zc8fvgye_msqa0k6y.jpeg" alt="Kesalahan"></div><br><br><h3>  Bagaimana cara menjalankan aplikasi asli? </h3><br>  Pada awal autochk, urutan startup program ditentukan oleh nilai kunci registri: <br><br><pre> <code class="bash hljs">HKLM\System\CurrentControlSet\Control\Session Manager\BootExecute</code> </pre> <br>  Manajer sesi menjalankan program dari daftar ini satu per satu.  Manajer sesi itu sendiri mencari file yang dapat dieksekusi di direktori system32.  Format nilai kunci registri adalah sebagai berikut: <br><br><pre> <code class="bash hljs">autocheck autochk *MyNative</code> </pre> <br>  Nilai harus dalam format heksadesimal, dan tidak dalam ASCII biasa, oleh karena itu, kunci yang disajikan di atas akan memiliki format: <br><br><pre> <code class="bash hljs">61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Untuk mengonversi nama, Anda dapat menggunakan layanan online, misalnya, yang <a href="https://www.rapidtables.com/convert/number/ascii-to-hex.html">ini</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ii/ky/sn/iikysns0tim-qpz91mbazv4uepa.jpeg"></div><br>  Ternyata untuk menjalankan aplikasi asli, kita perlu: <br><br><ol><li>  Salin file yang dapat dieksekusi ke folder system32 </li><li>  Tambahkan kunci ke registri </li><li>  Mesin boot ulang </li></ol><br>  Untuk kenyamanan, berikut ini skrip yang sudah jadi untuk menginstal aplikasi asli: <br><br>  <i>install.bat</i> <br><br><pre> <code class="bash hljs">@<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> off copy MyNative.exe %systemroot%\system32\. regedit /s add.reg <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Native Example Installed pause</code> </pre> <br>  <i>add.reg</i> <br><br><pre> <code class="bash hljs">REGEDIT4 [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager] <span class="hljs-string"><span class="hljs-string">"BootExecute"</span></span>=hex(7):61,75,74,6f,63,68,65,63,6b,20,61,75,74,6f,63,68,6b,20,2a,00,4d,79,4e,61,74,69,76,65,00,00</code> </pre> <br>  Setelah instalasi dan reboot, bahkan sebelum layar pemilihan pengguna muncul, kita mendapatkan gambar berikut: <br><br><img src="https://habrastorage.org/webt/yi/5p/7_/yi5p7_4vygq1wttxg_edlw-keqi.jpeg" alt="hasil"><br><br><h3>  Ringkasan </h3><br>  Menggunakan contoh aplikasi sekecil itu, kami yakin sangat mungkin menjalankan aplikasi pada level Windows Native.  Lebih jauh, orang-orang dari Universitas Innopolis akan terus membangun layanan yang akan memulai proses berinteraksi dengan pengemudi lebih awal daripada dalam versi sebelumnya dari proyek kami.  Dan dengan munculnya shell win32, akan masuk akal untuk mentransfer kontrol ke layanan lengkap yang telah dikembangkan (lebih lanjut tentang ini di <a href="https://habr.com/ru/company/acronis/blog/479524/">sini</a> ). <br><br>  Pada artikel selanjutnya, kita akan menyentuh komponen lain dari layanan Active Restore, yaitu driver UEFI.  Berlangganan ke blog kami untuk tidak ketinggalan posting berikutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481382/">https://habr.com/ru/post/id481382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481370/index.html">Greta Tunberg benar? Kereta Pesawat VS</a></li>
<li><a href="../id481372/index.html">Pohon Biner yang Dapat Diindeks</a></li>
<li><a href="../id481374/index.html">Habr Weekly # 32 / Rambler mengembalikan, memanipulasi di tempat kerja, cara melindungi proyek hewan peliharaan, gadget mengambil foto narsis dengan diam-diam</a></li>
<li><a href="../id481376/index.html">Analisis pelajaran yang diajarkan kepada masyarakat oleh situasi NGINX</a></li>
<li><a href="../id481378/index.html">Cara mengoptimalkan pengembangan aplikasi</a></li>
<li><a href="../id481386/index.html">Dithering: Sinyal bising untuk memperbaikinya</a></li>
<li><a href="../id481388/index.html">Bagaimana pertukaran cryptocurrency membangun blockchains mereka melawan DeFi</a></li>
<li><a href="../id481390/index.html">Berita dari dunia OpenStreetMap No. 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../id481392/index.html">Saat saya menulis cryptocurrency terpusat di PHP. (Bagian 1 - Ringkasan dasar + Mulai cepat)</a></li>
<li><a href="../id481394/index.html">Menciptakan dalam permainan baru apa yang kita sukai untuk yang lama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>