<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”· ğŸ¦Œ ğŸ’‡ğŸ¾ C ++ Russia Piter 2019 melaporkan ulasan ğŸ™‡ğŸ¿ ğŸ“Œ ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam program bersama ITMO dan JetBrains Master , kami meminta siswa yang dikirim ke konferensi untuk menulis laporan dengan tinjauan laporan. 
 Kami ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ Russia Piter 2019 melaporkan ulasan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/480798/">  Dalam program bersama ITMO dan JetBrains <a href="http://mse.itmo.ru/">Master</a> , kami meminta siswa yang dikirim ke konferensi untuk menulis laporan dengan tinjauan laporan. <br>  Kami menerbitkan salah satu dari laporan ini tentang konferensi C ++ Russia Piter 2019. Penulis adalah mahasiswa tahun ke-2 Artyom Khoroshev. <br><br><img src="https://habrastorage.org/webt/dg/fx/2y/dgfx2yszxbfsmhrhbwtlmlwbnay.png"><br><a name="habracut"></a><br>  Pada awal November, saya menghadiri konferensi cpp-russia-piter, di bawah ini saya akan berbicara tentang laporan yang saya ingat. <br><br><h2>  Roman Rusyaev: Pengecualian C ++ melalui prisma optimisasi kompiler </h2><br>  Sebuah laporan menarik di mana pembicara pada contoh LLVM berbicara tentang pengecualian nol biaya dalam C ++ modern. <br><br>  LLVM IR menyajikan program sebagai grafik aliran kontrol.  Di dalam simpul grafik terdapat blok instruksi yang harus diikuti.  Di akhir setiap blok, ada terminator yang mentransfer kontrol ke blok berikutnya.  Terminator dapat berupa transisi bersyarat ke blok lain, instruksi pengembalian, atau instruksi pemanggilan khusus, yang memiliki semantik memanggil fungsi, dan jika berhasil, mentransfer aliran kontrol ke satu blok, dan dalam kasus pengecualian, menunjukkan blok yang Anda inginkan untuk memprosesnya.  Instruksi dalam sebuah blok memiliki properti bahwa jika kami menekan blok, kami akan menjalankan semua instruksi, atau kami tidak akan jatuh ke dalam blok ini sama sekali.  Ada optimisasi yang hanya dapat bekerja dalam satu blok.  Dalam kasus blok kecil, mereka akan memiliki konteks yang lebih kecil, akibatnya lebih buruk untuk melakukan optimasi. <br>  Pembicara berbicara tentang bagaimana kompiler modern dapat mengonversi pernyataan aktif ke pernyataan panggilan, yang tidak lagi terminal, dan, sebagai hasilnya, memberi kompiler lebih banyak ruang untuk optimisasi.  Tetapi, agar tidak bergantung pada kompiler, Anda dapat menulis sendiri fungsi noexcept (jika ini benar) untuk memastikan bahwa kompiler akan melakukan semua optimasi. <br><br>  <a href="https://assets.ctfassets.net/oxjq45e8ilak/6Q09SPvX2Rsveiayc1VkcC/ce9e2b8eb22d6693eb4c3b06968bedc0/100693_477384438_Roman_Rusyayev_Isklyucheniya_C_cherez_prizmu_kompilyatornykh_optimizatsiy.pdf">(slide laporan)</a> <br><br><h2>  Maxim Khizhinsky: Perumahan kelas kenyamanan untuk aktor dan penangan </h2><br>  Pembicara menetapkan tujuan untuk menyingkirkan sejumlah masalah yang terkait dengan pemrograman paralel: <br><br><ul><li>  data bersama </li><li>  pergantian konteks, </li><li>  sinkronisasi </li><li>  Penciptaan aliran dengan cepat untuk kebutuhan jangka pendek. </li></ul><br>  Akibatnya, pembicara menyarankan untuk memecah programnya menjadi komponen, yang masa pakainya akan sama dengan masa pakai program, dan memasukkan komponen ke dalam "apartemen", yang jumlahnya harus sama dengan jumlah utas.  Komponen itu sendiri, sebagai akibatnya, adalah single-threaded, dan komunikasi antara komponen harus terjadi melalui pesan yang lewat.  Saya setuju bahwa ini menyelesaikan masalah, tetapi dengan mengorbankan semua penyesuaian program kami, kami harus melakukannya pada saat kompilasi.  Minimal, perlu pada saat kompilasi untuk mendistribusikan komponen secara merata di antara "apartemen", yang selanjutnya mencegah sistem dari penyeimbangan kembali tergantung pada beban.  Akibatnya, menurut saya, solusinya sendiri tidak terlihat cukup fleksibel. <br><br>  <a href="https://assets.ctfassets.net/oxjq45e8ilak/4ZUD3DvQyHCk2bNNtnRt6w/d9b72f3459b9c1c744a4387e90f56a64/100645_18452947_Maksim_Khizhinskiy_Zhilye_komfort-klassa_dlya_aktorov_i_khendlerov.pdf">(slide laporan)</a> <br><br><h2>  Nikolay Beloborodov: Penggunaan slab-dialokasikan pada aplikasi jaringan yang sangat dimuat </h2><br>  Nama itu berbicara sendiri.  Pembicara memberi tahu bagaimana mereka secara signifikan meningkatkan kinerja sistem menggunakan <a href="https://en.wikipedia.org/wiki/Slab_allocation">pengalokasi slab</a> .  Pengalokasi slab beroperasi pada beberapa entitas: <br><br><ul><li>  slab adalah bagian memori yang berdekatan (biasanya berukuran tetap) yang dibagi menjadi beberapa bagian dengan ukuran yang sama.  Area ini digunakan untuk menyimpan objek dengan ukuran yang sama, </li><li>  cache - daftar slab dengan split yang sama, </li><li>  pengalokasi slab - satu set cache. </li></ul><br>  Berkat konstruksi ini, objek dengan ukuran yang sama disimpan secara lokal.  Deallokasi dirancang sebagai tanda bahwa situs tertentu lemah dan dapat digunakan kembali.  Ini menghindari fragmentasi memori. <br><br>  Dari definisi slab pengalokasi ini, menjadi jelas bahwa itu sangat cocok untuk menyoroti pelepasan objek yang ukurannya terletak pada interval terbatas.  Misalnya, mengalokasikan ukuran yang lebih besar dan lebih besar setiap kali, cache baru akan dibuat, cache lama tidak akan digunakan kembali. <br><br>  Pembicara mengatakan bahwa karena ini mereka harus meninggalkan beberapa wadah, demi yang lain.  Sebagai contoh, vektor diganti dengan daftar, peta hash dengan pohon, tetapi bagaimanapun, keuntungan dalam kinerja masih diperoleh. <br><br>  <a href="https://assets.ctfassets.net/oxjq45e8ilak/2fI4wLgo2MmwDRsj0Gjod7/5ed8bde194c04345f5c78c80550b48c4/100690_1341752961_Nikolay_Beloborodov_Primeneniye_slab-allokatorov_v_vysokonagruzhennykh_setevykh_prilozheniyakh.pdf">(slide laporan)</a> <br><br><h2>  Anton Polukhin: Trik Taksi C ++ </h2><br>  Laporan dari Anton Polukhin selalu menarik, dan solusi yang dia tawarkan terlihat bagus.  Kali ini, Anton menunjukkan bagaimana pola jerawat dapat diperbaiki dalam hal alokasi dinamis.  Untuk melakukan ini, Anda perlu menempatkan repositori untuk objek implementasi di objek itu sendiri.  Biarkan saya mengingatkan Anda bahwa pola jerawat klasik adalah sebagai berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Foo.h struct Foo { Foo(); private: struct Foo_impl; //forward declaration std::unique_ptr&lt;Foo_impl&gt; impl; }; // Foo.cpp //implementation struct Foo::Foo_impl { };</span></span></code> </pre> <br>  Kami ingin menyingkirkan alokasi dinamis, untuk ini kami akan menyiapkan tempat terlebih dahulu langsung di objek Foo: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Foo.h struct Foo { Foo(); private: struct Foo_impl; //forward declaration std::aligned_storage_t&lt;sizeof(Foo_impl), alignof(Foo_impl)&gt; impl; }; // Foo.cpp //implementation struct Foo::Foo_impl { }</span></span></code> </pre><br>  Metode ini tidak akan berfungsi, karena kami tidak memiliki informasi lengkap tentang tipe Foo_impl di Foo.h dan kesalahan kompilasi akan diterima.  Satu-satunya solusi yang tersisa adalah menebak ukuran penyimpanan terlebih dahulu. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Foo.h struct Foo { Foo(); private: struct Foo_impl; //forward declaration constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; impl; }; // Foo.cpp //implementation struct Foo::Foo_impl { }</span></span></code> </pre><br>  Tetapi Anda perlu menambahkan tanda centang bahwa ukurannya masih benar.  Ini perlu, karena upaya untuk menempatkan objek dalam buffer yang tidak sesuai untuk itu adalah UB. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Foo.h struct Foo { Foo(); ~Foo(); private: constexpr std::size_t kImplSize = 32; constexpr std::size_t kImplAlign = 8; struct Foo_impl; //forward declaration std::aligned_storage_t&lt;kImplSize, kImplAlign&gt; impl; }; // Foo.cpp //implementation struct Foo::Foo_impl { } struct Foo::~Foo() { static_assert(kImplSize==sizeof(Foo_impl),"Size and sizeof(T) mismatch"); static_assert(kImplAlign==alignof(kImplAlign),"Alignment and alignof(T) mismatch"); // call destructor of Foo_impl }</span></span></code> </pre><br>  Kami melakukan pemeriksaan pada file cpp, dan jika ada sesuatu yang tidak benar, kami akhiri dengan kesalahan kompilasi, dan mencetak ukuran struktur yang benar sehingga programmer dapat menebak dari upaya kedua. <br><br>  Anton menunjukkan cara membuat pustaka serialisasi dalam berbagai format menjadi nyaman, hanya saja tidak melupakan fitur ADL: jika ada parameter template untuk argumen fungsi, fungsi tersebut akan dicari dalam ruang nama parameter argumen ini. <br><br>  <a href="https://assets.ctfassets.net/oxjq45e8ilak/4rkoaQV6ancsfvzYx1fOCF/087dda7d63101cc225d706d03d7c5075/100566_2093066332_Anton_Polukhin_C_tryuki_iz_Taksi.pdf">(slide laporan)</a> <br><br><h2>  Eric Niebler: Abstraksi pemersatu untuk async dalam C ++ </h2><br>  Laporan yang menarik, yang membahas masalah abstraksi asinkron dalam standar bahasa yang ada: mengapa masa depan dan janji lambat, dan bisakah kita mendesain perpustakaan sedemikian rupa untuk menghindari overhead ini.  Para pengembang facebook tampaknya memiliki solusi yang layak <a href="https://github.com/facebookexperimental/libunifex">https://github.com/facebookexperimental/libunifex</a> <br><br>  <a href="https://downloads.ctfassets.net/oxjq45e8ilak/7t4EOuNTYQ6EdOGL29JIjD/e84cd20b1613cabd4e996c50be2646f5/100546_1679046287_Eric_Niebler_A_unifying_abstraction_for_async_in_C.pdf">(slide laporan)</a> <br><br><h2>  Dmitry Kozhevnikov dan Andrey Davydov: Dua laporan tentang modul </h2><br>  Program memiliki dua laporan berturut-turut tentang modul.  Setelah mendengarkan kedua laporan, menjadi jelas bahwa modul-modul tersebut belum siap untuk digunakan.  Ini sedikit membuat saya kesal, karena saya tidak tertarik pada prinsipnya bagaimana fitur baru bahasa ini diimplementasikan, dan saya berpikir bahwa C ++ 20 akan keluar dan siap untuk digunakan segera.  Sayangnya, ternyata tidak demikian. <br><br>  (slide laporan: <a href="https://assets.ctfassets.net/oxjq45e8ilak/5gShGYJh9P0cIJZxfTgHu0/92cb2eeec856eef5833e588090d22559/100558_1104503204_Dmitriy_Kozhevnikov_Moduli_v_S20__pravda_ili_vymysel.pdf">1</a> , <a href="https://downloads.ctfassets.net/oxjq45e8ilak/76buZHU0KEcucSJ7iLt0M0/6612f35172b8b70ce5e8c6800b53ce5a/100581_45993991_Andrey_Davydov_Moduli_izmeneniya_v_core_language.pdf">2</a> ) <br><br><h2>  Kesimpulan </h2><br>  Konferensi yang lalu senang dengan contoh-contoh menarik menggunakan fitur-fitur terkenal dari bahasa tersebut.  Sejumlah besar laporan tentang chip dari standar berikut - C ++ 20.  Ini, tentu saja, sangat berguna untuk semua pengembang C ++. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480798/">https://habr.com/ru/post/id480798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480788/index.html">Pohon Natal di baris perintah</a></li>
<li><a href="../id480790/index.html">"Efisiensi pabrik". Menemukan hambatan dan menerapkan sistem tarikan untuk meningkatkan produktivitas</a></li>
<li><a href="../id480792/index.html">Rekayasa Hadiah</a></li>
<li><a href="../id480794/index.html">Sedikit tentang kasus khusus implementasi algoritma pencarian pintu terbuka</a></li>
<li><a href="../id480796/index.html">Pemrogram Schrodinger, devops dan kucing</a></li>
<li><a href="../id480800/index.html">Mencari penguji pekerjaan? Bersiaplah untuk menunjukkan keterampilan pengembang</a></li>
<li><a href="../id480802/index.html">Rekayasa Kekacauan, Bagian 3: Metode dan Alat</a></li>
<li><a href="../id480804/index.html">Memilih sistem desain 3D yang sempurna</a></li>
<li><a href="../id480806/index.html">5 Alasan Utama Mengapa Saya Menyukai Properti CSS Khusus</a></li>
<li><a href="../id480808/index.html">Frontend Odnoklassniki baru: meluncurkan React in Java. Bagian I</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>