<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😏 👊🏿 🗜️ Este es tu Haskell (no) solo factorial y bueno para 🥈 👩‍🎨 😸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando se trata de lenguajes favoritos, generalmente digo que, en igualdad de condiciones, prefiero C ++ para los trituradores de números y Haskell pa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Este es tu Haskell (no) solo factorial y bueno para</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445134/"><p> Cuando se trata de lenguajes favoritos, generalmente digo que, en igualdad de condiciones, prefiero C ++ para los trituradores de números y Haskell para todo lo demás.  Es útil verificar periódicamente si esta división está justificada, y recientemente surgió una pregunta ociosa y muy simple: cómo se comportará la suma de todos los divisores de un número con el crecimiento de este mismo número, por ejemplo, para los primeros mil millones de números.  Es fácil intimidar esta tarea (es una lástima llamarlo el generador de números resultante), por lo que parece una gran opción para tal verificación. </p><br><p>  Además, todavía no tengo la capacidad de predecir con precisión el rendimiento del código Haskell, por lo que es útil intentar enfoques deliberadamente malos para ver cómo se degradará el rendimiento. </p><br><p>  Bueno, además, puede mostrar fácilmente un algoritmo más eficiente que una búsqueda frontal de divisores para cada número de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhiPklW7vGPzlRW9oEqWGuNYVa9a3A#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhiPklW7vGPzlRW9oEqWGuNYVa9a3A#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  . </p><a name="habracut"></a><br><h3>  Algoritmo </h3><br><p>  Entonces, comencemos con el algoritmo. </p><br><p>  Cómo encontrar la suma de todos los divisores de un número <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhiPklW7vGPzlRW9oEqWGuNYVa9a3A#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> n </script>  ?  Puedes pasar por todo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span><script type="math/tex" id="MathJax-Element-4"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  y por cada tal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.265ex" height="2.298ex" viewBox="0 -780.1 975.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhiPklW7vGPzlRW9oEqWGuNYVa9a3A#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/445134/&amp;usg=ALkJrhiPklW7vGPzlRW9oEqWGuNYVa9a3A#MJMAIN-31" x="737" y="-213"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> k_1 </script>  verifica el resto de la división <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> n </script>  en <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-msubsup" id="MJXp-Span-16"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-18" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> k_1 </script>  .  Si el resto es <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mn" id="MJXp-Span-20">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  , luego agregue a la batería <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-24" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k_1 + k_2 </script>  donde <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">c</span><span class="MJXp-mrow" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span></span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;">1</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> k_2 = \ frac {n} {k_1} </script>  si <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-48" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">q</span><span class="MJXp-msubsup" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-55" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> k_1 \ neq k_2 </script>  y solo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-msubsup" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-59" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> k_1 </script>  de lo contrario </p><br><p>  ¿Se puede aplicar este algoritmo? <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> n </script>  veces, para cada número de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> n </script>  ?  Puedes, por supuesto.  ¿Cuál será la dificultad?  Fácil de ver ese orden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">O</span><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-71" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">c</span><span class="MJXp-mrow" id="MJXp-Span-76"><span class="MJXp-mn" id="MJXp-Span-77">3</span></span><span class="MJXp-mrow" id="MJXp-Span-78"><span class="MJXp-mn" id="MJXp-Span-79">2</span></span><span class="MJXp-mo" id="MJXp-Span-80" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> O (n ^ \ frac {3} {2}) </script>  divisiones: para cada número hacemos exactamente la raíz de las divisiones, y tenemos números <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> n </script>  .  ¿Podemos hacerlo mejor?  Resulta que sí. </p><br><p>  Uno de los problemas con este método es que estamos desperdiciando demasiado esfuerzo.  Demasiadas divisiones no nos llevan al éxito, dando un resto distinto de cero.  Es natural tratar de ser un poco más perezoso y abordar la tarea desde el otro lado: ¿vamos a generar todo tipo de candidatos para divisores y ver qué números satisfacen? </p><br><p>  Entonces, ahora necesitamos una caída repentina para cada número de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mn" id="MJXp-Span-84">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 1 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> n </script>  calcular la suma de todos sus divisores.  Para hacer esto, revisa todo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="noError" id="MJXp-Span-88" style="display: inline-block;">k_1&nbsp;\&nbsp;in&nbsp;\&nbsp;{1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;sqrt&nbsp;n&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> k_1 \ in \ {1 \ dots \ lfloor \ sqrt n \ rfloor \} </script>  y para cada uno <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-msubsup" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-92" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> k_1 </script>  repasemos todo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="noError" id="MJXp-Span-94" style="display: inline-block;">k_2&nbsp;\&nbsp;in&nbsp;\&nbsp;{k_1&nbsp;\&nbsp;dots&nbsp;\&nbsp;lfloor&nbsp;\&nbsp;frac&nbsp;{n}&nbsp;{k}&nbsp;\&nbsp;rfloor&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> k_2 \ in \ {k_1 \ dots \ lfloor \ frac {n} {k} \ rfloor \} </script>  .  Para cada par <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mo" id="MJXp-Span-96" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-msubsup" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-99" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-103" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> (k_1, k_2) </script>  agregar a la celda con el índice <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-msubsup" id="MJXp-Span-106"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-108" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-109">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">t</span><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-116" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> k_1 \ cdot k_2 </script>  valor <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-msubsup" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-120" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-122"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-124" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> k_1 + k_2 </script>  si <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-msubsup" id="MJXp-Span-126"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-128" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mtext" id="MJXp-Span-129">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">q</span><span class="MJXp-msubsup" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-135" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> k_1 \ neq k_2 </script>  y <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-msubsup" id="MJXp-Span-137"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138" style="margin-right: 0.05em;">k</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-139" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> k_1 </script>  de lo contrario </p><br><p>  Este algoritmo hace exactamente <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-msubsup" id="MJXp-Span-141"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142" style="margin-right: 0.05em;">n</span><span class="MJXp-mtext MJXp-script" id="MJXp-Span-143" style="vertical-align: 0.5em;">&nbsp;</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">c</span><span class="MJXp-mrow" id="MJXp-Span-148"><span class="MJXp-mn" id="MJXp-Span-149">1</span></span><span class="MJXp-mrow" id="MJXp-Span-150"><span class="MJXp-mn" id="MJXp-Span-151">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> n ^ \ frac {1} {2} </script>  divisiones, y cada multiplicación (que es más barata que la división) nos lleva al éxito: en cada iteración aumentamos algo.  Esto es mucho más efectivo que el enfoque frontal. </p><br><p>  Además, con este mismo enfoque frontal, puede comparar ambas implementaciones y asegurarse de que den los mismos resultados para números bastante pequeños, lo que debería agregar un poco de confianza. </p><br><h3>  Primera implementación </h3><br><p>  Y, por cierto, esto es directamente casi un pseudocódigo de la implementación inicial en Haskell: </p><br><pre><code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.IntMap.Strict <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IM divisorSums :: Int -&gt; Int divisorSums n = IM.fromListWith (+) premap IM.! n where premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor $ sqrt $ fromIntegral n ] , k2 &lt;- [ k1 .. n `quot` k1 ] ]</code> </pre> <br><p>  <code>Main</code> módulo es simple y no lo traigo. </p><br><p>  Además, aquí mostramos la cantidad solo para la mayoría <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-152"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> n </script>  para facilitar la comparación con otras implementaciones.  A pesar del hecho de que Haskell es un lenguaje perezoso, en este caso se calcularán todas las cantidades (aunque la justificación completa para esto está más allá del alcance de este artículo), por lo que no resulta que no contaremos nada inadvertidamente. </p><br><p>  ¿Qué tan rápido funciona?  En mi i7 3930k, en una secuencia, 100,000 elementos se resuelven en 0.4 s.  En este caso, se gastan 0,15 s en cálculos y 0,25 s en GC.  Y ocupamos aproximadamente 8 megabytes de memoria, aunque, dado que el tamaño del int es de 8 bytes, idealmente deberíamos tener 800 kilobytes. </p><br><p>  Bueno (no realmente)  ¿Cómo crecerán estos números con números crecientes?  Para 1'000'000 elementos, ha estado trabajando durante aproximadamente 7.5 segundos, gastando tres segundos en computación y 4.5 segundos gastando en GC, y también ocupando 80 megabytes (10 veces más de lo necesario).  E incluso si pretendemos ser Desarrolladores de Software Java Senior por un segundo y comenzamos a ajustar GC, no cambiaremos significativamente la imagen.  Que mal.  Parece que nunca esperaremos mil millones de números, y tampoco entraremos en la memoria: solo hay 64 gigabytes de RAM en mi máquina, y tomará alrededor de 80 si la tendencia continúa. </p><br><p>  Parece tiempo de hacer </p><br><h3>  Opción C ++ </h3><br><p>  Tratemos de tener una idea de lo que tiene sentido luchar, y para esto escribiremos el código en las ventajas. </p><br><p>  Bueno, como ya tenemos un algoritmo depurado, entonces todo es simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;string&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; int main(int argc, char **argv) { if (argc != 2) { std::cerr &lt;&lt; "Usage: " &lt;&lt; argv[0] &lt;&lt; " maxN" &lt;&lt; std::endl; return 1; } int64_t n = std::stoi(argv[1]); std::vector&lt;int64_t&gt; arr; arr.resize(n + 1); for (int64_t k1 = 1; k1 &lt;= static_cast&lt;int64_t&gt;(std::sqrt(n)); ++k1) { for (int64_t k2 = k1; k2 &lt;= n / k1; ++k2) { auto val = k1 != k2 ? k1 + k2 : k1; arr[k1 * k2] += val; } } std::cout &lt;&lt; arr.back() &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Si de repente quieres escribir algo sobre este código</b> <div class="spoiler_text"><p>  El compilador hace un gran movimiento de código invariante de bucle en este caso, calcula la raíz una vez en la vida del programa y calcula <code>n / k1</code> una vez por iteración del bucle externo. <br></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Y un spoiler sobre simplicidad</b> <div class="spoiler_text"><p>  Este código no funcionó para mí la primera vez, a pesar de que copié un algoritmo existente.  Cometí un par de errores muy estúpidos que, al parecer, no están directamente relacionados con los tipos, pero aún así se cometieron.  Pero lo es, pensamientos en voz alta. </p></div></div><br><p>  <code>-O3 -march=native</code> , clang 8, se procesan un millón de elementos en 0.024 s, ocupando los 8 megabytes de memoria asignados.  Mil millones: 155 segundos, 8 gigabytes de memoria, como se esperaba.  Ouch  Haskell no es bueno.  Haskell necesita ser expulsado.  ¡Solo factoriales y prepromorfismos en él y escribir!  O no? </p><br><h3>  Segunda opción </h3><br><p>  Obviamente, ejecutar todos los datos generados a través de <code>IntMap</code> , que es, de hecho, un mapa relativamente ordinario, por decirlo suavemente, no es la decisión más sabia (sí, esta es la misma opción obviamente mala que se mencionó al principio).  ¿Por qué no usamos una matriz como en el código C ++? </p><br><p>  Probemos </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! n where arr = A.accumArray (+) 0 (1, <span class="hljs-title"><span class="hljs-title">n</span></span>) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span>, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Aquí usamos inmediatamente la versión sin caja de la matriz, ya que <code>Int</code> bastante simple y no necesitamos pereza.  La versión en caja solo diferiría en el tipo <code>arr</code> , por lo que no perdemos en el idioma también.  Además, el enlace para el <code>bound</code> se realiza por separado aquí, pero no porque el compilador sea estúpido y no haga LICM, sino porque entonces puede especificar explícitamente su tipo y evitar una advertencia del compilador sobre el incumplimiento del argumento de <code>floor</code> . </p><br><p>  0.045 s para un millón de elementos (¡solo dos veces peor que las ventajas!).  8 megabytes de memoria, cero milisegundos en GC (!).  En tamaños más grandes, la tendencia persiste: aproximadamente dos veces más lenta que C ++ y la misma cantidad de memoria.  Gran resultado!  ¿Pero podemos hacerlo mejor? </p><br><p>  Resulta que sí.  <code>accumArray</code> verifica los índices, lo cual no es necesario que hagamos en este caso: los índices son correctos en la construcción.  Intentemos reemplazar la llamada a <code>accumArray</code> con <code>unsafeAccumArray</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Divisors.Multi(<span class="hljs-title"><span class="hljs-title">divisorSums</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.IArray <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Array.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> A divisorSums :: Int -&gt; Int divisorSums n = arr A.! (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) where arr = A.unsafeAccumArray (+) 0 (0, <span class="hljs-title"><span class="hljs-title">n</span></span> - 1) premap :: A.UArray Int Int premap = [ (<span class="hljs-title"><span class="hljs-title">k1</span></span> * <span class="hljs-title"><span class="hljs-title">k2</span></span> - 1, <span class="hljs-title"><span class="hljs-title">if</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> /= <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">then</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span> + <span class="hljs-title"><span class="hljs-title">k2</span></span> <span class="hljs-title"><span class="hljs-title">else</span></span> <span class="hljs-title"><span class="hljs-title">k1</span></span>) | k1 &lt;- [ 1 .. floor bound ] , k2 &lt;- [ k1 .. n `quot` k1 ] ] bound = sqrt $ fromIntegral n :: Double</code> </pre> <br><p>  Como puede ver, los cambios son mínimos, excepto por la necesidad de ser indexados desde cero (que, en mi opinión, es un error en la API de la biblioteca, pero esta es otra pregunta).  ¿Cuál es el rendimiento? </p><br><p>  Un millón de elementos: 0.021 s (¡guau, dentro del margen de error, pero más rápido que los profesionales!).  Naturalmente, los mismos 8 megabytes de memoria, los mismos 0 ms en el GC. </p><br><p>  Mil millones de elementos: 152 s (¡parece que es realmente más rápido que las ventajas!).  Ligeramente menos de 8 gigabytes.  0 ms en GC.  El código sigue siendo idiomático.  Creo que podemos decir que esto es una victoria. </p><br><h3>  En conclusión </h3><br><p>  En primer lugar, me sorprendió que el reemplazo de <code>accumArray</code> con una versión <code>unsafe</code> aumentaría tanto.  Sería más razonable esperar 10-20 por ciento (después de todo, en las ventajas, reemplazar el <code>operator[]</code> con <code>at()</code> no da una disminución significativa en el rendimiento), ¡pero no a la mitad! </p><br><p>  En segundo lugar, en mi opinión, es realmente genial que un código limpio bastante idiomático sin un mutable sobresaliente alcance este nivel de rendimiento. </p><br><p>  En tercer lugar, por supuesto, son posibles otras optimizaciones, y en todos los niveles.  Estoy seguro, por ejemplo, de que puede extraer un poco más del código de las ventajas.  Sin embargo, en mi opinión, en todos los puntos de referencia, el equilibrio entre el esfuerzo realizado (y la cantidad de código) y el escape resultante es importante.  De lo contrario, todo finalmente converge al desafío de LLVM JIT o algo así.  Además, existen ciertamente algoritmos más eficientes para resolver este problema, pero el resultado de una breve reflexión presentada aquí también funcionará para esta pequeña aventura dominical. </p><br><p>  Cuarto, mi favorito: los sistemas de tipos necesitan ser desarrollados.  <code>unsafe</code> no es necesario aquí, como programador puedo demostrar que <code>k_1 * k_2 &lt;= n</code> para todos los <code>k_1, k_2</code> encontrados en el bucle.  En un mundo ideal de lenguajes de tipo dependiente, construiría esta prueba estáticamente y la pasaría a la función correspondiente, lo que eliminaría la necesidad de verificaciones en tiempo de ejecución.  Pero, por desgracia, en Haskell no hay zavtipov completo, y en los idiomas donde hay zavtipy (y que sé), no hay una <code>array</code> y análogos. </p><br><p>  Quinto, no conozco otros lenguajes de programación lo suficiente como para calificar para puntos de referencia cercanos en estos idiomas, pero uno de mis amigos escribió un análogo en Python.  Casi exactamente cien veces más lento, y peor de memoria.  Y el algoritmo en sí mismo es extremadamente simple, por lo que si alguien conocedor escribe un análogo en Go, Rust, Julia, D, Java, Malbolge en los comentarios, o comparte una comparación, por ejemplo, con el código C ++ en su máquina, probablemente será genial . </p><br><p>  PD: Perdón por el encabezado ligeramente clickbait.  No se me ocurrió nada mejor. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445134/">https://habr.com/ru/post/445134/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445122/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 357 (18 al 24 de marzo de 2019)</a></li>
<li><a href="../445124/index.html">Endurecimiento moderado para Firefox</a></li>
<li><a href="../445126/index.html">Aplicaciones de ingeniería inversa después de la ofuscación (Parte 2)</a></li>
<li><a href="../445128/index.html">Tutorial de Oracle Application Express Resumen del IDE</a></li>
<li><a href="../445130/index.html">El Ministerio del Interior ha comprado PC por 180 millones de rublos; todo el dinero fue a fabricantes extranjeros</a></li>
<li><a href="../445136/index.html">No te pongas nervioso, no te apresures, no interrumpas: la historia de una tragedia</a></li>
<li><a href="../445138/index.html">IBM Integration Bus y lo que come</a></li>
<li><a href="../445140/index.html">PHP Digest No. 152 (del 11 al 25 de marzo de 2019)</a></li>
<li><a href="../445146/index.html">La historia del elefante Slonik, el logotipo de PostgreSQL</a></li>
<li><a href="../445150/index.html">Upwork está registrado en la Federación Rusa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>