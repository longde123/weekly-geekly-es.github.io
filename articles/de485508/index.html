<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♑️ 🌌 🦃 Auf dem Weg zu einem funktionsfähigen DBMS und NoSQL ERP: Salden- und Kalkulationsspeicher 🖕🏽 👌🏻 ☝🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr 

 Wir untersuchen weiterhin die Anwendbarkeit der Prinzipien der funktionalen Programmierung bei der Gestaltung von ERP. In einem früheren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auf dem Weg zu einem funktionsfähigen DBMS und NoSQL ERP: Salden- und Kalkulationsspeicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485508/"> Hallo habr <br><br>  Wir untersuchen weiterhin die Anwendbarkeit der Prinzipien der funktionalen Programmierung bei der Gestaltung von ERP.  In einem <a href="https://habr.com/ru/post/482938/">früheren Artikel haben</a> wir darüber gesprochen, warum dies notwendig ist, die Grundlagen der Architektur gelegt und die Konstruktion einfacher Windungen am Beispiel einer umgekehrten Aussage demonstriert.  Tatsächlich wird der <a href="https://habr.com/ru/post/178259/">Event-Sourcing-</a> Ansatz vorgeschlagen, aber aufgrund der Trennung der Datenbank in unveränderliche und veränderbare Teile erhalten wir in einem System eine Kombination der Vorteile einer Zuordnung / Reduzierung des Speichers und eines speicherinternen DBMS, wodurch sowohl das Leistungsproblem als auch das Skalierbarkeitsproblem gelöst werden.  In diesem Artikel zeige ich (und zeige einen Prototyp für TypeScript- und <a href="https://deno.land/" rel="nofollow">Deno-Laufzeit</a> ), wie Register von <a href="https://deno.land/" rel="nofollow">Sofortguthaben</a> in einem solchen System gespeichert und Kosten berechnet werden.  Für diejenigen, die den 1. Artikel noch nicht gelesen haben - eine kurze Zusammenfassung: <br><br>  <b>1. Journal of documents</b> .  Ein ERP, das auf der Basis eines RDBMS aufgebaut ist, ist ein riesiger veränderlicher Zustand mit wettbewerbsfähigem Zugriff, daher nicht skalierbar, schwach hörbar und unzuverlässig im Betrieb (es ermöglicht Dateninkonsistenz).  Im funktionalen ERP sind alle Daten in Form eines chronologisch geordneten Journals mit unveränderlichen Primärdokumenten organisiert, und es gibt nichts anderes als diese Dokumente.  Verknüpfungen werden von neuen zu alten Dokumenten durch vollständige ID aufgelöst (und niemals umgekehrt), und alle anderen Daten (Salden, Register, Vergleiche) sind berechnete Windungen, d. H. Zwischengespeicherte Ergebnisse von reinen Funktionen im Dokumentenfluss.  Das Fehlen von Status + Hörbarkeit von Funktionen erhöht die Zuverlässigkeit (die Blockchain passt perfekt zu diesem Schema), und als Bonus erhalten wir eine Vereinfachung des Speicherschemas + adaptiver Cache anstelle von fest (auf der Basis von Tabellen organisiert). <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">So sieht das Datenfragment in unserem ERP aus</b> <div class="spoiler_text"><pre><code class="json hljs">//   { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"person"</span></span>, //  ,      <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0^1580006048190"</span></span>, //  +    ID <span class="hljs-attr"><span class="hljs-attr">"erp_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.retail"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } //  <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"purch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"purch.XXX"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"purch.XXX^1580006158787"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2020-01-21"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"person"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0^1580006048190"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"stock"</span></span>: <span class="hljs-string"><span class="hljs-string">"stock.0^1580006048190"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"lines"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"nomen"</span></span>: <span class="hljs-string"><span class="hljs-string">"nomen.0^1580006048190"</span></span>, //    <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">116.62545127448834</span></span> } ] }</code> </pre> </div></div><br>  <b>2. Immunität und Veränderlichkeit</b> .  Das Journal of Documents ist in 2 ungleiche Teile unterteilt: <br><br><ul><li>  Der große, <b>unveränderliche</b> Teil befindet sich in den JSON-Dateien, ist für sequenzielles Lesen verfügbar und kann auf Serverknoten kopiert werden, um eine gleichzeitige Lesung zu gewährleisten.  Die auf dem unveränderlichen Teil berechneten Windungen werden zwischengespeichert, und bis zur Verschiebung bleiben auch die Immunitätspunkte unverändert (d. H. Repliziert). </li><li>  Der kleinere <b>veränderbare</b> Teil sind die aktuellen Daten (in Bezug auf die Buchhaltung - die aktuelle Periode), in denen Sie Dokumente bearbeiten und stornieren (aber nicht löschen), Beziehungen nachträglich einfügen und neu organisieren können (z. B. Belege mit Ausgaben abgleichen, Kosten neu berechnen usw.). .).  Veränderliche Daten werden als Ganzes in den Speicher geladen, wodurch eine schnelle Faltungsberechnung und ein relativ einfacher Transaktionsmechanismus bereitgestellt werden. </li></ul><br>  <b>3. Faltung</b> .  Aufgrund der fehlenden JOIN-Semantik ist die SQL-Sprache ungeeignet und alle Algorithmen sind im Filter / Reduce-Funktionsstil geschrieben. Für bestimmte Dokumenttypen gibt es auch Trigger (Event-Handler).  Die Filter- / Reduktionsberechnung wird Faltung genannt.  Der Faltungsalgorithmus für den Anwendungsentwickler sieht aus wie ein vollständiger Durchlauf durch das Dokumentjournal. Der Kernel führt jedoch während der Ausführung eine Optimierung durch. Das aus dem unveränderlichen Teil berechnete Zwischenergebnis wird aus dem Cache entnommen und dann aus dem veränderlichen Teil „gezählt“.  Ab dem zweiten Start wird die Faltung also vollständig im Arbeitsspeicher berechnet, was Bruchteile von Sekunden auf einer Million Dokumente dauert (wir werden dies anhand von Beispielen zeigen).  Die Faltung wird bei jedem Aufruf gezählt, da es sehr schwierig ist, alle Änderungen in veränderlichen Dokumenten zu verfolgen (imperativ-reaktiver Ansatz), und die Berechnungen im RAM sind billig, und der Benutzercode mit diesem Ansatz wird stark vereinfacht.  Eine Faltung kann die Ergebnisse anderer Faltungen verwenden, um Dokumente nach ID zu extrahieren und nach Schlüsseln im oberen Cache nach Dokumenten zu suchen. <br><br>  <b>4. Versionierung und Zwischenspeicherung von Dokumenten</b> .  Jedes Dokument hat einen eindeutigen Schlüssel und eine eindeutige ID (Schlüssel + Zeitstempel).  Dokumente mit demselben Schlüssel werden in einer Gruppe organisiert, deren letzter Datensatz aktuell (aktuell) und der Rest historisch ist. <br><br>  Ein Cache ist alles, was gelöscht werden kann und wird beim Starten der Datenbank aus dem Dokumentjournal wiederhergestellt.  Unser System verfügt über 3 Caches: <br><br><ul><li>  <b>Dokumenten-Cache</b> mit ID-Zugriff.  In der Regel handelt es sich dabei um Verzeichnisse und semipermanente Dokumente, z. B. Spesenabrechnungen.  Das Caching-Attribut (Ja / Nein) ist an den Dokumenttyp gebunden, der Cache wird beim ersten Start der Datenbank initialisiert und dann vom Kernel unterstützt. </li><li>  <b>Oberster Cache von Dokumenten</b> mit Schlüsselzugriff.  Speichert die neuesten Versionen von Verzeichniseinträgen und Sofortregistern (z. B. Salden und Salden).  Das Zeichen für die Notwendigkeit eines Top-Caches ist an den Dokumenttyp gebunden. Der Top-Cache wird vom Kernel beim Erstellen / Ändern eines Dokuments aktualisiert. </li><li>  <b>Der</b> aus dem unveränderlichen Teil der Datenbank berechnete <b>Faltungscache</b> ist eine Sammlung von Schlüssel / Wert-Paaren.  Der Faltungsschlüssel ist eine Zeichenfolgendarstellung des Algorithmuscodes + des serialisierten Anfangswerts des Akkumulators (in dem die Eingangsberechnungsparameter übertragen werden), und das Ergebnis der Faltung ist der serialisierte Endwert des Akkumulators (es kann sich um ein komplexes Objekt oder eine Sammlung handeln). </li></ul><br><h4>  Aufbewahrung von Guthaben </h4><br>  Wir gehen weiter zum Thema des Artikels - der Lagerung von Rückständen.  Das erste, was mir in den Sinn kommt, ist, den Rest als Faltung zu implementieren, deren Eingabeparameter eine Kombination von Analysten ist (z. B. Nomenklatur + Warehouse + Batch).  In ERP müssen wir jedoch den Selbstkostenpreis berücksichtigen, für den ein Vergleich der Kosten mit den Salden erforderlich ist (FIFO-Algorithmen, Batch-FIFO, Lagerdurchschnitt - theoretisch können wir die Kosten für jede Kombination von Analysten berechnen).  Mit anderen Worten, wir brauchen den Rest als unabhängige Einheit, und da alles ein Dokument in unserem System ist, ist der Rest auch ein Dokument. <br><br>  Ein Beleg vom Typ "Saldo" wird vom Auslöser zum Zeitpunkt der Buchung von Belegzeilen für Kauf / Verkauf / Bewegung usw. erzeugt.  Der Saldenschlüssel ist eine Kombination von Analysten. Salden mit demselben Schlüssel bilden eine historische Gruppe, deren letztes Element im obersten Cache gespeichert und sofort verfügbar ist.  Salden sind keine Buchungen und werden daher nicht zusammengefasst. Der letzte Datensatz ist relevant, und die frühesten Datensätze führen einen Verlauf. <br><br>  Die Waage speichert die Menge in Lagereinheiten und den Betrag in der Hauptwährung und teilt die zweite in die erste - wir erhalten die Sofortkosten an der Schnittstelle des Analytikers.  Somit speichert das System nicht nur die vollständige Historie der Residuen, sondern auch die vollständige Historie der Kosten, was für die Überprüfung der Ergebnisse von Vorteil ist.  Der Saldo ist leichtgewichtig, die maximale Anzahl der Salden entspricht der Anzahl der Belegzeilen (tatsächlich weniger, wenn die Zeilen nach Analystenkombinationen gruppiert werden), die Anzahl der Top-Saldendatensätze hängt nicht vom Volumen der Datenbank ab und wird durch die Anzahl der Analystenkombinationen bestimmt, die bei der Saldokontrolle und Kostenberechnung beteiligt sind Unser Top-Cache ist immer vorhersehbar. <br><br><h4>  Post-Verbrauchsmaterialien </h4><br>  Die Salden werden zunächst aus Belegdokumenten vom Typ „Einkauf“ gebildet und um etwaige Aufwandsbelege bereinigt.  Ein Auslöser für einen Verkaufsbeleg führt beispielsweise Folgendes aus: <br><br><ul><li>  Extrahiert das aktuelle Guthaben aus dem oberen Cache </li><li>  prüft Mengenverfügbarkeit </li><li>  Speichert einen Link zum aktuellen Kontostand in der Belegzeile und den Sofortkosten </li><li>  generiert eine neue Bilanz mit einem reduzierten Betrag und Betrag </li></ul><br>  Ein Beispiel für eine Veränderung des Gleichgewichts beim Verkauf <br><br><pre> <code class="json hljs">//    { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0^1580006158787"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">11209</span></span>, //  <span class="hljs-attr"><span class="hljs-attr">"val"</span></span>: <span class="hljs-number"><span class="hljs-number">1392411.5073958784</span></span> //  } //  <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"sale"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"sale.XXX"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"sale.XXX^1580006184280"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2020-01-21"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"person"</span></span>: <span class="hljs-string"><span class="hljs-string">"person.0^1580006048190"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"stock"</span></span>: <span class="hljs-string"><span class="hljs-string">"stock.0^1580006048190"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"lines"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"nomen"</span></span>: <span class="hljs-string"><span class="hljs-string">"nomen.0^1580006048190"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">295.5228788368553</span></span>, //   <span class="hljs-attr"><span class="hljs-attr">"cost"</span></span>: <span class="hljs-number"><span class="hljs-number">124.22263425781769</span></span>, //  <span class="hljs-attr"><span class="hljs-attr">"from"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0^1580006158787"</span></span> // - } ] } //    { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"bal|nomen.0|stock.0^1580006184281"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"qty"</span></span>: <span class="hljs-number"><span class="hljs-number">11189</span></span>, <span class="hljs-attr"><span class="hljs-attr">"val"</span></span>: <span class="hljs-number"><span class="hljs-number">1389927.054710722</span></span> }</code> </pre><br>  TypeScript Document Handler-Klassencode <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Document, DocClass, IDBCore } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../core/DBMeta.ts'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sale</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DocClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> before_add(doc: Document, <span class="hljs-attr"><span class="hljs-attr">db</span></span>: IDBCore): [boolean, string?] { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> err = <span class="hljs-string"><span class="hljs-string">''</span></span> doc.lines.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">line</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-string"><span class="hljs-string">'bal'</span></span> + <span class="hljs-string"><span class="hljs-string">'|'</span></span> + db.key_from_id(line.nomen) + <span class="hljs-string"><span class="hljs-string">'|'</span></span> + db.key_from_id(doc.stock) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bal = db.get_top(key, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-comment"><span class="hljs-comment">// true -  ,    - const bal_qty = bal?.qty ?? 0 //   const bal_val = bal?.val ?? 0 //   if (bal_qty &lt; line.qty) { err += '\n"' + key + '": requested ' + line.qty + ' but balance is only ' + bal_qty } else { line.cost = bal_val / bal_qty //     line.from = bal.id } }) return err !== '' ? [false, err] : [true,] } static after_add(doc: Document, db: IDBCore): void { doc.lines.forEach(line =&gt; { const key = 'bal' + '|' + db.key_from_id(line.nomen) + '|' + db.key_from_id(doc.stock) const bal = db.get_top(key, true) const bal_qty = bal?.qty ?? 0 const bal_val = bal?.val ?? 0 db.add_mut( { type: 'bal', key: key, qty: bal_qty - line.qty, val: bal_val - line.cost * line.qty // cost   before_add() } ) }) } }</span></span></code> </pre><br>  Natürlich wäre es möglich, die Kosten nicht direkt in den Ausgabenzeilen zu speichern, sondern als Referenz aus der Bilanz zu übernehmen, aber die Tatsache ist, dass Salden Dokumente sind, es gibt viele von ihnen, es ist unmöglich, alles zwischenzuspeichern, und das Abrufen eines Dokuments nach ID durch Lesen von der Festplatte ist teuer ( wie man sequentielle Dateien für den schnellen Zugriff indiziert - ich sage es Ihnen beim nächsten Mal). <br><br>  Das Hauptproblem, auf das Kommentatoren hingewiesen haben, ist die Systemleistung, und wir haben alles, um sie an relativ relevanten Datenmengen zu messen. <br><br><h4>  Generierung von Quelldaten </h4><br>  Unser System besteht aus <b>5.000</b> Gegenparteien (Lieferanten und Kunden), <b>3.000</b> Artikeln, <b>50</b> Lagern und <b>100.000</b> Dokumenten jeder Art - Kauf, Übertragung, Verkauf.  Dokumente werden zufällig generiert, durchschnittlich 8,5 Zeilen pro Dokument.  Einkaufs- und Verkaufslinien generieren eine Transaktion (und einen Saldo) und zwei Bewegungslinien, was dazu führt, dass <b>300.000</b> Primärdokumente etwa <b>3,4 Millionen</b> Transaktionen generieren, was dem monatlichen Volumen von ERP in den Provinzen entspricht.  Wir erzeugen den wandelbaren Teil auf die gleiche Weise, nur mit einem Volumen von 10 mal weniger. <br><br>  Wir generieren die Dokumente mit einem <a href="" rel="nofollow">Skript</a> .  Beginnen wir mit den Einkäufen, während der Rest der Dokumente überprüft der Trigger den Saldo an der Schnittstelle von Artikel und Lager. Wenn mindestens eine Zeile nicht erfolgreich ist, versucht das Skript, ein neues Dokument zu generieren.  Salden werden automatisch durch Trigger erstellt. Die maximale Anzahl der Analystenkombinationen entspricht der Anzahl der Nomenklaturen * Anzahl der Lager, d. H.  <b>150k.</b> <br><br><h4>  DB- und Cache-Größe </h4><br>  Nach Abschluss des Skripts werden die folgenden Datenbankmetriken angezeigt: <br><br><ul><li>  unveränderlicher Teil: <b>3.7kk</b> Dokumente (300k primär, <b>Restguthaben</b> ) - Datei <b>770 Mb</b> </li><li>  veränderlicher Teil: <b>370.000</b> Dokumente (30.000 Primärdokumente, Restguthaben) - Datei <b>76 MB</b> </li><li>  <b>Oberer</b> Dokumenten-Cache: <b>158.000</b> Dokumente (Referenzen + aktueller <b>Kontostand</b> ) - Datei <b>20 MB</b> </li><li>  Dokumenten-Cache: <b>8.8k</b> Dokumente (nur Verzeichnisse) - Datei <b>&lt;1 Mb</b> </li></ul><br><h4>  Benchmarking </h4><br>  Initialisierung der Basis.  Wenn keine Cache-Dateien vorhanden sind, führt die Datenbank beim ersten Start einen vollständigen Scan durch: <br><br><ul><li>  unveränderliche Datendatei (Füllen von Caches für zwischengespeicherte Dokumenttypen) - <b>55 Sek</b> </li><li>  veränderbare Datendatei (Laden der gesamten Daten in den Speicher und Aktualisieren des oberen Caches) - <b>6 Sek</b> </li></ul><br>  Wenn Caches vorhanden sind, kann die Basis schneller angehoben werden: <br><br><ul><li>  veränderbare Datendatei - <b>6 Sek</b> </li><li>  Top-Cache-Datei - <b>1,8 Sek</b> </li><li>  andere Caches - weniger als 1 Sekunde </li></ul><br>  Jede Benutzerfaltung (zum Beispiel das <a href="" rel="nofollow">Skript zum</a> Erstellen des Umsatzberichts) beim ersten Aufruf startet einen Scan der unveränderlichen Datei, und veränderbare Daten werden bereits im RAM gescannt: <br><br><ul><li>  unveränderliche Datei - <b>55 Sek</b> </li><li>  veränderbares Array im Speicher - <b>0,2 Sek</b> </li></ul><br>  Wenn bei nachfolgenden Aufrufen die Eingabeparameter übereinstimmen, gibt <i>reduct ()</i> das Ergebnis in <b>0,2 Sekunden zurück</b> , wobei jedes Mal Folgendes ausgeführt wird: <br><br><ul><li>  Extrahieren des Ergebnisses aus dem Reduce-Cache per Schlüssel (unter Berücksichtigung der Parameter) </li><li>  Scannen eines veränderlichen Arrays im Speicher ( <b>370.000</b> Dokumente) </li><li>  "Zählen" des Ergebnisses durch Anwendung des Faltungsalgorithmus auf gefilterte Dokumente ( <b>20k</b> ) </li></ul><br>  Die Ergebnisse sind für ein solches Datenvolumen, meinen Single-Core-Laptop, das völlige Fehlen von DBMS (wir vergessen nicht, dass dies nur ein Prototyp ist) und einen One-Pass-Algorithmus in der TypeScript-Sprache (der für Unternehmen immer noch als fragwürdige Wahl gilt) recht attraktiv. Backend-Anwendungen). <br><br><h4>  Technische Optimierung </h4><br>  Nachdem ich die Leistung des Codes untersucht hatte, stellte ich fest, dass mehr als 80% der Zeit damit verbracht wurde, die Datei zu lesen und Unicode zu analysieren, nämlich <i>File.read ()</i> und <i>TextDecoder (). Decode ()</i> .  Außerdem ist die Dateischnittstelle auf hoher Ebene in Deno nur asynchron, und wie ich <a href="https://habr.com/ru/post/483734/">kürzlich herausgefunden habe,</a> ist der Preis für <i>async / await</i> für meine Aufgabe zu hoch.  Daher musste ich meinen eigenen synchronen <a href="" rel="nofollow">Reader</a> schreiben, ohne mich wirklich um Optimierungen zu kümmern, um die Geschwindigkeit des reinen Lesens um das Dreifache zu erhöhen, oder, wenn Sie mit JSON-Parsing rechnen - um das Zweifache. Gleichzeitig wurde die Asynchronisierung global beseitigt.  Vielleicht muss dieses Stück auf niedriger Ebene umgeschrieben werden (oder vielleicht das ganze Projekt).  Das Schreiben von Daten auf die Festplatte ist ebenfalls unannehmbar langsam, obwohl dies für den Prototypen weniger kritisch ist. <br><br><h4>  Weitere Schritte </h4><br>  1. Demonstrieren Sie die Implementierung der folgenden ERP-Algorithmen in einem funktionalen Stil: <br><br><ul><li>  Reservemanagement und offene Bedürfnisse </li><li>  Supply-Chain-Planung </li><li>  Berechnung der Produktionskosten unter Berücksichtigung der Gemeinkosten </li></ul><br>  2. Wechseln Sie in das Binärspeicherformat. Dies beschleunigt möglicherweise das Lesen der Datei.  Oder setzen Sie sogar alles in Mongo. <br><br>  3. Übertragen Sie FuncDB im Mehrbenutzermodus.  Gemäß dem <a href="https://ru.wikipedia.org/wiki/CQRS" rel="nofollow">CQRS-</a> Prinzip wird das Lesen direkt von Serverknoten ausgeführt, auf die unveränderliche Datenbankdateien kopiert (oder über das Netzwerk durchsucht) werden, und die Aufzeichnung wird über einen einzelnen REST-Punkt ausgeführt, der veränderbare Daten, Caches und Transaktionen verwaltet. <br><br>  4. Beschleunigung des Erhalts eines nicht zwischengespeicherten Dokuments nach ID aufgrund der Indizierung von sequentiellen Dateien (was natürlich gegen unser Konzept von Single-Pass-Algorithmen verstößt, aber das Vorhandensein einer Möglichkeit ist immer besser als das Nichtvorhandensein). <br><br><h4>  Zusammenfassung </h4><br>  Bisher habe ich keinen einzigen Grund gefunden, die Idee eines funktionalen DBMS / ERP aufzugeben, denn trotz der Nichtuniversalität eines solchen DBMS für eine bestimmte Aufgabe (Rechnungswesen und Planung) haben wir die Chance, die Skalierbarkeit, Hörbarkeit und Zuverlässigkeit des Zielsystems um ein Vielfaches zu steigern - alles dank der Einhaltung der Grundvoraussetzungen Prinzipien der FP. <br><br>  <a href="" rel="nofollow"><b>Vollständiger Projektcode</b></a> <br><br>  Wenn jemand alleine spielen möchte: <br><br><ul><li>  installiere <a href="https://deno.land/" rel="nofollow">deno</a> </li><li>  Klonen Sie das Repository </li><li>  Führen Sie das Datenbankgenerierungsskript mit Residuen-Kontrolle aus (generate_sample_database_with_balanses.ts) </li><li>  Führen Sie die Skripte der Beispiele 1..4 aus, die sich im Stammverzeichnis befinden </li><li>  Überlegen Sie sich ein eigenes Beispiel, kodieren Sie, testen Sie und geben Sie mir Feedback </li></ul><br>  PS <br>  Die Konsolenausgabe ist für Linux konzipiert, möglicherweise funktionieren Esc-Sequenzen unter Windows nicht richtig, aber ich habe nichts zu überprüfen :) <br><br>  Vielen Dank für Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485508/">https://habr.com/ru/post/de485508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485494/index.html">Wochenend-Tipps: Leichte Lesung für MINT-Majors</a></li>
<li><a href="../de485496/index.html">LyX: Allgemeine Bemerkungen. Teil 1</a></li>
<li><a href="../de485498/index.html">Anwendungsbeispiel Federreaktiv (Stand 14.01.2020)</a></li>
<li><a href="../de485502/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 495 (01/07/2020 - 01/13/2020)</a></li>
<li><a href="../de485504/index.html">Indem wir die Gesichtserkennung verbieten, verpassen wir den Punkt</a></li>
<li><a href="../de485510/index.html">So starten Sie ein Produkt alleine, wenn Sie Entwickler sind: Tipps von Taylor Otvel, dem Schöpfer von Laravel. Teil 3: Gib nicht auf</a></li>
<li><a href="../de485514/index.html">EBlink - GDB Server für ARM Cortex-M Mikrocontroller</a></li>
<li><a href="../de485518/index.html">Der Versuch, das Nicht-Komponierbare zu komponieren: Erhebe alles</a></li>
<li><a href="../de485520/index.html">QueryFilter: das Konzept des Filterns von Modellen</a></li>
<li><a href="../de485522/index.html">Hack The Box - Walkthrough AI. SQLi in API Text To Sreach, SSH-Weiterleitung und RCE in JDWP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>