<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏿 🖕🏿 👨🏾‍💼 Penerapan debug perangkat lunak dengan strace 🧑🏿‍🤝‍🧑🏿 🚎 👨🏻‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pekerjaan utama saya adalah, untuk sebagian besar, penyebaran sistem perangkat lunak, yaitu, saya menghabiskan banyak waktu untuk mencoba menjawab per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penerapan debug perangkat lunak dengan strace</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/478626/"><p><img src="https://habrastorage.org/webt/zi/se/d3/zised39h1shd8invmnqtcvxxdgu.jpeg"></p><br><p>  Pekerjaan utama saya adalah, untuk sebagian besar, penyebaran sistem perangkat lunak, yaitu, saya menghabiskan banyak waktu untuk mencoba menjawab pertanyaan-pertanyaan ini: </p><br><ul><li>  Perangkat lunak ini berfungsi untuk pengembang, tetapi tidak untuk saya.  Mengapa </li><li>  Kemarin perangkat lunak ini bekerja untuk saya, tetapi tidak hari ini.  Mengapa </li></ul><br><p>  Ini adalah jenis debugging yang sedikit berbeda dari debugging perangkat lunak biasa.  Debugging normal adalah tentang logika kode, tetapi penyebaran debugging adalah tentang interaksi kode dan lingkungan.  Sekalipun akar masalahnya adalah kesalahan logis, fakta bahwa segala sesuatu bekerja pada satu mesin dan bukan pada mesin lain berarti masalahnya ada di lingkungan. </p><br><p>  Jadi, alih-alih alat debugging biasa seperti <strong>gdb</strong> , saya memiliki seperangkat alat yang berbeda untuk debugging penyebaran.  Dan alat favorit saya untuk menangani masalah seperti "Mengapa tidak membajak perangkat lunak ini?"  disebut <strong>strace</strong> . </p><a name="habracut"></a><br><h3 id="chto-zhe-takoe-strace">  Apa itu strace? </h3><br><p>  <a href="https://strace.io/">strace</a> adalah alat untuk melacak panggilan sistem.  Awalnya dibuat di Linux, tetapi chip debugging yang sama dapat diputar dengan alat untuk sistem lain ( <a href="http://dtrace.org/blogs/about/">DTrace</a> atau <a href="https://man.openbsd.org/ktrace">ktrace</a> ). </p><br><p>  Aplikasi utama sangat sederhana.  Anda hanya perlu menjalankan strace dengan perintah apa pun dan itu akan mengirim semua panggilan sistem ke dump (meskipun, pertama, Anda mungkin harus menginstal <strong>strace</strong> itu sendiri): </p><br><pre><code class="plaintext hljs">$ strace echo Hello ...Snip lots of stuff... write(1, "Hello\n", 6) = 6 close(1) = 0 close(2) = 0 exit_group(0) = ? +++ exited with 0 +++</code> </pre> <br><p>  Apa panggilan sistem ini?  Ini adalah semacam API untuk kernel sistem operasi.  Sekali waktu, perangkat lunak memiliki akses langsung ke perangkat keras tempat ia bekerja.  Jika, misalnya, Anda perlu menampilkan sesuatu di layar, itu diputar dengan port dan / atau register memori untuk perangkat video.  Ketika sistem komputer multitasking menjadi populer, kekacauan memerintah karena berbagai aplikasi berjuang untuk perangkat keras.  Kesalahan dalam satu aplikasi dapat menurunkan pekerjaan orang lain, jika tidak seluruh sistem.  Kemudian mode privilege (atau "perlindungan dering") muncul di CPU.  Kernel menjadi yang paling istimewa: ia memperoleh akses penuh ke perangkat keras, membuat aplikasi yang kurang istimewa yang sudah harus meminta akses dari kernel untuk berinteraksi dengan perangkat keras - melalui panggilan sistem. </p><br><p>  Pada tingkat biner, panggilan sistem sedikit berbeda dari panggilan fungsi sederhana, namun sebagian besar program menggunakan pembungkus di perpustakaan standar.  Yaitu  pustaka standar POSIX C berisi panggilan ke fungsi <strong>write ()</strong> , yang berisi semua kode khusus arsitektur untuk panggilan sistem <strong>tulis</strong> . </p><br><p><img src="https://habrastorage.org/webt/cr/qx/_-/crqx_-ucgqzecn4942nlgmuhaek.png"></p><br><p>  Singkatnya, setiap interaksi antara aplikasi dan lingkungannya (sistem komputer) dilakukan melalui panggilan sistem.  Oleh karena itu, ketika perangkat lunak bekerja pada satu mesin dan bukan pada yang lain, alangkah baiknya untuk melihat hasil penelusuran panggilan sistem.  Untuk lebih spesifik, berikut adalah daftar titik-titik tipikal yang dapat dianalisis menggunakan pelacakan panggilan sistem: </p><br><ul><li>  Konsol I / O </li><li>  Input / output jaringan </li><li>  Akses Sistem File dan File I / O </li><li>  Manajemen proses / utas seumur hidup </li><li>  Manajemen Memori Tingkat Rendah </li><li>  Akses ke driver perangkat tertentu </li></ul><br><h3 id="kogda-ispolzovat-strace">  Kapan harus menggunakan strace? </h3><br><p>  Secara teori, <strong>strace</strong> digunakan dengan program apa pun di ruang pengguna, karena program apa pun di ruang pengguna harus melakukan panggilan sistem.  Ia bekerja lebih efisien dengan mengkompilasi, program tingkat rendah, tetapi juga bekerja dengan bahasa tingkat tinggi seperti Python jika Anda dapat melewati kebisingan tambahan dari runtime dan interpreter. </p><br><p>  Dalam semua kemegahannya, <strong>strace</strong> memanifestasikan dirinya selama debugging perangkat lunak yang bekerja dengan baik pada satu mesin, tetapi tiba-tiba berhenti bekerja pada yang lain, memberikan pesan yang tidak jelas tentang file, izin atau upaya gagal untuk menjalankan beberapa perintah atau sesuatu ... Sayang sekali, tapi tidak begitu baik itu dikombinasikan dengan masalah tingkat tinggi seperti kesalahan verifikasi sertifikat.  Ini biasanya memerlukan kombinasi alat <strong>strace</strong> , kadang <a href="https://linux.die.net/man/1/ltrace">ltrace,</a> dan tingkat yang lebih tinggi (seperti alat baris perintah <strong>openssl</strong> untuk debugging sertifikat). </p><br><p>  Misalnya, kami bekerja di server yang berdiri sendiri, tetapi melacak panggilan sistem sering dapat dilakukan pada platform penyebaran yang lebih kompleks.  Anda hanya perlu memilih toolkit yang tepat. </p><br><h3 id="primer-prostoy-otladki">  Contoh Debugging Sederhana </h3><br><p>  Katakanlah Anda ingin menjalankan aplikasi server foo yang luar biasa, tetapi ternyata ini: </p><br><pre> <code class="plaintext hljs">$ foo Error opening configuration file: No such file or directory</code> </pre> <br><p>  Jelas, dia tidak dapat menemukan file konfigurasi yang Anda tulis.  Ini terjadi karena kadang-kadang, ketika manajer paket mengkompilasi aplikasi, mereka mengesampingkan lokasi file yang diharapkan.  Dan jika Anda mengikuti panduan instalasi untuk satu distribusi, di yang lain Anda menemukan file sepenuhnya tidak seperti yang saya harapkan.  Mungkin untuk menyelesaikan masalah dalam beberapa detik jika pesan kesalahan mengatakan di mana harus mencari file konfigurasi, tetapi tidak dikatakan.  Jadi ke mana harus mencari? </p><br><p>  Jika Anda memiliki akses ke kode sumber, Anda dapat membacanya dan mengetahuinya.  Paket cadangan yang bagus, tetapi bukan solusi tercepat.  Anda dapat menggunakan debugger langkah-demi-langkah seperti <strong>gdb</strong> dan melihat apa yang dilakukan program, tetapi jauh lebih efisien untuk menggunakan alat yang dirancang khusus untuk menunjukkan interaksi dengan lingkungan: <strong>strace</strong> . </p><br><p>  Kesimpulan dari <strong>strace</strong> mungkin tampak berlebihan, tetapi kabar baiknya adalah sebagian besar dapat diabaikan dengan aman.  Seringkali berguna untuk menggunakan operator -o untuk menyimpan hasil penelusuran ke file terpisah: </p><br><pre> <code class="plaintext hljs">$ strace -o /tmp/trace foo Error opening configuration file: No such file or directory $ cat /tmp/trace execve("foo", ["foo"], 0x7ffce98dc010 /* 16 vars */) = 0 brk(NULL) = 0x56363b3fb000 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=25186, ...}) = 0 mmap(NULL, 25186, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f2f12cf1000 close(3) = 0 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260A\2\0\0\0\0\0"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0755, st_size=1824496, ...}) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2f12cef000 mmap(NULL, 1837056, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f2f12b2e000 mprotect(0x7f2f12b50000, 1658880, PROT_NONE) = 0 mmap(0x7f2f12b50000, 1343488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f2f12b50000 mmap(0x7f2f12c98000, 311296, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16a000) = 0x7f2f12c98000 mmap(0x7f2f12ce5000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b6000) = 0x7f2f12ce5000 mmap(0x7f2f12ceb000, 14336, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f2f12ceb000 close(3) = 0 arch_prctl(ARCH_SET_FS, 0x7f2f12cf0500) = 0 mprotect(0x7f2f12ce5000, 16384, PROT_READ) = 0 mprotect(0x56363b08b000, 4096, PROT_READ) = 0 mprotect(0x7f2f12d1f000, 4096, PROT_READ) = 0 munmap(0x7f2f12cf1000, 25186) = 0 openat(AT_FDCWD, "/etc/foo/config.json", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x2 (flags O_RDWR) brk(NULL) = 0x56363b3fb000 brk(0x56363b41c000) = 0x56363b41c000 fstat(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x8), ...}) = 0 write(3, "Error opening configuration file"..., 60) = 60 close(3) = 0 exit_group(1) = ? +++ exited with 1 +++</code> </pre> <br><p>  Tentang seluruh halaman pertama dari output <strong>strace</strong> biasanya merupakan persiapan tingkat rendah untuk diluncurkan.  (Ada banyak <strong>mmap</strong> , <strong>mprotect</strong> , panggilan <strong>brk</strong> untuk hal-hal seperti mendeteksi memori tingkat rendah dan menampilkan pustaka dinamis.) Faktanya, selama debugging, output <strong>strace</strong> paling baik dibaca dari awal.  Di bagian bawah adalah panggilan untuk <strong>menulis</strong> , yang menampilkan pesan kesalahan.  Kami melihat di atas dan melihat panggilan sistem yang salah pertama - panggilan <strong>openat</strong> yang <strong>melempar</strong> kesalahan <strong>ENOENT</strong> ("file atau direktori tidak ditemukan"), mencoba membuka <strong>/etc/foo/config.json</strong> .  Di sini, di sini file konfigurasi seharusnya terletak. </p><br><p>  Itu hanya sebuah contoh, tetapi saya akan mengatakan bahwa 90% dari waktu saya menggunakan <strong>strace</strong> , tidak ada yang lebih sulit untuk dilakukan dan tidak harus.  Di bawah ini adalah panduan debugging langkah-demi-langkah lengkap: </p><br><ul><li>  Frustrasi oleh pesan kesalahan sistem-y cadel dari suatu program </li><li>  Mulai ulang program dengan <strong>strace</strong> </li><li>  Temukan pesan kesalahan dalam hasil penelusuran </li><li>  Pergi lebih tinggi sampai Anda bertemu dengan panggilan sistem gagal pertama </li></ul><br><p>  Sangat mungkin bahwa panggilan sistem pada langkah 4 akan menunjukkan apa yang salah. </p><br><h3 id="podskazki">  Kiat </h3><br><p>  Sebelum menunjukkan contoh debugging yang lebih kompleks, saya akan memberi tahu Anda beberapa trik untuk menggunakan <strong>strace</strong> secara efektif: </p><br><p>  <strong>pria adalah temanmu</strong> </p><br><p>  Pada banyak sistem * nix, daftar lengkap panggilan sistem kernel dapat diperoleh dengan menjalankan <strong>syscalls</strong> .  Anda akan melihat hal-hal seperti <strong>brk (2)</strong> , yang berarti Anda bisa mendapatkan informasi lebih lanjut dengan menjalankan <strong>man 2 brk</strong> . </p><br><p>  <strong>Garpu</strong> kecil rake: <strong>man 2</strong> menunjukkan kepada saya sebuah halaman untuk shell <strong>fork ()</strong> di <strong>GNU libc</strong> , yang ternyata diimplementasikan menggunakan panggilan <strong>clone ()</strong> .  Semantik panggilan <strong>fork</strong> tetap sama jika Anda menulis program yang menggunakan <strong>fork ()</strong> dan mulai melacak - saya tidak akan menemukan panggilan <strong>fork</strong> , alih-alih mereka akan ada <strong>klon ()</strong> .  Rake semacam itu hanya membingungkan jika Anda mulai membandingkan sumber dengan output dari <strong>strace</strong> . </p><br><p>  <strong>Gunakan -o untuk menyimpan output ke file</strong> </p><br><p>  <strong>strace</strong> dapat menghasilkan keluaran yang luas, sehingga seringkali berguna untuk menyimpan hasil penelusuran dalam file yang terpisah (seperti dalam contoh di atas).  Dan itu membantu untuk tidak membingungkan output program dengan output <strong>strace</strong> di konsol. </p><br><p>  <strong>Gunakan -s untuk melihat lebih banyak data argumen</strong> </p><br><p>  Anda mungkin memperhatikan bahwa bagian kedua dari pesan kesalahan tidak ditampilkan dalam contoh jejak di atas.  Ini karena <strong>strace</strong> hanya menampilkan 32 byte pertama dari argumen string secara default.  Jika Anda ingin melihat lebih banyak, tambahkan sesuatu seperti <strong>-s 128</strong> ke panggilan <strong>strace</strong> . </p><br><p>  <strong>-Y Memfasilitasi pelacakan file \ soket \ dan sebagainya.</strong> </p><br><p>  “Everything is a file” berarti sistem * nix melakukan semua I / O menggunakan deskriptor file, apakah itu berlaku untuk file atau jaringan, atau ke saluran antarproses.  Ini nyaman untuk pemrograman, tetapi membuatnya sulit untuk melacak apa yang sebenarnya terjadi ketika Anda melihat umum <strong>membaca</strong> dan <strong>menulis</strong> dalam jejak hasil panggilan sistem. </p><br><p>  Dengan menambahkan operator -u, Anda memaksa <strong>strace untuk</strong> membubuhi keterangan setiap deskriptor file dalam output dengan catatan apa yang ditunjukkannya. </p><br><p>  Lampirkan ke proses yang sudah berjalan dengan -p ** </p><br><p>  Seperti yang akan dilihat dari contoh di bawah ini, kadang-kadang Anda perlu melacak program yang sudah berjalan.  Jika Anda tahu itu berjalan sebagai proses 1337 (katakanlah, dari kesimpulan <strong>ps</strong> ), maka Anda dapat melacaknya seperti ini: </p><br><pre> <code class="plaintext hljs">$ strace -p 1337 ...system call trace output...</code> </pre> <br><p>  Mungkin Anda membutuhkan root privilege. </p><br><p>  <strong>Gunakan -f untuk memantau proses anak</strong> </p><br><p>  <strong>strace</strong> secara default hanya melacak satu proses.  Jika proses ini memunculkan proses anak, maka Anda dapat melihat panggilan sistem untuk menelurkan proses anak, tetapi panggilan sistem proses anak tidak akan ditampilkan. </p><br><p>  Jika Anda berpikir bahwa kesalahan ada dalam proses <strong>turunan</strong> , gunakan operator <strong>-f</strong> , ini akan memungkinkan penelusurannya.  Kelemahan dari ini adalah bahwa kesimpulannya akan membuat Anda lebih bingung.  Ketika <strong>strace</strong> melacak satu proses atau satu utas, itu menunjukkan aliran peristiwa panggilan tunggal.  Ketika melacak beberapa proses sekaligus, maka Anda mungkin akan melihat awal panggilan terputus oleh pesan <strong>&lt;unfinished ...&gt;</strong> , lalu sekelompok panggilan untuk cabang eksekusi lainnya, dan hanya kemudian akhir dari yang pertama dengan <strong>&lt;... foocall dilanjutkan&gt;</strong> .  Atau, pisahkan semua hasil penelusuran ke dalam file yang berbeda, menggunakan operator <strong>-ff</strong> juga ( <strong>lihat</strong> <a href="https://linux.die.net/man/1/strace">manual</a> <strong>strace</strong> untuk perincian). </p><br><p>  <strong>Saring jejaknya dengan -e</strong> </p><br><p>  Seperti yang Anda lihat, hasil penelusuran adalah kumpulan nyata dari semua panggilan sistem yang mungkin.  Dengan flag <strong>-e</strong> , Anda dapat memfilter jejak (lihat <a href="https://linux.die.net/man/1/strace">manual</a> <strong>strace</strong> ).  Keuntungan utama adalah menjalankan jejak dengan pemfilteran lebih cepat daripada melakukan jejak penuh, dan kemudian <strong>grep</strong> .  Sejujurnya, saya hampir selalu tidak peduli. </p><br><p>  <strong>Tidak semua kesalahan itu buruk</strong> </p><br><p>  Contoh sederhana dan umum adalah program mencari file di beberapa tempat sekaligus, seperti shell mencari, di mana keranjang / direktori berisi file yang dapat dieksekusi: </p><br><pre> <code class="plaintext hljs">$ strace sh -c uname ... stat("/home/user/bin/uname", 0x7ffceb817820) = -1 ENOENT (No such file or directory) stat("/usr/local/bin/uname", 0x7ffceb817820) = -1 ENOENT (No such file or directory) stat("/usr/bin/uname", {st_mode=S_IFREG|0755, st_size=39584, ...}) = 0 ...</code> </pre> <br><p>  Heuristik "permintaan gagal terakhir sebelum pesan kesalahan" bagus untuk menemukan kesalahan yang relevan.  Bagaimanapun, adalah logis untuk memulai dari awal. </p><br><p>  <strong>C Panduan Pemrograman Bantuan Memahami Panggilan Sistem</strong> </p><br><p>  Panggilan standar ke pustaka C bukan panggilan sistem, tetapi hanya lapisan permukaan yang tipis.  Jadi, jika Anda memahami setidaknya sedikit bagaimana dan apa yang harus dilakukan dalam C, akan lebih mudah bagi Anda untuk memahami hasil penelusuran panggilan sistem.  Misalnya, jika Anda mengalami masalah debugging panggilan ke sistem jaringan, lihat <a href="https://beej.us/guide/bgnet/html/index.html">"Panduan Pemrograman Jaringan" Bija yang</a> sama. </p><br><h3 id="primer-otladki-poslozhnee">  Contoh debugging yang lebih rumit </h3><br><p>  Saya sudah mengatakan bahwa contoh debugging sederhana adalah contoh dari sesuatu yang, sebagian besar, saya harus berurusan dengan <strong>strace</strong> .  Namun, terkadang diperlukan investigasi nyata, jadi inilah contoh nyata debugging yang lebih rumit. </p><br><p>  <a href="https://untroubled.org/bcron/">bcron</a> adalah penjadwal pemrosesan tugas, implementasi lain dari <strong>daemon cron</strong> * nix.  Itu diinstal di server, tetapi ketika seseorang mencoba mengedit jadwal, inilah yang terjadi: </p><br><pre> <code class="plaintext hljs"># crontab -e -u logs bcrontab: Fatal: Could not create temporary file</code> </pre> <br><p>  Oke, jadi <strong>bcron</strong> mencoba menulis file tertentu, tetapi tidak berhasil dan dia tidak mengakui alasannya.  Temukan <strong>strace</strong> : </p><br><pre> <code class="plaintext hljs"># strace -o /tmp/trace crontab -e -u logs bcrontab: Fatal: Could not create temporary file # cat /tmp/trace ... openat(AT_FDCWD, "bcrontab.14779.1573691864.847933", O_RDONLY) = 3 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f82049b4000 read(3, "#Ansible: logsagg\n20 14 * * * lo"..., 8192) = 150 read(3, "", 8192) = 0 munmap(0x7f82049b4000, 8192) = 0 close(3) = 0 socket(AF_UNIX, SOCK_STREAM, 0) = 3 connect(3, {sa_family=AF_UNIX, sun_path="/var/run/bcron-spool"}, 110) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f82049b4000 write(3, "156:Slogs\0#Ansible: logsagg\n20 1"..., 161) = 161 read(3, "32:ZCould not create temporary f"..., 8192) = 36 munmap(0x7f82049b4000, 8192) = 0 close(3) = 0 write(2, "bcrontab: Fatal: Could not creat"..., 49) = 49 unlink("bcrontab.14779.1573691864.847933") = 0 exit_group(111) = ? +++ exited with 111 +++</code> </pre> <br><p>  Pada akhirnya, ada pesan kesalahan <strong>tulis</strong> , tetapi kali ini ada sesuatu yang berbeda.  Pertama, tidak ada kesalahan panggilan sistem yang relevan yang biasanya terjadi sebelum ini.  Kedua, jelas bahwa di suatu tempat seseorang telah membaca pesan kesalahan.  Sepertinya masalah sebenarnya ada di tempat lain, dan <strong>bcrontab</strong> hanya memutar pesannya. </p><br><p>  Jika Anda melihat <strong>man 2 read</strong> , Anda dapat melihat bahwa argumen pertama (3) adalah deskriptor file yang * nix gunakan untuk semua pemrosesan I / O.  Bagaimana cara mencari tahu apa file deskriptor 3 mewakili?  Dalam kasus khusus ini, Anda dapat menjalankan <strong>strace</strong> dengan operator <strong>-u</strong> (lihat di atas), dan itu akan secara otomatis memberi tahu Anda, namun, untuk menghitung hal-hal seperti itu, berguna untuk mengetahui cara membaca dan menganalisis hasil penelusuran. </p><br><p>  Sumber deskriptor file dapat menjadi salah satu dari banyak panggilan sistem (semuanya tergantung pada apa deskriptor untuk konsol, soket jaringan, file itu sendiri, atau sesuatu yang lain), tetapi karena mungkin, kami mencari panggilan yang mengembalikan 3 (t .e mencari "= 3" di hasil penelusuran).  Akibatnya, ada 2 di antaranya: <strong>openat</strong> di bagian paling atas dan <strong>soket</strong> di tengah.  <strong>openat</strong> membuka file, tetapi <strong>tutup</strong> (3) setelah itu akan menunjukkan bahwa itu ditutup lagi.  (Rake: deskriptor file dapat digunakan kembali ketika dibuka dan ditutup).  Panggilan <strong>soket ()</strong> cocok, karena ini adalah yang terakhir sebelum <strong>dibaca ()</strong> , dan ternyata bcrontab berfungsi dengan sesuatu melalui soket.  Baris berikutnya menunjukkan bahwa deskriptor file dikaitkan dengan <strong>soket domain unix di</strong> sepanjang path <strong>/ var / run / bcron-spool</strong> . </p><br><p>  Jadi, Anda perlu menemukan proses yang terpasang pada <strong>soket unix</strong> di sisi lain.  Ada beberapa trik bagus untuk tujuan ini, dan keduanya berguna untuk debugging penyebaran server.  Yang pertama adalah menggunakan <strong>netstat</strong> atau yang lebih baru <strong>ss</strong> (status soket).  Kedua perintah menunjukkan koneksi jaringan aktif dari sistem dan mengambil operator <strong>-l</strong> untuk menggambarkan soket mendengarkan, dan operator <strong>-p</strong> untuk menampilkan program yang terhubung ke soket sebagai klien.  (Ada banyak opsi yang lebih berguna, tetapi keduanya cukup untuk tugas ini.) </p><br><pre> <code class="plaintext hljs"># ss -pl | grep /var/run/bcron-spool u_str LISTEN 0 128 /var/run/bcron-spool 1466637 * 0 users:(("unixserver",pid=20629,fd=3))</code> </pre> <br><p>  Ini menunjukkan bahwa pendengar adalah perintah <strong>inixserver</strong> yang bekerja dengan proses ID 20629. (Dan, secara kebetulan, menggunakan pendeskripsi file 3 sebagai soket.) </p><br><p>  Alat kedua yang sangat berguna untuk menemukan informasi yang sama disebut <strong>lsof</strong> .  Ini mencantumkan semua file yang terbuka (atau deskriptor file) dalam sistem.  Atau Anda dapat memperoleh informasi tentang satu file tertentu: </p><br><pre> <code class="plaintext hljs"># lsof /var/run/bcron-spool COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME unixserve 20629 cron 3u unix 0x000000005ac4bd83 0t0 1466637 /var/run/bcron-spool type=STREAM</code> </pre> <br><p>  Proses 20629 adalah server yang berumur panjang, jadi Anda dapat melampirkan <strong>strace</strong> padanya menggunakan sesuatu seperti <strong>strace -o / tmp / trace -p 20629</strong> .  Jika kita mengedit tugas cron di terminal lain, kita mendapatkan output dari hasil penelusuran dengan kesalahan.  Dan inilah hasilnya: </p><br><pre> <code class="plaintext hljs">accept(3, NULL, NULL) = 4 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21181 close(4) = 0 accept(3, NULL, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21181, si_uid=998, si_status=0, si_utime=0, si_stime=0} --- wait4(0, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], WNOHANG|WSTOPPED, NULL) = 21181 wait4(0, 0x7ffe6bc36764, WNOHANG|WSTOPPED, NULL) = -1 ECHILD (No child processes) rt_sigaction(SIGCHLD, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, 8) = 0 rt_sigreturn({mask=[]}) = 43 accept(3, NULL, NULL) = 4 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21200 close(4) = 0 accept(3, NULL, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21200, si_uid=998, si_status=111, si_utime=0, si_stime=0} --- wait4(0, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 111}], WNOHANG|WSTOPPED, NULL) = 21200 wait4(0, 0x7ffe6bc36764, WNOHANG|WSTOPPED, NULL) = -1 ECHILD (No child processes) rt_sigaction(SIGCHLD, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, 8) = 0 rt_sigreturn({mask=[]}) = 43 accept(3, NULL, NULL</code> </pre> <br><p>  (Penerimaan terakhir <strong>()</strong> tidak akan lengkap saat melacak.) Dan lagi, sayangnya, hasil ini tidak mengandung kesalahan yang kita cari.  Kami tidak melihat pesan apa pun yang akan dikirimkan atau diterima bcrontag dari soket.  Alih-alih, kontrol penuh proses ( <strong>clone</strong> , <strong>wait4</strong> , <strong>SIGCHLD</strong> , dll.) Proses ini memunculkan proses anak, yang, seperti yang Anda duga, melakukan pekerjaan yang sebenarnya.  Dan jika Anda perlu menangkap jejaknya, tambahkan <strong>strace -f</strong> ke panggilan.  Inilah yang kami temukan dengan mencari pesan kesalahan di hasil baru dengan strace <strong>-f -o / tmp / trace -p 20629</strong> : </p><br><pre> <code class="plaintext hljs">21470 openat(AT_FDCWD, "tmp/spool.21470.1573692319.854640", O_RDWR|O_CREAT|O_EXCL, 0600) = -1 EACCES (Permission denied) 21470 write(1, "32:ZCould not create temporary f"..., 36) = 36 21470 write(2, "bcron-spool[21470]: Fatal: logs:"..., 84) = 84 21470 unlink("tmp/spool.21470.1573692319.854640") = -1 ENOENT (No such file or directory) 21470 exit_group(111) = ? 21470 +++ exited with 111 +++</code> </pre> <br><p>  Sekarang, ini sesuatu.  Proses 21470 menerima kesalahan "akses ditolak" ketika mencoba membuat file di jalur <strong>tmp / spool.21470.1573692319.854640</strong> (merujuk ke direktori kerja saat ini).  Jika kita hanya tahu direktori kerja saat ini, kita akan tahu path lengkap dan bisa mencari tahu mengapa prosesnya tidak dapat membuat file sementara sendiri di dalamnya.  Sayangnya, prosesnya sudah keluar, jadi Anda tidak bisa hanya menggunakan <strong>lsof -p 21470</strong> untuk menemukan direktori saat ini, tetapi Anda dapat bekerja di arah yang berlawanan - cari panggilan sistem PID 21470 yang mengubah direktori.  (Jika tidak ada, PID 21470 harus mewarisinya dari induknya, dan ini tidak dapat <strong>dipecahkan</strong> melalui <strong>lsof -p</strong> .) Panggilan sistem ini adalah <strong>chdir</strong> (yang mudah ditemukan dengan bantuan mesin pencari jaringan modern).  Dan di sini adalah hasil pencarian terbalik berdasarkan hasil penelusuran, hingga server PID 20629 itu sendiri: </p><br><pre> <code class="plaintext hljs">20629 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21470 ... 21470 execve("/usr/sbin/bcron-spool", ["bcron-spool"], 0x55d2460807e0 /* 27 vars */) = 0 ... 21470 chdir("/var/spool/cron") = 0 ... 21470 openat(AT_FDCWD, "tmp/spool.21470.1573692319.854640", O_RDWR|O_CREAT|O_EXCL, 0600) = -1 EACCES (Permission denied) 21470 write(1, "32:ZCould not create temporary f"..., 36) = 36 21470 write(2, "bcron-spool[21470]: Fatal: logs:"..., 84) = 84 21470 unlink("tmp/spool.21470.1573692319.854640") = -1 ENOENT (No such file or directory) 21470 exit_group(111) = ? 21470 +++ exited with 111 +++</code> </pre> <br><p>  (Jika Anda tersesat, Anda mungkin perlu membaca posting saya sebelumnya <a href="https://theartofmachinery.com/2018/11/07/writing_a_nix_shell.html">pada * nix process control and shells</a> .) Jadi, server PID 20629 tidak mendapatkan izin untuk membuat file di sepanjang jalur <strong>/var/spool/cron/tmp/spool.21470.1573692319.854640</strong> .  ,   —     . : </p><br><pre> <code class="plaintext hljs"># ls -ld /var/spool/cron/tmp/ drwxr-xr-x 2 root root 4096 Nov 6 05:33 /var/spool/cron/tmp/ # ps u -p 20629 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND cron 20629 0.0 0.0 2276 752 ? Ss Nov14 0:00 unixserver -U /var/run/bcron-spool -- bcron-spool</code> </pre> <br><p>    !     cron,    root      <strong>/var/spool/cron/tmp/</strong> .   <strong>chown cron /var/spool/cron/tmp/</strong>  <strong>bcron</strong>  . (     ,      —     SELinux  AppArmor,           <strong>dmesg</strong> .) </p><br><h3 id="itogo">  Total </h3><br><p>        ,  , , ,   —         . ,     <strong>bcron</strong> ,   . </p><br><p>            ,     ,  ,  <strong>strace</strong> ,        ,   .   , <strong>strace</strong>       . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478626/">https://habr.com/ru/post/id478626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478606/index.html">"Selamat malam" - bagaimana gadget pintar membuat orang tidak bisa tidur</a></li>
<li><a href="../id478616/index.html">Windows UAC tidak pernah berhenti memukau, atau Cara mendeteksi orang dalam</a></li>
<li><a href="../id478618/index.html">School of Magic PHP</a></li>
<li><a href="../id478620/index.html">Mengapa Anda mencoba FastAPI?</a></li>
<li><a href="../id478622/index.html">Pengujian A / B, saluran pipa dan ritel: kuartal bermerek untuk Big Data dari GeekBrains dan X5 Retail Group</a></li>
<li><a href="../id478628/index.html">CRI tinggi dalam bahasa Cina</a></li>
<li><a href="../id478630/index.html">Pascal memainkan Go. Implementasi metode dan antarmuka dalam kompiler amatir</a></li>
<li><a href="../id478634/index.html">Perangkap dalam Manajemen Proyek Pembelajaran Mesin</a></li>
<li><a href="../id478636/index.html">Cara kerja penyandian teks. Dari mana "buaya" berasal. Prinsip-prinsip pengkodean. Generalisasi dan analisis terperinci</a></li>
<li><a href="../id478638/index.html">db-tree: cari dan navigasikan basis data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>