<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”œ ğŸ‘ ğŸ‘¨ğŸ¾â€âš•ï¸ SObjectizer-5.6.0: potong hidup untuk tumbuh lebih lanjut ğŸ¤ ğŸšº ğŸš»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada hari ketiga, versi baru SObjectizer tersedia : 5.6.0 . Fitur utamanya adalah penolakan kompatibilitas dengan cabang stabil sebelumnya 5,5, yang t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SObjectizer-5.6.0: potong hidup untuk tumbuh lebih lanjut</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453256/"><p><img src="https://habrastorage.org/webt/vp/ah/jx/vpahjx-dkpsauwtfzyeiktnsfp4.jpeg"></p><br><p>  Pada hari ketiga, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">versi baru SObjectizer</a> tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">: 5.6.0</a> .  Fitur utamanya adalah penolakan kompatibilitas dengan cabang stabil sebelumnya 5,5, yang telah berkembang terus selama empat setengah tahun. </p><br><p>  Prinsip dasar pengoperasian SObjectizer-5 tetap sama.  Komunikasi, agen, kerja sama dan operator masih bersama kami.  Tetapi sesuatu berubah dengan serius, sesuatu yang umumnya dibuang.  Karena itu, hanya mengambil SO-5.6.0 dan mengkompilasi ulang kode Anda akan gagal.  Sesuatu perlu ditulis ulang.  Sesuatu mungkin harus didesain ulang. </p><br><p>  Mengapa kami menjaga kompatibilitas selama beberapa tahun, dan kemudian memutuskan untuk mengambil dan menghancurkan semuanya?  Dan apa yang paling parah? </p><br><p>  Saya akan mencoba membicarakan ini di artikel ini. </p><br><h1 id="zachem-voobsche-potrebovalos-chto-to-lomat">  Mengapa Anda perlu memecahkan sesuatu? </h1><br><p>  Sederhana saja. </p><a name="habracut"></a><br><p>  SObjectizer-5.5 selama pengembangannya telah menyerap begitu banyak hal yang berbeda dan beragam yang pada awalnya tidak direncanakan, sehingga sebagai hasilnya, ia telah membentuk terlalu banyak kruk dan alat peraga di dalamnya.  Dengan setiap versi baru, menambahkan sesuatu yang baru ke SO-5.5 menjadi semakin sulit.  Dan akhirnya, untuk pertanyaan "Mengapa kita membutuhkan semua ini?"  tidak ada jawaban yang cocok ditemukan. </p><br><p>  Jadi alasan pertama adalah komplikasi ulang jeroan ayam itik dari SObjectizer. </p><br><p>  Alasan kedua adalah bahwa kita bodoh bosan berfokus pada kompiler C ++ lama.  Cabang 5.5 dimulai pada 2014, ketika kami memiliki, jika saya tidak salah, gcc-4.8 dan MSVS2013.  Dan pada level ini, kami masih terus mempertahankan standar persyaratan untuk level dukungan untuk standar C ++. </p><br><p>  Awalnya, kami memiliki "kepentingan egois" dalam hal ini.  Selain itu, untuk beberapa waktu kami menganggap persyaratan rendah untuk kualitas dukungan untuk standar C ++ sebagai "keunggulan kompetitif" kami. </p><br><p>  Tetapi waktu terus berjalan, "minat egois" sudah berakhir.  Beberapa manfaat dari "keunggulan kompetitif" seperti itu tidak terlihat.  Mungkin mereka akan, jika kita bekerja dengan C ++ 98 sama sekali, maka kita akan tertarik pada perusahaan berdarah.  Tetapi perusahaan berdarah pada orang-orang seperti kita, pada prinsipnya, tidak tertarik.  Karena itu, diputuskan untuk berhenti membatasi diri dan mengambil sesuatu yang lebih segar.  Jadi kami mengambil yang terbaru dari stabil saat ini: C ++ 17. </p><br><p>  Tentunya, tidak semua orang akan menyukai solusi ini, untuk banyak C ++ 17, ini sekarang merupakan keunggulan terdepan yang tidak dapat dicapai, yang masih sangat, sangat jauh. </p><br><p>  Namun demikian, kami memutuskan risiko seperti itu.  Semua sama, proses mempopulerkan SObjectizer tidak berjalan cepat, jadi ketika SObjectizer menjadi lebih atau kurang banyak diminati, C ++ 17 tidak akan lagi menjadi "ujung tombak".  Sebaliknya, itu akan diperlakukan sama seperti sekarang di C ++ 11. </p><br><p>  Secara umum, alih-alih terus membangun kruk menggunakan subset C ++ 11, kami memutuskan untuk serius membuat ulang internal SObjectizer menggunakan C ++ 17.  Untuk membangun basis di mana SObjectizer dapat semakin berkembang selama empat atau lima tahun ke depan. </p><br><h1 id="chto-serezno-pomenyalos-v-sobjectizer-56">  Apa yang berubah serius di SObjectizer-5.6? </h1><br><p>  Sekarang, mari kita secara singkat membahas beberapa perubahan yang paling mencolok. </p><br><h2 id="u-kooperaciy-agentov-bolshe-net-strokovyh-imen">  Kerjasama agen tidak lagi memiliki nama string </h2><br><h3 id="problema">  Masalah </h3><br><p>  Sejak awal, SObjectizer-5 menuntut agar setiap kerjasama memiliki nama string yang unik.  Fitur ini diwarisi dari SObjectizer kelima dari sebelumnya, SObjectizer keempat. </p><br><p>  Karenanya, SObjectizer perlu menyimpan nama-nama koperasi terdaftar.  Periksa keunikan mereka saat mendaftar.  Cari kerja sama dengan nama selama deregistrasi, dll., Dll. </p><br><p>  Sejak versi pertama, skema sederhana telah digunakan dalam SObjectzer-5: kamus tunggal dari kerjasama terdaftar yang dilindungi oleh mutex.  Saat mendaftarkan kerja sama, mutex ditangkap, keunikan nama kerja sama, kehadiran orang tua, dll. Diperiksa.  Setelah memeriksa, kamus diubah, setelah itu mutex dirilis.  Ini berarti bahwa jika pada saat yang sama pendaftaran / deregistrasi beberapa koperasi sekaligus dimulai, maka di beberapa titik mereka akan berhenti dan menunggu sampai salah satu operasi selesai bekerja dengan kamus koperasi.  Karena itu, operasi koperasi tidak skala dengan baik. </p><br><p>  Itulah yang ingin saya singkirkan untuk memperbaiki situasi dengan kecepatan pendaftaran kerjasama. </p><br><h3 id="reshenie">  Solusi </h3><br><p>  Dua cara utama untuk memecahkan masalah ini dipertimbangkan. </p><br><p>  Pertama, menyimpan nama string, tetapi mengubah cara kamus disimpan sehingga operasi pendaftaran kerjasama dapat ditingkatkan.  Misalnya, kamus sharding, mis.  memecahnya menjadi beberapa bagian, yang masing-masing akan dilindungi oleh mutex-nya. </p><br><p>  Kedua, penolakan lengkap atas nama string dan penggunaan beberapa pengidentifikasi yang ditugaskan oleh SObjectizer. </p><br><p> Akibatnya, kami memilih metode kedua dan benar-benar meninggalkan penamaan koperasi.  Sekarang di SObjectizer ada yang namanya <code>coop_handle</code> , mis.  pegangan yang isinya disembunyikan dari pengguna, tetapi yang dapat dibandingkan dengan <code>std::weak_ptr</code> . </p><br><p>  SObjectizer mengembalikan <code>coop_handle</code> saat mendaftarkan kolaborasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    .</span></span></code> </pre> <br><p>  Pegangan ini harus digunakan untuk deregistrasi kerja sama: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    . ... // - . // ,     . //       . env.deregister_coop(coop_id, ...);</span></span></code> </pre> <br><p>  Juga, pegangan ini harus digunakan ketika membangun hubungan orangtua-anak: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . auto parent = env.make_coop(); ... //  parent . auto parent_id = env.register_coop(std::move(parent)); //  . ... //      ,    . auto child = env.make_coop(parent_id); ...</span></span></code> </pre> <br><p>  Struktur repositori untuk kerjasama dalam Lingkungan SObjectizer juga telah berubah secara dramatis.  Jika sebelum versi 5.5 termasuk itu adalah satu kamus umum, sekarang setiap kerjasama adalah repositori tautan ke kerjasama anak.  Yaitu  koperasi membentuk pohon dengan akar di koperasi akar khusus yang disembunyikan dari pengguna. </p><br><p>  Struktur seperti itu memungkinkan untuk skala <code>deregister_coop</code> <code>register_coop</code> dan <code>deregister_coop</code> jauh lebih baik: pemblokiran mutual operasi paralel terjadi hanya jika keduanya milik kerjasama induk yang sama.  Untuk kejelasan, berikut ini adalah hasil dari meluncurkan <a href="" rel="nofollow">patokan khusus</a> yang mengukur kinerja operasi dengan kerja sama pada laptop lama saya dengan Ubuntu 16.04 dan GCC-7.3: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 15.69s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Yaitu  versi 5.6.0 diatasi dengan hampir 2 juta kerjasama dalam ~ 15,5 detik. </p><br><p>  Dan di sini adalah versi 5.5.24.4, yang terakhir dari cabang 5.5 saat ini: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 46.856s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Skenario yang sama, tetapi hasilnya tiga kali lebih buruk. </p><br><h2 id="ostalsya-vsego-odin-vid-dispetcherov">  Hanya ada satu jenis dispatcher yang tersisa </h2><br><p>  Dispatcher adalah salah satu pilar SObjectizer.  Operator yang menentukan di mana dan bagaimana agen akan memproses pesan mereka.  Jadi, tanpa ide dispatcher, mungkin tidak akan ada SObjectizer. </p><br><p>  Namun, operator itu sendiri berevolusi, berevolusi dan berevolusi ke titik di mana bahkan tidak sulit bagi kami untuk membuat operator baru untuk SObjectizer-5.5.  Tapi sangat merepotkan.  Namun, mari kita mulai. </p><br><p>  Pada awalnya, semua dispatcher yang diperlukan aplikasi hanya dapat dibuat pada awal SObjectizer: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//    SObjectizer-. []( so_5::environment_params_t &amp; params ) { p.add_named_dispatcher("active_obj", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("shutdowner", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("groups", so_5::disp::active_group::create_disp()); ... } );</span></span></code> </pre> <br><p>  Saya tidak membuat operator yang diperlukan sebelum memulai - semuanya, ini salah saya, Anda tidak dapat mengubah apa pun. </p><br><p>  Jelas bahwa ini merepotkan dan karena skenario penggunaan untuk SObjectizer diperluas, maka perlu untuk menyelesaikan masalah ini.  Oleh karena itu, metode <code>add_dispatcher_if_not_exists</code> , yang memeriksa keberadaan dispatcher dan, jika tidak ada, diizinkan untuk membuat instance baru: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Dispatcher seperti itu disebut publik.  Dispatcher publik memiliki nama unik.  Dan menggunakan nama-nama ini, agen terikat ke operator: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); //         //    . auto coop = env.create_coop( "ping_pong", //     extra_dispatcher. so_5::disp::active_obj::create_disp_binder( "extra_dispatcher" ) ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Tetapi operator publik memiliki satu fitur yang tidak menyenangkan.  Mereka mulai bekerja segera setelah ditambahkan ke Lingkungan SObjectizer dan terus bekerja sampai Lingkungan SObjectizer menyelesaikan pekerjaannya. </p><br><p>  Lagi-lagi, seiring waktu, itu mulai mengganggu.  Itu perlu untuk memastikan bahwa dispatcher dapat ditambahkan sesuai kebutuhan dan dispatcher yang menjadi tidak perlu secara otomatis dihapus. </p><br><p>  Jadi ada dispatcher "pribadi".  Dispatcher ini tidak memiliki nama dan hidup selama ada referensi kepada mereka.  Dispatcher pribadi dapat dibuat kapan saja setelah memulai Lingkungan SObjectizer, mereka dihancurkan secara otomatis. </p><br><p>  Secara umum, dispatcher pribadi ternyata menjadi tautan yang sangat sukses dalam evolusi dispatcher, tetapi bekerja dengan mereka sangat berbeda dengan bekerja dengan dispatcher publik: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::create_private_disp(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp-&gt;binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Bahkan lebih banyak operator swasta dan publik berbeda dalam implementasi.  Oleh karena itu, agar tidak menduplikasi kode dan menulis secara terpisah dispatcher publik dan pribadi dari jenis yang sama, saya harus menggunakan konstruksi yang agak rumit dengan templat dan warisan. </p><br><p>  Akibatnya, saya bosan menemani semua varietas ini, dan di SObjectizer-5.6 hanya ada satu jenis dispatcher yang tersisa.  Bahkan, ini adalah analog dari operator swasta.  Tetapi hanya tanpa menyebutkan kata "pribadi" secara eksplisit.  Jadi sekarang fragmen yang ditunjukkan di atas akan ditulis sebagai: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::make_dispatcher(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp.binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><h2 id="ostalis-tolko-svobodnye-funkcii-send-send_delayed-i-send_periodic">  Hanya ada fungsi bebas kirim, send_delayed dan send_ periodic tersisa </h2><br><p>  Pengembangan API untuk mengirim pesan ke SObjectizer mungkin merupakan contoh paling mencolok tentang bagaimana SObjectizer telah berubah karena dukungan untuk C ++ 11 telah meningkat dalam kompiler yang tersedia untuk kami. </p><br><p>  Pertama, pesan dikirim seperti ini: </p><br><pre> <code class="cpp hljs">mbox-&gt;deliver_message(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...));</code> </pre> <br><p>  Atau, jika Anda mengikuti "rekomendasi dari peternak anjing terbaik" (c): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;my_message&gt; msg(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...)); mbox-&gt;deliver_message(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg));</code> </pre> <br><p>  Namun, kemudian kami tiba di kompiler pembuangan kami dengan dukungan untuk templat variadic dan fungsi pengiriman yang muncul.  Menjadi mungkin untuk menulis seperti ini: </p><br><pre> <code class="cpp hljs">send&lt;my_message&gt;(target, ...);</code> </pre> <br><p>  Benar, butuh lebih banyak waktu bagi seluruh keluarga untuk <code>send_to_agent</code> dari <code>send</code> sederhana, termasuk <code>send_to_agent</code> , <code>send_delayed_to_agent</code> , dll.  Dan kemudian, untuk membuat keluarga ini lebih sempit ke set <code>send</code> <code>send_delayed</code> , <code>send_delayed</code> dan <code>send_periodic</code> . </p><br><p>  Namun, terlepas dari kenyataan bahwa keluarga fungsi pengiriman sudah terbentuk sejak lama dan telah direkomendasikan untuk mengirim pesan selama beberapa tahun, metode lama seperti <code>deliver_message</code> , <code>schedule_timer</code> , dan <code>single_timer</code> masih tersedia bagi pengguna. </p><br><p>  Tetapi dalam versi 5.6.0, hanya fungsi <code>send</code> , <code>send_delayed</code> , dan <code>send_periodic</code> yang disimpan dalam API SObjectizer publik.  Semua yang lain dihapus sekaligus atau dipindahkan ke ruang nama SObjectizer internal. </p><br><p>  Jadi dalam SObjectizer-5.6, antarmuka untuk mengirim pesan akhirnya menjadi seperti semula jika kita memiliki kompiler dengan dukungan C ++ 11 yang normal sejak awal.  Nah, ditambah dengan itu, jika kita memiliki pengalaman menggunakan C ++ 11 yang sangat normal ini. </p><br><h2 id="edinyy-format-send_delayed-i-send_periodic">  Format tunggal send_delayed dan send_ periodic </h2><br><p>  Dengan fungsi <code>send_delayed</code> dan <code>send_periodic</code> dalam versi SObjectizer sebelumnya, ada insiden lain. </p><br><p>  Untuk menggunakan timer, Anda harus memiliki akses ke Lingkungan SObjectizer.  Di dalam agen ada tautan ke Lingkungan SObjectizer.  Dan di dalam mchain ada tautan seperti itu.  Tetapi di dalam kotak itu dia tidak ada di sana.  Oleh karena itu, jika pesan yang tertunda dikirim ke agen atau ke mchain, maka panggilan <code>send_delayed</code> seperti: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...);</code> </pre> <br><p>  Untuk mbox, kami harus mengambil tautan ke Lingkungan SObjectizer dari tempat lain: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_environment(), target_mbox, pause, ...);</code> </pre> <br><p>  Fitur <code>send_delayed</code> dan <code>send_periodic</code> ini adalah pecahan kecil.  Yang tidak terlalu mengganggu, tapi cukup mengganggu.  Dan semua karena pada awalnya kami tidak mulai menyimpan tautan ke Lingkungan SObjectizer di mbox-ahs. </p><br><p>  Pelanggaran kompatibilitas dengan versi sebelumnya adalah alasan yang baik untuk menyingkirkan sempalan ini. </p><br><p>  Sekarang Anda dapat mengetahui dari mbox untuk apa SObjectizer Environment diciptakan.  Dan ini memungkinkan untuk menggunakan <code>send_periodic</code> dan <code>send_periodic</code> <code>send_delayed</code> tunggal untuk semua jenis penerima pesan penghitung waktu: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...); send_delayed&lt;my_message&gt;(target_mbox, pause, ...);</code> </pre> <br><p>  Dalam arti harfiah, "agak sepele, tapi bagus." </p><br><h2 id="net-bolshe-ad-hoc-agentov">  Tidak ada lagi agen ad-hoc </h2><br><p>  Seperti kata pepatah, "Setiap kecelakaan memiliki nama depan, nama tengah dan nama belakang."  Dalam hal agen ad-hoc, ini adalah nama depan, nama tengah dan nama belakang saya :( </p><br><p>  Intinya adalah ini.  Ketika kami mulai berbicara tentang SObjectizer-5 di depan umum, kami mendengar banyak celaan untuk verbositas kode untuk contoh-contoh SObjectizer.  Dan secara pribadi, verbositas ini bagi saya merupakan masalah serius yang harus saya tangani dengan serius. </p><br><p>  Salah satu sumber verbositas adalah kebutuhan agen untuk mewarisi dari <code>agent_t</code> type base khusus.  Dan dari sini, tampaknya, tidak ada jalan keluar.  Atau tidak? </p><br><p>  Jadi ada agen ad-hoc, yaitu  agen, untuk penentuan yang tidak perlu untuk menulis kelas yang terpisah, itu hanya cukup untuk mengatur reaksi terhadap pesan dalam bentuk fungsi lambda.  Misalnya, contoh ping-pong klasik pada agen ad-hoc dapat ditulis seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pinger = coop-&gt;define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ponger = coop-&gt;define_agent(); pinger .on_start( [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ) .event&lt; msg_pong &gt;( pinger, [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ); ponger .event&lt; msg_ping &gt;( ponger, [pinger]{ so_5::send&lt; msg_pong &gt;( pinger ); } );</code> </pre> <br><p>  Yaitu  tidak ada kelas mereka sendiri.  Kami hanya memanggil <code>define_agent()</code> pada kerjasama dan mendapatkan beberapa jenis objek agen, yang Anda dapat berlangganan pesan yang masuk. </p><br><p>  Jadi di SObjectizer-5 ada pemisahan menjadi agen reguler dan ad-hoc. </p><br><p>  Yang tidak membawa bonus yang terlihat, hanya biaya tenaga kerja tambahan untuk menyertai pemisahan seperti itu.  Dan seiring waktu, menjadi jelas bahwa agen ad-hoc seperti koper tanpa pegangan: sulit untuk dibawa dan sangat disayangkan untuk pergi.  Tetapi ketika bekerja pada SObjectizer-5.6, diputuskan untuk berhenti. </p><br><p>  Pada saat yang sama, pelajaran lain juga dipelajari, mungkin bahkan lebih penting: dalam setiap diskusi publik tentang alat di Internet, sejumlah besar orang akan mengambil bagian yang acuh tak acuh terhadap apa alat itu, mengapa diperlukan, mengapa itu seperti yang seharusnya digunakan, dll.  Sangat penting bagi mereka untuk mengekspresikan pendapat mereka yang kuat.  Di segmen Internet berbahasa Rusia, selain itu, masih sangat penting untuk menyampaikan kepada pengembang alat bagaimana mereka bodoh dan tidak berpendidikan, dan seberapa banyak hasil pekerjaan mereka tidak diperlukan. </p><br><p>  Karena itu, Anda harus sangat berhati-hati dengan apa yang diperintahkan.  Dan Anda dapat mendengarkan (dan kemudian dengan hati-hati) hanya dengan apa yang dikatakan di sini dalam nada ini: "Saya mencoba melakukan ini pada instrumen Anda dan saya tidak suka berapa banyak kode yang didapat di sini."  Bahkan keinginan seperti itu harus diperlakukan dengan sangat hati-hati: "Saya akan mengambil pengembangan Anda jika akan lebih mudah di sini dan di sini." </p><br><p>  Sayangnya, keterampilan "menyaring" kata "simpatisan baik" di Internet sekitar lima tahun lalu jauh lebih sedikit daripada sekarang.  Oleh karena itu, percobaan khusus seperti agen ad-hoc di SObjectizer. </p><br><h2 id="sobjectizer-56-bolshe-ne-podderzhivaet-sinhronnogo-vzaimodeystviya-agentov">  SObjectizer-5.6 tidak lagi mendukung interaksi agen yang disinkronkan </h2><br><p>  Topik interaksi yang disinkronkan antara agen sangat tua dan sakit. </p><br><p>  Itu dimulai pada zaman SObjectizer-4.  Dan di SObjectizer-5 berlanjut.  Sejauh ini, akhirnya, yang disebut  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">permintaan layanan</a> .  Yang awalnya, memang, menakutkan seperti kematian.  Tapi kemudian saya berhasil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">memberi mereka tampilan yang lebih atau kurang layak</a> . </p><br><p>  Tapi ini ternyata menjadi kasus ketika pancake pertama keluar kental :( </p><br><p>  Di dalam SObjectizer, saya harus mengimplementasikan pengiriman dan pemrosesan pesan reguler dengan satu cara, dan pengiriman dan pemrosesan permintaan sinkron di lain.  Sangat menyedihkan bahwa fitur-fitur ini harus diperhitungkan, termasuk ketika mengimplementasikan mbox-s Anda sendiri. </p><br><p>  Dan setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsionalitas pesan amplop</a> ditambahkan ke SObjectizer, menjadi perlu untuk melihat lebih sering dan lebih teliti perbedaan antara pesan biasa dan permintaan sinkron. </p><br><p>  Secara umum, dengan permintaan sinkron selama pemeliharaan / pengembangan SObjectizer, ada terlalu banyak sakit kepala.  Sedemikian rupa sehingga pada awalnya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">keinginan konkret untuk menyingkirkan permintaan yang sangat sinkron ini</a> .  Dan kemudian keinginan ini terwujud. </p><br><p>  Maka pada SObjectizer-5.6, agen dapat berinteraksi kembali hanya melalui pesan asinkron. </p><br><p>  Dan karena kadang-kadang sesuatu seperti interaksi sinkron masih diperlukan, dukungan untuk jenis interaksi ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">telah diserahkan kepada proyek so5extra yang menyertainya</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    "-". using my_request_reply = so_5::extra::sync::request_reply_t&lt;my_request, my_reply&gt;; ... //  ,    . class request_handler final : public so_5::agent_t { ... //  .      . void on_request(typename my_request_reply::request_mhood_t cmd) { ... //  . //      cmd-&gt;request(). //   . cmd-&gt;make_reply(...); //      my_reply. } ... void so_define_agent() override { //       . so_subscribe_self().event(&amp;request_handler::on_request); } }; ... //     . so_5::mbox_t handler_mbox = ...; //        15s. //    ,    . my_reply reply = my_request_reply::ask_value(handler_mbox, 15s, ...); //       my_request.</span></span></code> </pre> <br><p>  Yaitu  Sekarang bekerja dengan permintaan sinkron secara fundamental berbeda karena penangan permintaan tidak mengembalikan nilai dari metode penangan, seperti sebelumnya.  Sebagai gantinya, metode <code>make_reply</code> . </p><br><p>  Implementasi baru baik dalam hal permintaan dan respons dikirim dalam SObjectizer seperti pesan asinkron biasa.  Sebenarnya, <code>make_reply</code> adalah implementasi <code>send</code> sedikit lebih spesifik. </p><br><p>  Dan, yang penting, implementasi baru memungkinkan kami untuk mendapatkan fungsionalitas yang sebelumnya tidak dapat dicapai: </p><br><ul><li>  permintaan sinkron (mis. <code>request_reply_t&lt;Request, Reply&gt;</code> objek) sekarang dapat disimpan dan / atau diteruskan ke penangan lain.  Apa yang memungkinkan untuk mengimplementasikan berbagai skema penyeimbangan beban; </li><li>  Anda dapat membuat respons terhadap permintaan datang dalam kotak mbox reguler dari agen yang mengajukan permintaan.  Dan agen pemula akan memproses respons dengan cara biasa, seperti pesan lainnya; </li><li>  Anda dapat mengirim beberapa permintaan ke penerima yang berbeda sekaligus, dan kemudian mem-parsing tanggapan dari mereka sesuai urutan penerimaannya: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> first_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;first_request, first_reply&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;second_request, second_reply&gt;; <span class="hljs-comment"><span class="hljs-comment">//         . auto reply_ch = create_mchain(env); //     . first_dialog::initiate_with_custom_reply_to( one_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); second_dialog::initiate_with_custom_reply_to( another_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); //    . receive(from(reply_ch).handle_n(2).empty_timeout(15s), [](typename first_dialog::reply_mhood_t cmd) {...}, [](typename second_dialog::reply_mhood_t cmd) {...});</span></span></code> </pre> <br><p>  Jadi, kita dapat mengatakan bahwa dengan interaksi sinkron di SObjectizer terjadi hal berikut: </p><br><ul><li>  untuk waktu yang lama dia pergi karena alasan ideologis; </li><li>  kemudian ditambahkan dan ternyata interaksi seperti itu bermanfaat; </li><li>  tetapi pengalaman menunjukkan bahwa implementasi pertama tidak terlalu berhasil; </li><li>  implementasi lama benar-benar dibuang, dan implementasi baru diusulkan sebagai imbalan. </li></ul><br><p>  Mereka melakukan kesalahan mereka sendiri, secara umum. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Artikel ini, secara singkat, berbicara tentang beberapa perubahan pada SObjectizer-5.6.0 dan alasan di balik perubahan ini. </p><br><p>  Daftar perubahan yang lebih lengkap dapat ditemukan di <a href="" rel="nofollow">sini</a> . </p><br><p>  Kesimpulannya, saya ingin menawarkan mereka yang belum mencoba SObjectizer, ambil dan coba.  Dan bagikan perasaan Anda kepada kami: apa yang Anda sukai, apa yang tidak Anda sukai, apa yang hilang. </p><br><p>  Kami dengan cermat mendengarkan semua komentar / saran yang membangun.  Selain itu, dalam beberapa tahun terakhir, hanya yang dibutuhkan seseorang yang termasuk dalam SObjectizer.  Jadi jika Anda tidak memberi tahu kami apa yang ingin Anda miliki di SObjectizer, maka ini tidak akan muncul.  Dan jika Anda memberi tahu saya, lalu siapa yang tahu ...;) </p><br><p>  Proyek ini sekarang hidup dan berkembang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">sini</a> .  Dan bagi mereka yang terbiasa menggunakan hanya GitHub, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">cermin GitHub</a> .  Cermin ini benar-benar baru, sehingga Anda dapat mengabaikan kekurangan bintang. </p><br><p>  PS.  Anda dapat mengikuti berita terkait SObjectizer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">di grup Google ini</a> .  Di sana Anda dapat mengangkat masalah yang terkait dengan SObjectizer. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453256/">https://habr.com/ru/post/id453256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453242/index.html">Taman bermain untuk acara musim panas</a></li>
<li><a href="../id453246/index.html">ERP - Sistem Degradasi Berkelanjutan</a></li>
<li><a href="../id453248/index.html">Artemis Lunar Mission - produksi elemen utama stasiun lunar Lunar Gateway diluncurkan</a></li>
<li><a href="../id453252/index.html">Bagaimana kami melakukan program klub Sportmaster</a></li>
<li><a href="../id453254/index.html">Tentang kode GOST, Belalang, SBox-nya, dan benih yang hilang</a></li>
<li><a href="../id453258/index.html">Membuat Pedal Reverb Menggunakan Keripik PT2399 (Bagian 1)</a></li>
<li><a href="../id453260/index.html">Fitur Pengaturan DPI</a></li>
<li><a href="../id453262/index.html">Di mana konstanta Anda disimpan pada mikrokontroler CortexM (menggunakan kompiler C ++ IAR sebagai contoh)</a></li>
<li><a href="../id453264/index.html">Virtuali-tee: "T-shirt medis" yang tidak menutupi tetapi mengekspos</a></li>
<li><a href="../id453272/index.html">Sponsor GitHub: cara baru untuk berkontribusi ke open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>