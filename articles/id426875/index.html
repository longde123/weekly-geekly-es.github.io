<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☪️ 🎩 🙇🏼 Arsitektur Shooter Meta Server Online Tacticool 🧞 ✍🏽 😀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pembicaraan lain dengan Pixonic DevGAMM Talks - kali ini dari kolega kami di PanzerDog. Insinyur Perangkat Lunak Pimpinan perusahaan Pavel Platto memb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur Shooter Meta Server Online Tacticool</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/426875/">  Pembicaraan lain dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pixonic DevGAMM Talks</a> - kali ini dari kolega kami di PanzerDog.  Insinyur Perangkat Lunak Pimpinan perusahaan Pavel Platto membongkar meta-server permainan dengan arsitektur berorientasi layanan, memberi tahu solusi dan teknologi mana yang dipilih, apa dan bagaimana mereka diskalakan, dan kesulitan apa yang harus mereka hadapi.  Teks laporan, slide dan tautan ke pidato lain dari mitap, seperti biasa, di bawah potongan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JcuOHUzXXHw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Pertama, saya ingin menunjukkan trailer kecil untuk game kami: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yIpGvbbMCn4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>  Laporan akan terdiri dari 3 bagian.  Pada bagian pertama saya akan berbicara tentang teknologi apa yang kami pilih dan mengapa, pada bagian kedua - bagaimana meta-server kami diatur, dan pada bagian ketiga saya akan berbicara tentang berbagai infrastruktur pendukung yang kami gunakan, dan bagaimana kami menerapkan pembaruan tanpa downtime. . <br><br><img src="https://habrastorage.org/webt/-s/fg/tz/-sfgtzhre4ij6b0n9-b_r0cako4.png"><br>  <i>Tumpukan teknologi</i> <br><br>  Server meta di-host di Amazon dan ditulis dalam Elixir.  Ini adalah bahasa pemrograman fungsional dengan model komputasi aktor.  Karena kita tidak memiliki Ops, programmer terlibat dalam operasi, dan sebagian besar infrastruktur digambarkan sebagai kode menggunakan HashiCorp Terraform. <br><br>  Tacticool saat ini dalam versi beta terbuka, server meta telah dalam pengembangan selama sedikit lebih dari setahun dan telah beroperasi selama hampir satu tahun.  Mari kita lihat bagaimana semuanya dimulai. <br><br><img src="https://habrastorage.org/webt/zs/a0/fa/zsa0favmdahf0gdsnt0-goxhrnq.png"><br><br>  Ketika saya bergabung dengan perusahaan, kami sudah memiliki fungsionalitas dasar yang diimplementasikan sebagai monolith pada campuran C / C ++ dan penyimpanan PostageSQL.  Implementasi ini memiliki masalah tertentu. <br><br>  Pertama, karena tingkat C yang rendah, ada beberapa bug yang sulit dipahami.  Misalnya, untuk beberapa pemain, perjodohan hang ketat karena kesalahan pemberian array yang salah sebelum digunakan kembali.  Tentu saja, menemukan hubungan antara kedua peristiwa ini cukup sulit.  Dan karena keadaan beberapa utas secara universal dimodifikasi dalam kode, kondisi Ras bukan tanpa. <br><br>  Pemrosesan paralel sejumlah besar tugas juga keluar dari pertanyaan, karena server dimulai pada awal sekitar 10 proses pekerja, yang diblokir oleh pertanyaan ke Amazon atau database.  Dan bahkan jika kita lupa tentang permintaan pemblokiran ini, layanan mulai runtuh pada beberapa koneksi yang tidak melakukan operasi apa pun kecuali ping.  Selain itu, layanan tidak dapat diskalakan secara horizontal. <br><br>  Setelah beberapa minggu menghabiskan waktu menemukan dan memperbaiki bug yang paling kritis, kami memutuskan bahwa lebih mudah untuk menulis ulang semuanya dari awal daripada mencoba untuk memperbaiki semua kekurangan dari solusi saat ini. <br><br>  Dan ketika Anda mulai dari awal, masuk akal untuk mencoba memilih bahasa yang akan membantu menghindari beberapa masalah sebelumnya.  Kami memiliki tiga kandidat: <br><br><ul><li>  C #; </li><li>  Pergi; </li><li>  Elixir. </li></ul><br><img src="https://habrastorage.org/webt/_f/vt/q5/_fvtq51jwvlo2uuquqy-4vwsnhw.png"><br><br>  C # ada di daftar "kenalan", sebagai  klien dan server gim ditulis dalam Unity, dan sebagian besar pengalaman dalam tim adalah dengan bahasa pemrograman ini.  Go dan Elixir dianggap karena ini adalah bahasa modern dan cukup populer yang dibuat untuk mengembangkan aplikasi server. <br><br>  Masalah dari iterasi sebelumnya membantu kami menentukan kriteria untuk mengevaluasi kandidat. <br><br>  Kriteria pertama adalah kenyamanan bekerja dengan operasi asinkron.  Di C #, pekerjaan mudah dengan operasi asinkron tidak muncul pada percobaan pertama.  Ini mengarah pada fakta bahwa kita memiliki "kebun binatang" solusi yang, menurut pendapat saya, masih berdiri sedikit di samping.  Di Go dan Elixir, masalah ini diperhitungkan saat merancang bahasa ini, mereka berdua menggunakan utas ringan (di Go mereka adalah goroutine, di Elixir mereka adalah proses).  Aliran ini memiliki overhead yang jauh lebih kecil daripada utas sistem, dan karena kita dapat membuatnya dalam puluhan dan ratusan ribu, kami tidak menyesal memblokirnya. <br><br>  Kriteria kedua adalah kemampuan untuk bekerja dengan proses kompetitif.  C # out of the box tidak menawarkan apa pun selain kolam utas dan memori bersama, akses yang harus dilindungi menggunakan berbagai primitif sinkronisasi.  Go memiliki model rawan kesalahan yang lebih sedikit dalam bentuk goroutine dan saluran.  Elixir, di sisi lain, menawarkan model aktor tanpa memori bersama dengan olahpesan.  Kurangnya memori bersama memungkinkan untuk menerapkan teknologi yang berguna untuk lingkungan eksekusi kompetitif dalam runtime, seperti multitasking take-out jujur ​​dan pengumpulan sampah tanpa gangguan di dunia. <br><br>  Kriteria ketiga adalah ketersediaan alat untuk bekerja dengan tipe data yang tidak dapat diubah.  Semua pengalaman pengembangan saya menunjukkan bahwa sebagian besar bug dikaitkan dengan perubahan data yang salah.  Solusi untuk ini sudah ada sejak lama - tipe data yang tidak dapat diubah.  Dalam C #, tipe data ini dapat dibuat, tetapi dengan biaya satu ton boilerplate.  Di Go, ini tidak mungkin sama sekali.  Dan di Elixir, semua tipe data tidak dapat diubah. <br><br>  Dan kriteria terakhir adalah jumlah spesialis.  Di sini hasilnya jelas.  Pada akhirnya, kami memilih Elixir. <br><br>  Dengan pilihan hosting, semuanya menjadi lebih sederhana.  Kami telah meng-host server game di Amazon GameLift, di samping itu, Amazon menawarkan sejumlah besar layanan yang akan memungkinkan kami untuk mengurangi waktu pengembangan. <br><br><img src="https://habrastorage.org/webt/f2/zm/jn/f2zmjnyjejb3ffw0vhs69hvqjoi.png"><br><br>  Kami sepenuhnya menyerah kepada cloud dan tidak menggunakan solusi pihak ketiga apa pun - database, antrian pesan - semua ini dikelola oleh Amazon untuk kami.  Menurut pendapat saya, ini adalah satu-satunya solusi untuk tim kecil yang ingin mengembangkan game online, dan bukan infrastruktur untuk itu. <br><br>  Kami menemukan pilihan teknologi, mari beralih ke cara kerja server meta. <br><br><img src="https://habrastorage.org/webt/q1/jy/m8/q1jym8itnftw6e3tqyvsbqh-uva.png"><br><br>  Secara umum: klien terhubung ke penyeimbang beban Amazon melalui koneksi soket web;  balancer mencerai-beraikan koneksi ini antara beberapa instance front-end, front-end mengirimkan permintaan klien ke backend.  Tetapi front-end dan back-end berkomunikasi secara tidak langsung, melalui antrian pesan.  Ada antrian terpisah untuk setiap jenis pesan, dan frontend, berdasarkan jenis pesan, menentukan tempat untuk menulisnya, dan backend mendengarkan antrian ini. <br><br>  Agar backend dapat mengirim respons ke permintaan kepada klien, atau semacam acara, setiap frontend memiliki antrian terpisah (khusus dialokasikan untuk itu).  Dan dalam setiap permintaan, backend menerima pengidentifikasi frontend untuk menentukan di mana antrian respons harus ditulis.  Jika dia perlu mengirim suatu acara, dia memanggil basis data untuk mencari tahu contoh antarmuka mana yang terhubung dengan klien. <br><br>  Dengan skema umum, mari beralih ke detail. <br><br><img src="https://habrastorage.org/webt/xe/rr/u-/xerru-5vn3tx-dwqbylflu18mrm.png"><br><br>  Pertama, saya akan berbicara tentang beberapa fitur interaksi client-server.  Kami menggunakan protokol biner kami karena sangat efisien dan memungkinkan untuk menghemat lalu lintas.  Kedua, untuk operasi apa pun dengan akun yang mengubahnya, server tidak mengirim perubahan ini kepada klien, tetapi versi lengkap (diperbarui) dari akun ini.  Ini sedikit kurang efisien, tetapi tidak memakan banyak ruang dan menyederhanakan kehidupan kita baik pada klien maupun di server.  Juga, frontend memastikan bahwa klien melakukan tidak lebih dari satu permintaan sekaligus.  Ini memungkinkan Anda untuk menangkap bug pada klien, misalnya, ketika ia beralih ke layar lain sebelum pemain melihat hasil operasi sebelumnya. <br><br>  Sekarang sedikit tentang bagaimana mengatur frontend. <br><br><img src="https://habrastorage.org/webt/te/-k/ff/te-kffgzvatzj_3tjwcus5lvpdk.png"><br><br>  Frontend pada dasarnya adalah server web yang mendengarkan koneksi soket web.  Untuk setiap sesi, dua proses dibuat.  Proses pertama melayani koneksi soket web itu sendiri, dan yang kedua adalah mesin negara yang menggambarkan keadaan klien saat ini.  Berdasarkan keadaan ini, itu menentukan validitas permintaan dari klien.  Misalnya, hampir semua permintaan tidak dapat diselesaikan sampai otorisasi selesai.  Karena tidak ada keadaan di frontend selain sesi ini, sangat mudah untuk menambahkan instance frontend baru, tetapi sedikit lebih sulit untuk menghapus yang lama.  Sebelum menghapus instalan, Anda harus membiarkan semua klien menyelesaikan permintaan mereka saat ini dan meminta mereka untuk terhubung kembali ke instance lain. <br><br>  Sekarang tentang bagaimana tampilan backend.  Saat ini, terdiri dari lima layanan. <br><br><img src="https://habrastorage.org/webt/qh/cj/x4/qhcjx4ckmzg8lcqpriouhi8rnee.png"><br><br>  Kesepakatan pertama dengan segala sesuatu yang berhubungan dengan akun - dari pembelian untuk mata uang dalam game hingga menyelesaikan pencarian.  Yang kedua bekerja dengan semua yang berhubungan dengan pertandingan - berinteraksi langsung dengan GameLift dan server game.  Layanan ketiga adalah belanja uang sungguhan.  Yang keempat dan kelima bertanggung jawab untuk interaksi sosial - satu untuk teman, yang lain untuk permainan pesta. <br><br>  Setiap layanan backend dari sudut pandang arsitektur terlihat sangat identik.  Mereka adalah satu set pipa, yang masing-masing memproses satu jenis pesan.  Pipa terdiri dari dua elemen: produsen dan konsumen. <br><br><img src="https://habrastorage.org/webt/ym/di/eh/ymdiehrcngon3im1my2d8nbbgsk.png"><br><br>  Satu-satunya tugas produsen adalah membaca pesan dari antrian.  Oleh karena itu, ini diterapkan sepenuhnya dalam bentuk umum dan untuk setiap saluran pipa kita hanya perlu menunjukkan berapa banyak produsen yang ada, dari mana antrean dibaca dan berapa banyak konsumen yang akan dilayani oleh masing-masing produsen.  Konsumen, di sisi lain, diimplementasikan secara terpisah untuk setiap pipa dan merupakan modul dengan satu-satunya fungsi wajib yang menerima satu pesan, melakukan semua pekerjaan yang diperlukan dan mengembalikan daftar pesan yang perlu dikirim ke layanan lain ke klien atau ke server game.  Produser juga menerapkan tekanan balik sehingga dengan peningkatan tajam dalam jumlah pesan tidak ada kelebihan, dan meminta pesan tidak lebih dari yang dimiliki konsumen bebas. <br><br>  Layanan Backend tidak mengandung keadaan apa pun, sehingga mudah bagi kami untuk menambah dan menghapus instance lama.  Satu-satunya hal yang harus dilakukan sebelum menghapus adalah meminta produsen untuk berhenti membaca pesan baru dan memberi konsumen sedikit waktu untuk menyelesaikan pemrosesan pesan aktif. <br><br>  Bagaimana interaksi dengan GameLift terjadi?  GameLift terdiri dari beberapa komponen.  Dari yang kami gunakan, ini adalah mak comblang FlexMatch, antrian penempatan yang menentukan wilayah tertentu untuk menyelenggarakan sesi permainan dengan para pemain ini, dan armadanya sendiri, yang terdiri dari server game. <br><br><img src="https://habrastorage.org/webt/c8/ge/5h/c8ge5huiowlmu5q7b9izd4sew4y.png"><br><br>  Bagaimana interaksi ini?  Meta berkomunikasi langsung hanya dengan mak comblang, mengirimkan permintaan untuk menemukan kecocokan.  Dan dia memberitahukan meta dari semua peristiwa selama perjodohan melalui antrian pesan yang sama.  Dan begitu dia menemukan kelompok pemain yang cocok untuk memulai pertandingan, dia mengirimkan permintaan ke antrian penempatan, yang pada gilirannya memilih server untuk mereka. <br><br>  Interaksi meta dengan server game sangat sederhana.  Server permainan membutuhkan informasi tentang akun, bot, dan peta, dan meta mengirimkan semua informasi ini ke antrian yang dibuat khusus untuk pertandingan ini dalam satu pesan. <br><br><img src="https://habrastorage.org/webt/vv/zo/y5/vvzoy5ycub5em-qiovlo911pg0k.png"><br><br>  Dan server permainan, setelah aktivasi, mulai mendengarkan antrian ini dan menerima semua data yang dibutuhkan.  Di akhir pertandingan, ia mengirimkan hasilnya ke antrian umum yang didengarkan oleh meta. <br><br>  Sekarang mari kita beralih ke infrastruktur tambahan yang kita gunakan. <br><br><img src="https://habrastorage.org/webt/l-/st/nu/l-stnuybsqrbk_be4fhlgrsdgpa.png"><br><br>  Menyebarkan layanan cukup sederhana.  Mereka semua bekerja dalam wadah buruh pelabuhan, dan kami menggunakan Amazon ECS untuk orkestrasi.  Ini jauh lebih sederhana daripada Kubernetes, tentu saja, kurang canggih, tetapi melakukan tugas yang kita butuhkan darinya.  Yaitu: layanan penskalaan dan rilis bergulir, ketika kita perlu mengisi semacam perbaikan bug. <br><br>  Dan layanan terakhir yang juga kami gunakan adalah AWS Fargate.  Ini menyelamatkan kita dari keharusan mengelola secara mandiri gugusan mesin tempat wadah buruh pelabuhan kami beroperasi. <br><br><img src="https://habrastorage.org/webt/q1/xl/8m/q1xl8mppdukmbjoezzm6pzlbl9k.png"><br><br>  Sebagai penyimpanan utama kami menggunakan DynamoDB.  Pertama-tama, kami memilihnya karena sangat mudah dioperasikan dan berskala.  Kami juga menggunakan Redis sebagai penyimpanan tambahan melalui layanan yang dikelola Amazon ElasiCache.  Kami menggunakannya untuk tugas pemeringkatan pemain global dan untuk caching data akun dasar dalam situasi di mana kami harus segera mengembalikan data pada ratusan akun game kepada klien (misalnya, dalam tabel penilaian yang sama atau dalam daftar teman). <br><br>  Untuk menyimpan konfigurasi, mekanisme meta-gameplay, deskripsi senjata, pahlawan, dll.  kami menggunakan file JSON yang kami lampirkan ke gambar layanan yang membutuhkannya.  Karena jauh lebih mudah bagi kami untuk meluncurkan versi baru layanan dengan data yang diperbarui (jika beberapa jenis bug terdeteksi) daripada membuat keputusan yang secara dinamis akan memperbarui data ini dari beberapa penyimpanan eksternal dalam runtime. <br><br>  Untuk logging dan pemantauan, kami menggunakan beberapa layanan. <br><br><img src="https://habrastorage.org/webt/lh/ub/3u/lhub3urulc1urcn8omuxprcn0rg.png"><br><br>  Mari kita mulai dengan CloudWatch.  Ini adalah layanan pemantauan di mana metrik dari semua layanan Amazon berduyun-duyun.  Karenanya, kami memutuskan untuk mengirim metrik dari server meta kami ke sana juga.  Dan untuk logging, kami menggunakan pendekatan umum baik pada klien dan pada server game dan pada server meta.  Kami mengirim semua log ke layanan Amazon Kinesis Firehose, yang pada gilirannya mentransfernya ke Elasticseach dan S3. <br><br>  Di Elasticseach, kami hanya menyimpan data yang relatif baru dan dengan bantuan Kibana kami mencari kesalahan, menyelesaikan beberapa tugas analisis game dan membangun dashboard operasional, misalnya, dengan jadwal CCU dan jumlah instalasi baru.  S3 berisi semua data historis dan kami menggunakannya melalui layanan Athena, yang menyediakan antarmuka SQL di atas data dalam S3. <br><br>  Sekarang sedikit tentang bagaimana kita menggunakan Terraform. <br><br><img src="https://habrastorage.org/webt/o8/jj/-q/o8jj-qfa1hsyq1qposebwbof4dc.png"><br><br>  Terraform adalah alat yang memungkinkan Anda untuk mendeskripsikan infrastruktur secara deklaratif dan, jika ada perubahan dalam deskripsi, secara otomatis menentukan tindakan yang perlu Anda ambil untuk membawa infrastruktur Anda ke tampilan yang diperbarui.  Dengan demikian, memiliki deskripsi tunggal, kami mendapatkan lingkungan yang hampir identik untuk pementasan dan produksi.  Juga, lingkungan ini sepenuhnya terisolasi, karena mereka ditempatkan di bawah akun yang berbeda.  Satu-satunya kekurangan Terraform bagi kami adalah dukungan GameLift yang tidak lengkap. <br><br>  Saya juga akan berbicara tentang bagaimana kami menerapkan pembaruan tanpa downtime. <br><br><img src="https://habrastorage.org/webt/_l/ge/va/_lgevakn50wndn5tvfipi1_ujam.png"><br><br>  Ketika kami merilis pembaruan, kami meningkatkan salinan dari sebagian besar sumber daya: layanan, antrian pesan, beberapa label dalam database.  Dan para pemain yang mengunduh versi baru gim ini akan terhubung ke kluster yang diperbarui ini.  Tetapi para pemain yang belum diperbarui dapat terus bermain untuk beberapa waktu di versi lama gim, terhubung ke kluster lama. <br><br>  Bagaimana kami menerapkannya.  Pertama, menggunakan mesin modul di Terraform.  Kami telah mengalokasikan modul tempat kami menggambarkan semua sumber daya versi.  Dan modul ini dapat diimpor beberapa kali, dengan parameter berbeda.  Dengan demikian, untuk setiap versi kami mengimpor modul ini, yang menunjukkan jumlah versi ini.  Juga, tidak adanya skema dalam DynamoDB membantu kami, yang memungkinkan untuk melakukan migrasi data tidak selama pembaruan, tetapi untuk menundanya untuk setiap akun sampai pemiliknya masuk ke versi baru permainan.  Dan di penyeimbang, kami cukup menunjukkan untuk setiap versi aturan sehingga ia tahu ke mana harus mengarahkan pemain dengan versi yang berbeda. <br><br>  Akhirnya, beberapa hal yang kami pelajari.  Pertama, konfigurasi seluruh infrastruktur harus otomatis.  Yaitu  kami mengatur beberapa hal dengan tangan kami untuk sementara waktu, tetapi cepat atau lambat kami membuat kesalahan dalam pengaturan, karena ada beberapa fakap. <br><br><img src="https://habrastorage.org/webt/5i/3n/7f/5i3n7fuurk18kiak_krk6jy8w8s.png"><br><br>  Dan hal terakhir - Anda harus memiliki replika atau salinan cadangan untuk setiap elemen infrastruktur Anda.  Dan jika Anda tidak melakukannya untuk sesuatu, maka hal khusus ini akan mengecewakan kami. <br><br><h3>  Pertanyaan dari audiens </h3><br>  <b>- Tapi apakah itu tidak mengganggu Anda bahwa autoscaling dapat bertahan terlalu banyak karena beberapa jenis kesalahan dan Anda akan mendapatkan banyak uang?</b> <br><br>  - Untuk penskalaan otomatis, batas masih ditentukan.  Kami tidak akan menetapkan batas terlalu besar agar tidak jatuh untuk banyak uang.  Ini adalah solusi + pemantauan utama.  Anda dapat mengatur peringatan jika ada sesuatu yang terlalu kuat. <br><br>  <b>- Berapa batasan Anda saat ini?</b>  <b>Relatif terhadap infrastruktur saat ini sebagai persentase.</b> <br><br>  - Sekarang kami memiliki fase uji beta terbuka di 11 negara, jadi bukan CCU yang besar untuk setidaknya entah bagaimana mengevaluasi.  Sekarang infrastrukturnya terlalu banyak untuk jumlah orang yang kita miliki. <br><br>  <b>- Dan belum ada batasan?</b> <br><br>  - Ya, hanya saja mereka 10-100 kali lebih banyak dari CCU kami.  Jangan berbuat lebih sedikit. <br><br>  <b>- Anda mengatakan bahwa Anda memiliki garis antara depan dan backend - ini sangat tidak biasa.</b>  <b>Kenapa tidak langsung?</b> <br><br>  - Kami ingin layanan berkewarganegaraan dengan mudah menerapkan mekanisme pencadangan, sehingga layanan tidak meminta lebih banyak pesan daripada yang dimiliki penangan gratis.  Juga, misalnya, ketika pawang gagal, antrian akan memberikan pesan yang sama ke pawang lain - mungkin itu akan berhasil. <br><br>  <b>- Apakah antriannya tetap ada?</b> <br><br>  - Ya.  Ini adalah layanan SQS Amazon. <br><br>  <b>- Mengenai antrian: berapa banyak saluran yang dibuat selama pertandingan?</b>  <b>Apakah Anda memiliki sejumlah saluran untuk setiap pertandingan?</b> <br><br>  - Ini menciptakan relatif sedikit.  Sebagian besar antrian, seperti antrian permintaan, bersifat statis.  Ada antrian permintaan untuk otorisasi, ada antrian untuk memulai pertandingan.  Dari antrian yang dibuat secara dinamis, kami hanya memiliki antrian untuk setiap frontend (itu menciptakan untuk pesan masuk untuk klien saat startup) dan untuk setiap kecocokan kami membuat satu antrian.  Dalam layanan ini, hampir tidak ada biaya, mereka memiliki permintaan yang sama.  Yaitu  setiap permintaan untuk SQS (buat antrian, baca sesuatu darinya) biayanya sama dan pada saat yang sama kami tidak menghapus antrian ini untuk disimpan, mereka akan dihapus nanti.  Dan fakta bahwa mereka ada tidak membebani kita. <br><br>  <b>- Dalam arsitektur ini, ini tidak akan menjadi batas untuk Anda?</b> <br><br>  - Tidak. <br><br><h3>  Lebih banyak pembicaraan dengan Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Konsul untuk meningkatkan layanan yang</a> sah (Ivan Bubnov, DevOps di BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CICD: penyebaran mulus ke sistem cluster terdistribusi tanpa downtime</a> (Egor Panov, administrator sistem Pixonic); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek menggunakan model aktor di platform backend dari game Quake Champions</a> (Roman Rogozin, pengembang backend Saber Interactive); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana ECS, Sistem Pekerjaan C # dan SRP mengubah pendekatan arsitektur</a> (Valentin Simonov, Insinyur Lapangan di Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip KISS dalam pengembangan</a> (Konstantin Gladyshev, Lead Game Programmer di 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Logika permainan umum pada klien dan server</a> (Anton Grigoriev, Wakil Petugas Teknis di Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mentimun di Awan: Menggunakan Skrip BDD untuk Pengujian Stres Produk</a> (Anton Kosyakin, Manajer Produk Teknis pada Platform ALICE). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426875/">https://habr.com/ru/post/id426875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426861/index.html">Perburuan baru untuk materi gelap terjadi di bawah gunung</a></li>
<li><a href="../id426863/index.html">Tersedia tentang angka empat dan manfaatnya</a></li>
<li><a href="../id426865/index.html">Desain dasbor yang jelas untuk sistem manajemen iklan yang canggih</a></li>
<li><a href="../id426869/index.html">Cara efektif melakukan konferensi video dengan pelanggan asing</a></li>
<li><a href="../id426873/index.html">Kontrol otomatis menggunakan akses jarak jauh ke registri Windows</a></li>
<li><a href="../id426879/index.html">Menyiapkan sistem pembatasan listrik untuk proyek yang menggunakan antarmuka kecepatan tinggi</a></li>
<li><a href="../id426881/index.html">Meluncurkan Program Pengembang Online</a></li>
<li><a href="../id426889/index.html">Cara berpartisipasi dalam kompetisi pembelajaran mesin. Kuliah di Yandex</a></li>
<li><a href="../id426891/index.html">Penambangan proses SAP atau cara memahami proses bisnis Anda</a></li>
<li><a href="../id426893/index.html">Cara meluncurkan aplikasi iOS melalui React Native</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>