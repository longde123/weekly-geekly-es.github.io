<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🦒 🧔🏻 MVCC di PostgreSQL-2. Fork, file, halaman 😂 👩🏼‍🎤 ☄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terakhir kali kami berbicara tentang konsistensi data, melihat perbedaan antara tingkat isolasi transaksi dari sudut pandang pengguna dan mencari tahu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC di PostgreSQL-2. Fork, file, halaman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/469087/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali</a> kami berbicara tentang konsistensi data, melihat perbedaan antara tingkat isolasi transaksi dari sudut pandang pengguna dan mencari tahu mengapa ini penting untuk diketahui.  Sekarang kita mulai mengeksplorasi bagaimana PostgreSQL mengimplementasikan isolasi snapshot dan konkurensi multiversion. <br><br>  Pada artikel ini, kita akan melihat bagaimana data secara fisik diletakkan dalam file dan halaman.  Ini membuat kita menjauh dari membahas isolasi, tetapi penyimpangan seperti itu diperlukan untuk memahami apa yang terjadi selanjutnya.  Kita perlu mencari tahu bagaimana penyimpanan data diatur pada tingkat rendah. <br><br><h1>  Hubungan </h1><br>  Jika Anda melihat di dalam tabel dan indeks, ternyata mereka disusun dengan cara yang sama.  Keduanya adalah objek basis data yang berisi beberapa data yang terdiri dari baris. <br><br>  Tidak ada keraguan bahwa tabel terdiri dari baris, tetapi ini kurang jelas untuk indeks.  Namun, bayangkan B-tree: terdiri dari node yang berisi nilai yang diindeks dan referensi ke node atau baris tabel lainnya.  Ini node yang dapat dianggap sebagai baris indeks, dan pada kenyataannya, mereka. <br><br>  Sebenarnya, beberapa objek diatur dengan cara yang sama: urutan (pada dasarnya tabel baris tunggal) dan tampilan terwujud (pada dasarnya, tabel yang mengingat kueri).  Dan ada juga tampilan reguler, yang tidak menyimpan data sendiri, tetapi dalam semua hal lain mirip dengan tabel. <br><br>  Semua objek di PostgreSQL ini disebut <em>relasi</em> kata umum.  Kata ini sangat tidak tepat karena merupakan istilah dari teori relasional.  Anda bisa menggambar paralel antara relasi dan tabel (tampilan), tetapi tentu saja tidak antara relasi dan indeks.  Tapi itu terjadi begitu saja: asal mula akademik PostgreSQL memanifestasikan dirinya.  Sepertinya saya bahwa itu adalah tabel dan pandangan yang disebut begitu pertama, dan sisanya membengkak seiring waktu. <br><a name="habracut"></a><br>  Untuk lebih sederhana, kita akan membahas lebih lanjut tabel dan indeks, tetapi <em>hubungan</em> lainnya diatur dengan cara yang sama persis. <br><br><h1>  Garpu dan file </h1><br>  Biasanya beberapa <em>fork</em> berhubungan dengan masing-masing relasi.  Garpu dapat memiliki beberapa jenis, dan masing-masingnya berisi jenis data tertentu. <br><br>  Jika ada garpu, itu pertama diwakili oleh satu-satunya <em>file</em> .  Nama file adalah pengenal angka, yang dapat ditambahkan dengan akhiran yang sesuai dengan nama fork. <br><br>  File secara bertahap tumbuh dan ketika ukurannya mencapai 1 GB, file baru dari garpu yang sama dibuat (file seperti ini kadang-kadang disebut <em>segmen</em> ).  Nomor urut segmen ditambahkan pada akhir nama file. <br><br>  Batasan ukuran file 1 GB muncul secara historis untuk mendukung sistem file yang berbeda, beberapa di antaranya tidak dapat menangani file dengan ukuran lebih besar.  Anda dapat mengubah batasan ini ketika membangun PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Jadi, beberapa file pada disk dapat berhubungan dengan satu relasi.  Misalnya, untuk meja kecil akan ada tiga dari mereka. <br><br>  Semua file objek milik satu tablespace dan satu database akan disimpan dalam satu direktori.  Anda perlu mengingat ini karena sistem file biasanya gagal berfungsi dengan baik dengan sejumlah besar file dalam direktori. <br><br>  Perhatikan di sini bahwa file, pada gilirannya, dibagi menjadi beberapa <em>halaman</em> (atau <em>blok</em> ), biasanya sebesar 8 KB.  Kami akan membahas struktur internal halaman sedikit lebih jauh. <br><br><img src="https://habrastorage.org/webt/10/ze/w6/10zew6_pruaxe8amjtx7_6x70tk.png"><br><br>  Sekarang mari kita lihat jenis garpu. <br><br>  <strong>Garpu utama</strong> adalah data itu sendiri: baris tabel dan indeks yang paling.  Garpu utama tersedia untuk semua hubungan (kecuali tampilan yang tidak mengandung data). <br><br>  Nama-nama file dari garpu utama terdiri dari satu-satunya pengidentifikasi numerik.  Misalnya, ini adalah jalur ke tabel yang kami buat terakhir kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  Dari mana pengidentifikasi ini muncul?  Direktori "base" berhubungan dengan tablespace "pg_default".  Subdirektori berikutnya, yang terkait dengan basis data, adalah lokasi file yang menarik: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Path relatif, ditentukan mulai dari direktori data (PGDATA).  Selain itu, hampir semua jalur di PostgreSQL ditentukan mulai dari PGDATA.  Berkat ini, Anda dapat dengan aman memindahkan PGDATA ke lokasi yang berbeda - tidak ada yang membatasi (kecuali untuk itu mungkin diperlukan untuk mengatur jalur ke perpustakaan di LD_LIBRARY_PATH). <br><br>  Selanjutnya, melihat ke sistem file: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  <strong>Garpu inisialisasi</strong> hanya tersedia untuk tabel yang tidak di-log (dibuat dengan UNLOGGED yang ditentukan) dan indeksnya.  Objek seperti ini tidak jauh berbeda dari objek biasa kecuali bahwa operasi dengan mereka tidak dicatat dalam log tulis-depan (WAL).  Karena itu, lebih cepat untuk bekerja dengan mereka, tetapi tidak mungkin untuk memulihkan data dalam keadaan konsisten jika terjadi kegagalan.  Oleh karena itu, selama pemulihan PostgreSQL hanya menghapus semua garpu dari objek tersebut dan menulis garpu inisialisasi sebagai pengganti garpu utama.  Ini menghasilkan objek kosong.  Kami akan membahas login secara detail, tetapi di seri lain. <br><br>  Tabel "akun" dicatat, dan karena itu, tidak memiliki garpu inisialisasi.  Tetapi untuk bereksperimen, kami dapat mematikan pencatatan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  Contoh tersebut mengklarifikasi bahwa kemungkinan untuk menghidupkan dan mematikan logging dengan cepat dikaitkan dengan menulis ulang data ke file dengan nama yang berbeda. <br><br>  Garpu inisialisasi memiliki nama yang sama dengan garpu utama, tetapi dengan akhiran "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  <strong>Peta ruang bebas</strong> adalah garpu yang melacak ketersediaan ruang kosong di dalam halaman.  Ruang ini terus berubah: berkurang ketika versi baris baru ditambahkan dan meningkat selama menyedot debu.  Peta ruang bebas digunakan selama penyisipan versi baris baru untuk dengan cepat menemukan halaman yang cocok, di mana data yang akan ditambahkan akan cocok. <br><br>  Nama peta ruang bebas memiliki akhiran "_fsm".  Tetapi file ini muncul tidak dengan segera, tetapi hanya jika diperlukan.  Cara termudah untuk mencapai ini adalah dengan menyedot debu (kami akan menjelaskan mengapa ketika saatnya tiba): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  <strong>Peta visibilitas</strong> adalah garpu di mana halaman yang hanya berisi versi baris terbaru ditandai dengan satu bit.  Secara kasar, ini berarti bahwa ketika suatu transaksi mencoba membaca suatu baris dari halaman seperti itu, baris tersebut dapat ditampilkan tanpa memeriksa visibilitasnya.  Dalam artikel selanjutnya, kita akan membahas secara rinci bagaimana ini terjadi. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Halaman </h1><br>  Seperti yang telah disebutkan, file secara logis dibagi menjadi beberapa halaman. <br><br>  Halaman biasanya memiliki ukuran 8 KB.  Ukurannya dapat diubah dalam batas-batas tertentu (16 KB atau 32 KB), tetapi hanya selama build ( <code>./configure --with-blocksize</code> ).  Sebuah instance yang dibangun dan dijalankan hanya dapat bekerja dengan halaman dengan ukuran yang sama. <br><br>  Terlepas dari garpu tempat file berada, server menggunakannya dengan cara yang sangat mirip.  Halaman pertama kali dibaca ke dalam cache buffer, tempat proses dapat membaca dan mengubahnya;  kemudian ketika kebutuhan muncul, mereka diusir kembali ke disk. <br><br>  Setiap halaman memiliki partisi internal dan secara umum berisi partisi berikut: <br><br><pre>        0 + ----------------------------------- +
           |  tajuk |
       24 + ----------------------------------- +
           |  array pointer ke versi baris |
    lebih rendah + ----------------------------------- +
           |  ruang kosong |
    atas + ----------------------------------- +
           |  versi baris |
  spesial + ----------------------------------- +
           |  ruang khusus |
 pagesize + ----------------------------------- +
</pre><br>  Anda dapat dengan mudah mengetahui ukuran partisi ini menggunakan halaman ekstensi "riset", menginspeksi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Di sini kita melihat <strong>header</strong> halaman pertama (nol) dari tabel.  Selain ukuran area lain, tajuk memiliki informasi berbeda tentang halaman, yang belum kami minati. <br><br>  Di bagian bawah halaman ada <strong>ruang khusus</strong> , yang kosong dalam hal ini.  Ini hanya digunakan untuk indeks, dan bahkan tidak untuk semuanya.  "Di bagian bawah" di sini mencerminkan apa yang ada dalam gambar;  mungkin lebih akurat untuk mengatakan "di alamat tinggi". <br><br>  Setelah ruang khusus, <strong>versi baris</strong> ditemukan, yaitu data yang kami simpan di dalam tabel plus beberapa informasi internal. <br><br>  Di bagian atas halaman, tepat setelah header, ada daftar isi: <strong>array pointer</strong> ke versi baris yang tersedia di halaman. <br><br>  <strong>Ruang kosong</strong> dapat dibiarkan antara versi baris dan pointer (ruang bebas ini disimpan dalam peta ruang bebas).  Perhatikan bahwa tidak ada fragmentasi memori di dalam halaman - semua ruang kosong diwakili oleh satu area yang berdekatan. <br><br><h2>  Pointer </h2><br>  Mengapa pointer ke versi baris dibutuhkan?  Masalahnya adalah bahwa indeks harus entah bagaimana mereferensikan versi baris dalam tabel.  Jelas bahwa referensi harus berisi nomor file, jumlah halaman dalam file dan beberapa indikasi versi baris.  Kita bisa menggunakan offset dari awal halaman sebagai indikator, tetapi tidak nyaman.  Kami tidak akan dapat memindahkan versi baris di dalam halaman karena akan merusak referensi yang tersedia.  Dan ini akan mengakibatkan fragmentasi ruang di dalam halaman dan konsekuensi merepotkan lainnya.  Oleh karena itu, indeks referensi nomor penunjuk, dan penunjuk referensi lokasi saat ini dari versi baris di halaman.  Dan ini adalah penanganan tidak langsung. <br><br>  Setiap pointer menempati tepat empat byte dan mengandung: <br><br><ul><li>  referensi ke versi baris </li><li>  ukuran versi baris ini </li><li>  beberapa byte untuk menentukan status versi baris </li></ul><br><h2>  Format data </h2><br>  Format data pada disk persis sama dengan representasi data dalam RAM.  Halaman dibaca ke dalam cache buffer "apa adanya", tanpa konversi apa pun.  Oleh karena itu, file data dari satu platform ternyata tidak kompatibel dengan platform lain. <br><br>  Misalnya, dalam arsitektur X86, urutan byte dari paling signifikan ke byte paling signifikan (little-endian), z / Arsitektur menggunakan urutan terbalik (big-endian), dan dalam ARM urutan dapat ditukar. <br><br>  Banyak arsitektur menyediakan penyelarasan data pada batas-batas kata-kata mesin.  Misalnya, pada sistem x86 32-bit, angka integer (tipe "integer", yang menempati 4 byte) akan disejajarkan pada batas kata 4-byte, sama seperti angka presisi ganda (ketik "presisi ganda" , yang menempati 8 byte).  Dan pada sistem 64-bit, angka presisi ganda akan disejajarkan pada batas kata 8-byte.  Ini adalah satu lagi alasan ketidakcocokan. <br><br>  Karena penyelarasan, ukuran baris tabel tergantung pada urutan bidang.  Biasanya efek ini tidak terlalu terlihat, tetapi kadang-kadang, ini dapat menghasilkan pertumbuhan ukuran yang signifikan.  Misalnya, jika bidang tipe "char (1)" dan "integer" disisipkan, biasanya 3 byte di antaranya akan sia-sia.  Untuk detail lebih lanjut tentang ini, Anda dapat melihat presentasi Nikolay Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tuple internals</a> ". <br><br><h1>  Versi baris dan TOAST </h1><br>  Kami akan membahas detail struktur internal versi baris lain kali.  Pada titik ini, penting bagi kita untuk mengetahui bahwa setiap versi harus sepenuhnya sesuai dengan satu halaman: PostgreSQL tidak memiliki cara untuk "memperluas" baris ke halaman berikutnya.  Teknik Oributized Attributes Storage (TOAST) digunakan sebagai gantinya.  Nama itu sendiri mengisyaratkan bahwa satu baris dapat diiris menjadi roti panggang. <br><br>  Bercanda terpisah, TOAST menyiratkan beberapa strategi.  Kita bisa mengirimkan nilai atribut panjang ke tabel internal yang terpisah setelah memecahnya menjadi potongan roti kecil.  Pilihan lain adalah untuk mengompres nilai sehingga versi baris tidak cocok dengan halaman biasa.  Dan kita bisa melakukan keduanya: kompres pertama dan kemudian putus dan mengirimkan. <br><br>  Untuk setiap tabel utama, tabel TOAST terpisah dapat dibuat jika diperlukan, satu untuk semua atribut (bersama dengan indeks di atasnya).  Ketersediaan atribut yang berpotensi panjang menentukan kebutuhan ini.  Misalnya, jika tabel memiliki kolom tipe "numerik" atau "teks", tabel TOAST akan segera dibuat bahkan jika nilai yang panjang tidak akan digunakan. <br><br>  Karena tabel TOAST pada dasarnya adalah tabel biasa, ia memiliki set garpu yang sama.  Dan ini menggandakan jumlah file yang sesuai dengan tabel. <br><br>  Strategi awal ditentukan oleh tipe data kolom.  Anda dapat melihatnya menggunakan perintah <code>\d+</code> di psql, tetapi karena itu juga menampilkan banyak informasi lain, kami akan meminta katalog sistem: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Nama-nama strategi berarti: <br><br><ul><li>  plain - TOAST tidak digunakan (digunakan untuk tipe data yang dikenal pendek, seperti "integer"). </li><li>  diperpanjang - baik kompresi dan penyimpanan dalam tabel TOAST terpisah diizinkan </li><li>  nilai eksternal - panjang disimpan dalam tabel TOAST tanpa kompresi. </li><li>  nilai - nilai main - long pertama kali dikompresi dan hanya masuk ke tabel TOAST jika kompresi tidak membantu. </li></ul><br>  Secara umum, algoritma adalah sebagai berikut.  PostgreSQL bertujuan untuk memiliki setidaknya empat baris yang cocok untuk satu halaman.  Oleh karena itu, jika ukuran baris melebihi satu halaman, header dipertimbangkan (2040 bytes untuk halaman 8K biasa), TOAST harus diterapkan ke bagian nilai.  Kami mengikuti pesanan yang dijelaskan di bawah ini dan berhenti segera setelah baris tidak lagi melebihi ambang batas: <br><br><ol><li>  Pertama kita membahas atribut dengan strategi "eksternal" dan "diperpanjang" dari atribut terpanjang ke yang terpendek.  Atribut “Extended” dikompresi (jika itu efektif) dan jika nilainya sendiri melebihi satu dari halaman, ia langsung masuk ke tabel TOAST.  Atribut "Eksternal" diproses dengan cara yang sama, tetapi tidak dikompresi. </li><li>  Jika setelah lulus pertama, versi baris belum sesuai dengan halaman, kami mengirimkan atribut yang tersisa dengan strategi "eksternal" dan "diperpanjang" ke tabel TOAST. </li><li>  Jika ini juga tidak membantu, kami mencoba mengompresi atribut dengan strategi "utama", tetapi membiarkannya di halaman tabel. </li><li>  Dan hanya jika setelah itu, barisnya tidak cukup pendek, atribut "utama" masuk ke tabel TOAST. </li></ol><br>  Terkadang mungkin berguna untuk mengubah strategi untuk kolom tertentu.  Misalnya, jika diketahui sebelumnya bahwa data dalam kolom tidak dapat dikompresi, kita dapat mengatur strategi "eksternal" untuknya, yang memungkinkan kita menghemat waktu dengan menghindari upaya kompresi yang tidak berguna.  Ini dilakukan sebagai berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  Menjalankan kembali kueri, kita mendapatkan: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Tabel dan indeks TOAST terletak di skema pg_toast terpisah dan, oleh karena itu, biasanya tidak terlihat.  Untuk tabel sementara, skema "pg_toast_temp_ <em>N</em> " digunakan mirip dengan "pg_temp_ <em>N</em> " yang biasa. <br><br>  Tentu saja, jika Anda suka tidak seorang pun akan menghalangi Anda memata-matai mekanisme internal proses.  Katakanlah, dalam tabel "akun" ada tiga atribut yang berpotensi panjang, dan oleh karena itu, harus ada tabel TOAST.  Ini dia: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Masuk akal bahwa strategi "biasa" diterapkan pada roti panggang yang digunakan untuk memotong baris: tidak ada TOAST tingkat kedua. <br><br>  PostgreSQL menyembunyikan indeks dengan lebih baik, tetapi tidak sulit untuk menemukan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  Kolom "klien" menggunakan strategi "extended": nilainya akan dikompresi.  Mari kita periksa: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Tidak ada dalam tabel TOAST: karakter berulang dikompresi dengan baik dan setelah kompresi nilainya cocok dengan halaman tabel biasa. <br><br>  Dan sekarang biarkan nama klien terdiri dari karakter acak: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Urutan seperti itu tidak dapat dikompresi, dan masuk ke tabel TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Kita dapat melihat bahwa data dipecah menjadi potongan 2000-byte. <br><br>  Ketika nilai panjang diakses, PostgreSQL secara otomatis dan transparan untuk aplikasi mengembalikan nilai asli dan mengembalikannya ke klien. <br><br>  Tentu saja, cukup padat sumber daya untuk memampatkan dan memecah dan kemudian mengembalikan.  Oleh karena itu, untuk menyimpan data masif di PostgreSQL bukan ide terbaik, terutama jika mereka sering digunakan dan penggunaannya tidak memerlukan logika transaksional (misalnya: pemindaian dokumen akuntansi asli).  Alternatif yang lebih menguntungkan adalah menyimpan data tersebut pada sistem file dengan nama file yang disimpan dalam DBMS. <br><br>  Tabel TOAST hanya digunakan untuk mengakses nilai yang panjang.  Selain itu, konkurensi mutiversinya sendiri didukung untuk tabel TOAST: kecuali jika pembaruan data menyentuh nilai lama, versi baris baru akan merujuk nilai yang sama di tabel TOAST, dan ini menghemat ruang. <br><br>  Perhatikan bahwa TOAST hanya berfungsi untuk tabel, tetapi tidak untuk indeks.  Ini memberlakukan batasan pada ukuran kunci yang akan diindeks. <br><blockquote>  Untuk detail lebih lanjut dari struktur data internal, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469087/">https://habr.com/ru/post/id469087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469073/index.html">Derivatif Terpisah atau Ringkasan Cara Menjumlahkan Seri</a></li>
<li><a href="../id469075/index.html">DLR Grokay</a></li>
<li><a href="../id469077/index.html">Kursus Python Baru Microsoft [dalam bahasa Inggris]</a></li>
<li><a href="../id469079/index.html">Python dalam Visual Studio Code: September Extension Extension</a></li>
<li><a href="../id469085/index.html">Kami mengeluarkan perangkat lunak dari mikrokontroler yang dilindungi kata sandi Renesas M16C</a></li>
<li><a href="../id469093/index.html">Perbandingan perpustakaan CLI yang kurang populer dan tidak terlalu: cliff, plac, plumbum, dan lain-lain (bagian 2)</a></li>
<li><a href="../id469095/index.html">ML.NET dan Pembaruan Model Builder Dirilis: Apa yang Baru</a></li>
<li><a href="../id469097/index.html">Server web CentOS 8 dengan php7, node.js dan redis</a></li>
<li><a href="../id469099/index.html">Menguji tugas saat wawancara dengan pengembang - apakah masuk akal?</a></li>
<li><a href="../id469101/index.html">Belajar Bahasa Inggris: cara belajar berbicara sebagai penutur asli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>