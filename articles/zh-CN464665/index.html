<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛺️ ☀️ 💺 在SQL Server中分区 💩 🐿️ 🔐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SQL Server中的分区（“分区”）看似简单（“在那里-您按文件组分布表和索引，并从管理和性能中获利”）是一个相当广泛的主题。 下面，我将尝试描述如何创建和应用函数和分区方案以及您可能遇到的问题。 除了一件事-切换部分，当您立即从表中删除一个巨大的数据集时，我将不谈这些好处。反之亦然-立即将一个...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在SQL Server中分区</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464665/"> SQL Server中的分区（“分区”）看似简单（“在那里-您按文件组分布表和索引，并从管理和性能中获利”）是一个相当广泛的主题。 下面，我将尝试描述如何创建和应用函数和分区方案以及您可能遇到的问题。 除了一件事-切换部分，当您立即从表中删除一个巨大的数据集时，我将不谈这些好处。反之亦然-立即将一个同样巨大的数据集加载到表中。 <br><a name="habracut"></a><br> 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">msdn</a>所言：“分区表和索引的数据分为多个块，这些块可以分布在数据库中的多个文件组中。 数据是水平分区的，因此行组被映射到各个部分。 相同索引或表的所有部分必须位于同一数据库中。 在对数据执行查询或更新时，表或索引被视为单个逻辑实体。” <br><br> 此处还列出了主要优点： <br><br><ul><li> 快速高效地传输和访问数据子集，同时保持数据集的完整性 </li><li> 一个或多个部分可以更快地执行维护操作； </li><li> 您可以提高查询执行的速度，具体取决于硬件配置中经常执行的查询。 </li></ul><br> 换句话说，分区用于水平缩放。 表/索引由不同的文件组“散布”，这些文件组可以位于不同的物理磁盘上，这显着增加了管理的便利性，并且从理论上讲，提高了对该数据的查询性能-您可以只读取所需的部分（较少的数据），或者读取所有内容并行（设备不同，读取速度快）。 实际上，一切都有些复杂，并且仅当查询使用分区依据的字段进行选择时，提高对分区表的查询的性能才能起作用。 如果您还没有分区表的经验，请记住，查询的性能可能不会改变，但是在对表进行分区后，性能可能会下降。 <br><br> 让我们谈谈您肯定会与分区相处的绝对优势（但是您还需要使用分区）-这肯定会提高管理数据库的便利性。 例如，您有一个包含十亿条记录的表，其中有9亿条来自旧（“封闭”）期间，并且是只读的。 在分区的帮助下，您可以将旧数据传输到一个单独的只读文件组中，进行备份，而不再将其拖到您的所有日常备份中-创建备份副本的速度将增加，大小将减小。 您可以不在整个表上而是在选定的部分上重建索引。 此外，数据库的可用性正在增长-如果包含具有该部分的文件组的设备之一发生故障，则其他设备仍然可用。 <br><br> 为了获得剩余的好处（立即切换部分；提高生产率）-您需要专门设计数据结构并编写查询。 <br> 我想我已经足够使读者难堪了，现在我可以继续练习。 <br><br> 首先，创建一个包含4个文件组的数据库，我们将在其中进行实验： <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> primary (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestPrimary'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestPrimary.mdf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg1] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG1'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG1.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg2] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG2'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG2.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) , filegroup [fg3] (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> =<span class="hljs-string"><span class="hljs-string">'PTestFG3'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTestFG3.ndf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">8092</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB) <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">'PTest_Log'</span></span>, filename = <span class="hljs-string"><span class="hljs-string">'E:\data\partitionTest_log.ldf'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = <span class="hljs-number"><span class="hljs-number">2048</span></span>KB, filegrowth = <span class="hljs-number"><span class="hljs-number">1024</span></span>KB); go <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> [PartitionTest] <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">recovery</span></span> simple; go <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> partitionTest;</code> </pre> <br> 创建一个我们将折磨的桌子。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ptest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>));</code> </pre> <br> 并填写一年的数据： <br><pre> <code class="sql hljs">;<span class="hljs-keyword"><span class="hljs-keyword">with</span></span> nums <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> all <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ptest(dt, dummy_int, dummy_char) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dateadd</span></span>(hh, rn<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">'20180101'</span></span>) dt, rn dummy_int, <span class="hljs-string"><span class="hljs-string">'dummy char column #'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cast</span></span>(rn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> row_number() <span class="hljs-keyword"><span class="hljs-keyword">over</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>))) rn <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> nums n1, nums n2, nums n3, nums n4 )t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> rn &lt; <span class="hljs-number"><span class="hljs-number">8761</span></span></code> </pre> <br> 现在pTest表包含2018年每小时的一条记录。 <br><br> 现在，您需要创建一个分区函数，该函数描述将数据划分为多个部分的边界条件。  SQL Server仅支持范围分区。 <br><br> 我们将根据dt（日期时间）列对表进行分区，以便每个部分包含4个月的数据（实际上，我在这里搞砸了-实际上，第一部分将包含3的数据，第二部分包含4的数据，第三部分包含5个月的数据，但是出于演示目的-这不是问题） <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br> 一切似乎都很正常，但是我在这里故意犯了一个“错误”。 如果查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">msdn</a>中的语法，您将看到在创建过程中可以指定指定边框所属的部分-左侧或右侧。 默认情况下，由于某种未知的原因，指定的边框指的是“左侧”部分，因此对于我来说，创建分区函数如下是正确的： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br> 当我实际执行时： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br> 但是，我们稍后将返回到此并重新创建分区功能。 同时，我们继续进行所发生的事情，以了解所发生的事情以及为什么它对我们不是很好。 <br><br> 创建分区功能后，需要创建一个分区方案。 它清楚地将节绑定到文件组： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> pfTest <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ([FG1], [FG2], [FG3])</code> </pre> <br> 如您所见，我们的所有三个部分都位于不同的文件组中。 现在是时候对我们的表进行分区了。 为此，我们需要创建一个聚集索引，而不是指定应该位于其中的文件组，而是指定分区方案： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_pTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt)</code> </pre> <br> 在这里，我在当前方案中也犯了一个“错误”，我很可能在此列上创建了唯一的聚集索引，但是，当创建唯一索引时，用于分区的列应包括在索引中。 我想展示一下这种配置可以遇到的情况。 <br><br> 现在，让我们看看在当前配置中得到了什么（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请求从此处获取</a> ）： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sc.name + N<span class="hljs-string"><span class="hljs-string">'.'</span></span> + so.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Schema.Table], si.index_id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>], si.type_desc <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Structure], si.name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>], stat.row_count <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Rows</span></span>], stat.in_row_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">In</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> GB], stat.lob_reserved_page_count * <span class="hljs-number"><span class="hljs-number">8.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span>/<span class="hljs-number"><span class="hljs-number">1024.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">LOB</span></span> GB], p.partition_number <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">Partition</span></span> <span class="hljs-comment"><span class="hljs-comment">#], pf.name as [Partition Function], CASE pf.boundary_value_on_right WHEN 1 then 'Right / Lower' ELSE 'Left / Upper' END as [Boundary Type], prv.value as [Boundary Point], fg.name as [Filegroup] FROM sys.partition_functions AS pf JOIN sys.partition_schemes as ps on ps.function_id=pf.function_id JOIN sys.indexes as si on si.data_space_id=ps.data_space_id JOIN sys.objects as so on si.object_id = so.object_id JOIN sys.schemas as sc on so.schema_id = sc.schema_id JOIN sys.partitions as p on si.object_id=p.object_id and si.index_id=p.index_id LEFT JOIN sys.partition_range_values as prv on prv.function_id=pf.function_id and p.partition_number= CASE pf.boundary_value_on_right WHEN 1 THEN prv.boundary_id + 1 ELSE prv.boundary_id END /* For left-based functions, partition_number = boundary_id, for right-based functions we need to add 1 */ JOIN sys.dm_db_partition_stats as stat on stat.object_id=p.object_id and stat.index_id=p.index_id and stat.index_id=p.index_id and stat.partition_id=p.partition_id and stat.partition_number=p.partition_number JOIN sys.allocation_units as au on au.container_id = p.hobt_id and au.type_desc ='IN_ROW_DATA' /* Avoiding double rows for columnstore indexes. */ /* We can pick up LOB page count from partition_stats */ JOIN sys.filegroups as fg on fg.data_space_id = au.data_space_id ORDER BY [Schema.Table], [Index ID], [Partition Function], [Partition #];</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/72/qu/op/72quopaqu1glcalpur92qrwy6eo.png"><br><br> 因此，我们得到了三个不太成功的部分-第一个部分从时间开始存储数据，直到04/01/2018 00:00:00，包括第二个-从01/01/2018 00:00:01到08/01/2018 00:00:00，包括从08/01/2018 00:00:01到世界末日的第三个（我故意错过了几分之一秒，因为我不记得SQL Server将这些分数写到哪个等级，但含义已正确传输）。 <br> 现在，在dummy_int字段上创建一个非聚集索引，根据相同的分区方案“对齐”。 <br><br><div class="spoiler">  <b class="spoiler_title">为什么我们需要一个统一的索引？</b> <div class="spoiler_text"> 我们需要一个对齐的索引，以便我们可以执行切换部分（切换）的操作-这是其中的一项操作，而这些操作通常会困扰于分区。 如果表中至少有一个未对齐索引，则无法切换该部分 <br></div></div><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> nonclustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest(dummy_int) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> psTest(dt);</code> </pre> <br> 让我们看看为什么我说过在实现分段后您的查询可能会变慢。 运行请求： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 让我们看看执行统计信息： <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 3, logical reads 6, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br> 以及实施计划： <br><br><img src="https://habrastorage.org/webt/-i/ey/ay/-ieyay17s-rifng9eaij7bobfes.png"><br><br> 由于索引是按节“对齐”的，因此有条件地，每个节都有自己的索引，该索引与其他节的索引“不相连”。 我们没有在分区索引的字段上强加条件，因此SQL Server被迫在每个部分中执行索引查找，实际上是3个索引查找而不是一个。 <br><br> 让我们尝试排除一个部分： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> dummy_int = <span class="hljs-number"><span class="hljs-number">54</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> dt &lt; <span class="hljs-string"><span class="hljs-string">'20180801'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 让我们看看执行统计信息： <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 2, logical reads 4, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br> 是的，排除了一个部分，仅在两个部分中进行了所需值的搜索。 <br> 在决定分区时，必须记住这一点。 如果查询中没有对表分区的字段进行限制，则可能有问题。 <br><br> 我们不再需要非聚集索引，因此我将其删除 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> nix_pTest_dummyINT <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> pTest;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">为什么需要非集群索引？</b> <div class="spoiler_text"> 总的来说，我不需要它，我可以使用集群索引显示相同的内容，我不知道为什么创建它，但是由于已经创建并制作了屏幕截图，所以请不要消失 <br></div></div><br> 现在考虑以下情况：我们每4个月从此表中存档一次数据-我们删除旧数据并为接下来的4个月添加一个部分（“滑动窗口”的组织在msdn和博客堆中都有描述）。 <br><br> 我们将任务分为可理解的小子任务： <br><br><ol><li> 添加一节以获取01/01/2019至04/01/2019的数据 </li><li> 创建一个空的舞台表 </li><li> 在阶段表中切换数据部分直到04/01/2018 </li><li> 摆脱空白部分 </li></ol><br> 出发： <br><br>  1.我们宣布将在FG1文件组中创建新部分，因为它将很快从我们手中释放出来： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1];</code> </pre> <br> 并通过添加新边框来更改分区功能： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 我们看一下统计数据： <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 76171, physical reads 0, read-ahead reads 753, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 7440, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br> 该表中有8809页（集群索引），因此，读数的数量当然是多有好处。 让我们在各节中看看现在有什么。 <br><br><img src="https://habrastorage.org/webt/s0/hy/yx/s0hyyxxh7iny_jc3t3k48ca83hs.png"><br><br> 总的来说，一切都按预期进行-出现了一个具有上限的新部分（请记住我们的边界条件属于左侧部分）01/01/2019和一个空白部分，其中将有其他日期较长的数据。 <br><br> 一切似乎都很好，但是为什么会有这么多读数？ 我们仔细查看上图，发现FG3中来自第三部分的数据以FG1结尾，但下一部分为FG3。 <br><br>  2.创建一个阶段表。 <br><br> 要将一个部分切换（切换）到一个表，反之亦然，我们需要一个空表，在其中创建所有与分区表相同的限制和索引。 该表应与我们要在其中“切换”的部分位于同一文件组中。 第一个（归档的）部分位于FG1中，因此我们在同一位置创建一个表和一个簇索引： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br> 您无需对该表进行分区。 <br><br>  3.现在我们准备切换： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 这是我们得到的： <br><br><pre> <code class="sql hljs"> 4947,  16,  1,  59 <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SWITCH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> failed. There <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> identical <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.pTest'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'cix_stageTest_id'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> target <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'PartitionTest.dbo.stageTest'</span></span> .</code> </pre> <br> 有趣的是，让我们看看索引中的内容： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.name tblName, i.name indexName, c.name columnName, ic.is_included_column <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.indexes i <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.objects o <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> i.object_id = o.object_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.index_columns ic <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.object_id = i.object_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ic.index_id = i.index_id <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> sys.columns c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ic.column_id = c.column_id <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.object_id = c.object_id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'pTest'</span></span>, <span class="hljs-string"><span class="hljs-string">'stageTest'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8e/mf/1u/8emf1uqyw18p6rghqkv3enygfx0.png"><br><br> 还记得我写过的，有必要在分区表上创建唯一的聚集索引吗？ 这就是为什么有必要的原因。 当创建唯一的聚集索引时，SQL Server将要求显式地包括在索引中对表进行分区的列，因此他自己添加了该列，而忘记了。 我真的不明白为什么。 <br> 但是，总的来说，这个问题是可以理解的，我们在舞台表上重新创建集群索引。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (drop_existing = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br> 现在，我们再次尝试切换该部分： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 塔坝！ 该部分已切换，请看它花了我们多少钱： <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 3 ms.</code> </pre> <br> 但是什么都没有。 将节切换到空表，反之亦然（将整个表切换到空节）是仅对元数据的操作，这正是分区是非常非常酷的事情的原因。 <br><br> 让我们看一下我们的部分： <br><br><img src="https://habrastorage.org/webt/mb/7j/pl/mb7jpl32ekb7e-vgl3mjfczd1ru.png"><br><br> 他们的一切都很好。 在第一部分中，剩下的记录为零，它们安全地保留在stageTest表中。 我们可以继续前进 <br><br>  4.我们剩下的就是删除我们空白的第一部分。 让我们来看看会发生什么： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 在我们的例子中，这也是仅对元数据的操作。 我们查看以下部分： <br><br><img src="https://habrastorage.org/webt/ju/ce/lf/jucelfzq4upnfi3fqg_8snuurho.png"><br><br> 到目前为止，我们只有3个部分，每个部分都在自己的文件组中。 任务完成。 这里有什么可以改进的？ 好吧，首先，我希望边界值引用“正确的”部分，以便这些部分包含4个月的所有数据。 而且我希望看到创建新部分的成本更低。 读取数据的次数是表本身的十倍-破产。 <br><br> 我们现在无法对第一个进行任何操作，但是对于第二个我们将尝试。 让我们创建一个新部分，其中将包含从01/01/2019到04/01/2019的数据，并且直到时间结束： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG2]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 我们看到： <br><br><pre> <code class="sql hljs">SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms. SQL Server parse and compile time: CPU time = 0 ms, elapsed time = 0 ms. SQL Server Execution Times: CPU time = 0 ms, elapsed time = 0 ms.</code> </pre> <br> 哈！ 因此，此操作仅针对元数据吗？ 是的，如果您“划分”空白部分-这仅是对元数据的操作，因此，保留左侧和右侧保证的空白部分都是正确的决定，并在必要时选择一个新部分-从此处“剪切”它们。 <br><br> 现在让我们看看如果我想将数据从阶段表返回到分区表会发生什么。 为此，我需要： <br><br><ol><li> 在左侧创建一个新部分以获取数据 </li><li> 将表格切换到此部分 </li></ol><br> 我们尝试（并记住FG1中的stageTest）： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 我们看到： <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 2939, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br> 好吧，还不错。 仅阅读左侧部分（我们将其划分）即可。 好吧 要将非分区的非空表切换到分区表部分，源表必须具有限制，以便SQL Server知道一切都会好起来，并且可以通过对元数据的操作来进行切换（而不是读取行中的所有内容并检查该部分是否符合条件） ）： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> check_dt <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (dt &lt;= <span class="hljs-string"><span class="hljs-string">'20180401'</span></span>)</code> </pre> <br> 尝试切换： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 统计资料： <br><br><pre> <code class="sql hljs"> SQL Server Execution Times: CPU time = 15 ms, elapsed time = 39 ms.</code> </pre> <br> 同样，该操作仅针对元数据。 我们看一下各节的内容： <br><br><img src="https://habrastorage.org/webt/c2/wv/xe/c2wvxe_ex2iyvv3v7l9hvxokq70.png"><br><br> 好吧 似乎已经整理好了。 现在，我们将尝试重新创建函数和分区方案（我删除了分区方案和函数，使用新的分区方案重新创建并重新填充了表，并重新创建了群集索引）： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest (datetime) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>, <span class="hljs-string"><span class="hljs-string">'20180801'</span></span>)</code> </pre> <br> 让我们看看我们现在有哪些部分： <br><br><img src="https://habrastorage.org/webt/b6/mw/j2/b6mwj2konz7su7x_ng5eonsgukw.png"><br><br> 好了，现在我们有三个“逻辑”部分-从时间开始到04/01/2018 00:00:00（不包括），从04/01/2018 00:00:00（包括）到08/01/2018 00:00:00（ （不包括）和第三项，即大于或等于01/01/2018 00:00:00的所有内容。 <br><br> 现在，让我们尝试执行与使用上一个分区功能执行的数据存档任务相同的任务。 <br><br>  1.添加一个新部分： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> scheme psTest <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> used [FG1]; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">split</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20190101'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 我们看一下统计数据： <br><br><pre> <code class="sql hljs">Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'ptest'. Scan count 1, logical reads 3685, physical reads 0, read-ahead reads 4, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. Table 'Worktable'. Scan count 1, logical reads 0, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br> 不错，至少是合理的-仅阅读最后一部分。 我们在以下各节中介绍一下： <br><br><img src="https://habrastorage.org/webt/1l/yr/i9/1lyri90cqmu969imje4edli1e7m.png"><br><br> 请注意，现在，完整的第三节保留在FG3中，而新的空白部分已在FG1中创建。 <br><br>  2.我们创建一个阶段表并在其上创建正确的集群索引 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> stageTest (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), dt datetime, dummy_int <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, dummy_char <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">6000</span></span>)) ; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> clustered <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> cix_stageTest_id <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> stageTest(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, dt) <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> [FG1];</code> </pre> <br>  3.开关部分 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> pTest <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> stageTest <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 统计数据表明，元数据操作为： <br><br><pre> <code class="sql hljs">SQL Server Execution Times: CPU time = 0 ms, elapsed time = 5 ms.</code> </pre> <br> 现在，一切都没有惊喜。 <br><br>  4.删除不必要的部分 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pfTest() <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> (<span class="hljs-string"><span class="hljs-string">'20180401'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STATISTICS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span>, IO <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre> <br> 在这里，我们有一个惊喜： <br><br><pre> <code class="sql hljs">Table 'ptest'. Scan count 1, logical reads 27057, physical reads 0, read-ahead reads 251, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.</code> </pre> <br> 我们看一下各节的内容： <br><br><img src="https://habrastorage.org/webt/qn/_j/xr/qn_jxrttkmls8amaycjwxqrescu.png"><br><br> 这很清楚：我们的第2节从fg2文件组移到了fg1文件组。 类。 我们可以做些什么吗？ <br><br> 也许我们只需要始终有一个空白部分，并“销毁”“永远空白”的左部分和我们“切换”到另一个表的部分之间的边界。 <br><br>  <b>结论：</b> <br><br><ol><li> 使用完整的语法创建分区功能，不要依赖默认值-您可能无法获得所需的内容。 </li><li> 将左右保持在空白区域-在组织“滑动窗口”时它们将对您非常有用。 </li><li> 拆分并合并非空部分-总是很麻烦，请尽可能避免这种情况。 </li><li> 检查您的查询-如果它们不按计划对表进行分区的列使用筛选器，并且您需要切换部分的能力-它们的性能可能会大大降低。 </li><li> 如果您想做某事，请先进行生产测试。 </li></ol><br> 希望该材料对您有所帮助。 也许事实证明它是弄皱的，如果您认为所声明的内容未公开，请写，我将尽力完成它。 谢谢您的关注。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN464665/">https://habr.com/ru/post/zh-CN464665/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN464651/index.html">AVR微控制器的汇编代码生成器库。 第5部分</a></li>
<li><a href="../zh-CN464655/index.html">在过去的两年中，编程语言的薪水和受欢迎程度如何变化</a></li>
<li><a href="../zh-CN464657/index.html">逆向工程电动飞檐AM82TV</a></li>
<li><a href="../zh-CN464659/index.html">应用程序安全性，或如何在自定义开发中嵌入安全性。 在AGIMA的个人经历</a></li>
<li><a href="../zh-CN464661/index.html">向谁委托技术改造和重建设施的设计</a></li>
<li><a href="../zh-CN464671/index.html">接收常规短信到Viber和Telegram即时通讯程序（使用GoIP网关）</a></li>
<li><a href="../zh-CN464673/index.html">TinyFL-微控制器手电筒驱动器</a></li>
<li><a href="../zh-CN464675/index.html">Splunk中的应用程序接口本地化机制分析</a></li>
<li><a href="../zh-CN464677/index.html">证券交易所的投资和相关成本：经纪公司提供多少服务</a></li>
<li><a href="../zh-CN464679/index.html">Voxgun-无需任何额外努力即可创建专业视频内容的服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>