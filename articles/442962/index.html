<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨úÔ∏è ‚ôêÔ∏è üèµÔ∏è Otro art√≠culo sobre vidas en Rust üë®üèæ‚Äç‚öñÔ∏è üì´ üö¥üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los primeros meses de un alborotador novato generalmente se reducen a un encabezado sobre el concepto de vida y posesi√≥n. Algunas personas analizan es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otro art√≠culo sobre vidas en Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442962/"><p> Los primeros meses de un alborotador novato generalmente se reducen a un encabezado sobre el concepto de vida y posesi√≥n.  Algunas personas analizan esto, pero para aquellos que pudieron sobrevivir, esto ya no parece inusual o incorrecto.  Describir√© los puntos clave que, me parece, han ayudado a adaptarse m√°s r√°pido y mejor al concepto de vida y posesiones. <img src="https://habrastorage.org/webt/vm/qw/p5/vmqwp5m_uwm9ghbbtcm5be3xqre.png" align="right"></p><br><p>  Por supuesto, el bolet√≠n oficial es m√°s completo y m√°s detallado, pero tambi√©n requiere m√°s tiempo y paciencia para comprender y absorber completamente toda la informaci√≥n.  Trat√© de evitar una gran cantidad de detalles y presentar todo en orden creciente de complejidad, en un intento de hacer que este art√≠culo sea m√°s accesible para aquellos que comenzaron a mirar el rastreo o no entendieron realmente los momentos iniciales del tablero de anuncios oficial. </p><br><p>  Tambi√©n me hizo escribir que, por ejemplo, de las m√≥nadas, puedes encontrar algunos materiales de capacitaci√≥n oficiales, pero no siempre se comprenden bien, y la comprensi√≥n surge solo despu√©s de leer algo como "otra introducci√≥n" sobre este tema. </p><br><h3 id="vremya-zhizni-lifetime">  Toda la vida </h3><br><p>  Primero tenemos que sentirnos c√≥modos con dos cosas: el final del bloque y mover el valor a otro bloque.  M√°s adelante comenzaremos a complicarlo agregando "pr√©stamos", "mutabilidad" y "mutabilidad oculta". </p><a name="habracut"></a><br><p>  En primer lugar, la vida de un valor est√° determinada por el siguiente segmento: </p><br><ul><li>  El comienzo de la vida: crear valor.  Esto es com√∫n para la mayor√≠a de los lenguajes de programaci√≥n, por lo que no lleva ninguna carga inusual. </li><li>  El fin de la vida.  Aqu√≠ es donde Rust llamar√° autom√°ticamente al destructor y se olvidar√° del valor.  En un bloque de alcance, esto suceder√° al final de este bloque sin moverse.  El seguimiento mental del final de la vida es, en mi opini√≥n, la clave para una interacci√≥n exitosa con el prestatario. </li></ul><cut></cut><br><p>  Agregar√© un detalle que puede ser √∫til: si hay varios valores en el alcance, se destruir√°n en el orden inverso de la creaci√≥n. </p><br><p>  Otro punto: crear√© una cadena, porque no tiene un marcador Copiar, y los valores que tienen este marcador no se mueven sino que se copian, lo que se considera una operaci√≥n bastante barata, pero cambia el comportamiento del movimiento (y hace que sea m√°s f√°cil trabajar con tipos primitivos), pero m√°s sobre eso m√°s tarde. </p><br><p>  Los ejemplos se pueden ejecutar aqu√≠: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://play.rust-lang.org/</a> </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { { <span class="hljs-comment"><span class="hljs-comment">//    let a = "a".to_string(); // &lt;-   "a" let b = 100; // &lt;-   "b" // &lt;-   b // &lt;-   a } //    //     "a"  "b" }</span></span></code> </pre> <br><p>  Con un bloque simple, todo es relativamente simple, la siguiente etapa ocurre cuando usamos cosas aparentemente simples como funciones y cierres: </p><br><h3 id="peremeschenie">  En movimiento </h3><br><p>  Agregue un concepto como mover un valor.  En palabras simples, "mover" significa que el bloque actual ya no est√° interesado en el destino del valor y lo olvida, y su destino se transfiere a otro bloque, por ejemplo, a otra funci√≥n, a un cierre, o simplemente a otro valor. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>&lt;T: std::fmt::Display&gt;(x: T) { <span class="hljs-comment"><span class="hljs-comment">//   ,         . println!("{}", x); // &lt;-  ,   "a",    . } fn main() { let a = "a".to_string(); // "a"    let b = 2; f(a); //   "a"  f //        f(a) -   ,    "a"        .    a  b,    ,      Copy   . // "b" . }</span></span></code> </pre> <br><p>  Con cierres. </p><br><p>  Para que el cierre mueva el valor capturado a su bloque, se usa la palabra clave move, si no escribe move, el valor es prestado, sobre lo que escribir√© muy pronto. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let b = 2; let f_1 = move || {println!("{}", a)}; //   "a" //    "a"    . // let f_2 = move || {println!("{}", a)}; f_1(); }</span></span></code> </pre> <br><p>  Puede mover tanto a la funci√≥n como a la funci√≥n u otro valor. </p><br><p>  Este ejemplo demuestra c√≥mo hacer un seguimiento de las formas en que se mueven los valores para vivir en paz con el prestatario. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { x + <span class="hljs-string"><span class="hljs-string">" and x"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    x   +,     . //  +   String,    . } fn main() { let a = "a".to_string(); //  "a" let b = f(a); //  "a"  "f",  f     b. println!("{}", b); // "a"   . }</span></span></code> </pre> <br><h3 id="odalzhivanie">  Pr√©stamos </h3><br><p>  Introducimos este nuevo concepto: a diferencia del movimiento, esto significa que el bloque actual se reserva el control del valor, simplemente permite que el otro bloque use su valor. </p><br><p>  Observo que los pr√©stamos tambi√©n tienen lugar donde terminaron, lo que no es muy importante en estos ejemplos, pero aparecer√° en el pr√≥ximo p√°rrafo. </p><br><p>  Nota: No escribir√© sobre c√≥mo especificar la vida √∫til directamente en la funci√≥n, ya que el √≥xido moderno lo hace autom√°ticamente mejor que en los viejos tiempos, y la divulgaci√≥n de todo esto es unas pocas p√°ginas m√°s. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   &amp;,    . println!("{}", x); // &lt;-  ,  "x"     } fn main() { let a = "a".to_string(); // "a"    f(&amp;a); //   "a"  f //   f(&amp;a); //    -  . println!("{}", a); //   // "a"  . }</span></span></code> </pre> <br><p>  Con cierres similares: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.push_str("and x"); //   "a" let f_2 = || a.push_str("and x"); //   f_1(); f_2(); println!("{}", a); // "a"  . }</span></span></code> </pre> <br><p>  En realidad, en la mayor√≠a de estas construcciones simples, el usuario solo necesita decidir d√≥nde quiere terminar la vida del valor: al final del bloque actual y prestarlo a algunas funciones, o, si sabemos que ya no necesitamos el valor, luego moverlo a la funci√≥n al final por el cual ser√° destruido, cuanto m√°s r√°pido liberemos la memoria, pero el valor ya no estar√° disponible en el bloque actual. </p><br><h3 id="mutabelnost">  Mutabilidad </h3><br><p>  En rasta, como, por ejemplo, en kotlin, hay una divisi√≥n en valores mutables y no estables.  Pero surge el problema de que la mutabilidad tiene un efecto en los pr√©stamos: <br>  Puede pedir prestado un valor no estable muchas veces, y un valor mutable se puede pedir prestado mutuamente solo una vez.  No puede mutar un valor prestado anteriormente. </p><br><p>  Un ejemplo que no est√° relacionado con los anteriores, cuando este concepto nos salva de problemas al prohibir los pr√©stamos mutables y no estables simult√°neos: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.chars() { <span class="hljs-comment"><span class="hljs-comment">//   a.push_str(" and "); //  .  . a.push(x); } }</span></span></code> </pre> <br><p>  Aqu√≠ ya es necesario abastecerse de varios trucos para satisfacer, en su mayor parte, los justos reclamos de la rasta.  En el ejemplo anterior, lo m√°s f√°cil ser√≠a clonar "a" -&gt; el clon tendr√° un pr√©stamo no estable y no se relacionar√° con el "a" original. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.clone().chars() { <span class="hljs-comment"><span class="hljs-comment">//  ,   . a.push_str(" and "); //  .      -   .</span></span></code> </pre> <br><p>  Pero es mejor volver a nuestros ejemplos para mantener la coherencia.  Necesitamos cambiar "a" y no podemos hacerlo. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string(); <span class="hljs-comment"><span class="hljs-comment">// "a"    let mut f_1 = || a.push_str(" and x"); //   "a".   - ,  mut  mut. //      ,   f_1  . let mut f_2 = || a.push_str(" and y"); //     : second mutable borrow occurs here f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><h3 id="skrytoe-mutirovanie">  Mutaci√≥n oculta </h3><br><p>  Te√≥ricamente, se puede pasar un cierre a alguna funci√≥n que procesa, por ejemplo, de forma as√≠ncrona en otro subproceso, y entonces realmente tendr√≠amos problemas, pero en este caso, el revisor de pr√©stamos est√° reasegurado, aunque esto no cancela el hecho de que de alguna manera debemos estar de acuerdo . </p><br><p>  En pocas palabras: necesitamos dos pr√©stamos mutantes, pero el rastreo solo permite una cosa, pero los astutos inventores del rasta tienen una "mutaci√≥n oculta": RefCell. </p><br><p>  RefCell - lo que envolvemos en RefCell - el r√°ster lo considera nemable, sin embargo, al usar la funci√≥n pr√©stamos_mut () podemos extraer temporalmente un enlace mutable por el cual puede cambiar el valor, <strong>pero hay un matiz importante</strong> : el enlace solo se puede obtener cuando RefCell en tiempo de ejecuci√≥n se asegura de que no haya otros pr√©stamos activos, de lo contrario lanzar√° p√°nico o devolver√° un error si se usa try_borrow_mut ().  Es decir  aqu√≠ el crecimiento genera todas las preocupaciones sobre los pr√©stamos al cuidado del usuario, y √©l mismo debe asegurarse de no tomar prestado el valor de varios lugares a la vez. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = RefCell::new(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.to_string()); <span class="hljs-comment"><span class="hljs-comment">// "a"    let f_1 = || a.borrow_mut().push_str(" and x"); //    "a" let f_2 = || a.borrow_mut().push_str(" and y"); //    f_1(); //      a.borrow_mut() ,           mut    . f_2(); //   . println!("{}", a.borrow()); //         . }</span></span></code> </pre> <br><h3 id="schyotchik-ssylok-rc">  Rc Link Counter </h3><br><p>  Esta construcci√≥n es familiar en muchos idiomas, y se usa en rast, cuando, por ejemplo, no podemos tomar prestado un valor por alguna raz√≥n, y es necesario tener varios valores de referencia para un solo valor.  Rc, como su nombre lo indica, es simplemente un contador de referencia que posee un valor, puede tomar prestados enlaces no confiables, contar su n√∫mero y tan pronto como se restablece su n√∫mero, destruye el valor y a s√≠ mismo.  Resulta que Rc permite, por as√≠ decirlo, expandir en secreto la vida √∫til del valor que contiene. </p><br><p>  Agregar√© que el rastreo puede eliminar autom√°ticamente las estructuras para las que est√° definido, lo que significa que para trabajar con Rc, por regla general, no necesita ninguna extracci√≥n adicional del valor interno y solo trabajamos con Rc como con el valor dentro de √©l. </p><br><p>  Aqu√≠, un ejemplo simple se pens√≥ un poco, intentemos emular que el cierre del ejemplo anterior no quiere aceptar &amp; T o &amp; String, pero solo quiere String: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  String,    &amp;String println!("{}", x); } fn main() { let a = "a".to_string(); let f_1 = move || f(a); //   move,    ... let f_2 = move || f(a); // ...     ,           f_1(); f_2(); println!("{}", a); }</span></span></code> </pre> <br><p>  Este problema se resolver√≠a f√°cilmente si pudi√©ramos cambiar la funci√≥n a <code>fn f(x: &amp;String)</code> (o &amp; str), pero imaginemos que por alguna raz√≥n no podemos usar &amp; </p><br><p>  Utilizamos Rc </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Rc println!("{}", x); //     ,  println          ,           ,       ,    . } fn main() { let a_rc = Rc::new("a".to_string()); //  Rc   let a_ref_1 = a.clone(); //   -,  . let a_ref_2 = a.clone(); //   let f_1 = move || f(a_ref_1); //      - let f_2 = move || f(a_ref_2); //  f_1(); f_2(); println!("{}", a_rc); //     Rc  . //    a_rc       . }</span></span></code> </pre> <br><p>  Agregar√© el √∫ltimo ejemplo, ya que uno de los pares de contenedores m√°s frecuentes que se pueden encontrar es Rc &lt;RefCell&gt; <br></p><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>(x: Rc&lt;RefCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;&gt;) { x.borrow_mut().push_str(<span class="hljs-string"><span class="hljs-string">" and x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ,       ,   . } fn main() { let a = Rc::new(RefCell::new("a".to_string())); //      let a_ref_1 = a.clone(); let a_ref_2 = a.clone(); let f_1 = move || f(a_ref_1); let f_2 = move || f(a_ref_2); f_1(); f_2(); println!("{}", a.borrow()); // Rc   ,   RefCell   }</span></span></code> </pre> <br><p>  Adem√°s, ser√≠a l√≥gico mover este tutorial a un an√°logo de Rc-Arc seguro para subprocesos y luego continuar con Mutex, pero no hablar√° sobre seguridad de subprocesos y comprobaci√≥n de pr√©stamos en un p√°rrafo, y no est√° claro si este tipo de art√≠culo es necesario, ya que hay un subproceso oficial.  Entonces concluyo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442962/">https://habr.com/ru/post/442962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442948/index.html">Descartado a trav√©s de la automatizaci√≥n</a></li>
<li><a href="../442950/index.html">Revisi√≥n Cutra Wonder Cutter</a></li>
<li><a href="../442952/index.html">Nuevo Hackathon en Tinkoff.ru</a></li>
<li><a href="../442954/index.html">Usando SQLite en Unity (Unity + SQLite)</a></li>
<li><a href="../442958/index.html">Nikita Shamgunov le dijo a The Bell sobre trabajar en Microsoft y Facebook, hablando con Gates y la base de datos MemSQL</a></li>
<li><a href="../442964/index.html">H√°galo usted mismo analizando arte o DOM</a></li>
<li><a href="../442966/index.html">Bitcoin para Starbucks Coffee plantea importantes problemas de presentaci√≥n de impuestos</a></li>
<li><a href="../442968/index.html">Obtenci√≥n de un CPE para respaldar certificaciones profesionales (Estudio de caso de ISACA)</a></li>
<li><a href="../442970/index.html">Juego de mesa para aprender los conceptos b√°sicos de los circuitos el√©ctricos. Por que no</a></li>
<li><a href="../442974/index.html">El proyecto de ley sobre la lucha contra la informaci√≥n falsa se aprob√≥ en la tercera lectura.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>