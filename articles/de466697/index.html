<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî´ üëÇüèº üõçÔ∏è Monaden in Erlang üíÖüèæ ‚õ±Ô∏è üßú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf Habr√© finden Sie viele Ver√∂ffentlichungen, die sowohl die Theorie der Monaden als auch die Praxis ihrer Anwendung offenbaren. Die meisten dieser A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monaden in Erlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466697/"><p><img src="https://habrastorage.org/webt/uu/-w/xm/uu-wxmn1samfdcrveqdv27zpvvm.jpeg"></p><br><p>  Auf Habr√© finden Sie viele Ver√∂ffentlichungen, die sowohl die Theorie der Monaden als auch die Praxis ihrer Anwendung offenbaren.  Die meisten dieser Artikel werden √ºber Haskell erwartet.  Ich werde die Theorie nicht zum n-ten Mal nacherz√§hlen.  Heute werden wir √ºber einige Erlang-Probleme sprechen, M√∂glichkeiten, sie mit Monaden zu l√∂sen, teilweise Verwendung von Funktionen und syntaktischen Zucker von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erlando</a> - eine coole Bibliothek des RabbitMQ-Teams. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Erlang hat Unver√§nderlichkeit, aber keine Monaden <strong>*</strong> .  Dank der parse_transform-Funktionalit√§t und der erlando-Implementierung in der Sprache besteht jedoch weiterhin die M√∂glichkeit, Monaden in Erlang zu verwenden. </p><br><p>  √úber Immunit√§t am Anfang der Geschichte habe ich nicht zuf√§llig gesprochen.  Immunit√§t ist fast √ºberall und immer - eine der Hauptideen von Erlang.  Durch Immunit√§t und Reinheit der Funktionen k√∂nnen Sie sich auf die Entwicklung einer bestimmten Funktion konzentrieren und haben keine Angst vor Nebenwirkungen.  Neulinge in Erlang, die beispielsweise aus Java oder Python kommen, finden es jedoch ziemlich schwierig, Erlangs Ideen zu verstehen und zu akzeptieren.  Besonders wenn Sie sich an die Erlang-Syntax erinnern.  Diejenigen, die versuchten, Erlang zu verwenden, bemerkten wahrscheinlich seine Ungew√∂hnlichkeit und Unabh√§ngigkeit.  Auf jeden Fall habe ich viele R√ºckmeldungen von Anf√§ngern gesammelt und die ‚Äûseltsame‚Äú Syntax f√ºhrt die Bewertung an. </p><br><h2 id="erlando">  Erlando </h2><br><p>  Erlando ist ein Erlang-Erweiterungsset, das uns Folgendes bietet: </p><br><ul><li>  Teilweise Verwendung / Currying von Funktionen mit schemaartigen Schnitten </li><li>  Haskell-√§hnliche Notationen </li><li>  import-as - syntaktischer Zucker zum Importieren von Funktionen aus anderen Modulen. </li></ul><br><p>  <strong>Hinweis:</strong> Ich habe die folgenden Codebeispiele verwendet, um die Merkmale von erlando aus Matthew Sackmans Pr√§sentation zu veranschaulichen, und sie teilweise mit meinem Code und meinen Erkl√§rungen verd√ºnnt. </p><br><h2 id="abstrakciya-cut">  Abstrakter Schnitt </h2><br><p>  Gehen Sie direkt zum Punkt.  Betrachten Sie mehrere Funktionen eines realen Projekts: </p><br><pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VHostPath, Items)</span></span></span><span class="hljs-function"> -&gt;</span></span> map(VHostPath, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (Q) -&gt; info(Q, Items) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>). backing_queue_timeout(State = #q{ backing_queue = BQ }) -&gt; run_backing_queue( BQ, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (M, BQS) -&gt; M:timeout(BQS) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, State). reset_msg_expiry_fun(TTL) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (MsgProps) -&gt; MsgProps #message_properties{ expiry = calculate_msg_expiry(TTL)} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><p>  Alle diese Funktionen dienen dazu, Parameter durch einfache Ausdr√ºcke zu ersetzen.  Tats√§chlich handelt es sich hierbei um eine Teilanwendung, da einige Parameter vor dem Aufruf nicht bekannt sind.  Zusammen mit der Flexibilit√§t f√ºgen diese Funktionen unserem Code Rauschen hinzu.  Durch ein wenig √Ñndern der Syntax - durch Eingabe von cut - k√∂nnen Sie die Situation verbessern. </p><br><h3 id="znachenie-_">  Wert _ </h3><br><ul><li>  _ kann in Vorlagen verwendet werden </li><li>  Mit Ausschneiden k√∂nnen Sie _ Au√üenmuster verwenden </li><li>  Wenn es <em>sich au√üerhalb der Vorlage befindet, wird es</em> zu einem Parameter f√ºr den Ausdruck, in dem es sich befindet </li><li>  Die mehrfache Verwendung von _ innerhalb desselben Ausdrucks f√ºhrt zur Ersetzung mehrerer Parameter in diesem Ausdruck </li><li>  Cut ist kein Ersatz f√ºr Verschl√ºsse (Funs) </li><li>  Argumente werden vor der Schnittfunktion ausgewertet. </li></ul><br><p>  Cut verwendet _ in Ausdr√ºcken, um anzugeben, wo die Abstraktion angewendet werden soll.  Ausschneiden umschlie√üt nur die n√§chstgelegene Ebene im Ausdruck, verschachtelter Schnitt ist jedoch nicht verboten. <br>  Zum Beispiel <code>list_to_binary([1, 2, math:pow(2, _)]).</code>  <code>list_to_binary([1, 2, fun (X) -&gt; math:pow(2, X) end]).</code> zu <code>list_to_binary([1, 2, fun (X) -&gt; math:pow(2, X) end]).</code>  aber nicht im <code>fun (X) -&gt; list_to_binary([1, 2, math:pow(2, X)]) end.</code>  . </p><br><p>  Es klingt etwas verwirrend. Schreiben wir die obigen Beispiele mit cut neu: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VHostPath, Items)</span></span></span><span class="hljs-function"> -&gt;</span></span> map(VHostPath, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (Q) -&gt; info(Q, Items) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>). info_all(VHostPath, Items) -&gt; map(VHostPath, info(_, Items)).</code> </pre> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backing_queue_timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State = #q{ backing_queue = BQ })</span></span></span><span class="hljs-function"> -&gt;</span></span> run_backing_queue( BQ, <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (M, BQS) -&gt; M:timeout(BQS) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, State). backing_queue_timeout(State = #q{backing_queue = BQ}) -&gt; run_backing_queue(BQ, _:timeout(_), State).</code> </pre> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_msg_expiry_fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TTL)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (MsgProps) -&gt; MsgProps #message_properties { expiry = calculate_msg_expiry(TTL) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>. reset_msg_expiry_fun(TTL) -&gt; _ #message_properties { expiry = calculate_msg_expiry(TTL) }.</code> </pre> <br><h3 id="poryadok-vychisleniya-argumentov">  Reihenfolge der Argumentberechnung </h3><br><p>  Betrachten Sie das folgende Beispiel, um die Reihenfolge zu veranschaulichen, in der die Argumente berechnet werden: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_, _)</span></span></span><span class="hljs-function"> -&gt;</span></span> io:format(<span class="hljs-string"><span class="hljs-string">"in f1~n"</span></span>). test() -&gt; F = f1(io:format(<span class="hljs-string"><span class="hljs-string">"test line 1~n"</span></span>), _), F(io:format(<span class="hljs-string"><span class="hljs-string">"test line 2~n"</span></span>)).</code> </pre> <br><p>  Da die Argumente vor der Schnittfunktion ausgewertet werden, wird Folgendes angezeigt: </p><br><pre> <code class="plaintext hljs">test line 2 test line 1 in f1</code> </pre> <br><h3 id="abstrakciya-cut-v-razlichnyh-tipah-i-shablonah-koda">  Schneiden Sie die Abstraktion in verschiedene Arten und Muster von Code </h3><br><ul><li>  Tupel <br><pre> <code class="erlang hljs">F = {_, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {a, <span class="hljs-number"><span class="hljs-number">3</span></span>} = F(a).</code> </pre> </li><li>  Listen <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbl_cons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List)</span></span></span><span class="hljs-function"> -&gt;</span></span> [_, _ | List]. test() -&gt; F = dbl_cons([<span class="hljs-number"><span class="hljs-number">33</span></span>]), [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>] = F(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>).</code> </pre> </li><li>  Aufzeichnungen <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-record</span></span><span class="hljs-params"><span class="hljs-params">(vector, { x, y, z })</span></span>. test() -&gt; GetZ = _#vector.z, <span class="hljs-number"><span class="hljs-number">7</span></span> = GetZ(#vector { z = <span class="hljs-number"><span class="hljs-number">7</span></span> }), SetX = _#vector{x = _}, V = #vector{ x = <span class="hljs-number"><span class="hljs-number">5</span></span>, y = <span class="hljs-number"><span class="hljs-number">4</span></span> } = SetX(#vector{ y = <span class="hljs-number"><span class="hljs-number">4</span></span> }, <span class="hljs-number"><span class="hljs-number">5</span></span>).</code> </pre> </li><li>  F√§lle <br><pre> <code class="erlang hljs">F = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_integer(N) -&gt; N + N; N -&gt; N <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> = F(<span class="hljs-number"><span class="hljs-number">5</span></span>), ok = F(ok).</code> </pre> </li><li>  Karten <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> GetZ = maps:get(z, _), <span class="hljs-number"><span class="hljs-number">7</span></span> = GetZ(#{ z =&gt; <span class="hljs-number"><span class="hljs-number">7</span></span> }), SetX = _#{x =&gt; _}, V = #{ x := <span class="hljs-number"><span class="hljs-number">5</span></span>, y := <span class="hljs-number"><span class="hljs-number">4</span></span> } = SetX(#{ y =&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> }, <span class="hljs-number"><span class="hljs-number">5</span></span>).</code> </pre> </li><li>  √úbereinstimmende Listen und Erstellen von Bin√§rdaten <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cut_comprehensions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> F = &lt;&lt; &lt;&lt;(<span class="hljs-number"><span class="hljs-number">1</span></span> + (X*<span class="hljs-number"><span class="hljs-number">2</span></span>))&gt;&gt; || _ &lt;- _, X &lt;- _ &gt;&gt;, <span class="hljs-comment"><span class="hljs-comment">%% Note, this'll only be a /2 ! &lt;&lt;"AAA"&gt;&gt; = F([a,b,c], [32]), F1 = [ {X, Y, Z} || X &lt;- _, Y &lt;- _, Z &lt;- _, math:pow(X,2) + math:pow(Y,2) == math:pow(Z,2) ], [{3,4,5}, {4,3,5}, {6,8,10}, {8,6,10}] = lists:usort(F1(lists:seq(1,10), lists:seq(1,10), lists:seq(1,10))).</span></span></code> </pre> </li></ul><br><p>  <strong>Vorteile</strong> </p><br><ul><li>  Der Code ist kleiner geworden, daher ist die Wartung einfacher. </li><li>  Der Code ist einfacher und √ºbersichtlicher geworden. </li><li>  L√§rm vom Spa√ü gegangen. </li><li>  F√ºr Anf√§nger in Erlang ist es bequemer, Get / Set-Funktionen zu schreiben. </li></ul><br><p>  <strong>Nachteile</strong> </p><br><ul><li>  Erh√∂hte Einstiegsschwelle f√ºr erfahrene Erlang-Entwickler und reduzierte Einstiegsschwelle f√ºr Anf√§nger.  Jetzt muss das Team den Schnitt verstehen und eine weitere Syntax kennen. </li></ul><br><h2 id="do-notaciya">  Notation machen </h2><br><p>  Weiches Komma ist ein rechnerisch bindendes Konstrukt.  Erlang hat kein faules Berechnungsmodell.  Stellen wir uns vor, was passieren w√ºrde, wenn Erlang faul wie Haskell w√§re </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> A = foo(), B = bar(A, dog), ok.</code> </pre> <br><p>  Um die Ausf√ºhrungsreihenfolge zu gew√§hrleisten, m√ºssten wir die Berechnungen explizit durch Definieren eines Kommas verkn√ºpfen. </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> A = foo(), comma(), B = bar(A, dog), comma(), ok.</code> </pre> <br><p>  Setzen Sie die Konvertierung fort: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> comma(foo(), <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (A) -&gt; comma(bar(A, dog), <span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> (B) -&gt; ok <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)).</code> </pre> <br><p>  Basierend auf der Schlussfolgerung ist Komma / 2 eine idiomatische Funktion <code>&gt;&gt;=/2</code> .  Die Monade ben√∂tigt nur drei Funktionen: <code>&gt;&gt;=/2</code> , <code>return/1</code> und <code>fail/1</code> . <br>  Alles w√§re in Ordnung, aber die Syntax ist einfach schrecklich.  Wir wenden <code>erlando</code> von <code>erlando</code> . </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([Monad || A &lt;- foo(), B &lt;- bar(A, dog), ok])</span></span></span><span class="hljs-function">.</span></span></code> </pre> <br><h2 id="tipy-monad">  Arten von Monaden </h2><br><p>  Da der do-Block parametrisiert ist, k√∂nnen wir Monaden verschiedener Typen verwenden.  Innerhalb des Do-Blocks werden die Aufrufe <code>return/1</code> und <code>fail/1</code> f√ºr <code>Monad:return/1</code> bzw. <code>Monad:fail/1</code> bereitgestellt. </p><br><ul><li><p>  Identit√§tsmonade. <br>  Die identische Monade ist die einfachste Monade, die den Wertetyp nicht √§ndert und nicht an der Steuerung des Berechnungsprozesses beteiligt ist.  Es wird mit Transformatoren angewendet.  F√ºhrt Verkn√ºpfungsausdr√ºcke aus - das oben beschriebene Software-Komma. </p><br></li><li><p>  Vielleicht-Monade. <br>  Monade von Berechnungen mit Verarbeitung fehlender Werte.  Das Verkn√ºpfen eines Parameters mit einer parametrisierten Berechnung ist die √úbertragung eines Parameters auf eine Berechnung. Das Verkn√ºpfen eines fehlenden Parameters mit einer parametrisierten Berechnung ist ein fehlendes Ergebnis. <br>  Betrachten Sie ein Beispiel f√ºr vielleicht_m: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if_safe_div_zero</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, Y, Fun)</span></span></span><span class="hljs-function"> -&gt;</span></span> do([maybe_m || Result &lt;- <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Y == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; fail(<span class="hljs-string"><span class="hljs-string">"Cannot divide by zero"</span></span>); <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; return(X / Y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, return(Fun(Result))]).</code> </pre> <br><p>  Die Auswertung des Ausdrucks wird beendet, wenn nichts zur√ºckgegeben wird. </p><br><pre> <code class="erlang hljs">{just, <span class="hljs-number"><span class="hljs-number">6</span></span>} = if_safe_div_zero(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, _+<span class="hljs-number"><span class="hljs-number">4</span></span>) ## <span class="hljs-number"><span class="hljs-number">10</span></span>/<span class="hljs-number"><span class="hljs-number">5</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span> -&gt; <span class="hljs-number"><span class="hljs-number">6</span></span> nothing = if_safe_div_zero(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _+<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br></li><li><p>  Fehlermonade. <br>  √Ñhnlich wie vielleicht_m, nur mit Fehlerbehandlung.  Manchmal gilt das Let it Crash-Prinzip nicht und Fehler m√ºssen zum Zeitpunkt ihres Auftretens behandelt werden.  In diesem Fall erscheinen h√§ufig Treppen aus dem Fall im Code, zum Beispiel diese: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path, Data, Modes)</span></span></span><span class="hljs-function"> -&gt;</span></span> Modes1 = [binary, write | (Modes -- [binary, write])], <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> make_binary(Data) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Bin <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_binary(Bin) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> file:open(Path, Modes1) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> {ok, Hdl} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> file:write(Hdl, Bin) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> file:sync(Hdl) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ok -&gt; file:close(Hdl); {error, _} = E -&gt; file:close(Hdl), E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; {error, _} = E -&gt; file:close(Hdl), E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; {error, _} = E -&gt; E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; {error, _} = E -&gt; E <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bin)</span></span></span><span class="hljs-function"> -&gt;</span></span> Bin; make_binary(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> iolist_to_binary(List) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> error:Reason -&gt; {error, Reason} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br></li></ul><br><p>  Das zu lesen ist unangenehm, sieht aus wie R√ºckrufnudeln in JS.  Error_m kommt zur Rettung: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Path, Data, Modes)</span></span></span><span class="hljs-function"> -&gt;</span></span> Modes1 = [binary, write | (Modes -- [binary, write])], do([error_m || Bin &lt;- make_binary(Data), Hdl &lt;- file:open(Path, Modes1), Result &lt;- return(do([error_m || file:write(Hdl, Bin), file:sync(Hdl)])), file:close(Hdl), Result]). make_binary(Bin) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_binary(Bin) -&gt; error_m:return(Bin); make_binary(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> error_m:return(iolist_to_binary(List)) <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> error:Reason -&gt; error_m:fail(Reason) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><ul><li>  Listenmonade. <br>  Werte sind Listen, die als mehrere m√∂gliche Ergebnisse einer einzelnen Berechnung interpretiert werden k√∂nnen.  Wenn eine Berechnung von einer anderen abh√§ngt, wird die zweite Berechnung f√ºr jedes Ergebnis der ersten durchgef√ºhrt, und die Ergebnisse (zweite Berechnung) werden in einer Liste gesammelt. <br>  Betrachten Sie das Beispiel mit den klassischen pythagoreischen Tripeln.  Wir berechnen sie ohne Monaden: <br><pre> <code class="erlang hljs">P = [{X, Y, Z} || Z &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>), X &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,Z), Y &lt;- lists:seq(X,Z), math:pow(X,<span class="hljs-number"><span class="hljs-number">2</span></span>) + math:pow(Y,<span class="hljs-number"><span class="hljs-number">2</span></span>) == math:pow(Z,<span class="hljs-number"><span class="hljs-number">2</span></span>)].</code> </pre> </li></ul><br><p>  Gleiches gilt nur f√ºr list_m: </p><br><pre> <code class="erlang hljs">P = do([list_m || Z &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>), X &lt;- lists:seq(<span class="hljs-number"><span class="hljs-number">1</span></span>,Z), Y &lt;- lists:seq(X,Z), monad_plus:guard(list_m, math:pow(X,<span class="hljs-number"><span class="hljs-number">2</span></span>) + math:pow(Y,<span class="hljs-number"><span class="hljs-number">2</span></span>) == math:pow(Z,<span class="hljs-number"><span class="hljs-number">2</span></span>)), return({X,Y,Z})]).</code> </pre> <br><ul><li>  Staatsmonade. <br>  Monade des Stateful Computing. <br>  Ganz am Anfang des Artikels haben wir √ºber die Schwierigkeiten von Anf√§ngern bei der Arbeit mit einem variablen Zustand gesprochen.  Oft sieht der Code ungef√§hr so ‚Äã‚Äãaus: <br><pre> <code class="erlang hljs">State1 = init(Dimensions), State2 = plant_seeds(SeedCount, State1), {DidFlood, State3} = pour_on_water(WaterVolume, State2), State4 = apply_sunlight(Time, State3), {DidFlood2, State5} = pour_on_water(WaterVolume, State4), {Crop, State6} = harvest(State5), ...</code> </pre> </li></ul><br><p>  Mit einem Transformator und einer Schnittnotation kann dieser Code kompakter und lesbarer umgeschrieben werden: </p><br><pre> <code class="erlang hljs">StateT = state_t:new(identity_m), SM = StateT:modify(_), SMR = StateT:modify_and_return(_), StateT:exec( do([StateT || StateT:put(init(Dimensions)), SM(plant_seeds(SeedCount, _)), DidFlood &lt;- SMR(pour_on_water(WaterVolume, _)), SM(apply_sunlight(Time, _)), DidFlood2 &lt;- SMR(pour_on_water(WaterVolume, _)), Crop &lt;- SMR(harvest(_)), ... ]), undefined).</code> </pre> <br><ul><li>  Omega-Monade. <br>  √Ñhnlich wie list_m Monade.  Der Durchgang erfolgt jedoch diagonal. </li></ul><br><h3 id="skrytaya-obrabotka-oshibok">  Versteckte Fehlerbehandlung </h3><br><p>  Wahrscheinlich eines meiner Lieblingsfeatures der <code>error_m</code> Monade.  Unabh√§ngig davon, wo der Fehler auftritt, gibt die Monade immer entweder <code>{ok, Result}</code> oder <code>{error, Reason}</code> .  Ein Beispiel zur Veranschaulichung des Verhaltens: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([error_m || Hdl &lt;- file:open(Path, Modes), Data &lt;- file:read(Hdl, BytesToRead), file:write(Hdl, DataToWrite), file:sync(Hdl), file:close(Hdl), file:rename(Path, Path2), file:delete(Path), return(Data)])</span></span></span><span class="hljs-function">.</span></span></code> </pre> <br><h2 id="import_as">  Import_as </h2><br><p>  F√ºr einen Snack haben wir die Syntax import_as Zucker.  Mit der Standardsyntax f√ºr das Attribut -import / 2 k√∂nnen Sie Funktionen von anderen in das lokale Modul importieren.  Mit dieser Syntax k√∂nnen Sie der importierten Funktion jedoch keinen alternativen Namen zuweisen.  Import_as l√∂st dieses Problem: </p><br><pre> <code class="erlang hljs">-import_as<span class="hljs-params"><span class="hljs-params">({my_mod, [{size/</span><span class="hljs-number"><span class="hljs-params"><span class="hljs-number">1</span></span></span><span class="hljs-params">, m_size}]})</span></span> -import_as<span class="hljs-params"><span class="hljs-params">({my_other_mod, [{size/</span><span class="hljs-number"><span class="hljs-params"><span class="hljs-number">1</span></span></span><span class="hljs-params">, o_size}]})</span></span></code> </pre> <br><p>  Diese Ausdr√ºcke werden jeweils zu realen lokalen Funktionen erweitert: </p><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function"> -&gt;</span></span> my_mod:size(A). o_size(A) -&gt; my_other_mod:size(A).</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Mit Monaden k√∂nnen Sie den Berechnungsprozess nat√ºrlich mit aussagekr√§ftigeren Methoden steuern, Code und Zeit sparen, um ihn zu unterst√ºtzen.  Auf der anderen Seite erh√∂hen sie die Komplexit√§t untrainierter Teammitglieder. </p><br><p>  <strong>*</strong> - in der Tat existieren in Erlang Monaden ohne Erlando.  Ein Komma, das Ausdr√ºcke trennt, ist eine Konstruktion zum Linearisieren und Verkn√ºpfen von Berechnungen. </p><br><p>  PS Vor kurzem wurde die Erlando-Bibliothek von den Autoren als Archiv markiert.  Ich habe diesen Artikel vor mehr als einem Jahr geschrieben.  Damals wie heute gab es auf Habr√© jedoch keine Informationen √ºber Monaden in Erlang.  Um dieser Situation abzuhelfen, ver√∂ffentliche ich diesen Artikel, wenn auch versp√§tet. <br>  Um erlando in erlang&gt; = 22 zu verwenden, m√ºssen Sie das Problem mit veraltetem erlang beheben: get_stacktrace / 0.  Ein Beispiel f√ºr einen Fix finden Sie in meiner Gabel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/Vonmo/erlando/commit/52e23ecedd2b8c13707a11c7f0f14496b5a191c2</a> </p><br><p>  Danke f√ºr deine Zeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de466697/">https://habr.com/ru/post/de466697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de466683/index.html">Digitale Veranstaltungen in Moskau vom 9. bis 15. September</a></li>
<li><a href="../de466685/index.html">Geld sehen</a></li>
<li><a href="../de466689/index.html">So erstellen Sie Zeichenklassen in der mobilen MMO-Aktion</a></li>
<li><a href="../de466691/index.html">Also alle gleich RAML oder OAS (Swagger)?</a></li>
<li><a href="../de466693/index.html">Wenn Sie nicht in die IT eingeben</a></li>
<li><a href="../de466699/index.html">Z√§hmen von Vertrauensprotokollen - OAuth-Authentifizierung mit InterSystems IRIS</a></li>
<li><a href="../de466701/index.html">Let's Encrypt bedient fast 30% der Domains</a></li>
<li><a href="../de466705/index.html">Vivaldi Beta f√ºr Android - Echter Browser</a></li>
<li><a href="../de466709/index.html">Entwicklung einer monolithischen Unix-√§hnlichen OS-C-Bibliothek (2)</a></li>
<li><a href="../de466711/index.html">Sicherheitsl√ºcke DaOffice darf jeden Benutzer aus dem sozialen Netzwerk entfernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>