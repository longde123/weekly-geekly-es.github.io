<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱅 游 游깷 Organizaci칩n de la interacci칩n efectiva de microservicios. 游붊 游뛆 游댏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, las arquitecturas de microservicios han gozado de cierta popularidad. El rendimiento y la escalabilidad de las soluciones basadas en el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Organizaci칩n de la interacci칩n efectiva de microservicios.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/421579/">  Recientemente, las arquitecturas de microservicios han gozado de cierta popularidad.  El rendimiento y la escalabilidad de las soluciones basadas en ellos pueden depender de c칩mo interact칰an los microservicios.  Esta interacci칩n puede ser sincr칩nica o asincr칩nica.  El material, cuya traducci칩n presentamos hoy a su atenci칩n, analiza m칠todos sincr칩nicos para la interacci칩n de microservicios.  Es decir, nos centraremos en el estudio de dos tecnolog칤as: HTTP / 1.1 y gRPC.  La primera tecnolog칤a est치 representada por llamadas HTTP est치ndar.  El segundo se basa en el uso del marco RPC de alto rendimiento de Google.  El autor del art칤culo sugiere mirar el c칩digo necesario para implementar la interacci칩n de microservicios utilizando HTTP / 1.1 y gRPC, tomar medidas de rendimiento y elegir una tecnolog칤a que permita organizar el intercambio de datos entre microservicios de la mejor manera. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/8f/rs/wi/8frswixgdwda7hy0qyauot2ze0c.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Aplicaci칩n normal</font> </h2><br>  Comencemos peque침o y creemos un sistema de dos microservicios que puedan interactuar entre s칤.  Tenga en cuenta que el modo de cl칰ster no se usa aqu칤.  Aqu칤 hay un diagrama de nuestra aplicaci칩n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e7/4d1/da1/5e74d1da16523f9fbd60e31e08db4fe4.png"></div><br>  <i><font color="#999999">Arquitectura de aplicaci칩n t칤pica</font></i> <br><br>  La aplicaci칩n consta de los siguientes componentes: <br><br><ul><li>  Herramienta de prueba del sistema: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jMeter</a> . </li><li>  Servicio A: un microservicio que ejecuta solicitudes para el servicio B y devuelve las respuestas recibidas del mismo. </li><li>  Servicio B (Servicio B): un microservicio que env칤a datos JSON est치ticos en respuesta a solicitudes despu칠s de un retraso de 10 milisegundos, utilizado para todas sus API. </li><li>  M치quinas virtuales (VM 1 y VM 2): instancias Amazon EC2 t2.xlarge. </li></ul><br><h3>  <font color="#3AC1EF">郊껟TTP / 1.1</font> </h3><br>  HTTP / 1.1 es una tecnolog칤a est치ndar para organizar la interacci칩n de microservicios, que se utiliza cuando se utilizan bibliotecas HTTP como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">axios</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superagent</a> . <br><br>  Aqu칤 est치 el c칩digo de servicio B que implementa la API de nuestro sistema: <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">server</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.route</span></span>({  <span class="hljs-attribute"><span class="hljs-attribute">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>,  path: <span class="hljs-string"><span class="hljs-string">'/'</span></span>,  handler: async (request, h) =&gt; {    const response = await new <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>((resolve) =&gt; {      <span class="hljs-built_in"><span class="hljs-built_in">setTimeout</span></span>(() =&gt; {        <span class="hljs-built_in"><span class="hljs-built_in">resolve</span></span>({          id: 1,          name: <span class="hljs-string"><span class="hljs-string">'Abhinav Dhasmana'</span></span>,          enjoys_coding: true,        });      }, 10);    });    <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.response</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">response</span></span>);  }, });</code> </pre> <br>  Aqu칤 est치 el c칩digo para el servicio A que accede al servicio B usando HTTP / 1.1: <br><br><pre> <code class="hljs cs">server.route({ method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, handler: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (request, h) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Axios({ url: <span class="hljs-string"><span class="hljs-string">'http://localhost:8001/'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h.response(response.data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Boom.clientTimeout(err); } }, });</code> </pre> <br>  Al ejecutar estos microservicios, podemos aprovechar jMeter para ejecutar pruebas de rendimiento.  Descubriremos c칩mo se comporta el sistema cuando trabaje con 50 usuarios, cada uno de los cuales realiza 2000 solicitudes.  Como se puede ver en la siguiente figura, la mediana de los resultados de la medici칩n es de 37 ms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/d94/aea/2ebd94aea7752eb87d25f2c4cbdfdd1a.png"></div><br>  <i><font color="#999999">Resultados de la investigaci칩n de un sistema en modo normal usando HTTP / 1.1 usando jMeter</font></i> <br><br><h3>  <font color="#3AC1EF">郊껺RPC</font> </h3><br>  gRPC utiliza la tecnolog칤a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Protocol Buffers</a> de forma predeterminada.  Por lo tanto, usando gRPC, adem치s del c칩digo de dos servicios, necesitaremos escribir el c칩digo de protoarchivo, que describe la interfaz entre los m칩dulos del sistema. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> SampleDataService { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GetSampleData (Empty) returns (SampleData) {} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> SampleData { <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">bool</span></span> enjoys_coding = <span class="hljs-number"><span class="hljs-number">3</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Empty {}</code> </pre> <br>  Ahora, dado que ahora planeamos usar gRPC, necesitamos reescribir el c칩digo de servicio B: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> grpc = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'grpc'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proto = grpc.load(<span class="hljs-string"><span class="hljs-string">'serviceB.proto'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> grpc.Server(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GetSampleData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">call, callback</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, {     <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>,     <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Abhinav Dhasmana'</span></span>,     <span class="hljs-attr"><span class="hljs-attr">enjoys_coding</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span>); }; server.addService(proto.SampleDataService.service, { GetSampleData, }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> port = process.env.PORT; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'port'</span></span>, port); server.bind(<span class="hljs-string"><span class="hljs-string">`0.0.0.0:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${port}</span></span></span><span class="hljs-string">`</span></span>, grpc.ServerCredentials.createInsecure()); server.start(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'grpc server is running'</span></span>);</code> </pre> <br>  Presta atenci칩n a algunas caracter칤sticas de este c칩digo: <br><br><ul><li>  El comando <code>const server = new grpc.Server();</code>  creamos un servidor grpc. </li><li>  <code>server.addService(proto...</code> comando <code>server.addService(proto...</code> agregamos el servicio al servidor. </li><li>  El comando <code>server.bind(`0.0.0.0:${port}...</code> se usa para vincular el puerto y las credenciales. </li></ul><br>  Ahora reescriba el servicio A usando gRPC: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> protoPath = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/../serviceB/serviceB.proto`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> proto = grpc.load(protoPath); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> proto.SampleDataService(<span class="hljs-string"><span class="hljs-string">'localhost:8001'</span></span>, grpc.credentials.createInsecure()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getDataViagRPC = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { client.GetSampleData({}, (err, response) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!response.err) {     resolve(response);   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     reject(err);   } }); }); server.route({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">handler</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (request, h) =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allResults = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getDataViagRPC();   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> h.response(allResults); }, });</code> </pre> <br>  Entre las caracter칤sticas de este c칩digo est치n las siguientes: <br><br><ul><li>  <code>const client = new proto.SampleDataService...</code> comando <code>const client = new proto.SampleDataService...</code> creamos un cliente grpc. </li><li>  Se realiza una llamada remota utilizando el <code>client.GetSampleData({}...</code> </li></ul><br>  Ahora probemos lo que tenemos con jMeter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/48d/3c3/d1148d3c34e8b4b5fbdd62fbf546863c.png"></div><br>  <i><font color="#999999">Resultados de la investigaci칩n de un sistema en modo normal usando gRPC usando jMeter</font></i> <br><br>  Despu칠s de c치lculos simples, puede descubrir que una soluci칩n que usa gRPC es un 27% m치s r치pida que una soluci칩n que usa HTTP / 1.1. <br><br><h2>  <font color="#3AC1EF">Aplicaci칩n de cl칰ster</font> </h2><br>  Aqu칤 hay un diagrama de una aplicaci칩n similar a la que acabamos de investigar pero que funciona en modo de cl칰ster. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/2d0/d0b/72e2d0d0bd3566507d10a35e9b63f518.png"></div><br>  <i><font color="#999999">Arquitectura de aplicaci칩n en modo de cl칰ster</font></i> <br><br>  Si compara esta arquitectura con la considerada anteriormente, se pueden observar los siguientes cambios: <br><br><ul><li>  Hay un equilibrador de carga (Load Balancer), que usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NGINX</a> . </li><li>  El servicio B ahora est치 presente en tres instancias que escuchan en diferentes puertos. </li></ul><br>  Una arquitectura similar es t칤pica para proyectos reales. <br><br>  Explorando HTTP / 1.1 y gRPC en un nuevo entorno. <br><br><h3>  <font color="#3AC1EF">郊껟TTP / 1.1</font> </h3><br>  Cuando se utilizan microservicios que usan HTTP / 1.1 en un entorno en cl칰ster, su c칩digo no tendr치 que modificarse.  Solo necesita configurar nginx para organizar el equilibrio del tr치fico del servicio B. En nuestro caso, para hacer esto, necesita traer el <code>/etc/nginx/sites-available/default</code> a este formulario: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> httpservers {  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8001</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8002</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8003</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> {  <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / {     <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://httpservers;  } }</code> </pre> <br>  Ahora veamos lo que tenemos y veamos los resultados de probar el sistema usando jMeter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/fe5/3b6/113fe53b66aab039270b109b9f570e6b.png"></div><br>  <i><font color="#999999">Resultados de investigaci칩n para un sistema basado en cl칰ster que utiliza HTTP / 1.1 con jMeter</font></i> <br><br>  La mediana en este caso es de 41 ms. <br><br><h3>  <font color="#3AC1EF">郊껺RPC</font> </h3><br>  El soporte GRPC apareci칩 en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nginx 1.13.10</a> .  Por lo tanto, necesitamos la 칰ltima versi칩n de nginx, para cuya <code>sudo apt-get install nginx</code> comando <code>sudo apt-get install nginx</code> habitual no es adecuado. <br><br>  Tambi칠n aqu칤 no utilizamos Node.js en modo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cl칰ster</a> , ya que gRPC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compatible</a> con este modo. <br><br>  Para instalar la 칰ltima versi칩n de nginx, use la siguiente secuencia de comandos: <br><br><pre> <code class="hljs powershell">sudo apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install <span class="hljs-literal"><span class="hljs-literal">-y</span></span> software<span class="hljs-literal"><span class="hljs-literal">-properties</span></span><span class="hljs-literal"><span class="hljs-literal">-common</span></span> sudo <span class="hljs-built_in"><span class="hljs-built_in">add-apt</span></span><span class="hljs-literal"><span class="hljs-literal">-repository</span></span> ppa:nginx/stable sudo apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> update sudo apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install nginx</code> </pre> <br>  Adem치s, necesitaremos certificados SSL.  Se puede crear un certificado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">autofirmado</a> usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">openSSL</a> : <br><br><pre> <code class="hljs powershell">openssl req <span class="hljs-literal"><span class="hljs-literal">-x509</span></span> <span class="hljs-literal"><span class="hljs-literal">-newkey</span></span> rsa:<span class="hljs-number"><span class="hljs-number">2048</span></span> <span class="hljs-literal"><span class="hljs-literal">-nodes</span></span> <span class="hljs-literal"><span class="hljs-literal">-sha256</span></span> <span class="hljs-literal"><span class="hljs-literal">-subj</span></span> <span class="hljs-string"><span class="hljs-string">'/CN=localhost'</span></span> \ <span class="hljs-literal"><span class="hljs-literal">-keyout</span></span> localhost<span class="hljs-literal"><span class="hljs-literal">-privatekey</span></span>.pem <span class="hljs-literal"><span class="hljs-literal">-out</span></span> localhost<span class="hljs-literal"><span class="hljs-literal">-certificate</span></span>.pem</code> </pre> <br>  Para usar gRPC, debe editar el archivo / <code>etc/nginx/sites-available/default</code> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> httpservers {  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8001</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8002</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> ip_address:<span class="hljs-number"><span class="hljs-number">8003</span></span>; } <span class="hljs-section"><span class="hljs-section">server</span></span> {  <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>;  <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / {     <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://httpservers;  } }</code> </pre> <br>  Ahora todo est치 listo para probar la soluci칩n gRPC de cl칰ster utilizando jMeter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/618/666/8d2618666f9a8593328d15850271803e.png"></div><br>  <i><font color="#999999">Resultados de un sistema en modo de cl칰ster usando gRPC usando jMeter</font></i> <br><br>  En este caso, la mediana es de 28 ms, que es un 31% m치s r치pida en comparaci칩n con el mismo indicador obtenido al examinar una soluci칩n HTTP / 1.1 agrupada. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Los resultados del estudio muestran que una aplicaci칩n basada en microservicios que usa gRPC es aproximadamente un 30% m치s productiva que una aplicaci칩n similar que usa HTTP / 1.1 para intercambiar datos entre microservicios.  El c칩digo fuente de los proyectos discutidos en este art칤culo se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . <br><br>  <b>Estimados lectores!</b>  Si est치 desarrollando microservicios, hable acerca de c칩mo organizar el intercambio de datos entre ellos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421579/">https://habr.com/ru/post/es421579/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421569/index.html">Lo m치s importante con Gamescom 2018: Nvidia RTX, Cyberpunk 2077, Metro Exodus</a></li>
<li><a href="../es421571/index.html">Kivy Xamarin Reaccionar nativo. Tres marcos: un experimento (parte 3)</a></li>
<li><a href="../es421573/index.html">Food Design Digest Agosto 2018</a></li>
<li><a href="../es421575/index.html">La confrontaci칩n entre Yandex y Roskomnadzor madura</a></li>
<li><a href="../es421577/index.html">Se publica un exploit para una vulnerabilidad no cerrada en el Programador de tareas de Windows (traducci칩n)</a></li>
<li><a href="../es421583/index.html">쮻칩nde ir a la universidad para estudiar para un especialista en TI? + encuesta</a></li>
<li><a href="../es421585/index.html">쮺칩mo decidi칩 el concurso retro cosacos</a></li>
<li><a href="../es421587/index.html">[Ekaterimburgo, anuncio] Java Mitap - JUG.EKB</a></li>
<li><a href="../es421589/index.html">Metamorfosis: programaci칩n molecular de la forma.</a></li>
<li><a href="../es421591/index.html">Sistema de presupuesto para video vigilancia inal치mbrica (Wi-Fi) aut칩noma (desde bater칤a)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>