<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ ğŸ“¢ ğŸ‘¨ğŸ¿â€ğŸ”¬ ä¸‰é˜¶æ¨¡æ¿ï¼Œæˆ–è€…æˆ‘å¦‚ä½•å°†Jinja2ç§»æ¤åˆ°C ++ ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦ ğŸ§šğŸ» ğŸ‘‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="åœ¨C ++ä¸Šä¸‹æ–‡ä¸­ï¼Œâ€œæ¨¡å¼â€é€šå¸¸æ˜¯æŒ‡éå¸¸ç‰¹å®šçš„è¯­è¨€æ„é€ ã€‚ æœ‰ä¸€äº›ç®€å•çš„æ¨¡æ¿å¯ç®€åŒ–ä½¿ç”¨ç›¸åŒç±»å‹çš„ä»£ç çš„å·¥ä½œ-è¿™äº›æ˜¯ç±»å’Œå‡½æ•°æ¨¡æ¿ã€‚ å¦‚æœæ¨¡æ¿æœ¬èº«å…·æœ‰å‚æ•°ä¹‹ä¸€ï¼Œåˆ™å¯ä»¥è¯´æ˜¯äºŒé˜¶æ¨¡æ¿ï¼Œå¹¶ä¸”æ¨¡æ¿ä¼šæ ¹æ®å…¶å‚æ•°ç”Ÿæˆå…¶ä»–æ¨¡æ¿ã€‚ ä½†æ˜¯ï¼Œå¦‚æœä»–ä»¬çš„èƒ½åŠ›ä¸è¶³ä¸”æ›´å®¹æ˜“ç«‹å³ç”Ÿæˆæºæ–‡æœ¬ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿ å¾ˆå¤šæºä»£ç ï¼Ÿ 
 Python...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ä¸‰é˜¶æ¨¡æ¿ï¼Œæˆ–è€…æˆ‘å¦‚ä½•å°†Jinja2ç§»æ¤åˆ°C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416581/"><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Jinja2å¾½æ ‡" align="left"> åœ¨C ++ä¸Šä¸‹æ–‡ä¸­ï¼Œâ€œæ¨¡å¼â€é€šå¸¸æ˜¯æŒ‡éå¸¸ç‰¹å®šçš„è¯­è¨€æ„é€ ã€‚ æœ‰ä¸€äº›ç®€å•çš„æ¨¡æ¿å¯ç®€åŒ–ä½¿ç”¨ç›¸åŒç±»å‹çš„ä»£ç çš„å·¥ä½œ-è¿™äº›æ˜¯ç±»å’Œå‡½æ•°æ¨¡æ¿ã€‚ å¦‚æœæ¨¡æ¿æœ¬èº«å…·æœ‰å‚æ•°ä¹‹ä¸€ï¼Œåˆ™å¯ä»¥è¯´æ˜¯äºŒé˜¶æ¨¡æ¿ï¼Œå¹¶ä¸”æ¨¡æ¿ä¼šæ ¹æ®å…¶å‚æ•°ç”Ÿæˆå…¶ä»–æ¨¡æ¿ã€‚ ä½†æ˜¯ï¼Œå¦‚æœä»–ä»¬çš„èƒ½åŠ›ä¸è¶³ä¸”æ›´å®¹æ˜“ç«‹å³ç”Ÿæˆæºæ–‡æœ¬ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿ å¾ˆå¤šæºä»£ç ï¼Ÿ <br>  Pythonå’ŒHTMLå¸ƒå±€çš„è¿·ä»¬ç†Ÿæ‚‰ç”¨äºå¤„ç†åä¸º<b>Jinja2çš„</b>æ–‡æœ¬æ¨¡æ¿çš„å·¥å…·ï¼ˆå¼•æ“ï¼Œåº“ï¼‰ã€‚ åœ¨è¾“å…¥ç«¯ï¼Œæ­¤å¼•æ“æ¥æ”¶ä¸€ä¸ªæ¨¡æ¿æ–‡ä»¶ï¼Œåœ¨è¯¥æ–‡ä»¶ä¸­å¯ä»¥å°†æ–‡æœ¬ä¸æ§åˆ¶ç»“æ„æ··åˆï¼Œè¾“å‡ºæ˜¯çº¯æ–‡æœ¬ï¼Œå…¶ä¸­æ‰€æœ‰æ§ä»¶ç»“æ„å‡æ ¹æ®å¤–éƒ¨ï¼ˆæˆ–å†…éƒ¨ï¼‰æŒ‡å®šçš„å‚æ•°æ›¿æ¢ä¸ºæ–‡æœ¬ã€‚ ç²—ç•¥åœ°è¯´ï¼Œè¿™ç±»ä¼¼äºASPé¡µé¢ï¼ˆæˆ–C ++-é¢„å¤„ç†ç¨‹åºï¼‰ï¼Œåªæ˜¯æ ‡è®°è¯­è¨€ä¸åŒã€‚ <br> åˆ°ç›®å‰ä¸ºæ­¢ï¼Œè¯¥å¼•æ“çš„å®ç°ä»…é€‚ç”¨äºPythonã€‚ ç°åœ¨é€‚ç”¨äºC ++ã€‚ å…³äºå®ƒå‘ç”Ÿçš„æ–¹å¼å’ŒåŸå› ï¼Œå¹¶å°†åœ¨æœ¬æ–‡ä¸­è¿›è¡Œè®¨è®ºã€‚ <br><a name="habracut"></a><br><h2> æˆ‘ä¸ºä»€ä¹ˆè¿˜è¦æ‹¿è¿™ä¸ª </h2><br> ç¡®å®ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿ æ¯•ç«Ÿï¼Œæœ‰äº†Pythonï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡ºè‰²çš„å®ç°ï¼Œä¸€ç³»åˆ—åŠŸèƒ½ä»¥åŠè¯¥è¯­è¨€çš„å®Œæ•´è§„èŒƒã€‚ éšèº«æºå¸¦ï¼ æˆ‘ä¸å–œæ¬¢Python-åœ¨C ++ä¸­å¯ä»¥ä½¿ç”¨<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jinja2CppLight</a>æˆ–<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">inja</a> ï¼ˆéƒ¨åˆ†Jinja2ç«¯å£ï¼‰ã€‚ æœ€åï¼Œæ‚¨å¯ä»¥ä½¿ç”¨C ++ç«¯å£{{ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mustache</a> }}ã€‚ åƒå¾€å¸¸ä¸€æ ·ï¼Œç»†èŠ‚å†³å®šæˆè´¥ã€‚ æ‰€ä»¥ï¼Œæ¯”æ–¹è¯´ï¼Œæˆ‘éœ€è¦Jinja2ä¸­çš„è¿‡æ»¤å™¨åŠŸèƒ½å’Œextendsç»“æ„çš„åŠŸèƒ½ï¼Œè¿™ä½¿æ‚¨å¯ä»¥åˆ›å»ºå¯æ‰©å±•çš„æ¨¡æ¿ï¼ˆä»¥åŠå®å’ŒåŒ…å«ï¼Œä½†ç¨åå†ä»‹ç»ï¼‰ã€‚ æ‰€æåˆ°çš„å®ç°å‡ä¸æ”¯æŒæ­¤åŠŸèƒ½ã€‚ æˆ‘èƒ½ä¸ç”¨æ‰€æœ‰è¿™äº›å—ï¼Ÿ ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é—®é¢˜ã€‚ è‡ªå·±åˆ¤æ–­ã€‚ æˆ‘æœ‰ä¸€ä¸ª<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">é¡¹ç›®ï¼Œ</a>å…¶ç›®æ ‡æ˜¯åˆ›å»ºC ++-to-C ++æ ·æ¿ä»£ç ç”Ÿæˆå™¨ã€‚ ä¾‹å¦‚ï¼Œæ­¤è‡ªåŠ¨ç”Ÿæˆå™¨æ¥æ”¶å¸¦æœ‰ç»“æ„æˆ–æšä¸¾çš„æ‰‹åŠ¨ç¼–å†™çš„å¤´æ–‡ä»¶ï¼Œå¹¶åŸºäºè¯¥è‡ªåŠ¨ç”Ÿæˆå™¨ç”Ÿæˆåºåˆ—åŒ–/ååºåˆ—åŒ–çš„åŠŸèƒ½ï¼Œæˆ–è€…å°†æšä¸¾å…ƒç´ è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼ˆåä¹‹äº¦ç„¶ï¼‰ã€‚ æ‚¨å¯ä»¥åœ¨æˆ‘çš„æŠ¥å‘Šï¼ˆengï¼‰æˆ–<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">è¿™é‡Œ</a> ï¼ˆrusï¼‰ä¸­æ”¶å¬æœ‰å…³æ­¤å®ç”¨ç¨‹åºçš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚ <br> å› æ­¤ï¼Œåœ¨ä½¿ç”¨è¯¥å®ç”¨ç¨‹åºçš„è¿‡ç¨‹ä¸­è§£å†³çš„å…¸å‹ä»»åŠ¡æ˜¯åˆ›å»ºå¤´æ–‡ä»¶ï¼Œæ¯ä¸ªå¤´æ–‡ä»¶éƒ½æœ‰ä¸€ä¸ªå¤´æ–‡ä»¶ï¼ˆåŒ…å«ifdefså’Œincludeï¼‰ï¼Œä¸€ä¸ªåŒ…å«ä¸»è¦å†…å®¹çš„ä¸»ä½“å’Œä¸€ä¸ªé¡µè„šã€‚ æ­¤å¤–ï¼Œä¸»è¦å†…å®¹æ˜¯åç§°ç©ºé—´å¡æ»¡çš„ç”Ÿæˆçš„å£°æ˜ã€‚ åœ¨C ++æ‰§è¡Œä¸­ï¼Œç”¨äºåˆ›å»ºæ­¤ç±»å¤´æ–‡ä»¶çš„ä»£ç å¦‚ä¸‹ï¼ˆå¹¶éå…¨éƒ¨ï¼‰ï¼š <br><div class="spoiler">  <b class="spoiler_title">å¾ˆå¤šC ++ä»£ç </b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Enum2StringGenerator::WriteHeaderContent(CppSourceStream &amp;hdrOs) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;reflection::EnumInfoPtr&gt; enums; WriteNamespaceContents(hdrOs, m_namespaces.GetRootNamespace(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;enums](CppSourceStream &amp;os, reflection::NamespaceInfoPtr ns) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; enumInfo : ns-&gt;enums) { WriteEnumToStringConversion(os, enumInfo); WriteEnumFromStringConversion(os, enumInfo); enums.push_back(enumInfo); } }); hdrOs &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>; { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace flex_lib"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline const char* Enum2String($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline $enumFullQualifiedName$ String2Enum&lt;$enumFullQualifiedName$&gt;(const char* itemName)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::StringTo$enumName$(itemName);"</span></span>; } } } { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace std"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline std::string to_string($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// Enum item to string conversion writer void Enum2StringGenerator::WriteEnumToStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto scopedParams = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline const char* $enumName$ToString($enumScopedName$ e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope switchScope("switch (e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; switchScope; out::OutParams innerParams; for (auto&amp; i : enumDescr-&gt;items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(-1) &lt;&lt; "case $prefix$$itemName$:" &lt;&lt; out::new_line(1) &lt;&lt; "return \"$itemName$\";"; } } hdrOs &lt;&lt; out::new_line(1) &lt;&lt; "return \"Unknown Item\";"; } // String to enum conversion writer void Enum2StringGenerator::WriteEnumFromStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto params = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline $enumScopedName$ StringTo$enumName$(const char* itemName)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope itemsScope("static std::pair&lt;const char*, $enumScopedName$&gt; items[] = ", ";\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; itemsScope; out::OutParams&amp; innerParams = params.GetParams(); auto items = enumDescr-&gt;items; std::sort(begin(items), end(items), [](auto&amp; i1, auto&amp; i2) {return i1.itemName &lt; i2.itemName;}); for (auto&amp; i : items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(1) &lt;&lt; "{\"$itemName$\", $prefix$$itemName$},"; } } hdrOs &lt;&lt; out::with_params(params.GetParams()) &lt;&lt; R"( $enumScopedName$ result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "$enumName$"); return result;)"; }</span></span></code> </pre> <br>  <a href="">ä»è¿™é‡Œ</a> ã€‚ <br></div></div><br> è€Œä¸”ï¼Œæ­¤ä»£ç åœ¨æ–‡ä»¶ä¹‹é—´å‡ ä¹æ²¡æœ‰å˜åŒ–ã€‚ å½“ç„¶ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨clang-formatè¿›è¡Œæ ¼å¼åŒ–ã€‚ ä½†è¿™å¹¶ä¸ä¼šå–æ¶ˆå…¶ä½™æœ‰å…³ç”Ÿæˆæºæ–‡æœ¬çš„æ‰‹åŠ¨å·¥ä½œã€‚ <br> ç„¶åä¸€ä¸ªç¾å¥½çš„æ—¶åˆ»ï¼Œæˆ‘æ„è¯†åˆ°åº”è¯¥ç®€åŒ–æˆ‘çš„ç”Ÿæ´»ã€‚ ç”±äºæ”¯æŒæœ€ç»ˆç»“æœçš„å¤æ‚æ€§ï¼Œæˆ‘ä¸è€ƒè™‘ä½¿ç”¨æˆç†Ÿçš„è„šæœ¬è¯­è¨€ã€‚ ä½†æ˜¯è¦æ‰¾åˆ°åˆé€‚çš„æ¨¡æ¿å¼•æ“-ä¸ºä»€ä¹ˆä¸å‘¢ï¼Ÿ æˆ‘å‘ç°å®ƒå¯¹æœç´¢å¾ˆæœ‰ç”¨ï¼Œå‘ç°äº†å®ƒï¼Œç„¶åæˆ‘å‘ç°äº†Jinja2è§„èŒƒï¼Œå¹¶æ„è¯†åˆ°è¿™æ­£æ˜¯æˆ‘æ‰€éœ€è¦çš„ã€‚ æŒ‰ç…§æ­¤è§„èŒƒï¼Œç”¨äºç”Ÿæˆæ ‡å¤´çš„æ¨¡æ¿å¦‚ä¸‹æ‰€ç¤ºï¼š <br><pre> <code class="cpp hljs">{% extends <span class="hljs-string"><span class="hljs-string">"header_skeleton.j2tpl"</span></span> %} {% block generator_headers %} <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;flex_lib/stringized_enum.h&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; {% endblock %} {% block namespaced_decls %}{{super()}}{% endblock %} {% block namespace_content %} {% for enum in ns.enums | sort(attribute="name") %} {% set enumName = enum.name %} {% set scopeSpec = enum.scopeSpecifier %} {% set scopedName = scopeSpec ~ ('::' if scopeSpec) ~ enumName %} {% set prefix = (scopedName + '::') if not enumInfo.isScoped else (scopedName ~ '::' ~ scopeSpec ~ ('::' if scopeSpec)) %} inline const char* {{enumName}}ToString({{scopedName}} e) { switch (e) { {% for itemName in enum.items | map(attribute="itemName") | sort%} case {{prefix}}{{itemName}}: return "{{itemName}}"; {% endfor %} } return "Unknown Item"; } inline {{scopedName}} StringTo{{enumName}}(const char* itemName) { static std::pair&lt;const char*, {{scopedName}}&gt; items[] = { {% for itemName in enum.items | map(attribute="itemName") | sort %} {"{{itemName}}", {{prefix}}{{itemName}} } {{',' if not loop.last }} {% endfor %} }; {{scopedName}} result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "{{enumName}}"); return result; } {% endfor %}{% endblock %} {% block global_decls %} {% for ns in [rootNamespace] recursive %} {% for enum in ns.enums %} template&lt;&gt; inline const char* flex_lib::Enum2String({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } template&lt;&gt; inline {{enum.fullQualifiedName}} flex_lib::String2Enum&lt;{{enum.fullQualifiedName}}&gt;(const char* itemName) { return {{enum.namespaceQualifier}}::StringTo{{enum.name}}(itemName); } inline std::string to_string({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } {% endfor %} {{loop(ns.namespaces)}} {% endfor %} {% endblock %}</span></span></span></span></code> </pre> <br>  <a href="">ä»è¿™é‡Œ</a> ã€‚ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/7d6/5da/c987d65da32b047a4eb3d2b7630fb99c.jpg" alt="å›¾ç‰‡" align="right" width="50%"> åªæœ‰ä¸€ä¸ªé—®é¢˜ï¼šæˆ‘å‘ç°æ²¡æœ‰ä¸€ä¸ªå¼•æ“æ”¯æŒæˆ‘æ‰€éœ€çš„å…¨éƒ¨åŠŸèƒ½ã€‚ å¥½å§ï¼Œå½“ç„¶ï¼Œæ¯ä¸ªäººéƒ½æœ‰ä¸€ä¸ª<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">è‡´å‘½</a>çš„æ ‡å‡†<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ç¼ºé™·</a> ã€‚ æˆ‘ç¨å¾®æƒ³äº†ä¸€ä¸‹ï¼Œå¹¶å†³å®šå¦ä¸€ä¸ªä¸–ç•Œä¸ä¼šå› ä¸ºæ¨¡æ¿å¼•æ“çš„å¦ä¸€ä¸ªå®ç°è€Œå˜å¾—æ›´ç³Ÿã€‚ è€Œä¸”ï¼Œæ®ä¼°è®¡ï¼ŒåŸºæœ¬åŠŸèƒ½å¹¶ä¸æ˜¯å¾ˆéš¾å®ç°ã€‚ æ¯•ç«Ÿï¼Œç°åœ¨åœ¨C ++ä¸­æœ‰æ­£åˆ™è¡¨è¾¾å¼ï¼ <br> è¿™æ ·<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Jinja2Cpp</a>é¡¹ç›®<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">å°±è¯ç”Ÿäº†</a> ã€‚ æˆ‘å‡ ä¹çŒœåˆ°æ˜¯ä»¥å®ç°åŸºæœ¬ï¼ˆéå¸¸åŸºç¡€ï¼‰åŠŸèƒ½çš„å¤æ‚æ€§ä¸ºä»£ä»·çš„ã€‚ æ€»ä½“è€Œè¨€ï¼Œæˆ‘ç¡®å®é”™è¿‡äº†Piç³»æ•°çš„å¹³æ–¹ï¼šæˆ‘èŠ±äº†ä¸åˆ°ä¸‰ä¸ªæœˆçš„æ—¶é—´æ¥ç¼–å†™æ‰€éœ€çš„æ‰€æœ‰å†…å®¹ã€‚ ä½†æ˜¯ï¼Œå½“ä¸€åˆ‡å®Œæˆï¼Œå®Œæˆå¹¶æ’å…¥â€œè‡ªåŠ¨ç¼–ç¨‹å™¨â€åï¼Œæˆ‘æ„è¯†åˆ°è‡ªå·±æ²¡æœ‰ç™½è´¹ã€‚ å®é™…ä¸Šï¼Œä»£ç ç”Ÿæˆå®ç”¨ç¨‹åºæ”¶åˆ°äº†åŠŸèƒ½å¼ºå¤§çš„è„šæœ¬è¯­è¨€å’Œæ¨¡æ¿çš„ç»„åˆï¼Œä»è€Œä¸ºå…¶æ‰“å¼€äº†å…¨æ–°çš„å¼€å‘æœºä¼šã€‚ <br> æ³¨æ„ï¼šæˆ‘æœ‰ä¸ªä¸»æ„è¦ç´§å›ºPythonï¼ˆæˆ–Luaï¼‰ã€‚ ä½†æ˜¯ï¼Œç°æœ‰çš„æˆç†Ÿè„šæœ¬å¼•æ“éƒ½æ— æ³•è§£å†³ä»æ¨¡æ¿ç”Ÿæˆæ–‡æœ¬æ—¶çš„â€œå¼€ç®±å³ç”¨â€é—®é¢˜ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼ŒPythonä»ç„¶å¿…é¡»æ‹§ç´§ç›¸åŒçš„Jinja2ï¼Œä½†å¯¹äºLuaï¼Œåˆ™éœ€è¦å¯»æ‰¾ä¸åŒçš„ä¸œè¥¿ã€‚ ä¸ºä»€ä¹ˆæˆ‘éœ€è¦è¿™ä¸ªé¢å¤–çš„é“¾æ¥ï¼Ÿ <br><br><h2> è§£æå™¨å®ç° </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/570/463/d325704634011d586894096d9e09b20f.png" alt="å›¾ç‰‡" align="left" width="60%">  Jinja2æ¨¡æ¿çš„ç»“æ„èƒŒåçš„æƒ³æ³•éå¸¸ç®€å•ã€‚ å¦‚æœä¸€å¯¹â€œ {{â€ /â€œ}}â€ä¸­åŒ…å«çš„æ–‡æœ¬ä¸­æœ‰æŸäº›å†…å®¹ï¼Œåˆ™ä¸ºâ€œæŸç‰©â€-å¿…é¡»å¯¹å…¶æ±‚å€¼ï¼Œå°†å…¶è½¬æ¢ä¸ºæ–‡æœ¬è¡¨ç¤ºå½¢å¼å¹¶æ’å…¥æœ€ç»ˆç»“æœä¸­çš„è¡¨è¾¾å¼ã€‚ åœ¨â€œ {ï¼…â€ /â€œï¼…}â€å¯¹ä¸­ï¼Œæœ‰forï¼Œifï¼Œsetç­‰è¿ç®—ç¬¦ã€‚å¥½å§ï¼Œåœ¨â€œ {ï¼ƒâ€ /â€œï¼ƒ}â€ä¸­æœ‰æ³¨é‡Šã€‚ åœ¨ç ”ç©¶äº†Jinja2CppLightçš„å®ç°ä¹‹åï¼Œæˆ‘è®¤ä¸ºå°è¯•åœ¨æ¨¡æ¿æ–‡æœ¬ä¸­æ‰‹åŠ¨æ‰¾åˆ°æ‰€æœ‰è¿™äº›æ§åˆ¶ç»“æ„å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚ å› æ­¤ï¼Œæˆ‘ç”¨ä¸€ä¸ªç›¸å½“ç®€å•çš„æ­£åˆ™è¡¨è¾¾å¼æ­¦è£…è‡ªå·±ï¼šï¼ˆï¼ˆï¼ˆ\\\\\ï¼‰|ï¼ˆ\ {ï¼…ï¼‰|ï¼ˆï¼…\}ï¼‰|ï¼ˆ\ {ï¼ƒï¼‰|ï¼ˆï¼ƒ\}ï¼‰|ï¼ˆ\ nï¼‰ï¼‰ï¼Œåœ¨æ­¤å¸®åŠ©ä¸‹ï¼Œä»–å°†æ–‡æœ¬åˆ†æˆäº†å¿…è¦çš„ç‰‡æ®µã€‚ å¹¶å°†å…¶ç§°ä¸ºè§£æçš„ç²—ç•¥é˜¶æ®µã€‚ åœ¨å·¥ä½œçš„æœ€åˆé˜¶æ®µï¼Œè¿™ä¸ªæƒ³æ³•æ˜¾ç¤ºäº†å®ƒçš„æœ‰æ•ˆæ€§ï¼ˆæ˜¯çš„ï¼Œå®é™…ä¸Šï¼Œå®ƒä»ç„¶æ˜¾ç¤ºå‡ºæ¥ï¼‰ï¼Œä½†æ˜¯ï¼Œä»¥ä¸€ç§å¾ˆå¥½çš„æ–¹å¼ï¼Œå°†æ¥éœ€è¦å¯¹å…¶è¿›è¡Œé‡æ„ï¼Œå› ä¸ºç°åœ¨å¯¹æ¨¡æ¿æ–‡æœ¬æ–½åŠ äº†è¾ƒå°çš„é™åˆ¶ï¼šè½¬ä¹‰å¯¹â€œ {{â€å’Œæ–‡æœ¬ä¸­çš„â€œ}}â€ä¹Ÿè¢«â€œé¢å¤´â€å¤„ç†ã€‚ <br> åœ¨ç¬¬äºŒé˜¶æ®µï¼Œä»…è¯¦ç»†è§£æâ€œæ‹¬å·â€å†…çš„å†…å®¹ã€‚ åœ¨è¿™é‡Œï¼Œæˆ‘ä¸å¾—ä¸ä¿®è¡¥ã€‚ ä½¿ç”¨injaå’ŒJinja2CppLightï¼Œè¡¨è¾¾å¼è§£æå™¨éå¸¸ç®€å•ã€‚ åœ¨ç¬¬ä¸€ç§æƒ…å†µä¸‹-åœ¨åŒä¸€ä¸ªregexp'ahä¸Šï¼Œåœ¨ç¬¬äºŒç§æƒ…å†µä¸‹-æ‰‹å†™ï¼Œä½†æ˜¯ä»…æ”¯æŒéå¸¸ç®€å•çš„è®¾è®¡ã€‚ å¯¹è¿‡æ»¤å™¨ï¼Œæµ‹è¯•å™¨ï¼Œå¤æ‚çš„ç®—æœ¯æˆ–ç´¢å¼•çš„æ”¯æŒæ˜¯ä¸å¯èƒ½çš„ã€‚ è€Œæˆ‘æœ€æƒ³è¦çš„å°±æ˜¯Jinja2çš„è¿™äº›åŠŸèƒ½ã€‚ å› æ­¤ï¼Œæˆ‘åˆ«æ— é€‰æ‹©ï¼Œåªèƒ½é‡æ–°æ•´ç†ä¸€ä¸ªå®Œæ•´çš„LLï¼ˆ1ï¼‰è§£æå™¨ï¼ˆåœ¨æŸäº›åœ°æ–¹-ä¸Šä¸‹æ–‡ç›¸å…³ï¼‰ï¼Œä»¥å®ç°å¿…è¦çš„è¯­æ³•ã€‚ å¤§çº¦ååˆ°åäº”å¹´å‰ï¼Œæˆ‘å¯èƒ½ä¼šé€‰æ‹©Bisonæˆ–ANTLRå¹¶åœ¨ä»–ä»¬çš„å¸®åŠ©ä¸‹å®ç°è§£æå™¨ã€‚ å¤§çº¦ä¸ƒå¹´å‰ï¼Œæˆ‘ä¼šå°è¯•Boost.Spiritã€‚ ç°åœ¨ï¼Œæˆ‘é€šè¿‡é€’å½’ä¸‹é™æ–¹æ³•å®ç°äº†æˆ‘æ‰€éœ€çš„è§£æå™¨ï¼Œè€Œä¸ä¼šäº§ç”Ÿä¸å¿…è¦çš„ä¾èµ–å…³ç³»ï¼Œå¹¶ä¸”ä¸ä¼šæ˜¾ç€å¢åŠ ç¼–è¯‘æ—¶é—´ï¼Œå°±åƒä½¿ç”¨å¤–éƒ¨å®ç”¨ç¨‹åºæˆ–Boost.Spirité‚£æ ·ã€‚ åœ¨è§£æå™¨çš„è¾“å‡ºä¸­ï¼Œæˆ‘å¾—åˆ°äº†ä¸€ä¸ªASTï¼ˆç”¨äºè¡¨è¾¾å¼æˆ–è¿ç®—ç¬¦ï¼‰ï¼Œè¯¥ASTè¢«ä¿å­˜ä¸ºæ¨¡æ¿ï¼Œå‡†å¤‡ç”¨äºåç»­æ¸²æŸ“ã€‚ <br><div class="spoiler">  <b class="spoiler_title">è§£æé€»è¾‘çš„ä¸€ä¸ªä¾‹å­</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; ExpressionParser::ParseFullExpression(LexScanner &amp;lexer, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeIfPart) { ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; result; LexScanner::<span class="hljs-function"><span class="hljs-function">StateSaver </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lexer)</span></span></span></span>; ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; evaluator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;FullExpressionEvaluator&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> value = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetExpression(value); ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; filter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == <span class="hljs-string"><span class="hljs-string">'|'</span></span>) { lexer.EatToken(); filter = ParseFilterExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!filter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetFilter(filter); } ExpressionEvaluatorPtr&lt;IfExpression&gt; ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == Token::If) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeIfPart) { lexer.EatToken(); ifExpr = ParseIfExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ifExpr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetTester(ifExpr); } } saver.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluator; } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalOr(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalOr) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalOr, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalAnd(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalCompare(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalAnd) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalAnd, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalCompare(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tok = lexer.NextToken(); BinaryExpression::Operation operation; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (tok.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Equal: operation = BinaryExpression::LogicalEq; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::NotEqual: operation = BinaryExpression::LogicalNe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>: operation = BinaryExpression::LogicalLt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>: operation = BinaryExpression::LogicalGt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::GreaterEqual: operation = BinaryExpression::LogicalGe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::LessEqual: operation = BinaryExpression::LogicalLe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::In: operation = BinaryExpression::In; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Is: { Token nextTok = lexer.NextToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextTok != Token::Identifier) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name = AsString(nextTok.value); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; CallParams params; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() == <span class="hljs-string"><span class="hljs-string">'('</span></span>) params = ParseCallParams(lexer, valid); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!valid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;IsExpression&gt;(left, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(name), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params)); } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(operation, left, right); }</code> </pre> <br>  <a href="">ä»è¿™é‡Œ</a> ã€‚ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">ASTè¡¨è¾¾å¼æ ‘ç±»çš„ç‰‡æ®µ</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionFilter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfExpression</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FullExpressionEvaluator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExpressionEvaluatorBase { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;Expression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_expression = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_filter = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTester</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;IfExpression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_tester = expr; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream &amp;stream, RenderContext &amp;values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_expression; ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; m_filter; ExpressionEvaluatorPtr&lt;IfExpression&gt; m_tester; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueRefExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ValueRefExpression(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> valueName) : m_valueName(valueName) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_valueName; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubscriptExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SubscriptExpression(ExpressionEvaluatorPtr&lt;Expression&gt; value, ExpressionEvaluatorPtr&lt;Expression&gt; subscriptExpr) : m_value(value) , m_subscriptExpr(subscriptExpr) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_value; ExpressionEvaluatorPtr&lt;Expression&gt; m_subscriptExpr; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ConstantExpression(InternalValue constant) : m_constant(constant) {} <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_constant; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValue m_constant; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TupleCreator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TupleCreator(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; exprs) : m_exprs(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(exprs)) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; m_exprs; };</code> </pre> <br>  <a href="">ä»è¿™é‡Œ</a> ã€‚ <br></div></div><br><div class="spoiler">  <b class="spoiler_title">ASTæ ‘è¿ç®—ç¬¦çš„ç¤ºä¾‹ç±»</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Statement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RendererBase { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = Statement&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StatementPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CharT&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateImpl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ForStatement(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vars, ExpressionEvaluatorPtr&lt;&gt; expr, ExpressionEvaluatorPtr&lt;&gt; ifExpr, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRecursive) : m_vars(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(vars)) , m_value(expr) , m_ifExpr(ifExpr) , m_isRecursive(isRecursive) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElseBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> InternalValue&amp; val, OutStream&amp; os, RenderContext&amp; values)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; m_vars; ExpressionEvaluatorPtr&lt;&gt; m_value; ExpressionEvaluatorPtr&lt;&gt; m_ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isRecursive; RendererPtr m_mainBody; RendererPtr m_elseBody; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IfStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddElseBranch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatementPtr&lt;ElseBranchStatement&gt; branch)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBranches.push_back(branch); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StatementPtr&lt;ElseBranchStatement&gt;&gt; m_elseBranches; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ElseBranchStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldRender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; };</code> </pre><br>  <a href="">ä»è¿™é‡Œ</a> ã€‚ <br></div></div><br>  ASTèŠ‚ç‚¹ä»…ä¸æ¨¡æ¿çš„æ–‡æœ¬ç›¸å…³è”ï¼Œå¹¶åœ¨æ¸²æŸ“æ—¶è½¬æ¢ä¸ºæ€»å€¼ï¼ŒåŒæ—¶è€ƒè™‘åˆ°å½“å‰æ¸²æŸ“ä¸Šä¸‹æ–‡åŠå…¶å‚æ•°ã€‚ è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿåˆ›å»ºçº¿ç¨‹å®‰å…¨æ¨¡å¼ã€‚ ä½†æ˜¯å…³äºå®é™…æ¸²æŸ“çš„æ›´å¤šä¿¡æ¯ã€‚ <br> ä½œä¸ºä¸»è¦æ ‡è®°å™¨ï¼Œæˆ‘é€‰æ‹©äº†<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">lexertk</a>åº“ã€‚ å®ƒå…·æœ‰æˆ‘éœ€è¦çš„è®¸å¯è¯å’Œä»…æ ‡å¤´ã€‚ æ²¡é”™ï¼Œæˆ‘ä¸å¾—ä¸ä¸­æ–­æ‰€æœ‰è®¡ç®—æ–¹æ‹¬å·å¹³è¡¡çš„éº»çƒ¦ï¼Œåªå‰©ä¸‹äº†åˆ†è¯å™¨æœ¬èº«ï¼Œåè€…ï¼ˆåœ¨å¯¹æ–‡ä»¶ç¨åŠ æ•´ç†ä¹‹åï¼‰å­¦ä¼šäº†ä¸ä»…é€‚ç”¨äºcharï¼Œè€Œä¸”é€‚ç”¨äºwchar_tå­—ç¬¦ã€‚ åœ¨æ­¤æ ‡è®°ç¨‹åºç”Ÿæˆå™¨çš„é¡¶éƒ¨ï¼Œæˆ‘åŒ…è£…äº†å¦ä¸€ä¸ªç±»ï¼Œè¯¥ç±»æ‰§è¡Œä¸‰ä¸ªä¸»è¦åŠŸèƒ½ï¼šaï¼‰ä»æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„å­—ç¬¦ç±»å‹ä¸­æå–è§£æå™¨ä»£ç ï¼Œbï¼‰è¯†åˆ«ç‰¹å®šäºJinja2çš„å…³é”®å­—ï¼Œä»¥åŠcï¼‰å®ƒæä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„æ¥å£æ¥ä½¿ç”¨ä»¤ç‰Œæµï¼š <br><div class="spoiler">  <b class="spoiler_title">LexScanner</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> Lexer::TokensList::const_iterator m_begin; Lexer::TokensList::const_iterator m_end; Lexer::TokensList::const_iterator m_cur; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateSaver</span></span></span><span class="hljs-class"> {</span></span> StateSaver(LexScanner&amp; scanner) : m_state(scanner.m_state) , m_scanner(scanner) { } ~StateSaver() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_commited) m_scanner.m_state = m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_commited = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } State m_state; LexScanner&amp; m_scanner; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_commited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; LexScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer&amp; lexer) { m_state.m_begin = lexer.GetTokens().begin(); m_state.m_end = lexer.GetTokens().end(); Reset(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_state.m_cur = m_state.m_begin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> State&amp; state)</span></span></span><span class="hljs-function"> </span></span>{ m_state = state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur ++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_end) ++ m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_begin) -- m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PeekNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EatIfEqual(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Token::Type&gt;(type), tok); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Token::Type type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == Token::Type::Eof &amp;&amp; tok) *tok = EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type == Token::Type::Eof; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur-&gt;type == type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tok) *tok = *m_state.m_cur; ++ m_state.m_cur; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: State m_state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EofToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Token eof; eof.type = Token::Eof; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eof; } };</code> </pre> <br>  <a href="">ä»è¿™é‡Œ</a> ã€‚ <br></div></div><br> å› æ­¤ï¼Œå°½ç®¡å¼•æ“å¯ä»¥åŒæ—¶ä½¿ç”¨charå’Œwchar_tæ¨¡æ¿ï¼Œä½†ä¸»è¦çš„è§£æä»£ç å¹¶ä¸å–å†³äºå­—ç¬¦çš„ç±»å‹ã€‚ ä½†æ˜¯ï¼Œåœ¨æœ‰å…³è§’è‰²ç±»å‹çš„å†’é™©çš„éƒ¨åˆ†ä¸­ï¼Œæœ‰å…³æ­¤å†…å®¹çš„æ›´å¤šä¿¡æ¯ã€‚ <br> å¦å¤–ï¼Œæˆ‘ä¸å¾—ä¸ä¿®æ”¹æ§åˆ¶ç»“æ„ã€‚ åœ¨Jinja2ä¸­ï¼Œå…¶ä¸­è®¸å¤šæ˜¯é…å¯¹çš„ã€‚ ä¾‹å¦‚ï¼Œå¯¹äº/ endforï¼Œif / endifï¼Œblock / endblockç­‰ã€‚è¯¥å¯¹ä¸­çš„æ¯ä¸ªå…ƒç´ éƒ½ä½äºå…¶è‡ªå·±çš„â€œæ‹¬å·â€ä¸­ï¼Œå¹¶ä¸”åœ¨è¿™äº›å…ƒç´ ä¹‹é—´å¯ä»¥æœ‰ä¸€å †æ‰€æœ‰å†…å®¹ï¼šä»…æ˜¯çº¯æ–‡æœ¬å’Œå…¶ä»–æ§åˆ¶å—ã€‚ å› æ­¤ï¼Œè§£ææ¨¡æ¿çš„ç®—æ³•å¿…é¡»åœ¨å †æ ˆçš„åŸºç¡€ä¸Šå®Œæˆï¼Œæ‰€æœ‰æ–°å‘ç°çš„æ„é€ å’ŒæŒ‡ä»¤ä»¥åŠå®ƒä»¬ä¹‹é—´çš„ç®€å•æ–‡æœ¬ç‰‡æ®µâ€œ clingâ€éƒ½ä»¥å †æ ˆä¸ºåŸºç¡€ã€‚ ä½¿ç”¨ç›¸åŒçš„å †æ ˆï¼Œæ£€æŸ¥if-for-endif-endforç±»å‹æ˜¯å¦ä¸å¹³è¡¡ã€‚ ç”±äºæ‰€æœ‰è¿™äº›ï¼Œç»“æœè¯æ˜è¯¥ä»£ç ä¸åƒJinja2CppLightï¼ˆæˆ–injaï¼‰é‚£æ ·â€œç´§å‡‘â€ï¼Œå…¶ä¸­æ•´ä¸ªå®ç°éƒ½åœ¨ä¸€ä¸ªæºï¼ˆæˆ–æ ‡å¤´ï¼‰ä¸­ã€‚ ä½†æ˜¯è§£æé€»è¾‘å’Œä»£ç ä¸­çš„è¯­æ³•ï¼ˆå®é™…ä¸Šæ˜¯è¯­æ³•ï¼‰æ›´åŠ æ¸…æ™°å¯è§ï¼Œä»è€Œç®€åŒ–äº†å…¶æ”¯æŒå’Œæ‰©å±•ã€‚ è‡³å°‘é‚£æ˜¯æˆ‘çš„ç›®æ ‡ã€‚ ä»æ— æ³•æœ€å¤§é™åº¦åœ°å‡å°‘ä¾èµ–é¡¹æ•°é‡æˆ–ä»£ç æ•°é‡ï¼Œå› æ­¤æ‚¨éœ€è¦ä½¿å…¶æ›´æ˜“äºç†è§£ã€‚ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">åœ¨ä¸‹ä¸€éƒ¨åˆ†ä¸­ï¼Œ</a>æˆ‘ä»¬å°†è®¨è®ºæ¸²æŸ“æ¨¡æ¿çš„è¿‡ç¨‹ï¼Œä½†ç°åœ¨-é“¾æ¥ï¼š <br>  Jinja2è§„èŒƒï¼š <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http</a> ï¼š <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//jinja.pocoo.org/docs/2.10/templates/</a> <br>  Jinja2Cppå®ç°ï¼š <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/flexferrum/Jinja2Cpp</a> <br>  Jinja2CppLightå®ç°ï¼š <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/hughperkins/Jinja2CppLight</a> <br> å—ä¼¤çš„å®ç°ï¼š <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/pantor/inja</a> <br> ç”¨äºåŸºäºJinja2æ¨¡æ¿ç”Ÿæˆä»£ç çš„å®ç”¨ç¨‹åºï¼š <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/flexferrum/autoprogrammer/tree/jinja2cpp_refactor</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416581/">https://habr.com/ru/post/zh-CN416581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416569/index.html">åƒPriusï¼Œä½†ä»…åœ¨Linuxä¸Šï¼šè€ƒè™‘æ··åˆåŠå…¬å®¤</a></li>
<li><a href="../zh-CN416573/index.html">ä»ä»»ä½•åœ°å€å‘é€ç”µå­é‚®ä»¶</a></li>
<li><a href="../zh-CN416575/index.html">CERNå¤§å‹å¼ºå­å¯¹æ’æœºç£ä½“çš„è¶…å¯¼ç ´ååˆ†æ</a></li>
<li><a href="../zh-CN416577/index.html">æ‘˜è¦MBLT DEV-é€‚ç”¨äºiOSå¼€å‘äººå‘˜çš„å…¨æ–°å†…å®¹</a></li>
<li><a href="../zh-CN416579/index.html">æˆ‘ä»¬ä½¿ç”¨Web Bluetooth APIå’ŒArduinoæ§åˆ¶LED</a></li>
<li><a href="../zh-CN416583/index.html">è´­ä¹°å“ªä¸€å°3Dæ‰«æä»ªï¼Ÿ 3Dtoolè¯„é€‰çš„2018å¹´5å¤§æœ€ä½³3Dæ‰«æä»ª</a></li>
<li><a href="../zh-CN416585/index.html">è‡ªå®šä¹‰è„šæœ¬çš„è·¨æµè§ˆå™¨Webæ‰©å±•ç¬¬3éƒ¨åˆ†</a></li>
<li><a href="../zh-CN416587/index.html">å…³äºä½éŸ³ç‚®çš„ä¸€äº›è¯ä»¥åŠä¸ºä»€ä¹ˆå®ƒä»¬é€‚åˆå‡ ä¹æ‰€æœ‰äºº</a></li>
<li><a href="../zh-CN416589/index.html">æ­»ç»†èƒï¼šä½¿ç”¨3Dç®¡çº¿è¿›è¡Œ2DåŠ¨ç”»å¤„ç†</a></li>
<li><a href="../zh-CN416591/index.html">â€œæ‹§ç´§èºæ¯â€ï¼šä¸ºä»€ä¹ˆæ¯ä¸ªäººéƒ½å¼€å§‹è°ˆè®ºç´§ç¼©ITéƒ¨é—¨çš„æ³•è§„</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>