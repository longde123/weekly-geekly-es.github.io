<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèº üë®üèæ‚Äçüíª üë≥ Safety Cribs: JWT üë®üèº‚Äçüè≠ üåõ üëã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak aplikasi menggunakan JSON Web Tokens (JWT) untuk memungkinkan klien mengidentifikasi diri mereka untuk pertukaran informasi lebih lanjut setela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Safety Cribs: JWT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/457090/"><img src="https://habrastorage.org/webt/db/hk/3r/dbhk3r8z4e24imgvw6mjwyuat4m.png"><br><br>  Banyak aplikasi menggunakan JSON Web Tokens (JWT) untuk memungkinkan klien mengidentifikasi diri mereka untuk pertukaran informasi lebih lanjut setelah otentikasi. <br><br>  JSON Web Token adalah standar terbuka (RFC 7519) yang mendefinisikan cara yang ringkas dan mandiri untuk mentransfer informasi antar pihak secara aman sebagai objek JSON. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/oq/x9/6o/oqx96ozecxiq4qbsrzrk-dw7n5u.png"><br>  Informasi ini diverifikasi dan dapat diandalkan karena ditandatangani secara digital. <br>  JWT dapat ditandatangani menggunakan rahasia (menggunakan algoritma HMAC) atau pasangan kunci publik / pribadi menggunakan RSA atau ECDSA. <br><br>  JSON Web Token digunakan untuk mengirimkan informasi mengenai identitas dan karakteristik klien.  "Wadah" ini ditandatangani oleh server sehingga klien tidak mengganggu dan tidak dapat mengubah, misalnya, data identifikasi atau karakteristik apa pun (misalnya, peran dari pengguna yang sederhana menjadi administrator atau mengubah login klien). <br><br>  Token ini dibuat jika otentikasi berhasil dan diperiksa oleh server sebelum memulai setiap permintaan klien.  Token digunakan oleh aplikasi sebagai "kartu identitas" klien (sebuah wadah dengan semua informasi tentangnya).  Server memiliki kemampuan untuk memverifikasi validitas dan integritas token dengan cara yang aman.  Ini memungkinkan aplikasi menjadi stateless (aplikasi stateless tidak menyimpan data klien yang dihasilkan dalam satu sesi untuk digunakan dalam sesi berikutnya dengan klien ini (setiap sesi independen)), dan proses otentikasi independen dari layanan yang digunakan (dalam arti bahwa teknologi klien dan server dapat bervariasi, termasuk bahkan saluran transportasi, meskipun HTTP paling sering digunakan). <br><br><h2>  Pertimbangan untuk Menggunakan JWT </h2><br>  Bahkan jika token JWT mudah digunakan dan memungkinkan Anda untuk menyediakan layanan (terutama REST) ‚Äã‚Äãtanpa status (stateless), solusi ini tidak cocok untuk semua aplikasi, karena ia datang dengan beberapa peringatan, seperti masalah menyimpan token. <br><br>  Jika aplikasi tidak harus sepenuhnya tanpa kewarganegaraan, maka Anda dapat mempertimbangkan untuk menggunakan sistem sesi tradisional yang disediakan oleh semua platform web.  Namun, untuk aplikasi stateless, JWT adalah opsi yang baik jika diterapkan dengan benar. <br><br>
<h2>  Masalah dan Serangan JWT </h2><br><h4>  Menggunakan Algoritma Hash NONE </h4><br>  Serangan serupa terjadi ketika penyerang mengubah token dan juga mengubah algoritma hashing ("alg") untuk menunjukkan melalui kata kunci yang tidak ada integritas integritas token telah diverifikasi.  Beberapa perpustakaan melihat token yang ditandatangani menggunakan algoritme tidak ada sebagai token yang valid dengan tanda tangan yang diverifikasi, sehingga penyerang dapat mengubah payload token dan aplikasi akan mempercayai token. <br><br>  Untuk mencegah serangan, Anda harus menggunakan perpustakaan JWT, yang tidak terpengaruh oleh kerentanan ini.  Selain itu, selama validasi token, Anda harus secara eksplisit meminta penggunaan algoritma yang diharapkan. <br><br>  <b><u>Contoh Implementasi:</u></b> <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //        //    HMAC-256 - JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Intersepsi token </h4><br>  Serangan terjadi ketika token telah dicegat atau dicuri oleh penyerang dan ia menggunakannya untuk mendapatkan akses ke sistem menggunakan kredensial pengguna tertentu. <br><br>  Perlindungan terdiri dari menambahkan "konteks pengguna" ke token.  Konteks pengguna akan terdiri dari informasi berikut: <br><br><ol><li>  String acak yang dihasilkan pada tahap otentikasi dan disertakan dalam token, dan juga dikirim ke klien sebagai cookie yang lebih aman (flag: HttpOnly + Secure + SameSite + awalan cookie). </li><li>  Hash SHA256 dari string acak akan disimpan dalam token sehingga setiap masalah XSS tidak akan memungkinkan penyerang membaca nilai string acak dan mengatur cookie yang diharapkan. </li></ol><br>  Alamat IP tidak akan digunakan dalam konteks, karena ada situasi di mana alamat IP dapat berubah selama satu sesi, misalnya, ketika pengguna mengakses aplikasi melalui ponselnya.  Kemudian alamat IP terus berubah secara sah.  Selain itu, menggunakan alamat IP berpotensi menyebabkan masalah pada tingkat kepatuhan dengan GDPR Eropa. <br><br>  Jika selama verifikasi token token yang diterima tidak mengandung konteks yang benar, itu harus ditolak. <br>  <b><u>Contoh Implementasi:</u></b> <br><br>  <i>Kode untuk membuat token setelah otentikasi berhasil:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; //    private SecureRandom secureRandom = new SecureRandom(); ... //   ,     byte[] randomFgp = new byte[50]; secureRandom.nextBytes(randomFgp); String userFingerprint = DatatypeConverter.printHexBinary(randomFgp); //    cookie String fingerprintCookie = "__Secure-Fgp=" + userFingerprint + "; SameSite=Strict; HttpOnly; Secure"; response.addHeader("Set-Cookie", fingerprintCookie); // SHA256          // (  )  XSS      //     cookie MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      15     Calendar c = Calendar.getInstance(); Date now = c.getTime(); c.add(Calendar.MINUTE, 15); Date expirationDate = c.getTime(); Map&lt;String, Object&gt; headerClaims = new HashMap&lt;&gt;(); headerClaims.put("typ", "JWT"); String token = JWT.create().withSubject(login) .withExpiresAt(expirationDate) .withIssuer(this.issuerID) .withIssuedAt(now) .withNotBefore(now) .withClaim("userFingerprint", userFingerprintHash) .withHeader(headerClaims) .sign(Algorithm.HMAC256(this.keyHMAC));</span></span></code> </pre> <br><br>  <i>Kode untuk memverifikasi validitas token:</i> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //     cookie String userFingerprint = null; if (request.getCookies() != null &amp;&amp; request.getCookies().length &gt; 0) { List&lt;Cookie&gt; cookies = Arrays.stream(request.getCookies()).collect(Collectors.toList()); Optional&lt;Cookie&gt; cookie = cookies.stream().filter(c -&gt; "__Secure-Fgp" .equals(c.getName())).findFirst(); if (cookie.isPresent()) { userFingerprint = cookie.get().getValue(); } } //  SHA256      cookie  //       MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)) .withIssuer(issuerID) .withClaim("userFingerprint", userFingerprintHash) .build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Pencabutan token oleh pengguna secara eksplisit </h4><br>  Karena token menjadi tidak valid hanya setelah kedaluwarsa, pengguna tidak memiliki fungsi bawaan yang memungkinkan Anda untuk membatalkan token secara eksplisit.  Jadi, dalam kasus pencurian, pengguna tidak dapat menarik token sendiri dan kemudian memblokir penyerang. <br><br>  Salah satu metode perlindungan adalah pengenalan daftar hitam token, yang akan cocok untuk mensimulasikan fungsi "log out" yang ada dalam sistem sesi tradisional. <br><br>  Koleksi (dalam pengkodean SHA-256 dalam HEX) dari token dengan tanggal pembatalan, yang harus melebihi periode validitas token yang diterbitkan, akan disimpan dalam daftar hitam. <br><br>  Ketika pengguna ingin "logout", ia memanggil layanan khusus yang menambahkan token pengguna yang disediakan ke daftar hitam, yang mengarah pada pembatalan langsung token untuk digunakan lebih lanjut dalam aplikasi. <br><br>  <u><b>Contoh Implementasi:</b></u> <br><br>  <i>Repositori daftar hitam:</i> <br>  Untuk penyimpanan daftar hitam terpusat, sebuah database dengan struktur berikut akan digunakan: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">create table </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> not exists </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revoked_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jwt_token_digest varchar(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> primary key, revokation_date timestamp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">now</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <i>Manajemen pencabutan token:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    (logout). //  ,      //         . public class TokenRevoker { //    @Resource("jdbc/storeDS") private DataSource storeDS; //      public boolean isTokenRevoked(String jwtInHex) throws Exception { boolean tokenIsPresent = false; if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //     try (Connection con = this.storeDS.getConnection()) { String query = "select jwt_token_digest from revoked_token where jwt_token_digest = ?"; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); try (ResultSet rSet = pStatement.executeQuery()) { tokenIsPresent = rSet.next(); } } } } return tokenIsPresent; } //    HEX      public void revokeToken(String jwtInHex) throws Exception { if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //             //   if (!this.isTokenRevoked(jwtInHex)) { try (Connection con = this.storeDS.getConnection()) { String query = "insert into revoked_token(jwt_token_digest) values(?)"; int insertedRecordCount; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); insertedRecordCount = pStatement.executeUpdate(); } if (insertedRecordCount != 1) { throw new IllegalStateException("Number of inserted record is invalid," + " 1 expected but is " + insertedRecordCount); } } } } }</span></span></code> </pre><br><h4>  Pengungkapan Token </h4><br>  Serangan ini terjadi ketika penyerang mendapatkan akses ke token (atau satu set token) dan mengekstrak informasi yang tersimpan di dalamnya (informasi tentang token JWT dikodekan menggunakan base64) untuk mendapatkan informasi tentang sistem.  Informasi dapat berupa, misalnya, peran keamanan, format login, dll. <br><br>  Metode perlindungannya cukup jelas dan terdiri dalam mengenkripsi token.  Penting juga untuk melindungi data terenkripsi dari serangan menggunakan cryptanalysis.  Untuk mencapai semua tujuan ini, algoritma AES-GCM digunakan, yang menyediakan Enkripsi terotentikasi dengan Data Terkait (AEAD).  AEAD primitive menyediakan fungsionalitas enkripsi simetris yang diautentikasi.  Implementasi primitif ini dilindungi dari serangan adaptif berdasarkan ciphertext yang dipilih.  Saat mengenkripsi plaintext, Anda dapat menentukan data terkait yang harus diautentikasi tetapi tidak dienkripsi. <br><br>  Artinya, enkripsi dengan data yang relevan memastikan keaslian dan integritas data, tetapi tidak kerahasiaannya. <br><br>  Namun, harus dicatat bahwa enkripsi ditambahkan terutama untuk menyembunyikan informasi internal, tetapi sangat penting untuk mengingat bahwa perlindungan awal terhadap pemalsuan token JWT adalah tanda tangan, oleh karena itu, tanda tangan token dan verifikasi harus selalu digunakan. <br><br><h4>  Penyimpanan token sisi klien </h4><br>  Jika aplikasi menyimpan token sehingga satu atau lebih situasi berikut terjadi: <br><br><ul><li>  token secara otomatis dikirim oleh browser (penyimpanan cookie); </li><li>  token diperoleh bahkan jika browser dihidupkan ulang (menggunakan wadah localStorage browser); </li><li>  token diperoleh dalam kasus serangan XSS (cookie tersedia untuk kode JavaScript atau token yang disimpan di localStorage atau sessionStorage). </li></ul><br>  Untuk mencegah serangan: <br><br><ol><li>  Simpan token di browser menggunakan wadah sessionStorage. </li><li>  Tambahkan ke tajuk Otorisasi menggunakan skema Bearer.  Judulnya harus seperti ini: <br><br><pre> <code class="xml hljs">Authorization: Bearer <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">token</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </li><li>  Tambahkan informasi sidik jari ke token. </li></ol><br>  Dengan menyimpan token dalam wadah sessionStorage, ia menyediakan token untuk pencurian dalam kasus XSS.  Namun, sidik jari yang ditambahkan ke token mencegah penyerang menggunakan kembali token yang dicuri di komputernya.  Untuk menutup area penggunaan maksimum untuk penyerang, tambahkan Kebijakan Keamanan Konten untuk membatasi konteks eksekusi. <br><br>  Masih ada kasus di mana penyerang menggunakan konteks penelusuran pengguna sebagai server proxy untuk menggunakan aplikasi target melalui pengguna yang sah, tetapi Kebijakan Keamanan Konten dapat mencegah komunikasi dengan domain yang tidak terduga. <br><br>  Dimungkinkan juga untuk mengimplementasikan layanan otentikasi sehingga token dikeluarkan di dalam cookie aman, tetapi dalam hal ini, perlindungan terhadap CSRF harus dilaksanakan. <br><br><h4>  Menggunakan kunci yang lemah untuk membuat token </h4><br>  Jika rahasia yang digunakan dalam kasus algoritma HMAC-SHA256, yang diperlukan untuk menandatangani token, lemah, maka dapat diretas (diambil dengan menggunakan serangan brute force).  Akibatnya, seorang penyerang dapat memalsukan token yang valid dan sewenang-wenang dalam hal tanda tangan. <br><br>  Untuk mencegah masalah ini, Anda harus menggunakan kunci rahasia yang kompleks: alfanumerik (campuran huruf) + karakter khusus. <br><br>  Karena kunci hanya diperlukan untuk perhitungan komputer, ukuran kunci rahasia dapat melebihi 50 posisi. <br><br>  Sebagai contoh: <br><br><pre> <code class="plaintext hljs">A&amp;'/}Z57M(2hNg=;LE?~]YtRMS5(yZ&lt;vcZTA3N-($&gt;2j:ZeX-BGftaVk`)jKP~q?,jk)EMbgt*kW'</code> </pre> <br>  Untuk menilai kompleksitas kunci rahasia yang digunakan untuk penandatanganan token Anda, Anda dapat menerapkan serangan kamus kata sandi ke token dalam kombinasi dengan JWT API. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457090/">https://habr.com/ru/post/id457090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457072/index.html">Cara mengatasi masalah lama menggunakan ML dalam Python dan .Net</a></li>
<li><a href="../id457074/index.html">Evolusi pengembang: game apa yang harus kita harapkan di masa depan</a></li>
<li><a href="../id457078/index.html">Cara mengubah avatar Telegram Anda menjadi arloji</a></li>
<li><a href="../id457082/index.html">Pemberian hak administrator yang tidak sensitif</a></li>
<li><a href="../id457086/index.html">Pola arsitektur "Builder" di alam semesta "Swift" dan "iOS" / "macOS"</a></li>
<li><a href="../id457092/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 5</a></li>
<li><a href="../id457094/index.html">Add-in Excel yang memudahkan untuk mengatur filter saat bekerja dengan kubus (VBA)</a></li>
<li><a href="../id457096/index.html">Kami membebaskan tangan kami ke beberapa analis: API Livy untuk otomatisasi tugas perbankan yang khas</a></li>
<li><a href="../id457098/index.html">Penanganan kesalahan JavaScript yang elegan dengan Either monad</a></li>
<li><a href="../id457100/index.html">AWS Lambda - Teori, Kenalan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>