<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèº üßóüèΩ üòÜ 10 benef√≠cios n√£o √≥bvios do uso do Rust üßìüèª üíó üöÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust √© uma linguagem de programa√ß√£o de sistema jovem e ambiciosa. Ele implementa o gerenciamento autom√°tico de mem√≥ria sem um coletor de lixo e outras...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 benef√≠cios n√£o √≥bvios do uso do Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust √© uma linguagem de programa√ß√£o de sistema jovem e ambiciosa.  Ele implementa o gerenciamento autom√°tico de mem√≥ria sem um coletor de lixo e outras sobrecargas no tempo de execu√ß√£o.  Al√©m disso, o idioma padr√£o √© usado no idioma Rust, existem regras sem precedentes para acessar dados mut√°veis ‚Äã‚Äãe a vida √∫til do link tamb√©m √© levada em considera√ß√£o.  Isso lhe permite garantir a seguran√ßa da mem√≥ria e facilita a programa√ß√£o multithread, devido √† falta de corridas de dados. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Tudo isso j√° √© bem conhecido por todos que acompanham pelo menos um pouco o desenvolvimento de modernas tecnologias de programa√ß√£o.  Mas e se voc√™ n√£o for um programador de sistemas e n√£o houver muitos c√≥digos multithread em seus projetos, mas voc√™ ainda estiver atra√≠do pelo desempenho do Rust.  Voc√™ obter√° benef√≠cios adicionais com o uso em aplicativos?  Ou tudo o que ele lhe dar√° adicionalmente √© uma luta dura com o compilador, o que for√ßar√° voc√™ a escrever o programa para que ele siga constantemente as regras da linguagem sobre empr√©stimos e propriedade? </p><br><p>  Este artigo reuniu uma d√∫zia de vantagens n√£o √≥bvias e n√£o particularmente anunciadas do uso do Rust, o que, espero, ajudar√° voc√™ a decidir sobre a escolha desse idioma para seus projetos. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. A universalidade da l√≠ngua </h2><br><p>  Apesar do Rust estar posicionado como uma linguagem para a programa√ß√£o do sistema, ele tamb√©m √© adequado para resolver problemas aplicados de alto n√≠vel.  Voc√™ n√£o precisa trabalhar com ponteiros brutos, a menos que precise deles para sua tarefa.  A biblioteca de idiomas padr√£o j√° implementou a maioria dos tipos e fun√ß√µes que podem ser necess√°rias no desenvolvimento de aplicativos.  Voc√™ tamb√©m pode conectar facilmente bibliotecas externas e us√°-las.  O sistema de tipos e a programa√ß√£o generalizada no Rust permitem o uso de abstra√ß√µes de um n√≠vel bastante alto, embora n√£o haja suporte direto para OOP na linguagem. </p><br><p>  Vejamos alguns exemplos simples de uso do Rust. </p><br><p>  Um exemplo de combina√ß√£o de dois iteradores em um iterador sobre pares de elementos: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><blockquote>  Nota: uma chamada para o <code>name!(...)</code> do formato <code>name!(...)</code> √© uma chamada para uma macro funcional.  Os nomes dessas macros no Rust sempre terminam com um s√≠mbolo <code>!</code>  para que eles possam ser distinguidos dos nomes das fun√ß√µes e outros identificadores.  Os benef√≠cios do uso de macros ser√£o discutidos abaixo. </blockquote><p>  Um exemplo de uso da biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>regex</code></a> externa para trabalhar com express√µes regulares: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Um exemplo da implementa√ß√£o da <code>Add</code> para a pr√≥pria estrutura <code>Point</code> para sobrecarregar o operador de adi√ß√£o: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Um exemplo de uso de um tipo gen√©rico em uma estrutura: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  No Rust, voc√™ pode escrever utilit√°rios de sistema eficientes, grandes aplicativos de desktop, microsservi√ßos, aplicativos da Web (incluindo a parte do cliente, pois o Rust pode ser compilado no Wasm), aplicativos m√≥veis (embora o ecossistema de idiomas ainda seja pouco desenvolvido nessa dire√ß√£o).  Essa versatilidade pode ser uma vantagem para equipes de multiprojetos, pois permite usar as mesmas abordagens e os mesmos m√≥dulos em muitos projetos diferentes.  Se voc√™ est√° acostumado com o fato de que cada ferramenta √© projetada para seu campo de aplica√ß√£o restrito, tente ver o Rust como uma caixa de ferramentas com a mesma confiabilidade e conveni√™ncia.  Talvez seja exatamente isso que voc√™ estava perdendo. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Ferramentas pr√°ticas de gerenciamento de compila√ß√£o e depend√™ncia </h2><br><p>  Isso claramente n√£o √© anunciado, mas muitos percebem que o Rust possui um dos melhores sistemas de gerenciamento de compila√ß√£o e depend√™ncia dispon√≠veis atualmente.  Se voc√™ programou em C ou C ++, e a quest√£o do uso indolor de bibliotecas externas foi bastante aguda para voc√™, usar o Rust com sua ferramenta de constru√ß√£o e o gerenciador de depend√™ncia de carga ser√° uma boa op√ß√£o para seus novos projetos. </p><br><p>  Al√©m do fato de o Cargo fazer download de depend√™ncias para voc√™ e gerenciar suas vers√µes, criar e executar seus aplicativos, executar testes e gerar documenta√ß√£o, tamb√©m pode ser expandido com plugins para outras fun√ß√µes √∫teis.  Por exemplo, existem extens√µes que permitem ao Cargo determinar as depend√™ncias obsoletas do seu projeto, realizar an√°lises est√°ticas do c√≥digo-fonte, criar e reimplantar partes de clientes de aplicativos da Web e muito mais. </p><br><p>  O arquivo de configura√ß√£o do Cargo usa a linguagem de marca√ß√£o amig√°vel e m√≠nima para descrever as configura√ß√µes do projeto.  Aqui est√° um exemplo de um <code>Cargo.toml</code> configura√ß√£o t√≠pico do <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  E abaixo est√£o tr√™s comandos t√≠picos para usar o Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Com sua ajuda, o c√≥digo-fonte ser√° verificado quanto a erros de compila√ß√£o, montagem do projeto e lan√ßamento de testes, montagem e lan√ßamento do programa para execu√ß√£o, respectivamente. </p><br><h2 id="3-vstroennye-testy">  3. Testes internos </h2><br><p>  Escrever testes de unidade no Rust √© t√£o f√°cil e simples que voc√™ deseja fazer isso de novo e de novo.  :) Frequentemente, ser√° mais f√°cil escrever um teste de unidade do que tentar testar a funcionalidade de outra maneira.  Aqui est√° um exemplo de fun√ß√µes e testes para eles: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  As fun√ß√µes no m√≥dulo de <code>test</code> , marcadas com o atributo <code>#[test]</code> , s√£o testes de unidade.  Eles ser√£o executados em paralelo quando o comando de <code>cargo test</code> for chamado.  O atributo de compila√ß√£o condicional <code>#[cfg(test)]</code> , que marca todo o m√≥dulo com testes, levar√° ao fato de que o m√≥dulo ser√° compilado somente quando os testes forem executados, mas n√£o entrar√° na montagem normal. </p><br><p>  √â muito conveniente colocar os testes no mesmo m√≥dulo que o funcional em teste, simplesmente adicionando o subm√≥dulo de <code>test</code> a ele.  E se voc√™ precisar de testes de integra√ß√£o, basta coloc√°-los no diret√≥rio de <code>tests</code> na raiz do projeto e usar seu aplicativo neles como um pacote externo.  Um m√≥dulo de <code>test</code> separado e as diretivas de compila√ß√£o condicional nesse caso n√£o precisam ser adicionadas. </p><br><p>  Exemplos especiais de documenta√ß√£o executada como testes merecem aten√ß√£o especial, mas isso ser√° discutido abaixo. </p><br><p>  Testes de desempenho internos (benchmarks) tamb√©m est√£o dispon√≠veis, mas ainda n√£o s√£o est√°veis, portanto, est√£o dispon√≠veis apenas em montagens noturnas do compilador.  No Rust est√°vel, voc√™ precisar√° usar bibliotecas externas para esse tipo de teste. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Boa documenta√ß√£o com exemplos atuais </h2><br><p>  A biblioteca Rust padr√£o est√° muito bem documentada.  A documenta√ß√£o HTML √© gerada automaticamente a partir do c√≥digo-fonte com descri√ß√µes de descontos nos coment√°rios do dock.  Al√©m disso, os coment√°rios do documento no c√≥digo Rust cont√™m c√≥digo de amostra que √© executado quando os testes s√£o executados.  Isso garante a relev√¢ncia dos exemplos: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>A documenta√ß√£o</em></a> </p><br><p>  Aqui est√° um exemplo do uso do m√©todo <code>as_bytes</code> do tipo <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  ser√° executado como um teste durante o lan√ßamento dos testes. </p><br><p>  Al√©m disso, a pr√°tica de criar exemplos de seu uso na forma de pequenos programas independentes localizados no diret√≥rio de <code>examples</code> na raiz do projeto √© comum para as bibliotecas Rust.  Esses exemplos tamb√©m s√£o uma parte importante da documenta√ß√£o e tamb√©m s√£o compilados e executados durante a execu√ß√£o do teste, mas podem ser executados independentemente dos testes. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Dedu√ß√£o autom√°tica inteligente de tipos </h2><br><p>  Em um programa Rust, voc√™ n√£o pode especificar explicitamente o tipo de express√£o se o compilador puder produzi-la automaticamente com base no contexto de uso.  E isso se aplica n√£o apenas aos locais onde as vari√°veis ‚Äã‚Äãs√£o declaradas.  Vejamos um exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Se organizarmos as anota√ß√µes de tipo, este exemplo ser√° semelhante a este: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Ou seja, temos um vetor de fatias de sequ√™ncia e uma vari√°vel do tipo fatia de sequ√™ncia.  Mas, neste caso, a especifica√ß√£o de tipos √© completamente redundante, pois o compilador pode produzi-los por si s√≥ (usando a vers√£o estendida do algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hindley-Milner</a> ).  O fato de <code>vec</code> ser um vetor j√° √© claro pelo tipo de valor de retorno de <code>Vec::new()</code> , mas ainda n√£o est√° claro qual ser√° o tipo de seus elementos.  O fato de o tipo de <code>text</code> ser uma fatia de sequ√™ncia √© compreens√≠vel pelo fato de ser atribu√≠do um literal desse tipo.  Assim, ap√≥s <code>vec.push(text)</code> , o tipo de elementos do vetor se torna √≥bvio.  Observe que o tipo da vari√°vel <code>vec</code> foi completamente determinado por seu uso no encadeamento de execu√ß√£o, e n√£o no est√°gio de inicializa√ß√£o. </p><br><p>  Esse sistema de infer√™ncia de tipo elimina o ru√≠do do c√≥digo e o torna t√£o conciso quanto o c√≥digo em alguma linguagem de programa√ß√£o de tipo din√¢mico.  E isso mantendo a digita√ß√£o est√°tica estrita! </p><br><p>  Obviamente, n√£o podemos nos livrar completamente da digita√ß√£o em um idioma estaticamente digitado.  O programa deve ter pontos nos quais os tipos de objetos t√™m garantia de serem conhecidos, para que em outros locais esses tipos possam ser exibidos.  Tais pontos no Rust s√£o declara√ß√µes de tipos de dados definidos pelo usu√°rio e assinaturas de fun√ß√µes, nas quais n√£o se pode deixar de especificar os tipos utilizados.  Mas voc√™ pode inserir "meta-vari√°veis ‚Äã‚Äãde tipos" nelas, usando programa√ß√£o generalizada. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Correspond√™ncia de padr√µes em pontos de declara√ß√£o vari√°veis </h2><br><p>  <code>let</code> opera√ß√£o </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  n√£o √© realmente limitado a apenas declarar novas vari√°veis.  O que ela realmente faz √© igualar a express√£o √† direita do sinal de igual com o padr√£o √† esquerda.  E novas vari√°veis ‚Äã‚Äãpodem ser introduzidas como parte da amostra (e somente isso).  D√™ uma olhada no exemplo a seguir e ele ficar√° mais claro: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  A desestrutura√ß√£o √© realizada aqui: essa compara√ß√£o apresentar√° as vari√°veis <code>x</code> e <code>y</code> , que ser√£o inicializadas com o valor dos campos <code>x</code> e <code>y</code> do objeto da estrutura <code>Point</code> , retornado pela chamada <code>Point::new()</code> .  Ao mesmo tempo, a compara√ß√£o est√° correta, pois o tipo de express√£o √† direita corresponde ao padr√£o de <code>Point</code> do tipo <code>Point</code> √† esquerda.  De maneira semelhante, voc√™ pode pegar, por exemplo, os dois primeiros elementos de uma matriz: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  E muito mais a fazer.  O mais not√°vel √© que essas compara√ß√µes s√£o realizadas em todos os locais em que novos nomes de vari√°veis ‚Äã‚Äãpodem ser inseridos no Rust, a saber: na <code>match</code> , <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , no cabe√ßalho do loop <code>for</code> , nos argumentos de fun√ß√µes e fechamentos.  Aqui est√° um exemplo de como usar elegantemente a correspond√™ncia de padr√µes em um loop <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  O m√©todo <code>enumerate</code> , chamado no iterador, constr√≥i um novo iterador, que iterar√° n√£o sobre os valores iniciais, mas as tuplas, pares "√≠ndice ordinal, valor inicial".  Cada uma dessas tuplas durante a itera√ß√£o do ciclo ser√° mapeada para o padr√£o especificado <code>(i, ch)</code> , como resultado da vari√°vel <code>i</code> receber√° o primeiro valor da tupla - o √≠ndice e a vari√°vel <code>ch</code> - o segundo, ou seja, o caractere da string.  Mais adiante, no corpo do loop, podemos usar essas vari√°veis. </p><br><p>  Outro exemplo popular de usar um padr√£o em um loop <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Aqui, simplesmente ignoramos o valor do iterador usando o padr√£o <code>_</code> .  Porque n√£o usamos o n√∫mero da itera√ß√£o no corpo do loop.  O mesmo pode ser feito, por exemplo, com um argumento de fun√ß√£o: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Ou ao fazer a correspond√™ncia em uma declara√ß√£o de <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  A correspond√™ncia de padr√µes torna o c√≥digo muito compacto e expressivo e, na declara√ß√£o de <code>match</code> , geralmente √© insubstitu√≠vel.  O operador de <code>match</code> √© um operador de an√°lise variada completa, portanto voc√™ n√£o poder√° esquecer acidentalmente de verificar algumas das correspond√™ncias poss√≠veis para a express√£o analisada nela. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Extens√£o de sintaxe e DSL personalizado </h2><br><p>  A sintaxe da ferrugem √© limitada, em grande parte devido √† complexidade do sistema de tipos usado no idioma.  Por exemplo, Rust n√£o possui argumentos de fun√ß√£o nomeados ou fun√ß√µes com um n√∫mero vari√°vel de argumentos.  Mas voc√™ pode contornar essas e outras limita√ß√µes com macros.  O Rust possui dois tipos de macros: declarativo e processual.  Com macros declarativas, voc√™ nunca ter√° os mesmos problemas que as macros em C, porque s√£o higi√™nicas e n√£o funcionam no n√≠vel de substitui√ß√£o de texto, mas no n√≠vel de substitui√ß√£o na √°rvore de sintaxe abstrata.  As macros permitem criar abstra√ß√µes no n√≠vel da sintaxe do idioma.  Por exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Al√©m do fato de que essa macro expande os recursos sint√°ticos de chamar a "fun√ß√£o" de imprimir uma cadeia de caracteres formatada, tamb√©m verificar√° em sua implementa√ß√£o que os argumentos de entrada correspondem √† cadeia de formato especificada no tempo de compila√ß√£o e n√£o no tempo de execu√ß√£o.  Usando macros, voc√™ pode inserir sintaxe concisa para suas pr√≥prias necessidades de design, criar e usar DSL.  Aqui est√° um exemplo do uso de c√≥digo JavaScript dentro de um programa Rust compilando no Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  <code>js!</code> macro <code>js!</code>  definido no pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>stdweb</code></a> e permite incorporar c√≥digo JavaScript completo em seu programa (com exce√ß√£o de cadeias e operadores de aspas simples n√£o conclu√≠das com ponto-e-v√≠rgula) e usar objetos do c√≥digo Rust usando a sintaxe <code>@{expr}</code> . </p><br><p>  As macros oferecem enormes oportunidades para adaptar a sintaxe dos programas Rust √†s tarefas espec√≠ficas de uma √°rea espec√≠fica.  Eles economizar√£o seu tempo e aten√ß√£o ao desenvolver aplicativos complexos.  N√£o aumentando a sobrecarga do tempo de execu√ß√£o, mas aumentando o tempo de compila√ß√£o.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Gera√ß√£o autom√°tica de c√≥digo dependente </h2><br><p>  As macros de deriva√ß√£o processual da Rust s√£o amplamente usadas para implementar automaticamente caracter√≠sticas e outra gera√ß√£o de c√≥digo.  Aqui est√° um exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Como todos esses tipos ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> e <code>Eq</code> ) da biblioteca padr√£o s√£o implementados para o tipo de campo da estrutura <code>i32</code> , sua implementa√ß√£o pode ser exibida automaticamente para toda a estrutura como um todo.  Outro exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Aqui, usando as <code>Deserialize</code> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>serde</code></a> biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>serde</code></a> para a estrutura <code>Point</code> , s√£o gerados automaticamente m√©todos para sua serializa√ß√£o e desserializa√ß√£o.  Em seguida, voc√™ pode passar uma inst√¢ncia dessa estrutura para v√°rias fun√ß√µes de serializa√ß√£o, por exemplo, convertendo-a em uma sequ√™ncia JSON. </p><br><p>  Voc√™ pode criar suas pr√≥prias macros processuais que ir√£o gerar o c√≥digo necess√°rio.  Ou use as muitas macros j√° criadas por outros desenvolvedores.  Al√©m de salvar o programador de escrever c√≥digo padr√£o, as macros tamb√©m t√™m a vantagem de que voc√™ n√£o precisa manter se√ß√µes diferentes do c√≥digo em um estado consistente.  Por exemplo, se um terceiro campo <code>z</code> for adicionado √† estrutura <code>Point</code> , para fazer sua serializa√ß√£o corretamente, se voc√™ usar derivar, n√£o precisar√° fazer mais nada.  Se n√≥s mesmos implementarmos as caracter√≠sticas necess√°rias para a serializa√ß√£o do <code>Point</code> , teremos que garantir que essa implementa√ß√£o seja sempre consistente com as altera√ß√µes mais recentes na estrutura do <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Tipo de dados alg√©brico </h2><br><p>  Simplificando, um tipo de dados alg√©brico √© um tipo de dados composto que √© uma uni√£o de estruturas.  Mais formalmente, √© uma soma de tipos de produtos.  No Rust, esse tipo √© definido usando a palavra-chave <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  O tipo de um valor espec√≠fico de uma vari√°vel do tipo <code>Message</code> pode ser apenas um dos tipos de estrutura listados em <code>Message</code> .  Essa √© uma estrutura <code>Quit</code> sem campo, semelhante a uma unidade, uma das estruturas de tupla <code>ChangeColor</code> ou <code>Write</code> com campos sem nome ou a estrutura <code>Move</code> comum.  Um tipo enumerado tradicional pode ser representado como um caso especial de um tipo de dados alg√©brico: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  √â poss√≠vel descobrir que tipo realmente recebeu valor em um caso espec√≠fico usando a correspond√™ncia de padr√µes: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Na forma de tipos de dados alg√©bricos, o Rust implementa tipos importantes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Option</code></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Result</code></a> , que s√£o usados ‚Äã‚Äãpara representar o valor ausente e o resultado correto / incorreto, respectivamente.  Veja como o <code>Option</code> √© definido na biblioteca padr√£o: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Ferrugem n√£o tem um valor nulo, assim como os erros irritantes de uma chamada inesperada.  Em vez disso, onde √© realmente necess√°rio indicar a possibilidade de um valor ausente, <code>Option</code> usada: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  O tipo de dados alg√©brico √© uma ferramenta poderosa e expressiva que abre as portas para o desenvolvimento orientado a tipos.  Um programa escrito com compet√™ncia nesse paradigma atribui a maioria das verifica√ß√µes da corre√ß√£o de seu trabalho ao sistema de tipos.  Portanto, se voc√™ n√£o tiver um pouco de Haskell na programa√ß√£o industrial cotidiana, o Rust pode ser sua sa√≠da.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. F√°cil refatora√ß√£o </h2><br><p>  O sistema estrito de tipo est√°tico desenvolvido no Rust e a tentativa de realizar o maior n√∫mero poss√≠vel de verifica√ß√µes durante a compila√ß√£o levam ao fato de que modificar e refatorar o c√≥digo se torna bastante simples e seguro.  Se, ap√≥s as altera√ß√µes, o programa foi compilado, isso significa que ele deixou apenas erros l√≥gicos que n√£o estavam relacionados √† funcionalidade cuja verifica√ß√£o foi atribu√≠da ao compilador.  Combinado com a facilidade de adicionar testes de unidade √† l√≥gica de teste, isso leva a s√©rias garantias da confiabilidade dos programas e a um aumento da confian√ßa do programador na opera√ß√£o correta de seu c√≥digo ap√≥s fazer altera√ß√µes. </p><br><hr><br><p>  Talvez seja sobre isso que eu queria falar neste artigo.  Obviamente, o Rust tem muitas outras vantagens, al√©m de v√°rias desvantagens (alguma umidade da linguagem, falta de express√µes familiares de programa√ß√£o e sintaxe ‚Äún√£o liter√°ria‚Äù), que n√£o s√£o mencionadas aqui.  Se voc√™ tem algo a dizer sobre eles, escreva nos coment√°rios.  Em geral, tente Rust na pr√°tica.  E talvez as vantagens dele para voc√™ superem todas as defici√™ncias dele, como aconteceu no meu caso.  E, finalmente, voc√™ obter√° exatamente o conjunto de ferramentas necess√°rias por um longo tempo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430294/">https://habr.com/ru/post/pt430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430282/index.html">9 em cada 10 pessoas concordam em ganhar menos com um trabalho mais significativo</a></li>
<li><a href="../pt430284/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 275 (12 a 18 de novembro)</a></li>
<li><a href="../pt430286/index.html">Detalhes do lado obscuro e confuso dos jogos piratas para o Nintendo Switch</a></li>
<li><a href="../pt430290/index.html">Uma tentativa de prever a quarta itera√ß√£o do projeto SpaceX BFR</a></li>
<li><a href="../pt430292/index.html">Electronic Frontier Foundation: o desempenho da rede de placas da pol√≠cia dos EUA √© de 0,5%</a></li>
<li><a href="../pt430296/index.html">Fa√ßa suas id√©ias virem app. Aplicativo sem servidor - instru√ß√µes passo a passo</a></li>
<li><a href="../pt430300/index.html">Microsservi√ßos on Go com o kit Go: Introdu√ß√£o</a></li>
<li><a href="../pt430302/index.html">Uma introdu√ß√£o ao ptrace ou inje√ß√£o de c√≥digo no sshd por divers√£o</a></li>
<li><a href="../pt430304/index.html">Um posto avan√ßado maravilhoso em √≥rbita</a></li>
<li><a href="../pt430306/index.html">O primeiro t√∫nel da Companhia Chata perfurado por Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>