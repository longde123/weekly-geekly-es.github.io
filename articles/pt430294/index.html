<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏼 🧗🏽 😆 10 benefícios não óbvios do uso do Rust 🧓🏻 💗 🚃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust é uma linguagem de programação de sistema jovem e ambiciosa. Ele implementa o gerenciamento automático de memória sem um coletor de lixo e outras...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 benefícios não óbvios do uso do Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust é uma linguagem de programação de sistema jovem e ambiciosa.  Ele implementa o gerenciamento automático de memória sem um coletor de lixo e outras sobrecargas no tempo de execução.  Além disso, o idioma padrão é usado no idioma Rust, existem regras sem precedentes para acessar dados mutáveis ​​e a vida útil do link também é levada em consideração.  Isso lhe permite garantir a segurança da memória e facilita a programação multithread, devido à falta de corridas de dados. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Tudo isso já é bem conhecido por todos que acompanham pelo menos um pouco o desenvolvimento de modernas tecnologias de programação.  Mas e se você não for um programador de sistemas e não houver muitos códigos multithread em seus projetos, mas você ainda estiver atraído pelo desempenho do Rust.  Você obterá benefícios adicionais com o uso em aplicativos?  Ou tudo o que ele lhe dará adicionalmente é uma luta dura com o compilador, o que forçará você a escrever o programa para que ele siga constantemente as regras da linguagem sobre empréstimos e propriedade? </p><br><p>  Este artigo reuniu uma dúzia de vantagens não óbvias e não particularmente anunciadas do uso do Rust, o que, espero, ajudará você a decidir sobre a escolha desse idioma para seus projetos. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. A universalidade da língua </h2><br><p>  Apesar do Rust estar posicionado como uma linguagem para a programação do sistema, ele também é adequado para resolver problemas aplicados de alto nível.  Você não precisa trabalhar com ponteiros brutos, a menos que precise deles para sua tarefa.  A biblioteca de idiomas padrão já implementou a maioria dos tipos e funções que podem ser necessárias no desenvolvimento de aplicativos.  Você também pode conectar facilmente bibliotecas externas e usá-las.  O sistema de tipos e a programação generalizada no Rust permitem o uso de abstrações de um nível bastante alto, embora não haja suporte direto para OOP na linguagem. </p><br><p>  Vejamos alguns exemplos simples de uso do Rust. </p><br><p>  Um exemplo de combinação de dois iteradores em um iterador sobre pares de elementos: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><blockquote>  Nota: uma chamada para o <code>name!(...)</code> do formato <code>name!(...)</code> é uma chamada para uma macro funcional.  Os nomes dessas macros no Rust sempre terminam com um símbolo <code>!</code>  para que eles possam ser distinguidos dos nomes das funções e outros identificadores.  Os benefícios do uso de macros serão discutidos abaixo. </blockquote><p>  Um exemplo de uso da biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>regex</code></a> externa para trabalhar com expressões regulares: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Um exemplo da implementação da <code>Add</code> para a própria estrutura <code>Point</code> para sobrecarregar o operador de adição: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Um exemplo de uso de um tipo genérico em uma estrutura: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  No Rust, você pode escrever utilitários de sistema eficientes, grandes aplicativos de desktop, microsserviços, aplicativos da Web (incluindo a parte do cliente, pois o Rust pode ser compilado no Wasm), aplicativos móveis (embora o ecossistema de idiomas ainda seja pouco desenvolvido nessa direção).  Essa versatilidade pode ser uma vantagem para equipes de multiprojetos, pois permite usar as mesmas abordagens e os mesmos módulos em muitos projetos diferentes.  Se você está acostumado com o fato de que cada ferramenta é projetada para seu campo de aplicação restrito, tente ver o Rust como uma caixa de ferramentas com a mesma confiabilidade e conveniência.  Talvez seja exatamente isso que você estava perdendo. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Ferramentas práticas de gerenciamento de compilação e dependência </h2><br><p>  Isso claramente não é anunciado, mas muitos percebem que o Rust possui um dos melhores sistemas de gerenciamento de compilação e dependência disponíveis atualmente.  Se você programou em C ou C ++, e a questão do uso indolor de bibliotecas externas foi bastante aguda para você, usar o Rust com sua ferramenta de construção e o gerenciador de dependência de carga será uma boa opção para seus novos projetos. </p><br><p>  Além do fato de o Cargo fazer download de dependências para você e gerenciar suas versões, criar e executar seus aplicativos, executar testes e gerar documentação, também pode ser expandido com plugins para outras funções úteis.  Por exemplo, existem extensões que permitem ao Cargo determinar as dependências obsoletas do seu projeto, realizar análises estáticas do código-fonte, criar e reimplantar partes de clientes de aplicativos da Web e muito mais. </p><br><p>  O arquivo de configuração do Cargo usa a linguagem de marcação amigável e mínima para descrever as configurações do projeto.  Aqui está um exemplo de um <code>Cargo.toml</code> configuração típico do <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  E abaixo estão três comandos típicos para usar o Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Com sua ajuda, o código-fonte será verificado quanto a erros de compilação, montagem do projeto e lançamento de testes, montagem e lançamento do programa para execução, respectivamente. </p><br><h2 id="3-vstroennye-testy">  3. Testes internos </h2><br><p>  Escrever testes de unidade no Rust é tão fácil e simples que você deseja fazer isso de novo e de novo.  :) Frequentemente, será mais fácil escrever um teste de unidade do que tentar testar a funcionalidade de outra maneira.  Aqui está um exemplo de funções e testes para eles: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  As funções no módulo de <code>test</code> , marcadas com o atributo <code>#[test]</code> , são testes de unidade.  Eles serão executados em paralelo quando o comando de <code>cargo test</code> for chamado.  O atributo de compilação condicional <code>#[cfg(test)]</code> , que marca todo o módulo com testes, levará ao fato de que o módulo será compilado somente quando os testes forem executados, mas não entrará na montagem normal. </p><br><p>  É muito conveniente colocar os testes no mesmo módulo que o funcional em teste, simplesmente adicionando o submódulo de <code>test</code> a ele.  E se você precisar de testes de integração, basta colocá-los no diretório de <code>tests</code> na raiz do projeto e usar seu aplicativo neles como um pacote externo.  Um módulo de <code>test</code> separado e as diretivas de compilação condicional nesse caso não precisam ser adicionadas. </p><br><p>  Exemplos especiais de documentação executada como testes merecem atenção especial, mas isso será discutido abaixo. </p><br><p>  Testes de desempenho internos (benchmarks) também estão disponíveis, mas ainda não são estáveis, portanto, estão disponíveis apenas em montagens noturnas do compilador.  No Rust estável, você precisará usar bibliotecas externas para esse tipo de teste. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Boa documentação com exemplos atuais </h2><br><p>  A biblioteca Rust padrão está muito bem documentada.  A documentação HTML é gerada automaticamente a partir do código-fonte com descrições de descontos nos comentários do dock.  Além disso, os comentários do documento no código Rust contêm código de amostra que é executado quando os testes são executados.  Isso garante a relevância dos exemplos: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>A documentação</em></a> </p><br><p>  Aqui está um exemplo do uso do método <code>as_bytes</code> do tipo <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  será executado como um teste durante o lançamento dos testes. </p><br><p>  Além disso, a prática de criar exemplos de seu uso na forma de pequenos programas independentes localizados no diretório de <code>examples</code> na raiz do projeto é comum para as bibliotecas Rust.  Esses exemplos também são uma parte importante da documentação e também são compilados e executados durante a execução do teste, mas podem ser executados independentemente dos testes. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Dedução automática inteligente de tipos </h2><br><p>  Em um programa Rust, você não pode especificar explicitamente o tipo de expressão se o compilador puder produzi-la automaticamente com base no contexto de uso.  E isso se aplica não apenas aos locais onde as variáveis ​​são declaradas.  Vejamos um exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Se organizarmos as anotações de tipo, este exemplo será semelhante a este: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Ou seja, temos um vetor de fatias de sequência e uma variável do tipo fatia de sequência.  Mas, neste caso, a especificação de tipos é completamente redundante, pois o compilador pode produzi-los por si só (usando a versão estendida do algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hindley-Milner</a> ).  O fato de <code>vec</code> ser um vetor já é claro pelo tipo de valor de retorno de <code>Vec::new()</code> , mas ainda não está claro qual será o tipo de seus elementos.  O fato de o tipo de <code>text</code> ser uma fatia de sequência é compreensível pelo fato de ser atribuído um literal desse tipo.  Assim, após <code>vec.push(text)</code> , o tipo de elementos do vetor se torna óbvio.  Observe que o tipo da variável <code>vec</code> foi completamente determinado por seu uso no encadeamento de execução, e não no estágio de inicialização. </p><br><p>  Esse sistema de inferência de tipo elimina o ruído do código e o torna tão conciso quanto o código em alguma linguagem de programação de tipo dinâmico.  E isso mantendo a digitação estática estrita! </p><br><p>  Obviamente, não podemos nos livrar completamente da digitação em um idioma estaticamente digitado.  O programa deve ter pontos nos quais os tipos de objetos têm garantia de serem conhecidos, para que em outros locais esses tipos possam ser exibidos.  Tais pontos no Rust são declarações de tipos de dados definidos pelo usuário e assinaturas de funções, nas quais não se pode deixar de especificar os tipos utilizados.  Mas você pode inserir "meta-variáveis ​​de tipos" nelas, usando programação generalizada. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Correspondência de padrões em pontos de declaração variáveis </h2><br><p>  <code>let</code> operação </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  não é realmente limitado a apenas declarar novas variáveis.  O que ela realmente faz é igualar a expressão à direita do sinal de igual com o padrão à esquerda.  E novas variáveis ​​podem ser introduzidas como parte da amostra (e somente isso).  Dê uma olhada no exemplo a seguir e ele ficará mais claro: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  A desestruturação é realizada aqui: essa comparação apresentará as variáveis <code>x</code> e <code>y</code> , que serão inicializadas com o valor dos campos <code>x</code> e <code>y</code> do objeto da estrutura <code>Point</code> , retornado pela chamada <code>Point::new()</code> .  Ao mesmo tempo, a comparação está correta, pois o tipo de expressão à direita corresponde ao padrão de <code>Point</code> do tipo <code>Point</code> à esquerda.  De maneira semelhante, você pode pegar, por exemplo, os dois primeiros elementos de uma matriz: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  E muito mais a fazer.  O mais notável é que essas comparações são realizadas em todos os locais em que novos nomes de variáveis ​​podem ser inseridos no Rust, a saber: na <code>match</code> , <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , no cabeçalho do loop <code>for</code> , nos argumentos de funções e fechamentos.  Aqui está um exemplo de como usar elegantemente a correspondência de padrões em um loop <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  O método <code>enumerate</code> , chamado no iterador, constrói um novo iterador, que iterará não sobre os valores iniciais, mas as tuplas, pares "índice ordinal, valor inicial".  Cada uma dessas tuplas durante a iteração do ciclo será mapeada para o padrão especificado <code>(i, ch)</code> , como resultado da variável <code>i</code> receberá o primeiro valor da tupla - o índice e a variável <code>ch</code> - o segundo, ou seja, o caractere da string.  Mais adiante, no corpo do loop, podemos usar essas variáveis. </p><br><p>  Outro exemplo popular de usar um padrão em um loop <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Aqui, simplesmente ignoramos o valor do iterador usando o padrão <code>_</code> .  Porque não usamos o número da iteração no corpo do loop.  O mesmo pode ser feito, por exemplo, com um argumento de função: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Ou ao fazer a correspondência em uma declaração de <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  A correspondência de padrões torna o código muito compacto e expressivo e, na declaração de <code>match</code> , geralmente é insubstituível.  O operador de <code>match</code> é um operador de análise variada completa, portanto você não poderá esquecer acidentalmente de verificar algumas das correspondências possíveis para a expressão analisada nela. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Extensão de sintaxe e DSL personalizado </h2><br><p>  A sintaxe da ferrugem é limitada, em grande parte devido à complexidade do sistema de tipos usado no idioma.  Por exemplo, Rust não possui argumentos de função nomeados ou funções com um número variável de argumentos.  Mas você pode contornar essas e outras limitações com macros.  O Rust possui dois tipos de macros: declarativo e processual.  Com macros declarativas, você nunca terá os mesmos problemas que as macros em C, porque são higiênicas e não funcionam no nível de substituição de texto, mas no nível de substituição na árvore de sintaxe abstrata.  As macros permitem criar abstrações no nível da sintaxe do idioma.  Por exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Além do fato de que essa macro expande os recursos sintáticos de chamar a "função" de imprimir uma cadeia de caracteres formatada, também verificará em sua implementação que os argumentos de entrada correspondem à cadeia de formato especificada no tempo de compilação e não no tempo de execução.  Usando macros, você pode inserir sintaxe concisa para suas próprias necessidades de design, criar e usar DSL.  Aqui está um exemplo do uso de código JavaScript dentro de um programa Rust compilando no Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  <code>js!</code> macro <code>js!</code>  definido no pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>stdweb</code></a> e permite incorporar código JavaScript completo em seu programa (com exceção de cadeias e operadores de aspas simples não concluídas com ponto-e-vírgula) e usar objetos do código Rust usando a sintaxe <code>@{expr}</code> . </p><br><p>  As macros oferecem enormes oportunidades para adaptar a sintaxe dos programas Rust às tarefas específicas de uma área específica.  Eles economizarão seu tempo e atenção ao desenvolver aplicativos complexos.  Não aumentando a sobrecarga do tempo de execução, mas aumentando o tempo de compilação.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Geração automática de código dependente </h2><br><p>  As macros de derivação processual da Rust são amplamente usadas para implementar automaticamente características e outra geração de código.  Aqui está um exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Como todos esses tipos ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> e <code>Eq</code> ) da biblioteca padrão são implementados para o tipo de campo da estrutura <code>i32</code> , sua implementação pode ser exibida automaticamente para toda a estrutura como um todo.  Outro exemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Aqui, usando as <code>Deserialize</code> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>serde</code></a> biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>serde</code></a> para a estrutura <code>Point</code> , são gerados automaticamente métodos para sua serialização e desserialização.  Em seguida, você pode passar uma instância dessa estrutura para várias funções de serialização, por exemplo, convertendo-a em uma sequência JSON. </p><br><p>  Você pode criar suas próprias macros processuais que irão gerar o código necessário.  Ou use as muitas macros já criadas por outros desenvolvedores.  Além de salvar o programador de escrever código padrão, as macros também têm a vantagem de que você não precisa manter seções diferentes do código em um estado consistente.  Por exemplo, se um terceiro campo <code>z</code> for adicionado à estrutura <code>Point</code> , para fazer sua serialização corretamente, se você usar derivar, não precisará fazer mais nada.  Se nós mesmos implementarmos as características necessárias para a serialização do <code>Point</code> , teremos que garantir que essa implementação seja sempre consistente com as alterações mais recentes na estrutura do <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Tipo de dados algébrico </h2><br><p>  Simplificando, um tipo de dados algébrico é um tipo de dados composto que é uma união de estruturas.  Mais formalmente, é uma soma de tipos de produtos.  No Rust, esse tipo é definido usando a palavra-chave <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  O tipo de um valor específico de uma variável do tipo <code>Message</code> pode ser apenas um dos tipos de estrutura listados em <code>Message</code> .  Essa é uma estrutura <code>Quit</code> sem campo, semelhante a uma unidade, uma das estruturas de tupla <code>ChangeColor</code> ou <code>Write</code> com campos sem nome ou a estrutura <code>Move</code> comum.  Um tipo enumerado tradicional pode ser representado como um caso especial de um tipo de dados algébrico: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  É possível descobrir que tipo realmente recebeu valor em um caso específico usando a correspondência de padrões: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  Na forma de tipos de dados algébricos, o Rust implementa tipos importantes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Option</code></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Result</code></a> , que são usados ​​para representar o valor ausente e o resultado correto / incorreto, respectivamente.  Veja como o <code>Option</code> é definido na biblioteca padrão: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Ferrugem não tem um valor nulo, assim como os erros irritantes de uma chamada inesperada.  Em vez disso, onde é realmente necessário indicar a possibilidade de um valor ausente, <code>Option</code> usada: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>Executar</em></a> </p><br><p>  O tipo de dados algébrico é uma ferramenta poderosa e expressiva que abre as portas para o desenvolvimento orientado a tipos.  Um programa escrito com competência nesse paradigma atribui a maioria das verificações da correção de seu trabalho ao sistema de tipos.  Portanto, se você não tiver um pouco de Haskell na programação industrial cotidiana, o Rust pode ser sua saída.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Fácil refatoração </h2><br><p>  O sistema estrito de tipo estático desenvolvido no Rust e a tentativa de realizar o maior número possível de verificações durante a compilação levam ao fato de que modificar e refatorar o código se torna bastante simples e seguro.  Se, após as alterações, o programa foi compilado, isso significa que ele deixou apenas erros lógicos que não estavam relacionados à funcionalidade cuja verificação foi atribuída ao compilador.  Combinado com a facilidade de adicionar testes de unidade à lógica de teste, isso leva a sérias garantias da confiabilidade dos programas e a um aumento da confiança do programador na operação correta de seu código após fazer alterações. </p><br><hr><br><p>  Talvez seja sobre isso que eu queria falar neste artigo.  Obviamente, o Rust tem muitas outras vantagens, além de várias desvantagens (alguma umidade da linguagem, falta de expressões familiares de programação e sintaxe “não literária”), que não são mencionadas aqui.  Se você tem algo a dizer sobre eles, escreva nos comentários.  Em geral, tente Rust na prática.  E talvez as vantagens dele para você superem todas as deficiências dele, como aconteceu no meu caso.  E, finalmente, você obterá exatamente o conjunto de ferramentas necessárias por um longo tempo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430294/">https://habr.com/ru/post/pt430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430282/index.html">9 em cada 10 pessoas concordam em ganhar menos com um trabalho mais significativo</a></li>
<li><a href="../pt430284/index.html">O resumo de materiais interessantes para o desenvolvedor móvel # 275 (12 a 18 de novembro)</a></li>
<li><a href="../pt430286/index.html">Detalhes do lado obscuro e confuso dos jogos piratas para o Nintendo Switch</a></li>
<li><a href="../pt430290/index.html">Uma tentativa de prever a quarta iteração do projeto SpaceX BFR</a></li>
<li><a href="../pt430292/index.html">Electronic Frontier Foundation: o desempenho da rede de placas da polícia dos EUA é de 0,5%</a></li>
<li><a href="../pt430296/index.html">Faça suas idéias virem app. Aplicativo sem servidor - instruções passo a passo</a></li>
<li><a href="../pt430300/index.html">Microsserviços on Go com o kit Go: Introdução</a></li>
<li><a href="../pt430302/index.html">Uma introdução ao ptrace ou injeção de código no sshd por diversão</a></li>
<li><a href="../pt430304/index.html">Um posto avançado maravilhoso em órbita</a></li>
<li><a href="../pt430306/index.html">O primeiro túnel da Companhia Chata perfurado por Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>