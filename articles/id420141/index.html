<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŠ ğŸ‘¨ğŸ¾â€ğŸ“ ğŸ‘¼ Dari MPMS DBMS yang dimuat - Danau Data peppy dengan alat analitis: bagikan detail pembuatannya â™Šï¸ ğŸš£ğŸ» ğŸ’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Semua organisasi yang setidaknya ada hubungannya dengan data cepat atau lambat menghadapi masalah menyimpan database relasional dan tidak terstruktur....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dari MPMS DBMS yang dimuat - Danau Data peppy dengan alat analitis: bagikan detail pembuatannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vtb/blog/420141/">  Semua organisasi yang setidaknya ada hubungannya dengan data cepat atau lambat menghadapi masalah menyimpan database relasional dan tidak terstruktur.  Tidak mudah untuk menemukan pendekatan yang nyaman, efektif dan murah untuk masalah ini secara bersamaan.  Dan untuk memastikan bahwa para ilmuwan data dapat berhasil bekerja dengan model pembelajaran mesin.  Kami berhasil - dan meskipun saya harus mengotak-atiknya, keuntungan akhir bahkan lebih dari yang diharapkan.  Kami akan membahas semua detail di bawah ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/755/bd0/32c/755bd032c95a1b46c4f412d65c5a7bf4.png"><br><a name="habracut"></a><br>  Seiring waktu, jumlah data perusahaan yang luar biasa menumpuk di bank mana pun.  Jumlah yang sebanding hanya disimpan di perusahaan internet dan telekomunikasi.  Itu terjadi karena persyaratan peraturan yang tinggi.  Data-data ini tidak berbohong - kepala lembaga keuangan telah lama menemukan cara untuk mendapatkan keuntungan dari ini. <br><br>  Kita semua mulai dengan manajemen dan pelaporan keuangan.  Berdasarkan data ini, kami belajar cara membuat keputusan bisnis.  Seringkali ada kebutuhan untuk mendapatkan data dari beberapa sistem informasi bank, di mana kami membuat basis data dan sistem pelaporan konsolidasi.  Dari ini secara bertahap terbentuk apa yang sekarang disebut data warehouse.  Segera, berdasarkan penyimpanan ini, sistem kami yang lain mulai bekerja: <br><br><ul><li>  CRM analitik, memungkinkan untuk menawarkan produk yang lebih nyaman kepada klien; <br></li><li>  konveyor pinjaman yang membantu Anda dengan cepat dan akurat membuat keputusan tentang pinjaman; <br></li><li>  sistem loyalitas menghitung cashback atau poin bonus sesuai dengan mekanisme dengan kompleksitas yang berbeda-beda. <br></li></ul><br>  Semua tugas ini diselesaikan oleh aplikasi analitis yang menggunakan model pembelajaran mesin.  Semakin banyak model informasi yang dapat diambil dari repositori, semakin akurat model itu akan bekerja.  Kebutuhan mereka akan data tumbuh secara eksponensial. <br><br>  Tentang situasi ini kami datang ke dua atau tiga tahun yang lalu.  Pada saat itu, kami memiliki penyimpanan berdasarkan MPP Teradata DBMS menggunakan alat SAS Data Integration Studio ELT.  Kami membangun gudang ini sejak 2011 bersama dengan Glowbyte Consulting.  Lebih dari 15 sistem perbankan besar diintegrasikan ke dalamnya, dan pada saat yang sama, data yang cukup dikumpulkan untuk implementasi dan pengembangan aplikasi analitis.  Ngomong-ngomong, tepat pada waktu itu, volume data di lapisan utama toko, karena banyak tugas yang berbeda, mulai tumbuh secara non-linear, dan analitik klien tingkat lanjut menjadi salah satu arahan utama pengembangan bank.  Ya, dan data kami Para ilmuwan sangat ingin mendukungnya.  Secara umum, untuk membangun Platform Penelitian Data, bintang-bintang terbentuk sebagaimana mestinya. <br><br><h2>  Merencanakan solusi </h2><br>  Di sini perlu dijelaskan: perangkat lunak industri dan server adalah kesenangan yang mahal bahkan untuk bank besar.  Tidak setiap organisasi mampu untuk menyimpan sejumlah besar data dalam MPMS DBMS teratas.  Anda selalu harus membuat pilihan antara harga dan kecepatan, keandalan dan volume. <br><br>  Untuk memanfaatkan peluang yang ada, kami memutuskan untuk melakukan ini: <br><br><ul><li> Beban ELT dan bagian yang paling diminta dari data historis CD harus dibiarkan pada DBMS Teradata; <br></li><li>  kirimkan cerita lengkap ke Hadoop, yang memungkinkan Anda menyimpan informasi jauh lebih murah. <br></li></ul><br>  Sekitar waktu itu, ekosistem Hadoop menjadi tidak hanya modis, tetapi juga cukup andal, nyaman untuk digunakan perusahaan.  Itu perlu untuk memilih kit distribusi.  Anda bisa membuat sendiri atau menggunakan Apache Hadoop yang terbuka.  Tetapi di antara solusi perusahaan berdasarkan Hadoop, distribusi yang sudah jadi dari vendor lain - Cloudera dan Hortonworks - telah membuktikan diri mereka lebih banyak.  Karena itu, kami juga memutuskan untuk menggunakan distribusi yang sudah jadi. <br><br>  Karena tugas utama kami masih menyimpan data besar terstruktur, di tumpukan Hadoop kami tertarik pada solusi yang sedekat mungkin dengan DBMS SQL klasik.  Para pemimpin di sini adalah Impala dan Sarang.  Cloudera mengembangkan dan mengintegrasikan Impala, Hortonworks - solusi Hive. <br><br>  Untuk studi mendalam, kami mengorganisir pengujian beban untuk kedua DBMS, dengan mempertimbangkan beban profil untuk kami.  Saya harus mengatakan bahwa mesin pengolah data di Impala dan Hive sangat berbeda - Hive umumnya menyajikan beberapa opsi berbeda.  Namun, pilihan jatuh pada Impala - dan, karenanya, distribusi dari Cloudera. <br><br><h2>  Apa yang saya sukai tentang Impala </h2><br><ul><li>  <i>Eksekusi analitik kecepatan tinggi</i> karena pendekatan alternatif dalam kaitannya dengan MapReduce.  Hasil perhitungan menengah tidak terlipat dalam HDFS, yang secara signifikan mempercepat pemrosesan data. <br></li><li>  <i>Pekerjaan yang efisien dengan penyimpanan data parket di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Parket</a> .</i>  Untuk tugas analitis, tabel lebar yang disebut dengan banyak kolom sering digunakan.  Semua kolom jarang digunakan - kemampuan untuk meningkatkan dari HDFS hanya yang dibutuhkan untuk bekerja menghemat RAM dan secara signifikan mempercepat permintaan. <br></li><li>  <i>Solusi elegan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">filter runtime</a> yang mencakup pemfilteran bloom.</i>  Baik Hive dan Impala sangat terbatas dalam penggunaan indeks umum untuk DBMS klasik karena sifat sistem penyimpanan file HDFS.  Oleh karena itu, untuk mengoptimalkan pelaksanaan query SQL, mesin DBMS harus secara efektif menggunakan partisi yang tersedia bahkan ketika tidak ditentukan secara eksplisit dalam kondisi permintaan.  Selain itu, ia perlu mencoba memprediksi jumlah data minimum dari HDFS yang perlu dinaikkan untuk pemrosesan yang dijamin dari semua baris.  Di Impala, ini bekerja dengan sangat baik. <br></li><li>  <i>Impala <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan LLVM</a></i> , kompiler mesin virtual dengan instruksi seperti RISC, untuk menghasilkan kode eksekusi query SQL yang optimal. <br></li><li>  <i>Antarmuka ODBC dan JDBC didukung.</i>  Ini memungkinkan Anda untuk mengintegrasikan data Impala dengan alat dan aplikasi analitik hampir di luar kotak. <br></li><li>  <i>Dimungkinkan untuk menggunakan Kudu</i> untuk menghindari beberapa keterbatasan HDFS, dan, khususnya, menulis konstruksi UPDATE dan DELETE dalam query SQL. <br></li></ul><br><h2>  Sqoop dan sisanya dari arsitektur </h2><br>  Alat terpenting berikutnya pada tumpukan Hadoop adalah Sqoop bagi kami.  Ini memungkinkan Anda untuk mentransfer data antara DBMS relasional (kami tentu saja tertarik pada Teradata) dan HDFS dalam cluster Hadoop dalam berbagai format, termasuk Parket.  Dalam pengujian, Sqoop menunjukkan fleksibilitas dan kinerja yang tinggi, jadi kami memutuskan untuk menggunakannya - alih-alih mengembangkan alat kami sendiri untuk mengambil data melalui ODBC / JDBC dan menyimpan ke HDFS. <br><br>  Untuk model pelatihan dan tugas terkait dari Ilmu Data, yang lebih nyaman untuk dieksekusi langsung pada cluster Hadoop, kami menggunakan Apache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spark</a> .  Di bidangnya, ini telah menjadi solusi standar - dan ada alasan: <br><br><ul><li>  Perpustakaan Belajar Mesin Spark ML <br></li><li>  dukungan untuk empat bahasa pemrograman (Scala, Java, Python, R); <br></li><li>  integrasi dengan alat analitis; <br></li><li>  pemrosesan data dalam memori memberikan kinerja yang sangat baik. <br></li></ul><br>  Server Oracle Big Data Appliance dibeli sebagai platform perangkat keras.  Kami mulai dengan enam node dalam sirkuit produktif dengan CPU 2x24-core dan masing-masing 256 GB memori.  Konfigurasi saat ini berisi 18 node yang sama dengan memori yang diperluas hingga 512 GB. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58f/173/025/58f173025e987a85582e383fd5f4b3d9.png"><br><br>  Diagram menunjukkan arsitektur tingkat atas dari Platform Penelitian Data dan sistem terkait.  Tautan pusat adalah cluster Hadoop berdasarkan distribusi Cloudera (CDH).  Ini digunakan baik untuk menerima dengan Sqoop dan menyimpan data QCD dalam HDFS - dalam format parket, memungkinkan penggunaan codec untuk kompresi, misalnya, Snappy.  Cluster juga memproses data: Impala digunakan untuk transformasi seperti ELT, Spark - untuk tugas-tugas Ilmu Data.  Sentry digunakan untuk berbagi akses data. <br><br>  Impala memiliki antarmuka untuk hampir semua alat analisis perusahaan modern.  Selain itu, alat sewenang-wenang yang mendukung antarmuka ODBC / JDBC dapat dihubungkan sebagai klien.  Untuk bekerja dengan SQL, kami mempertimbangkan Hue dan TOAD untuk Hadoop sebagai klien utama. <br><br>  Subsistem ETL yang terdiri dari alat SAS (Metadata Server, Data Integration Studio) dan kerangka kerja ETL yang ditulis berdasarkan SAS dan skrip shell menggunakan database untuk menyimpan metadata proses ETL digunakan untuk mengelola semua aliran yang ditunjukkan oleh panah pada diagram. .  Dipandu oleh aturan yang ditentukan dalam metadata, subsistem ETL meluncurkan proses pemrosesan data baik pada QCD maupun pada Platform Penelitian Data.  Sebagai hasilnya, kami memiliki sistem ujung ke ujung untuk memantau dan mengelola aliran data terlepas dari lingkungan yang digunakan (Teradata, Impala, Spark, dll., Jika perlu). <br><br><h2>  Melalui menyapu ke bintang-bintang </h2><br>  Membongkar QCD tampaknya sederhana.  Pada input dan output, DBMS relasional, ambil dan limpahkan data melalui Sqoop.  Menilai dari uraian di atas, semuanya berjalan sangat lancar dengan kami, tetapi, tentu saja, itu bukan tanpa petualangan, dan ini mungkin bagian yang paling menarik dari keseluruhan proyek. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c7/011/2fc/5c70112fc6dae573401cfd4a85733514.png"><br><br>  Dengan volume kami, kami tidak bisa berharap untuk mentransfer semua data sepenuhnya setiap hari.  Oleh karena itu, dari setiap fasilitas penyimpanan, perlu dipelajari cara membedakan kenaikan yang dapat diandalkan, yang tidak selalu mudah ketika data untuk tanggal bisnis yang bersejarah dapat berubah dalam tabel.  Untuk mengatasi masalah ini, kami mensistematisasikan objek tergantung pada metode pemuatan dan pemeliharaan riwayat.  Kemudian, untuk setiap jenis, predikat yang benar untuk Sqoop dan metode pemuatan ke penerima ditentukan.  Dan akhirnya, mereka menulis instruksi untuk pengembang objek baru. <br><br>  Sqoop adalah alat yang sangat berkualitas tinggi, tetapi tidak dalam semua kasus dan kombinasi sistem ini bekerja sangat andal.  Pada volume kami, konektor ke Teradata tidak berfungsi secara optimal.  Kami mengambil keuntungan dari kode sumber terbuka Sqoop dan membuat perubahan pada pustaka konektor.  Stabilitas koneksi saat memindahkan data telah meningkat. <br><br>  Untuk beberapa alasan, ketika Sqoop memanggil Teradata, predikat tidak sepenuhnya benar dikonversi ke kondisi WHERE.  Karena itu, Sqoop terkadang mencoba mengeluarkan meja besar dan memfilternya nanti.  Kami gagal menambal konektor di sini, tetapi kami menemukan cara lain: secara paksa membuat tabel sementara dengan predikat yang dikenakan untuk setiap objek yang dibongkar dan meminta Sqoop untuk melimpahi itu. <br><br>  Semua MPP, dan Teradata khususnya, memiliki fitur terkait penyimpanan data paralel dan eksekusi instruksi.  Jika fitur ini tidak diperhitungkan, maka mungkin ternyata semua pekerjaan akan diambil alih oleh satu node logis dari cluster, yang akan membuat eksekusi query lebih lambat, sekali dalam 100-200.  Tentu saja, kami tidak dapat membiarkan ini, oleh karena itu, kami menulis mesin khusus yang menggunakan metadata ETL dari tabel QCD dan memilih tingkat paralelisasi tugas Sqoop yang optimal. <br><br>  Historisitas dalam penyimpanan adalah masalah yang rumit, terutama jika Anda menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SCD2</a> , sementara Impala tidak mendukung UPDATE dan DELETE.  Tentu saja, kami ingin tabel historis dalam Platform Penelitian Data terlihat persis sama dengan di Teradata.  Ini dapat dicapai dengan menggabungkan kenaikan penerimaan melalui Sqoop, menyoroti kunci bisnis yang diperbarui dan menghapus partisi di Impala.  Agar logika yang rumit ini tidak harus ditulis oleh masing-masing pengembang, kami mengemasnya ke perpustakaan khusus (di "slang" loader ETL kami). <br><br>  Akhirnya - pertanyaan dengan tipe data.  Impala cukup bebas mengetik konversi, jadi kami menemui beberapa kesulitan hanya pada tipe TIMESTAMP dan CHAR / VARCHAR.  Untuk tanggal-waktu, kami memutuskan untuk menyimpan data dalam Impala dalam format teks (STRING) YYYY-MM-DD HH: MM: SS.  Pendekatan ini, ternyata, memungkinkan untuk menggunakan fungsi mengubah tanggal dan waktu.  Untuk data string dengan panjang tertentu, ternyata penyimpanan dalam format STRING di Impala tidak kalah dengan mereka, oleh karena itu kami juga menggunakannya. <br><br>  Biasanya, untuk mengatur Danau Data, mereka menyalin data sumber dalam format semi-terstruktur ke area tahap khusus di Hadoop, setelah itu Hive atau Impala mengatur skema deserialisasi untuk data ini untuk digunakan dalam kueri SQL.  Kami pergi dengan cara yang sama.  Penting untuk dicatat bahwa tidak semuanya dan tidak selalu masuk akal untuk menarik data warehouse, karena pengembangan proses penyalinan file dan pemasangan skema jauh lebih murah daripada memuat atribut bisnis ke dalam model QCD menggunakan proses ETL menggunakan proses ETL.  Ketika masih belum jelas berapa, untuk berapa lama dan dengan frekuensi berapa data sumber dibutuhkan, Data Lake dalam pendekatan yang dijelaskan adalah solusi sederhana dan murah.  Sekarang kami secara teratur mengunggah ke Danau Data terutama sumber yang menghasilkan peristiwa pengguna: data analisis aplikasi, log dan skenario transisi untuk Avaya auto dialer dan mesin penjawab, transaksi kartu. <br><br><h2>  Perangkat Analis </h2><br>  Kami tidak melupakan tujuan lain dari keseluruhan proyek - untuk memungkinkan analis untuk menggunakan semua kekayaan ini.  Berikut adalah prinsip-prinsip dasar yang membimbing kami di sini: <br><br><ul><li>  Kenyamanan alat dalam penggunaan dan dukungan <br></li><li>  Penerapan dalam Tugas Ilmu Data <br></li><li>  Kemungkinan maksimum menggunakan sumber daya komputasi cluster Hadoop, daripada server aplikasi atau komputer peneliti <br></li></ul><br>  Dan inilah yang kami singgahi: <br><br><ul><li>  Python + Anaconda.  Lingkungan yang digunakan adalah iPython / Jupyter <br></li><li>  R + Shiny.  Peneliti bekerja di desktop atau versi web R Studio, Shiny digunakan untuk mengembangkan aplikasi web yang dipertajam oleh penggunaan algoritma yang dikembangkan dalam R. <br></li><li>  Spark  Untuk bekerja dengan data, antarmuka untuk Python (pyspark) dan R digunakan, yang dikonfigurasi dalam lingkungan pengembangan yang ditentukan dalam paragraf sebelumnya.  Kedua antarmuka memungkinkan Anda untuk menggunakan perpustakaan Spark ML, yang memungkinkan untuk melatih model ML pada kluster Hadoop / Spark. <br></li><li>  Data Impala dapat diakses melalui Hue, Spark dan dari lingkungan pengembangan menggunakan antarmuka ODBC standar dan perpustakaan khusus seperti implyr <br></li></ul><br>  Saat ini, Data Lake berisi sekitar 100 TB data dari penyimpanan ritel, ditambah sekitar 50 TB dari sejumlah sumber OLTP.  Danau diperbarui setiap hari secara bertahap.  Di masa mendatang, kami akan meningkatkan kenyamanan pengguna, memperkenalkan beban ELT di Impala, menambah jumlah sumber yang diunggah ke Data Lake, dan memperluas peluang untuk analitik lanjutan. <br><br>  Sebagai kesimpulan, saya ingin memberikan beberapa saran umum kepada rekan-rekan yang baru memulai perjalanan mereka dalam menciptakan repositori besar: <br><br><ul><li>  Gunakan praktik terbaik.  Jika kami tidak memiliki subsistem ETL, metadata, penyimpanan berversi dan arsitektur yang dapat dimengerti, kami tidak akan menguasai tugas ini.  Praktik terbaik membayar sendiri, meskipun tidak segera. <br></li><li>  Ingat jumlah data.  Data besar dapat membuat kesulitan teknis di tempat yang sangat tidak terduga. <br></li><li>  Tetap disini untuk teknologi baru.  Solusi baru sering muncul, tidak semuanya berguna, tetapi terkadang permata asli ditemukan. <br></li><li>  Eksperimen lebih banyak.  Jangan hanya mempercayai deskripsi pemasaran dari solusi - cobalah sendiri. <br></li></ul><br>  <i>Omong-omong, Anda dapat membaca tentang bagaimana analis kami menggunakan pembelajaran mesin dan data bank untuk bekerja dengan risiko kredit di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos</a> terpisah.</i> <i><br></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420141/">https://habr.com/ru/post/id420141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420129/index.html">Pola asyncio coroutine: menunggu di luar</a></li>
<li><a href="../id420131/index.html">Metode Penambangan Bitcoin Probabilistik</a></li>
<li><a href="../id420133/index.html">Pemodelan sistem dinamis: Bagaimana bulan bergerak?</a></li>
<li><a href="../id420135/index.html">Ini juga Toshiba: produk yang tidak terduga dari perusahaan Jepang</a></li>
<li><a href="../id420139/index.html">Buku â€œRekayasa Keandalan Situs. Keandalan dan keandalan seperti di Google Â»</a></li>
<li><a href="../id420143/index.html">Performa Kotlin di Android</a></li>
<li><a href="../id420145/index.html">Bagaimana hari kerja para anggota PC AppsConf</a></li>
<li><a href="../id420147/index.html">OpenSource di Clojure</a></li>
<li><a href="../id420151/index.html">Lebih mudah daripada kedengarannya. Bab 12</a></li>
<li><a href="../id420153/index.html">Pencetakan 3D bagian kompleks yang terbuat dari ABS dan PLA dengan banyak dukungan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>