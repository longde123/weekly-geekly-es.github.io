<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 🙇🏿 📵 Práctica: consejos para escribir programas compatibles en el mundo real 🔚 🚞 💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo se centra en las mejores prácticas para escribir el código Go. Está compuesto en el estilo de presentación, pero sin las diapositivas ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Práctica: consejos para escribir programas compatibles en el mundo real</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441842/">  Este artículo se centra en las mejores prácticas para escribir el código Go.  Está compuesto en el estilo de presentación, pero sin las diapositivas habituales.  Intentaremos revisar breve y claramente cada elemento. <br><br>  Primero debe acordar qué significan las <i>mejores</i> prácticas para un lenguaje de programación.  Aquí puede recordar las palabras de Russ Cox, director técnico de Go: <br><br><blockquote>  La ingeniería de software es lo que sucede con la programación, si agrega el factor tiempo y otros programadores. </blockquote><br>  Por lo tanto, Russ distingue entre los conceptos de <i>programación</i> e <i>ingeniería de software</i> .  En el primer caso, usted escribe un programa para usted, en el segundo crea un producto en el que otros programadores trabajarán con el tiempo.  Los ingenieros van y vienen.  Los equipos crecen o se reducen.  Se agregan nuevas funciones y se corrigen errores.  Esta es la naturaleza del desarrollo de software. <br><a name="habracut"></a><br><a name="0"></a><h1>  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenido</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1. Principios fundamentales</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simplicidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Legibilidad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Productividad</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2. Identificadores</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Identificadores de nombre basados ​​en la claridad en lugar de la brevedad</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ID longitud</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">No nombrar variables por tipo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Use un solo estilo de nomenclatura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Use un estilo de declaración único</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trabajar para el equipo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3. Comentarios</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los comentarios en variables y constantes deben describir su contenido, no su propósito</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Siempre documente personajes disponibles públicamente</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4. estructura del paquete</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un buen paquete comienza con un buen nombre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evite nombres como base, común o util</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regresa rápidamente sin zambullirte profundamente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hacer que el valor nulo sea útil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Evitar estado de nivel de paquete</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5. Estructura del proyecto</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Menos paquetes pero más grandes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El paquete principal más pequeño</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6. estructura API</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API de diseño que son difíciles de abusar por diseño</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diseñar una API para un caso de uso básico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deje que las funciones determinen el comportamiento deseado.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7. Manejo de errores</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elimine la necesidad de manejar errores eliminando los errores mismos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manejar el error solo una vez</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8. Concurrencia</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haz algo de trabajo todo el tiempo.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Deja paralelismo a la persona que llama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nunca ejecute goroutine sin saber cuándo se detendrá</a> </li></ul></li></ul><br><a name="1"></a><h1>  1. Principios fundamentales </h1><br>  Puedo ser uno de los primeros usuarios de Go entre ustedes, pero esta no es mi opinión personal.  Estos principios básicos son la base del propio Go: <br><br><ol><li>  Simplicidad </li><li>  Legibilidad </li><li>  Productividad </li></ol><br>  <i>Nota</i>  <i>Tenga en cuenta que no mencioné "rendimiento" o "concurrencia".</i>  <i>Hay idiomas más rápidos que Go, pero ciertamente no se pueden comparar en simplicidad.</i>  <i>Hay lenguajes que priorizan el paralelismo, pero no se pueden comparar en términos de legibilidad o productividad de programación.</i> <i><br><br></i>  <i>El rendimiento y la concurrencia son atributos importantes, pero no tan importantes como la simplicidad, la legibilidad y la productividad.</i> <br><br><a name="1_1"></a><h2>  Simplicidad </h2><br><blockquote>  <i>"La simplicidad es un requisito previo para la fiabilidad"</i> - Edsger Dijkstra </blockquote><br>  ¿Por qué luchar por la simplicidad?  ¿Por qué es importante que los programas Go sean simples? <br><br>  Cada uno de nosotros se encontró con un código incomprensible, ¿verdad?  Cuando tiene miedo de hacer un cambio porque romperá otra parte del programa que no comprende y no sabe cómo solucionar.  Esta es la dificultad. <br><br><blockquote>  <i>“Hay dos formas de diseñar software: la primera es hacerla tan simple que no haya fallas obvias, y la segunda es hacerla tan compleja que no haya fallas obvias.</i>  <i>El primero es mucho más difícil ”.</i> - C.E. R. Hoar </blockquote><br>  La complejidad convierte el software confiable en poco confiable.  La complejidad es lo que mata los proyectos de software.  Por lo tanto, la simplicidad es el objetivo final de Go.  Cualesquiera que sean los programas que escribamos, deberían ser simples. <br><br><a name="1_2"></a><h2>  1.2.  Legibilidad </h2><br><blockquote>  <i>"La legibilidad es una parte integral de la mantenibilidad"</i> - Mark Reinhold, Conferencia JVM, 2018 </blockquote><br>  ¿Por qué es importante que el código sea legible?  ¿Por qué debemos luchar por la legibilidad? <br><br><blockquote>  <i>"Los programas deben estar escritos para personas, y las máquinas simplemente los ejecutan"</i> - Hal Abelson y Gerald Sassman, "Estructura e interpretación de programas de computadora" </blockquote><br>  No solo los programas Go, sino que generalmente todo el software está escrito por personas para personas.  El hecho de que las máquinas también procesen código es secundario. <br><br>  Una vez que el código escrito sea leído repetidamente por la gente: cientos, si no miles de veces. <br><br><blockquote>  <i>"La habilidad más importante para un programador es la capacidad de comunicar ideas de manera efectiva".</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gaston Horker</a> </blockquote><br>  La legibilidad es la clave para comprender lo que hace un programa.  Si no puede entender el código, ¿cómo mantenerlo?  Si el software no puede ser soportado, será reescrito;  y esta puede ser la última vez que su empresa usa Go. <br><br>  Si está escribiendo un programa para usted, haga lo que funcione para usted.  Pero si esto es parte de un proyecto conjunto o si el programa se utilizará el tiempo suficiente para cambiar los requisitos, las funciones o el entorno en el que funciona, su objetivo es hacer que el programa sea sostenible. <br><br>  El primer paso para escribir software compatible es asegurarse de que el código sea claro. <br><br><a name="1_3"></a><h2>  1.3.  Productividad </h2><br><blockquote>  <i>"El diseño es el arte de organizar el código para que funcione hoy, pero siempre apoya el cambio".</i> - Sandy Mets </blockquote><br>  Como último principio básico, quiero nombrar la productividad del desarrollador.  Este es un gran tema, pero se reduce a la proporción: cuánto tiempo pasas en un trabajo útil y cuánto, esperando una respuesta de las herramientas o deambulaciones desesperadas en una base de código incomprensible.  Los programadores de Go deberían sentir que pueden manejar mucho trabajo. <br><br>  Es una broma que el lenguaje Go se desarrolló mientras se compilaba el programa C ++.  La compilación rápida es una característica clave de Go y un factor clave para atraer nuevos desarrolladores.  Aunque se están mejorando los compiladores, en general, la compilación de minutos en otros idiomas lleva unos segundos en Go.  Entonces, los desarrolladores de Go se sienten tan productivos como los programadores en lenguajes dinámicos, pero sin ningún problema con la confiabilidad de esos lenguajes. <br><br>  Si hablamos fundamentalmente sobre la productividad de los desarrolladores, entonces los programadores de Go comprenden que leer el código es esencialmente más importante que escribirlo.  En esta lógica, Go incluso llega a usar las herramientas para formatear todo el código en un estilo determinado.  Esto elimina la más mínima dificultad para aprender el dialecto específico de un proyecto en particular y ayuda a identificar errores porque simplemente se <i>ven</i> mal en comparación con el código normal. <br><br>  Los programadores de Go no pasan días depurando errores de compilación extraños, scripts de compilación complejos o implementando código en un entorno de producción.  Y lo más importante, no pierden el tiempo tratando de entender lo que escribió un colega. <br><br>  Cuando los desarrolladores de Go hablan de <i>escalabilidad</i> , se refieren a la productividad. <br><br><a name="2"></a><h1>  2. Identificadores </h1><br>  El primer tema que discutiremos: <i>identificadores</i> , es sinónimo de <i>nombres</i> : nombres de variables, funciones, métodos, tipos, paquetes, etc. <br><br><blockquote>  <i>"El mal nombre es un síntoma de mal diseño"</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dave Cheney</a> </blockquote><br>  Dada la sintaxis limitada de Go, los nombres de los objetos tienen un gran impacto en la legibilidad del programa.  La legibilidad es un factor clave en un buen código, por lo que elegir buenos nombres es crucial. <br><br><a name="2_1"></a><h2>  2.1.  Identificadores de nombre basados ​​en la claridad en lugar de la brevedad </h2><br><blockquote>  <i>“Es importante que el código sea obvio.</i>  <i>Lo que puedes hacer en una línea, debes hacerlo en tres. ”</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ukia Smith</a> </blockquote><br>  Go no está optimizado para frases complicadas o el número mínimo de líneas en un programa.  No optimizamos el tamaño del código fuente en el disco, ni el tiempo requerido para escribir el programa en el editor. <br><br><blockquote>  <i>“Un buen nombre es como un buen chiste.</i>  <i>Si necesita explicarlo, ya no es divertido ".</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dave Cheney</a> </blockquote><br>  La clave para la máxima claridad son los nombres que elegimos para identificar los programas.  ¿Qué cualidades son inherentes a un buen nombre? <br><br><ul><li>  <b>Un buen nombre es conciso</b> .  No tiene que ser el más corto, pero no contiene exceso.  Tiene una alta relación señal / ruido. </li><li>  <b>Un buen nombre es descriptivo</b> .  Describe el uso de una variable o constante, <i>no los</i> contenidos.  Un buen nombre describe el resultado de una función o el comportamiento de un método, <i>no una</i> implementación.  El propósito del paquete, <i>no</i> su contenido.  Cuanto más exactamente el nombre describa lo que identifica, mejor. </li><li>  <b>Un buen nombre es predecible</b> .  Por un nombre debes entender cómo se usará el objeto.  Los nombres deben ser descriptivos, pero también es importante seguir la tradición.  A eso se refieren los programadores de Go cuando dicen <i>"idiomático"</i> . </li></ul><br>  Consideremos con más detalle cada una de estas propiedades. <br><br><a name="2_2"></a><h2>  2.2.  ID longitud </h2><br>  A veces, el estilo de Go es criticado por nombres cortos de variables.  Como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dijo</a> Rob Pike, "los programadores de Go quieren identificadores de la longitud <i>correcta</i> ". <br><br>  Andrew Gerrand ofrece identificadores más largos para indicar importancia. <br><br><blockquote>  <i>"Cuanto mayor sea la distancia entre la declaración de un nombre y el uso de un objeto, más largo debe ser el nombre"</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Andrew Gerrand</a> </blockquote><br>  Por lo tanto, se pueden hacer algunas recomendaciones: <br><br><ul><li>  Los nombres cortos de variables son buenos si la distancia entre la declaración y el <i>último</i> uso es pequeña. <br></li><li>  Los nombres largos de variables deben justificarse a sí mismos;  cuanto más largos sean, más importantes deberían ser.  Los títulos detallados contienen poca señal en relación con su peso en la página. <br></li><li>  No incluya el nombre del tipo en el nombre de la variable. <br></li><li>  Los nombres constantes deben describir el valor interno, no cómo se usa el valor. <br></li><li>  Prefiera variables de una sola letra para bucles y ramas, palabras separadas para parámetros y valores de retorno, palabras múltiples para funciones y declaraciones a nivel de paquete. <br></li><li>  Prefiere palabras simples para métodos, interfaces y paquetes. <br></li><li>  Recuerde que el nombre del paquete es parte del nombre que usa la persona que llama como referencia. </li></ul><br>  Considera un ejemplo. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br>  En la décima línea, <code>p</code> declara una variable de rango <code>p</code> , y se llama solo una vez desde la siguiente línea.  Es decir, la variable vive en la página durante muy poco tiempo.  Si el lector está interesado en el papel de <code>p</code> en el programa, solo necesita leer dos líneas. <br><br>  A modo de comparación, las <code>people</code> declaran en los parámetros de la función y viven siete líneas.  Lo mismo ocurre con la <code>sum</code> y el <code>count</code> , por lo que justifican sus nombres más largos.  El lector necesita escanear más código para encontrarlos: esto justifica los nombres más distinguidos. <br><br>  Puede elegir <code>s</code> para <code>sum</code> <code>c</code> (o <code>n</code> ) para <code>count</code> , pero esto reduce la importancia de todas las variables en el programa al mismo nivel.  Puede reemplazar <code>people</code> con <code>p</code> , pero habrá un problema, cómo llamar a la variable de iteración <code>for ... range</code> .  Una sola <code>person</code> se verá extraña, porque una variable de iteración de corta duración obtiene un nombre más largo que varios valores de los que se deriva. <br><br><blockquote>  <b>Consejo</b>  Separe la secuencia de funciones con líneas vacías, ya que las líneas vacías entre párrafos interrumpen el flujo de texto.  En <code>AverageAge</code> , tenemos tres operaciones consecutivas.  Primero, verificando la división por cero, luego la conclusión de la edad total y el número de personas, y el último: el cálculo de la edad promedio. </blockquote><br><h3>  2.2.1.  Lo principal es el contexto. </h3><br>  Es importante comprender que la mayoría de los consejos de nombres son específicos del contexto.  Me gusta decir que este es un principio, no una regla. <br><br>  ¿Cuál es la diferencia entre <code>i</code> e <code>index</code> ?  Por ejemplo, no puede decir con certeza que dicho código <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  fundamentalmente más legible que <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  Creo que la segunda opción no es peor, porque en este caso la región <code>i</code> o <code>index</code> limitada por el cuerpo del ciclo <code>for</code> , y la verbosidad adicional agrega poco a la comprensión del programa. <br><br>  Pero, ¿cuál de estas funciones es más legible? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  o <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  En este ejemplo, <code>oid</code> es una abreviatura de ID de objeto SNMP, y la abreviatura adicional <code>o</code> obliga a cambiar de una notación documentada a una más corta en el código al leer el código.  Del mismo modo, reducir el <code>index</code> a <code>i</code> hace que sea más difícil de entender, porque en los mensajes SNMP, el subvalor de cada OID se denomina índice. <br><br><blockquote>  <b>Consejo</b>  No combine parámetros formales largos y cortos en un anuncio. </blockquote><br><a name="2_3"></a><h2>  2.3.  No nombrar variables por tipo </h2><br>  No llamas a tus mascotas "perro" y "gato", ¿verdad?  Por la misma razón, no debe incluir el nombre del tipo en el nombre de la variable.  Debe describir el contenido, no su tipo.  Considere un ejemplo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br>  ¿De qué sirve este anuncio?  Vemos que este es un mapa, y tiene algo que ver con el <code>*User</code> Tipo de <code>*User</code> : probablemente sea bueno.  Pero <code>usersMap</code> es <i>realmente un</i> mapa, y Go, como lenguaje estáticamente tipado, no permitirá usar accidentalmente dicho nombre cuando se requiera una variable escalar, por lo que el sufijo <code>Map</code> es redundante. <br><br>  Considere una situación en la que se agregan otras variables: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br>  Ahora tenemos tres variables de tipo de mapa: <code>usersMap</code> , <code>companiesMap</code> y <code>productsMap</code> , y todas las líneas se asignan a diferentes tipos.  Sabemos que estos son mapas, y también sabemos que el compilador arrojará un error si tratamos de usar <code>companiesMap</code> donde el código espera <code>map[string]*User</code> .  En esta situación, está claro que el sufijo <code>Map</code> no mejora la claridad del código, estos son solo caracteres adicionales. <br><br>  Sugiero evitar cualquier sufijo que se parezca al tipo de una variable. <br><br><blockquote>  <b>Consejo</b>  Si el nombre <code>users</code> no describe la esencia con suficiente claridad, entonces <code>usersMap</code> también. </blockquote><br>  Este consejo también se aplica a los parámetros de la función.  Por ejemplo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  El nombre de <code>config</code> para el parámetro <code>*Config</code> es redundante.  Ya sabemos que esto es <code>*Config</code> , se escribe inmediatamente al lado. <br><br>  En este caso, considere <code>conf</code> o <code>c</code> si la vida útil de la variable es lo suficientemente corta. <br><br>  Si en algún punto de nuestra área hay más de una <code>*Config</code> , los nombres <code>conf1</code> y <code>conf2</code> menos significativos que los <code>original</code> y <code>updated</code> , ya que estos últimos son más difíciles de mezclar. <br><br><blockquote>  <b>Nota</b>  No permita que los nombres de paquetes roben buenos nombres de variables. <br><br>  El nombre del identificador importado contiene el nombre del paquete.  Por ejemplo, el tipo de <code>Context</code> en el paquete de <code>context</code> se llamará <code>context.Context</code> .  Esto hace que sea imposible usar una variable o tipo de <code>context</code> en su paquete. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  Esto no se compilará.  Es por eso que al declarar el <code>context.Context</code> tipos de <code>context.Context</code> localmente, por ejemplo, nombres como <code>ctx</code> se usan tradicionalmente. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4.  Use un solo estilo de nomenclatura </h2><br>  Otra propiedad de un buen nombre es que debe ser predecible.  El lector debe entenderlo de inmediato.  Si este es un nombre <i>común</i> , entonces el lector tiene el derecho de asumir que no ha cambiado el significado del tiempo anterior. <br><br>  Por ejemplo, si el código va alrededor del descriptor de la base de datos, cada vez que se muestra el parámetro, debe tener el mismo nombre.  En lugar de todo tipo de combinaciones como <code>d *sql.DB</code> , <code>d *sql.DB</code> <code>dbase *sql.DB</code> , <code>DB *sql.DB</code> y la <code>database *sql.DB</code> , es mejor usar una cosa: <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br>  Es más fácil entender el código.  Si ve <code>db</code> , entonces sabe que es <code>*sql.DB</code> y que la persona que llama la declara localmente. <br><br>  Consejos similares con respecto a los destinatarios de un método;  use el mismo nombre de destinatario para cada método de este tipo.  Por lo tanto, será más fácil para el lector aprender el uso del destinatario entre los diversos métodos de este tipo. <br><br><blockquote>  <b>Nota</b>  El acuerdo de nombre corto de destinatario Go contradice las recomendaciones expresadas anteriormente.  Este es uno de esos casos donde la elección realizada en una etapa temprana se convierte en el estilo estándar, como usar <code>CamelCase</code> lugar de <code>snake_case</code> . </blockquote><br><blockquote>  <b>Consejo</b>  El estilo Ir apunta a nombres de una sola letra o abreviaturas para destinatarios derivados de su tipo.  Puede resultar que el nombre del destinatario a veces entra en conflicto con el nombre del parámetro en el método.  En este caso, se recomienda hacer que el nombre del parámetro sea un poco más largo y no olvide usarlo secuencialmente. </blockquote><br>  Finalmente, algunas variables de una letra se asocian tradicionalmente con bucles y recuento.  Por ejemplo, <code>i</code> , <code>j</code> y <code>k</code> suelen ser variables inductivas en bucles <code>for</code> , <code>n</code> suele asociarse con un contador o sumador acumulativo, <code>v</code> es una abreviatura típica de valor en una función de codificación, <code>k</code> suele utilizarse para una clave de mapa y <code>s</code> menudo se utiliza como abreviatura para parámetros de tipo <code>string</code> . <br><br>  Al igual que con el ejemplo <code>db</code> anterior, los programadores <i>esperan que</i> <code>i</code> sea ​​una variable inductiva.  Si lo ven en código, esperan ver un bucle pronto. <br><br><blockquote>  <b>Consejo</b>  Si tiene tantos bucles anidados que se ha quedado sin variables <code>i</code> , <code>j</code> y <code>k</code> , es posible que desee dividir la función en unidades más pequeñas. </blockquote><br><a name="2_5"></a><h2>  2.5.  Use un estilo de declaración único </h2><br>  Go tiene al menos seis formas diferentes de declarar una variable. <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br>  Estoy seguro de que aún no lo recuerdo todo.  Los desarrolladores de Go probablemente consideran esto un error, pero es demasiado tarde para cambiar algo.  Con esta elección, ¿cómo garantizar un estilo uniforme? <br><br>  Quiero proponer un estilo de declaración de variables que yo mismo trato de usar siempre que sea posible. <br><br><ul><li>  <b>Al declarar una variable sin inicialización, use <code>var</code></b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code> actúa como una pista de que esta variable se declara <i>intencionalmente</i> como un valor nulo del tipo especificado.  Esto es coherente con el requisito de declarar variables a nivel de paquete con <code>var</code> en oposición a la sintaxis de declaración corta, aunque argumentaré más adelante que las variables de nivel de paquete no deberían usarse en absoluto. </li><li>  <b>Al declarar con inicialización, use <code>:=</code></b> .  Esto deja en claro al lector que la variable a la izquierda de <code>:=</code> inicializa intencionalmente. <br><br>  Para explicar por qué, veamos el ejemplo anterior, pero esta vez inicializamos especialmente cada variable: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br>  Como Go no tiene conversiones automáticas de un tipo a otro, en el primer y tercer ejemplo, el tipo en el lado izquierdo del operador de asignación debe ser idéntico al tipo en el lado derecho.  El compilador puede inferir el tipo de la variable declarada del tipo de la derecha, por lo que el ejemplo se puede escribir de manera más concisa: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br>  Aquí, los <code>players</code> inicializan explícitamente a <code>0</code> , lo cual es redundante, porque el valor inicial de los <code>players</code> es cero en cualquier caso.  Por lo tanto, es mejor dejar en claro que queremos usar un valor nulo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  ¿Qué pasa con el segundo operador?  No podemos determinar el tipo y escribir <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br>  Porque <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no</a> <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo</a> .  En cambio, tenemos una opción: o usamos un valor cero para cortar ... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ... o crear un segmento con cero elementos? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  En el segundo caso, el valor para el segmento <i>no</i> es cero, y lo dejamos claro para el lector usando una forma corta de declaración: <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Esto le dice al lector que decidimos inicializar <code>things</code> explícitamente. <br><br>  Entonces llegamos a la tercera declaración: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Aquí, tanto la inicialización explícita de la variable como la introducción de la palabra clave "única" <code>new</code> , que a algunos programadores de Go no les gusta.  Usando los rendimientos recomendados de sintaxis corta <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Esto deja en claro que la <code>thing</code> inicializa explícitamente al resultado de <code>new(Thing)</code> , pero aún deja una <code>new</code> atípica.  El problema podría resolverse usando un literal: <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br>  Lo cual es similar a <code>new(Thing)</code> , y esa duplicación molesta a algunos programadores de Go.  Sin embargo, esto significa que inicializamos explícitamente la <code>thing</code> con un puntero a <code>Thing{}</code> y un valor de <code>Thing</code> de cero. <br><br>  Pero es mejor tener en cuenta el hecho de que la <code>thing</code> declara con un valor cero, y usar la dirección del operador para pasar la dirección de la <code>thing</code> en <code>json.Unmarshall</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>Nota</b>  Por supuesto, hay excepciones a cualquier regla.  Por ejemplo, a veces dos variables están estrechamente relacionadas, por lo que será extraño escribir <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Declaración más legible: <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br>  Para resumir: <br><br><ul><li>  Al declarar una variable sin inicialización, use la sintaxis <code>var</code> . <br></li><li>  Al declarar e inicializar explícitamente una variable, use <code>:=</code> . </li></ul><br><blockquote>  <b>Consejo</b>  Señale explícitamente cosas complejas. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Aquí, la <code>length</code> se puede usar con la biblioteca, que requiere un tipo numérico específico, y esta opción indica más claramente que la longitud del tipo se elige específicamente como uint32 que en la declaración breve: <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br>  En el primer ejemplo, rompo intencionalmente mi regla al usar la declaración var con inicialización explícita.  Una desviación del estándar hace que el lector entienda que algo inusual está sucediendo. </blockquote><br><a name="2_6"></a><h2>  2.6.  Trabajar para el equipo </h2><br>  Ya he dicho que la esencia del desarrollo de software es la creación de código legible y compatible.  La mayor parte de su carrera probablemente trabajará en proyectos conjuntos.  Mi consejo en esta situación: sigue el estilo adoptado en el equipo. <br><br>  Cambiar estilos en el medio del archivo es molesto.  La consistencia es importante, aunque en detrimento de la preferencia personal.  Mi regla de oro es: si el código se ajusta a través de <code>gofmt</code> , entonces el problema generalmente no merece la discusión. <br><br><blockquote>  <b>Consejo</b>  Si desea cambiar el nombre en toda la base de código, no mezcle esto con otros cambios.  Si alguien usa git bisect, no le gustará buscar miles de cambios de nombre para encontrar otro código modificado. </blockquote><br><h1>  3. Comentarios </h1><br>  Antes de pasar a puntos más importantes, quiero tomarme un par de minutos para comentar. <br><br><blockquote>  <i>"Un buen código tiene muchos comentarios, y un código malo necesita muchos comentarios".</i> - Dave Thomas y Andrew Hunt, Programador pragmático </blockquote><br>  Los comentarios son muy importantes para la legibilidad del programa.  Cada comentario debe hacer una, y solo una, de tres cosas: <br><br><ol><li>  Explica <i>qué hace el</i> código. </li><li>  Explica <i>cómo</i> lo hace. </li><li>  Explica <i>por qué</i> . </li></ol><br>  La primera forma es ideal para comentar sobre personajes públicos: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br>  El segundo es ideal para comentarios dentro de un método: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br>  La tercera forma ("por qué") es única en el sentido de que no reemplaza ni reemplaza las dos primeras.  Dichos comentarios explican los factores externos que llevaron a la escritura del código en su forma actual.  A menudo, sin este contexto, es difícil entender por qué el código está escrito de esta manera. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br>  En este ejemplo, puede que no esté claro de inmediato qué sucede cuando HealthyPanicThreshold se establece en cero por ciento.  El comentario pretende aclarar que un valor de 0 deshabilita el umbral de pánico. <br><br><a name="3_1"></a><h2>  3.1.  Los comentarios en variables y constantes deben describir su contenido, no su propósito </h2><br>  Anteriormente dije que el nombre de una variable o constante debería describir su propósito.  Pero un comentario sobre una variable o constante debe describir exactamente el <i>contenido</i> , no el <i>propósito</i> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br>  En este ejemplo, un comentario describe <i>por qué</i> <code>randomNumber</code> en 6 y de dónde proviene.  El comentario no describe dónde se <code>randomNumber</code> .  Aquí hay algunos ejemplos más: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>En el contexto de HTTP, el</i> número <code>100</code> conoce como <code>StatusContinue</code> , como se define en RFC 7231, sección 6.2.1. <br><br><blockquote>  <b>Consejo</b>  Para las variables sin un valor inicial, el comentario debe describir quién es responsable de inicializar esta variable. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br>  Aquí un comentario le dice al lector que la función <code>dowidth</code> responsable de mantener el estado de <code>sizeCalculationDisabled</code> . </blockquote><br><blockquote>  <b>Consejo</b>  Esconderse a la vista.  Este es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consejo de Kate Gregory</a> .  A veces, el mejor nombre para una variable está oculto en los comentarios. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br>  El autor agregó un comentario porque el <code>registry</code> nombres no explica suficientemente su propósito: este es un registro, pero ¿cuál es el registro? <br><br>  Si cambia el nombre de una variable a sqlDrivers, queda claro que contiene controladores SQL. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br>  Ahora el comentario se ha vuelto redundante y se puede eliminar. </blockquote><br><a name="3_2"></a><h2>  3.2.  Siempre documente personajes disponibles públicamente </h2><br>  Godoc genera la documentación de su paquete, por lo que debe agregar un comentario a cada carácter público declarado en el paquete: una variable, constante, función y método. <br><br>  Aquí hay dos pautas de la Guía de estilo de Google: <br><br><ul><li>  Cualquier función pública que no sea obvia y concisa debe ser comentada. <br></li><li>  Cualquier función en la biblioteca debe comentarse, independientemente de su longitud o complejidad. </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br>  Hay una excepción a esta regla: no necesita documentar los métodos que implementan la interfaz.  Específicamente, no hagas esto: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br>  Este comentario no significa nada.  No dice qué hace el método: peor, envía a algún lado a buscar documentación.  En esta situación, propongo eliminar completamente el comentario. <br><br>  Aquí hay un ejemplo del paquete <code>io</code> . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br>  Tenga en cuenta que la declaración de <code>LimitedReader</code> está precedida inmediatamente por la función que la utiliza, y la declaración de <code>LimitedReader.Read</code> sigue a la declaración de <code>LimitedReader</code> .  Aunque <code>LimitedReader.Read</code> sí no está documentado, se puede entender que se trata de una implementación de <code>io.Reader</code> . <br><br><blockquote>  <b>Consejo</b>  Antes de escribir una función, escriba un comentario describiéndola.  Si le resulta difícil escribir un comentario, entonces esta es una señal de que el código que está a punto de escribir será difícil de entender. </blockquote><br><h3>  3.2.1.  No comente sobre el código incorrecto, vuelva a escribirlo </h3><br><blockquote>  <i>"No comente el código incorrecto - Reescríbalo"</i> - Brian Kernighan </blockquote><br>  No es suficiente indicar en los comentarios la dificultad del fragmento de código.  Si encuentra alguno de estos comentarios, debe comenzar un ticket con un recordatorio de refactorización.  Puede vivir con deudas técnicas siempre que se conozca su monto. <br><br>  En la biblioteca estándar, se acostumbra dejar comentarios en el estilo TODO con el nombre del usuario que notó el problema. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br>  Esto no es una obligación para solucionar el problema, pero el usuario indicado puede ser la mejor persona para hacer una pregunta.  Otros proyectos acompañan a TODO con una fecha o número de boleto. <br><br><h3>  3.2.2.  En lugar de comentar el código, refactorizarlo </h3><br><blockquote>  <i>“Un buen código es la mejor documentación.</i>  <i>Cuando esté a punto de agregar un comentario, hágase la pregunta: "¿Cómo mejorar el código para que este comentario no sea necesario?"</i>  <i>Refactorice y deje un comentario para hacerlo aún más claro. ”</i> - Steve McConnell </blockquote><br>  Las funciones deben realizar solo una tarea.  Si desea escribir un comentario porque algún fragmento no está relacionado con el resto de la función, considere extraerlo en una función separada. <br><br>  Las funciones más pequeñas no solo son más claras, sino también más fáciles de probar por separado.  Cuando aisló el código en una función separada, su nombre puede reemplazar un comentario. <br><br><a name="4"></a><h1>  4. estructura del paquete </h1><br><blockquote>  <i>"Escriba un código modesto: módulos que no muestran nada superfluo a otros módulos y que no dependen de la implementación de otros módulos"</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dave Thomas</a> </blockquote><br>  Cada paquete es esencialmente un pequeño programa Go separado.  Así como la implementación de una función o método no es importante para la persona que llama, la implementación de las funciones, métodos y tipos que conforman la API pública de su paquete tampoco es importante. <br><br>  Un buen paquete Go se esfuerza por una conectividad mínima con otros paquetes en el nivel del código fuente, de modo que a medida que el proyecto crece, los cambios en un paquete no se conectan en cascada en toda la base del código.  Tales situaciones inhiben en gran medida a los programadores que trabajan en esta base de código. <br><br>  En esta sección, hablaremos sobre el diseño del paquete, incluido su nombre y consejos para escribir métodos y funciones. <br><br><a name="4_1"></a><h2>  4.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un buen paquete comienza con un buen nombre </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un buen paquete Go comienza con un nombre de calidad. </font><font style="vertical-align: inherit;">Piense en ello como una breve presentación limitada a una sola palabra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que los nombres de variables en la sección anterior, el nombre del paquete es muy importante. </font><font style="vertical-align: inherit;">No es necesario pensar en los tipos de datos en este paquete, es mejor hacer la pregunta: "¿Qué servicio proporciona este paquete?" </font><font style="vertical-align: inherit;">Por lo general, la respuesta no es "Este paquete proporciona el tipo X", sino "Este paquete le permite conectarse a través de HTTP".</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Elija un nombre de paquete por su funcionalidad, no por su contenido.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1 </font><font style="vertical-align: inherit;">Los buenos nombres de paquetes deben ser únicos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada paquete tiene un nombre único en el proyecto. </font><font style="vertical-align: inherit;">No hay dificultad si seguiste el consejo de dar nombres para el propósito de los paquetes. </font><font style="vertical-align: inherit;">Si resulta que los dos paquetes tienen el mismo nombre, lo más probable:</font></font><br><br><ol><li>     . </li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2>  4.2.    <code>base</code> , <code>common</code>  <code>util</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una razón común para los malos nombres son los llamados </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquetes de servicio</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donde con el tiempo se acumulan varios ayudantes y códigos de servicio. Dado que es difícil encontrar un nombre único allí. Esto a menudo lleva al hecho de que el nombre del paquete se deriva de lo que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : utilidades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los nombres como </font></font><code>utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalmente se encuentran en proyectos grandes, en los que se arraiga una jerarquía profunda de paquetes, y se comparten funciones auxiliares. Si extrae alguna función en un nuevo paquete, la importación se descompone. En este caso, el nombre del paquete no refleja el propósito del paquete, sino solo el hecho de que la función de importación falló debido a una organización incorrecta del proyecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En tales situaciones, recomiendo analizar desde dónde se llaman los paquetes.</font></font><code>utils</code> <code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, si es posible, mueva las funciones correspondientes al paquete de llamada. </font><font style="vertical-align: inherit;">Incluso si esto implica la duplicación de algún código auxiliar, es mejor que introducir una dependencia de importación entre dos paquetes.</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"[Una pequeña] duplicación es mucho más barata que una abstracción incorrecta"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sandy Mets</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si las funciones de utilidad se utilizan en muchos lugares, en lugar de un paquete monolítico con funciones de utilidad, es mejor hacer varios paquetes, cada uno de los cuales se centra en un aspecto. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Use el plural para paquetes de servicios. </font><font style="vertical-align: inherit;">Por ejemplo, </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para las utilidades de procesamiento de cadenas.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los paquetes con nombres como </font></font><code>base</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o a </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menudo se encuentran cuando una cierta funcionalidad común de dos o más implementaciones o tipos comunes para un cliente y un servidor se fusiona en un paquete separado. </font><font style="vertical-align: inherit;">Creo que en tales casos es necesario reducir la cantidad de paquetes combinando el cliente, el servidor y el código común en un paquete con un nombre que corresponda a su función. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, para </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hacer los paquetes individuales </font></font><code>client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en cambio, hay archivos </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con los tipos de datos correspondientes, así como </font></font><code>transport.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para el transporte global.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es importante recordar que el nombre del identificador incluye el nombre del paquete.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una función </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de un paquete se </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convierte en un </font></font><code>http.Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace desde otro paquete.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tipo </font></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de un paquete se </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transforma cuando se importa a otros paquetes </font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La interfaz </font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del paquete está </font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">claramente asociada con errores de red.</font></font></li></ul></blockquote><br><a name="4_3"></a><h2>  4.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regresa rápidamente sin zambullirte profundamente </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde Go utiliza excepciones en el flujo de control no es necesario cortar profundamente en el código para proporcionar una estructura de nivel superior para las unidades </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En lugar de una jerarquía de niveles múltiples, el código Go baja la pantalla a medida que avanza la función. </font><font style="vertical-align: inherit;">Mi amigo Matt Ryer llama a esta práctica una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"línea de visión"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se logra utilizando </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operadores de límite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : bloques condicionales con una condición previa en la entrada a la función. </font><font style="vertical-align: inherit;">Aquí hay un ejemplo del paquete </font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al ingresar a la función </font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se verifica el estado </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y si la operación anterior no fue así </font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces se devuelve un error inmediatamente. El resto de la función funciona en función de lo que es </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mayor que </font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare con la misma función, pero sin el operador de límite:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cuerpo de una rama exitosa más probable está incrustado en la primera condición </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y la condición para una salida exitosa </font></font><code>return nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe descubrirse haciendo coincidir cuidadosamente los </font><font style="vertical-align: inherit;">corchetes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cierre</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La última línea de la función ahora devuelve un error, y debe rastrear la ejecución de la función hasta el </font><font style="vertical-align: inherit;">corchete de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apertura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondiente </font><font style="vertical-align: inherit;">para averiguar cómo llegar a este punto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta opción es más difícil de leer, lo que degrada la calidad de la programación y el soporte de código, por lo que Go prefiere usar operadores de límite y devolver errores en una etapa temprana.</font></font><br><br><a name="4_4"></a><h2>  4.4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hacer que el valor nulo sea útil </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada declaración de variable, suponiendo la ausencia de un inicializador explícito, se inicializará automáticamente con un valor correspondiente al contenido de la memoria puesta a cero, es decir, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cero</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El tipo de valor está determinado por una de las opciones: para tipos numéricos: cero, para tipos de puntero: nulo, lo mismo para sectores, mapas y canales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La capacidad de establecer siempre un valor predeterminado conocido es importante para la seguridad y corrección de su programa y puede hacer que sus programas Go sean más fáciles y compactos. Esto es lo que los programadores de Go tienen en mente cuando dicen: "Dale a las estructuras un valor cero útil". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere un tipo </font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que contiene dos campos enteros que representan el estado interno del mutex. Estos campos son automáticamente nulos en cualquier declaración.</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este hecho se tiene en cuenta en el código, por lo que el tipo es adecuado para su uso sin una inicialización explícita.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otro ejemplo de un tipo con un valor nulo útil es </font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puede declarar y comenzar a escribir en él sin una inicialización explícita.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor cero de esta estructura significa que </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambos </font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son iguales </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el puntero a la memoria con el contenido de la matriz de segmentos de respaldo, valor </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto significa que no necesita cortar explícitamente, simplemente puede declararlo.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similar a las dos líneas comentadas en la parte superior, pero no idénticas a ellas. </font><font style="vertical-align: inherit;">Hay una diferencia entre un valor de corte de cero y un valor de corte de longitud cero. </font><font style="vertical-align: inherit;">El siguiente código se imprimirá falso.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una propiedad útil, aunque inesperada, de las variables de puntero no inicializadas (punteros nulos) es la capacidad de invocar métodos en tipos que son nulos. </font><font style="vertical-align: inherit;">Esto se puede usar para proporcionar fácilmente valores predeterminados.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5. </font><font style="vertical-align: inherit;">Evitar estado de nivel de paquete</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clave para escribir programas fáciles de soportar que están débilmente conectados es que cambiar un paquete debería tener una baja probabilidad de afectar a otro paquete que no depende directamente del primero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay dos excelentes maneras de lograr una conectividad débil en Go:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilice interfaces para describir el comportamiento requerido por funciones o métodos. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar el estado global. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Go, podemos declarar variables en el alcance de una función o método, así como en el alcance de un paquete. </font><font style="vertical-align: inherit;">Cuando una variable está disponible públicamente, con un identificador con una letra mayúscula, su alcance es realmente global para todo el programa: cualquier paquete </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en cualquier momento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ve el tipo y el contenido de esta variable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El estado global mutable proporciona una estrecha relación entre las partes independientes del programa, ya que las variables globales se convierten en un parámetro invisible para cada función en el programa. </font><font style="vertical-align: inherit;">Cualquier función que se base en una variable global se puede violar cuando cambia el tipo de esta variable. </font><font style="vertical-align: inherit;">Cualquier función que dependa del estado de una variable global puede ser violada si otra parte del programa cambia esta variable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cómo reducir la conectividad que crea una variable global: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mueva las variables correspondientes como campos a las estructuras que las necesitan. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilice interfaces para reducir la conexión entre el comportamiento y la implementación de este comportamiento. </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Estructura del proyecto </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hablemos de cómo se combinan los paquetes en un proyecto. </font><font style="vertical-align: inherit;">Este suele ser un único repositorio de Git. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que el paquete, cada proyecto debe tener un objetivo claro. </font><font style="vertical-align: inherit;">Si es una biblioteca, debe hacer una cosa, por ejemplo, análisis XML o registro en diario. </font><font style="vertical-align: inherit;">No debe combinar varios objetivos en un proyecto, esto ayudará a evitar una biblioteca aterradora </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En mi experiencia, el repositorio en </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">última instancia está estrechamente relacionado con el consumidor más grande, y esto hace que sea difícil hacer correcciones a versiones anteriores (correcciones de puerto posterior) sin actualizar tanto </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el consumidor como el consumidor en la etapa de bloqueo, lo que conduce a muchos cambios no relacionados, además de que se rompen en el camino API</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tiene una aplicación (aplicación web, controlador Kubernetes, etc.), el proyecto puede tener uno o más paquetes principales. </font><font style="vertical-align: inherit;">Por ejemplo, en mi controlador Kubernetes hay un paquete </font></font><code>cmd/contour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que sirve como servidor implementado en un clúster de Kubernetes y como cliente de depuración.</font></font><br><br><a name="5_1"></a><h2>  5.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menos paquetes pero más grandes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la revisión del código, noté uno de los errores típicos de los programadores que cambiaron a Go desde otros idiomas: tienden a abusar de los paquetes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go no proporciona el elaborado sistema de visibilidad: el idioma no es suficiente modificadores de acceso como en el de Java ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implícito </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">No existe un análogo de clases amigables de C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Go, solo tenemos dos modificadores de acceso: estos son identificadores públicos y privados, que se indican mediante la primera letra del identificador (mayúsculas / minúsculas). </font><font style="vertical-align: inherit;">Si el identificador es público, su nombre comienza con una letra mayúscula, puede ser referenciado por cualquier otro paquete Go.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Podía escuchar las palabras "exportado" o "no exportado" como sinónimos de público y privado.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dadas las funciones de control de acceso limitado, ¿qué métodos se pueden usar para evitar jerarquías de paquetes demasiado complejas? </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En cada paquete, además de </font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe estar presente el código fuente.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He dicho repetidamente que es mejor preferir menos paquetes más grandes. </font><font style="vertical-align: inherit;">Su posición predeterminada debe ser no crear un nuevo paquete. </font><font style="vertical-align: inherit;">Esto hace que demasiados tipos se hagan públicos, creando un amplio y pequeño alcance de API disponible. </font><font style="vertical-align: inherit;">A continuación consideramos esta tesis con más detalle.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vino de Java? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vienes del mundo de Java o C #, recuerda la regla tácita: un paquete de Java es equivalente a un único archivo fuente </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El paquete Go es equivalente a todo el módulo Maven o ensamblado .NET.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.1 </font><font style="vertical-align: inherit;">Ordenar código por archivo usando las instrucciones de importación</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si organiza paquetes por servicio, ¿debería hacer lo mismo con los archivos del paquete? </font><font style="vertical-align: inherit;">¿Cómo saber cuándo dividir un archivo </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en varios? </font><font style="vertical-align: inherit;">¿Cómo sabe si ha ido demasiado lejos y necesita pensar en fusionar archivos? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí están las recomendaciones que uso:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comience cada paquete con un archivo </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dé a este archivo el mismo nombre que el directorio. </font><font style="vertical-align: inherit;">Por ejemplo, el paquete </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe estar en un archivo </font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un directorio </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medida que crece el paquete, puede dividir las diversas funciones en varios archivos. </font><font style="vertical-align: inherit;">Por ejemplo, el archivo </font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contendrá tipos </font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo de </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, servidor de tipo de </font><font style="vertical-align: inherit;">archivo </font><font style="vertical-align: inherit;">.</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> —    HTTP     . </li></ul><br><blockquote> <b></b> .      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( —      Go).           . </blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.2. </font><font style="vertical-align: inherit;">Prefiero pruebas internas a externas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La herramienta </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">admite el paquete </font></font><code>testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en dos lugares. </font><font style="vertical-align: inherit;">Si tiene un paquete </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puede escribir un archivo </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usar la declaración del paquete </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se compila el código </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es parte del paquete </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En el habla coloquial, tal prueba se llama interna. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La herramienta </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también admite una declaración de paquete especial que termina con </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , es decir </font></font><code>http_test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto permite que los archivos de prueba vivan en el mismo paquete con el código, pero cuando se compilan tales pruebas, no forman parte del código de su paquete, sino que viven en su propio paquete. </font><font style="vertical-align: inherit;">Esto le permite escribir pruebas como si otro paquete estuviera invocando su código. </font><font style="vertical-align: inherit;">Tales pruebas se llaman externas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recomiendo el uso de pruebas internas para pruebas unitarias unitarias. Esto le permite probar cada función o método directamente, evitando la burocracia de las pruebas externas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesario</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> colocar ejemplos de funciones de prueba ( </font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">en un archivo de prueba externo </font><font style="vertical-align: inherit;">. Esto asegura que cuando se ve en godoc, los ejemplos recibirán el prefijo de paquete apropiado y se pueden copiar fácilmente.</font></font><br><br><blockquote> <b></b> .    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3> 5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si su proyecto tiene múltiples paquetes, puede encontrar funciones exportadas que están destinadas a ser utilizadas por otros paquetes, pero no para la API pública. </font><font style="vertical-align: inherit;">En tal situación, la herramienta </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reconoce un nombre de carpeta especial </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se puede usar para colocar el código que está abierto para su proyecto, pero cerrado para otros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear dicho paquete, colóquelo en un directorio con un nombre </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o en su subdirectorio. </font><font style="vertical-align: inherit;">Cuando el equipo </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ve la importación del paquete con la ruta </font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verifica la ubicación del paquete de llamada en un directorio o subdirectorio </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, un paquete </font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede importar solo un paquete desde un árbol de directorios </font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero no puede hacerlo en absoluto </font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o en cualquier otro repositorio (consulte</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><a name="5_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2. </font><font style="vertical-align: inherit;">El paquete principal más pequeño</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una función </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y un paquete </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deben tener una funcionalidad mínima, porque </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actúa como un singleton: un programa solo puede tener una función </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, incluidas las pruebas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un singleton, existen muchas restricciones sobre los objetos llamados: se llaman solo durante </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y solo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una vez</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esto dificulta la escritura de pruebas de código </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, debe esforzarse por obtener la mayor lógica posible de la función principal e, idealmente, del paquete principal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe analizar indicadores, abrir conexiones a bases de datos, registradores, etc., y luego transferir la ejecución a un objeto de alto nivel.</font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. estructura API </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El último consejo de diseño para el proyecto lo considero el más importante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las oraciones anteriores son, en principio, no vinculantes. </font><font style="vertical-align: inherit;">Estas son solo recomendaciones basadas en la experiencia personal. </font><font style="vertical-align: inherit;">No inserto demasiado estas recomendaciones en una revisión de código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La API es otro asunto, aquí tomamos los errores más en serio, porque todo lo demás se puede arreglar sin romper la compatibilidad con versiones anteriores: en su mayor parte, estos son solo detalles de implementación. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se trata de API públicas, vale la pena considerar seriamente la estructura desde el principio, porque los cambios posteriores serán destructivos para los usuarios.</font></font><br><br><a name="6_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1. </font><font style="vertical-align: inherit;">API de diseño que son difíciles de abusar por diseño</font></font></h2><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Las API deben ser simples para un uso adecuado y difíciles para incorrectas"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Bloch</font></font></a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El consejo de Josh Bloch es quizás el más valioso en este artículo. </font><font style="vertical-align: inherit;">Si la API es difícil de usar para cosas simples, entonces cada llamada a la API es más complicada de lo necesario. </font><font style="vertical-align: inherit;">Cuando una llamada API es compleja y no obvia, es probable que se pase por alto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1.1. </font><font style="vertical-align: inherit;">Tenga cuidado con las funciones que aceptan múltiples parámetros del mismo tipo.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un buen ejemplo de una API simple a primera vista, pero difícil de usar es cuando requiere dos o más parámetros del mismo tipo. </font><font style="vertical-align: inherit;">Compare dos firmas de funciones:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál es la diferencia entre estas dos funciones? </font><font style="vertical-align: inherit;">Obviamente, uno devuelve un máximo de dos números y el otro copia el archivo. </font><font style="vertical-align: inherit;">Pero este no es el punto.</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conmutativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el orden de los parámetros no importa. </font><font style="vertical-align: inherit;">Un máximo de ocho y diez es diez, independientemente de si se comparan ocho y diez o diez y ocho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero en el caso de CopyFile, esto no es así.</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuál de estos operadores respaldará su presentación y cuál la sobrescribirá con la versión de la semana pasada? </font><font style="vertical-align: inherit;">No puede saberlo hasta que verifique la documentación. </font><font style="vertical-align: inherit;">En el curso de la revisión del código, no está claro si el orden de los argumentos es correcto o no. </font><font style="vertical-align: inherit;">Nuevamente, mira la documentación. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una posible solución es introducir un tipo auxiliar que sea responsable de la llamada correcta </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">siempre se llama correctamente - se puede argumentar por una prueba de unidad - y se puede hacer en privado, lo que reduce aún más la probabilidad de mal uso.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Una API con múltiples parámetros del mismo tipo es difícil de usar correctamente.</font></font></blockquote><br><a name="6_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2. </font><font style="vertical-align: inherit;">Diseñar una API para un caso de uso básico</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hace unos años, hice una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre el uso de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opciones funcionales</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para facilitar la API por defecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La esencia de la presentación fue que debe desarrollar una API para el caso de uso principal. </font><font style="vertical-align: inherit;">En otras palabras, la API no debería requerir que el usuario proporcione parámetros adicionales que no le interesen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.1. </font><font style="vertical-align: inherit;">No se recomienda usar nil como parámetro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencé diciendo que no debe forzar al usuario a proporcionar parámetros de API que no le interesen. </font><font style="vertical-align: inherit;">Esto significa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diseñar las API para el caso de uso principal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (opción predeterminada). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay un ejemplo del paquete net / http.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acepta dos parámetros: una dirección TCP para escuchar las conexiones entrantes y </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para procesar una solicitud HTTP entrante. </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite que el segundo parámetro sea </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Las notas de comentario que normalmente la persona que llama </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que indica un deseo de utilizar </font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como un parámetro implícito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora la persona que llama </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene dos formas de hacer lo mismo.</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambas opciones hacen lo mismo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta aplicación se </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propaga como un virus. </font><font style="vertical-align: inherit;">El paquete también </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene un ayudante </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que puede imaginar la estructura de la función </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite que la persona que llama pase </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el segundo parámetro, </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también admite este comportamiento. </font><font style="vertical-align: inherit;">De hecho, está en la </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lógica implementada "si el manejador es igual </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, use </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">La aceptación </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de un parámetro puede hacer que la persona que llama piense que se puede pasar </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ambos parámetros. </font><font style="vertical-align: inherit;">Pero tal</font></font><code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conduce a un pánico terrible. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No mezcle parámetros en la misma firma de función </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y no </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El autor </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">intentó simplificar la vida de los usuarios de API para el caso predeterminado, pero la seguridad se vio afectada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En presencia, </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no hay diferencia en el número de líneas entre el uso explícito e indirecto </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comparado con </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Valió la pena mantener una línea? </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Piense seriamente en cuánto tiempo las funciones de ayuda ahorrarán al programador. </font><font style="vertical-align: inherit;">La claridad es mejor que la brevedad.</font></font></blockquote><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Evite las API públicas con parámetros que solo las pruebas necesitan. </font><font style="vertical-align: inherit;">Evite exportar API con parámetros cuyos valores difieran solo durante las pruebas. </font><font style="vertical-align: inherit;">En cambio, exporte las funciones de contenedor que ocultan la transferencia de dichos parámetros, y en las pruebas utilice funciones auxiliares similares que pasen los valores necesarios para la prueba.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.2. </font><font style="vertical-align: inherit;">Utilice argumentos de longitud variable en lugar de [] T</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Muy a menudo, una función o método toma una porción de valores. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es solo un ejemplo inventado, pero es muy común. El problema es que estas firmas suponen que se llamarán con más de un registro. Como muestra la experiencia, a menudo se les llama con un solo argumento, que debe "empaquetarse" dentro del segmento para cumplir con los requisitos de la firma de la función. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, dado que el parámetro </font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un segmento, puede pasar un segmento vacío o cero a la función, y el compilador estará contento. Esto agrega una carga de prueba adicional ya que las pruebas deberían cubrir tales casos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para dar un ejemplo de dicha clase de API, recientemente refactoré la lógica que requería la instalación de algunos campos adicionales si al menos uno de los parámetros no era cero. La lógica se parecía a esto:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el operador se estaba </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alargando mucho, quería incorporar la lógica de validación a una función separada. </font><font style="vertical-align: inherit;">Esto es lo que se me ocurrió:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto permitió establecer claramente la condición bajo la cual se ejecutará la unidad interior: </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, hay un problema con </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alguien que accidentalmente podría llamarlo así:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ese caso, </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volveremos </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esta no es la peor opción. </font><font style="vertical-align: inherit;">Peor si se </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en ausencia de argumentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, sería mejor poder cambiar la firma de anyPositive para garantizar que se pase al menos un argumento a la persona que llama. </font><font style="vertical-align: inherit;">Esto se puede hacer combinando parámetros para argumentos normales y argumentos de longitud variable (varargs):</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede llamar con menos de un argumento.</font></font><br><br><a name="6_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3. </font><font style="vertical-align: inherit;">Deje que las funciones determinen el comportamiento deseado.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supongamos que se me encomendó la tarea de escribir una función que conserve la estructura </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el disco.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podría escribir una función </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que escriba </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un archivo </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero hay algunos problemas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La firma </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elimina la posibilidad de registrar datos a través de la red. Si tal requisito aparece en el futuro, la firma de la función tendrá que cambiarse, lo que afectará a todos los objetos que llaman. </font></font><br><br> <code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">También es desagradable probarlo, ya que funciona directamente con archivos en el disco. Por lo tanto, para verificar su funcionamiento, la prueba debe leer el contenido del archivo después de la escritura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y tengo que asegurarme de que esté </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escrito en una carpeta temporal y posteriormente eliminado. </font></font><br><br> <code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también define muchos métodos que no están relacionados con </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo, leer directorios y verificar si una ruta es un enlace simbólico. Bueno, si la firma</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">describe solo las partes relevantes </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se puede hacer</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con la ayuda de </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este, puede aplicar el principio de separación de interfaz y redefinirlo </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en una interfaz que describa las propiedades más generales del archivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de tal cambio, cualquier tipo que implemente la interfaz </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede ser reemplazado por el anterior </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto amplía simultáneamente el alcance </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y aclara al llamante qué métodos de tipo </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">están relacionados con su funcionamiento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y el autor </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ya no puede llamar a estos métodos no relacionados </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque está oculto detrás de la interfaz </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero podemos extender el principio de separación de la interfaz aún más. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar si</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sigue el principio de responsabilidad única, es poco probable que lea el archivo que acaba de escribir para verificar su contenido; otro código debería hacerlo. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, puede reducir las especificaciones de la interfaz para </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribir y cerrar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, el mecanismo de cierre de subprocesos y </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es un legado de la época en que funcionaba con el archivo. </font><font style="vertical-align: inherit;">La pregunta es, ¿bajo qué circunstancias </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se cerrará? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">causa </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin condiciones, ya sea en el caso de éxito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto presenta un problema para la persona que llama porque puede querer agregar datos a la secuencia después de escribir el documento.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mejor opción es redefinir Guardar para trabajar solo </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, salvando al operador de todas las demás funciones, excepto para escribir datos en la transmisión. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de aplicar el principio de separación de interfaz, la función al mismo tiempo se volvió más específica en términos de requisitos (solo necesita un objeto donde se pueda escribir) y más general en términos de funcionalidad, ya que ahora podemos usarla </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para guardar datos en cualquier lugar donde se implemente </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Manejo de errores </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varias presentaciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">escribí </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sobre este tema en el blog, así que no lo repetiré. </font><font style="vertical-align: inherit;">En cambio, quiero cubrir otras dos áreas relacionadas con el manejo de errores.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><a name="7_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1. </font><font style="vertical-align: inherit;">Elimine la necesidad de manejar errores eliminando los errores mismos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hice muchas sugerencias para mejorar la sintaxis de manejo de errores, pero la mejor opción es no manejarlas en absoluto. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No digo "eliminar el manejo de errores". </font><font style="vertical-align: inherit;">Sugiero cambiar el código para que no haya errores de procesamiento.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El reciente libro de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filosofía de desarrollo de software de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> John Osterhout me inspiró a hacer esta sugerencia </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Uno de los capítulos se titula "Eliminar errores de la realidad". </font><font style="vertical-align: inherit;">Intentemos aplicar este consejo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1 </font><font style="vertical-align: inherit;">Recuento de filas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Escribiremos una función para contar el número de líneas en un archivo. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medida que seguimos los consejos de las secciones anteriores, </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acepta </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; ya es tarea de la persona que llama proporcionar el </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenido de quién queremos contar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego llamamos al método en un bucle </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aumentando el contador, hasta llegar al final del archivo, luego devolvemos el número de líneas leídas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al menos queremos escribir dicho código, pero la función está cargada de manejo de errores. Por ejemplo, hay una construcción tan extraña:</font></font><br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aumentamos el número de líneas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antes de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buscar errores, esto parece extraño. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La razón por la que deberíamos escribirlo de esta manera es porque </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolverá un error si encuentra el final del archivo antes que el carácter de nueva línea. </font><font style="vertical-align: inherit;">Esto puede suceder si no hay una nueva línea al final del archivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para intentar solucionar esto, cambie la lógica del contador de filas y luego vea si necesitamos salir del bucle.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esta lógica aún no es perfecta, ¿puedes encontrar un error?</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no hemos terminado de buscar errores. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regresará </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando encuentre el final del archivo. </font><font style="vertical-align: inherit;">Esta es la situación esperada, por lo </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que debe hacer alguna forma de decir "detente, no hay nada más que leer". </font><font style="vertical-align: inherit;">Por lo tanto, antes de devolver el error al objeto que realiza la llamada </font></font><code>CountLine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, debe verificar que el error no esté relacionado </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego transmitirlo; de lo contrario, volveremos </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y diremos que todo está bien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creo que este es un buen ejemplo de la tesis de Russ Cox sobre cómo el manejo de errores puede ocultar la función. </font><font style="vertical-align: inherit;">Veamos la versión mejorada.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta versión mejorada utiliza en su </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under the hood </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero agrega un buen nivel de abstracción, lo que ayuda a eliminar el manejo de errores.</font></font><br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El método </font></font><code>sc.Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve un valor </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si el escáner encontró una cadena y no encontró un error. Por lo tanto, el cuerpo del bucle se </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llama solo si hay una línea de texto en el búfer del escáner. Esto significa que el nuevo </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maneja casos cuando no hay una nueva línea o cuando el archivo está vacío. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, dado que </font></font><code>sc.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regresa </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se detecta un error, el ciclo </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finaliza cuando llega al final del archivo o se detecta un error. El tipo </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recuerda el primer error que encontró y, utilizando el método </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos restaurar ese error tan pronto como salgamos del ciclo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, se </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encarga del procesamiento </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y lo convierte </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se </font><font style="vertical-align: inherit;">llega al </font><font style="vertical-align: inherit;">final del archivo sin errores.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si encuentra un manejo excesivo de errores, intente extraer algunas operaciones en un tipo auxiliar.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2. </font><font style="vertical-align: inherit;">Escribir respuesta</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mi segundo ejemplo está inspirado en la publicación </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Los errores son valores"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente vimos ejemplos de cómo se abre, escribe y cierra un archivo. </font><font style="vertical-align: inherit;">Hay manejo de errores, pero no es demasiado, porque las operaciones se pueden encapsular en ayudantes, como </font></font><code>ioutil.ReadFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>ioutil.WriteFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero cuando se trabaja con protocolos de red de bajo nivel, es necesario crear una respuesta directamente utilizando primitivas de E / S. </font><font style="vertical-align: inherit;">En este caso, el manejo de errores puede volverse intrusivo. </font><font style="vertical-align: inherit;">Considere un fragmento de un servidor HTTP que crea una respuesta HTTP.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, construya la barra de estado con </font></font><code>fmt.Fprintf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y verifique el error. Luego, para cada encabezado, escribimos una clave y un valor de encabezado, cada vez que verificamos un error. Finalmente, completamos la sección del encabezado con una adicional </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verificamos el error y copiamos el cuerpo de la respuesta al cliente. Finalmente, aunque no necesitamos verificar el error </font></font><code>io.Copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, debemos traducirlo de dos valores devueltos al único que retorna </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un trabajo monótono. Pero puede facilitar su tarea aplicando un pequeño tipo de envoltorio </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satisface el contrato </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por lo que puede usarse como envoltorio. </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasa registros a través de la función hasta que se detecta un error. En este caso, rechaza las entradas y devuelve el error anterior.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se aplica </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la claridad del código mejoró significativamente. </font><font style="vertical-align: inherit;">Ya no necesita verificar errores en cada operación individual. </font><font style="vertical-align: inherit;">El mensaje de error se mueve al final de la función como una comprobación de campo </font></font><code>ew.err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, evitando la molesta traducción de los valores devueltos de io.Copy.</font></font><br><br><a name="7_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2. </font><font style="vertical-align: inherit;">Manejar el error solo una vez</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, quiero señalar que los errores deben manejarse solo una vez. </font><font style="vertical-align: inherit;">Procesar significa verificar el significado del error y tomar una </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sola</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decisión.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si toma menos de una decisión, ignora el error. </font><font style="vertical-align: inherit;">Como vemos aquí, se </font></font><code>w.WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignora </font><font style="vertical-align: inherit;">el error de </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero tomar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">más de una</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> decisión en respuesta a un error también está mal. </font><font style="vertical-align: inherit;">A continuación se muestra el código que a menudo encuentro.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este ejemplo, si se produce un error durante el tiempo </font></font><code>w.Write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la línea se escribe en el registro y también se devuelve a la persona que llama, que también puede registrarlo y pasarlo al nivel superior del programa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo más probable es que la persona que llama haga lo mismo:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por lo tanto, se crea una pila de líneas repetidas en el registro. </font></font><br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero en la parte superior del programa obtienes un error original sin ningún contexto. </font></font><br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quiero analizar este tema con más detalle, porque no considero el problema de devolver simultáneamente un error y registrar mis preferencias personales. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo encuentro un problema que un programador olvida regresar de un error. Como dijimos anteriormente, el estilo de Go es usar operadores de límites, verificar los requisitos previos a medida que se ejecuta la función y regresar temprano. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este ejemplo, el autor verificó el error, lo registró, pero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">olvidó</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> regresar. Debido a esto, surge un problema sutil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El contrato de manejo de errores de Go dice que en presencia de un error, no se pueden hacer suposiciones sobre el contenido de otros valores de retorno. Dado que el cálculo de referencias JSON falló, el contenido es </font></font><code>buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desconocido: puede no contener nada, pero lo que es peor, puede contener un fragmento JSON medio escrito.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el programador olvidó regresar después de verificar y registrar el error, se transferirá el búfer dañado </font></font><code>WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es probable que la operación tenga éxito y, por lo tanto, el archivo de configuración no se escribirá correctamente. </font><font style="vertical-align: inherit;">Sin embargo, la función se completa normalmente, y la única señal de que se ha producido un problema es una línea en el registro donde falló el cálculo de referencias JSON, y no un error de registro de configuración.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.1 </font><font style="vertical-align: inherit;">Agregar contexto a los errores</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se produjo un error porque el autor intentaba agregar contexto al mensaje de error. </font><font style="vertical-align: inherit;">Trató de dejar una marca para indicar la fuente del error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veamos otra forma de hacer lo mismo </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si combina el registro de error con el retorno en una línea, es más difícil olvidar regresar y evitar la continuación accidental. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se produce un error de E / S al escribir el archivo, el método </font></font><code>Error()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">producirá algo como esto:</font></font><br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.2 </font><font style="vertical-align: inherit;">Error al envolver con github.com/pkg/errors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El patrón </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona bien para grabar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensajes de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> error, pero el </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> error se deja de lado. </font><font style="vertical-align: inherit;">Argumenté que manejar los errores como valores opacos es importante para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proyectos </font><i><font style="vertical-align: inherit;">acoplados libremente</font></i><font style="vertical-align: inherit;"> , por lo que el tipo de error de origen no debería importar si solo necesitamos trabajar con su valor:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asegúrese de que no sea cero. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualízalo en la pantalla o regístralo. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, sucede que necesita restaurar el error original. </font><font style="vertical-align: inherit;">Para anotar tales errores, puede usar algo como mi paquete </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora el mensaje se convierte en un buen error de estilo K&amp;D: </font></font><br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y su valor contiene un enlace al motivo original. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por lo tanto, puede restaurar el error original y mostrar el seguimiento de la pila: </font></font><br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El paquete le </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite agregar contexto a los valores de error en un formato conveniente tanto para una persona como para una máquina. </font><font style="vertical-align: inherit;">En una presentación reciente, les dije que en la próxima versión de Go, tal contenedor aparecerá en la biblioteca estándar.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Concurrencia </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go a menudo se elige debido a sus capacidades de concurrencia. Los desarrolladores han hecho mucho para aumentar su eficiencia (en términos de recursos de hardware) y rendimiento, pero las funciones de paralelismo de Go se pueden usar para escribir código que no sea productivo ni confiable. Al final del artículo, quiero dar un par de consejos sobre cómo evitar algunas de las dificultades de las funciones de concurrencia de Go. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El soporte de concurrencia de primer nivel de Go es proporcionado por canales, así como instrucciones </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si estudiaste la teoría de Go en libros de texto o en una universidad, es posible que hayas notado que la sección de paralelismo siempre es una de las últimas del curso. </font><font style="vertical-align: inherit;">Nuestro artículo no es diferente: decidí hablar sobre paralelismo al final, como algo adicional a las habilidades habituales que el programador Go debería aprender. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí hay una cierta dicotomía, porque la característica principal de Go es nuestro modelo de paralelismo simple y fácil. </font><font style="vertical-align: inherit;">Como producto, nuestro lenguaje se vende a expensas de casi esta función. </font><font style="vertical-align: inherit;">Por otro lado, la concurrencia en realidad no es tan fácil de usar, de lo contrario los autores no lo habrían convertido en el último capítulo de sus libros, y no habríamos mirado con pesar nuestro código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta sección se analizan algunas de las trampas del uso ingenuo de las funciones de concurrencia de Go.</font></font><br><br><a name="8_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1. </font><font style="vertical-align: inherit;">Haz algo de trabajo todo el tiempo.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Cuál es el problema con este programa? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El programa hace lo que pretendíamos: sirve un servidor web simple. </font><font style="vertical-align: inherit;">Al mismo tiempo, pasa el tiempo de la CPU en un bucle infinito, porque </font></font><code>for{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la última línea </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloquea gorutin main, sin realizar ninguna E / S, no hay que esperar para bloquear, enviar o recibir mensajes, o algún tipo de conexión con el programador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que el tiempo de ejecución de Go generalmente es atendido por un programador, este programa se ejecutará sin sentido en el procesador y puede terminar en un bloqueo activo (bloqueo en vivo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cómo arreglarlo? </font><font style="vertical-align: inherit;">Aquí hay una opción.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede parecer una tontería, pero esta es una solución común que se me ocurre en la vida real. </font><font style="vertical-align: inherit;">Este es un síntoma de un malentendido del problema subyacente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tienes un poco más de experiencia con Go, puedes escribir algo como esto.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una declaración vacía se </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloquea para siempre. </font><font style="vertical-align: inherit;">Esto es útil, porque ahora no hacemos girar todo el procesador solo por una llamada </font></font><code>runtime.GoSched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sin embargo, tratamos solo el síntoma, no la causa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiero mostrarte otra solución que, espero, ya se te haya ocurrido. </font><font style="vertical-align: inherit;">En lugar de correr </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en goroutine, dejando el problema principal de goroutine, solo corre </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la goroutine principal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si sale de la función </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el programa Go finaliza incondicionalmente, independientemente de lo que hagan otras rutinas que se ejecuten durante la ejecución del programa.</font></font></blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Así que este es mi primer consejo: si goroutine no puede avanzar hasta que reciba un resultado de otro, entonces a menudo es más fácil hacer el trabajo usted mismo, en lugar de delegarlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto a menudo elimina una gran cantidad de rastreo de estado y manipulación de canales necesarios para transferir el resultado de la rutina al iniciador del proceso.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Muchos programadores de Go abusan de las gorutinas, especialmente al principio. </font><font style="vertical-align: inherit;">Como todo lo demás en la vida, la clave del éxito es la moderación.</font></font></blockquote><br><a name="8_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2. </font><font style="vertical-align: inherit;">Deja paralelismo a la persona que llama</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Cuál es la diferencia entre las dos API? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencionamos las diferencias obvias: el primer ejemplo lee el directorio en un segmento y luego devuelve todo el segmento o error si algo salió mal. Esto ocurre sincrónicamente, la persona que llama se bloquea </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasta que se hayan leído todas las entradas del directorio. Dependiendo de qué tan grande sea el directorio, puede llevar mucho tiempo y potencialmente mucha memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere el segundo ejemplo. Es un poco más como la programación clásica de Go, aquí </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve el canal a través del cual se transmitirán las entradas del directorio. Cuando el canal está cerrado, esto es una señal de que no hay más entradas de catálogo. Como el llenado del canal ocurre después del regreso </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se puede suponer que las gorutinas comienzan a llenar el canal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En la segunda opción, no es necesario usar goroutine: puede seleccionar un canal suficiente para almacenar todas las entradas del directorio sin bloquear, completarlo, cerrarlo y luego devolver el canal a la persona que llama. </font><font style="vertical-align: inherit;">Pero esto es poco probable, ya que en este caso surgirán los mismos problemas al usar una gran cantidad de memoria para almacenar todos los resultados en el canal.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La versión del </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canal tiene dos problemas más:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de un canal cerrado como señal de que no hay más elementos para procesar, </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede informar al llamador de un conjunto incompleto de elementos debido a un error. </font><font style="vertical-align: inherit;">La persona que llama no tiene forma de transmitir la diferencia entre un directorio vacío y un error. </font><font style="vertical-align: inherit;">En ambos casos, parece que el canal se cerrará inmediatamente.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La persona que llama debe continuar leyendo desde el canal cuando está cerrado, porque esta es la única manera de entender que el canal que llena la rutina ha dejado de funcionar. </font><font style="vertical-align: inherit;">Esta es una restricción seria de uso </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la persona que llama pasa tiempo leyendo el canal, incluso si recibió todos los datos necesarios. </font><font style="vertical-align: inherit;">Esto es probablemente más eficiente en términos de uso de memoria para directorios medianos y grandes, pero el método no es más rápido que el método original basado en el segmento.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En ambos casos, la solución es usar una devolución de llamada: una función que se llama en el contexto de cada entrada de directorio a medida que se ejecuta. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como era de esperar, la función </font></font><code>filepath.WalkDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona de esa manera.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si su función inicia goroutine, debe proporcionar a la persona que llama una forma de detener explícitamente esta rutina. </font><font style="vertical-align: inherit;">A menudo es más fácil dejar el modo de ejecución asíncrono en la persona que llama.</font></font></blockquote><br><a name="8_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3. </font><font style="vertical-align: inherit;">Nunca ejecute goroutine sin saber cuándo se detendrá</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el ejemplo anterior, la gorutina se usó innecesariamente. </font><font style="vertical-align: inherit;">Pero una de las principales fortalezas de Go es su capacidad de concurrencia de primera clase. </font><font style="vertical-align: inherit;">De hecho, en muchos casos el trabajo paralelo es bastante apropiado, y luego es necesario usar gorutinas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta sencilla aplicación sirve el tráfico http en dos puertos diferentes: el puerto 8080 para el tráfico de la aplicación y el puerto 8001 para acceder al punto final </font></font><code>/debug/pprof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque el programa no es complicado, es la base de una aplicación real. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La aplicación en su forma actual tiene varios problemas que aparecerán a medida que crecen, así que veamos de inmediato algunos de ellos.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manipuladores de ruptura </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de funciones separadas, hemos separado de ellos </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">También seguimos el consejo anterior y nos aseguramos </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dejamos la tarea de asegurar el paralelismo de la persona que llama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hay algunos problemas con el rendimiento de dicho programa. </font><font style="vertical-align: inherit;">Si salimos </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y luego </font><font style="vertical-align: inherit;">salimos </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el programa termina y el administrador de procesos lo reiniciará.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Así como las funciones en Go dejan paralelismo a la persona que llama, las aplicaciones deberían dejar de monitorear su estado y reiniciar el programa que las llamó. </font><font style="vertical-align: inherit;">No responsabilice a sus aplicaciones de reiniciarse: este procedimiento se maneja mejor desde fuera de la aplicación.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comienza en una rutina diferente, y en caso de su lanzamiento, la rutina termina, mientras que el resto del programa continúa. </font><font style="vertical-align: inherit;">A sus desarrolladores no les gustará el hecho de que no puedan obtener estadísticas de la aplicación porque el controlador </font></font><code>/debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ha dejado de funcionar por mucho tiempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos asegurarnos de que la aplicación esté cerrada si </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">detiene </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cualquier</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rutina que la atienda.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>serverApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">errores de comprobación de </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y si es causa necesaria </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dado que ambos manejadores trabajan en goroutines, elaboramos la rutina principal en </font></font><code>select{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este enfoque tiene varios problemas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regresa con un error </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no habrá llamada </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el servicio HTTP en este puerto se cerrará sin detener la aplicación.</font></font><br></li><li> <code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamadas </font></font><code>os.Exit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que salen incondicionalmente del programa; </font><font style="vertical-align: inherit;">las llamadas diferidas no funcionarán, otras gorutinas no serán notificadas del cierre, el programa simplemente se detendrá. </font><font style="vertical-align: inherit;">Esto hace que sea difícil escribir pruebas para estas funciones.</font></font></li></ol><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Usar solo </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en funciones </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, queremos transmitir cualquier error que ocurra al creador de la gorutina, para que pueda descubrir por qué se detuvo y completó limpiamente el proceso.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El estado de devolución de Goroutine se puede obtener a través del canal. El tamaño del canal es igual a la cantidad de gorutinas que queremos controlar, por lo que el envío al canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se bloqueará, ya que esto bloqueará el cierre de las gorutinas y provocará una fuga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no puede cerrarse de manera segura, no podemos usar el idioma para el ciclo del canal </font></font><code>for range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hasta que todas las gorutinas hayan informado. En cambio, ejecutamos todas las goroutines en ejecución en un ciclo, que es igual a la capacidad del canal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos una manera de salir limpiamente de cada rutina y corregir todos los errores que encuentren. Solo queda enviar una señal para completar el trabajo desde la primera gorutina a todos los demás. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El llamamiento a</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre la finalización, así que envolví esta lógica en una función auxiliar. </font><font style="vertical-align: inherit;">El ayudante </font></font><code>serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acepta la dirección y </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, del mismo modo </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el canal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que usamos para ejecutar el método </font></font><code>Shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, para cada valor en el canal </font><font style="vertical-align: inherit;">, cerramos </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el canal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que hace que cada gorutina en este canal cierre por su cuenta </font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A su vez, esto lleva a un retorno de todas las goroutinas restantes </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cuando todas las gorutinas en ejecución se han detenido, </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">finaliza y el proceso se detiene limpiamente.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consejo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Escribir esa lógica por su cuenta es un trabajo repetitivo y el riesgo de errores. </font><font style="vertical-align: inherit;">Mire algo como </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este paquete</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que hará la mayor parte del trabajo por usted.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441842/">https://habr.com/ru/post/441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441826/index.html">Lo que está sucediendo en el mercado de transmisión de audio: discutiendo el desarrollo de plataformas de transmisión</a></li>
<li><a href="../441830/index.html">Guía del usuario de Kibana. Visualización. Parte 4</a></li>
<li><a href="../441832/index.html">¿Quién es el gerente del proyecto en opinión del propietario del negocio y cómo tratarlo?</a></li>
<li><a href="../441834/index.html">No llevar a trabajar. Pero, ¿y si el problema está en ti?</a></li>
<li><a href="../441836/index.html">One Cloud Story: Huawei + 3data = Cloud</a></li>
<li><a href="../441844/index.html">iRobot Scooba: experiencia y soluciones a problemas comunes de un robot limpiador de lavado</a></li>
<li><a href="../441848/index.html">Pasantías para desarrolladores en Avito: misiones de combate y trabajo con mentores experimentados</a></li>
<li><a href="../441850/index.html">Adivinación en redes neuronales: si el propio autor señaló en los comentarios en la publicación</a></li>
<li><a href="../441852/index.html">42 Silicon Valley: cómo ser seleccionado</a></li>
<li><a href="../441854/index.html">DESCANSO? Toma un tonto JSON-RPC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>