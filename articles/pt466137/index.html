<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•Ñ üöÆ üë≤ System.IO. Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho üíé üå¶Ô∏è ‚ÄºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° leitor. Muito tempo se passou desde o lan√ßamento do .NET Core 2.1. E inova√ß√µes legais como Span e Memory j√° s√£o amplamente conhecidas, voc√™ pode l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO. Pipelines - uma ferramenta pouco conhecida para os amantes de alto desempenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466137/">  Ol√° leitor.  Muito tempo se passou desde o lan√ßamento do .NET Core 2.1.  E inova√ß√µes legais como Span e Memory j√° s√£o amplamente conhecidas, voc√™ pode ler, ver e ouvir muito sobre elas.  No entanto, infelizmente, a biblioteca chamada System.IO Pipeslines n√£o recebeu a mesma aten√ß√£o.  Quase tudo o que existe neste t√≥pico √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a √∫nica publica√ß√£o</a> que foi traduzida e copiada em muitos recursos.  Deve haver mais informa√ß√µes sobre essa tecnologia para analis√°-la de diferentes √¢ngulos. <br><br><img src="https://habrastorage.org/webt/fe/ff/_q/feff_q0xj_lqisaxmeji-eomyne.jpeg"><br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Portanto, esta biblioteca tem como objetivo acelerar o processamento de dados de streaming.  Ele foi originalmente criado e usado pela equipe de desenvolvimento do Kestrel (um servidor Web de plataforma cruzada para o ASP.NET Core), mas atualmente est√° dispon√≠vel para mortais atrav√©s de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pacote nuget</a> . <br><br>  Antes de nos aprofundarmos no t√≥pico, podemos imaginar o mecanismo da biblioteca como um an√°logo aprimorado do MemoryStream.  O problema com o MemoryStream original √© um n√∫mero excessivo de c√≥pias, o que √© √≥bvio se voc√™ se lembrar de que uma matriz de bytes privada √© usada dentro do MemoryStream como um buffer.  Por exemplo, nos m√©todos de <a href="">leitura</a> e <a href="">grava√ß√£o</a> , voc√™ pode ver claramente a c√≥pia dos dados.  Assim, para o objeto que queremos gravar no fluxo, uma c√≥pia ser√° criada no buffer interno e, durante a leitura, uma c√≥pia da c√≥pia interna ser√° devolvida ao consumidor.  Parece que n√£o √© o uso mais racional da mem√≥ria. <br><br>  O System.IO.Pipelines n√£o tem como objetivo substituir todos os fluxos, √© uma ferramenta adicional no arsenal de um desenvolvedor que escreve c√≥digo de alto desempenho.  Sugiro que voc√™ se familiarize com os m√©todos e classes b√°sicos, veja os detalhes de implementa√ß√£o e analise exemplos b√°sicos. <br><br>  Vamos come√ßar com os detalhes internos e de implementa√ß√£o, ao mesmo tempo analisando fragmentos de c√≥digo simples.  Depois disso, ficar√° claro como funciona e como deve ser usado.  Ao trabalhar com System.IO.Pipelines, vale lembrar que o conceito b√°sico √© que todas as opera√ß√µes de leitura e grava√ß√£o devem ocorrer sem aloca√ß√µes adicionais.  Mas alguns m√©todos atraentes √† primeira vista contradizem essa regra.  Assim, o c√≥digo que voc√™ est√° tentando acelerar com tanta intensidade come√ßa a alocar mem√≥ria para dados novos e novos, carregando o coletor de lixo. <br><br>  Os internos da biblioteca usam as mais amplas possibilidades das vers√µes mais recentes do idioma e do tempo de execu√ß√£o - Span, Mem√≥ria, pools de objetos, ValueTask e assim por diante.  Vale a pena procurar pelo menos um √≥timo exemplo de uso desses recursos na produ√ß√£o. <br><br>  Ao mesmo tempo, alguns desenvolvedores n√£o estavam satisfeitos com a implementa√ß√£o de fluxos em C #, porque uma classe era usada para leitura e grava√ß√£o.  Mas como eles dizem, voc√™ n√£o pode jogar m√©todos fora de uma classe.  Mesmo se o fluxo n√£o suportar leitura / grava√ß√£o / busca, as propriedades CanRead, CanWrite e CanSeek ser√£o usadas.  Parece uma pequena muleta.  Mas agora as coisas se tornam diferentes. <br><br>  Para trabalhar com pipelines, s√£o usadas 2 classes: <a href="">PipeWriter</a> e <a href="">PipeReader</a> .  Essas classes cont√™m aproximadamente 50 linhas de c√≥digo e s√£o pseudo-fachadas (n√£o a mais cl√°ssica de suas encarna√ß√µes, pois ocultam uma √∫nica classe, n√£o muito) para a classe <a href="">Pipe</a> , que cont√©m toda a l√≥gica b√°sica para trabalhar com dados.  Esta classe cont√©m 5 membros p√∫blicos: 2 construtores, 2 propriedades get-only - Reader e Writer, o m√©todo Reset (), que redefine os campos internos para seu estado inicial para que a classe possa ser reutilizada.  Os demais m√©todos de trabalho s√£o internos e denominados usando pseudo-fachadas. <br><br><h2>  Vamos come√ßar com a classe de pipe </h2><br>  A inst√¢ncia da classe ocupa 320 bytes, o que √© bastante (quase um ter√ßo de um kilobyte, dois desses objetos n√£o cabiam na mem√≥ria do Manchester Mark I).  Portanto, alocar uma grande quantidade de inst√¢ncias √© uma m√° ideia.  Al√©m disso, o objeto √© destinado ao uso a longo prazo.  O uso de pools tamb√©m cria um argumento para esta declara√ß√£o.  Os objetos usados ‚Äã‚Äãno pool permanecer√£o para sempre (para a implementa√ß√£o do pool padr√£o). <br>  Observe que a classe est√° marcada como lacrada e √© segura para threads - muitas se√ß√µes do c√≥digo s√£o cr√≠ticas e est√£o envolvidas em bloqueios. <br><br>  Para come√ßar a usar essa classe, voc√™ deve criar uma inst√¢ncia da classe Pipe e obter os objetos PipeReader e PipeWriter usando as propriedades mencionadas. <br><br><div class="spoiler">  <b class="spoiler_title">Inicializa√ß√£o simples</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); PipeWriter pipeWriter = pipe.Writer; PipeReader pipeReader = pipe.Reader;</code> </pre> <br></div></div><br>  Considere os m√©todos para trabalhar com tubos: <br>  Gravando com PipeWriter - WriteAsync, GetMemory / GetSpan, Advance, FlushAsync, Complete, CancelPendingFlush, OnReaderCompleted. <br><br>  Leitura com PipeReader - AdvanceTo, ReadAsync, TryRead, Complete, CancelPendingRead, OnWriterCompleted. <br><br>  Conforme declarado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post mencionado</a> , a classe usa uma lista de buffers vinculada individualmente.  Mas, obviamente, eles n√£o s√£o transferidos entre o PipeReader e o PipeWriter - toda a l√≥gica est√° em uma classe.  Esta lista √© usada para leitura e escrita.  Al√©m disso, os dados retornados s√£o armazenados nesta lista (para que nenhuma c√≥pia seja executada). <br><br>  Al√©m disso, existem objetos indicando o in√≠cio dos dados a serem lidos (ReadHead e √≠ndice), o final dos dados a serem lidos (ReadTail e √≠ndice) e o in√≠cio do espa√ßo a ser gravado (WriteHead e o n√∫mero de bytes armazenados em buffer gravados).  Aqui, ReadHead, ReadTail e WriteHead s√£o membros (segmentos) espec√≠ficos da lista interna de segmentos e o √≠ndice indica uma posi√ß√£o espec√≠fica dentro do segmento.  Assim, a grava√ß√£o pode come√ßar no meio de um segmento, capturar um pr√≥ximo segmento inteiro e terminar no meio do terceiro.  Esses ponteiros s√£o movidos em v√°rios m√©todos. <br><br><h2>  Introdu√ß√£o aos m√©todos PipeWriter </h2><br><h3>  # 1 <a href="">ValueTask &lt;FlushResult&gt; WriteAsync (fonte ReadOnlyMemory &lt;byte&gt;, CancellationToken cancellationToken)</a> </h3><br>  Isso √© mencionado atraente √† primeira vista.  Possui uma assinatura muito adequada e moderna - aceita ReadOnlyMemory, ass√≠ncrono.  E muitos podem ficar tentados, principalmente lembrando que Span e Memory s√£o t√£o r√°pidos e legais.  Mas n√£o se iluda.  Tudo o que esse m√©todo faz √© copiar o ReadOnlyMemory passado para ele na lista interna.  E por "c√≥pia" entende-se uma chamada para o m√©todo CopyTo (), e n√£o copiar apenas o pr√≥prio objeto.  Todos os dados que queremos gravar ser√£o copiados, carregando assim a mem√≥ria.  Este m√©todo deve ser mencionado apenas para garantir que √© melhor n√£o us√°-lo.  Bem, e talvez para algumas situa√ß√µes raras, esse comportamento √© apropriado. <br>  O corpo do m√©todo √© uma se√ß√£o cr√≠tica, o acesso a ele √© sincronizado atrav√©s de um monitor. <br><br>  Em seguida, pode surgir a pergunta: como escrever algo, se n√£o atrav√©s do m√©todo mais √≥bvio e √∫nico adequado <br><br><h3>  # 2 <a href="">Mem√≥ria &lt;byte&gt; GetMemory (int sizeHint)</a> </h3><br>  O m√©todo usa um par√¢metro de um tipo inteiro.  Nele, devemos indicar quantos bytes queremos gravar no pipeline (qual o tamanho do buffer que queremos).  Este m√©todo verifica se h√° espa√ßo suficiente para grava√ß√£o no fragmento de mem√≥ria atual armazenado em _writingHeadMemory.  Se suficiente, _writingHeadMemory √© retornado como a mem√≥ria.  Caso contr√°rio, para os dados gravados no buffer, mas para os quais o m√©todo FlushAsync n√£o foi chamado, ele ser√° chamado e outro BufferSegment ser√° alocado, que ser√° conectado ao anterior (aqui est√° nossa lista interna).  Se _writingHeadMemory for nulo, ele ser√° inicializado com um novo BufferSegment.  E a aloca√ß√£o do buffer √© uma se√ß√£o cr√≠tica e √© feita sob o bloqueio. <br><br>  Eu sugiro olhar para um exemplo.  √Ä primeira vista, pode parecer que o compilador (ou tempo de execu√ß√£o) tenha enganado o dem√¥nio. <br><br><div class="spoiler">  <b class="spoiler_title">Devilry</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeNoOptions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Memory&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; memoryOne = pipeNoOptions.Writer.GetMemory(<span class="hljs-number"><span class="hljs-number">2</span></span>); Console.WriteLine(memoryOne.Length); <span class="hljs-comment"><span class="hljs-comment">//2048 or 4096 var pipeWithOptions = new Pipe(new PipeOptions(minimumSegmentSize: 5)); Memory&lt;byte&gt; memoryTwo = pipeWithOptions.Writer.GetMemory(2); Console.WriteLine(memoryTwo.Length); //16</span></span></code> </pre><br></div></div><br>  Mas tudo neste exemplo √© compreens√≠vel e simples. <br>  Ao criar uma inst√¢ncia de Pipe, podemos passar o objeto <a href="">PipeOptions</a> para ele no construtor com op√ß√µes para cria√ß√£o. <br><br>  PipeOptions possui um campo de tamanho de segmento m√≠nimo padr√£o.  H√° pouco tempo, era 2048, mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse commit</a> atualizou esse valor para 4096. No momento da reda√ß√£o deste artigo, a vers√£o 4096 estava no nuget-package de pr√©-lan√ßamento, a √∫ltima vers√£o possu√≠a o valor 2048. Isso explica o comportamento do primeiro exemplo.  Se voc√™ for cr√≠tico ao usar um tamanho menor para o buffer padr√£o, poder√° especific√°-lo em uma inst√¢ncia do tipo PipeOptions. <br><br>  Mas no segundo exemplo, onde o tamanho m√≠nimo √© especificado, o comprimento n√£o corresponde a ele.  E isso est√° acontecendo porque a cria√ß√£o de um novo BufferSegment ocorre usando pools.  Uma das op√ß√µes no PipeOptions √© o pool de mem√≥ria.  Depois disso, o pool especificado ser√° usado para criar um novo segmento.  Se voc√™ n√£o especificou o conjunto de mem√≥rias, ser√° utilizado o ArrayPool padr√£o, que, como voc√™ sabe, possui v√°rios buckets para tamanhos diferentes de arrays (cada um deles √© 2 vezes maior que o anterior) e quando √© solicitado para um determinado tamanho, ele procura um balde com matrizes de tamanho adequado (ou seja, o maior ou maior o mais pr√≥ximo).  Consequentemente, o novo buffer quase certamente ser√° maior do que o solicitado.  O tamanho m√≠nimo da matriz no ArrayPool padr√£o (System.Buffers.TlsOverPerCoreLockedStacksArrayPool) √© 16. Mas n√£o se preocupe, esse √© um conjunto de matrizes.  Dessa forma, na grande maioria dos casos, a matriz n√£o exerce press√£o sobre o coletor de lixo e ser√° reutilizada posteriormente. <br><br><h3>  # 2.5 <a href="">Span &lt;byte&gt; GetSpan (int sizeHint)</a> </h3><br>  Funciona da mesma forma, fornecendo Span from Memory. <br><br>  Portanto, GetMemory () ou GetSpan () s√£o os principais m√©todos de grava√ß√£o.  Eles nos d√£o um objeto para o qual podemos escrever.  Para fazer isso, n√£o precisamos alocar mem√≥ria para novas matrizes de valores, podemos escrever diretamente no canal.  Qual usar depender√° principalmente da API que voc√™ est√° usando e do m√©todo de assincronia.  No entanto, tendo em conta o que precede, surge uma quest√£o.  Como o leitor saber√° quanto escrevemos?  Se sempre usamos uma implementa√ß√£o espec√≠fica do pool, que fornece uma matriz exatamente do mesmo tamanho que o solicitado, o leitor pode ler o buffer inteiro de uma s√≥ vez.  No entanto, como j√° dissemos, temos um buffer com alta probabilidade de tamanho maior.  Isso leva ao seguinte m√©todo necess√°rio para a opera√ß√£o. <br><br><h3>  # 3 <a href="">void Advance (int bytes)</a> </h3><br>  Um m√©todo terrivelmente simples.  Leva o n√∫mero de bytes escritos como argumento.  Eles incrementam os contadores internos - _unflushedBytes e _writingHeadBytesBuffered, cujos nomes falam por si.  Ele tamb√©m trunca (fatias) _writingHeadMemory exatamente o n√∫mero de bytes gravados (usando o m√©todo Slice).  Portanto, depois de chamar esse m√©todo, voc√™ precisar√° solicitar um novo bloco de mem√≥ria na forma de Mem√≥ria ou Extens√£o, n√£o poder√° gravar no anterior.  E todo o corpo do m√©todo √© uma se√ß√£o cr√≠tica e funciona sob um bloqueio. <br><br>  Parece que depois disso o leitor pode receber dados.  Mas √© necess√°rio mais um passo. <br><br><h3>  # 4 <a href="">ValueTask &lt;FlushResult&gt; FlushAsync (CancellationToken cancellationToken)</a> </h3><br>  O m√©todo √© chamado depois que escrevemos os dados necess√°rios na Mem√≥ria recebida (GetMemory) e indica quanto escrevemos l√° (Avan√ßado).  O m√©todo retorna ValueTask, no entanto, n√£o √© ass√≠ncrono (diferente do StreamPipeWriter descendente).  ValueTask √© um tipo especial (estrutura somente leitura) usado no caso em que a maioria das chamadas n√£o ser√° ass√≠ncrona, ou seja, todos os dados necess√°rios estar√£o dispon√≠veis no momento da chamada e o m√©todo terminar√° de forma s√≠ncrona.  Dentro de si, ele cont√©m dados ou Tarefas (caso n√£o funcione de forma s√≠ncrona).  Depende da propriedade _writerAwaitable.IsCompleted.  Se procurarmos o que muda o estado deste _writerAwaitable, veremos que isso acontece se a quantidade de dados n√£o consumidos (isso n√£o √© exatamente o mesmo que os dados n√£o examinados ser√£o explicados posteriormente) exceder um determinado limite (_pauseWriterThreshold).  O valor padr√£o √© 16 tamanhos de segmento.  Se desejado, o valor pode ser alterado em PipeOptions.  Al√©m disso, esse m√©todo inicia a continua√ß√£o do m√©todo ReadAsync, se um foi bloqueado. <br><br>  Retorna um FlushResult contendo 2 propriedades - IsCanceled e IsCompleted.  IsCanceled indica se o Flush foi cancelado (chamada CancelPendingFlush ()).  IsCompleted indica se o PipeReader foi conclu√≠do (chamando os m√©todos Complete () ou CompleteAsync ()). <br>  A parte principal do m√©todo √© realizada sob o bloqueio. <br><br>  Outros m√©todos do PipeWriter n√£o s√£o interessantes do ponto de vista da implementa√ß√£o e s√£o usados ‚Äã‚Äãcom muito menos frequ√™ncia; portanto, apenas uma breve descri√ß√£o ser√° fornecida. <br><br><h3>  # 5 void Complete (exce√ß√£o de exce√ß√£o = null) ou ValueTask CompleteAsync (exce√ß√£o de exce√ß√£o = null) </h3><br>  Marca o tubo fechado para escrever.  Uma exce√ß√£o ser√° lan√ßada ao tentar usar os m√©todos de grava√ß√£o ap√≥s a conclus√£o.  Se o PipeReader j√° tiver sido conclu√≠do, toda a inst√¢ncia do Pipe tamb√©m ser√° conclu√≠da.  A maior parte do trabalho √© feita sob o bloqueio. <br><br><h3>  # 6 void CancelPendingFlush () </h3><br>  Como o nome indica, ele cancela a opera√ß√£o atual FlushAsync ().  H√° uma fechadura. <br><br><h3>  # 7 void OnReaderCompleted (a√ß√£o &lt;exce√ß√£o, objeto&gt; retorno de chamada, estado do objeto) </h3><br>  Executa o delegado passado quando o leitor √© conclu√≠do.  H√° tamb√©m uma fechadura. <br>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> , est√° atualmente escrito que esse m√©todo n√£o pode ser chamado em algumas implementa√ß√µes do PipeWriter e ser√° removido no futuro.  Portanto, voc√™ n√£o deve vincular a l√≥gica a esses m√©todos. <br><br><h2>  Est√° na hora do PipeReader </h2><br><h3>  # 1 <a href="">ValueTask &lt;ReadResult&gt; ReadAsync (token CancellationToken)</a> </h3><br>  Aqui, como em FlushAsync (), ValueTask √© retornado, o que sugere que o m√©todo √© principalmente s√≠ncrono, mas nem sempre.  Depende do estado de _readerAwaitable.  Assim como no FlushAsync, voc√™ precisa descobrir quando _readerAwaitable est√° definido como incompleto.  Isso acontece quando o PipeReader l√™ tudo da lista interna (ou cont√©m dados que foram marcados como examinados e voc√™ precisa de mais dados para continuar).  O que, de fato, √© √≥bvio.  Assim, podemos concluir que √© desej√°vel ajustar o Pipe ao seu trabalho, definir todas as suas op√ß√µes cuidadosamente, com base em estat√≠sticas empiricamente identificadas.  A configura√ß√£o adequada reduzir√° a chance de uma ramifica√ß√£o de execu√ß√£o ass√≠ncrona e permitir√° um processamento mais eficiente dos dados.  Quase todo o c√≥digo em todo o m√©todo √© cercado por um bloqueio. <br><br>  Retorna alguns <a href="">ReadResult</a> misteriosos.  De fato, √© apenas um buffer + sinalizadores mostrando o status da opera√ß√£o (IsCanceled - se o ReadAsync foi cancelado e IsCompleted indicando se o PipeWriter foi fechado).  IsCompleted √© um valor que indica se os m√©todos PipeWriter Complete () ou CompleteAsync () foram chamados.  Se esses m√©todos foram chamados com uma exce√ß√£o passada, ela ser√° lan√ßada ao tentar ler. <br><br>  E, novamente, o buffer tem um tipo misterioso - <a href="">ReadOnlySequence</a> .  Este, por sua vez, √© o objeto do conte√∫do dos segmentos <a href="">(ReadOnlySequenceSegment)</a> do in√≠cio e dos √≠ndices end + start e end dentro dos segmentos correspondentes.  O que na verdade se parece com a estrutura da pr√≥pria classe Pipe.  A prop√≥sito, BufferSegment √© herdado de ReadOnlySequenceSegment, o que sugere que o BufferSegment √© usado nessa sequ√™ncia.  Gra√ßas a isso, voc√™ pode se livrar de aloca√ß√µes de mem√≥ria desnecess√°rias para transfer√™ncia de dados do gravador para o leitor. <br>  O ReadOnlySpan pode ser obtido no buffer para processamento adicional.  Para concluir a imagem, voc√™ pode verificar se o buffer cont√©m um √∫nico ReadOnlySpan.  Se ele contiver, n√£o precisamos iterar a cole√ß√£o de um elemento e podemos obt√™-la usando a propriedade First.  Caso contr√°rio, √© necess√°rio passar por todos os segmentos no buffer e processar ReadOnlySpan de cada um. <br><br>  T√≥pico de discuss√£o - na classe ReadOnlySequence, os tipos de refer√™ncia anul√°veis ‚Äã‚Äãs√£o usados ‚Äã‚Äãativamente e existe o goto (n√£o para aninhamento de loop profundo e n√£o no c√≥digo gerado) - em particular <a href="">aqui</a> . <br><br>  Ap√≥s o processamento, voc√™ precisa sinalizar para a inst√¢ncia do Pipe que lemos os dados. <br><br><h3>  # 2 <a href="">bool TryRead (resultado ReadResult)</a> </h3><br>  Vers√£o s√≠ncrona.  Permite obter o resultado, se existir.  Caso contr√°rio, ao contr√°rio do ReadAsync, ele n√£o bloqueia e retorna false.  Al√©m disso, o c√≥digo deste m√©todo est√° na fechadura. <br><br><h3>  # 3 <a href="">void AdvanceTo (SequencePosition consumida, SequencePosition examinada)</a> </h3><br>  Nesse m√©todo, voc√™ pode especificar quantos bytes examinamos e consumimos.  Os dados que foram examinados, mas n√£o consumidos, ser√£o retornados na pr√≥xima vez que forem lidos.  Esse recurso pode parecer estranho √† primeira vista, mas ao processar um fluxo de bytes, raramente √© necess√°rio processar cada byte individualmente.  Normalmente, os dados s√£o trocados usando mensagens.  Pode surgir uma situa√ß√£o em que o leitor, ao ler, recebeu uma mensagem inteira e parte da segunda.  O todo deve ser processado e parte do segundo deve ser deixada para o futuro, para que ele venha junto com a parte restante.  O m√©todo AdvanceTo usa uma SequencePosition, que na verdade √© um segmento + √≠ndice.  Ao processar tudo o que o ReadAsync leu, voc√™ pode especificar buffer.End.  Caso contr√°rio, voc√™ precisar√° criar explicitamente uma posi√ß√£o, indicando o segmento e o √≠ndice em que o processamento foi interrompido.  A fechadura est√° embaixo do cap√¥. <br>  Al√©m disso, se a quantidade de informa√ß√µes n√£o consumidas for menor que o limite especificado (_resumeWriterThreshold), ele iniciar√° a continua√ß√£o do PipeWriter se tiver sido bloqueado.  Por padr√£o, esse limite √© de 8 volumes de segmento (metade do limite de bloqueio). <br><br><h3>  # 4 vazio (exce√ß√£o exce√ß√£o = nulo) </h3><br>  Conclui o PipeReader.  Se o PipeWriter for conclu√≠do nesse momento, a inst√¢ncia inteira do Pipe ser√° conclu√≠da.  Trave para dentro. <br><br><h3>  # 5 void CancelPendingRead () </h3><br>  Permite cancelar a leitura que est√° atualmente no estado pendente.  Bloquear <br><br><h3>  # 6 void OnWriterCompleted (a√ß√£o &lt;exce√ß√£o, objeto&gt; retorno de chamada, estado do objeto) </h3><br>  Permite especificar o delegado a ser executado ap√≥s a conclus√£o do PipeWriter. <br>  Como o m√©todo semelhante do PipeWriter, na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> h√° a mesma tag que ser√° removida.  A fechadura est√° embaixo do cap√¥. <br><br><h2>  Exemplo </h2><br>  A lista abaixo mostra um exemplo de trabalho com tubos. <br>  Desde a introdu√ß√£o do .NET Core Span e Memory, muitas classes para trabalhar com dados foram complementadas por sobrecargas usando esses tipos.  Portanto, o esquema geral de intera√ß√£o ser√° aproximadamente o mesmo.  No meu exemplo, usei pipelines para trabalhar com pipes (gosto de palavras semelhantes) - objetos do SO para comunica√ß√£o entre processos.  A API de pipes acaba de ser expandida de acordo para ler dados no Span e na Memory.  A vers√£o ass√≠ncrona usa Mem√≥ria, j√° que o m√©todo ass√≠ncrono ser√° convertido em um m√©todo de modelo usando uma m√°quina de estado finito gerada automaticamente, na qual todas as vari√°veis ‚Äã‚Äãlocais e par√¢metros de m√©todo s√£o armazenados e, como Span √© ref read-only struct, ele n√£o pode ser colocado em a pilha, respectivamente, usando Span em um m√©todo ass√≠ncrono √© imposs√≠vel.  Mas h√° tamb√©m uma vers√£o s√≠ncrona do m√©todo que permite usar o Span.  No meu exemplo, eu tentei os dois e verificou-se que a vers√£o s√≠ncrona nessa situa√ß√£o se mostra melhor.  Ao us√°-lo, ocorre menos coleta de lixo e o processamento de dados √© mais r√°pido.  Mas isso ocorreu apenas porque havia muitos dados no canal (os dados estavam sempre dispon√≠veis).  Na situa√ß√£o em que √© prov√°vel que n√£o haja dados no momento da inscri√ß√£o para o pr√≥ximo lote, voc√™ deve usar a vers√£o ass√≠ncrona para n√£o sobrecarregar o processador. <br>  O exemplo tem coment√°rios que explicam alguns pontos.  Chamo a aten√ß√£o para o fato de que, apesar de os fragmentos do programa respons√°vel pela leitura do pipe e do processamento serem separados, ao gravar em um arquivo, os dados s√£o lidos exatamente no local em que foram gravados ao ler no cachimbo. <br><br><div class="spoiler">  <b class="spoiler_title">Anos de evolu√ß√£o em prol de um recurso poderoso - principal ass√≠ncrono</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PipeDataWriter(pipe.Writer, <span class="hljs-string"><span class="hljs-string">"testpipe"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataProcessor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataProcessor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleBytesProcessor(), pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAll(dataWriter.ReadFromPipeAsync(cts.Token), dataProcessor.StartProcessingDataAsync(cts.Token)); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pipepatawriter</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PipeDataWriter</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NamedPipeClientStream _namedPipe; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeWriter _pipeWriter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Servername = <span class="hljs-string"><span class="hljs-string">"."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipeDataWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PipeWriter pipeWriter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pipeName</span></span></span><span class="hljs-function">)</span></span> { _pipeWriter = pipeWriter ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeWriter)); _namedPipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NamedPipeClientStream(Servername, pipeName, PipeDirection.In); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _namedPipe.ConnectAsync(token); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ when working with the asynchronous method, use Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> //Memory</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> buffer = _pipeWriter.GetMemory(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ asynchronous reading from a named pipe in Memory </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">/ there can be any operation to obtain data - from reading from a file to random generation. //int readBytes = await _namedPipe.ReadAsync(buffer, token); // synchronous reading from the named pipe to the requested from PipeWriter Span // there can be any operation to obtain data - from reading from a file to random generation. int readBytes = _namedPipe.Read(_pipeWriter.GetSpan()); // if there was nothing in the channel, release the thread for half a second and try again // in other cases we can break the loop, it's just example if (readBytes == 0) { await Task.Delay(500, token); continue; } // specify the amount of bytes read from the pipe _pipeWriter.Advance(readBytes); // flush data to make them available PipeReader FlushResult result = await _pipeWriter.FlushAsync(token); // if PipeReader has been completed, it no longer needs to write data // PS this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeWriter to complete the entire instance of pipe _pipeWriter.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Processador de dados</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DataProcessor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IBytesProcessor _bytesProcessor; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PipeReader _pipeReader; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DataProcessor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IBytesProcessor bytesProcessor, PipeReader pipeReader</span></span></span><span class="hljs-function">)</span></span> { _bytesProcessor = bytesProcessor ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(bytesProcessor)); _pipeReader = pipeReader ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(pipeReader)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartProcessingDataAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CancellationToken token</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { token.ThrowIfCancellationRequested(); <span class="hljs-comment"><span class="hljs-comment">// reading data from a pipe instance ReadResult result = await _pipeReader.ReadAsync(token); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; // We perform calculations with the data obtained. await _bytesProcessor.ProcessBytesAsync(buffer, token); // indicate to which position the data was processed. In this case, everything is written to the file. // in situations where not all data has been processed, you need to create a position manually using the buffer and index // in this situation, IBytesProcessor.ProcessBytesAsync can be supplemented by returning this position _pipeReader.AdvanceTo(buffer.End); // if PipeWriter has been completed, reading is no longer necessary // this behavior was chosen by me as an example, it depends on business logic if (result.IsCompleted) { break; } } // complete _pipeReader to complete the entire instance of pipe _pipeReader.Complete(); } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bytesprocessor</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-function"><span class="hljs-function">Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessBytesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; bytesSequence, CancellationToken token</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleBytesProcessor</span></span> : <span class="hljs-title"><span class="hljs-title">IBytesProcessor</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Let's imagine that in this class there is a normal constructor and IDisposable readonly FileStream _fileStream = new FileStream("buffer", FileMode.Create); public Task ProcessBytesAsync(ReadOnlySequence&lt;byte&gt; bytesSequence, CancellationToken token) { if (bytesSequence.IsSingleSegment) { ProcessSingle(bytesSequence.First.Span); } else { foreach (var segment in bytesSequence) { ProcessSingle(segment.Span); } } return Task.CompletedTask; } private void ProcessSingle(ReadOnlySpan&lt;byte&gt; span) { _fileStream.Write(span); } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466137/">https://habr.com/ru/post/pt466137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466121/index.html">Gera√ß√£o de som em microcontroladores AVR usando o m√©todo de tabela de ondas com suporte a polifonia</a></li>
<li><a href="../pt466123/index.html">Crescimento. Peso. Tr√™s vizinhos</a></li>
<li><a href="../pt466127/index.html">Kola NPP ou em p√© no reator</a></li>
<li><a href="../pt466129/index.html">Efici√™ncia do transporte em gasolina, baterias e hidrog√™nio</a></li>
<li><a href="../pt466135/index.html">Megapack: como os desenvolvedores do Factorio conseguiram resolver o problema com o multiplayer de 200 jogadores</a></li>
<li><a href="../pt466139/index.html">Tecnologia aplicada nas ru√≠nas da febre do blockchain ou nos benef√≠cios pr√°ticos da aloca√ß√£o de recursos</a></li>
<li><a href="../pt466143/index.html">Como criamos c√≥digo de papel√£o ou a vers√£o Scratch do jogo de tabuleiro Golem Battle</a></li>
<li><a href="../pt466147/index.html">Gerenciador de exibi√ß√£o de dados reativa. 1. Introdu√ß√£o</a></li>
<li><a href="../pt466149/index.html">Criando um s√≠mbolo de conector com texto "din√¢mico" no OrCAD</a></li>
<li><a href="../pt466151/index.html">Investiga√ß√£o: programas estranhos no Registro de software dom√©stico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>