<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òéÔ∏è üì¥ üèÆ Conteneurs pour adultes (partie 01): un guide pratique de la terminologie üëÉüèª ‚úä üòô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous vous demandez peut-√™tre pourquoi traiter avec la terminologie si le concept de conteneurs semble assez simple et direct? Cependant, bien souvent,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conteneurs pour adultes (partie 01): un guide pratique de la terminologie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  Vous vous demandez peut-√™tre pourquoi traiter avec la terminologie si le concept de conteneurs semble assez simple et direct?  Cependant, bien souvent, l'utilisation incorrecte des termes cr√©e des obstacles au d√©veloppement de conteneurs.  Par exemple, les gens pensent souvent que les termes ¬´conteneurs¬ª et ¬´images¬ª sont utilis√©s de mani√®re interchangeable, bien qu'il existe en fait d'importantes diff√©rences conceptuelles entre eux.  Autre exemple: dans le monde des conteneurs, un ¬´r√©f√©rentiel¬ª ne signifie pas ce que vous pensez.  De plus, la technologie des conteneurs est bien plus qu'un simple docker. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Ainsi, sans conna√Ætre la terminologie, il sera difficile de comprendre en quoi docker diff√®re de CRI-O, rkt ou lxc / lxd;  ou √©valuer le r√¥le de l'Open Container Initiative dans la normalisation des technologies de conteneurs. <br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  Commencer avec les conteneurs Linux est tr√®s simple, mais il s'av√®re rapidement que cette simplicit√© est trompeuse.  Cela se produit g√©n√©ralement comme ceci: apr√®s avoir pass√© quelques minutes √† installer un docker ou un autre moteur de conteneur, vous entrez d√©j√† vos premi√®res commandes.  Juste quelques minutes - et vous avez d√©j√† cr√©√© votre premi√®re image du conteneur et l'avez plac√©e dans le domaine public.  Ensuite, vous passez habituellement √† l'architecture de l'environnement de production, puis soudain vous vous rendez compte que pour cela, vous devez d'abord faire face √† la masse des termes et des technologies qui sont derri√®re tout cela.  Pire encore, bon nombre des termes √©num√©r√©s ci-dessous sont utilis√©s de mani√®re interchangeable, ce qui cr√©e beaucoup de confusion pour les d√©butants. <br><br><ul><li>  Conteneur </li><li>  Image </li><li>  Image du conteneur </li><li>  Couche d'image </li><li>  Registre </li><li>  D√©p√¥t </li><li>  Tag </li><li>  Image de base </li><li>  Image de la plateforme </li><li>  Couche </li></ul><br>  Apr√®s avoir ma√Ætris√© la terminologie pr√©sent√©e dans ce document, vous comprendrez mieux la base technologique des conteneurs.  De plus, cela vous aidera, vous et vos coll√®gues, √† parler le m√™me langage, ainsi qu'√† concevoir consciemment et d√©lib√©r√©ment l'architecture des environnements de conteneurs en fonction des sp√©cificit√©s des t√¢ches √† r√©soudre.  √Ä son tour, du point de vue de la communaut√© informatique et de l'industrie dans son ensemble, une augmentation g√©n√©rale de la compr√©hension des technologies de conteneurs contribue √† l'√©mergence de nouvelles architectures et solutions.  Notez que cet article est destin√© √† un lecteur qui a d√©j√† une id√©e de la fa√ßon d'ex√©cuter des conteneurs. <br><br><h3>  Conteneurs: notions de base </h3><br>  Avant de passer √† la terminologie des conteneurs, nous d√©terminerons ce qu'est en fait le conteneur lui-m√™me.  Le terme ¬´conteneur¬ª signifie deux choses √† la fois.  Comme un programme Linux classique, un conteneur peut √™tre dans l'un des deux √©tats: fonctionnel et non fonctionnel.  √Ä l'√©tat inactif, le conteneur est un fichier ou un ensemble de fichiers stock√©s sur le disque.  C'est √† cet √©tat que se r√©f√®rent les termes Container Image et Container Repository.  Lorsque vous entrez la commande de lancement de conteneur, le moteur de conteneur d√©compresse les fichiers et les m√©tadonn√©es n√©cessaires et les transf√®re au noyau Linux.  Le d√©marrage d'un conteneur est tr√®s similaire au d√©marrage d'un processus Linux normal et n√©cessite un appel d'API au noyau Linux.  Cet appel d'API lance g√©n√©ralement une isolation suppl√©mentaire et monte une copie des fichiers qui se trouvent dans l'image du conteneur.  Une fois le conteneur lanc√©, il ne s'agit que d'un processus Linux.  La proc√©dure de lancement des conteneurs, ainsi que le format des images des conteneurs stock√©s sur disque, sont d√©finis et r√©glement√©s par des normes. <br><br>  Il existe plusieurs formats pour les images de conteneurs ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LXD</a> ), mais l'industrie √©volue progressivement vers une seule norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Open Container Initiative</a> , parfois appel√©e Open Containers ou simplement OCI.  Cette norme d√©finit la <a href="">sp√©cification du format d'image de conteneur</a> , qui d√©finit le format de disque pour le stockage des images de conteneur, ainsi que les m√©tadonn√©es, qui, √† leur tour, d√©finissent des √©l√©ments tels que l'architecture mat√©rielle et le syst√®me d'exploitation (Linux, Windows, etc.).  Un format d'image standard unique est la cl√© pour cr√©er un √©cosyst√®me logiciel qui permet aux d√©veloppeurs, aux projets Open Source et aux √©diteurs de logiciels de cr√©er des images compatibles et divers outils, tels que la signature √©lectronique, la num√©risation, l'assemblage, le lancement, le d√©placement et la gestion des images de conteneurs. <br><br>  En outre, il existe plusieurs moteurs de conteneurs, tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LXC</a> .  Le moteur de conteneur prend une image du conteneur et le transforme en conteneur (c'est-√†-dire un processus en cours d'ex√©cution).  Le processus de conversion est √©galement d√©fini par la norme OCI, qui comprend une sp√©cification d'ex√©cution de conteneur et une impl√©mentation de r√©f√©rence d'ex√©cution appel√©e RunC, qui est un mod√®le open source r√©glement√© par la communaut√© de d√©veloppement appropri√©e.  De nombreux moteurs de conteneur utilisent ce mod√®le pour interagir avec le noyau h√¥te lors de la cr√©ation de conteneurs. <br><br>  Les outils qui prennent en charge les sp√©cifications du <a href="">format d'image de conteneur</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'environnement d'ex√©cution de conteneur de</a> la norme OCI offrent une portabilit√© au sein de l'√©cosyst√®me de diverses plates-formes de conteneurs, moteurs de conteneurs et outils de support sur diverses plates-formes cloud et architectures locales.  Comprendre la terminologie, les normes et l'architecture des syst√®mes de conteneurs vous permettra de communiquer avec d'autres sp√©cialistes et de concevoir des applications et des environnements conteneuris√©s √©volutifs et pris en charge qui garantissent l'utilisation efficace des conteneurs pour les ann√©es √† venir. <br><br><h3>  Vocabulaire de base </h3><br><h4>  Image du conteneur </h4><br>  Dans sa d√©finition la plus simple, une image de conteneur est un fichier t√©l√©charg√© √† partir du serveur de registre et utilis√© localement comme point de montage au d√©marrage du conteneur.  Bien que le terme ¬´image de conteneur¬ª soit utilis√© assez souvent, il peut signifier diff√©rentes choses.  Le fait est que bien que Docker, RKT et m√™me LXD fonctionnent selon le principe qui vient d'√™tre d√©crit - c'est-√†-dire qu'ils t√©l√©chargent les fichiers supprim√©s et les ex√©cutent en tant que conteneurs - chacune de ces technologies interpr√®te l'image du conteneur √† sa mani√®re.  LXD fonctionne avec des images monolithiques (monocouche), tandis que docker et RKT utilisent des images OCI, qui peuvent contenir plusieurs couches. <br><br>  √Ä strictement parler, une image de conteneur sur un serveur de registre est loin d'√™tre un seul fichier.  Lorsque les gens utilisent le terme ¬´image de conteneur¬ª, ils d√©signent souvent le r√©f√©rentiel et un ensemble de plusieurs couches de l'image de conteneur, ainsi que des m√©tadonn√©es qui contiennent des informations suppl√©mentaires sur ces couches. <br><br>  De plus, le concept d'image conteneur implique implicitement l'existence d'un format pour une telle image. <br><br><h4>  Format d'image du conteneur </h4><br>  Initialement, chaque moteur de conteneur, y compris LXD, RKT et Docker, avait son propre format d'image.  Certains de ces formats n'autorisent qu'une seule couche, tandis que d'autres prennent en charge une arborescence de plusieurs couches.  Aujourd'hui, presque tous les principaux outils et moteurs de conteneur sont pass√©s au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OCI</a> , qui d√©termine comment les couches et les m√©tadonn√©es doivent √™tre organis√©es dans l'image du conteneur.  En substance, le format OCI d√©finit une image de conteneur qui se compose de fichiers tar s√©par√©s pour chaque couche et d'un fichier manifest.json commun contenant des m√©tadonn√©es. <br><br>  La norme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Open Container Initiative (OCI)</a> , qui √©tait √† l'origine bas√©e sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le format d'image Docker V2</a> , a r√©ussi √† combiner un vaste √©cosyst√®me de moteurs de conteneurs, de plates-formes cloud et d'outils (scanners de s√©curit√©, outils de signature, cr√©ation et d√©placement de conteneurs) et vous permet de prot√©ger votre investissement dans les connaissances et des outils. <br><br><h4>  Moteur de conteneur </h4><br>  Le moteur de conteneur est la partie du logiciel qui accepte les demandes des utilisateurs, y compris les param√®tres de ligne de commande, t√©l√©charge les images et, du point de vue de l'utilisateur final, lance les conteneurs.  Il existe de nombreux moteurs de conteneurs, dont Docker, RKT, CRI-O et LXD.  En outre, de nombreuses plates-formes cloud, services PaaS et plates-formes de conteneurs ont leurs propres moteurs qui comprennent les images au format Docker ou OCI.  Le fait d'avoir une norme industrielle pour le format d'image garantit l'interop√©rabilit√© de toutes ces plateformes. <br><br>  En descendant d'un niveau, nous pouvons dire que la plupart des moteurs de conteneur ne d√©marrent pas r√©ellement les conteneurs eux-m√™mes, mais via un runtime compatible OCI, comme runc.  En r√®gle g√©n√©rale, un runtime de conteneur effectue les op√©rations suivantes: <br><br><ul><li>  G√®re les param√®tres, entr√©e utilisateur </li><li>  G√®re les param√®tres transmis via l'API (le plus souvent le syst√®me d'orchestration de conteneurs) </li><li>  T√©l√©charger des images de conteneur depuis le serveur de registre </li><li>  D√©compresse et enregistre l'image du conteneur sur le disque √† l'aide du pilote graphique (bloc ou fichier, selon le pilote) </li><li>  Pr√©pare un point de montage pour le conteneur, g√©n√©ralement dans un stockage de copie sur √©criture (√† nouveau, bloc ou fichier, selon le pilote) </li><li>  Pr√©pare les m√©tadonn√©es qui seront transmises au runtime pour ex√©cuter correctement le conteneur en utilisant: <br><ul><li>  Param√®tres par d√©faut sp√©cifiques implicites pour l'image du conteneur (par exemple, <a href="">ArchX86</a> ) </li><li>  Entr√©e utilisateur pour remplacer les valeurs par d√©faut contenues dans l'image du conteneur (par exemple, CMD, ENTRYPOINT) </li><li>  Param√®tres par d√©faut sp√©cifi√©s par l'image du conteneur (par exemple, r√®gles <a href="">SECCOM</a> ) </li></ul></li><li>  Appelle l'ex√©cution du conteneur </li></ul><br><h4>  Conteneur </h4><br>  Les conteneurs existent dans les syst√®mes d'exploitation depuis un certain temps, car il ne s'agit en fait que d'une instance en cours d'ex√©cution d'une image de conteneur.  Un conteneur est un processus Linux standard qui est g√©n√©ralement cr√©√© √† l'aide de l'appel syst√®me clone () au lieu de fork () ou exec ().  De plus, des mesures d'isolement suppl√©mentaires sont souvent appliqu√©es aux conteneurs √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SELinux</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppArmor</a> . <br><br><h4>  H√¥te de conteneur </h4><br>  Un h√¥te de conteneur est un syst√®me sur lequel s'ex√©cutent des processus conteneuris√©s, souvent appel√©s conteneurs pour plus de simplicit√©.  Il peut s'agir, par exemple, d'une machine virtuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RHEL Atomic Host</a> situ√©e dans un cloud public ou ex√©cut√©e sur du m√©tal nu dans un centre de donn√©es d'entreprise.  Lorsque l'image de conteneur (en d'autres termes, le r√©f√©rentiel) du serveur de registre est t√©l√©charg√©e sur l'h√¥te de conteneur local, ils disent qu'elle tombe dans le cache local. <br><br>  Vous pouvez d√©terminer quels r√©f√©rentiels sont synchronis√©s avec le cache local √† l'aide de la commande suivante: <br><br><pre>  [root @ rhel7 ~] # images docker -a<font></font>
<font></font>
 ID D'IMAGE D'√âTIQUETTE DE R√âF√âRENTIEL FORMAT VIRTUEL CR√â√â
 registry.access.redhat.com/rhel7 derni√®re 6883d5422f4e il y a 3 semaines 201,7 Mo </pre><br><h4>  Serveur de registre </h4><br>  Un serveur de registre est essentiellement un serveur de fichiers utilis√© pour stocker des r√©f√©rentiels Docker.  En r√®gle g√©n√©rale, le serveur de registre est sp√©cifi√© par le nom DNS et, √©ventuellement, le num√©ro de port.  La plupart des avantages de l'√©cosyst√®me Docker sont dus √† la possibilit√© de t√©l√©charger et de t√©l√©charger des r√©f√©rentiels sur des serveurs de registre. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Si le d√©mon docker ne trouve pas de copie du r√©f√©rentiel dans le cache local, il la t√©l√©charge automatiquement √† partir du serveur de registre.  Sur la plupart des distributions Linux, le d√©mon docker utilisera le site docker.io pour cela, mais sur certaines distributions, il peut √™tre configur√© √† sa mani√®re.  Par exemple, Red Hat Enterprise Linux essaie d'abord de t√©l√©charger √† partir de registry.access.redhat.com, puis seulement √† partir de docker.io (Docker Hub). <br><br>  Il faut souligner ici que le serveur de registre est implicitement consid√©r√© comme fiable.  Par cons√©quent, vous devez d√©cider dans quelle mesure vous faites confiance au contenu d'un registre et, respectivement, l'autoriser ou le refuser.  Outre la s√©curit√©, d'autres aspects doivent √™tre trait√©s √† l'avance, par exemple les probl√®mes de licence logicielle ou la surveillance de la conformit√©.  La simplicit√© avec laquelle Docker permet aux utilisateurs de t√©l√©charger des logiciels rend la question de la confiance extr√™mement importante. <br><br>  Red Hat Enterprise Linux vous permet de configurer le registre Docker par d√©faut.  De plus, RHEL7 et RHEL7 Atomic vous permettent d'ajouter ou de verrouiller des serveurs de registre via le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fichier de configuration</a> : <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 et RHEL 7 Atomic utilisent le serveur de registre Red Hat par d√©faut: <br><br><pre>  ADD_REGISTRY = '- add-registry registry.access.redhat.com'
</pre><br>  Dans certains cas, pour des raisons de s√©curit√©, il est logique de bloquer les registres de docker publics, tels que DockerHub: <br><br><pre>  # BLOCK_REGISTRY = '- bloc-registre'
</pre><br>  Red Hat propose √©galement son serveur de registre int√©gr√© dans le cadre de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plate</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">forme de conteneur OpenShift</a> , ainsi que le serveur de registre d'entreprise autonome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quay Enterprise</a> et le cloud, les r√©f√©rentiels priv√©s et publics <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quay.io.</a> <br><br><h4>  Orchestration de conteneurs </h4><br>  Les gens commencent g√©n√©ralement par installer un h√¥te de conteneur et t√©l√©chargent d'abord les images de conteneur dont ils ont besoin.  Ensuite, ils proc√®dent √† la cr√©ation de leurs propres images et les t√©l√©chargent sur le serveur de registre pour les mettre √† la disposition du reste de l'√©quipe.  Apr√®s un certain temps, il est n√©cessaire de combiner plusieurs conteneurs afin qu'ils puissent √™tre d√©ploy√©s en une seule unit√©.  Et enfin, √† un moment donn√©, ces unit√©s doivent faire partie du convoyeur de production (d√©veloppement-QA-production).  C'est ainsi que les gens r√©alisent g√©n√©ralement qu'ils ont besoin d'un syst√®me d'orchestration. <br><br>  <b>Le syst√®me d'orchestration de conteneurs n'impl√©mente que deux choses:</b> <br><br><ol><li>  R√©partir dynamiquement les chargements de conteneurs sur les ordinateurs du cluster (ce que l'on appelle souvent ¬´informatique distribu√©e¬ª) </li><li>  Fournit un fichier de description d'application standard (kube yaml, docker compose, etc.) </li></ol><br>  Ces deux choses offrent en fait une gamme d'avantages: <br><br><ol><li>  La possibilit√© de g√©rer les conteneurs qui composent l'application, ind√©pendamment les uns des autres, ce qui vous permet de r√©soudre efficacement les t√¢ches suivantes: <br><ul><li>  √âlimination des grands clusters h√¥tes de conteneurs </li><li>  D√©faillance au niveau des conteneurs individuels (processus ne r√©pondant plus, √©puisement de la m√©moire) </li><li>  Basculement au niveau de l'h√¥te du conteneur (lecteurs, r√©seau, red√©marrage) </li><li>  Basculement au niveau du moteur du conteneur (avarie, red√©marrage) </li><li>  Mise √† l'√©chelle individuelle des conteneurs de haut en bas </li></ul></li><li>  D√©ploiement facile de nouvelles instances de la m√™me application dans de nouveaux environnements, √† la fois cloud et traditionnels, par exemple: <br><ul><li>  Sur les machines de d√©veloppement contr√¥l√©es par un syst√®me d'orchestration </li><li>  Dans un environnement de d√©veloppement partag√© dans un espace de noms priv√© </li><li>  Dans un environnement de d√©veloppement commun dans un espace de noms public interne pour garantir la visibilit√© et les performances des tests </li><li>  Dans l'environnement interne de QA </li><li>  Dans un environnement de charge de test fourni dynamiquement et r√©voqu√© dans le cloud </li><li>  Dans un environnement de r√©f√©rence pour v√©rifier la compatibilit√© avec l'environnement de production </li><li>  En environnement de production </li><li>  Dans un environnement de reprise apr√®s sinistre </li><li>  Dans un nouvel environnement de production contenant des h√¥tes de conteneurs, des moteurs de conteneurs ou des outils d'orchestration mis √† jour </li><li>  Dans le nouvel environnement de production, qui n'est pas diff√©rent du principal, mais situ√© dans une r√©gion diff√©rente </li></ul></li></ol><br>  Les communaut√©s Open Source et les √©diteurs de logiciels proposent de nombreux outils d'orchestration diff√©rents.  Au d√©part, les trois grands de ces outils incluaient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mesos</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kubernetes</a> , mais aujourd'hui Kubernetes est devenu la norme de l'industrie, car m√™me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mesosphere</a> ont annonc√© leur soutien, sans parler de presque tous les principaux fournisseurs de services.  Cependant, si vous recherchez un syst√®me d'orchestration d'entreprise, nous vous recommandons de regarder de plus pr√®s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Red Hat OpenShift</a> . <br><br><h3>  Dictionnaire avanc√© </h3><br><h4>  Ex√©cution du conteneur </h4><br>  Le runtime du conteneur est un composant de bas niveau qui est g√©n√©ralement utilis√© dans le cadre d'un moteur de conteneur, mais peut √©galement √™tre utilis√© manuellement pour tester les conteneurs.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La norme OCI</a> d√©finit une impl√©mentation de r√©f√©rence du runtime connue sous le nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">runc</a> .  Il s'agit de l'impl√©mentation la plus utilis√©e, mais il existe d'autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">temps d'ex√©cution</a> compatibles OCI tels que les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneurs Crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Railcar</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">katacontainers</a> .  Docker, CRI-O et de nombreux autres moteurs de conteneurs utilisent runc. <br><br>  Le runtime du conteneur est responsable des √©l√©ments suivants: <br><br><ul><li>  Obtient le point de montage du conteneur fourni par le moteur de conteneur (pour les tests, il pourrait simplement s'agir d'un r√©pertoire) </li><li>  Obtient les m√©tadonn√©es de conteneur fournies par le moteur de conteneur (pendant les tests, il peut s'agir d'un fichier config.json assembl√© manuellement) </li><li>  Communique avec le noyau du syst√®me d'exploitation pour lancer des processus conteneuris√©s (via l'appel syst√®me clone) </li><li>  Configure les groupes de contr√¥le </li><li>  Configure la politique SELinux </li><li>  Configure les r√®gles d'armure d'application </li></ul><br>  Petite parenth√®se historique: lorsque le moteur Docker est apparu pour la premi√®re fois, il utilisait le LXC comme environnement d'ex√©cution.  Les d√©veloppeurs Docker ont ensuite √©crit leur propre biblioth√®que pour ex√©cuter des conteneurs appel√©s libcontainer.  Il a √©t√© √©crit dans la langue Golang et est devenu une partie du moteur Docker.  Apr√®s la cr√©ation de l'organisation OCI, Docker a introduit le code source libcontainer dans ce projet et a publi√© cette biblioth√®que en tant qu'utilitaire distinct appel√© runc, qui est ensuite devenu l'impl√©mentation de r√©f√©rence du runtime du conteneur dans la norme OCI et est utilis√© dans d'autres moteurs de conteneur, tels que CRI-O .  Runc est un utilitaire tr√®s simple qui n'attend qu'un point de montage (r√©pertoire) et des m√©tadonn√©es (config.json) pour lui √™tre transmis.  Vous trouverez plus d'informations sur runc <a href="">ici</a> . <br><br>  Pour une compr√©hension plus approfondie, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation des normes de conteneur</a> et de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ex√©cution</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conteneur</a> . <br><br><h4>  Couches d'images </h4><br>  Les r√©f√©rentiels sont souvent appel√©s images ou images de conteneurs, bien qu'en r√©alit√© les r√©f√©rentiels se composent d'une ou plusieurs couches.  Les couches d'image du r√©f√©rentiel sont interconnect√©es par les relations parent-enfant, et chaque couche d'image contient des diff√©rences par rapport √† la couche parent. <br><br>  Examinons les couches de r√©f√©rentiel sur l'h√¥te de conteneur local.  Depuis le d√©marrage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de la version 1.7, Docker ne dispose d'aucun outil int√©gr√© pour afficher les couches d'images</a> dans le r√©f√©rentiel local (mais il existe des outils pour les registres en ligne), nous utiliserons l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dockviz</a> .  Notez que chaque couche a une balise et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">identifiant unique universel (UUID)</a> .  Pour afficher les UUID abr√©g√©s qui sont g√©n√©ralement uniques au sein de la m√™me machine, nous utilisons la commande suivante (si vous avez besoin d'un UUID complet, utilisez la m√™me commande avec l'option -no-trunc): <br><br>  docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock nate / dockviz images -t <br><br><pre>  ‚îú‚îÄ2332d8973c93 Taille virtuelle: 187,7 Mo
  Virtual ‚îî‚îÄea358092da77 Taille virtuelle: 187,9 Mo
  Virtual ‚îî‚îÄa467a7c6794f Taille virtuelle: 187,9 Mo
  ‚îÇ ‚îî‚îÄca4d7b1b9a51 Taille virtuelle: 187,9 Mo
  Virtual ‚îî‚îÄ4084976dd96d Taille virtuelle: 384,2 Mo
  Virtual ‚îî‚îÄ943128b20e28 Taille virtuelle: 386,7 Mo
  ‚îÇ ‚îî‚îÄdb20cc018f56 Taille virtuelle: 386,7 Mo
  ‚îÇ ‚îî‚îÄ45b3c59b9130 Taille virtuelle: 398,2 Mo
  Virtual ‚îî‚îÄ91275de1a5d7 Taille virtuelle: 422,8 Mo
  Virtual ‚îî‚îÄe7a97058d51f Taille virtuelle: 422,8 Mo
  ‚îÇ ‚îî‚îÄd5c963edfcb2 Taille virtuelle: 422,8 Mo
  ‚îÇ ‚îî‚îÄ5cfc0ce98e02 Taille virtuelle: 422,8 Mo
  Virtual ‚îî‚îÄ7728f71a4bcd Taille virtuelle: 422,8 Mo
  ‚îÇ ‚îî‚îÄ0542f67da01b Taille virtuelle: 422,8 Mo Tags: docker.io/registry:latest
</pre><br>  Comme vous pouvez le voir, le r√©f√©rentiel docker.io/registry se compose en fait de plusieurs couches.  Cependant, plus important encore, l'utilisateur peut, en principe, ¬´d√©marrer¬ª le conteneur √† partir de n'importe quelle √©tape de cette √©chelle, par exemple, en entrant la commande ci-dessous (c'est tout √† fait correct, mais personne ne peut garantir qu'il a √©t√© test√© ou fonctionnera correctement).  En r√®gle g√©n√©rale, le collecteur d'images marque (cr√©e des noms) les couches qui doivent √™tre utilis√©es comme point de d√©part: <br><br><pre>  docker run -it 45b3c59b9130 bash
</pre><br>  Les r√©f√©rentiels sont organis√©s de la m√™me mani√®re car chaque fois que le collecteur cr√©e une nouvelle image, les diff√©rences sont enregistr√©es sous un autre calque.  Il existe deux fa√ßons principales de cr√©er de nouvelles couches dans le r√©f√©rentiel.  Tout d'abord, lors de la cr√©ation manuelle d'une image, chaque confirmation de modification cr√©e un nouveau calque.  Si le collecteur cr√©e une image √† l'aide d'un fichier Docker, chaque directive du fichier cr√©e un nouveau calque.  Par cons√©quent, il est toujours utile de pouvoir voir ce qui a chang√© dans le r√©f√©rentiel entre les couches. <br><br><h4>  Balises </h4><br>  Bien que l'utilisateur lui-m√™me puisse sp√©cifier la couche de d√©part pour le montage et le d√©marrage du conteneur dans le r√©f√©rentiel, il n'a pas du tout √† le faire.  Lorsque le collecteur d'images cr√©e un nouveau r√©f√©rentiel, ils marquent g√©n√©ralement les calques les plus appropri√©s pour ce r√¥le.  Ces marqueurs sont appel√©s balises et repr√©sentent un outil avec lequel le collecteur d'images peut indiquer au consommateur d'images quelles couches sont les mieux utilis√©es.  En r√®gle g√©n√©rale, les balises sont utilis√©es pour indiquer les versions logicielles dans un r√©f√©rentiel.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, ni OCI, ni aucune autre norme ne r√©glemente l'utilisation des balises, ce qui ouvre un champ illimit√© de confusion pendant la collaboration. </font><font style="vertical-align: inherit;">Par cons√©quent, nous vous recommandons de documenter soigneusement les balises si elles sont utilis√©es non seulement pour marquer les versions logicielles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, il existe une balise sp√©ciale - latest, qui pointe g√©n√©ralement vers une couche contenant les derniers logiciels dans le r√©f√©rentiel. </font><font style="vertical-align: inherit;">Cette balise pointe simplement vers la couche d'image, comme toute autre balise, et peut donc √©galement √™tre utilis√©e de mani√®re incorrecte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher √† distance les balises disponibles dans le r√©f√©rentiel, ex√©cutez la commande suivante (l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilitaire jq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rend la sortie beaucoup plus lisible):</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curl -s registry.access.redhat.com/v1/repositories/rhel7/tags | </font><font style="vertical-align: inherit;">jq
 </font></font> {<font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font>
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",<font></font>
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",<font></font>
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",<font></font>
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",<font></font>
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "latest": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"<font></font>
  }
</pre><br><h4>  </h4><br>    docker     ,   . ,     ¬´rhel7¬ª ‚Äì  . <br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      ¬´¬ª (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
 registry.access.redhat.com/rhel6/rhel latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
  ...
</pre><br>     ,            .      docker ( ,    )      ,      ¬´rhel7¬ª    . <br><br>         ,    docker     URL.  ,   ,   URL   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br>  ,    : <br><br><pre> REGISTRY/NAMESPACE/REPOSITORY[:TAG]
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une URL compl√®te se compose d'un nom de serveur, d'un espace de noms et √©ventuellement d'une balise. </font><font style="vertical-align: inherit;">En fait, il y a beaucoup de nuances lors de la sp√©cification d'une URL, et en explorant l'√©cosyst√®me des dockers, vous verrez que beaucoup de choses sont facultatives. </font><font style="vertical-align: inherit;">En particulier, regardez les commandes ci-dessous: toutes sont correctes et conduisent au m√™me r√©sultat:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> docker pull registry.access.redhat.com/rhel7/rhel:latest</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 docker pull registry.access.redhat.com/rhel7/rhel</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 docker pull registry.access.redhat.com/rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 docker pull rhel7 / rhel: dernier</font></font><font></font>
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espaces de noms </font></font></h4><br>   ‚Äì       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DockerHub</a>       ,     ,         . <br><br> Red Hat         ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Red Hat Federated Registry</a> .     registry.access.redhat.com  .  ,            .    ,  Red Hat   ,     -  : <br><br><pre> registry.access.redhat.com/rhel7/rhel<font></font>
registry.access.redhat.com/openshift3/mongodb-24-rhel7<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
registry.access.redhat.com/rhscl/mongodb-26-rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter que parfois l'URL compl√®te peut ne pas √™tre sp√©cifi√©e. </font><font style="vertical-align: inherit;">Dans l'exemple ci-dessus, pour chaque espace de noms, il existe un r√©f√©rentiel par d√©faut. </font><font style="vertical-align: inherit;">Si l'utilisateur sp√©cifie uniquement l'espace de noms fedora, le r√©f√©rentiel avec la derni√®re balise est t√©l√©charg√© sur le serveur local. </font><font style="vertical-align: inherit;">Par cons√©quent, les commandes ci-dessous conduisent au m√™me r√©sultat:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> docker pull fedora</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker pull docker.io/fedora</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
docker pull docker.io/library/fedora:latest</font></font><font></font>
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espaces de noms du noyau </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exec()</a> .    ,       ,  docker,   docker          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">clone()</a> .   clone ()     ,          ,  ,  ,  ,    .. <br><br> ,   Linux   -      ,            clone (). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b> ‚Ä¶</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416169/">https://habr.com/ru/post/fr416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416157/index.html">Dans les bras de Python (femmes uniquement)</a></li>
<li><a href="../fr416159/index.html">Comment nous avons √©t√© charg√©s de comparer un h√©risson avec un serpent</a></li>
<li><a href="../fr416161/index.html">10 raisons [de ne pas] utiliser k8s</a></li>
<li><a href="../fr416163/index.html">Apprenez OpenGL. Le√ßon 5.6 - Mappage de parallaxe</a></li>
<li><a href="../fr416167/index.html">Peter Norwig: apprendre la programmation en ... 10 ans</a></li>
<li><a href="../fr416171/index.html">Tests d'interface utilisateur cod√©s Visual Studio: th√©orie et pratique de l'application dans notre entreprise</a></li>
<li><a href="../fr416175/index.html">R√©sultats du concours des jeunes d√©veloppeurs d'applications AR Epson Moverio BT-300</a></li>
<li><a href="../fr416177/index.html">Formule de Tupper et impl√©mentation de l'algorithme en Python</a></li>
<li><a href="../fr416179/index.html">Une porte qui nous accueille par son nom et ne s'ouvre qu'aux employ√©s du d√©partement</a></li>
<li><a href="../fr416181/index.html">Modulation d'amplitude sur les doigts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>