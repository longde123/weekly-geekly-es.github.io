<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç∑ üë®üèø‚Äç‚öïÔ∏è ü§§ De todos modos, ¬°no puedes hacerlo! - Uso de interfaces e inyecci√≥n de dependencias para un dise√±o a largo plazo. üöä üîù üßñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 Finalmente tenemos un contrato para actualizar el libro de Mark Siman " Dependency Injection in .NET ". Lo principal es que lo termin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>De todos modos, ¬°no puedes hacerlo! - Uso de interfaces e inyecci√≥n de dependencias para un dise√±o a largo plazo.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/428075/">  Hola a todos! <br><br>  Finalmente tenemos un contrato para actualizar el libro de Mark Siman " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dependency Injection in .NET</a> ". Lo principal es que lo termine lo antes posible.  Tambi√©n tenemos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">libro</a> en el editor del respetado Dinesh Rajput sobre patrones de dise√±o en la primavera 5, donde uno de los cap√≠tulos tambi√©n est√° dedicado a la implementaci√≥n de dependencias. <br><br>  Durante mucho tiempo hemos estado buscando material interesante que recuerde las fortalezas del paradigma DI y aclare nuestro inter√©s en √©l, y ahora se ha encontrado.  Es cierto que el autor prefiri√≥ dar ejemplos en Go.  Esperamos que esto no le impida seguir sus pensamientos y le ayude a comprender los principios generales de inversi√≥n de control y trabajar con interfaces, si este tema est√° cerca de usted. <br><br>  La coloraci√≥n emocional del original es un poco m√°s tranquila, el n√∫mero de signos de exclamaci√≥n en la traducci√≥n se reduce.  Que tengas una buena lectura! <br><a name="habracut"></a><br>  El uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaces</a> es una t√©cnica comprensible que le permite crear c√≥digo que es f√°cil de probar y f√°cilmente extensible.  En repetidas ocasiones me he convencido de que esta es la herramienta de dise√±o de arquitectura m√°s poderosa de todas. <br><br>  El prop√≥sito de este art√≠culo es explicar qu√© son las interfaces, c√≥mo se usan y c√≥mo proporcionan extensibilidad y capacidad de prueba del c√≥digo.  Finalmente, el art√≠culo debe mostrar c√≥mo las interfaces pueden ayudar a optimizar la gesti√≥n de entrega de software y simplificar la planificaci√≥n. <br><br>  <b>Interfaces</b> <br><br>  La interfaz describe el contrato.  Dependiendo del lenguaje o marco, el uso de interfaces puede ser dictado expl√≠cita o impl√≠citamente.  Entonces, en el lenguaje Go, las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaces se dictan expl√≠citamente</a> .  Si intenta utilizar una entidad como interfaz, pero no ser√° totalmente coherente con las reglas de esta interfaz, se producir√° un error en tiempo de compilaci√≥n.  Por ejemplo, al ejecutar el ejemplo anterior, obtenemos el siguiente error: <br><br><pre><code class="hljs sql">prog.go:22:85: cannot <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> BadPricer literal (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BadPricer) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockPricer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> isPricerHigherThan100: BadPricer does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implement StockPricer (<span class="hljs-keyword"><span class="hljs-keyword">missing</span></span> CurrentPrice method) Program exited.</code> </pre> <br>  Interfaces es una herramienta para ayudar a separar a la persona que llama de la persona que llama, esto se hace mediante un contrato. <br><br>  Vamos a concretar este problema usando un ejemplo de un programa para el intercambio autom√°tico de divisas.  Se llamar√° al programa de comerciantes con un precio de compra establecido y un s√≠mbolo de cotizaci√≥n.  Luego, el programa ir√° al intercambio para averiguar la cotizaci√≥n actual de este ticker.  Adem√°s, si el precio de compra de este ticker no excede el precio establecido, el programa realizar√° una compra. <br><br><img src="https://habrastorage.org/webt/pp/hx/mv/pphxmvus0-rkxh-vffl9o18bjsq.png"><br><br>  De forma simplificada, la arquitectura de este programa se puede representar de la siguiente manera.  Del ejemplo anterior est√° claro que la operaci√≥n de obtener el precio actual depende directamente del protocolo HTTP, mediante el cual el programa contacta al servicio de intercambio. <br><br>  El estado de la <code>Action</code> tambi√©n depende directamente de HTTP.  Por lo tanto, ambos estados deben comprender completamente c√≥mo usar HTTP para extraer datos de intercambio y / o completar transacciones. <br><br>  As√≠ es como se ver√≠a la implementaci√≥n: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err)</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... currentPrice := parsePriceFromBody(body) var hasTraded bool var err error if currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) if err == nil { hasTraded = true } } return hasTraded, err }</span></span></code> </pre> <br>  Aqu√≠, la persona que llama ( <code>analyze</code> ) depende directamente de HTTP.  Ella necesita saber c√≥mo se formulan las solicitudes HTTP.  ¬øC√≥mo se hace su an√°lisis?  C√≥mo manejar reintentos, tiempos de espera, autenticaci√≥n, etc.  Ella tiene un buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">control</a> sobre <code>http</code> .  <b>Siempre que llamemos a an√°lisis, tambi√©n debemos llamar a la biblioteca <code>http</code></b> . <br><br>  ¬øC√≥mo puede ayudarnos la interfaz aqu√≠?  En el contrato proporcionado por la interfaz, puede describir el <b>comportamiento</b> , en lugar de la <b>implementaci√≥n</b> espec√≠fica. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StockExchange <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CurrentPrice(ticker <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br>  Lo anterior define el concepto de <code>StockExchange</code> .  Aqu√≠ dice que <code>StockExchange</code> admite llamar a la √∫nica funci√≥n <code>CurrentPrice</code> .  Estas tres l√≠neas me parecen la t√©cnica arquitect√≥nica m√°s poderosa de todas.  Nos ayudan a controlar las dependencias de las aplicaciones con mucha m√°s confianza.  Proporcionar pruebas.  Proporcionar extensibilidad. <br><br>  <b>Inyecci√≥n de dependencia</b> <br><br>  Para comprender completamente el valor de las interfaces, debe dominar la t√©cnica llamada "inyecci√≥n de dependencia". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La inyecci√≥n de dependencia</a> significa que la persona que llama proporciona algo que necesita.  Por lo general, se ve as√≠: la persona que llama configura el objeto y luego lo pasa a la persona que llama.  Luego, la parte llamada extrae de la configuraci√≥n y la implementaci√≥n.  En este caso, hay una mediaci√≥n conocida.  Considere una solicitud al servicio HTTP Rest.  Para implementar el cliente, necesitamos usar una biblioteca HTTP que pueda formular, enviar y recibir solicitudes HTTP. <br><br>  Si colocamos la solicitud HTTP detr√°s de la interfaz, la persona que llama podr√≠a separarse y ella "no se dar√≠a cuenta" de que la solicitud HTTP realmente tuvo lugar. <br><br>  La persona que llama solo debe realizar una llamada de funci√≥n gen√©rica.  Puede ser una llamada local, una llamada remota, una llamada HTTP, una llamada RPC, etc.  La persona que llama no est√° al tanto de lo que est√° sucediendo y, por lo general, le conviene perfectamente, siempre que obtenga los resultados esperados.  A continuaci√≥n se muestra c√≥mo se ver√≠a la inyecci√≥n de dependencia en nuestro m√©todo de <code>analyze</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StockExchange, ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, maxTradePrice </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hasTraded <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maximumTradePrice { err = doTrade(ticker, currentPrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { hasTraded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasTraded, err }</code> </pre> <br>  Nunca dejo de sorprenderme de lo que est√° sucediendo aqu√≠.  Revertimos completamente nuestro √°rbol de dependencias y comenzamos a controlar mejor todo el programa.  Adem√°s, incluso visualmente, toda la implementaci√≥n se ha vuelto m√°s limpia y comprensible.  Vemos claramente que el m√©todo de an√°lisis debe elegir el precio actual, verificar si este precio es adecuado para nosotros y, de ser as√≠, hacer un trato. <br><br>  Lo m√°s importante, en este caso separamos a la persona que llama de la persona que llama.  Dado que la persona que llama y toda la implementaci√≥n est√°n separadas de la llamada usando la interfaz, puede extender la interfaz creando muchas implementaciones diferentes.  ¬°Las interfaces le permiten crear muchas implementaciones espec√≠ficas diferentes sin necesidad de cambiar el c√≥digo de la parte llamada! <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  El estado de "obtener el precio actual" en este programa depende solo de la interfaz de <code>StockExchange</code> .  Esta implementaci√≥n no sabe <b>nada</b> sobre c√≥mo contactar al servicio de intercambio, c√≥mo se almacenan los precios o c√≥mo se realizan las solicitudes.  La verdadera ignorancia dichosa.  Por otra parte, bilateral.  La implementaci√≥n <code>HTTPStockExchange</code> tampoco sabe nada sobre el an√°lisis.  Sobre el contexto en el que se llevar√° a cabo el an√°lisis, cuando se lleve a cabo, porque los desaf√≠os ocurren indirectamente. <br><br>  Dado que los fragmentos de programa (aquellos que dependen de interfaces) no necesitan cambiarse al cambiar / agregar / eliminar implementaciones espec√≠ficas, <b>dicho dise√±o resulta ser duradero</b> .  Supongamos que encontramos que <code>StockService</code> menudo no <code>StockService</code> disponible. <br><br>  ¬øEn qu√© se diferencia el ejemplo anterior de llamar a una funci√≥n?  Al aplicar una llamada de funci√≥n, la implementaci√≥n tambi√©n ser√° m√°s limpia.  La diferencia es que cuando llama a la funci√≥n, todav√≠a tenemos que recurrir a HTTP.  El m√©todo de <code>analyze</code> simplemente delegar√° la tarea de la funci√≥n, que deber√≠a llamar a <code>http</code> , en lugar de llamar a <code>http</code> directamente.  Toda la fuerza de esta t√©cnica radica en la "inyecci√≥n", es decir, en que la persona que llama proporciona la interfaz a la persona que llama.  As√≠ es exactamente como se produce la inversi√≥n de dependencia, donde los precios dependen solo de la interfaz y no de la implementaci√≥n. <br><br>  <b>M√∫ltiples implementaciones listas para usar</b> <br><br>  En esta etapa, tenemos la funci√≥n de <code>analyze</code> y la interfaz <code>StockExchange</code> , pero en realidad no podemos hacer nada √∫til.  Acabo de anunciar nuestro programa.  Por el momento, es imposible llamarlo, ya que todav√≠a no tenemos una √∫nica implementaci√≥n espec√≠fica que cumpla con los requisitos de nuestra interfaz. <br><br>  El √©nfasis principal en el siguiente diagrama se hace en el estado de "obtener el precio actual" y su dependencia de la interfaz de <code>StockExchange</code> .  A continuaci√≥n se muestra c√≥mo coexisten dos implementaciones completamente diferentes y no se conoce el precio actual.  Adem√°s, ambas implementaciones no est√°n relacionadas entre s√≠, cada una de ellas depende solo de la interfaz de <code>StockExchange</code> . <br><br><img src="https://habrastorage.org/webt/c8/us/5_/c8us5_mv_y2tmittjhk33ahgw7i.png"><br><br>  Producci√≥n <br><br>  La implementaci√≥n HTTP original ya existe en la implementaci√≥n de <code>analyze</code> primaria;  todo lo que nos queda es extraerlo y encapsularlo detr√°s de una implementaci√≥n concreta de la interfaz. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HTTPStockExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se HTTPStockExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { resp, err := http.Get( <span class="hljs-string"><span class="hljs-string">"http://stock-service.com/currentprice/"</span></span> + ticker ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... return parsePriceFromBody(body) }</span></span></code> </pre> <br>  El c√≥digo que anteriormente <code>StockExchange</code> a la funci√≥n de an√°lisis ahora es aut√≥nomo y satisface la interfaz de <code>StockExchange</code> , es decir, ahora podemos pasarlo a <code>analyze</code> .  Como recordar√° de los diagramas anteriores, el an√°lisis ya no est√° asociado con la dependencia HTTP.  Al usar la interfaz, el <code>analyze</code> no "imagina" lo que sucede detr√°s de escena.  Solo sabe que se le garantizar√° un objeto con el que puede llamar a <code>CurrentPrice</code> . <br><br>  Tambi√©n aqu√≠ aprovechamos las virtudes t√≠picas de la encapsulaci√≥n.  Antes, cuando las solicitudes http estaban vinculadas al an√°lisis, la √∫nica forma de comunicarse con el intercambio a trav√©s de http era indirecta, a trav√©s del m√©todo de <code>analyze</code> .  S√≠, podr√≠amos encapsular estas llamadas en funciones y ejecutar la funci√≥n de forma independiente, pero las interfaces nos obligan a separar a la persona que llama de la persona que llama.  Ahora podemos probar <code>HTTPStockExchange</code> independientemente de la persona que llama.  Esto afecta fundamentalmente el alcance de nuestras pruebas y c√≥mo entendemos y respondemos a las fallas de las pruebas. <br><br>  <b>Prueba</b> <br><br>  En el c√≥digo existente, tenemos la estructura <code>HTTPStockService</code> , que nos permite asegurarnos por separado de que puede comunicarse con el servicio de intercambio y analizar las respuestas recibidas de √©l.  Pero ahora <code>StockExchange</code> que el an√°lisis pueda manejar correctamente la respuesta de la interfaz de <code>StockExchange</code> , adem√°s, que esta operaci√≥n es confiable y reproducible. <br><br><pre> <code class="go hljs">currentPrice := se.CurrentPrice(ticker) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> currentPrice &lt;= maxTradePrice { err := doTrade(ticker, currentPrice) }</code> </pre> <br>  PODR√çAMOS usar la implementaci√≥n con HTTP, pero tendr√≠a muchas desventajas.  Hacer llamadas de red en pruebas unitarias puede ser lento, especialmente para servicios externos.  Debido a demoras y una conexi√≥n de red inestable, las pruebas podr√≠an resultar poco confiables.  Adem√°s, si necesit√°ramos pruebas con la declaraci√≥n de que podemos completar la transacci√≥n, y pruebas con la declaraci√≥n de que podemos filtrar los casos en los que la transacci√≥n NO debe concluirse, ser√≠a dif√≠cil encontrar datos de producci√≥n reales que satisfagan de manera confiable ambos condiciones  Se podr√≠a elegir <code>maxTradePrice</code> , imitando artificialmente cada una de las condiciones de esta manera, por ejemplo, con <code>maxTradePrice := -100</code> transacci√≥n no debe completarse, y <code>maxTradePrice := 10000000</code> obviamente debe terminar con la transacci√≥n. <br><br>  Pero, ¬øqu√© sucede si se nos asigna una determinada cuota en el servicio de intercambio?  ¬øO si tenemos que pagar el acceso?  ¬øRealmente (y deber√≠amos) pagar o gastar nuestra cuota cuando se trata de pruebas unitarias?  Idealmente, las pruebas deben ejecutarse con la mayor frecuencia posible, por lo que deben ser r√°pidas, baratas y confiables.  ¬°Creo que de este p√°rrafo est√° claro por qu√© usar una versi√≥n con HTTP puro es irracional en t√©rminos de prueba! <br><br>  <b>¬°Hay una mejor manera, e implica el uso de interfaces!</b> <br><br>  Con una interfaz, puede fabricar cuidadosamente la implementaci√≥n de <code>StockExchange</code> , que nos permitir√° <code>analyze</code> r√°pida, segura y confiable. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> StubExchange <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(se StubExchange)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ticker </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> se.Price } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_MakeTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">11</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Errorf(<span class="hljs-string"><span class="hljs-string">"expected err == nil received: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !traded { t.Error(<span class="hljs-string"><span class="hljs-string">"expected traded == true"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestAnalyze_DontTrade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { se := StubExchange{Price: <span class="hljs-number"><span class="hljs-number">10</span></span>} maxTradePrice := <span class="hljs-number"><span class="hljs-number">9</span></span> traded, err := analyze(se, <span class="hljs-string"><span class="hljs-string">"TSLA"</span></span>, maxTradePrice) <span class="hljs-comment"><span class="hljs-comment">//  }</span></span></code> </pre> <br>  El trozo del servicio de intercambio se utiliza anteriormente, gracias al cual se lanza la rama de inter√©s para nosotros en el <code>analyze</code> .  Luego, se hacen declaraciones en cada una de las pruebas para asegurarse de que el an√°lisis haga lo que se necesita.  Aunque este es un programa de prueba, mi experiencia sugiere que los componentes / arquitectura, donde las interfaces se usan aproximadamente de esta manera, tambi√©n se prueban de esta manera para garantizar la durabilidad en el c√≥digo de batalla.  Gracias a las interfaces, podemos usar el <code>StockExchange</code> controlado en la memoria, que proporciona pruebas confiables, f√°cilmente configurables, f√°ciles de entender, reproducibles y r√°pidas. <br><br>  <b>Desanclar: configuraci√≥n del llamante</b> <br><br>  Ahora que hemos discutido c√≥mo usar las interfaces para separar a la persona que llama de la persona que llama, y ‚Äã‚Äãc√≥mo hacer m√∫ltiples implementaciones, todav√≠a no hemos tocado un aspecto cr√≠tico.  ¬øC√≥mo configurar y proporcionar una implementaci√≥n espec√≠fica en un momento estrictamente definido?  Puede llamar directamente a la funci√≥n de an√°lisis, pero ¬øqu√© hacer en la configuraci√≥n de producci√≥n? <br><br>  Aqu√≠ es donde la implementaci√≥n de dependencias es √∫til. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ticker = flag.String(<span class="hljs-string"><span class="hljs-string">"ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"stock ticker symbol to trade for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxTradePrice = flag.Float64(<span class="hljs-string"><span class="hljs-string">"maxtradeprice"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"max price to pay for a share of the ticker symbol."</span></span> se := HTTPStockExchange{} analyze(se, *ticker, *maxTradePrice) }</code> </pre> <br>  Al igual que en nuestro caso de prueba, la implementaci√≥n concreta espec√≠fica de StockExchange que se utilizar√° con el <code>analyze</code> configura la persona que llama fuera del an√°lisis.  Luego se pasa (inyecta) para <code>analyze</code> .  Esto garantiza que se analice NADA NADA sobre c√≥mo <code>HTTPStockExchange</code> configura <code>HTTPStockExchange</code> .  Quiz√°s nos gustar√≠a proporcionar el dominio http que vamos a utilizar en forma de un indicador de l√≠nea de comando, y luego analizar no tendr√° que cambiar.  ¬øO qu√© hacer si necesit√°ramos proporcionar alg√∫n tipo de autenticaci√≥n o token para acceder a <code>HTTPStockExchange</code> , que se extraer√° del entorno?  Nuevamente, analizar no debe cambiar. <br><br>  La configuraci√≥n se lleva a cabo a un nivel fuera del <code>analyze</code> , liberando as√≠ al an√°lisis de la necesidad de configurar sus propias dependencias.  Por lo tanto, se logra una estricta separaci√≥n de funciones. <br><br><img src="https://habrastorage.org/webt/nq/jt/_i/nqjt_id9j2-yc7rzozkrldtrwxq.png"><br><br>  <b>Decisiones de estanter√≠a</b> <br><br>  Quiz√°s los ejemplos anteriores son suficientes, pero todav√≠a hay muchas otras ventajas para las interfaces y la inyecci√≥n de dependencias.  Las interfaces permiten diferir decisiones sobre implementaciones espec√≠ficas.  Aunque las decisiones nos obligan a decidir qu√© comportamiento apoyaremos, a√∫n nos permiten tomar decisiones sobre implementaciones espec√≠ficas m√°s adelante.  Supongamos que sab√≠amos que quer√≠amos realizar transacciones automatizadas, pero a√∫n no est√°bamos seguros de qu√© proveedor de cotizaciones usar√≠amos.  Una clase similar de soluciones se trata constantemente cuando se trabaja con almacenes de datos.  ¬øQu√© debe usar nuestro programa: mysql, postgres, redis, sistema de archivos, cassandra?  En definitiva, todo esto son detalles de implementaci√≥n, y las interfaces nos permiten diferir las decisiones finales sobre estos temas.  ¬°Nos permiten desarrollar la l√≥gica de negocios de nuestros programas y cambiar a soluciones tecnol√≥gicas espec√≠ficas en el √∫ltimo momento! <br><br>  A pesar de que esta t√©cnica por s√≠ sola deja muchas posibilidades, algo m√°gico sucede a nivel de planificaci√≥n de proyectos.  Imagine lo que suceder√° si agregamos una dependencia m√°s a la interfaz de intercambio. <br><br><img src="https://habrastorage.org/webt/pb/bf/x-/pbbfx-mcx9oabbpa-tkkeivgtnq.png"><br><br>  Aqu√≠ reconfiguraremos nuestra arquitectura en forma de un gr√°fico ac√≠clico dirigido, de modo que tan pronto como estemos de acuerdo con los detalles de la interfaz de intercambio, podamos COMPETIBLEMENTE continuar trabajando con la tuber√≠a utilizando <code>HTTPStockExchange</code> .  Creamos una situaci√≥n en la que la incorporaci√≥n de una nueva persona al proyecto nos ayuda a avanzar m√°s r√°pido.  Al ajustar nuestra arquitectura de esta manera, vemos mejor d√≥nde, cu√°ndo y durante cu√°nto tiempo podemos involucrar a m√°s personas en el proyecto para acelerar la entrega de todo el proyecto.  Adem√°s, dado que la conexi√≥n entre nuestras interfaces es d√©bil, generalmente es f√°cil involucrarse en el trabajo, comenzando con las interfaces de implementaci√≥n.  ¬°Puede desarrollar, probar y probar <code>HTTPStockExchange</code> completamente independientemente de nuestro programa! <br><br>  El an√°lisis de las dependencias arquitect√≥nicas y la planificaci√≥n de acuerdo con estas dependencias pueden acelerar dr√°sticamente los proyectos.  Usando esta t√©cnica en particular, pude completar muy r√°pidamente proyectos para los cuales se asignaron varios meses. <br><br>  <b>Por delante</b> <br><br>  Ahora deber√≠a ser m√°s claro c√≥mo las interfaces y la implementaci√≥n de dependencias aseguran la durabilidad del programa dise√±ado.  Supongamos que cambiamos nuestro proveedor de cotizaciones, o comenzamos a transmitir cuotas y las guardamos en tiempo real;  Hay tantas otras posibilidades como quieras.  El m√©todo de an√°lisis en su forma actual admitir√° cualquier implementaci√≥n adecuada para la integraci√≥n con la interfaz de <code>StockExchange</code> . <br><br><pre> <code class="go hljs">se.CurrentPrice(ticker)</code> </pre> <br>  Por lo tanto, en muchos casos, puede hacerlo sin cambios.  No en todos, pero en esos casos predecibles que podemos encontrar.  No solo somos inmunes a la necesidad de cambiar el c√≥digo de <code>analyze</code> y verificar dos veces su funcionalidad clave, sino que podemos ofrecer f√°cilmente nuevas implementaciones o cambiar entre proveedores.  ¬°Tambi√©n podemos expandir o actualizar sin problemas las implementaciones espec√≠ficas que ya tenemos sin la necesidad de cambiar o verificar el <code>analyze</code> ! <br><br>  Espero que los ejemplos anteriores demuestren de manera convincente c√≥mo el debilitamiento de la comunicaci√≥n entre entidades en el programa mediante el uso de interfaces reorienta completamente las dependencias y separa a la persona que llama de la persona que llama.  Gracias a este desapego, el programa no depende de una implementaci√≥n espec√≠fica, sino que depende de un <b>comportamiento</b> espec√≠fico.  Este comportamiento puede ser proporcionado por una amplia variedad de implementaciones.  Este principio de dise√±o cr√≠tico tambi√©n se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipificaci√≥n de pato</a> . <br><br>  El concepto de interfaces y la dependencia del comportamiento, y no de la implementaci√≥n, es tan poderoso que considero las interfaces como un lenguaje primitivo, s√≠, esto es bastante radical.  Espero que los ejemplos discutidos anteriormente resulten bastante convincentes, y usted estar√° de acuerdo en que las interfaces y la inyecci√≥n de dependencia se deben usar desde el comienzo del proyecto.  En casi todos los proyectos en los que trabaj√©, se requer√≠a no una, sino al menos dos implementaciones: para producci√≥n y para pruebas. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428075/">https://habr.com/ru/post/es428075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428063/index.html">Los navegadores rechazan la compatibilidad con TLS 1.0 y 1.1</a></li>
<li><a href="../es428065/index.html">Menos no significa peor: skyrmions y paredes de dominio en ferromagnetos</a></li>
<li><a href="../es428067/index.html">AntiFuzzing: ¬øSeguridad a trav√©s de la oscuridad?</a></li>
<li><a href="../es428069/index.html">Optimice el equilibrio de carga en la infraestructura de Veeam Backup & Replication</a></li>
<li><a href="../es428073/index.html">Rust 1.30 Lanzamiento</a></li>
<li><a href="../es428077/index.html">React.js: una gu√≠a para principiantes</a></li>
<li><a href="../es428079/index.html">Aplicaci√≥n de principios S√ìLIDOS para reaccionar al desarrollo de aplicaciones</a></li>
<li><a href="../es428081/index.html">Uso de RxJS en React Development para administrar el estado de la aplicaci√≥n</a></li>
<li><a href="../es428083/index.html">Matriz de influencia de an√°lisis web: el sistema estrat√©gico de Avinash Koshik</a></li>
<li><a href="../es428085/index.html">Frontend contraataca: top 10 (?) HolyJS 2018 Piter informa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>