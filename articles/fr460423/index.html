<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèΩ üë®‚Äçüéì ü§üüèø WAL dans PostgreSQL: 3. Checkpoint üññüèΩ üñïüèΩ üíó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous nous sommes d√©j√† familiaris√©s avec le p√©riph√©rique de cache de tampon , l'un des principaux objets de la m√©moire partag√©e, et nous avons r√©alis√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL dans PostgreSQL: 3. Checkpoint</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/460423/">  Nous nous sommes d√©j√† familiaris√©s avec le p√©riph√©rique de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cache de tampon</a> , l'un des principaux objets de la m√©moire partag√©e, et nous avons r√©alis√© que pour r√©cup√©rer d'une d√©faillance lorsque le contenu de la RAM √©tait perdu, vous devez conserver un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journal de pr√©-enregistrement</a> . <br><br>  Le probl√®me non r√©solu que nous avons arr√™t√© la derni√®re fois est que l'on ne sait pas √† quel moment vous pouvez commencer √† lire les journaux pendant la r√©cup√©ration.  Commencer depuis le d√©but, comme le conseillait le roi d' <em>Alice</em> , ne fonctionnera pas: il est impossible de stocker toutes les entr√©es de journal depuis le d√©but du serveur - c'est potentiellement une quantit√© √©norme et le m√™me temps de r√©cup√©ration √©norme.  Nous avons besoin d'un point qui progresse progressivement √† partir duquel nous pouvons commencer la r√©cup√©ration (et, par cons√©quent, nous pouvons supprimer en toute s√©curit√© toutes les entr√©es de journal pr√©c√©dentes).  C'est le <em>point de contr√¥le</em> qui sera discut√© aujourd'hui. <br><br><h1>  Point de contr√¥le </h1><br>  Quelle propri√©t√© doit avoir un point de contr√¥le?  Nous devons √™tre s√ªrs que toutes les entr√©es de journal, √† partir du point de contr√¥le, seront appliqu√©es aux pages √©crites sur le disque.  Si ce n'√©tait pas le cas, lors de la restauration, nous pouvions lire sur le disque une version trop ancienne de la page et lui appliquer une entr√©e de journal, et ainsi endommager d√©finitivement les donn√©es. <br><a name="habracut"></a><br>  Comment obtenir un point d'arr√™t?  L'option la plus simple consiste √† suspendre p√©riodiquement le syst√®me et √† vider toutes les pages sales du tampon et des autres caches sur le disque.  (Notez que les pages sont uniquement √©crites, mais pas √©ject√©es du cache.) De tels points satisferont la condition, mais, bien s√ªr, personne ne voudra travailler avec un syst√®me qui se bloque constamment pendant une dur√©e ind√©finie, mais tr√®s significative. <br><br>  Par cons√©quent, dans la pratique, tout est un peu plus compliqu√©: un point de contr√¥le √† partir d'un point se transforme en segment.  Nous <em>commen√ßons d'abord le</em> point d'arr√™t.  Apr√®s cela, sans interrompre le travail et, si possible, sans cr√©er de charges de pointe, nous vidons lentement les tampons sales sur le disque. <br><br><img src="https://habrastorage.org/webt/n0/ch/6f/n0ch6fdrfxkylmuqjdar7idfxsw.png"><br><br>  Lorsque tous les tampons qui √©taient sales <em>au d√©but du</em> point de contr√¥le ont √©t√© √©crits, le point de contr√¥le est consid√©r√© comme <em>termin√©</em> .  Maintenant (mais pas plus t√¥t), nous pouvons utiliser le point de d√©part comme point √† partir duquel vous pouvez d√©marrer la r√©cup√©ration.  Et les √©critures de journal dont nous n'avons plus besoin jusqu'ici. <br><br><img src="https://habrastorage.org/webt/q4/th/83/q4th83seql63dkrgfmg7esu3zh8.png"><br><br>  Le point de contr√¥le est g√©r√© par un processus sp√©cial de pointeur de fond. <br><br>  La dur√©e des tampons sales est d√©termin√©e par la valeur du param√®tre <em>checkpoint_completion_target</em> .  Il montre combien de temps entre deux points de contr√¥le adjacents l'enregistrement aura lieu.  La valeur par d√©faut est 0,5 (comme dans les figures ci-dessus), c'est-√†-dire que l'enregistrement prend la moiti√© du temps entre les points de contr√¥le.  En r√®gle g√©n√©rale, la valeur est augment√©e jusqu'√† 1,0 pour une plus grande uniformit√©. <br><br>  Examinons plus en d√©tail ce qui se passe lorsqu'un point de contr√¥le est ex√©cut√©. <br><br>  Le processus de point de contr√¥le vide d'abord les tampons d'√©tat des transactions (XACT) sur le disque.  Puisqu'ils sont peu nombreux (128 au total), ils sont enregistr√©s imm√©diatement. <br><br>  Ensuite, le travail principal commence - √©crire des pages sales √† partir du cache de tampon.  Comme nous l'avons d√©j√† dit, il est impossible de r√©initialiser toutes les pages √† la fois, car la taille du cache de tampon peut √™tre importante.  Par cons√©quent, tout d'abord, toutes les pages actuellement sales sont marqu√©es dans le cache de tampon dans les en-t√™tes avec un indicateur sp√©cial. <br><br><img src="https://habrastorage.org/webt/_4/ym/eq/_4ymeqozl8o23kwq6su9ntvjujk.png"><br><br>  Et puis le processus de point de contr√¥le passe progressivement par tous les tampons et vide ceux marqu√©s sur le disque.  Rappelez-vous que les pages ne sont pas √©ject√©es du cache, mais uniquement √©crites sur le disque, vous n'avez donc pas besoin de faire attention au nombre d'appels au tampon ou √† sa correction. <br><br>  Les tampons √©tiquet√©s peuvent √©galement √™tre √©crits par les processus serveur - selon qui acc√®de au tampon en premier.  Dans tous les cas, le drapeau pr√©c√©demment d√©fini est supprim√© lors de l'enregistrement, donc (aux fins du point de contr√¥le) le tampon ne sera √©crit qu'une seule fois. <br><br>  Naturellement, lors de l'ex√©cution du point de contr√¥le, les pages continuent de changer dans le cache tampon.  Mais les nouveaux tampons sales ne sont pas marqu√©s et le processus de point de contr√¥le ne doit pas les √©crire. <br><br><img src="https://habrastorage.org/webt/fg/uo/vm/fguovmm8yzy0jb4jwisgg10nmm8.png"><br><br>  √Ä la fin de son travail, le processus cr√©e une entr√©e de journal pour la fin du point de contr√¥le.  Cet enregistrement contient le LSN du d√©but des travaux du point de contr√¥le.  Comme le point de contr√¥le n'√©crit rien dans le journal au d√©but de son travail, ce LSN peut contenir n'importe quel enregistrement de journal. <br><br>  De plus, le fichier $ PGDATA / global / pg_control met √† jour l'indication du dernier point de contr√¥le <em>pass√©</em> .  Avant la fin du point de contr√¥le, pg_control pointe vers le point de contr√¥le pr√©c√©dent. <br><br><img src="https://habrastorage.org/webt/w0/cy/gi/w0cygixp3k4k3qscwfa2nlapqna.png"><br><br>  Pour regarder le travail du point de contr√¥le, cr√©ez une table - ses pages iront dans le cache tampon et seront sales: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(n); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre> <pre> <code class="plaintext hljs"> count ------- 78 (1 row)</code> </pre><br>  Rappelez-vous la position actuelle dans le journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A048 (1 row)</code> </pre><br>  Maintenant, nous allons ex√©cuter le point de contr√¥le manuellement et nous assurer qu'il n'y a pas de pages sales dans le cache (comme nous l'avons dit, de nouvelles pages sales peuvent appara√Ætre, mais dans notre cas, il n'y a eu aucun changement dans le processus d'ex√©cution du point de contr√¥le): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> isdirty;</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Voyons comment le point de contr√¥le a √©t√© refl√©t√© dans le journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A0E4 (1 row)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A048 -e 0/3514A0E4</code> </pre><pre> <code class="plaintext hljs">rmgr: Standby len (rec/tot): 50/ 50, tx: 0, lsn: 0/3514A048, prev 0/35149CEC, desc: RUNNING_XACTS nextXid 101105 latestCompletedXid 101104 oldestRunningXid 101105</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A07C, prev 0/3514A048, desc: CHECKPOINT_ONLINE redo 0/3514A048; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 101105; online</code> </pre><br>  Ici, nous voyons deux entr√©es.  Le dernier est un enregistrement du passage du point de contr√¥le (CHECKPOINT_ONLINE).  Le LSN du d√©but du point de contr√¥le est indiqu√© apr√®s le mot refaire, et cette position correspond √† l'entr√©e de journal, qui √©tait la derni√®re au d√©but du point de contr√¥le. <br><br>  On retrouvera les m√™mes informations dans le fichier de contr√¥le: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | egrep 'Latest.*location'</code> </pre><pre> <code class="plaintext hljs">Latest checkpoint location: 0/3514A07C Latest checkpoint's REDO location: 0/3514A048</code> </pre><br><h1>  R√©cup√©ration </h1><br>  Nous sommes maintenant pr√™ts √† clarifier l'algorithme de r√©cup√©ration d√©crit dans l'article pr√©c√©dent. <br><br>  Si le serveur tombe en panne, la prochaine fois qu'il d√©marre, le processus de d√©marrage le d√©tecte en consultant le fichier pg_control et en voyant un √©tat autre que ¬´arr√™t√©¬ª.  Dans ce cas, une r√©cup√©ration automatique est effectu√©e. <br><br>  Tout d'abord, le processus de r√©cup√©ration lira du m√™me pg_control la position du d√©but du point de contr√¥le.  (Pour compl√©ter l'image, nous notons que si le fichier backup_label est pr√©sent, alors l'enregistrement du point de contr√¥le est lu √† partir de celui-ci - cela est n√©cessaire pour la restauration √† partir de sauvegardes, mais c'est un sujet pour un cycle s√©par√©.) <br><br>  Ensuite, il lira le magazine, √† partir de la position trouv√©e, en appliquant s√©quentiellement des entr√©es de journal aux pages (si n√©cessaire, comme nous l'avons vu la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">derni√®re fois</a> ). <br><br>  En conclusion, toutes les tables non journalis√©es sont √©cras√©es √† l'aide d'images dans les fichiers init. <br><br>  √Ä ce stade, le processus de d√©marrage se termine et le processus de pointeur de v√©rification ex√©cute imm√©diatement un point de contr√¥le pour corriger l'√©tat restaur√© sur le disque. <br><br>  Vous pouvez simuler un √©chec en arr√™tant de force le serveur en mode imm√©diat. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop -m immediate --skip-systemctl-redirect</code> </pre><br>  (La cl√© <code>--skip-systemctl-redirect</code> est n√©cessaire ici car PostgreSQL est install√© dans Ubuntu √† partir du package. Elle est contr√¥l√©e par la commande pg_ctlcluster, qui appelle en fait systemctl, et elle appelle d√©j√† pg_ctl. Avec tous ces wrappers, le nom du mode est perdu en cours de route, et le <code>--skip-systemctl-redirect</code> vous permet de vous passer de systemctl et d'enregistrer des informations importantes.) <br><br>  V√©rifiez l'√©tat du cluster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Au d√©marrage, PostgreSQL comprend qu'un √©chec s'est produit et qu'une r√©cup√©ration est n√©cessaire. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><pre> <code class="plaintext hljs">postgres$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:49.441 MSK [8865] LOG: database system was interrupted; last known up at 2019-07-17 15:27:48 MSK 2019-07-17 15:27:49.801 MSK [8865] LOG: database system was not properly shut down; automatic recovery in progress 2019-07-17 15:27:49.804 MSK [8865] LOG: redo starts at 0/3514A048 2019-07-17 15:27:49.804 MSK [8865] LOG: invalid record length at 0/3514A0E4: wanted 24, got 0 2019-07-17 15:27:49.804 MSK [8865] LOG: redo done at 0/3514A07C 2019-07-17 15:27:49.824 MSK [8864] LOG: database system is ready to accept connections 2019-07-17 15:27:50.409 MSK [8872] [unknown]@[unknown] LOG: incomplete startup packet</code> </pre><br>  Le besoin de r√©cup√©ration est not√© dans le journal des messages: le <em>syst√®me de base de donn√©es n'a pas √©t√© correctement arr√™t√©;</em>  <em>r√©cup√©ration automatique en cours</em> .  Ensuite, les entr√©es de journal commencent √† jouer √† partir de la position marqu√©e ¬´recommencer √†¬ª et continuent jusqu'√† ce que les entr√©es de journal suivantes puissent √™tre r√©cup√©r√©es.  Ceci termine la r√©cup√©ration dans la position ¬´refaire √†¬ª et le SGBD commence √† travailler avec les clients (le <em>syst√®me de base de donn√©es est pr√™t √† accepter les connexions</em> ). <br><br>  Et que se passe-t-il lors d'un arr√™t normal du serveur?  Pour vider les pages sales sur le disque, PostgreSQL d√©connecte tous les clients, puis ex√©cute le point de contr√¥le final. <br><br>  Rappelez-vous la position actuelle dans le journal: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/3514A14C (1 row)</code> </pre><br>  Arr√™tez maintenant doucement le serveur: <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main stop</code> </pre><br>  V√©rifiez l'√©tat du cluster: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: shut down</code> </pre><br>  Et dans le journal, nous trouvons le seul enregistrement sur le point de contr√¥le final (CHECKPOINT_SHUTDOWN): <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/3514A14C</code> </pre><pre> <code class="plaintext hljs">rmgr: XLOG len (rec/tot): 102/ 102, tx: 0, lsn: 0/3514A14C, prev 0/3514A0E4, desc: CHECKPOINT_SHUTDOWN redo 0/3514A14C; tli 1; prev tli 1; fpw true; xid 0:101105; oid 74081; multi 1; offset 0; oldest xid 561 in DB 1; oldest multi 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest running xid 0; shutdown</code> </pre><pre> <code class="plaintext hljs">pg_waldump: FATAL: error in WAL record at 0/3514A14C: invalid record length at 0/3514A1B4: wanted 24, got 0</code> </pre><br>  (Dans un terrible message fatal, pg_waldump veut juste dire qu'il a lu jusqu'√† la fin du magazine.) <br><br>  Ex√©cutez √† nouveau l'instance. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main start</code> </pre><br><h1>  Enregistrement en arri√®re-plan </h1><br>  Comme nous l'avons d√©couvert, le point de contr√¥le est l'un des processus qui √©crit les pages sales du cache tampon sur le disque.  Mais pas le seul. <br><br>  Si le backend doit pousser la page hors du tampon et que la page est sale, il devra l'√©crire sur le disque de son propre chef.  C'est une mauvaise situation, ce qui conduit √† des attentes - c'est beaucoup mieux lorsque l'enregistrement se produit de mani√®re asynchrone en arri√®re-plan. <br><br>  Par cons√©quent, en plus du <em>processus de</em> point de contr√¥le <em>,</em> il existe √©galement <em>un processus d'enregistrement en arri√®re-plan</em> (√©crivain en arri√®re-plan, bgwriter ou simplement √©crivain).  Ce processus utilise le m√™me algorithme de recherche de tampon que le m√©canisme de pr√©emption.  Il existe essentiellement deux diff√©rences. <br><br><ol><li>  Il n'utilise pas de pointeur sur la "prochaine victime", mais le sien.  Il peut √™tre en avance sur le pointeur de la ¬´victime¬ª, mais ne tra√Æne jamais derri√®re lui. </li><li>  Lors de la travers√©e de tampons, le compteur de coups ne diminue pas. </li></ol><br>  Des tampons sont √©crits simultan√©ment: <br><br><ul><li>  contenir des donn√©es modifi√©es (sales), </li><li>  non fixe (nombre de broches = 0), </li><li>  avoir z√©ro acc√®s (nombre d'utilisation = 0). </li></ul><br>  Ainsi, le processus d'enregistrement en arri√®re-plan, pour ainsi dire, pr√©c√®de l'√©viction et trouve les tampons qui seront probablement √©vinc√©s bient√¥t.  Id√©alement, pour cette raison, les processus de service devraient trouver que les tampons qu'ils s√©lectionnent peuvent √™tre utilis√©s sans s'arr√™ter pour √©crire. <br><br><h1>  Personnalisation </h1><br>  <em>Le processus de point de contr√¥le est</em> g√©n√©ralement configur√© pour les raisons suivantes. <br><br>  Vous devez d'abord d√©cider de la quantit√© de fichiers journaux que nous pouvons nous permettre d'√©conomiser (et du temps de r√©cup√©ration qui nous convient).  Plus c'est grand, mieux c'est, mais pour des raisons √©videntes, cette valeur sera limit√©e. <br><br>  Ensuite, nous pouvons calculer combien de temps ce volume sera g√©n√©r√© sous une charge normale.  Nous avons d√©j√† r√©fl√©chi √† la fa√ßon de proc√©der (nous devons nous souvenir des positions dans le journal et soustraire les uns des autres). <br><br>  Ce temps sera notre intervalle habituel entre les points de contr√¥le.  Nous l'√©crivons dans le param√®tre <em>checkpoint_timeout</em> .  La valeur par d√©faut de 5 minutes est √©videmment trop petite, g√©n√©ralement le temps est augment√©, disons, √† une demi-heure.  Je le r√©p√®te: moins vous pouvez vous permettre des jalons, mieux c'est - cela r√©duit les frais g√©n√©raux. <br><br>  Cependant, il est possible (et m√™me probable) que parfois la charge soit plus √©lev√©e que la normale et que trop d'entr√©es de journal soient g√©n√©r√©es dans le temps sp√©cifi√© dans le param√®tre.  Dans ce cas, je voudrais effectuer le point de contr√¥le plus souvent.  Pour ce faire, dans le param√®tre <em>max_wal_size</em> , nous <em>sp√©cifions</em> le montant qui est valide au sein du m√™me point de contr√¥le.  Si le volume r√©el est obtenu davantage, le serveur lance un point de contr√¥le non planifi√©. <br><br>  Ainsi, la plupart des points de contr√¥le se produisent sur une planification: une fois par unit√© de temps <em>checkpoint_timeout</em> .  Mais avec une charge accrue, le point de contr√¥le est appel√© plus souvent lorsque le volume <em>max_wal_size</em> est <em>atteint</em> . <br><br>  Il est important de comprendre que le param√®tre <em>max_wal_size</em> ne d√©termine pas du tout la quantit√© maximale que les fichiers journaux sur le disque peuvent occuper. <br><br><ul><li>  Pour r√©cup√©rer apr√®s une panne, vous devez stocker les fichiers √† partir du moment o√π le dernier point de contr√¥le a √©t√© franchi, ainsi que les fichiers qui se sont accumul√©s pendant le fonctionnement du point de contr√¥le actuel.  Par cons√©quent, le volume total peut √™tre approximativement estim√© √† <br>  (1 + <em>checkpoint_completion_target</em> ) √ó <em>max_wal_size</em> . </li><li>  Avant la version 11, PostgreSQL stockait √©galement des fichiers pour le point de contr√¥le de deux ans, donc jusqu'√† la version 10 dans la formule ci-dessus, vous devez d√©finir 2 au lieu de 1. </li><li>  Le param√®tre <em>max_wal_size</em> n'est qu'un souhait, mais pas une limite <em>stricte</em> .  Cela peut s'av√©rer plus. </li><li>  Le serveur n'a pas le droit d'effacer les fichiers journaux qui n'ont pas encore √©t√© transf√©r√©s via les emplacements de r√©plication et qui n'ont pas encore √©t√© archiv√©s lors de l'archivage continu.  Si cette fonctionnalit√© est utilis√©e, une surveillance constante est n√©cessaire, car il est facile de d√©border la m√©moire du serveur. </li></ul><br>  Pour compl√©ter l'image, vous pouvez d√©finir non seulement le volume maximum, mais aussi le minimum: param√®tre <em>min_wal_size</em> .  La signification de ce param√®tre est que le serveur ne supprime pas les fichiers lorsqu'ils tiennent dans le volume dans <em>min_wal_size</em> , mais les renomme simplement et les utilise √† nouveau.  Cela vous permet d'√©conomiser un peu en cr√©ant et supprimant constamment des fichiers. <br><br>  <em>Il</em> est judicieux de configurer le <em>processus d'enregistrement en arri√®re-plan une</em> fois le point de contr√¥le configur√©.  Ensemble, ces processus doivent avoir le temps d'√©crire des tampons sales avant d'√™tre utilis√©s par les processus de maintenance. <br><br>  Le processus d'enregistrement en arri√®re-plan s'ex√©cute en cycles d'au plus <em>bgwriter_lru_maxpages</em> pages, s'endormant entre les cycles sur <em>bgwriter_delay</em> . <br><br>  Le nombre de pages qui seront enregistr√©es dans un cycle de travail est d√©termin√© par le nombre moyen de tampons qui ont √©t√© demand√©s par les processus de maintenance de la derni√®re ex√©cution (en utilisant une moyenne mobile pour aplanir les in√©galit√©s entre les ex√©cutions, mais ne d√©pend pas d'une longue histoire).  Le nombre calcul√© de tampons est multipli√© par le coefficient <em>bgwriter_lru_multiplier</em> (mais en aucun cas il ne d√©passera <em>bgwriter_lru_maxpages</em> ). <br><br>  Valeurs par d√©faut: <em>bgwriter_delay</em> = 200 <em>ms</em> (probablement trop, il <em>fuit</em> beaucoup d'eau en 1/5 de seconde), <em>bgwriter_lru_maxpages</em> = 100, <em>bgwriter_lru_multiplier</em> = 2.0 (nous essayons de r√©pondre √† la demande avant la date pr√©vue). <br><br>  Si le processus ne d√©tecte pas du tout les tampons sales (c'est-√†-dire qu'il ne se passe rien dans le syst√®me), il "hiberne", d'o√π il est d√©duit que le processus serveur acc√®de au tampon.  Apr√®s cela, le processus se r√©veille et fonctionne √† nouveau de la mani√®re habituelle. <br><br><h1>  Suivi </h1><br>  Les param√®tres d'enregistrement du point de contr√¥le et de l'arri√®re-plan peuvent et doivent √™tre ajust√©s, en recevant les commentaires de la surveillance. <br><br>  Le param√®tre <em>checkpoint_warning</em> affiche un avertissement si les points de contr√¥le provoqu√©s par des d√©passements de taille du fichier journal s'ex√©cutent trop souvent.  Sa valeur par d√©faut est de 30 secondes et elle doit √™tre align√©e sur la valeur de <em>checkpoint_timeout</em> . <br><br>  Le param√®tre <em>log_checkpoints</em> (d√©sactiv√© par d√©faut) permet de recevoir des informations sur les points de contr√¥le ex√©cut√©s dans le journal des messages du serveur.  Allumez-le. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_checkpoints = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Maintenant, changez quelque chose dans les donn√©es et ex√©cutez le point de contr√¥le. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> chkpt <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> n = n + <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CHECKPOINT</span></span>;</code> </pre><br>  Dans le journal des messages, nous verrons quelque chose comme ceci: <br><br><pre> <code class="plaintext hljs">postgres$ tail -n 2 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-07-17 15:27:55.248 MSK [8962] LOG: checkpoint starting: immediate force wait 2019-07-17 15:27:55.274 MSK [8962] LOG: checkpoint complete: wrote 79 buffers (0.5%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.013 s, total=0.025 s; sync files=2, longest=0.011 s, average=0.006 s; distance=1645 kB, estimate=1645 kB</code> </pre><br>  Vous pouvez voir ici combien de tampons ont √©t√© √©crits, comment la composition des fichiers journaux a chang√© apr√®s le point de contr√¥le, combien de temps le point de contr√¥le a pris et la distance (en octets) entre les points de contr√¥le voisins. <br><br>  Mais, probablement, les informations les plus utiles sont les statistiques du travail des processus d'enregistrement de point de contr√¥le et d'arri√®re-plan dans la vue pg_stat_bgwriter.  La vue est une pour deux, car une fois que les deux t√¢ches ont √©t√© effectu√©es par un seul processus;  puis leurs fonctions ont √©t√© divis√©es, et la vue est rest√©e. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_bgwriter \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------+------------------------------ checkpoints_timed | 0 checkpoints_req | 1 checkpoint_write_time | 1 checkpoint_sync_time | 13 buffers_checkpoint | 79 buffers_clean | 0 maxwritten_clean | 0 buffers_backend | 42 buffers_backend_fsync | 0 buffers_alloc | 363 stats_reset | 2019-07-17 15:27:49.826414+03</code> </pre><br>  Ici, entre autres, nous voyons le nombre de points de contr√¥le termin√©s: <br><br><ul><li>  checkpoints_timed - selon le calendrier (en atteignant checkpoint_timeout), </li><li>  checkpoints_req - √† la demande (y compris en atteignant max_wal_size). </li></ul><br>  La grande valeur de checkpoint_req (par rapport √† checkpoints_timed) indique que les points de contr√¥le se produisent plus souvent que pr√©vu. <br><br>  Informations importantes sur le nombre de pages enregistr√©es: <br><br><ul><li>  buffers_checkpoint - processus de point de contr√¥le, </li><li>  buffers_backend - en servant des processus, </li><li>  buffers_clean - processus d'enregistrement en arri√®re-plan. </li></ul><br>  Sur un syst√®me bien r√©gl√©, la valeur de buffers_backend doit √™tre sensiblement inf√©rieure √† la somme de buffers_checkpoint et buffers_clean. <br><br>  De plus, maxwritten_clean est utile pour configurer l'enregistrement en arri√®re-plan - ce nombre indique combien de fois le processus d'enregistrement en arri√®re-plan a cess√© de fonctionner en raison du d√©passement de <em>bgwriter_lru_maxpages</em> . <br><br>  Vous pouvez r√©initialiser les statistiques accumul√©es √† l'aide de l'appel suivant: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_stat_reset_shared(<span class="hljs-string"><span class="hljs-string">'bgwriter'</span></span>);</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460423/">https://habr.com/ru/post/fr460423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460411/index.html">Mad Converter GIF'ok en autocollants anim√©s pour Telegram</a></li>
<li><a href="../fr460413/index.html">7 sites et applications utiles pour apprendre l'anglais</a></li>
<li><a href="../fr460415/index.html">Apple Watch 4 (44 mm, 2019) vs Pebble Steel Classic (2014)</a></li>
<li><a href="../fr460419/index.html">R√©cup√©ration de chaleur des fum√©es: respectueuse de l'environnement</a></li>
<li><a href="../fr460421/index.html">Commutateur optique TP-Link T2600G-28SQ pour les fournisseurs de services: un examen d√©taill√©</a></li>
<li><a href="../fr460425/index.html">Rhume infernal, l√©vitation et plasma: pass√©, pr√©sent et futur de la supraconductivit√©</a></li>
<li><a href="../fr460431/index.html">Cr√©ation d'un pipeline de tests automatis√©s sur Azure DevOps</a></li>
<li><a href="../fr460433/index.html">Risques et menaces sur l'Internet des objets</a></li>
<li><a href="../fr460435/index.html">Petty Little Joy # 8: Petits plaisirs pour travailler avec la base de donn√©es</a></li>
<li><a href="../fr460437/index.html">Comment nous mettons un v√©lo de support technique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>