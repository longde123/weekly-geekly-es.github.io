<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üöµüèæ üî∂ Node.js-Handbuch, Teil 2: JavaScript, V8, einige Entwicklungstricks üòá ‚ö†Ô∏è üë©üèª‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit der Ver√∂ffentlichung des ersten Teils der √úbersetzung dieses Handbuchs auf Node.js haben wir uns entschlossen, die Meinung des Publikums dar√ºber h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js-Handbuch, Teil 2: JavaScript, V8, einige Entwicklungstricks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423153/">  Mit der Ver√∂ffentlichung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teils der</a> √úbersetzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses</a> Handbuchs auf Node.js haben wir uns entschlossen, die Meinung des Publikums dar√ºber herauszufinden, ob wir weiter an dem Projekt arbeiten sollten, und eine kleine Umfrage durchgef√ºhrt.  Wie sich herausstellte, unterst√ºtzten ungef√§hr 94% der W√§hler unsere Initiative.  Treffen Sie also den zweiten Teil des Node.js.-Tutorials <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br>  Heute werden wir dar√ºber sprechen, welche Art von JS-Wissen Sie ben√∂tigen, um Anwendungen f√ºr die Node.js-Plattform effizient zu entwickeln, die Unterschiede zwischen browser- und serverseitigem JavaScript-Code zu diskutieren und √ºber JS-Engines und einige Techniken der Node.js-Entwicklung zu sprechen. <br><br><div class="spoiler">  <b class="spoiler_title">[Wir empfehlen Ihnen zu lesen] Andere Teile des Zyklus</b> <div class="spoiler_text">  Teil 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Allgemeine Informationen und erste Schritte</a> <br>  Teil 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript, V8, einige Entwicklungstricks</a> <br>  Teil 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hosting, REPL, Arbeit mit der Konsole, Module</a> <br>  Teil 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateien npm, package.json und package-lock.json</a> <br>  Teil 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">npm und npx</a> <br>  Teil 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisschleife, Aufrufstapel, Timer</a> <br>  Teil 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Programmierung</a> <br>  Teil 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 8: HTTP- und WebSocket-Protokolle</a> <br>  Teil 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 9: Arbeiten mit dem Dateisystem</a> <br>  Teil 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node.js-Handbuch, Teil 10: Standardmodule, Streams, Datenbanken, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vollst√§ndiges PDF des Node.js-Handbuchs</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Welche JS-Kenntnisse ben√∂tige ich f√ºr die Entwicklung von Node.j?</font> </h2><br>  Angenommen, Sie haben gerade mit dem Programmieren begonnen.  Wie tief m√ºssen Sie JavaScript lernen, um Node.js erfolgreich zu beherrschen?  F√ºr einen Anf√§nger ist es schwierig, ein solches Niveau zu erreichen, wenn er gen√ºgend Vertrauen in seine beruflichen F√§higkeiten gewinnt.  Wenn Sie Programmieren studieren, haben Sie m√∂glicherweise das Gef√ºhl, dass Sie nicht genau verstehen, wo Browser-JavaScript endet und die Entwicklung f√ºr Node.js. beginnt. <br><br>  Wenn Sie am Anfang des Weges eines JavaScript-Programmierers stehen, w√ºrde ich Ihnen raten, bevor Sie f√ºr Node.js schreiben, die folgenden Sprachkonzepte gut zu beherrschen: <br><br><ul><li>  Lexikalische Konstruktionen. </li><li>  Ausdr√ºcke. </li><li>  Typen. </li><li>  Variablen </li><li>  Funktionen </li><li>  Dieses Schl√ºsselwort. </li><li>  Pfeilfunktionen </li><li>  Zyklen </li><li>  Geltungsbereich. </li><li>  Arrays </li><li>  Vorlagenzeichenfolgen. </li><li>  Wenden Sie ein Semikolon an. </li><li>  Arbeiten Sie im strengen Modus. </li></ul><br>  Tats√§chlich geht diese Liste weiter, aber wenn Sie alles beherrschen, bedeutet dies, dass Sie eine gute Grundlage f√ºr eine produktive Client- und Serverentwicklung in JavaScript schaffen. <br>  Die folgenden Sprachkonzepte sind auch sehr wichtig, um die Ideen der asynchronen Programmierung zu verstehen, die einer der Grundbestandteile von Node.js sind.  Insbesondere sprechen wir √ºber Folgendes: <br><br><ul><li>  Asynchrone Programmier- und R√ºckruffunktionen. </li><li>  Timer. </li><li>  Versprechen. </li><li>  Async / warte Konstrukt. </li><li>  Kurzschl√ºsse. </li><li>  Zyklus der Ereignisse. </li></ul><br>  Es gibt viele JavaScript-Materialien, mit denen Anf√§nger die Sprache lernen k√∂nnen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist</a> zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein</a> Schulungskurs f√ºr den Autor dieses Handbuchs. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> sehr n√ºtzlicher Abschnitt von MDN. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist ein</a> Tutorial f√ºr javascript.ru  Grundlegende JavaScript-Mechanismen finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freecodecamp.com</a> . <br><br>  Oben haben wir dar√ºber gesprochen, wie Anf√§nger √ºber die Frage besorgt sein k√∂nnen, wo die Grenze zwischen Server- und Client-JavaScript-Entwicklung liegt.  Reden wir dar√ºber. <br><br><h2>  <font color="#3AC1EF">Unterschiede zwischen Node.js Plattform und Browser</font> </h2><br>  Wie unterscheidet sich die JS-Entwicklung f√ºr Node.js von der Browserprogrammierung?  Die √Ñhnlichkeit zwischen diesen Umgebungen besteht darin, dass dort und dort dieselbe Sprache verwendet wird.  Die Entwicklung von Anwendungen, die f√ºr die Ausf√ºhrung in einem Browser entwickelt wurden, unterscheidet sich jedoch stark von der Entwicklung von Serveranwendungen.  Trotz der Verwendung derselben Sprache gibt es einige wesentliche Unterschiede, die diese beiden Entwicklungstypen zu v√∂llig unterschiedlichen Aktivit√§ten machen. <br><br>  Es sollte beachtet werden, dass jemand, der fr√ºher Front-End-Lernen zum Starten von Node.js durchgef√ºhrt hat, eine sehr ernsthafte Gelegenheit hat, schnell alles zu beherrschen, was notwendig ist, da er in einer Sprache schreibt, die er bereits kennt.  Wenn die Notwendigkeit, eine neue Umgebung zu lernen, hinzugef√ºgt wird und eine neue Sprache gelernt werden muss, ist die Aufgabe viel komplizierter. <br>  Der Hauptunterschied zwischen Client und Server besteht also in der Umgebung, f√ºr die Sie programmieren m√ºssen, in den √ñkosystemen dieser Umgebungen. <br><br>  Im Browser entf√§llt der Gro√üteil der Arbeit auf verschiedene Vorg√§nge mit Webdokumenten √ºber das DOM sowie auf die Verwendung anderer Webplattform-APIs, z. B. Mechanismen f√ºr die Arbeit mit Cookies.  Node.js hat nat√ºrlich all das.  Es gibt kein <code>document</code> , kein <code>window</code> sowie andere vom Browser bereitgestellte Objekte. <br><br>  Der Browser verf√ºgt wiederum nicht √ºber die Softwaremechanismen, die in der Node.js-Umgebung verf√ºgbar sind und in Form von Modulen vorliegen, die mit der Anwendung verbunden werden k√∂nnen.  Dies ist beispielsweise eine API f√ºr den Zugriff auf das Dateisystem. <br><br>  Ein weiterer Unterschied zwischen der Client- und Serverentwicklung in JS besteht darin, dass der Entwickler bei der Arbeit in einer Node.js-Umgebung die volle Kontrolle √ºber die Umgebung hat.  Sofern Sie keine Open Source-Anwendung entwickeln, die √ºberall ausgef√ºhrt werden kann, wissen Sie beispielsweise genau, an welcher Version von Node.js Ihr Projekt arbeiten wird.  Dies ist sehr praktisch im Vergleich zu der Client-Umgebung, in der Ihr Code im Browser des Benutzers funktionieren muss.  Dar√ºber hinaus bedeutet dies, dass Sie ohne Angst vor Problemen die neuesten Funktionen der Sprache verwenden k√∂nnen. <br><br>  Da sich JavaScript extrem schnell entwickelt, haben Browser einfach nicht genug Zeit, um alle Innovationen schnell umzusetzen.  Dar√ºber hinaus arbeiten nicht alle Benutzer mit den neuesten Browserversionen.  Entwickler, die etwas Neues in ihren Programmen verwenden m√∂chten, m√ºssen dies ber√ºcksichtigen und auf die Kompatibilit√§t ihrer Anwendungen mit den von ihnen verwendeten Browsern achten, was dazu f√ºhren kann, dass die modernen JavaScript-Funktionen nicht mehr verwendet werden m√ºssen.  Sie k√∂nnen den Babel-Transporter nat√ºrlich verwenden, um den Code in ein Format zu konvertieren, das mit dem EcmaScript 5-Standard kompatibel ist, der von allen Browsern unterst√ºtzt wird. Dies wird jedoch bei der Arbeit mit Node.js nicht ben√∂tigt. <br><br>  Ein weiterer Unterschied zwischen Node.js und Browsern besteht darin, dass Node.js das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CommonJS-</a> Modulsystem verwendet, w√§hrend Sie in Browsern den Beginn der Implementierung des ES-Modulstandards sehen k√∂nnen.  In der Praxis bedeutet dies, dass derzeit in Node.js das Konstrukt <code>require()</code> verwendet wird, um externen Code zu verbinden und in den Browsercode zu <code>import</code> . <br><br><h2>  <font color="#3AC1EF">V8 und andere JavaScript-Engines</font> </h2><br>  V8 ist der Name der JavaScript-Engine, die im Google Chrome-Browser verwendet wird.  Er ist f√ºr die Ausf√ºhrung des JavaScript-Codes verantwortlich, der bei der Arbeit im Internet in den Browser gelangt.  V8 bietet eine Laufzeit f√ºr JavaScript.  DOM und andere Webplattform-APIs werden vom Browser bereitgestellt. <br><br>  Die JS-Engine ist unabh√§ngig von dem Browser, in dem sie ausgef√ºhrt wird.  Diese Tatsache hat die Entstehung und Entwicklung der Node.js.-Plattform erm√∂glicht.  V8 wurde 2009 als Motor f√ºr Node.js ausgew√§hlt.  Aufgrund des explosionsartigen Anstiegs der Popularit√§t stellte sich heraus, dass Node.js V8 eine Engine ist, die jetzt f√ºr die Ausf√ºhrung einer gro√üen Menge serverseitigen JS-Codes verantwortlich ist. <br><br>  Das √ñkosystem von Node.js ist riesig.  Dank dessen wird der V8 in Projekten wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Electron</a> auch zur Entwicklung von Desktop-Anwendungen verwendet. <br><br>  Es ist zu beachten, dass es neben V8 noch andere Motoren gibt: <br><br><ul><li>  Firefox verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpiderMonkey-</a> Engine. </li><li>  Safari verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScriptCore</a> (auch Nitro genannt). </li><li>  Edge verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chakra-</a> Engine. </li></ul><br>  Die Liste der JS-Engines ist nicht darauf beschr√§nkt. <br><br>  Diese Engines implementieren die ECMA-262-Spezifikation, auch ECMAScript genannt.  Diese Spezifikation standardisiert JavaScript.  Die neueste Version des Standards finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  <font color="#3AC1EF">‚ñçJS Motorentwicklung und Leistungsanspruch</font> </h3><br>  Die V8-Engine ist in C ++ geschrieben und wird st√§ndig verbessert.  Es kann auf vielen Systemen ausgef√ºhrt werden, insbesondere auf Mac, Windows und Linux.  Hier werden wir nicht √ºber die Details der Implementierung von V8 sprechen.  Informationen dazu finden Sie in anderen Publikationen, unter anderem auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Website von V8</a> .  Sie √§ndern sich im Laufe der Zeit, manchmal sehr ernst. <br><br>  V8 entwickelt sich st√§ndig weiter, das gilt auch f√ºr andere Motoren.  Dies f√ºhrt insbesondere zu einer Leistungssteigerung von Webbrowsern und der Node.js.-Plattform.  Hersteller von Browser-Engines konkurrieren st√§ndig um die Geschwindigkeit der Codeausf√ºhrung. Dies geschieht seit vielen Jahren.  All dies ist f√ºr Benutzer und Programmierer von Vorteil. <br><br><h3>  <font color="#3AC1EF">‚ñç Interpretation und Zusammenstellung</font> </h3><br>  JavaScript wird als interpretierte Sprache betrachtet, aber moderne Engines interpretieren JS-Code bei weitem nicht nur.  Sie kompilieren es.  Dieser Trend ist seit 2009 zu beobachten, als der JavaScript-Compiler in Firefox 3.5 hinzugef√ºgt wurde. Danach haben andere Hersteller von Engines und Browsern diese Idee √ºbernommen. <br><br>  V8 kompiliert JavaScript, um die Codeleistung zu verbessern.  Seit dem Aufkommen von Google Maps im Jahr 2004 hat sich JavaScript aus einer Sprache entwickelt, in der zur Implementierung der interaktiven Funktionen von Webanwendungen normalerweise einige zehn Zeilen in eine Sprache geschrieben wurden, in der Browseranwendungen aus Tausenden oder sogar Hunderten geschrieben sind tausend Codezeilen.  Solche Anwendungen k√∂nnen stundenlang im Browser ausgef√ºhrt werden, was sich stark von den alten JS-Verwendungsszenarien unterscheidet. Der Code, mit dem beispielsweise nur die Richtigkeit der in die Formulare eingegebenen Daten √ºberpr√ºft werden kann.  Unter modernen Bedingungen ist das Kompilieren des Codes sehr sinnvoll, da die Ausf√ºhrung dieses Schritts zwar den Moment des Startens des Codes verz√∂gern kann, der Code jedoch nach dem Kompilieren viel produktiver ist als derjenige, der ausschlie√ülich vom Interpreter verarbeitet wird und schneller ausgef√ºhrt wird, aber langsamer arbeitet. <br><br>  Nachdem wir nun einige Bestimmungen zu JS-Engines, Interpretation und Kompilierung von Code besprochen haben, k√∂nnen wir mit dem √úben fortfahren.  Lassen Sie uns n√§mlich dar√ºber sprechen, wie Node.js-Anwendungen heruntergefahren werden. <br><br><h2>  <font color="#3AC1EF">Beenden der Node.js-Anwendung</font> </h2><br>  Es gibt verschiedene M√∂glichkeiten, Node.js-Anwendungen herunterzufahren. <br><br>  Wenn Sie also ein Programm in der Konsole ausf√ºhren, k√∂nnen Sie die Arbeit mit der Tastenkombination <code>ctrl+c</code> .  Wir sind jedoch mehr an Softwaremethoden zum Herunterfahren von Anwendungen interessiert.  Und wir werden vielleicht mit dem unh√∂flichsten Befehl beginnen, das Programm zu beenden. Wie Sie jetzt verstehen werden, ist es besser, es nicht zu verwenden. <br><br>  Das Kernel- <code>process</code> bietet eine praktische Methode, mit der Sie eine Node.js-Anwendung programmgesteuert beenden k√∂nnen.  Es sieht so aus: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>()</code> </pre> <br>  Wenn Node.js auf einen solchen Befehl im Code st√∂√üt, f√ºhrt dies dazu, dass sein Prozess sofort endet.  Dies bedeutet, dass absolut alles, was das Programm getan hat, ziemlich unh√∂flich und bedingungslos unterbrochen wird.  Wir sprechen √ºber ungebetene R√ºckrufe, √ºber Netzwerkanforderungen, die zum Zeitpunkt der Ver√∂ffentlichung ausgef√ºhrt werden, √ºber Aktionen mit Dateien, √ºber Schreibvorg√§nge in <code>stdout</code> oder <code>stderr</code> . <br><br>  Wenn diese Situation zu Ihnen passt, k√∂nnen Sie diese Methode verwenden.  Wenn Sie es aufrufen, k√∂nnen Sie ihm eine Ganzzahl √ºbergeben, die vom Betriebssystem als Exit-Code f√ºr das Programm wahrgenommen wird. <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Standardm√§√üig ist dieser Code auf 0 gesetzt, was einen erfolgreichen Abschluss bedeutet.  Andere Exit-Codes haben andere Bedeutungen, die n√ºtzlich sein k√∂nnen, um sie in Ihrem eigenen System zu verwenden, um die Interaktion einiger Programme mit anderen herzustellen. <br>  Details zu den Codes zum Herunterfahren des Programms finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Sie k√∂nnen der Eigenschaft <code>process.exitCode</code> auch einen Exit-Code zuweisen.  Es sieht so aus: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.exitCode = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Nach Beendigung des Programms gibt Node.js diesen Code an das System zur√ºck. <br><br>  Es ist zu beachten, dass die Arbeit des Programms von selbst endet, nachdem alle darin angegebenen Aktionen ausgef√ºhrt wurden.  Im Fall von Node.js gibt es jedoch h√§ufig Programme, die unter idealen Bedingungen f√ºr eine unbestimmte Dauer ausgelegt sind.  Wir sprechen zum Beispiel √ºber HTTP-Server wie diesen: <br><br><pre> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.send(<span class="hljs-string"><span class="hljs-string">'Hi!'</span></span>) }) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server ready'</span></span>))</code> </pre> <br>  Solch ein Programm kann theoretisch f√ºr immer funktionieren, wenn nichts passiert.  Wenn Sie in diesem Fall <code>process.exit()</code> aufrufen, werden die Vorg√§nge, die zum Zeitpunkt des Aufrufs dieses Befehls ausgef√ºhrt wurden, unterbrochen.  Und das ist schlecht. <br><br>  Um die Arbeit solcher Programme abzuschlie√üen, m√ºssen Sie das <code>SIGTERM</code> Signal verwenden und die erforderlichen Aktionen mit dem entsprechenden Handler ausf√ºhren. <br><br>  Beachten Sie, dass Sie zur Verwendung des <code>process</code> keine Verbindung mit <code>require</code> , da dieses Objekt standardm√§√üig f√ºr Node.js-Anwendungen verf√ºgbar ist. <br><br>  Betrachten Sie das folgende Beispiel: <br><br><pre> <code class="hljs coffeescript">const express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>) const app = express() app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { res.send(<span class="hljs-string"><span class="hljs-string">'Hi!'</span></span>) }) app.listen(<span class="hljs-number"><span class="hljs-number">3000</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Server ready'</span></span>)) process.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'SIGTERM'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { app.close(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Process terminated'</span></span>) }) })</code> </pre> <br>  Was sind Signale?  Signale sind ein Mittel zur Interaktion zwischen Prozessen im POSIX-Standard (Portable Operating System Interface).  Es handelt sich um Benachrichtigungen, die an den Prozess gesendet werden, um ihn √ºber bestimmte Ereignisse zu informieren. <br><br>  Beispielsweise teilt ein <code>SIGKILL</code> Signal einem Prozess mit, dass er sofort heruntergefahren werden muss.  Es funktioniert idealerweise genauso wie <code>process.exit()</code> . <br><br>  Das <code>SIGTERM</code> Signal teilt dem Prozess mit, dass ein normaler Abschaltvorgang ausgef√ºhrt werden muss.  Solche Signale werden von Prozessmanagern wie <code>upstart</code> oder <code>supervisord</code> und von vielen anderen gesendet. <br><br>  Sie k√∂nnen ein solches Signal vom Programm selbst mit dem folgenden Befehl senden: <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.kill(<span class="hljs-keyword"><span class="hljs-keyword">process</span></span>.pid, <span class="hljs-symbol"><span class="hljs-symbol">'SIGTERM</span></span>')</code> </pre> <br>  Um einen solchen Befehl erfolgreich abzuschlie√üen, m√ºssen Sie die <code>PID</code> Prozesses kennen, den Sie ausf√ºhren m√∂chten. <br><br><h2>  <font color="#3AC1EF">Umgebungsvariablen aus Node.js lesen</font> </h2><br>  Das <code>process</code> verf√ºgt √ºber die Eigenschaft <code>env</code> , die den Zugriff auf alle Umgebungsvariablen erm√∂glicht, die zum Zeitpunkt des Prozessstarts festgelegt wurden. <br><br>  Hier ist ein Beispiel f√ºr die Arbeit mit der Umgebungsvariablen <code>NODE_ENV</code> , die standardm√§√üig auf <code>development</code> : <br><br><pre> <code class="hljs mel">process.<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>.NODE_ENV <span class="hljs-comment"><span class="hljs-comment">// "development"</span></span></code> </pre> <br>  Wenn Sie das Skript vor dem Ausf√ºhren auf <code>production</code> , wird Node.js dar√ºber informiert, dass das Programm in einer Produktionsumgebung ausgef√ºhrt wird. <br><br>  Ebenso k√∂nnen Sie mit anderen Umgebungsvariablen arbeiten, z. B. denen, die Sie selbst festgelegt haben. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Heute haben wir die browserbasierte und serverseitige Programmierung in JavaScript angesprochen, √ºber JS-Engines gesprochen, wie Serveranwendungen heruntergefahren werden und wie Umgebungsvariablen aus Node.js-Programmen gelesen werden.  Das n√§chste Mal werden wir √ºber das Hosting f√ºr Node.js-Anwendungen, die Verwendung von Node.js im REPL-Modus, die Arbeit mit Argumenten, die beim Aufruf an Skripte √ºbergeben werden k√∂nnen, die Interaktion mit der Konsole und das Entwerfen des Codes im Formular sprechen Module. <br><br>  <b>Liebe Leser!</b>  Welche JavaScript-Tutorials w√ºrden Sie Anf√§ngern empfehlen? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423153/">https://habr.com/ru/post/de423153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423141/index.html">Claude Shannon: Wie ein Genie Probleme l√∂st</a></li>
<li><a href="../de423143/index.html">Oktober Slerm: Intensiv auf Kubernetes</a></li>
<li><a href="../de423147/index.html">√úber die Speicherstrategie und das Speicherformat in der Hadoop-√Ñra</a></li>
<li><a href="../de423149/index.html">Direkter Vergleich der Methoden zur Korrektur von Laser-Myopie oder Ihrer Bezahlung bei der Auswahl von ReLEx SMILE</a></li>
<li><a href="../de423151/index.html">Globale Objekte in PHP</a></li>
<li><a href="../de423155/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 8: Netzwerksicherheitsmodell, Teil 2</a></li>
<li><a href="../de423157/index.html">Verwendung der Funktion connect () von react-redux</a></li>
<li><a href="../de423159/index.html">Gl√ºcklicher Programmiertag! Liebe deine Entwickler</a></li>
<li><a href="../de423161/index.html">Unternehmen wollen personenbezogene Daten</a></li>
<li><a href="../de423163/index.html">CryptoPro mit Mono verbinden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>