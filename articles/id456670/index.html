<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏿 🤴🏻 📑 Tentang metode otentikasi yang sangat mata-mata 👦 💪🏻 👧🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi, kami mengirim agen super rahasia Alice dan Bob ke negara musuh yang menyamar. Selama misi, mereka harus menghubungi dan bekerja bersama, bertuka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang metode otentikasi yang sangat mata-mata</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456670/"><p> Jadi, kami mengirim agen super rahasia Alice dan Bob ke negara musuh yang menyamar.  Selama misi, mereka harus menghubungi dan bekerja bersama, bertukar informasi, urusan spionase biasa.  Tentu saja, semua ini harus dilakukan sesuai dengan semua aturan dan prosedur keselamatan yang memungkinkan. </p><br><p>  Memang, pada gilirannya terakhir, kami ingin mengungkapkan mereka: baik misi itu sendiri dan agen itu sendiri dan semua keamanan nasional beresiko.  Karena itu, kepentingan kami adalah memberikan informasi minimal yang diperlukan bagi mata-mata.  Secara khusus, semakin sedikit yang mereka ketahui tentang satu sama lain dan teknik komunikasi, semakin baik. </p><br><p>  Tetapi bagaimana mereka mengidentifikasi kawan markas mereka? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ceb/454/721/ceb4547217be4972a9e5f8fe323cf257.gif" alt="KDPV"></p><br><p>  TL; DR - menemukan mekanisme otentikasi pengguna menggunakan steganografi untuk agensi tiga karakter imajiner dari negara yang tidak ada. </p><a name="habracut"></a><br><h2 id="o-volkah-i-ovechih-shkurah">  Tentang serigala dan kulit domba </h2><br><p>  Penutup adalah penutup, jadi Alice atau Bob tidak boleh menimbulkan kecurigaan dengan tindakan mereka.  Perencanaan yang tepat menyiratkan paranoia tentang pemantauan konstan mereka di semua tingkatan yang memungkinkan.  Posting ini tidak akan membahas tugas pertukaran informasi secara langsung (layak mendapatkan seri terpisahnya sendiri), tetapi hanya cara untuk memastikan bahwa informasi tersebut dikirimkan oleh mereka yang membutuhkannya kepada siapa pun yang membutuhkannya. </p><br><p>  Kemungkinan besar, kedua mata-mata akan memiliki sejarah dalam format warga biasa, apalagi, tidak terhubung satu sama lain.  Oleh karena itu, Anda harus segera memveto penggunaan alat kriptografi klasik dan saluran aman - setiap agen kontra intelijen tahu bahwa orang jujur ​​yang tidak memiliki koneksi dekat tidak perlu disembunyikan. </p><br><h2 id="chto-delat">  Apa yang harus dilakukan </h2><br><p>  Tentu saja, tugas seperti itu bukanlah hal baru, itu ada dengan gembira dan telah dipecahkan jauh sebelum munculnya ini dari Internet Anda.  Dan tidak hanya telah diputuskan, jadi beberapa keputusan telah diperkuat dalam budaya dan masih ditemukan di buku, film, dan permainan. </p><br><p>  Mari kita lihat pemandangan seperti itu: dua orang berjaket panjang berkumpul di tempat umum dan bertukar kalimat yang sangat aneh.  Jika frasa dan jawaban awal benar, maka otentikasi berhasil, dan orang-orang bertukar folder bertanda "Top Secret" dan menyimpang ke arah yang tidak diketahui. </p><br><p>  Kerugian dari skema semacam itu segera jelas - frasa harus dirahasiakan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sering diubah</a> , yang tidak terlalu sederhana di wilayah musuh.  Pada saat yang sama, agar tidak diucapkan secara kebetulan dan tidak mengarah pada kasus KDPV, mereka menjadi sangat menonjol dan acak, yang berarti bahwa mereka dapat memberikan agen yang mengucapkannya. </p><br><p><img src="https://habrastorage.org/webt/pl/pe/sh/plpeshe7ifcmijrxlaziosekgey.png"></p><br><p>  Kami, di era teknologi digital, tidak menyukai metode ini.  Terutama jika Anda ingat bahwa hampir semua saluran komunikasi dikendalikan oleh seseorang dan disadap karena motif baik dan buruk.  Dan apa pun yang mereka meyakinkan kami, kehidupan orang-orang tidak boleh dipercaya dalam kebijakan privasi Facebook mana pun. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/984/c5d/c5d/984c5dc5dae5cba450b58907693ceed6.png"></p><br><h2 id="steganografiya-opyat">  Steganografi (lagi?) </h2><br><p>  Landak jelas bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan untuk bersembunyi satu sama lain</a> dalam situasi seperti itu terlihat lebih menarik dari sebelumnya.  Dan pada kenyataannya, bahkan metode yang dijelaskan adalah subspesiesnya - frasa kode dapat dianggap sebagai wadah dengan hanya sedikit informasi di dalamnya. </p><br><p>  Mamalia yang sama dari detasemen insektivora memahami bahwa ini bukan hanya tentang saling melemparkan stegocontainers.  Pertukaran semacam itu akan menyebabkan kecurigaan yang hampir lebih besar daripada beberapa enkripsi PGP yang umum, jadi kami tidak tertarik. </p><br><h3 id="a-o-chem-togda">  Bagaimana dengan itu? </h3><br><p>  Tidak seperti cryptograms, stegocontainers memiliki keunggulan yang jelas - konteks aplikasi.  Setiap teks, gambar, file audio, dll., Selain konten yang jelas, juga membawa kemungkinan diskusi <strong>alami</strong> dan dapat dikirim tidak hanya dari teluk, tetapi dalam proses dialog yang tidak menimbulkan kecurigaan. </p><br><p>  Dipersenjatai dengan ide-ide seperti itu, kita sudah dapat menyusun protokol otentikasi steganografi sederhana berdasarkan kunci umum: </p><br><ul><li>  A -&gt; B: pesan cantik yang meminta wadah steganografi parameter tertentu; </li><li>  B: memilih wadah <em>C</em> yang cocok dengan konteks dan parameter yang diminta; </li><li>  B: sama menciptakan pesan <em>M</em> ; </li><li>  B -&gt; A: <em>C '= Sematkan (C, M, K)</em> ; </li><li>  A: Cek <em>C '</em> untuk kepatuhan dengan parameter yang ditetapkan; </li><li>  A -&gt; B: <em>M '= Ekstrak (C', K)</em> ; </li><li>  B: Cek apakah <em>M</em> dan <em>M</em> cocok. </li></ul><br><p>  Protokol semacam itu memiliki kelemahan yang jelas - Alice dan Bob harus memiliki kunci bersama dan fungsi embedding dan ekstraksi.  Kompromi mereka dapat mengarah pada kemungkinan analisis terperinci tentang metode otentikasi musuh dan membahayakan pengguna dan markas lainnya.  Sesuatu harus diperbaiki. </p><br><h2 id="ispolnitel-ne-cherepashka">  Artis itu bukan bug </h2><br><p>  Jika pembaca pergi ke sekolah setelah munculnya kelas-kelas komputer, maka ia harus ingat belajar dasar-dasar algoritmaisasi menggunakan pemain kura-kura, semut dan sejenisnya.  Gagasan mereka adalah untuk menunjukkan kemungkinan mengoptimalkan sejumlah besar tindakan tunggal manual dengan membuat program sederhana.  Untuk menyelesaikan masalah kita, kita harus pergi ke arah yang berlawanan. </p><br><p><img src="https://habrastorage.org/webt/nc/lo/lo/nclolotljunb2zzbkgr2-4qo0ri.png" alt="Bukankah itu lucu?"></p><br><p>  Karena kita dapat menyederhanakan penulisan algoritma akhir dari urutan langkah ke deskripsi prosedural mereka sesuai dengan parameter yang diberikan, kita dapat melakukan proses inversi.  Jika Anda membayangkan sebuah wadah sebagai array dari beberapa komponennya, maka menyematkan pesan dengan kunci dapat ditulis sebagai urutan operasi yang terurut pada elemen kontainer pada indeks tertentu dengan berbagai parameter konstan. </p><br><p>  Di sinilah non-matematika dimulai, jadi saya meminta yang pemalu untuk hanya membalik paragraf yang tampak sulit ke bagian operasi atau bahkan sedikit lebih jauh.  Tidak ada yang mengerikan akan terjadi, aku janji. </p><br><p>  Untuk menanamkan data, kita perlu urutan bentuk: <em>(f1, S1, i, D1), (f2, S2, j, D2) ...</em> , di mana: </p><br><ul><li>  <em>Di</em> - beberapa bagian dari data yang disematkan; </li><li>  <em>i, j</em> adalah indeks unsur-unsur wadah; </li><li>  <em>fi: (Negara, Elemen, D) -&gt; (Negara, Elemen)</em> - fungsi sematan; </li><li>  <em>Si</em> adalah keadaan tertentu, konteks operasi, <em>(El ', S [i + 1]) = fi (Si, El, Di)</em> . </li></ul><br><p>  Untuk mengekstraknya, Anda tidak perlu menyimpan bagian data (K.O), karena itu ada cukup tiga kali lipat: <em>(g1, S1, I1), (g2, S2, I2) ...</em> dengan nilai yang sama, hanya <em>gi: (Negara, Elemen) -&gt; (Negara, D)</em> . </p><br><p>  Semua ini dapat diwakili oleh diagram simetris di bawah ini.  Jika karena alasan tertentu saya tidak berhasil mencapai kejelasan, maka itu tidak menakutkan, baca terus. </p><br><p><img src="https://habrastorage.org/webt/l7/yk/pk/l7ykpkwfi8sfkcebwxryswzo1r0.png" alt="Baik atau tidak lagi"></p><br><p>  Dapat dilihat bahwa fungsi penyematan memiliki tingkat kebebasan yang lebih besar.  Tidak seperti saudara perempuannya, dia memodifikasi wadah, sambil melakukan ini berdasarkan dua elemen independen - data tertanam dan elemen.  Terima kasih, atau, lebih tepatnya, karena ini, dua pendekatan global untuk penerapan algoritma steganografi oleh sistem seperti itu dimungkinkan: </p><br><ol><li>  Pilih indeks elemen yang paling tepat untuk diubah sesuai dengan fungsi embedding (paling tidak terlihat atau tidak memerlukannya sama sekali) dan transfer urutan yang terbentuk terkait dengan wadah tertentu.  Dengan pendekatan ini, mereka perlu diisolasi satu sama lain sebelum muncul kebutuhan untuk menggunakan metode klasik seperti enkripsi dan media aman lainnya; </li><li>  Temukan metode membagi wadah menjadi elemen dan fungsi penyisipan sehingga setiap perubahan yang diharapkan akan sama tidak terlihat.  Dalam hal ini, urutannya tidak tergantung pada wadah dan dapat dibuat bahkan oleh generator yang sepenuhnya acak.  Kurang fleksibel dan kurangnya kontrol kasus terburuk.  Di sisi lain, pendekatan ini lebih sederhana dan lebih nyaman ketika diterapkan di lapangan, jadi di bawah ini saya akan menggunakannya. </li></ol><br><p>  Jika status tidak diperlukan untuk algoritme, maka semua hal di atas tetap valid, hanya tanpa satu huruf dan blok pada diagram.  Tanpa itu, sebenarnya lebih mudah. </p><br><h2 id="i-zachem-ono-nam">  Dan mengapa kita membutuhkannya? </h2><br><p>  Sekarang, jika Anda tahu sebelumnya wadah mana dengan pesan dan kunci mana yang akan digunakan, alih-alih sepenuhnya mengungkapkan bagian-bagian dari algoritma, Anda dapat menghasilkan dan memberikan agen untuk hanya menggunakan urutan dan juru bahasa seperti itu.  Baiklah, tidak hanya memberi, tentu saja, tetapi lebih banyak tentang itu nanti. </p><br><h3 id="dobavlyaem-asimmetrichnost">  Tambahkan asimetri </h3><br><p>  Bahkan seorang seniman kura-kura dapat menggambar kotak dengan ratusan cara berbeda, cukup mengubah urutan operasi dan menambahkan yang baru.  Ini berarti bahwa tidak ada yang mengganggu kami dan melakukan hal yang sama dengan urutan yang dijelaskan untuk data input tetap. </p><br><p>  Artinya, kita dapat mengambil urutan penyematan, menambahkan operasi baru, mencampur semuanya, dan agar hasilnya tetap sama.  Kecuali, di hadapan suatu negara, akan perlu untuk melacaknya dan menambahkan secara terpisah perubahan yang diperlukan untuk urutan.  Itu sebabnya tanpanya lebih mudah, ya. </p><br><p>  Dengan satu dan lain cara, setelah diremas-remas dan berisik, bahkan pembuat embedder itu sendiri tidak akan lagi dapat memahami apa yang sebenarnya ia tanamkan: setiap urutan operasi <em>N</em> akan mewakili <em>N!</em>  pesan yang berpotensi tertanam - satu untuk setiap permutasi dari bagian yang tertanam.  Pada saat yang sama, <em>N</em> sendiri adalah pertanyaan besar.  Oleh karena itu, seseorang dapat memanggil urutan seperti itu terbuka - mereka tidak memberikan informasi apa pun baik tentang pesan yang disematkan, maupun tentang algoritma dan kunci yang digunakan. </p><br><p>  Saat mengekstraksi informasi, sangat penting bagi kami baik urutan (untuk mengembalikan pesan yang benar sama dari semua kemungkinan) dan jumlah bagian yang akan diekstraksi, sehingga urutan ekstraksi tetap tidak berubah dari saat kelahiran.  Karena mereka secara implisit mengandung informasi tentang kunci, generator dan algoritma yang digunakan, mereka, seperti hewan dari buku merah, perlu disimpan dan dilindungi.  Dan merahasiakannya. </p><br><p>  Apa hubungannya asimetri dengan itu?  Faktanya adalah bahwa sekarang setiap urutan ekstraksi dikaitkan dengan jumlah embedder yang tak terbatas.  Dan memulihkan satu dari yang lain, dalam kasus umum, adalah tugas yang tidak terpecahkan. </p><br><h3 id="ekspluatiruem">  Kami sedang beroperasi </h3><br><p>  Kami lupa tentang matematika dekat dan kembali ke tugas semula - bagaimana kita bisa mengirim Alice dan Bob ke wilayah musuh untuk: </p><br><ul><li>  mereka tidak saling kenal satu sama lain </li><li>  tidak memiliki algoritma rahasia di tangan </li><li>  tetapi bisakah Anda memverifikasi satu sama lain saat berkomunikasi di saluran terbuka? </li></ul><br><p>  Nah, dengan paragraf pertama semuanya jelas, kami hanya tidak memberi mereka informasi eksplisit tentang satu sama lain, tidak ada kunci bersama.  Untuk yang kedua, Anda perlu mengingat deskripsi protokol di atas.  Sekarang kita dapat mengecualikan secara langsung algoritma <em>Embed</em> dan <em>Extract</em> yang mewakili potensi rahasia negara dan semua itu.  Dan, dengan mempertimbangkan ini, untuk yang ketiga dimungkinkan untuk membuat protokol dua tahap berikut. </p><br><p>  Pembuatan informasi otentikasi <strong>sebelum dimulainya misi</strong> dengan kantor pusat sebagai pihak tepercaya dari Trent: </p><br><ul><li>  T: memilih algoritma rahasia dan kunci rahasia K, dibuat dengan bantuan mereka: <br><ul><li>  Ekstrak urutan <em>Ex</em> ; </li><li>  cocok untuk otentikasi (di bawah) konteks <em>Ctx</em> ; </li></ul></li><li>  T -&gt; A: <em>Ctx, Ex</em> ; </li><li>  T: menggunakan <em>Ex</em> dan konteks yang dibuat, menghasilkan: <br><ul><li>  pesan <em>M</em> sebelumnya tidak digunakan untuk agen yang dipilih dari antara bagian <em>| Ex |</em>  ; </li><li>  urutan satu kali <em>Em</em> , membuatnya terbuka seperti dijelaskan di atas; </li></ul></li><li>  T -&gt; B: <em>Em, h (M)</em> , jika diinginkan, membuat set tambahan. </li></ul><br><p>  Dengan demikian, Alice hanya memiliki satu urutan untuk semua kesempatan dan konteks kontak di masa depan, dan Bob menjadi pemilik yang bahagia dari serangkaian urutan dan hash pesan satu kali yang mereka tanam. </p><br><p>  Protokol otentikasi yang sudah ada <strong>selama misi</strong> terlihat seperti ini: </p><br><ul><li>  A -&gt; B: pesan <em>IM awal</em> berdasarkan konteks <em>Ctx</em> dengan deskripsi wadah; </li><li>  B: memilih <em>C ~ IM yang</em> sesuai; </li><li>  B -&gt; A: <em>C '= Em (C)</em> ; </li><li>  A: memeriksa kepatuhan dengan <em>C '~ IM</em> (karena perubahan tidak terlihat, itu harus disimpan); </li><li>  A -&gt; B: <em>M '= Ex (C')</em> , menandai M 'saat digunakan; </li><li>  B: cek, <em>h (M ') == h (M)</em> , hancurkan <em>Em, h (M)</em> . </li></ul><br><p>  Pembaca yang penuh perhatian akan memperhatikan bahwa sebelum protokol, Alice dan Bob hanya memiliki satu set informasi, yang dengan sendirinya tidak berarti apa-apa bagi mereka, atau bagi musuh potensial, dan hanya selama "bermain dengan warna". </p><br><p>  Setiap set terbuka Bob hanya digunakan sekali, yang dikendalikan oleh langkah kedua dari belakang Alice.  Ketika bertemu <em>M yang</em> sebelumnya digunakan (dan, karena itu, <em>Em</em> tak terlihat olehnya) oleh orang lain, dia menyadari bahwa salah satu "rekan" -nya adalah palsu. </p><br><p>  Penggunaan berulang oleh orang yang sama memberi tahu dia bahwa dia tidak mengetahui seluk-beluk protokol dan tentu saja bukan orang yang harus dihubungi.  Yah, lebih baik terlambat daripada tidak sama sekali. </p><br><p><img src="https://habrastorage.org/webt/bv/6v/0h/bv6v0hcim8kmzndrvn5__thsp1y.png"></p><br><p>  Oke, beginilah semuanya terlihat terlalu rumit dan sulit dipahami.  Adakah yang datang? </p><br><p>  Mari kita tunjukkan lebih baik dalam praktik, karena bahkan mata-mata itu sendiri tidak perlu mengetahui rincian protokol untuk digunakan, apalagi pembaca yang buruk.  Awalnya hanya sedikit tentang bagaimana itu semua diterapkan. </p><br><h2 id="vysokie-tehnologii">  Teknologi tinggi </h2><br><p>  Jadi, tetap hanya menulis semua yang diperlukan untuk protokol.  Ya, Anda tidak melakukan segalanya dengan tangan Anda (meskipun Anda bisa).  Dan hari ini korban kode saya akan ... <em>memutar roda keberuntungan</em> ... Jawa?  Baiklah, pada saat yang sama segala sesuatu di STL akan, Anda tidak perlu mencari apa pun. </p><br><p>  Mari kita mulai dengan API yang diperlukan.  Untuk bekerja, Anda hanya perlu menentukan kelas array elemen kontainer dengan kemampuan untuk menerima dan mengubah elemen berdasarkan indeks: </p><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StegoContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MyElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  i-  } public void set(int i, MyElement v) { //  i-  } public int size() { //    } }</span></span></code> </pre> <br><p>  Penggunaan lebih lanjut dikurangi untuk membuat pembungkus otomat steganografi di atas wadah yang diperlukan dan memasok fungsi embedding dan ekstraksi ke inputnya: </p><br><pre> <code class="java hljs">StegoMachine&lt;MyState, MyElement&gt; myMachine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StegoMachine( initialState, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyContainer&lt;MyElement&gt;(<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StegoEmbed myEmbed = (st, el, dp) -&gt; { <span class="hljs-comment"><span class="hljs-comment">//    dp   el   st }; final StegoExtract myExtract = (st, el) -&gt; { //     el   st return dp; }; //    MyDataPart part = /*    */; myMachine.exec(1337, myEmbed, part); //... //    /,   //      State currState = myMachine.getState(); //... //    part = myMachine.exec(80085, myExtract); //... //        MyContainer container = (MyContainer) myMachine.getContainer();</span></span></code> </pre> <br><p>  Kelas dengan akhiran Stateless digunakan dengan cara yang sama, jika implementasi algoritma tidak memerlukan mempertahankan keadaan internal. </p><br><p>  Generator urutan dapat bekerja sesuka Anda dan tidak memiliki API umum.  Dalam kasus umum, apa pun dapat menjadi bagian dari data secara umum, mulai dari bit tunggal hingga rock art dalam pengkodean terpisah. </p><br><h3 id="primer-realizacii">  Contoh implementasi </h3><br><h4 id="o-metode">  Tentang Metode </h4><br><p>  Sebagai contoh implementasi, menggunakan antarmuka yang dibuat, saya menerapkan algoritma sederhana dari keluarga LSB untuk gambar bitmap dengan kompresi lossless.  Elemen-elemen mereka adalah piksel yang tidak memiliki tetangga dalam bit paling signifikan dari semua komponen RGB.  Fungsi embed bekerja dengan bit tunggal dari data sumber dan hanya mengubah bit orde rendah dari nilai salah satu komponen (yang indeks akan arahkan ke). </p><br><p>  Ini cukup sederhana, tetapi sangat bagus untuk mengimplementasikan protokol, karena mengubah elemen apa pun sama-sama tidak terlihat menurut pilihan mereka, sehingga indeks elemen yang akan diubah dihasilkan menggunakan generator acak.  Dalam kasus Java, menggunakan <em>SecureRandom</em> , tetapi jika diinginkan, ia dengan mudah berubah ke sumber entropinya. </p><br><p>  <em>Namun demikian, ini adalah metode yang sangat sederhana, saya tidak merekomendasikan menggunakannya untuk mata-mata nyata.</em> </p><br><h4 id="o-heshah">  Tentang hash </h4><br><p>  Karena teks cenderung terdistorsi tergantung pada kepribadian agen yang disimulasikan (beberapa tidak memasukkan huruf kapital, yang lain suka membuat emotikon, dll., Yang lain umumnya buta huruf), saya sarankan menggunakan sha256 untuk menghitung hash, tetapi hanya dari kata-kata yang dicetak huruf kecil: </p><br><pre> <code class="plaintext hljs">h("Hello world?...") == h("hello, world!11")</code> </pre> <br><h4 id="ob-interfeyse">  Tentang antarmuka </h4><br><p>  Paket perangkat lunak terdiri dari dua bagian - satu untuk menghasilkan urutan dan hash lainnya untuk Trent, yang lain untuk menanamkan dan memeriksa pesan yang diterima untuk kepatuhan. </p><br><p>  Bekerja dengan keduanya terjadi dari baris perintah melalui argumen dan aliran input-output, tidak ada antarmuka lain yang disampaikan (ketakutan dan horor).  Tetap saja, untuk menjadi karyawan markas itu, mata-mata itu - artinya memiliki semacam kualifikasi.  Nah, jika tidak, saya masih akan menunjukkan contoh. </p><br><div class="spoiler">  <b class="spoiler_title">Ini bantuannya</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yx/1m/ge/yx1mge8ligshzbsv7hxi3olw__g.png" alt="Tangkapan layar penggunaan"></p><br></div></div><br><h3 id="chto-im-vsem-delat-to">  Apa yang mereka lakukan? </h3><br><p>  Untuk memulainya, Trent di kantor pusat perlu mengerjakan informasi otentikasi.  Khususnya, untuk memikirkan terlebih dahulu situasi di mana agen akan bekerja. </p><br><p>  Misalnya, biarkan Bob menjadi freelancer grafis dan Alice sebagai pelanggannya.  Otentikasi akan berlangsung dengan kedok perintah untuk membuat grafik / desain / sesuatu yang lain. </p><br><p>  Kami melaporkan informasi yang bermanfaat ini kepada keduanya dan kembali ke protokol itu sendiri.  Kami akan menyiapkan pesan tertanam <em>M.txt yang</em> sesuai <em>terlebih dahulu</em> , meminimalkan jumlah karakter di dalamnya: "itu cocok untuk saya di mana mentransfer uang."  Hasilkan <em>Em</em> dan <em>Ex</em> menggunakan utilitas untuk Trent: </p><br><pre> <code class="bash hljs">Trent@HQWorkstation:~$ java -jar HQUtil.jar -ex $(<span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> -c%s <span class="hljs-string"><span class="hljs-string">"M.txt"</span></span>) 4096 &gt; Ex.txt Trent@HQWorkstation:~$ cat Ex.txt | java -jar HQUtil.jar -em <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(cat M.txt)</span></span></span><span class="hljs-string">"</span></span> 0.25 4096 &gt; Em.txt Trent@HQWorkstation:~$ cat M.txt | java -jar HQUtil.jar -h &gt; hash.bin</code> </pre> <br><p>  Di sini <code>$(stat -c%s "M.txt")</code> mengembalikan ukuran pesan dalam byte, dan 4096 - pembatasan pada kisaran indeks yang dihasilkan (untuk memungkinkan penggunaan wadah yang lebih kecil).  Demikian pula, <code>$(cat M.txt)</code> digunakan untuk meneruskan pesan itu sendiri ke parameter baris perintah.  Pada prinsipnya, Anda dapat melakukannya tanpa bash, menggunakan tenaga manual Anda sendiri, tetapi kepada siapa itu lebih nyaman. </p><br><p>  <em>Ex.txt</em> diteruskan ke Alice, <em>Em.txt</em> dan <em>hash.bin</em> ke Bob.  Sekarang bayangkan agen telah berhasil dikerahkan dan ingin berkomunikasi satu sama lain - kami melanjutkan ke pelaksanaan protokol.  Bob menempatkan resumenya atau tawaran pekerjaan pada suatu pertukaran, dan Alice memulai komunikasi: </p><br><pre> <code class="plaintext hljs">: ,     %_% :        ,   .  ? : ,   </code> </pre> <br><p>  Bob mencari gambar payung, bahkan mungkin menggambarnya sendiri jika arwahnya kreatif, sedikit mengompres / memaksakan tanda air (atau apa yang dilakukan freelancer di sana sekarang) dan melakukannya: </p><br><pre> <code class="bash hljs">Bob@PC:~$ cat Em.txt | java -jar SpyUtil.jar -e umbrella.png</code> </pre> <br><p>  Setelah menunggu beberapa saat, pura-pura bekerja, jika dalam kenyataannya dia tidak melakukannya, dia mengirimkan Alice wadah yang diterima, tentu saja, mengingat konteksnya: </p><br><pre> <code class="plaintext hljs">: ,  ,     </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mengirimkan payung dengan pesan, 670kb</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/qw/nk/in/qwnkinuhpppynf6ve9gkrmpnehm.png"></p></div></div><br><p>  Itu, pada gilirannya, mengambil pesan yang disimpan secara internal: </p><br><pre> <code class="bash hljs">Alice@PC:~$ cat Ex.txt | java -jar SpyUtil.jar -e umbrella.png      </code> </pre> <br><p>  Mengubah satu set kata menjadi kalimat normal dan mengirimkannya ke Bob: </p><br><pre> <code class="plaintext hljs">: ,  ,   ?</code> </pre><br><p>  Ia memeriksa keakuratan pesan: </p><br><pre> <code class="java hljs">Bob<span class="hljs-meta"><span class="hljs-meta">@PC</span></span>:~$ java -jar SpyUtil.jar -c hash.bin <span class="hljs-string"><span class="hljs-string">",  ,   ?"</span></span> ,  ,   ? - Correct</code> </pre><br><p>  Dan komunikasi terus mudah, jika semuanya OK.  Seluruh dialog pada bagian pengamat terlihat seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">500 kilobyte gif</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/ye/he/ffyeheonv4qo9dxdjygalg8kvtq.gif"></p></div></div><br><p>  Jelas bahwa kontra intelijen tidak akan menemukan sesuatu yang mencurigakan dalam semua yang disadap ini.  Bahkan, bahkan metode analisis stego dalam kasus ini tidak akan selalu diterapkan - well, seseorang memesan gambar payung seharga 5 dolar, mereka menemukan sesuatu yang mengejutkan Internet.  Sumber daya komputasi dan orang tidak terbatas untuk memeriksa setiap situasi seperti itu.  Otentikasi berhasil, tirai. </p><br><p>  -&gt; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456670/">https://habr.com/ru/post/id456670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456656/index.html">Pelajaran tentang SDL 2: Pelajaran 4 - Peregangan PNG</a></li>
<li><a href="../id456658/index.html">Tumbuh dewasa: bagaimana kami menilai keterampilan dalam suatu tim</a></li>
<li><a href="../id456662/index.html">Bagaimana cara menghemat uang pada seorang terapis menggunakan pengembangan berbasis tes</a></li>
<li><a href="../id456666/index.html">WebTotem atau bagaimana kita ingin membuat Internet lebih aman</a></li>
<li><a href="../id456668/index.html">Microsoft ML Spark: ekstensi Spark yang menjadikan SparkML lebih manusiawi dan LightGBM sebagai bonus</a></li>
<li><a href="../id456672/index.html">Resep Nginx: pemberitahuan asinkron dari PostgreSQL ke websocket</a></li>
<li><a href="../id456676/index.html">Masuk dalam aplikasi php yang didistribusikan</a></li>
<li><a href="../id456678/index.html">Keadaan elektronik masa depan. Bagian 4</a></li>
<li><a href="../id456680/index.html">Delapan Hukum Penamaan dalam Desain UX (Bagian 2)</a></li>
<li><a href="../id456682/index.html">Perilaku tidak terdefinisi dengan deklarasi fungsi yang tidak digunakan lagi di ANSI C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>