<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛫 🏢 🤹🏿 Algunos aspectos de la supervisión de MS SQL Server. Recomendaciones para establecer marcas de seguimiento 🛶 💇🏿 🚿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prólogo 
 Muy a menudo, los usuarios, desarrolladores y administradores de los DBMS de MS SQL Server enfrentan problemas de rendimiento de la base de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algunos aspectos de la supervisión de MS SQL Server. Recomendaciones para establecer marcas de seguimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448044/"><h3>  Prólogo </h3><br>  Muy a menudo, los usuarios, desarrolladores y administradores de los DBMS de MS SQL Server enfrentan problemas de rendimiento de la base de datos o DBMS en general, por lo tanto, el monitoreo de MS SQL Server es muy relevante. <br><br>  Este artículo es una adición al artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uso de Zabbix para monitorear la base de datos de MS SQL Server</a> y examinará algunos aspectos de la supervisión de MS SQL Server, en particular: cómo determinar rápidamente qué recursos faltan, así como recomendaciones para establecer marcas de seguimiento. <br><br>  Para que los siguientes scripts funcionen, debe crear el esquema inf en la base de datos deseada de la siguiente manera: <br><br><div class="spoiler">  <b class="spoiler_title">Crear un esquema inf</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> &lt;_&gt;; go <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> inf;</code> </pre> </div></div><a name="habracut"></a><br><h3>  Método para detectar escasez de RAM </h3><br>  El primer indicador de falta de RAM es el caso cuando una instancia de MS SQL Server se come toda la RAM asignada. <br><br>  Para hacer esto, cree la siguiente vista inf.vRAM: <br><br><div class="spoiler">  <b class="spoiler_title">Crear una vista inf.vRAM</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vRAM] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.[TotalAvailOSRam_Mb] <span class="hljs-comment"><span class="hljs-comment">--       , a.[RAM_Avail_Percent] --     , a.[Server_physical_memory_Mb] --       , a.[SQL_server_committed_target_Mb] --     MS SQL Server   , a.[SQL_server_physical_memory_in_use_Mb] --    MS SQL Server       , a.[SQL_RAM_Avail_Percent] --    MS SQL Server      MS SQL Server , a.[StateMemorySQL] --    MS SQL Server , a.[SQL_RAM_Reserve_Percent] --    MS SQL Server     --     , (case when a.[RAM_Avail_Percent]&lt;10 and a.[RAM_Avail_Percent]&gt;5 and a.[TotalAvailOSRam_Mb]&lt;8192 then 'Warning' when a.[RAM_Avail_Percent]&lt;=5 and a.[TotalAvailOSRam_Mb]&lt;2048 then 'Danger' else 'Normal' end) as [StateMemoryServer] from ( select cast(a0.available_physical_memory_kb/1024.0 as int) as TotalAvailOSRam_Mb , cast((a0.available_physical_memory_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [RAM_Avail_Percent] , a0.system_low_memory_signal_state , ceiling(b.physical_memory_kb/1024.0) as [Server_physical_memory_Mb] , ceiling(b.committed_target_kb/1024.0) as [SQL_server_committed_target_Mb] , ceiling(a.physical_memory_in_use_kb/1024.0) as [SQL_server_physical_memory_in_use_Mb] , cast(((b.committed_target_kb-a.physical_memory_in_use_kb)/casT(b.committed_target_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Avail_Percent] , cast((b.committed_target_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Reserve_Percent] , (case when (ceiling(b.committed_target_kb/1024.0)-1024)&lt;ceiling(a.physical_memory_in_use_kb/1024.0) then 'Warning' else 'Normal' end) as [StateMemorySQL] from sys.dm_os_sys_memory as a0 cross join sys.dm_os_process_memory as a cross join sys.dm_os_sys_info as b cross join sys.dm_os_sys_memory as v ) as a;</span></span></code> </pre></div></div><br>  Luego puede determinar que la instancia de MS SQL Server consume toda la memoria asignada por la siguiente consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> SQL_server_physical_memory_in_use_Mb, SQL_server_committed_target_Mb <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vRAM];</code> </pre><br>  Si la métrica SQL_server_physical_memory_in_use_Mb es constantemente al menos SQL_server_committed_target_Mb, entonces debe verificar las estadísticas de expectativas. <br><br>  Para determinar la falta de RAM a través de las estadísticas de expectativas, cree una vista inf.vWaits: <br><br><div class="spoiler">  <b class="spoiler_title">Crear una vista inf.vWaits</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> [Waits] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [wait_type], <span class="hljs-comment"><span class="hljs-comment">--   [wait_time_ms] / 1000.0 AS [WaitS],--      .    signal_wait_time_ms ([wait_time_ms] - [signal_wait_time_ms]) / 1000.0 AS [ResourceS],--        signal_wait_time_ms [signal_wait_time_ms] / 1000.0 AS [SignalS],--           [waiting_tasks_count] AS [WaitCount],--   .         100.0 * [wait_time_ms] / SUM ([wait_time_ms]) OVER() AS [Percentage], ROW_NUMBER() OVER(ORDER BY [wait_time_ms] DESC) AS [RowNum] FROM sys.dm_os_wait_stats WHERE [waiting_tasks_count]&gt;0 and [wait_type] NOT IN ( N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP', N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE', N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE', N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE', N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE', N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX', N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE', N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE', N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP', N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY', N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK', N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES', N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT', N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN', N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') ) , ress as ( SELECT [W1].[wait_type] AS [WaitType], CAST ([W1].[WaitS] AS DECIMAL (16, 2)) AS [Wait_S],--      .    signal_wait_time_ms CAST ([W1].[ResourceS] AS DECIMAL (16, 2)) AS [Resource_S],--        signal_wait_time_ms CAST ([W1].[SignalS] AS DECIMAL (16, 2)) AS [Signal_S],--           [W1].[WaitCount] AS [WaitCount],--   .         CAST ([W1].[Percentage] AS DECIMAL (5, 2)) AS [Percentage], CAST (([W1].[WaitS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgWait_S], CAST (([W1].[ResourceS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgRes_S], CAST (([W1].[SignalS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgSig_S] FROM [Waits] AS [W1] INNER JOIN [Waits] AS [W2] ON [W2].[RowNum] &lt;= [W1].[RowNum] GROUP BY [W1].[RowNum], [W1].[wait_type], [W1].[WaitS], [W1].[ResourceS], [W1].[SignalS], [W1].[WaitCount], [W1].[Percentage] HAVING SUM ([W2].[Percentage]) - [W1].[Percentage] &lt; 95 -- percentage threshold ) SELECT [WaitType] ,MAX([Wait_S]) as [Wait_S] ,MAX([Resource_S]) as [Resource_S] ,MAX([Signal_S]) as [Signal_S] ,MAX([WaitCount]) as [WaitCount] ,MAX([Percentage]) as [Percentage] ,MAX([AvgWait_S]) as [AvgWait_S] ,MAX([AvgRes_S]) as [AvgRes_S] ,MAX([AvgSig_S]) as [AvgSig_S] FROM ress group by [WaitType];</span></span></code> </pre></div></div><br>  En este caso, puede determinar la falta de RAM mediante la siguiente consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [Percentage]      ,[AvgWait_S]  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [inf].[vWaits]  <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre><br>  Aquí debe prestar atención al rendimiento de Percentage y AvgWait_S.  Si son significativos en su totalidad, entonces hay una probabilidad muy alta de que la RAM no sea suficiente para una instancia de MS SQL Server.  Los valores esenciales se determinan individualmente para cada sistema.  Sin embargo, puede comenzar con la siguiente métrica: Porcentaje&gt; = 1 y AvgWait_S&gt; = 0.005. <br><br>  Para enviar indicadores a un sistema de monitoreo (por ejemplo, Zabbix), puede crear las siguientes dos consultas: <br><br><ol><li>  cuánto en porcentaje ocupan los tipos de expectativas para RAM (la suma de todos esos tipos de expectativas): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>([Percentage]), <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Percentage] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li><li>  cuántos milisegundos ocupan los tipos de expectativas para RAM (el valor máximo de todos los retrasos promedio para todos esos tipos de expectativas): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([AvgWait_S])*<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [AvgWait_MS] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li></ol><br>  En función de la dinámica de los valores obtenidos para estos dos indicadores, podemos concluir si hay suficiente RAM para la instancia de MS SQL Server. <br><br><h3>  Método de detección de sobrecarga de CPU </h3><br>  Para identificar la falta de tiempo de CPU, solo use la vista del sistema sys.dm_os_schedulers.  Aquí, si el indicador runnable_tasks_count es constantemente mayor que 1, entonces hay una alta probabilidad de que el número de núcleos no sea suficiente para la instancia de MS SQL Server. <br><br>  Para mostrar el indicador en un sistema de monitoreo (por ejemplo, Zabbix), puede crear la siguiente consulta: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([runnable_tasks_count]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [runnable_tasks_count] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.dm_os_schedulers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduler_id&lt;<span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre><br>  En función de la dinámica de los valores obtenidos para este indicador, podemos concluir si hay suficiente tiempo de procesador (el número de núcleos de CPU) para una instancia de MS SQL Server. <br>  Sin embargo, es importante recordar el hecho de que las solicitudes mismas pueden solicitar varios subprocesos a la vez.  Y a veces el optimizador no puede evaluar correctamente la complejidad de la solicitud en sí.  Entonces, a la solicitud se le pueden asignar demasiados hilos que en un momento dado no se pueden procesar simultáneamente.  Y esto también provoca un tipo de espera asociado con la falta de tiempo de procesador y el crecimiento de la cola para los planificadores que usan núcleos de CPU específicos, es decir, el indicador runnable_tasks_count crecerá en tales condiciones. <br><br>  En este caso, antes de aumentar el número de núcleos de CPU, debe configurar correctamente las propiedades de paralelismo de la instancia de MS SQL Server y, a partir de la versión 2016, configurar correctamente las propiedades de paralelismo de las bases de datos requeridas: <br><br><img src="https://habrastorage.org/webt/iu/dz/ul/iudzulebjpipajxjwgxc9vkgoka.png"><br><br><img src="https://habrastorage.org/webt/7u/pk/qf/7upkqfeuffvrmi98yx5bid3h3wm.png"><br><br>  Aquí vale la pena prestar atención a los siguientes parámetros: <br><br><ol><li>  Grado máximo de paralelismo: establece el número máximo de subprocesos que se pueden asignar a cada solicitud (el valor predeterminado es la restricción 0 solo para el sistema operativo y la edición MS SQL Server) </li><li>  Umbral de costo para paralelismo: costo estimado de paralelismo (el valor predeterminado es 5) </li><li>  Max DOP establece el número máximo de subprocesos que se pueden asignar a cada consulta en el nivel de la base de datos (pero no más que el valor de la propiedad "Grado máximo de paralelismo") (el valor predeterminado es la restricción 0 solo para el sistema operativo y la edición MS SQL Server, así como la restricción en la propiedad "Grado máximo de paralelismo" de toda la instancia de MS SQL Server) </li></ol><br>  Es imposible dar una receta igualmente buena para todos los casos, es decir, necesita analizar solicitudes difíciles. <br><br>  Desde mi propia experiencia, recomiendo el siguiente algoritmo de acciones para sistemas OLTP para configurar propiedades de paralelismo: <br><br><ol><li>  primero prohibir la concurrencia estableciendo el nivel de toda la instancia de Max Degree of Parallelism en 1 </li><li>  analizar las solicitudes más difíciles y elegir el número óptimo de hilos para ellas </li><li>  establezca el Grado máximo de paralelismo en el número óptimo seleccionado de subprocesos obtenidos del elemento 2, y para bases de datos específicas establezca el valor DOP máximo obtenido del elemento 2 para cada base de datos </li><li>  Analice las solicitudes más difíciles e identifique el efecto negativo del subprocesamiento múltiple.  Si es así, aumente el umbral de costo para paralelismo. <br>  Para sistemas como 1C, Microsoft CRM y Microsoft NAV, en la mayoría de los casos, la prohibición de subprocesamiento múltiple es adecuada. </li></ol><br>  Además, si se instala la edición Standard, en la mayoría de los casos la prohibición de subprocesos múltiples es adecuada en vista del hecho de que esta edición está limitada por el número de núcleos de CPU. <br><br>  Para los sistemas OLAP, el algoritmo descrito anteriormente no es adecuado. <br><br>  Desde mi propia experiencia, recomiendo el siguiente algoritmo de acciones para sistemas OLAP para establecer propiedades de paralelismo: <br><br><ol><li>  analizar las solicitudes más difíciles y elegir el número óptimo de hilos para ellas </li><li>  establezca el Grado máximo de paralelismo en el número óptimo seleccionado de subprocesos obtenidos del elemento 1, y también para bases de datos específicas establezca el valor DOP máximo obtenido del elemento 1 para cada base de datos </li><li>  analizar las solicitudes más difíciles e identificar el efecto negativo del límite de concurrencia.  Si es así, reduzca el Umbral de costo para el valor de paralelismo o repita los pasos 1-2 de este algoritmo </li></ol><br>  Es decir, para sistemas OLTP pasamos de subprocesos simples a subprocesos múltiples, y para sistemas OLAP, por el contrario, pasamos de subprocesos múltiples a subprocesos simples.  Por lo tanto, es posible seleccionar la configuración de concurrencia óptima tanto para una base de datos específica como para toda la instancia de MS SQL Server. <br>  También es importante comprender que la configuración de las propiedades de concurrencia debe cambiarse con el tiempo en función de los resultados de la supervisión del rendimiento de MS SQL Server. <br><br><h3>  Recomendaciones para establecer marcas de seguimiento </h3><br>  Desde mi propia experiencia y la experiencia de mis colegas, recomiendo configurar los siguientes indicadores de seguimiento en el nivel de inicio del servicio MS SQL Server para las versiones 2008-2016 para un rendimiento óptimo: <br><br><ol><li>  610 - Reducción del registro de inserciones en tablas indexadas.  Puede ayudar con las inserciones en tablas con una gran cantidad de registros y muchas transacciones, con frecuentes expectativas largas de WRITELOG para cambios en los índices </li><li>  1117 - Si un archivo en un grupo de archivos cumple con el umbral de crecimiento automático, todos los archivos en el grupo de archivos se expanden </li><li>  1118: fuerza que todos los objetos se ubiquen en diferentes extensiones (prohibición de extensiones mixtas), lo que minimiza la necesidad de escanear la página SGAM, que se utiliza para rastrear extensiones mixtas </li><li>  1224: deshabilita la escalada de bloqueo en función del número de bloqueos.  El uso excesivo de memoria puede incluir la escalada de bloqueo. </li><li>  2371: cambia el umbral para las actualizaciones de estadísticas automáticas fijas al umbral para las actualizaciones de estadísticas automáticas dinámicas.  Es importante actualizar los planes de consulta para tablas grandes donde determinar incorrectamente el número de registros conduce a planes de ejecución erróneos. </li><li>  3226 - Suprime los mensajes de respaldo exitosos en el registro de errores </li><li>  4199: incluye cambios en el optimizador de consultas publicados en la actualización acumulativa y los paquetes de servicio de SQL Server </li><li>  6532-6534: incluye un rendimiento de consulta mejorado para tipos de datos espaciales </li><li>  8048 - Convierte objetos de memoria particionados NUMA en particiones de CPU </li><li>  8780: habilita la asignación de tiempo adicional para programar una solicitud.  Algunas solicitudes sin este indicador pueden rechazarse porque no tienen un plan de solicitud (error muy raro) </li><li>  9389: incluye un búfer de memoria dinámico adicional provisto temporalmente para operadores en modo por lotes, que permite al operador en modo por lotes solicitar memoria adicional y evitar transferir datos a tempdb si hay memoria adicional disponible </li></ol><br>  Antes de la versión 2016, es útil incluir el indicador de seguimiento 2301, que incluye la optimización del soporte de decisiones ampliado y, por lo tanto, ayuda a elegir planes de consulta más correctos.  Sin embargo, a partir de la versión 2016, a menudo tiene un efecto negativo en un tiempo de ejecución de consulta general bastante largo. <br><br>  Además, para sistemas en los que hay muchos índices (por ejemplo, para bases de datos 1C), le recomiendo que habilite el indicador de traza 2330, que deshabilita la recopilación sobre el uso de índices, que generalmente tiene un efecto positivo en el sistema. <br><br>  Obtenga más información sobre las marcas de seguimiento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Usando el enlace anterior, también es importante considerar las versiones y ensamblajes de MS SQL Server, porque para las versiones más nuevas, algunos indicadores de rastreo están habilitados de manera predeterminada o no tienen ningún efecto.  Por ejemplo, en la versión 2017, es relevante establecer solo los siguientes 5 indicadores de seguimiento: 1224, 3226, 6534, 8780 y 9389. <br><br>  Puede habilitar o deshabilitar el indicador de rastreo utilizando los comandos DBCC TRACEON y DBCC TRACEOFF, respectivamente.  Ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí para</a> más detalles. <br><br>  Puede obtener el estado de las marcas de rastreo con el comando DBCC TRACESTATUS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más</a> . <br><br>  Para que los indicadores de seguimiento se incluyan en la ejecución automática del servicio MS SQL Server, debe ir al Administrador de configuración de SQL Server y agregar estos indicadores de seguimiento en las propiedades del servicio a través de -T: <br><br><img src="https://habrastorage.org/webt/nt/oe/l7/ntoel7jpaujursvrp07tvcbnw80.png"><br><br><h3>  Resumen </h3><br>  En este artículo, se examinaron algunos aspectos de la supervisión de MS SQL Server, con la ayuda de los cuales puede identificar rápidamente la falta de RAM y tiempo libre de CPU, así como una serie de otros problemas menos obvios.  Se consideraron los indicadores de rastreo más utilizados. <br><br><h3>  Fuentes </h3><br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estadísticas en espera de SQL Server</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estadísticas de expectativas de SQL Server o dígame dónde le duele</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vista del sistema sys.dm_os_schedulers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usando Zabbix para rastrear la base de datos MS SQL Server</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estilo de vida SQL</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Trazar banderas</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sql.ru</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448044/">https://habr.com/ru/post/448044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448032/index.html">Más robots: Walmart presenta miles de máquinas para operar en sus tiendas</a></li>
<li><a href="../448034/index.html">Búsqueda de tareas en JIRA (lenguaje simple). Parte 1: Búsqueda rápida y básica</a></li>
<li><a href="../448036/index.html">Importar a J. Connect desde el archivo de lista de usuarios a través de API</a></li>
<li><a href="../448038/index.html">Nuevas características para autores de extensiones en Visual Studio 2019 v.16.1</a></li>
<li><a href="../448040/index.html">El resumen de materiales interesantes para el desarrollador móvil # 294 (del 8 al 14 de abril)</a></li>
<li><a href="../448046/index.html">Radio Day: patentes de Marconi y Popov</a></li>
<li><a href="../448048/index.html">Comprensión de la hiedra angular: DOM incremental y DOM virtual</a></li>
<li><a href="../448050/index.html">Holografía amateur: materiales de haluro de plata</a></li>
<li><a href="../448052/index.html">Mikrotik IPSEC vpn para NAT como cliente</a></li>
<li><a href="../448054/index.html">SciPy, optimización con condiciones.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>