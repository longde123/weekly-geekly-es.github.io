<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♋️ 🏽 🧑🏿‍🤝‍🧑🏽 OutOfLine - padrão na memória para aplicativos C ++ de alto desempenho ☝🏻 👩🏿‍💼 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enquanto trabalhava na Headlands Technologies, tive a sorte de escrever vários utilitários para simplificar a criação de código C ++ de alto desempenh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OutOfLine - padrão na memória para aplicativos C ++ de alto desempenho</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421475/"><p> Enquanto trabalhava na Headlands Technologies, tive a sorte de escrever vários utilitários para simplificar a criação de código C ++ de alto desempenho.  Este artigo oferece uma visão geral de um desses utilitários, <a href=""><code>OutOfLine</code></a> . </p><a name="habracut"></a><br><p>  Vamos começar com um exemplo ilustrativo.  Suponha que você tenha um sistema que lide com um grande número de objetos do sistema de arquivos.  Podem ser arquivos comuns, denominados soquetes ou tubos UNIX.  Por algum motivo, você abre muitos descritores de arquivos na inicialização, depois trabalha intensamente com eles e, no final, fecha os descritores e exclui os links dos arquivos (aprox. A faixa significa a função <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">desvincular</a> ). </p><br><p>  A versão inicial (simplificada) pode ser assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : path(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD() { close(fd); unlink(path.c_str()); } UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  E esse é um bom design, logicamente correto.  Ele conta com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RAII</a> para liberar automaticamente o descritor e remover o link.  Você pode criar uma grande variedade desses objetos, trabalhar com eles e, quando a matriz deixar de existir, os próprios objetos limparão tudo o que era necessário no processo. </p><br><p>  Mas e o desempenho?  Suponha que <code>fd</code> usado com muita frequência e <code>path</code> somente ao excluir um objeto.  Agora a matriz consiste em objetos de tamanho 40 bytes, mas geralmente apenas 4 bytes são usados.  Isso significa que haverá mais erros no cache, porque você precisa "pular" 90% dos dados. </p><br><p>  Uma das soluções comuns para esse problema é a transição de uma matriz de estruturas para uma estrutura de matriz.  Isso fornecerá o desempenho desejado, mas ao custo de abandonar o RAII.  Existe uma opção que combine as vantagens de ambas as abordagens? </p><br><p>  Um compromisso simples seria substituir <code>std::string</code> tamanho de 32 bytes por <code>std::unique_ptr&lt;std::string&gt;</code> , cujo tamanho é de apenas 8 bytes.  Isso reduzirá o tamanho do nosso objeto de 40 bytes para 16 bytes, o que é uma grande conquista.  Mas essa solução ainda perde ao usar várias matrizes. </p><br><p>  <code>OutOfLine</code> é uma ferramenta que permite, sem abandonar o RAII, mover completamente os campos raramente usados ​​(frios) para fora do objeto.  OutOfLine é usado como uma classe base <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRTP</a> , portanto, o primeiro argumento para o modelo deve ser uma classe filho.  O segundo argumento é o tipo de dados raramente usados ​​(frios) associados a um objeto (principal) usado com frequência. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD(); UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Então, como é essa classe? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColdData</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class"> {</span></span></code> </pre> <br><p>  A idéia básica de implementação é usar um contêiner associativo global que mapeie ponteiros para objetos principais e ponteiros para objetos que contêm dados frios. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;ColdData&gt;&gt; global_map_;</code> </pre> <br><p>  <code>OutOfLine</code> pode ser usado com qualquer tipo de dados frios, cuja instância é criada e associada ao objeto principal automaticamente. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); }</code> </pre> <br><p>  A remoção do objeto principal implica a remoção automática do objeto frio associado: </p><br><pre> <code class="cpp hljs"> ~OutOfLine() { global_map_.erase(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>  Ao mover (mover construtor / operador de atribuição de movimento) do objeto principal, o objeto frio correspondente será automaticamente associado ao novo objeto sucessor principal.  Como resultado, você não deve acessar os dados frios de um objeto movido de. </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutOfLine&amp;&amp; other)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = other; } OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine&amp;&amp; other) { global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(global_map_[&amp;other]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  No exemplo de implementação <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acima</a> , o <code>OutOfLine</code> é tornado impossível de copiar por simplicidade.  Se necessário, é fácil adicionar operações de cópia; elas apenas precisam criar e vincular uma cópia de um objeto frio. </p><br><pre> <code class="cpp hljs">OutOfLine(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br><p>  Agora, para que isso seja realmente útil, seria bom ter acesso a dados frios.  Ao herdar de <code>OutOfLine</code> classe recebe os métodos constantes e não constantes de <code>cold()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ColdData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; } <span class="hljs-function"><span class="hljs-function">ColdData </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; }</code> </pre> <br><p>  Eles retornam o tipo apropriado de referência para dados frios. </p><br><p>  Isso é quase tudo.  Essa opção <code>UnlinkingFD</code> terá 4 bytes de tamanho, fornecerá acesso amigável ao cache ao campo <code>fd</code> e manterá os benefícios do RAII.  Todo o trabalho relacionado ao ciclo de vida de um objeto é totalmente automatizado.  Quando o objeto principal usado com frequência é movido, dados frios raramente usados ​​são movidos com ele.  Quando o objeto principal é excluído, o objeto frio correspondente também é excluído. </p><br><p>  Às vezes, no entanto, seus dados são conspirados para complicar sua vida - e você se depara com uma situação em que os dados básicos devem ser criados primeiro.  Por exemplo, eles são necessários para construir dados frios.  É necessário criar objetos na ordem inversa em relação ao que o <code>OutOfLine</code> oferece.  Para esses casos, um "backup" é útil para controlarmos a ordem de inicialização e de inicialização. </p><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoPhaseInit</span></span></span><span class="hljs-class"> {</span></span>}; OutOfLine(TwoPhaseInit){} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_cold_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_.find(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;second = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release_cold_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>].reset(); }</code> </pre> <br><p>  Este é outro construtor <code>OutOfLine</code> que pode ser usado em classes filho; ele aceita uma tag do tipo <code>TwoPhaseInit</code> .  Se você criar o <code>OutOfLine</code> dessa maneira, os dados frios não serão inicializados e o objeto permanecerá parcialmente construído.  Para concluir a construção de duas fases, você precisa chamar o método <code>init_cold_data</code> (transmitindo os argumentos necessários para criar um objeto do tipo <code>ColdData</code> ).  Lembre-se de que você não pode chamar <code>.cold()</code> em um objeto cujos dados frios ainda não foram inicializados.  Por analogia, os dados frios podem ser excluídos antes do agendamento antes de executar o <code>~OutOfLine</code> chamando <code>release_cold_data</code> . </p><br><pre> <code class="cpp hljs">}; <span class="hljs-comment"><span class="hljs-comment">// end of class OutOfLine</span></span></code> </pre> <br><p>  Agora é tudo.  Então, o que essas 29 linhas de código nos fornecem?  Eles são outra troca possível entre desempenho e facilidade de uso.  Nos casos em que você tem um objeto, alguns dos quais membros são usados ​​com muito mais frequência do que outros, o <code>OutOfLine</code> pode servir como uma maneira fácil de otimizar o cache, com o custo de diminuir significativamente o acesso a dados raramente usados. </p><br><p>  Conseguimos aplicar essa técnica em vários locais - muitas vezes há a necessidade de suplementar dados de trabalho usados ​​intensivamente com metadados adicionais necessários no final do trabalho, em situações raras ou inesperadas.  Sejam as informações sobre os usuários que estabeleceram a conexão, do terminal de negociação do qual o pedido veio ou o identificador do acelerador de hardware envolvido no processamento de dados de troca - o <code>OutOfLine</code> manterá o cache limpo quando você estiver na parte crítica dos cálculos (caminho crítico). </p><br><p>  Eu preparei um <a href="">teste</a> para que você possa ver e avaliar a diferença. </p><br><table><thead><tr><th>  O script </th><th>  Tempo (ns) </th></tr></thead><tbody><tr><td>  Dados frios no objeto principal (versão inicial) </td><td>  34684547 </td></tr><tr><td>  Dados frios completamente excluídos (melhor cenário) </td><td>  2938327 </td></tr><tr><td>  Usando OutOfLine </td><td>  2947645 </td></tr></tbody></table><br><p>  Eu obtive uma aceleração de cerca de <code>OutOfLine</code> ao usar o <code>OutOfLine</code> .  Obviamente, esse teste foi projetado para demonstrar o potencial do <code>OutOfLine</code> , mas também mostra quanto da otimização de cache pode ter um impacto significativo no desempenho, assim como o <code>OutOfLine</code> permite obter essa otimização.  Manter o cache livre de dados raramente usados ​​pode fornecer aprimoramentos complexos, mensuráveis ​​e abrangentes ao restante do código.  Como sempre com a otimização, confie em medições mais do que suposições, no entanto, espero que o <code>OutOfLine</code> seja uma ferramenta útil na sua coleção de utilitários. </p><br><h2 id="primechanie-ot-perevodchika">  <em>Nota do tradutor</em> </h2><br><p>  <em>O código fornecido no artigo serve para demonstrar a ideia e não é representativo do código de produção.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421475/">https://habr.com/ru/post/pt421475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421465/index.html">DevOps para celular na prática</a></li>
<li><a href="../pt421467/index.html">Desenvolvimento de um robô para coletar bolas de golfe</a></li>
<li><a href="../pt421469/index.html">O Telegram concordou em transferir para os serviços IP [mas não para o russo] endereços IP e números de alguns usuários</a></li>
<li><a href="../pt421471/index.html">Ad Exchange Server - Diferente de outros</a></li>
<li><a href="../pt421473/index.html">O que são corotinas em Kotlin?</a></li>
<li><a href="../pt421477/index.html">O que está escrito no arquivo .ssh / known_hosts</a></li>
<li><a href="../pt421481/index.html">Microfones, capturas de tela e vídeo local: como o SDK da Web Voximplant controla a mídia em um navegador</a></li>
<li><a href="../pt421485/index.html">Aviso importante para usuários do Gitlab Pages</a></li>
<li><a href="../pt421487/index.html">Como fortalecer o suporte técnico - 6 maneiras secretas</a></li>
<li><a href="../pt421489/index.html">Grunhir, mas dar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>