<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèΩ üåü üé© Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 1 üï† üëè üï∫üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya primera parte de la traducci√≥n publicamos hoy, discutir√° c√≥mo el motor V8 JavaScript selecciona las mejores formas de representar va...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467247/">  El material, cuya primera parte de la traducci√≥n publicamos hoy, discutir√° c√≥mo el motor V8 JavaScript selecciona las mejores formas de representar varios valores JS en la memoria, y c√≥mo esto afecta los mecanismos internos de V8 con respecto al trabajo con los llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formularios. objetos</a> (forma).  Todo esto nos ayudar√° a resolver la esencia del reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de rendimiento de React</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/pu/wk/8i/puwk8ihuo_in6vqmeg86j2-5sxa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tipos de datos de JavaScript</font> </h2><br>  Cada valor de JavaScript puede tener solo uno de los ocho tipos de datos existentes: <code>Number</code> , <code>String</code> , <code>Symbol</code> , <code>BigInt</code> , <code>Boolean</code> , <code>Undefined</code> , <code>Null</code> y <code>Object</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/5e0/3fb/36e5e03fb481b601d2bb1cc61a1fa2f4.png"></div><br>  <i><font color="#999999">Tipos de datos de JavaScript</font></i> <br><br>  El tipo de valor se puede determinar utilizando el operador <code>typeof</code> , pero hay una excepci√≥n importante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number' typeof 'foo'; // 'string' typeof Symbol('bar'); // 'symbol' typeof 42n; // 'bigint' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' -   ,     typeof { x: 42 }; // 'object'</span></span></code> </pre> <br>  Como puede ver, el comando <code>typeof null</code> devuelve <code>'object'</code> , no <code>'null'</code> , a pesar de que <code>null</code> tiene su propio tipo: <code>Null</code> .  Para comprender la raz√≥n de este tipo de comportamiento, tenemos en cuenta el hecho de que el conjunto de todos los tipos de JavaScript se puede dividir en dos grupos: <br><br><ul><li>  Objetos (es decir, tipo <code>Object</code> ). </li><li>  Valores primitivos (es decir, cualquier valor no objetivo). </li></ul><br>  A la luz de este conocimiento, resulta que <code>null</code> significa "sin valor de objeto", mientras que <code>undefined</code> significa "sin valor". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/8e6/c97/0e98e6c97b3e87411146a60f1c67cf8e.png"></div><br>  <i><font color="#999999">Valores primitivos, objetos, nulos e indefinidos</font></i> <br><br>  Siguiendo estas reflexiones en el esp√≠ritu de Java, Brendan Eich dise√±√≥ JavaScript para que el operador <code>typeof</code> devolviera <code>'object'</code> para los valores de esos tipos que se encuentran en la figura anterior a la derecha.  Todos los valores de objeto y <code>null</code> llegan aqu√≠.  Es por eso que la expresi√≥n <code>typeof null === 'object'</code> es verdadera, aunque hay un tipo separado <code>Null</code> en la especificaci√≥n del lenguaje. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/df7/0e2/23edf70e2101cc687a759653f150305d.png"></div><br>  <i><font color="#999999">La expresi√≥n typeof v === 'objeto' es verdadera</font></i> <br><br><h2>  <font color="#3AC1EF">Representaci√≥n de valores</font> </h2><br>  Los motores de JavaScript deber√≠an poder representar cualquier valor de JavaScript en la memoria.  Sin embargo, es importante tener en cuenta que los tipos de valores en JavaScript est√°n separados de c√≥mo los representan los motores JS en la memoria. <br><br>  Por ejemplo, un valor de 42 en JavaScript es de tipo <code>number</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number'</span></span></code> </pre> <br>  Hay varias formas de representar enteros como 42 en la memoria: <br><div class="scrollable-table"><table><tbody><tr><td>  Sumisi√≥n <br></td><td>  Pedacitos <br></td></tr><tr><td>  8 bits, adem√°s de dos <br></td><td>  0010 1010 <br></td></tr><tr><td>  32 bits, con adici√≥n de hasta dos <br></td><td>  0000 0000 0000 0000 0000 0000 0010 1010 <br></td></tr><tr><td>  Paquete decimal codificado en binario (BCD) <br></td><td>  0100 0010 <br></td></tr><tr><td>  32 bits, n√∫mero de coma flotante IEEE-754 <br></td><td>  0100 0010 0010 1000 0000 0000 0000 0000 <br></td></tr><tr><td>  64 bits, n√∫mero de coma flotante IEEE-754 <br></td><td>  0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 <br></td></tr></tbody></table></div><br>  Seg√∫n el est√°ndar ECMAScript, los n√∫meros son valores de coma flotante de 64 bits, conocidos como n√∫meros de coma flotante de doble precisi√≥n (Float64).  Sin embargo, esto no significa que los motores de JavaScript siempre almacenen n√∫meros en una vista Float64.  ¬°Eso ser√≠a muy, muy ineficiente!  Los motores pueden usar otras representaciones internas de n√∫meros, siempre que el comportamiento de los valores coincida exactamente con el comportamiento de los n√∫meros Float64. <br><br>  La mayor√≠a de los n√∫meros en aplicaciones JS reales, como result√≥, son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√≠ndices de</a> matriz ECMAScript v√°lidos.  Es decir, enteros en el rango de 0 a 2 <sup>32</sup> -2. <br><br><pre> <code class="javascript hljs">array[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      . array[42]; array[2**32-2]; //      .</span></span></code> </pre> <br>  Los motores de JavaScript pueden elegir el formato √≥ptimo para representar dichos valores en la memoria.  Esto se hace para optimizar el c√≥digo que funciona con elementos de matriz mediante √≠ndices.  Un procesador que realiza operaciones de acceso a memoria necesita que los √≠ndices de la matriz est√©n disponibles como n√∫meros almacenados en una vista con una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">suma de dos</a> .  Si, en cambio, representamos los √≠ndices de las matrices en forma de valores Float64, esto significar√≠a un desperdicio de recursos del sistema, ya que el motor necesitar√≠a convertir los n√∫meros Float64 a un formato con la suma de dos y viceversa cada vez que alguien acceda a un elemento de la matriz. <br><br>  La representaci√≥n de n√∫meros de 32 bits con la adici√≥n de hasta dos es √∫til no solo para optimizar el trabajo con matrices.  En general, se puede observar que el procesador realiza operaciones enteras mucho m√°s r√°pido que las operaciones que utilizan valores de punto flotante.  Es por eso que en el siguiente ejemplo, el primer ciclo sin problemas es el doble de r√°pido en comparaci√≥n con el segundo ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; ++i) {  <span class="hljs-comment"><span class="hljs-comment">//  } for (let i = 0.1; i &lt; 1000.1; ++i) {  //  }</span></span></code> </pre> <br>  Lo mismo se aplica a los c√°lculos que utilizan operadores matem√°ticos. <br><br>  Por ejemplo, el desempe√±o del operador de tomar el resto de la divisi√≥n del siguiente fragmento de c√≥digo depende de qu√© n√∫meros est√©n involucrados en los c√°lculos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = value % divisor; <span class="hljs-comment"><span class="hljs-comment">//  -  `value`  `divisor`   , //    .</span></span></code> </pre> <br>  Si ambos operandos est√°n representados por enteros, entonces el procesador puede calcular el resultado de manera muy eficiente.  Hay una optimizaci√≥n adicional en V8 para los casos en que el operando <code>divisor</code> est√° representado por un n√∫mero que es una potencia de dos.  Para los valores representados como n√∫meros de coma flotante, los c√°lculos son mucho m√°s complicados y toman mucho m√°s tiempo. <br><br>  Dado que las operaciones de enteros generalmente se realizan mucho m√°s r√°pido que las operaciones en valores de punto flotante, podr√≠a parecer que los motores simplemente pueden almacenar todos los enteros y todos los resultados de las operaciones de enteros en un formato con una suma de dos.  Desafortunadamente, este enfoque violar√≠a la especificaci√≥n ECMAScript.  Como ya se mencion√≥, el est√°ndar proporciona la representaci√≥n de n√∫meros en el formato Float64, y algunas operaciones con n√∫meros enteros pueden dar lugar a la aparici√≥n de resultados en forma de n√∫meros de punto flotante.  Es importante que en tales situaciones, los motores JS produzcan resultados correctos. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Float64   53-  . //         . 2**53 === 2**53+1; // true // Float64   ,   -1 * 0   -0,  //           . -1*0 === -0; // true // Float64   Infinity,   , //     . 1/0 === Infinity; // true -1/0 === -Infinity; // true // Float64    NaN. 0/0 === NaN;</span></span></code> </pre> <br>  Aunque en el ejemplo anterior todos los n√∫meros en el lado izquierdo de las expresiones son enteros, todos los n√∫meros en el lado derecho de las expresiones son valores de coma flotante.  Es por eso que ninguna de las operaciones anteriores se puede realizar correctamente utilizando un formato de 32 bits con una adici√≥n de hasta dos.  Los motores de JavaScript deben prestar especial atenci√≥n para garantizar que, al realizar operaciones con enteros, obtenga los resultados de Float64 correctos (aunque capaces de parecer inusuales, como en el ejemplo anterior). <br><br>  En el caso de los enteros peque√±os que caen dentro del rango de la representaci√≥n de 31 bits de los enteros con signo, V8 usa una representaci√≥n especial llamada <code>Smi</code> .  Todo lo que no sea un valor <code>Smi</code> se representa como un valor <code>HeapObject</code> , que es la direcci√≥n de alguna entidad en la memoria.  Para los n√∫meros que no entran en el rango <code>Smi</code> , tenemos un tipo especial de <code>HeapObject</code> : el llamado <code>HeapNumber</code> . <br><br><pre> <code class="javascript hljs">-<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> <span class="hljs-comment"><span class="hljs-comment">// HeapNumber -(2**30)-1 // HeapNumber  -(2**30) // Smi       -42 // Smi        -0 // HeapNumber         0 // Smi       4.2 // HeapNumber        42 // Smi   2**30-1 // Smi     2**30 // HeapNumber  Infinity // HeapNumber       NaN // HeapNumber</span></span></code> </pre> <br>  Como puede ver en el ejemplo anterior, algunos n√∫meros JS se representan como <code>Smi</code> y otros como <code>HeapNumber</code> .  El motor V8 est√° optimizado en t√©rminos de procesamiento de n√∫meros <code>Smi</code> .  El hecho es que los enteros peque√±os son muy comunes en los programas JS reales.  Cuando se trabaja con valores <code>Smi</code> , no es necesario asignar memoria para entidades individuales.  Su uso, adem√°s, le permite realizar operaciones r√°pidas con enteros. <br><br><h2>  <font color="#3AC1EF">Comparaci√≥n de Smi, HeapNumber y MutableHeapNumber</font> </h2><br>  Hablemos de c√≥mo se ve la estructura interna de estos mecanismos.  Supongamos que tenemos el siguiente objeto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Smi  y: 4.2, // HeapNumber };</span></span></code> </pre> <br>  El valor 42 de la propiedad del objeto <code>x</code> est√° codificado como <code>Smi</code> .  Esto significa que se puede almacenar dentro del propio objeto.  Para almacenar el valor 4.2, por otro lado, necesitar√° crear una entidad separada.  En el objeto, habr√° un enlace a esta entidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/116/718/f34/116718f3426bccd613dd35dc95be9739.png"></div><br>  <i><font color="#999999">Almacenamiento de varios valores.</font></i> <br><br>  Supongamos que estamos ejecutando el siguiente c√≥digo JavaScript: <br><br><pre> <code class="javascript hljs">ox += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ox   52 oy += 1; // oy   5.2</span></span></code> </pre> <br>  En este caso, el valor de la propiedad <code>x</code> se puede actualizar en su ubicaci√≥n de almacenamiento.  El hecho es que el nuevo valor de <code>x</code> es 52, y este n√∫mero se encuentra dentro del rango de <code>Smi</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/400/d42/4d8400d42a2046c9727d4ff76ad2b483.png"></div><br>  <i><font color="#999999">El nuevo valor de la propiedad x se almacena donde se almacen√≥ el valor anterior.</font></i> <br><br>  Sin embargo, el nuevo valor de <code>y</code> , 5.2, no encaja en el rango de <code>Smi</code> y, adem√°s, difiere del valor anterior de y - 4.2.  Como resultado, V8 tiene que asignar memoria para la nueva entidad <code>HeapNumber</code> y referenciarla desde el objeto ya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/ecf/095/9baecf0951766c6e2781b552593b6b94.png"></div><br>  <i><font color="#999999">Nueva entidad HeapNumber para almacenar el nuevo valor y</font></i> <br><br>  <code>HeapNumber</code> entidades <code>HeapNumber</code> son inmutables.  Esto le permite implementar algunas optimizaciones.  Supongamos que queremos establecer la propiedad del objeto <code>x</code> valor de la propiedad <code>y</code> : <br><br><pre> <code class="javascript hljs">ox = oy; <span class="hljs-comment"><span class="hljs-comment">// ox   5.2</span></span></code> </pre> <br>  Al realizar esta operaci√≥n, podemos referirnos a la misma entidad <code>HeapNumber</code> y no asignar memoria adicional para almacenar el mismo valor. <br><br>  Una de las desventajas de la inmunidad de las entidades HeapNuber es que la actualizaci√≥n frecuente de campos con valores fuera del rango <code>Smi</code> es lenta.  Esto se demuestra en el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   `HeapNumber`. const o = { x: 0.1 }; for (let i = 0; i &lt; 5; ++i) {  //    `HeapNumber`.  ox += 1; }</span></span></code> </pre> <br>  Al procesar la primera l√≠nea, se crea una instancia de <code>HeapNumber</code> , cuyo valor inicial es 0.1.  En el cuerpo del ciclo, este valor cambia a 1.1, 2.1, 3.1, 4.1 y finalmente a 5.1.  Como resultado, en el proceso de ejecuci√≥n de este c√≥digo, <code>HeapNumber</code> 6 instancias de <code>HeapNumber</code> , cinco de las cuales estar√°n sujetas a operaciones de recolecci√≥n de basura despu√©s de completar el ciclo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/7e2/8f1/d107e28f181bf1eaf1fd57765bdfe49f.png"></div><br>  <i><font color="#999999">HeapNumber Entities</font></i> <br><br>  Para evitar este problema, V8 tiene optimizaci√≥n, que es un mecanismo para actualizar campos num√©ricos cuyos valores no se ajustan al rango <code>Smi</code> en los mismos lugares donde ya est√°n almacenados.  Si un campo num√©rico almacena valores para los cuales la entidad <code>Smi</code> no <code>Smi</code> adecuada para el almacenamiento, entonces V8, en forma de objeto, marca este campo como <code>Double</code> y asigna memoria para la entidad <code>MutableHeapNumber</code> , que almacena el valor real representado en el formato Float64. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a17/c42/466/a17c42466cde98778836809e09df4da6.png"></div><br>  <i><font color="#999999">Uso de entidades MutableHeapNumber</font></i> <br><br>  Como resultado, despu√©s de que el valor del campo cambia, V8 ya no necesita asignar memoria para la nueva entidad <code>HeapNumber</code> .  En cambio, simplemente escriba el nuevo valor en una entidad <code>MutableHeapNumber</code> existente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/3bd/d1c/c863bdd1c81213b080d86bed079e9e5f.png"></div><br>  <i><font color="#999999">Escribir un nuevo valor en MutableHeapNumber</font></i> <br><br>  Sin embargo, este enfoque tiene sus inconvenientes.  Es decir, dado que los valores de <code>MutableHeapNumber</code> pueden cambiar, es importante asegurarse de que el sistema funcione de tal manera que estos valores se comporten seg√∫n lo dispuesto en la especificaci√≥n del lenguaje. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/be3/8ca/176be38cad03b4e4ab2881d7a9b67bfd.png"></div><br>  <i><font color="#999999">Desventajas de MutableHeapNumber</font></i> <br><br>  Por ejemplo, si asigna el valor de <code>ox</code> alguna otra variable <code>y</code> , entonces es necesario que el valor de <code>y</code> no cambie con un cambio posterior en <code>ox</code> .  ¬°Eso ser√≠a una violaci√≥n de la especificaci√≥n de JavaScript!  Como resultado, al acceder a <code>ox</code> , el n√∫mero debe volverse a empaquetar con el valor habitual de <code>HeapNumber</code> antes de que se le asigne <code>y</code> . <br><br>  En el caso de los n√∫meros de coma flotante, V8 realiza las operaciones de empaquetado anteriores utilizando sus mecanismos internos.  Pero en el caso de los enteros peque√±os, usar <code>MutableHeapNumber</code> ser√≠a una p√©rdida de tiempo, porque <code>Smi</code> es una forma m√°s eficiente de representar tales n√∫meros. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""  `x`    object.x += 1; //   `x`  </span></span></code> </pre> <br>  Para evitar el uso ineficiente de los recursos del sistema, todo lo que necesitamos hacer para trabajar con enteros peque√±os es marcar los campos correspondientes en las formas de los objetos como <code>Smi</code> .  Como resultado, los valores de estos campos, siempre que correspondan al rango <code>Smi</code> , se pueden actualizar directamente dentro de los objetos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6a/d23/b96/b6ad23b9635e31d8f695d7170b8d3d7c.png"></div><br>  <i><font color="#999999">Trabaja con enteros cuyos valores caen dentro del rango de Smi</font></i> <br><br>  Continuar√° ... <br><br>  <b>Estimados lectores!</b>  ¬øHa encontrado problemas de rendimiento de JavaScript causados ‚Äã‚Äãpor las caracter√≠sticas del motor JS? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467247/">https://habr.com/ru/post/467247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467231/index.html">Presentamos Iniciar sesi√≥n con Apple en tu aplicaci√≥n iOS</a></li>
<li><a href="../467237/index.html">Eleve su servidor DNS sobre HTTPS</a></li>
<li><a href="../467239/index.html">La diferencia entre Data Scientist y un adolescente en un auto deportivo</a></li>
<li><a href="../467241/index.html">Carro para camiones ROS. Parte 4. Crear una simulaci√≥n de robot usando los editores rviz y gazebo</a></li>
<li><a href="../467245/index.html">Dmitry Matskevich, Dbrain: sobre el emprendimiento como una discapacidad mental, IA y seguridad emocional</a></li>
<li><a href="../467249/index.html">Una historia sobre V8, React y una ca√≠da en el rendimiento. Parte 2</a></li>
<li><a href="../467251/index.html">Rehenes COBOL y Matem√°ticas. Parte 1</a></li>
<li><a href="../467253/index.html">Rehenes COBOL y Matem√°ticas. Parte 2</a></li>
<li><a href="../467255/index.html">Tres errores de seguridad comunes que todo desarrollador de React debe conocer</a></li>
<li><a href="../467257/index.html">No guardes todos tus huevos en una canasta a la vez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>