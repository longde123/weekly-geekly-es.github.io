<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏽 🌟 🎩 Una historia sobre V8, React y una caída en el rendimiento. Parte 1 🕠 👏 🕺🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El material, cuya primera parte de la traducción publicamos hoy, discutirá cómo el motor V8 JavaScript selecciona las mejores formas de representar va...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una historia sobre V8, React y una caída en el rendimiento. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467247/">  El material, cuya primera parte de la traducción publicamos hoy, discutirá cómo el motor V8 JavaScript selecciona las mejores formas de representar varios valores JS en la memoria, y cómo esto afecta los mecanismos internos de V8 con respecto al trabajo con los llamados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formularios. objetos</a> (forma).  Todo esto nos ayudará a resolver la esencia del reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">problema de rendimiento de React</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/pu/wk/8i/puwk8ihuo_in6vqmeg86j2-5sxa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tipos de datos de JavaScript</font> </h2><br>  Cada valor de JavaScript puede tener solo uno de los ocho tipos de datos existentes: <code>Number</code> , <code>String</code> , <code>Symbol</code> , <code>BigInt</code> , <code>Boolean</code> , <code>Undefined</code> , <code>Null</code> y <code>Object</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36e/5e0/3fb/36e5e03fb481b601d2bb1cc61a1fa2f4.png"></div><br>  <i><font color="#999999">Tipos de datos de JavaScript</font></i> <br><br>  El tipo de valor se puede determinar utilizando el operador <code>typeof</code> , pero hay una excepción importante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number' typeof 'foo'; // 'string' typeof Symbol('bar'); // 'symbol' typeof 42n; // 'bigint' typeof true; // 'boolean' typeof undefined; // 'undefined' typeof null; // 'object' -   ,     typeof { x: 42 }; // 'object'</span></span></code> </pre> <br>  Como puede ver, el comando <code>typeof null</code> devuelve <code>'object'</code> , no <code>'null'</code> , a pesar de que <code>null</code> tiene su propio tipo: <code>Null</code> .  Para comprender la razón de este tipo de comportamiento, tenemos en cuenta el hecho de que el conjunto de todos los tipos de JavaScript se puede dividir en dos grupos: <br><br><ul><li>  Objetos (es decir, tipo <code>Object</code> ). </li><li>  Valores primitivos (es decir, cualquier valor no objetivo). </li></ul><br>  A la luz de este conocimiento, resulta que <code>null</code> significa "sin valor de objeto", mientras que <code>undefined</code> significa "sin valor". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e9/8e6/c97/0e98e6c97b3e87411146a60f1c67cf8e.png"></div><br>  <i><font color="#999999">Valores primitivos, objetos, nulos e indefinidos</font></i> <br><br>  Siguiendo estas reflexiones en el espíritu de Java, Brendan Eich diseñó JavaScript para que el operador <code>typeof</code> devolviera <code>'object'</code> para los valores de esos tipos que se encuentran en la figura anterior a la derecha.  Todos los valores de objeto y <code>null</code> llegan aquí.  Es por eso que la expresión <code>typeof null === 'object'</code> es verdadera, aunque hay un tipo separado <code>Null</code> en la especificación del lenguaje. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23e/df7/0e2/23edf70e2101cc687a759653f150305d.png"></div><br>  <i><font color="#999999">La expresión typeof v === 'objeto' es verdadera</font></i> <br><br><h2>  <font color="#3AC1EF">Representación de valores</font> </h2><br>  Los motores de JavaScript deberían poder representar cualquier valor de JavaScript en la memoria.  Sin embargo, es importante tener en cuenta que los tipos de valores en JavaScript están separados de cómo los representan los motores JS en la memoria. <br><br>  Por ejemplo, un valor de 42 en JavaScript es de tipo <code>number</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'number'</span></span></code> </pre> <br>  Hay varias formas de representar enteros como 42 en la memoria: <br><div class="scrollable-table"><table><tbody><tr><td>  Sumisión <br></td><td>  Pedacitos <br></td></tr><tr><td>  8 bits, además de dos <br></td><td>  0010 1010 <br></td></tr><tr><td>  32 bits, con adición de hasta dos <br></td><td>  0000 0000 0000 0000 0000 0000 0010 1010 <br></td></tr><tr><td>  Paquete decimal codificado en binario (BCD) <br></td><td>  0100 0010 <br></td></tr><tr><td>  32 bits, número de coma flotante IEEE-754 <br></td><td>  0100 0010 0010 1000 0000 0000 0000 0000 <br></td></tr><tr><td>  64 bits, número de coma flotante IEEE-754 <br></td><td>  0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 <br></td></tr></tbody></table></div><br>  Según el estándar ECMAScript, los números son valores de coma flotante de 64 bits, conocidos como números de coma flotante de doble precisión (Float64).  Sin embargo, esto no significa que los motores de JavaScript siempre almacenen números en una vista Float64.  ¡Eso sería muy, muy ineficiente!  Los motores pueden usar otras representaciones internas de números, siempre que el comportamiento de los valores coincida exactamente con el comportamiento de los números Float64. <br><br>  La mayoría de los números en aplicaciones JS reales, como resultó, son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">índices de</a> matriz ECMAScript válidos.  Es decir, enteros en el rango de 0 a 2 <sup>32</sup> -2. <br><br><pre> <code class="javascript hljs">array[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      . array[42]; array[2**32-2]; //      .</span></span></code> </pre> <br>  Los motores de JavaScript pueden elegir el formato óptimo para representar dichos valores en la memoria.  Esto se hace para optimizar el código que funciona con elementos de matriz mediante índices.  Un procesador que realiza operaciones de acceso a memoria necesita que los índices de la matriz estén disponibles como números almacenados en una vista con una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">suma de dos</a> .  Si, en cambio, representamos los índices de las matrices en forma de valores Float64, esto significaría un desperdicio de recursos del sistema, ya que el motor necesitaría convertir los números Float64 a un formato con la suma de dos y viceversa cada vez que alguien acceda a un elemento de la matriz. <br><br>  La representación de números de 32 bits con la adición de hasta dos es útil no solo para optimizar el trabajo con matrices.  En general, se puede observar que el procesador realiza operaciones enteras mucho más rápido que las operaciones que utilizan valores de punto flotante.  Es por eso que en el siguiente ejemplo, el primer ciclo sin problemas es el doble de rápido en comparación con el segundo ciclo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; ++i) {  <span class="hljs-comment"><span class="hljs-comment">//  } for (let i = 0.1; i &lt; 1000.1; ++i) {  //  }</span></span></code> </pre> <br>  Lo mismo se aplica a los cálculos que utilizan operadores matemáticos. <br><br>  Por ejemplo, el desempeño del operador de tomar el resto de la división del siguiente fragmento de código depende de qué números estén involucrados en los cálculos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = value % divisor; <span class="hljs-comment"><span class="hljs-comment">//  -  `value`  `divisor`   , //    .</span></span></code> </pre> <br>  Si ambos operandos están representados por enteros, entonces el procesador puede calcular el resultado de manera muy eficiente.  Hay una optimización adicional en V8 para los casos en que el operando <code>divisor</code> está representado por un número que es una potencia de dos.  Para los valores representados como números de coma flotante, los cálculos son mucho más complicados y toman mucho más tiempo. <br><br>  Dado que las operaciones de enteros generalmente se realizan mucho más rápido que las operaciones en valores de punto flotante, podría parecer que los motores simplemente pueden almacenar todos los enteros y todos los resultados de las operaciones de enteros en un formato con una suma de dos.  Desafortunadamente, este enfoque violaría la especificación ECMAScript.  Como ya se mencionó, el estándar proporciona la representación de números en el formato Float64, y algunas operaciones con números enteros pueden dar lugar a la aparición de resultados en forma de números de punto flotante.  Es importante que en tales situaciones, los motores JS produzcan resultados correctos. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Float64   53-  . //         . 2**53 === 2**53+1; // true // Float64   ,   -1 * 0   -0,  //           . -1*0 === -0; // true // Float64   Infinity,   , //     . 1/0 === Infinity; // true -1/0 === -Infinity; // true // Float64    NaN. 0/0 === NaN;</span></span></code> </pre> <br>  Aunque en el ejemplo anterior todos los números en el lado izquierdo de las expresiones son enteros, todos los números en el lado derecho de las expresiones son valores de coma flotante.  Es por eso que ninguna de las operaciones anteriores se puede realizar correctamente utilizando un formato de 32 bits con una adición de hasta dos.  Los motores de JavaScript deben prestar especial atención para garantizar que, al realizar operaciones con enteros, obtenga los resultados de Float64 correctos (aunque capaces de parecer inusuales, como en el ejemplo anterior). <br><br>  En el caso de los enteros pequeños que caen dentro del rango de la representación de 31 bits de los enteros con signo, V8 usa una representación especial llamada <code>Smi</code> .  Todo lo que no sea un valor <code>Smi</code> se representa como un valor <code>HeapObject</code> , que es la dirección de alguna entidad en la memoria.  Para los números que no entran en el rango <code>Smi</code> , tenemos un tipo especial de <code>HeapObject</code> : el llamado <code>HeapNumber</code> . <br><br><pre> <code class="javascript hljs">-<span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> <span class="hljs-comment"><span class="hljs-comment">// HeapNumber -(2**30)-1 // HeapNumber  -(2**30) // Smi       -42 // Smi        -0 // HeapNumber         0 // Smi       4.2 // HeapNumber        42 // Smi   2**30-1 // Smi     2**30 // HeapNumber  Infinity // HeapNumber       NaN // HeapNumber</span></span></code> </pre> <br>  Como puede ver en el ejemplo anterior, algunos números JS se representan como <code>Smi</code> y otros como <code>HeapNumber</code> .  El motor V8 está optimizado en términos de procesamiento de números <code>Smi</code> .  El hecho es que los enteros pequeños son muy comunes en los programas JS reales.  Cuando se trabaja con valores <code>Smi</code> , no es necesario asignar memoria para entidades individuales.  Su uso, además, le permite realizar operaciones rápidas con enteros. <br><br><h2>  <font color="#3AC1EF">Comparación de Smi, HeapNumber y MutableHeapNumber</font> </h2><br>  Hablemos de cómo se ve la estructura interna de estos mecanismos.  Supongamos que tenemos el siguiente objeto: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> o = {  <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Smi  y: 4.2, // HeapNumber };</span></span></code> </pre> <br>  El valor 42 de la propiedad del objeto <code>x</code> está codificado como <code>Smi</code> .  Esto significa que se puede almacenar dentro del propio objeto.  Para almacenar el valor 4.2, por otro lado, necesitará crear una entidad separada.  En el objeto, habrá un enlace a esta entidad. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/116/718/f34/116718f3426bccd613dd35dc95be9739.png"></div><br>  <i><font color="#999999">Almacenamiento de varios valores.</font></i> <br><br>  Supongamos que estamos ejecutando el siguiente código JavaScript: <br><br><pre> <code class="javascript hljs">ox += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ox   52 oy += 1; // oy   5.2</span></span></code> </pre> <br>  En este caso, el valor de la propiedad <code>x</code> se puede actualizar en su ubicación de almacenamiento.  El hecho es que el nuevo valor de <code>x</code> es 52, y este número se encuentra dentro del rango de <code>Smi</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/400/d42/4d8400d42a2046c9727d4ff76ad2b483.png"></div><br>  <i><font color="#999999">El nuevo valor de la propiedad x se almacena donde se almacenó el valor anterior.</font></i> <br><br>  Sin embargo, el nuevo valor de <code>y</code> , 5.2, no encaja en el rango de <code>Smi</code> y, además, difiere del valor anterior de y - 4.2.  Como resultado, V8 tiene que asignar memoria para la nueva entidad <code>HeapNumber</code> y referenciarla desde el objeto ya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/ecf/095/9baecf0951766c6e2781b552593b6b94.png"></div><br>  <i><font color="#999999">Nueva entidad HeapNumber para almacenar el nuevo valor y</font></i> <br><br>  <code>HeapNumber</code> entidades <code>HeapNumber</code> son inmutables.  Esto le permite implementar algunas optimizaciones.  Supongamos que queremos establecer la propiedad del objeto <code>x</code> valor de la propiedad <code>y</code> : <br><br><pre> <code class="javascript hljs">ox = oy; <span class="hljs-comment"><span class="hljs-comment">// ox   5.2</span></span></code> </pre> <br>  Al realizar esta operación, podemos referirnos a la misma entidad <code>HeapNumber</code> y no asignar memoria adicional para almacenar el mismo valor. <br><br>  Una de las desventajas de la inmunidad de las entidades HeapNuber es que la actualización frecuente de campos con valores fuera del rango <code>Smi</code> es lenta.  Esto se demuestra en el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   `HeapNumber`. const o = { x: 0.1 }; for (let i = 0; i &lt; 5; ++i) {  //    `HeapNumber`.  ox += 1; }</span></span></code> </pre> <br>  Al procesar la primera línea, se crea una instancia de <code>HeapNumber</code> , cuyo valor inicial es 0.1.  En el cuerpo del ciclo, este valor cambia a 1.1, 2.1, 3.1, 4.1 y finalmente a 5.1.  Como resultado, en el proceso de ejecución de este código, <code>HeapNumber</code> 6 instancias de <code>HeapNumber</code> , cinco de las cuales estarán sujetas a operaciones de recolección de basura después de completar el ciclo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/7e2/8f1/d107e28f181bf1eaf1fd57765bdfe49f.png"></div><br>  <i><font color="#999999">HeapNumber Entities</font></i> <br><br>  Para evitar este problema, V8 tiene optimización, que es un mecanismo para actualizar campos numéricos cuyos valores no se ajustan al rango <code>Smi</code> en los mismos lugares donde ya están almacenados.  Si un campo numérico almacena valores para los cuales la entidad <code>Smi</code> no <code>Smi</code> adecuada para el almacenamiento, entonces V8, en forma de objeto, marca este campo como <code>Double</code> y asigna memoria para la entidad <code>MutableHeapNumber</code> , que almacena el valor real representado en el formato Float64. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a17/c42/466/a17c42466cde98778836809e09df4da6.png"></div><br>  <i><font color="#999999">Uso de entidades MutableHeapNumber</font></i> <br><br>  Como resultado, después de que el valor del campo cambia, V8 ya no necesita asignar memoria para la nueva entidad <code>HeapNumber</code> .  En cambio, simplemente escriba el nuevo valor en una entidad <code>MutableHeapNumber</code> existente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c86/3bd/d1c/c863bdd1c81213b080d86bed079e9e5f.png"></div><br>  <i><font color="#999999">Escribir un nuevo valor en MutableHeapNumber</font></i> <br><br>  Sin embargo, este enfoque tiene sus inconvenientes.  Es decir, dado que los valores de <code>MutableHeapNumber</code> pueden cambiar, es importante asegurarse de que el sistema funcione de tal manera que estos valores se comporten según lo dispuesto en la especificación del lenguaje. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/be3/8ca/176be38cad03b4e4ab2881d7a9b67bfd.png"></div><br>  <i><font color="#999999">Desventajas de MutableHeapNumber</font></i> <br><br>  Por ejemplo, si asigna el valor de <code>ox</code> alguna otra variable <code>y</code> , entonces es necesario que el valor de <code>y</code> no cambie con un cambio posterior en <code>ox</code> .  ¡Eso sería una violación de la especificación de JavaScript!  Como resultado, al acceder a <code>ox</code> , el número debe volverse a empaquetar con el valor habitual de <code>HeapNumber</code> antes de que se le asigne <code>y</code> . <br><br>  En el caso de los números de coma flotante, V8 realiza las operaciones de empaquetado anteriores utilizando sus mecanismos internos.  Pero en el caso de los enteros pequeños, usar <code>MutableHeapNumber</code> sería una pérdida de tiempo, porque <code>Smi</code> es una forma más eficiente de representar tales números. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// ""  `x`    object.x += 1; //   `x`  </span></span></code> </pre> <br>  Para evitar el uso ineficiente de los recursos del sistema, todo lo que necesitamos hacer para trabajar con enteros pequeños es marcar los campos correspondientes en las formas de los objetos como <code>Smi</code> .  Como resultado, los valores de estos campos, siempre que correspondan al rango <code>Smi</code> , se pueden actualizar directamente dentro de los objetos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6a/d23/b96/b6ad23b9635e31d8f695d7170b8d3d7c.png"></div><br>  <i><font color="#999999">Trabaja con enteros cuyos valores caen dentro del rango de Smi</font></i> <br><br>  Continuará ... <br><br>  <b>Estimados lectores!</b>  ¿Ha encontrado problemas de rendimiento de JavaScript causados ​​por las características del motor JS? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467247/">https://habr.com/ru/post/467247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467231/index.html">Presentamos Iniciar sesión con Apple en tu aplicación iOS</a></li>
<li><a href="../467237/index.html">Eleve su servidor DNS sobre HTTPS</a></li>
<li><a href="../467239/index.html">La diferencia entre Data Scientist y un adolescente en un auto deportivo</a></li>
<li><a href="../467241/index.html">Carro para camiones ROS. Parte 4. Crear una simulación de robot usando los editores rviz y gazebo</a></li>
<li><a href="../467245/index.html">Dmitry Matskevich, Dbrain: sobre el emprendimiento como una discapacidad mental, IA y seguridad emocional</a></li>
<li><a href="../467249/index.html">Una historia sobre V8, React y una caída en el rendimiento. Parte 2</a></li>
<li><a href="../467251/index.html">Rehenes COBOL y Matemáticas. Parte 1</a></li>
<li><a href="../467253/index.html">Rehenes COBOL y Matemáticas. Parte 2</a></li>
<li><a href="../467255/index.html">Tres errores de seguridad comunes que todo desarrollador de React debe conocer</a></li>
<li><a href="../467257/index.html">No guardes todos tus huevos en una canasta a la vez</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>