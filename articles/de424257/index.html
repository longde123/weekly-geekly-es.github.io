<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➿ 💮 ✨ Sechseckkarten in Einheit: Teile 1-3 ⏪ 🌚 🧙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem Übersetzer: Dieser Artikel ist der erste einer detaillierten (27 Teile) Reihe von Tutorials zum Erstellen von Karten aus Sechsecken. Dies so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sechseckkarten in Einheit: Teile 1-3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424257/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg" alt="Bild"></div><br>  <i>Von einem Übersetzer: Dieser Artikel ist der erste einer detaillierten (27 Teile) Reihe von Tutorials zum Erstellen von Karten aus Sechsecken.</i>  <i>Dies sollte ganz am Ende der Tutorials geschehen.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenhöhen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Flüsse und Straßen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und Wälle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 1: Eingriff aus Sechsecken </h1><br><h2>  Inhaltsverzeichnis </h2><br><ul><li>  Wandle Quadrate in Sechsecke um. </li><li>  Triangulieren Sie ein Sechseckgitter. </li><li>  Wir arbeiten mit kubischen Koordinaten. </li><li>  Wir interagieren mit Gitterzellen. </li><li>  Erstelle einen In-Game-Editor. </li></ul><br>  Dieses Tutorial ist der Beginn einer Reihe über Sechseckkarten.  Hexagon-Netze werden in vielen Spielen verwendet, insbesondere in Strategien, einschließlich Age of Wonders 3, Civilization 5 und Endless Legend.  Wir werden mit den Grundlagen beginnen, nach und nach neue Funktionen hinzufügen und als Ergebnis ein komplexes Relief auf der Basis von Sechsecken erstellen. <br><a name="habracut"></a><br>  In diesem Tutorial wird davon ausgegangen, dass Sie bereits die <i>Mesh Basics-</i> Reihe studiert haben, die mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prozeduralen Raster</a> beginnt.  Es wurde unter Unity 5.3.1 erstellt.  Die Serie verwendet mehrere Versionen von Unity.  Der letzte Teil wurde in Unity 2017.3.0p3 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54e/065/633/54e065633ba41c99214f720278b68336.png"></div><br>  <i>Eine einfache Karte von Sechsecken.</i> <br><br><h2>  Über Sechsecke </h2><br>  Warum werden Sechsecke benötigt?  Wenn wir ein Raster benötigen, ist es logisch, Quadrate zu verwenden.  Quadrate sind sehr einfach zu zeichnen und zu positionieren, haben aber auch einen Nachteil.  Schauen Sie sich ein einzelnes Quadrat des Gitters und dann seine Nachbarn an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/d4f/9b8/48fd4f9b87d5aa2381d9b03dbae704ae.png"></div><br>  <i>Der Platz und seine Nachbarn.</i> <br><br>  Insgesamt hat der Platz acht Nachbarn.  Vier davon können durch Überqueren des Randes des Quadrats erreicht werden.  Dies sind horizontale und vertikale Nachbarn.  Die anderen vier können durch Überqueren der Ecke des Platzes erreicht werden.  Dies sind diagonale Nachbarn. <br><br>  Wie groß ist der Abstand zwischen den Zentren benachbarter quadratischer Gitterzellen?  Wenn die Kantenlänge 1 ist, ist die Antwort für horizontale und vertikale Nachbarn 1. Für diagonale Nachbarn ist die Antwort jedoch √2. <br><br>  Der Unterschied zwischen den beiden Arten von Nachbarn führt zu Schwierigkeiten.  Wenn wir diskrete Bewegungen verwenden, wie kann man dann die Bewegung entlang der Diagonale wahrnehmen?  Soll ich es überhaupt zulassen?  Wie kann das Erscheinungsbild organischer gestaltet werden?  Unterschiedliche Spiele verwenden unterschiedliche Ansätze mit ihren Vor- und Nachteilen.  Ein Ansatz besteht darin, überhaupt kein quadratisches Gitter zu verwenden, sondern stattdessen Sechsecke zu verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/47a/9a1/77247a9a1784bdbe1b736672460b95bf.png"></div><br>  <i>Sechseck und seine Nachbarn.</i> <br><br>  Im Gegensatz zu einem Quadrat hat ein Sechseck nicht acht, sondern sechs Nachbarn.  Alle diese Nachbarn grenzen an die Ränder, es gibt keine Ecknachbarn.  Das heißt, es gibt nur eine Art von Nachbarn, was viel vereinfacht.  Natürlich ist ein Sechseckgitter schwerer zu bauen als ein Quadrat, aber wir können damit umgehen. <br><br>  Bevor wir beginnen, müssen wir die Größe der Sechsecke bestimmen.  Die Kantenlänge sei gleich 10 Einheiten.  Da das Sechseck aus einem Kreis von sechs gleichseitigen Dreiecken besteht, beträgt der Abstand vom Zentrum zu einem beliebigen Winkel ebenfalls 10. Dieser Wert bestimmt den Außenradius der sechseckigen Zelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdb/a2f/82f/cdba2f82fb30358f0d2ca31c95f133d5.png"></div><br>  <i>Der äußere und innere Radius des Sechsecks.</i> <br><br>  Es gibt auch einen Innenradius, der der Abstand von der Mitte zu jeder der Kanten ist.  Dieser Parameter ist wichtig, da der Abstand zwischen den Mittelpunkten der Nachbarn gleich diesem Wert mal zwei ist.  Der Innenradius ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;">s </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;">q </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;">r </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;">t </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;">3</font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"> 2</font></span></span></font><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mtext" id="MJXp-Span-8">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;"></font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.098ex" height="2.419ex" viewBox="0 -780.1 5209 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="1631" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="1993" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="4708" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> \ frac {\ sqrt {3}} {2} </script>  vom äußeren Radius, das heißt in unserem Fall <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mn" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;">q </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;">3</font></span></span></font><span class="MJXp-mtext" id="MJXp-Span-19">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.954ex" height="2.298ex" viewBox="0 -728.2 2994 989.6" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-35" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="1220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="1680" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="2132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="2493" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 5 \ sqrt {3} </script>  .  Lassen Sie uns diese Parameter der Einfachheit halber in eine statische Klasse einordnen. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMetrics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie leitet man den Wert des Innenradius ab?</b> <div class="spoiler_text">  Nimm eines der sechs Dreiecke eines Sechsecks.  Der Innenradius entspricht der Höhe dieses Dreiecks.  Diese Höhe kann erhalten werden, indem das Dreieck in zwei reguläre Dreiecke geteilt und dann der Satz von Pythagoras verwendet wird. <br><br>  Daher für die Länge der Rippe <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.083ex" height="1.523ex" viewBox="0 -535.3 466.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> e </script>  Innenradius ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mtext" id="MJXp-Span-29">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">t</span><span class="MJXp-mrow" id="MJXp-Span-34"><span class="MJXp-msubsup" id="MJXp-Span-35"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-37" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">e</span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-43">2</span><span class="MJXp-msubsup" id="MJXp-Span-44"><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-46" style="vertical-align: 0.5em;">2</span></span></span><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-48">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">t</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mn" id="MJXp-Span-54">3</span><span class="MJXp-msubsup" id="MJXp-Span-55"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-57" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-58"><span class="MJXp-mo" id="MJXp-Span-59" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-60">4</span></span><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">e</span><span class="MJXp-mtext" id="MJXp-Span-63">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">t</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-mn" id="MJXp-Span-69">3</span></span><span class="MJXp-mrow" id="MJXp-Span-70"><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-72">2</span><span class="MJXp-mtext" id="MJXp-Span-73">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">a</span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mn" id="MJXp-Span-77">0</span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-79">886</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="52.148ex" height="3.037ex" viewBox="0 -950 22452.6 1307.5" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="1631" y="0"></use><g transform="translate(1993,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="659" y="513"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2212" x="1142" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-28" x="2143" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="2532" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2F" x="2999" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="3499" y="0"></use><g transform="translate(4000,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="550" y="513"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-3D" x="7114" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="8420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="8890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="9350" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="9802" y="0"></use><g transform="translate(10163,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="659" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2F" x="1420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-34" x="1921" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-3D" x="12863" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="13919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="14636" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="15105" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="15566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="16017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="16379" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2F" x="16879" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="17380" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-63" x="18130" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="18564" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2E" x="19093" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-30" x="19538" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2C" x="20039" y="0"></use><g transform="translate(20484,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-38"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-38" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-36" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="21986" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> \ sqrt {e ^ 2 - (e / 2) ^ 2} = \ sqrt {3e ^ 2/4} = e \ sqrt {3} / 2 \ ca. 0,886e </script>  . </div></div><br>  Wenn wir dies bereits tun, bestimmen wir die Positionen der sechs Ecken relativ zur Mitte der Zelle.  Es ist zu beachten, dass es zwei Möglichkeiten gibt, das Sechseck auszurichten: mit einer scharfen oder flachen Seite nach oben.  Wir werden die Ecke aufstellen.  Beginnen wir in diesem Winkel und fügen den Rest im Uhrzeigersinn hinzu.  Legen Sie sie so auf die XZ-Ebene, dass die Sechsecke auf dem Boden liegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b2/0eb/95a/5b20eb95ac844ed93a117b7d37f90e11.png"></div><br>  <i>Mögliche Orientierungen.</i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius) };</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einheitspaket</a> <br><br><h2>  Vernetzung </h2><br>  Um ein Sechseckgitter zu erstellen, benötigen wir Gitterzellen.  Erstellen Sie zu diesem Zweck die <code>HexCell</code> Komponente.  Lassen Sie es vorerst leer, da wir noch keine bestimmten Zellen verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br>  Erstellen Sie zunächst ein Standardebenenobjekt, fügen Sie eine Zellenkomponente hinzu und verwandeln Sie alles in ein Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/f1f/3ab/b61f1f3ab3210349434c2aff8c9ac374.png"></div><br>  <i>Verwendung einer Ebene als Fertighaus einer sechseckigen Zelle.</i> <br><br>  Nun gehen wir ins Netz.  Erstellen wir eine einfache Komponente mit allgemeinen Variablen für Zellenbreite, -höhe und -fertigung.  Fügen Sie dann der Szene ein Spielobjekt mit dieser Komponente hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell cellPrefab; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/749/12e/cad74912e6a951918b4a3d0f4b9bb6bb.png"></div><br>  <i>Sechseck-Netzobjekt.</i> <br><br>  Beginnen wir mit der Erstellung eines regelmäßigen Quadrats von Quadraten, da wir bereits wissen, wie das geht.  Speichern wir die Zellen in einem Array, um darauf zugreifen zu können. <br><br>  Da die Ebenen standardmäßig eine Größe von 10 x 10 Einheiten haben, verschieben wir jede Zelle um diesen Betrag. <br><br><pre> <code class="cs hljs"> HexCell[] cells; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[height * width]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; height; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { CreateCell(x, z, i++); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = x * <span class="hljs-number"><span class="hljs-number">10f</span></span>; position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * <span class="hljs-number"><span class="hljs-number">10f</span></span>; HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/560/321/d11560321e63ac581846776aa5b658b6.png"></div><br>  <i>Quadratisches Gitter von Flugzeugen.</i> <br><br>  So haben wir ein schönes festes Gitter aus quadratischen Zellen.  Aber welche Zelle ist wo?  Dies ist natürlich leicht zu überprüfen, aber es gibt Schwierigkeiten mit Sechsecken.  Es wäre praktisch, wenn wir gleichzeitig die Koordinaten aller Zellen sehen könnten. <br><br><h3>  Koordinatenanzeige </h3><br>  Fügen Sie der Szene Leinwand hinzu, indem Sie <i>GameObject / UI / Canvas</i> auswählen und sie zu einem <i>untergeordneten Element</i> unseres <i>Netzobjekts</i> machen.  Da diese Zeichenfläche nur zur Information dient, entfernen wir ihre Raycaster-Komponente.  Sie können auch das Ereignissystemobjekt löschen, das automatisch zur Szene hinzugefügt wurde, da wir es derzeit nicht benötigen. <br><br>  Stellen Sie den <i>Render-Modus</i> auf " <i>Weltraum"</i> und drehen Sie ihn um 90 Grad entlang der X-Achse, sodass die Leinwand über dem Raster liegt.  Drehpunkt und Position auf Null setzen.  Geben Sie ihm einen leichten vertikalen Versatz, damit der Inhalt oben ist.  Breite und Höhe sind uns nicht wichtig, da wir den Inhalt selbst arrangieren.  Wir können den Wert auf 0 setzen, um das große Rechteck im Szenenfenster zu entfernen. <br><br>  Als letzten Schliff erhöhen Sie die <i>dynamischen Pixel pro Einheit</i> auf 10. Wir garantieren daher, dass Textobjekte eine ausreichende Texturauflösung verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/d5e/34e/d37d5e34e417e5d703d2915ef2e6ad19.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/c37/273/374c37273c1e8e61befc30543efca5b2.png"></div><br>  <i>Leinwand für Gitterkoordinaten von Sechsecken.</i> <br><br>  Um die Koordinaten anzuzeigen, erstellen Sie ein <i>Textobjekt</i> ( <i>GameObject / UI / Text</i> ) und verwandeln Sie es in ein Fertighaus.  Zentrieren Sie die Anker und drehen Sie sie, und stellen Sie die Größe auf 5 x 15 ein. Der Text sollte auch horizontal und vertikal in der Mitte ausgerichtet sein.  Stellen Sie die Schriftgröße auf 4 ein. Schließlich möchten wir den Standardtext nicht verwenden und verwenden keinen <i>Rich-Text</i> .  Außerdem spielt es für uns keine Rolle, ob das <i>Raycast-Ziel aktiviert</i> ist, da es für unsere Leinwand immer noch nicht benötigt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/c09/d55/f15c09d55444941d69d563940806340f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6d/0df/ab2/d6d0dfab20e21276e48a2ca5bdc36503.png"></div><br>  <i>Fertighausetikett.</i> <br><br>  Jetzt müssen wir dem Raster etwas über Leinwand und Fertighaus erzählen.  Fügen Sie am Anfang ihres Skripts <code>using UnityEngine.UI;</code>  um bequem auf den Typ <code>UnityEngine.UI.Text</code> .  Ein vorgefertigtes Etikett benötigt eine gemeinsam genutzte Variable, und Canvas kann durch Aufrufen von <code>GetComponentInChildren</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text cellLabelPrefab; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fae/b30/599/faeb3059923e68e4b072a5b401086072.png"></div><br>  <i>Verbindungsfertige Tags.</i> <br><br>  Nachdem Sie das Fertighaus des Etiketts verbunden haben, können Sie seine Instanzen erstellen und die Koordinaten der Zelle anzeigen.  Fügen Sie zwischen X und Z ein Zeilenumbruchzeichen ein, sodass sie in separaten Zeilen angezeigt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = x.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e8/1e2/9b0/0e81e29b0fd80afb2f7056a5b8ed829d.png"></div><br>  <i>Koordinatenanzeige.</i> <br><br><h3>  Sechseckpositionen </h3><br>  Jetzt, da wir jede Zelle visuell erkennen können, können wir sie verschieben.  Wir wissen, dass der Abstand zwischen benachbarten hexagonalen Zellen in X-Richtung dem doppelten Innenradius entspricht.  Wir werden es benutzen.  Außerdem sollte der Abstand zur nächsten Zellenreihe 1,5-mal größer sein als der äußere Radius. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/269/f40/6e4269f40ead27d2ddb0dd75a1154d99.png"></div><br>  <i>Geometrie benachbarter Sechsecke.</i> <br><br><pre> <code class="cs hljs"> position.x = x * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ca/d03/034/5cad03034d4aacacf5ccd49dccf0af3a.png"></div><br>  <i>Wir wenden Abstände zwischen Sechsecken ohne Offsets an.</i> <br><br>  Natürlich liegen die Ordnungsreihen der Sechsecke nicht genau übereinander.  Jede Zeile ist entlang der X-Achse um den Wert des Innenradius versetzt.  Dieser Wert kann erhalten werden, indem die Hälfte von Z zu X addiert und dann mit dem doppelten Innenradius multipliziert wird. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/e06/f65/75ce06f65db02737bddf223d45f6b8f3.png"></div><br>  <i>Durch die richtige Platzierung der Sechsecke entsteht ein rautenförmiges Gitter.</i> <br><br>  Obwohl wir auf diese Weise die Zellen an den richtigen Positionen der Sechsecke platziert haben, füllt unser Gitter jetzt eher die Raute als das Rechteck.  Wir arbeiten viel einfacher mit rechteckigen Gittern. Lassen Sie uns also die Zellen wieder in Betrieb nehmen.  Dies kann durch Zurückschieben eines Teils des Versatzes erfolgen.  In jeder zweiten Zeile müssen alle Zellen um einen weiteren Schritt zurückgeschoben werden.  Dazu müssen wir das Ergebnis der ganzzahligen Division von Z durch 2 subtrahieren, bevor wir multiplizieren. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/429/30a/51942930aa48daab518847429e4c8b74.png"></div><br>  <i>Die Position der Sechsecke in einem rechteckigen Bereich.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Hexagon-Rendering </h2><br>  Nachdem die Zellen korrekt platziert wurden, können wir die realen Sechsecke anzeigen.  Zuerst müssen wir die Ebenen entfernen, damit wir alle Komponenten außer <code>HexCell</code> aus dem Zellen- <code>HexCell</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/32a/214/48f32a214e6ef61f580a0147a5f310da.png"></div><br>  <i>Es gibt keine Flugzeuge mehr.</i> <br><br>  Wie in den Tutorials zu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzgrundlagen verwenden</a> wir ein Netz, um das gesamte Netz zu rendern.  Dieses Mal werden wir jedoch die Anzahl der erforderlichen Eckpunkte und Dreiecke nicht voreingestellt.  Stattdessen werden wir Listen verwenden. <br><br>  Erstellen Sie eine neue <code>HexMesh</code> Komponente, <code>HexMesh</code> um unser Netz kümmert.  Es erfordert einen Netzfilter und einen Renderer, ein Netz und Listen für Scheitelpunkte und Dreiecke. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMesh</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Mesh hexMesh; List&lt;Vector3&gt; vertices; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } }</code> </pre> <br>  Erstellen Sie mit dieser Komponente ein neues untergeordnetes Objekt für dieses Netz.  Er erhält automatisch einen Mesh-Renderer, ihm wird jedoch kein Material zugewiesen.  Fügen Sie daher das Standardmaterial hinzu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/831/2ab/f2a8312ab61274a7563aeeb7860c3609.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/bf1/710/8abbf17103e93485e696daf3a94bb277.png"></div><br>  <i>Hex-Mesh-Objekt.</i> <br><br>  <code>HexGrid</code> kann nun sein Sechsecknetz auf dieselbe Weise abrufen, wie er die Leinwand gefunden hat. <br><br><pre> <code class="cs hljs"> HexMesh hexMesh; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); … }</code> </pre> <br>  Nach dem Wachnetz sollte es dem Netz befehlen, seine Zellen zu triangulieren.  Wir müssen sicher sein, dass dies nach der Awake-Komponente des Hex-Netzes geschieht.  Da <code>Start</code> später aufgerufen wird, geben Sie dort den entsprechenden Code ein. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br>  Diese <code>HexMesh.Triangulate</code> Methode kann jederzeit aufgerufen werden, auch wenn die Zellen bereits zuvor trianguliert wurden.  Daher sollten wir zunächst alte Daten bereinigen.  Wenn wir alle Zellen durchlaufen, triangulieren wir sie einzeln.  Nach Abschluss dieses Vorgangs weisen wir dem Netz die generierten Scheitelpunkte und Dreiecke zu und berechnen abschließend die Netznormalen neu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); triangles.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } hexMesh.vertices = vertices.ToArray(); hexMesh.triangles = triangles.ToArray(); hexMesh.RecalculateNormals(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Da die Sechsecke aus Dreiecken bestehen, erstellen wir eine bequeme Methode zum Hinzufügen eines Dreiecks basierend auf den Positionen von drei Eckpunkten.  Es werden nur die Eckpunkte der Reihe nach hinzugefügt.  Er addiert auch die Indizes dieser Eckpunkte, um ein Dreieck zu bilden.  Der Index des ersten Scheitelpunkts entspricht der Länge der Liste der Scheitelpunkte, bevor neue Scheitelpunkte hinzugefügt werden.  Vergessen Sie dies nicht, wenn Sie Scheitelpunkte hinzufügen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Jetzt können wir unsere Zellen triangulieren.  Beginnen wir mit dem ersten Dreieck.  Sein erster Gipfel befindet sich in der Mitte des Sechsecks.  Die beiden anderen Eckpunkte sind der erste und der zweite Winkel relativ zur Mitte. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">0</span></span>], center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/d2b/ca3/860d2bca3ec0d1c95bd66082735021f7.png"></div><br>  <i>Das erste Dreieck jeder Zelle.</i> <br><br>  Das hat funktioniert, also lasst uns alle sechs Dreiecke umrunden. <br><br><pre> <code class="cs hljs"> Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Können Spitzen geteilt werden?</b> <div class="spoiler_text">  Ja, das kannst du.  Tatsächlich können wir es sogar noch besser machen und nur vier statt sechs Dreiecke zum Rendern verwenden.  Wenn wir dies jedoch aufgeben, werden wir unsere Arbeit vereinfachen, und es wird richtig sein, da in den folgenden Tutorials alles komplizierter wird.  Die Optimierung von Eckpunkten und Dreiecken in dieser Phase wird uns in Zukunft behindern. </div></div><br>  Leider führt dieser Prozess zu einer <code>IndexOutOfRangeException</code> .  Dies liegt daran, dass das letzte Dreieck versucht, die siebte Ecke zu erhalten, die nicht existiert.  Natürlich sollte er zurückgehen und als letzten Scheitelpunkt der ersten Ecke verwenden.  Oder wir können die erste Ecke in <code>HexMetrics.corners</code> , um nicht über die Grenzen hinauszugehen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8d/277/e13/c8d277e139df24953e9b381fabca2a42.png"></div><br>  <i>Sechsecke vollständig.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Sechseckige Koordinaten </h2><br>  Schauen wir uns noch einmal die Koordinaten der Zellen an, jetzt im Kontext eines Sechseckgitters.  Die Z-Koordinate sieht gut aus und die X-Koordinate im Zickzack.  Dies ist ein Nebeneffekt des Linienversatzes, um einen rechteckigen Bereich abzudecken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/745/502/73f745502f1d8d20245bd22edc99a3ce.png"></div><br>  <i>Versetzte Koordinaten mit hervorgehobenen Nulllinien.</i> <br><br>  Bei der Arbeit mit Sechsecken sind solche Versatzkoordinaten nicht einfach zu handhaben.  <code>HexCoordinates</code> wir eine Struktur <code>HexCoordinates</code> , die zum Konvertieren in ein anderes Koordinatensystem verwendet werden kann.  Machen wir es serialisierbar, damit Unity es speichern kann und es im Wiedergabemodus neu kompiliert wird.  Wir machen diese Koordinaten auch unveränderlich, indem wir die öffentlichen schreibgeschützten Eigenschaften verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { X = x; Z = z; } }</code> </pre> <br>  Fügen Sie eine statische Methode hinzu, um einen Satz von Koordinaten aus normalen Versatzkoordinaten zu erstellen.  Im Moment werden wir diese Koordinaten einfach kopieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z); } }</code> </pre> <br>  Wir fügen auch praktische Methoden zur Konvertierung von Zeichenfolgen hinzu.  Die <code>ToString</code> Methode gibt standardmäßig einen Strukturtypnamen zurück, was für uns nicht sehr nützlich ist.  Wir definieren es neu, damit es die Koordinaten in einer Zeile zurückgibt.  Wir werden auch eine Methode zum Anzeigen von Koordinaten in separaten Zeilen hinzufügen, da wir bereits ein solches Schema verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br>  Jetzt können wir viele Koordinaten an unsere <code>HexCell</code> Komponente übergeben. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; }</code> </pre> <br>  Ändern Sie <code>HexGrid.CreateCell</code> so, dass die neuen Koordinaten verwendet werden können. <br><br><pre> <code class="cs hljs"> HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines();</code> </pre> <br>  Wiederholen wir nun diese X-Koordinaten so, dass sie entlang einer geraden Achse ausgerichtet sind.  Dies kann durch Aufheben der horizontalen Verschiebung erfolgen.  Das resultierende Ergebnis wird üblicherweise als Axialkoordinaten bezeichnet. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x - z / <span class="hljs-number"><span class="hljs-number">2</span></span>, z); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/1bf/29d/4331bf29dbf016e466a3636b5cd90311.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ab/03d/7af/4ab03d7afdef480fe4657ae86901fd1a.png"></div><br>  <i>Axialkoordinaten.</i> <br><br>  Dieses zweidimensionale Koordinatensystem ermöglicht es uns, die Bewegung der Verschiebung in vier Richtungen nacheinander zu beschreiben.  Zwei verbleibende Richtungen erfordern jedoch noch besondere Aufmerksamkeit.  Dies macht uns klar, dass es eine dritte Dimension gibt.  Und tatsächlich würden wir, wenn wir die Dimension von X horizontal spiegeln würden, die fehlende Dimension von Y erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32c/39b/9b7/32c39b9b7705099d7bcb8e525aa6fe48.png"></div><br>  <i>Die Y-Messung wird angezeigt.</i> <br><br>  Da diese Messungen von X und Y Spiegelkopien voneinander sind, ergibt die Addition ihrer Koordinaten immer das gleiche Ergebnis, wenn Z konstant bleibt.  Wenn Sie alle drei Koordinaten addieren, erhalten wir immer Null.  Wenn Sie eine Koordinate erhöhen, müssen Sie die andere reduzieren.  Tatsächlich gibt uns dies sechs mögliche Bewegungsrichtungen.  Solche Koordinaten werden normalerweise als kubisch bezeichnet, da sie dreidimensional sind und die Topologie einem Würfel ähnelt. <br><br>  Da die Summe aller Koordinaten Null ist, können wir immer eine der Koordinaten von den anderen beiden erhalten.  Da wir bereits die X- und Z-Koordinaten speichern, müssen wir die Y-Koordinate nicht speichern. <br>  Wir können eine Eigenschaft hinzufügen, die sie bei Bedarf auswertet, und sie in Zeichenfolgenmethoden verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -X - Z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c36/ad9/d32/c36ad9d322193e811fd6c59b5d76249a.png"></div><br>  <i>Kubische Koordinaten.</i> <br><br><h3>  Inspektorkoordinaten </h3><br>  Wählen Sie im Wiedergabemodus eine der Gitterzellen aus.  Es stellt sich heraus, dass der Inspektor seine Koordinaten nicht anzeigt, <code>HexCell.coordinates</code> nur die <code>HexCell.coordinates</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/a1d/a0e/d02a1da0e906223abcb9aeeb46ce7477.png"></div><br>  <i>Der Inspektor zeigt die Koordinaten nicht an.</i> <br><br>  Obwohl dies kein großes Problem ist, wäre es großartig, die Koordinaten anzuzeigen.  Unity zeigt keine Koordinaten an, da diese nicht als serialisierbare Felder markiert sind.  Um sie anzuzeigen, müssen Sie explizit serialisierbare Felder für X und Z angeben. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, z; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ea/264/fff/5ea264fffa724e10205c41c8191ad78b.png"></div><br>  X- und Z-Koordinaten werden jetzt angezeigt, können jedoch geändert werden.  Wir brauchen das nicht, weil die Koordinaten festgelegt werden müssen.  Es ist auch nicht sehr gut, dass sie untereinander angezeigt werden. <br><br>  Wir können es besser machen: Definieren Sie unsere eigene Eigenschaftsschublade für den <code>HexCoordinates</code> Typ.  Erstellen Sie ein <code>HexCoordinatesDrawer</code> Skript und fügen Sie es in den <i>Editor-</i> Ordner ein, da dieses Skript nur für den Editor bestimmt ist. <br><br>  Die Klasse muss <code>UnityEditor.PropertyDrawer</code> und benötigt das Attribut <code>UnityEditor.CustomPropertyDrawer</code> , um es einem geeigneten Typ zuzuordnen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(HexCoordinates))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCoordinatesDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { }</code> </pre> <br>  Eigenschaftsschubladen zeigen ihren Inhalt mit der <code>OnGUI</code> Methode an.  Mit dieser Methode konnten serialisierbare Eigenschaftsdaten und die Bezeichnung des Felds, zu dem sie gehören, innerhalb des Bildschirmrechtecks ​​gezeichnet werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Wir extrahieren die Werte von x und z aus der Eigenschaft und verwenden sie dann, um einen neuen Satz von Koordinaten zu erstellen.  Zeichnen Sie dann das GUI-Label an der ausgewählten Position mit unserer <code>HexCoordinates.ToString</code> Methode. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates( property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"x"</span></span>).intValue, property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"z"</span></span>).intValue ); GUI.Label(position, coordinates.ToString()); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d6/d0f/852/1d6d0f852f744b6b5080a54478a3f4bf.png"></div><br>  <i>Koordinaten ohne Präfixbezeichnung.</i> <br><br>  Dadurch werden die Koordinaten angezeigt, aber jetzt fehlt der Feldname.  Diese Namen werden normalerweise mit der <code>EditorGUI.PrefixLabel</code> Methode gerendert.  Als Bonus wird ein ausgerichtetes Rechteck zurückgegeben, das dem Leerzeichen rechts neben dieser Beschriftung entspricht. <br><br><pre> <code class="cs hljs"> position = EditorGUI.PrefixLabel(position, label); GUI.Label(position, coordinates.ToString());</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6c/d34/856/a6cd348569c891e063c6fc515d075d04.png"></div><br>  <i>Koordinaten mit einem Etikett.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Zellen berühren </h2><br>  Ein Sechseckgitter ist nicht sehr interessant, wenn wir nicht damit interagieren können.  Die einfachste Interaktion besteht darin, die Zelle zu berühren. Fügen wir also Unterstützung hinzu.  Im <code>HexGrid</code> fügen wir diesen Code einfach direkt in <code>HexGrid</code> .  Wenn es anfängt zu funktionieren, werden wir es an einen anderen Ort verschieben. <br><br>  Um eine Zelle zu berühren, können Sie von der Position des Mauszeigers aus Strahlen in die Szene senden.  Wir können den gleichen Ansatz wie im Tutorial zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzdeformation verwenden</a> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { TouchCell(hit.point); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + position); }</code> </pre> <br>  Bisher macht der Code nichts.  Wir müssen dem Gitter einen Kollider hinzufügen, damit der Strahl mit etwas kollidieren kann.  Daher geben wir das <code>HexMesh</code> Collider-Netz an. <br><br><pre> <code class="cs hljs"> MeshCollider meshCollider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); … }</code> </pre> <br>  Weisen Sie dem Collider nach Abschluss der Triangulation ein Netz zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { … meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Können wir nicht einfach Box Collider verwenden?</b> <div class="spoiler_text">  Wir können, aber es wird nicht genau mit dem Umriss unseres Gitters übereinstimmen.  Ja, und unser Raster wird nicht lange flach bleiben, aber dies ist ein Thema für zukünftige Tutorials. </div></div><br>  Jetzt können wir das Gitter berühren!  Aber welche Zelle berühren wir?  Um dies herauszufinden, müssen wir die Berührungsposition in die Koordinaten der Sechsecke umwandeln.  Dies ist eine Arbeit für <code>HexCoordinates</code> , daher erklären wir, dass es eine statische <code>FromPosition</code> Methode gibt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + coordinates.ToString()); }</code> </pre> <br>  Wie bestimmt diese Methode, welche Koordinate zur Position gehört?  Wir können beginnen, indem wir x durch die horizontale Breite des Sechsecks teilen.  Und da die Y-Koordinate ein Spiegelbild der X-Koordinate ist, ergibt ein negatives x y. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -x; }</code> </pre> <br>  Dies würde uns natürlich die richtigen Koordinaten geben, wenn Z Null wäre.  Wir müssen uns erneut verschieben, wenn wir uns entlang Z bewegen. Alle zwei Zeilen müssen wir um eine Einheit nach links verschieben. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = position.z / (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">3f</span></span>); x -= offset; y -= offset;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen erweisen sich unsere x- und y-Werte als Ganzzahlen in der Mitte jeder Zelle. </font><font style="vertical-align: inherit;">Wenn wir sie daher auf die nächste ganze Zahl runden, müssen wir die Koordinaten erhalten. </font><font style="vertical-align: inherit;">Wir berechnen auch Z und erhalten so die endgültigen Koordinaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iX = Mathf.RoundToInt(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iY = Mathf.RoundToInt(y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iZ = Mathf.RoundToInt(-x -y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse sehen vielversprechend aus, aber sind diese Koordinaten korrekt? </font><font style="vertical-align: inherit;">Bei sorgfältiger Untersuchung können Sie feststellen, dass wir manchmal die Koordinaten erhalten, deren Summe ungleich Null ist! </font><font style="vertical-align: inherit;">Aktivieren Sie die Benachrichtigung, um sicherzustellen, dass dies wirklich geschieht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"rounding error!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten tatsächlich Benachrichtigungen. </font><font style="vertical-align: inherit;">Wie beheben wir diesen Fehler? </font><font style="vertical-align: inherit;">Es entsteht nur neben den Kanten zwischen den Sechsecken. </font><font style="vertical-align: inherit;">Das heißt, das Runden von Koordinaten verursacht Probleme. </font><font style="vertical-align: inherit;">Welche Koordinate ist in die falsche Richtung gerundet? </font><font style="vertical-align: inherit;">Je weiter wir uns von der Mitte der Zelle entfernen, desto runder werden wir. </font><font style="vertical-align: inherit;">Daher ist es logisch anzunehmen, dass die am meisten gerundete Koordinate falsch ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann besteht die Lösung darin, die Koordinate mit dem größten Rundungsdelta zu löschen und sie aus den Werten der beiden anderen neu zu erstellen. </font><font style="vertical-align: inherit;">Da wir jedoch nur X und Z benötigen, können wir Y nicht neu erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dX = Mathf.Abs(x - iX); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dY = Mathf.Abs(y - iY); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dZ = Mathf.Abs(-x -y - iZ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt; dY &amp;&amp; dX &gt; dZ) { iX = -iY - iZ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dZ &gt; dY) { iZ = -iX - iY; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sechsecke Malvorlagen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir die richtige Zelle berühren können, ist die Zeit für echte Interaktion gekommen. </font><font style="vertical-align: inherit;">Lassen Sie uns die Farbe jeder Zelle ändern, in die wir gelangen. </font><font style="vertical-align: inherit;">Fügen Sie für die </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benutzerdefinierten Farben der Standardzelle und der betroffenen Zelle hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color defaultColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color touchedColor = Color.magenta;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/89a/d05/33d89ad0522ace10075800607aac71b2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswahl der Zellenfarbe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Farbfeld hinzufügen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es der Standardfarbe zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen auch </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Farbinformationen </font><font style="vertical-align: inherit;">ergänzen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;Color&gt; colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); … hexMesh.vertices = vertices.ToArray(); hexMesh.colors = colors.ToArray(); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Triangulieren müssen wir nun jedem Dreieck Farbdaten hinzufügen. </font><font style="vertical-align: inherit;">Zu diesem Zweck erstellen wir eine separate Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurück zu </font></font><code>HexGrid.TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Konvertieren Sie zunächst die Koordinaten der Zelle in den entsprechenden Index des Arrays. </font><font style="vertical-align: inherit;">Für ein quadratisches Gitter wäre dies nur X plus Z multipliziert mit der Breite, aber in unserem Fall müssen wir auch einen Versatz von der Hälfte Z hinzufügen. Dann nehmen wir die Zelle, ändern ihre Farbe und triangulieren das Netz erneut.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Müssen wir wirklich das gesamte Netz neu triangulieren?</font></font></b> <div class="spoiler_text">    ,       .       .    ,    ,     .       . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = touchedColor; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir die Zellen jetzt einfärben können, sind visuelle Änderungen noch nicht sichtbar. </font><font style="vertical-align: inherit;">Dies liegt daran, dass der Shader standardmäßig keine Scheitelpunktfarben verwendet. </font><font style="vertical-align: inherit;">Wir müssen unsere eigenen schreiben. </font><font style="vertical-align: inherit;">Erstellen Sie einen neuen Standard-Shader ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / Create / Shader / Default Surface Shader</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Es müssen nur zwei Änderungen vorgenommen werden. </font><font style="vertical-align: inherit;">Fügen Sie zunächst Farbdaten zu der Eingabestruktur hinzu. </font><font style="vertical-align: inherit;">Zweitens multiplizieren Sie die Albedo mit dieser Farbe. </font><font style="vertical-align: inherit;">Wir interessieren uns nur für RGB-Kanäle, weil das Material undurchsichtig ist.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/VertexColors" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie mit diesem Shader ein neues Material und lassen Sie das Maschennetz dieses Material verwenden. </font><font style="vertical-align: inherit;">Dank dessen erscheinen die Farben der Zellen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/efe/be1/223efebe1bdda83c9b383dac32197c6e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbige Zellen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bekomme seltsame Schattenartefakte!</font></font></b> <div class="spoiler_text">    Unity        .          ,   ,   Z-.            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karteneditor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir nun wissen, wie man Farben ändert, erstellen wir einen einfachen In-Game-Editor. </font><font style="vertical-align: inherit;">Diese Funktionalität gilt nicht für Funktionen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher werden wir sie </font></font><code>TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine allgemeine Methode mit einem zusätzlichen Farbparameter umwandeln. </font><font style="vertical-align: inherit;">Löschen Sie auch das Feld </font></font><code>touchedColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Color color</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = color; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Komponente </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verschieben Sie die Methoden </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">dorthin </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie ein gemeinsames Feld hinzu, um auf das Sechseckraster, ein Array von Farben und ein privates Feld zu verweisen, um die aktive Farbe zu verfolgen. </font><font style="vertical-align: inherit;">Fügen Sie abschließend eine allgemeine Methode zum Auswählen einer Farbe hinzu und lassen Sie sie zunächst die erste Farbe auswählen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color activeColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SelectColor(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { hexGrid.ColorCell(hit.point, activeColor); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeColor = colors[index]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine weitere Zeichenfläche hinzu, wobei Sie die Standardeinstellungen beibehalten. </font><font style="vertical-align: inherit;">Fügen Sie eine Komponente hinzu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definieren Sie mehrere Farben und verbinden Sie sie mit einem Sechseckraster. </font><font style="vertical-align: inherit;">Dieses Mal benötigen wir ein Ereignissystemobjekt, das automatisch neu erstellt wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/0d6/be4/d180d6be4c656688f4ec6c4f5789bdba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vierfarbiger Sechskant-Karteneditor. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der Leinwand ein Bedienfeld zum Speichern von Farbwählern hinzu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Bedienfeld</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Fügen Sie ihre Umschaltgruppe hinzu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponenten / Benutzeroberfläche / Umschaltgruppe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Machen Sie das Panel klein und platzieren Sie es in der Ecke des Bildschirms.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/b05/4db/63fb054dbb5c64fce6c4671283df6e6a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbbedienfeld mit Umschaltgruppe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Füllen Sie nun das Bedienfeld mit Schaltern für jede Farbe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Toggle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Solange wir uns nicht mit der Erstellung einer komplexen Benutzeroberfläche beschäftigen, reicht eine einfache manuelle Konfiguration aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/40e/ffc/eef40effcb9510ba924186b766a1fee0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/0e4/595/d580e45954552b134082a9379af2eb8c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Schalter für jede Farbe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie den ersten Schalter ein. </font><font style="vertical-align: inherit;">Machen Sie außerdem alle Schalter zu Teilen der Umschaltgruppe, sodass jeweils nur einer ausgewählt werden kann. </font><font style="vertical-align: inherit;">Verbinden Sie sie schließlich mit </font></font><code>SelectColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">unseres Editors. </font><font style="vertical-align: inherit;">Dies kann über die Schaltfläche "+" der Benutzeroberfläche des Ereignisses " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed" erfolgen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wählen Sie das Karteneditorobjekt aus und wählen Sie dann die gewünschte Methode aus der Dropdown-Liste aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/e05/0af/7b4e050afca862a244607248834676aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schalter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Ereignis übergibt ein boolesches Argument, das bestimmt, ob der Schalter bei jeder Änderung eingeschaltet wird. </font><font style="vertical-align: inherit;">Aber es ist uns egal. </font><font style="vertical-align: inherit;">Stattdessen müssen wir manuell ein ganzzahliges Argument übergeben, das dem Farbindex entspricht, den wir verwenden möchten. </font><font style="vertical-align: inherit;">Lassen Sie daher den Wert 0 für den ersten Schalter, setzen Sie den Wert 1 auf den zweiten und so weiter.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann wird die Switch-Event-Methode aufgerufen?</font></font></b> <div class="spoiler_text">       .      ,    ,   . <br><br>      ,         ,    .  ,  <code>SelectColor</code>   .  ,      . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/0bb/8f4/35a0bb8f4425b0c821836f9aa9afda16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Färbung in mehreren Farben. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Benutzeroberfläche funktioniert, gibt es ein nerviges Detail. </font><font style="vertical-align: inherit;">Bewegen Sie das Bedienfeld so, dass es das Sechseckgitter bedeckt, um es zu sehen. </font><font style="vertical-align: inherit;">Bei der Auswahl einer neuen Farbe werden auch die Zellen unter der Benutzeroberfläche eingefärbt. </font><font style="vertical-align: inherit;">Das heißt, wir interagieren gleichzeitig mit der Benutzeroberfläche und dem Raster. </font><font style="vertical-align: inherit;">Dies ist ein unerwünschtes Verhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann behoben werden, indem das Ereignissystem gefragt wird, ob es die Position des Cursors über einem Objekt bestimmt hat. </font><font style="vertical-align: inherit;">Da sie nur über UI-Objekte Bescheid weiß, wird uns dies mitteilen, dass wir mit der UI interagieren. </font><font style="vertical-align: inherit;">Daher müssen wir die Eingabe nur dann selbst verarbeiten, wenn dies nicht der Fall ist.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 2: Mischen von Zellfarben </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsverzeichnis </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbinden Sie die Nachbarn. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolieren Sie die Farben zwischen den Dreiecken. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie Mischbereiche. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vereinfachen Sie die Geometrie. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir den Grundstein für das Raster gelegt und die Möglichkeit zum Bearbeiten von Zellen hinzugefügt. </font><font style="vertical-align: inherit;">Jede Zelle hat ihre eigene Volltonfarbe und die Farben an den Zellenrändern ändern sich dramatisch. </font><font style="vertical-align: inherit;">In diesem Tutorial erstellen wir Übergangszonen, in denen die Farben benachbarter Zellen gemischt werden.</font></font><br><cut></cut><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/518/132/8ca518132084099a6159027d4a345710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte Übergänge zwischen Zellen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachbarzellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir eine Glättung zwischen den Farben der Zellen durchführen, müssen wir herausfinden, welche der Zellen nebeneinander liegen. </font><font style="vertical-align: inherit;">Jede Zelle hat sechs Nachbarn, die in Richtung der Kardinalpunkte identifiziert werden können. </font><font style="vertical-align: inherit;">Wir erhalten die folgenden Richtungen: Nordosten, Osten, Südosten, Südwesten, Westen und Nordwesten. </font><font style="vertical-align: inherit;">Erstellen wir eine Aufzählung für sie und fügen sie in eine separate Skriptdatei ein.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist Aufzählung?</font></font></b> <div class="spoiler_text"> <code>enum</code>     ,     .            .      ,      .  ,        . <br><br>  enum     .   ,     integer  .   ,    -  ,    integer. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/e0e/37f/181e0e37fdd59ab37214cc909409351c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sechs Nachbarn, sechs Richtungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array </font><font style="vertical-align: inherit;">hinzu, um diese Nachbarn zu speichern </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obwohl wir es allgemein machen können, werden wir es stattdessen privat machen und den Zugriff auf Methoden unter Verwendung von Anweisungen ermöglichen. </font><font style="vertical-align: inherit;">Wir machen es auch serialisierbar, damit die Bindungen bei der Neukompilierung nicht verloren gehen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] HexCell[] neighbors;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Müssen wir alle Verbindungen zu Nachbarn speichern?</font></font></b> <div class="spoiler_text">       ,       .     —    ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird das Array der Nachbarn im Inspektor angezeigt. </font><font style="vertical-align: inherit;">Da jede Zelle sechs Nachbarn hat, legen </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">für unser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighaus </font><font style="vertical-align: inherit;">die Größe von Array 6 fest.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/8c1/a2e/6ef8c1a2ee9478b007faefcef2516934.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Fertighaus ist Platz für sechs Nachbarn. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir nun eine allgemeine Methode hinzu, um einen Zellnachbarn in eine Richtung zu erhalten. </font><font style="vertical-align: inherit;">Da der Richtungswert immer im Bereich von 0 bis 5 liegt, müssen wir nicht prüfen, ob sich der Index innerhalb des Arrays befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fügen Sie eine Methode hinzu, um einen Nachbarn anzugeben. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Beziehungen der Nachbarn sind bidirektional. </font><font style="vertical-align: inherit;">Wenn Sie einen Nachbarn in eine Richtung setzen, ist es daher logisch, einen Nachbarn sofort in die entgegengesetzte Richtung zu setzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; cell.neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction.Opposite()] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b86/616/15c/b8661615ceece04f7f4c16fa1c032be4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbarn in entgegengesetzte Richtungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies deutet natürlich darauf hin, dass wir Anweisungen für den gegenüberliegenden Nachbarn anfordern können. </font><font style="vertical-align: inherit;">Wir können dies implementieren, indem wir eine Erweiterungsmethode für erstellen </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um die entgegengesetzte Richtung zu erhalten, müssen Sie zum Original 3 hinzufügen. Dies funktioniert jedoch nur für die ersten drei Richtungen, für den Rest müssen Sie 3 subtrahieren.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexDirectionExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Opposite</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> ? (direction + <span class="hljs-number"><span class="hljs-number">3</span></span>) : (direction - <span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist eine Erweiterungsmethode?</font></font></b> <div class="spoiler_text">   —      ,       - .       — , , ,    .         <code>this</code> .      ,     . <br><br>        ? ,  ,       ,      .    ?    — .  ,      ,        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachbarverbindung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können den Nachbarlink in initialisieren </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir Zellen Zeile für Zeile von links nach rechts durchlaufen, wissen wir, welche Zellen bereits erstellt wurden. </font><font style="vertical-align: inherit;">Dies sind die Zellen, mit denen wir uns verbinden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am einfachsten ist die E - W - Verbindung. </font><font style="vertical-align: inherit;">Die erste Zelle jeder Reihe hat keinen östlichen Nachbarn. </font><font style="vertical-align: inherit;">Aber alle anderen Zellen haben es. </font><font style="vertical-align: inherit;">Und diese Nachbarn werden vor der Zelle erstellt, mit der wir gerade arbeiten. </font><font style="vertical-align: inherit;">Deshalb können wir sie verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/3bf/16f/7873bf16fdecde4ff216cc30b206ce89.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verbindung von E nach W während der Erstellung von Zellen.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.color = defaultColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/560/08e/8b6/56008e8b6b2c16f3da710a2cedebb7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die östlichen und westlichen Nachbarn sind miteinander verbunden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen zwei weitere bidirektionale Verbindungen erstellen. </font><font style="vertical-align: inherit;">Da dies die Verbindungen zwischen verschiedenen Linien des Gitters sind, können wir nur mit der vorherigen Linie kommunizieren. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die erste Zeile vollständig überspringen müssen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Linien im Zickzack sind, müssen sie unterschiedlich verarbeitet werden. </font><font style="vertical-align: inherit;">Lassen Sie uns zuerst mit geraden Linien umgehen. </font><font style="vertical-align: inherit;">Da alle Zellen in solchen Zeilen einen Nachbarn auf SE haben, können wir sie damit verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/e56/419/7d5e56419ed4a0fb7b2c506061543561.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung von NW nach SE für gerade Linien.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht z &amp; 1?</font></font></b> <div class="spoiler_text"> <code>&amp;&amp;</code> —    ,  <code>&amp;</code> —    .     ,         .      1,      1. , <code>10101010 &amp; 00001111</code>  <code>00001010</code> . <br><br>     .    0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,         0. <br><br>      ,  ,    .    0,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können uns mit Nachbarn in der SW verbinden, mit Ausnahme der ersten Zelle jeder Zeile, die diese nicht hat. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed1/f7a/73c/ed1f7a73c9e09970a041e4596668626b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung von NE nach SW für gerade Linien.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungerade Linien folgen der gleichen Logik, jedoch spiegelbildlich. </font><font style="vertical-align: inherit;">Nach Abschluss dieses Vorgangs sind alle Nachbarn in unserem Netz verbunden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; width - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/eee/ff1/00beeeff163b36232bd37f6076c34c90.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Nachbarn sind verbunden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist nicht jede Zelle mit genau sechs Nachbarn verbunden. </font><font style="vertical-align: inherit;">Zellen an der Gittergrenze haben mindestens zwei und nicht mehr als fünf Nachbarn. </font><font style="vertical-align: inherit;">Und das muss berücksichtigt werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/4a9/1c5/e7a4a91c55e7cc2574eed105f7b9a110.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbarn für jede Zelle. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farbmischung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen von Farben erschwert die Triangulation jeder Zelle. </font><font style="vertical-align: inherit;">Lassen Sie uns daher den Triangulationscode in einem separaten Teil trennen. </font><font style="vertical-align: inherit;">Da wir jetzt Anweisungen haben, verwenden wir sie anstelle von numerischen Indizes, um Teile anzuzeigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction], center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir jetzt Richtungen verwenden, wäre es praktisch, Winkel mit Richtungen zu erhalten und nicht die Konvertierung in Indizes durchzuführen. </font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu müssen Sie </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei statische Methoden </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als Bonus können wir so die Auswahl der Winkel privat machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Farben auf einem Dreieck </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher hat die Methode </font></font><code>HexMesh.AddTriangleColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur ein Farbargument. </font><font style="vertical-align: inherit;">Es kann nur ein einfarbiges Dreieck erstellt werden. </font><font style="vertical-align: inherit;">Erstellen wir eine Alternative, die separate Farben für jeden Scheitelpunkt unterstützt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir anfangen, Farben zu mischen! </font><font style="vertical-align: inherit;">Beginnen wir einfach mit der Nachbarfarbe für die beiden anderen Eckpunkte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) ); HexCell neighbor = cell.GetNeighbor(direction); AddTriangleColor(cell.color, neighbor.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies führt leider dazu </font></font><code>NullReferenceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dass die Zellen an der Grenze keine sechs Nachbarn haben. </font><font style="vertical-align: inherit;">Was sollen wir tun, wenn ein Nachbar fehlt? </font><font style="vertical-align: inherit;">Seien wir pragmatisch und verwenden die Zelle selbst als Ersatz.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht der Betreiber?</font></font></b> <div class="spoiler_text">    null-coalescing operator.   ,  <code>a ?? b</code> —      <code>a != null ? a : b</code> . <br><br>   ,     -   Unity   .           <code>null</code> .        . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/558/667/3755586675e7126b25e776f1283ec8b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Mischung von Farben, aber es wird falsch gemacht.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wohin gingen die Koordinatenbeschriftungen?</font></font></b> <div class="spoiler_text">   ,       UI. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farbmittelung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen von Farben funktioniert, aber die Ergebnisse sind offensichtlich falsch. </font><font style="vertical-align: inherit;">Die Farbe an den Rändern der Sechsecke sollte der Durchschnitt zweier benachbarter Zellen sein.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Color edgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddTriangleColor(cell.color, edgeColor, edgeColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/079/b26/aff079b261e39c1959d004c0ddf3a58f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rippen mischen. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir an den Rändern mischen, erhalten wir immer noch scharfe Farbränder. </font><font style="vertical-align: inherit;">Dies geschieht, weil jeder Scheitelpunkt des Sechsecks von drei Sechsecken geteilt wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/8f2/507/19e8f2507f011213c1514ea20ce04906.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Nachbarn, vier Farben. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass wir auch Nachbarn in der vorherigen und nächsten Richtung berücksichtigen müssen. </font><font style="vertical-align: inherit;">Das heißt, wir erhalten vier Farben in zwei Dreiergruppen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir </font></font><code>HexDirectionExtensions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Additionsmethoden für einen bequemen Übergang zur vorherigen und nächsten Richtung hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NE ? HexDirection.NW : (direction - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NW ? HexDirection.NE : (direction + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir alle drei Nachbarn bekommen und Drei-Wege-Mischen durchführen. </font></font><br><br><pre> <code class="cs hljs"> HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/b19/778/430b197786bb2bde51fb528946561733.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An den Ecken mischen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So erhalten wir die richtigen Farbübergänge mit Ausnahme des Netzrandes. </font><font style="vertical-align: inherit;">Die Randzellen stimmen nicht mit den Farben der fehlenden Nachbarn überein, daher sehen wir hier immer noch scharfe Ränder. </font><font style="vertical-align: inherit;">Im Allgemeinen liefert unser derzeitiger Ansatz jedoch keine guten Ergebnisse. </font><font style="vertical-align: inherit;">Wir brauchen eine bessere Strategie. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mischbereiche </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen über die gesamte Oberfläche des Sechsecks führt zu verschwommenem Chaos. </font><font style="vertical-align: inherit;">Wir können einzelne Zellen nicht klar sehen. </font><font style="vertical-align: inherit;">Die Ergebnisse können erheblich verbessert werden, indem nur neben den Kanten der Sechsecke gemischt wird. </font><font style="vertical-align: inherit;">In diesem Fall behält der innere Bereich der Sechsecke eine feste Farbe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/82a/ff6/53e82aff62f060a51ef5645accd45d03.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontinuierliche Schattierung von Cent mit Mischbereichen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie groß sollte der feste Bereich im Vergleich zum Mischbereich sein? </font><font style="vertical-align: inherit;">Unterschiedliche Verteilungen führen zu unterschiedlichen Ergebnissen. </font><font style="vertical-align: inherit;">Wir werden diesen Bereich als Bruchteil des Außenradius definieren. </font><font style="vertical-align: inherit;">Lassen Sie es gleich 75% sein. </font><font style="vertical-align: inherit;">Dies wird uns zu zwei neuen Metriken führen, die insgesamt 100% betragen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - solidFactor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch Erstellen dieses neuen festen Füllfaktors können wir Methoden schreiben, um die Winkel fester innerer Sechsecke zu erhalten. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * solidFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * solidFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie es </font><font style="vertical-align: inherit;">jetzt </font><font style="vertical-align: inherit;">so, dass diese festen Schattierungswinkel anstelle der ursprünglichen Winkel verwendet werden. </font><font style="vertical-align: inherit;">Wir lassen die Farben vorerst gleich.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d40/eb5/326/d40eb5326b0e0457e55ae2752897efc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feste Sechsecke ohne Kanten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation von Mischbereichen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen den leeren Raum ausfüllen, den wir durch Reduzieren der Dreiecke erstellt haben. </font><font style="vertical-align: inherit;">In jeder Richtung hat dieser Raum die Form eines Trapezes. </font><font style="vertical-align: inherit;">Um es abzudecken, können Sie das Viereck (Quad) verwenden. </font><font style="vertical-align: inherit;">Daher werden wir Methoden erstellen, um ein Viereck und seine Farben hinzuzufügen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/bc9/ce5/c2fbc9ce504e0e8df61b194f20c83f3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trapezrippe.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3, Color c4</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); colors.Add(c4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es neu, so dass das Dreieck eine Farbe erhält und das Viereck eine Mischung zwischen einer Volltonfarbe und den Farben zweier Winkel ausführt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); Vector3 v3 = center + HexMetrics.GetFirstCorner(direction); Vector3 v4 = center + HexMetrics.GetSecondCorner(direction); AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor( cell.color, cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aea/8de/d01/aea8ded01fc8928ec64293b11b335a91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen mit Trapezrippen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brücken zwischen Rippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bild wird besser, aber die Arbeit ist noch nicht abgeschlossen. </font><font style="vertical-align: inherit;">Das Mischen von Farben zwischen zwei Nachbarn wird durch benachbarte Zellen kontaminiert. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, müssen wir die Ecken des Trapezes abschneiden und in ein Rechteck verwandeln. </font><font style="vertical-align: inherit;">Danach wird er eine Brücke zwischen der Zelle und ihrem Nachbarn bauen und Lücken an den Seiten hinterlassen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/acf/602/b76acf602ad32b7001117a17c0e6c72f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Brücke zwischen den Rippen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können neue Positionen finden </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, beginnend mit </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann entlang der Brücke bis zum Rand der Zelle gehen. </font><font style="vertical-align: inherit;">Wie wird die Brücke verschoben? </font><font style="vertical-align: inherit;">Wir können es finden, indem wir den Mittelpunkt zwischen den beiden entsprechenden Winkeln nehmen und dann den Mischungskoeffizienten darauf anwenden. </font><font style="vertical-align: inherit;">Das wird reichen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * blendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurück zu </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es ist jetzt logisch, eine Option hinzuzufügen </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die nur zwei Farben erfordert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c1); colors.Add(c2); colors.Add(c2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie es </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass richtig gemischte Brücken zwischen den Nachbarn entstehen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor(cell.color, (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/0bd/fb3/2880bdfb3ae5b97a5907164fc8b71774.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig gestrichene Brücken mit Eckabständen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lücken füllen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir eine dreieckige Lücke an der Verbindungsstelle von drei Zellen gebildet. </font><font style="vertical-align: inherit;">Wir haben diese Lücken durch Ausschneiden der dreieckigen Seiten des Trapezes erhalten. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Dreiecke zurückbekommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich zunächst ein Dreieck vor, das mit einem vorherigen Nachbarn verbunden ist. </font><font style="vertical-align: inherit;">Sein erster Scheitelpunkt hat eine Zellfarbe. </font><font style="vertical-align: inherit;">Die Farbe des zweiten Peaks ist eine Mischung aus drei Farben. </font><font style="vertical-align: inherit;">Und der letzte Gipfel hat die gleiche Farbe wie der Punkt in der Mitte der Brücke.</font></font><br><br><pre> <code class="cs hljs"> Color bridgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddQuadColor(cell.color, bridgeColor); AddTriangle(v1, center + HexMetrics.GetFirstCorner(direction), v3); AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, bridgeColor );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/d75/a50/b7fd75a50368ba2bcb79595fa1c58329.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast alles ist fertig. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein anderes Dreieck funktioniert auf die gleiche Weise, außer dass die Brücke nicht den dritten, sondern den zweiten Gipfel berührt.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, center + HexMetrics.GetSecondCorner(direction)); AddTriangleColor( cell.color, bridgeColor, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/7b2/d71/9a57b2d71d5db4aa2c22a2aba954babe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volle Färbung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir schöne Mischbereiche, die wir jeder Größe geben können. </font><font style="vertical-align: inherit;">Die Kanten können nach Belieben verschwommen oder scharf gemacht werden. </font><font style="vertical-align: inherit;">Sie können jedoch feststellen, dass das Mischen in der Nähe des Netzrandes immer noch nicht korrekt implementiert ist. </font><font style="vertical-align: inherit;">Und wieder werden wir es für später belassen und uns vorerst auf ein anderes Thema konzentrieren.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber die Übergänge zwischen den Farben sind immer noch hässlich</font></font></b> <div class="spoiler_text">     .            .            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rippenfusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich die Topologie unseres Rasters an. </font><font style="vertical-align: inherit;">Welche Formen fallen hier auf? </font><font style="vertical-align: inherit;">Wenn Sie die Grenze nicht beachten, können wir drei verschiedene Arten von Formularen unterscheiden. </font><font style="vertical-align: inherit;">Es gibt einfarbige Sechsecke, zweifarbige Rechtecke und dreifarbige Dreiecke. </font><font style="vertical-align: inherit;">Alle diese drei Farben erscheinen an der Verbindungsstelle der drei Zellen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a27/370/ae7/a27370ae7474595516c3186adb393590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei visuelle Strukturen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle zwei Sechsecke sind also durch eine rechteckige Brücke verbunden. </font><font style="vertical-align: inherit;">Und alle drei Sechsecke sind durch ein Dreieck verbunden. </font><font style="vertical-align: inherit;">Wir führen jedoch eine komplexere Triangulation durch. </font><font style="vertical-align: inherit;">Jetzt verwenden wir zwei Vierecke anstelle von einem, um ein Paar Sechsecke zu verbinden. </font><font style="vertical-align: inherit;">Und um die drei Sechsecke zu verbinden, verwenden wir sechs Dreiecke. </font><font style="vertical-align: inherit;">Das ist zu redundant. </font><font style="vertical-align: inherit;">Wenn wir uns direkt mit einer Form verbinden würden, müssten wir keine Farbmittelung vornehmen. </font><font style="vertical-align: inherit;">Daher könnten wir mit weniger Komplexität, weniger Arbeit und weniger Dreiecken auskommen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/448/ef3/e5d448ef31208fd42f3e7e73138c3b48.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Härter als nötig.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum brauchen wir das überhaupt?</font></font></b> <div class="spoiler_text"> ,        .   ,     ,   .   ,        ,     .       ,   ,   . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direkte Überbrückung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt bestehen unsere Brücken zwischen den Rippen aus zwei Vierecken. Um sie auf das nächste Sechseck auszudehnen, müssen wir die Länge der Brücke verdoppeln. Dies bedeutet, dass wir nicht mehr zwei Winkel mitteln müssen </font></font><code>HexMetrics.GetBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Stattdessen addieren wir sie einfach und multiplizieren sie dann mit dem Mischfaktor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * blendFactor; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/8d6/33f/f168d633fff07b5ecd6bf361e14e0edd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Brücken überspannten die gesamte Länge und überlappten sich. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken stellen jetzt direkte Verbindungen zwischen Sechsecken her. </font><font style="vertical-align: inherit;">Wir erzeugen aber immer noch zwei Vierecke pro Verbindung, eines in jede Richtung. </font><font style="vertical-align: inherit;">Das heißt, nur einer von ihnen sollte Brücken zwischen zwei Zellen schaffen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachen wir zuerst unseren Triangulationscode. </font><font style="vertical-align: inherit;">Wir löschen alles, was mit den Dreiecken der Kanten und der Farbmischung zu tun hat. </font><font style="vertical-align: inherit;">Verschieben Sie dann den Code, der das Viereck der Brücke zur neuen Methode hinzufügt. </font><font style="vertical-align: inherit;">Wir übergeben die ersten beiden Eckpunkte an diese Methode, damit wir sie nicht neu berechnen müssen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); TriangulateConnection(direction, cell, v1, v2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Triangulation von Verbindungen leicht begrenzen. </font><font style="vertical-align: inherit;">Zunächst fügen wir die Bridge nur hinzu, wenn Sie mit der NE-Verbindung arbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == HexDirection.NE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/7ac/53f/cfa7ac53f3fbab322c4c481f29ec1cac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brücken sind nur in Richtung NE. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass wir alle Verbindungen abdecken können, indem wir sie nur in die ersten drei Richtungen triangulieren: NE, E und SE.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/568/698/e07/568698e079839a5ff4108083c6f71d8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle internen Brücken und Brücken an den Grenzen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben alle Verbindungen zwischen zwei benachbarten Zellen abgedeckt. </font><font style="vertical-align: inherit;">Wir haben aber auch einige Brücken, die von der Zelle ins Nirgendwo führen. </font><font style="vertical-align: inherit;">Lassen Sie uns sie loswerden und raus, </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Nachbarn raus sind. </font><font style="vertical-align: inherit;">Das heißt, wir müssen die fehlenden Nachbarn nicht mehr durch die Zelle selbst ersetzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/54c/21d/5a254c21d71cf66817a1ee42b7f02ddd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur interne Brücken.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dreiecksgelenke </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir die dreieckigen Lücken wieder schließen. </font><font style="vertical-align: inherit;">Lassen Sie uns dies für ein Dreieck tun, das mit dem nächsten Nachbarn verbunden ist. </font><font style="vertical-align: inherit;">Und dies muss wieder nur getan werden, wenn ein Nachbar existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wird die Position des dritten Gipfels sein? </font><font style="vertical-align: inherit;">Ich habe als Ersatz eingefügt </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber das ist offensichtlich falsch. </font><font style="vertical-align: inherit;">Da jede Kante dieser Dreiecke mit der Brücke verbunden ist, können wir sie finden, indem wir entlang der Brücke zum nächsten Nachbarn gehen.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/256/bde/b5c256bde3a05d41287ca96007e208f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen wieder die vollständige Triangulation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind wir fertig? </font><font style="vertical-align: inherit;">Noch nicht, denn jetzt erstellen wir überlappende Dreiecke. </font><font style="vertical-align: inherit;">Da die drei Zellen eine gemeinsame Dreiecksverbindung haben, müssen sie nur für zwei Verbindungen hinzugefügt werden. </font><font style="vertical-align: inherit;">Daher werden NE und E. ausreichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next())); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 3: Höhen </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsverzeichnis </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenhöhe hinzufügen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulieren Sie die Hänge. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setzen Sie die Leisten ein. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kombinieren Sie Felsvorsprünge und Klippen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Teil des Tutorials werden wir Unterstützung für verschiedene Höhenstufen hinzufügen und spezielle Übergänge zwischen ihnen erstellen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/24a/e1f/8da24ae1f70e4770264ed0ab05d183ef.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Höhen und Leisten.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenhöhe </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben unsere Karte in separate Zellen unterteilt, die einen flachen Bereich abdecken. </font><font style="vertical-align: inherit;">Jetzt geben wir jeder Zelle ihre eigene Höhe. </font><font style="vertical-align: inherit;">Wir werden diskrete Höhenstufen verwenden, um sie als ganzzahliges Feld in zu speichern </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie groß kann jede nachfolgende Höhe sein? </font><font style="vertical-align: inherit;">Wir können jeden Wert verwenden, also setzen wir ihn als eine andere Konstante </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden einen Schritt von fünf Einheiten verwenden, damit die Übergänge deutlich sichtbar sind. </font><font style="vertical-align: inherit;">In einem echten Spiel würde ich einen kleineren Schritt verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen ändern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher konnten wir nur die Farbe der Zelle ändern, jetzt können wir ihre Höhe ändern. </font><font style="vertical-align: inherit;">Daher </font></font><code>HexGrid.ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reicht uns </font><font style="vertical-align: inherit;">die Methode </font><font style="vertical-align: inherit;">nicht aus. </font><font style="vertical-align: inherit;">Darüber hinaus können wir in Zukunft weitere Optionen für die Zellbearbeitung hinzufügen, sodass wir einen neuen Ansatz benötigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benennen Sie </font></font><code>ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in um </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und machen Sie es so, dass anstatt die Farbe der Zelle festzulegen, die Zelle an der angegebenen Position zurückgegeben wird. </font><font style="vertical-align: inherit;">Da diese Methode nichts anderes ändert, müssen wir die Zellen sofort triangulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[index]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird sich der Editor mit dem Zellwechsel befassen. </font><font style="vertical-align: inherit;">Nach Abschluss der Arbeiten muss das Gitter erneut trianguliert werden. </font><font style="vertical-align: inherit;">Fügen Sie dazu eine allgemeine Methode hinzu </font></font><code>HexGrid.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit er mit neuen Methoden arbeiten kann. </font><font style="vertical-align: inherit;">Geben wir ihm eine neue Methode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die alle Änderungen an der Zelle behandelt und anschließend das Raster aktualisiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCell(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir können die Höhen einfach ändern, indem wir der gewünschten Zelle die gewünschte Höhenstufe zuweisen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei Farben benötigen wir eine Methode zum Festlegen der aktiven Höhenstufe, die wir der Benutzeroberfläche zuordnen. </font><font style="vertical-align: inherit;">Um Werte aus dem Höhenintervall auszuwählen, verwenden wir den Schieberegler. </font><font style="vertical-align: inherit;">Da die Schieberegler mit float arbeiten, erfordert unsere Methode einen Parameter vom Typ float. </font><font style="vertical-align: inherit;">Wir werden es einfach in eine Ganzzahl konvertieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation</span></span></span><span class="hljs-function">)</span></span> { activeElevation = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)elevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie einen Schieberegler auf der Leinwand hinzu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / Create / Slider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und platzieren Sie ihn unter dem </font><i><font style="vertical-align: inherit;">Farbbedienfeld</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir machen es vertikal von unten nach oben, so dass es optisch den Höhen entspricht. </font><font style="vertical-align: inherit;">Wir beschränken es auf Ganzzahlen und erstellen ein geeignetes Intervall, z. B. von 0 bis 6. Dann hängen wir das Ereignis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an die </font><i><font style="vertical-align: inherit;">Hex Map Editor-</font></i></font><code>SetElevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektmethode an </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Methode muss aus der dynamischen Liste ausgewählt werden, damit sie mit dem Wert des Schiebereglers aufgerufen wird.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05f/6c5/93c/05f6c593cc553c4f4a86f9c2e9012156.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/0a5/e8b/7c60a5e8bfebd2ec87d2daaeeb148be6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Höhenregler.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Höhenvisualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Ändern einer Zelle stellen wir jetzt sowohl Farbe als auch Höhe ein. </font><font style="vertical-align: inherit;">Obwohl wir im Inspektor sehen können, dass sich die Höhe tatsächlich ändert, ignoriert der Triangulationsprozess sie immer noch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht aus, die vertikale lokale Position der Zelle zu ändern, wenn wir die Höhe ändern. </font><font style="vertical-align: inherit;">Machen Sie die Methode der Einfachheit halber </font></font><code>HexCell.elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privat und fügen Sie eine allgemeine Eigenschaft hinzu </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir die vertikale Position der Zelle beim Bearbeiten der Höhe ändern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfordert natürlich kleine Änderungen an </font></font><code>HexMapEditor.EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/5de/6eb/6525de6ebae59208507af3e8b744bab5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen mit unterschiedlichen Höhen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändert sich der Mesh-Collider an die neue Höhe?</font></font></b> <div class="spoiler_text">    Unity          mesh collider  null.  ,    ,      null    .   .     (     )  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellenhöhen sind jetzt sichtbar, aber es gibt zwei Probleme. </font><font style="vertical-align: inherit;">Erstens. </font><font style="vertical-align: inherit;">Zellmarkierungen verschwinden unter den erhabenen Zellen. </font><font style="vertical-align: inherit;">Zweitens ignorieren Verbindungen zwischen Zellen die Höhe. </font><font style="vertical-align: inherit;">Lass es uns reparieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ändern Sie die Position der Zellbezeichnungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit werden UI-Beschriftungen für Zellen nur einmal erstellt und platziert. Danach vergessen wir sie. </font><font style="vertical-align: inherit;">Um ihre vertikalen Positionen zu aktualisieren, müssen wir sie verfolgen. </font><font style="vertical-align: inherit;">Lassen Sie uns jedem einen </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinen UI-Labels geben, damit Sie ihn später aktualisieren können.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform uiRect;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie sie am Ende zu </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.uiRect = label.rectTransform; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir die Eigenschaft </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so erweitern, dass sich auch die Position der Benutzeroberfläche der Zelle ändert. </font><font style="vertical-align: inherit;">Da das Leinwandnetz der Sechsecke gedreht wird, müssen die Beschriftungen in negativer Richtung entlang der Z-Achse und nicht auf der positiven Seite der Y-Achse verschoben werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = elevation * -HexMetrics.elevationStep; uiRect.localPosition = uiPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/b81/c97/c72b81c970b2bddfe2b2ce6d22471dc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags mit Höhe.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schaffung von Pisten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt müssen wir die Flachzellenverbindungen in Steigungen umwandeln. </font><font style="vertical-align: inherit;">Dies geschieht in </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei Kantenverbindungen müssen wir die Höhe des anderen Endes der Brücke neu definieren.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei Eckfugen müssen wir dasselbe mit der Brücke zum nächsten Nachbarn tun. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; AddTriangle(v2, v4, v5); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49b/548/792/49b5487921c6844b7a282e049a97bbd9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung unter Berücksichtigung der Höhe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt unterstützen wir Zellen in unterschiedlichen Höhen mit den richtigen Schrägfugen zwischen ihnen. </font><font style="vertical-align: inherit;">Aber lasst uns hier nicht aufhören. </font><font style="vertical-align: inherit;">Wir werden diese Pisten interessanter machen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rippenfugen mit Leisten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerade Hänge sehen nicht sehr attraktiv aus. </font><font style="vertical-align: inherit;">Wir können sie in mehrere Schritte unterteilen, indem wir Schritte hinzufügen. </font><font style="vertical-align: inherit;">Dieser Ansatz wird im Spiel Endless Legend verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel können wir an jedem Hang zwei Leisten einfügen. </font><font style="vertical-align: inherit;">Infolgedessen verwandelt sich ein großer Hang in drei kleine, zwischen denen sich zwei flache Bereiche befinden. </font><font style="vertical-align: inherit;">Um ein solches Schema zu triangulieren, müssen wir jede Verbindung in fünf Stufen trennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce3/08b/82d/ce308b82db1bb0c72c387cc9da480d54.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Vorsprünge am Hang. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Anzahl der Stufen für die Steigung einstellen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und daraus die Anzahl der Stufen berechnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terracesPerSlope = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terraceSteps = terracesPerSlope * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Idealfall könnten wir einfach jeden Schritt entlang der Steigung interpolieren. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht ganz trivial, da sich die Y-Koordinate nur in ungeraden Stufen ändern sollte. </font><font style="vertical-align: inherit;">Andernfalls erhalten wir keine flachen Leisten. </font><font style="vertical-align: inherit;">Fügen wir hierfür eine spezielle Interpolationsmethode hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die horizontale Interpolation ist einfach, wenn wir die Größe des Interpolationsschritts kennen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> horizontalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / terraceSteps; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert die Interpolation zwischen zwei Werten?</font></font></b> <div class="spoiler_text">     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">a</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.074ex" viewBox="0 -772.3 429.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-62" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6">b</script>      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7">t</script>  .  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">t</script>  0,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9">a</script>  .    1,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.074ex" viewBox="0 -772.3 429.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-62" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-10">b</script>  .  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11">t</script>  -  0  1, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-12">a</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">b</span></span></span><script type="math/tex" id="MathJax-Element-13">b</script>  .       : <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-99"><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-101">1</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">t</span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">a</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">b</span></span></span><script type="math/tex" id="MathJax-Element-14">(1 - t)a + tb</script>  . <br><br>  ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-111">1</span><span class="MJXp-mo" id="MJXp-Span-112" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">t</span><span class="MJXp-mo" id="MJXp-Span-114" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115">a</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118">b</span><span class="MJXp-mo" id="MJXp-Span-119" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">a</span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">a</span><span class="MJXp-mo" id="MJXp-Span-124" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">b</span><span class="MJXp-mo" id="MJXp-Span-127" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">a</span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">t</span><span class="MJXp-mo" id="MJXp-Span-131" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">b</span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">a</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-15">(1 - t)a + tb = a - ta + tb = a + t(b - a)</script>  .        <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">a</span></span></span><script type="math/tex" id="MathJax-Element-16">a</script>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-138"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">b</span></span></span><script type="math/tex" id="MathJax-Element-17">b</script>   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">b</span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">a</span><span class="MJXp-mo" id="MJXp-Span-145" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-18">(b - a)</script>  .  ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um Y nur in ungeraden Stadien zu ändern, können wir verwenden </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-146"><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-150"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-153"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-155"><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19">(step + 1) / 2</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir eine ganzzahlige Division verwenden, wird die Reihe 1, 2, 3, 4 in 1, 1, 2, 2 umgewandelt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> verticalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (terracesPerSlope + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = ((step + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.verticalTerraceStepSize; ay += (<span class="hljs-keyword"><span class="hljs-keyword">by</span></span> - ay) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir eine Methode zum Interpolieren von Leisten für Farben hinzu. </font><font style="vertical-align: inherit;">Interpolieren Sie sie einfach so, als ob die Verbindungen flach wären.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color a, Color b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Color.Lerp(a, b, h); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Triangulation der Kantenverbindung komplizierter wird, entfernen wir den entsprechenden Code aus </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und platzieren ihn in einer separaten Methode. </font><font style="vertical-align: inherit;">In den Kommentaren werde ich den Quellcode speichern, um in Zukunft darauf zu verweisen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep; TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color); … } void TriangulateEdgeTerraces ( Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell ) { AddQuad(beginLeft, beginRight, endLeft, endRight); AddQuadColor(beginCell.color, endCell.color); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem ersten Schritt des Prozesses. </font><font style="vertical-align: inherit;">Wir werden unsere speziellen Interpolationsmethoden verwenden, um das erste Quad zu erstellen. </font><font style="vertical-align: inherit;">In diesem Fall sollte eine kurze Steigung erzeugt werden, die steiler als die ursprüngliche ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/434/174/aea/434174aea469a4ba7da285ff02d4467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt beim Erstellen einer Kante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir sofort zur letzten Stufe übergehen und alles dazwischen überspringen. </font><font style="vertical-align: inherit;">Dies wird die Verbindung der Kanten vervollständigen, wenn auch bisher mit einer unregelmäßigen Form.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/1be/b3e/c6f1beb3ee6663cf8984130dc3d9378e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Schritt beim Erstellen einer Kante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwischenschritte können durch die Schleife hinzugefügt werden. </font><font style="vertical-align: inherit;">In jeder Phase werden die letzten beiden vorherigen Scheitelpunkte die neuen ersten. </font><font style="vertical-align: inherit;">Gleiches gilt für Farbe. </font><font style="vertical-align: inherit;">Nach der Berechnung der neuen Vektoren und Farben wird ein weiteres Quad hinzugefügt.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c2; v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, i); v4 = HexMetrics.TerraceLerp(beginRight, endRight, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2); } AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/20f/64c/e6d20f64c28feaa5329f085d8a5b673a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Zwischenschritte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben alle Kantenfugen zwei Leisten oder eine andere Zahl, die Sie in angeben </font></font><code>HexMetrics.terracesPerSlope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bis wir Leisten für Eckverbindungen erstellt haben, werden wir dies natürlich für später belassen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/37b/4f9/4f337b4f9ba0092144e1148b10a4970b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Kantenfugen haben Leisten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbindungstypen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Umrüsten aller Kantenfugen in Leisten ist keine so gute Idee. </font><font style="vertical-align: inherit;">Sie sehen nur dann gut aus, wenn der Höhenunterschied nur eine Ebene beträgt. </font><font style="vertical-align: inherit;">Mit einem größeren Unterschied werden jedoch schmale Leisten mit großen Lücken zwischen ihnen erzeugt, und dies sieht nicht sehr schön aus. </font><font style="vertical-align: inherit;">Außerdem müssen wir nicht für alle Verbindungen Leisten erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns dies formalisieren und drei Arten von Kanten definieren: eine Ebene, eine Neigung und eine Klippe. </font><font style="vertical-align: inherit;">Erstellen wir hierfür eine Aufzählung.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexEdgeType { Flat, Slope, Cliff }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man feststellen, um welche Art von Verbindung es sich handelt? </font><font style="vertical-align: inherit;">Dazu können wir eine </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">hinzufügen </font><font style="vertical-align: inherit;">, die zwei Höhenstufen verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Höhen gleich sind, haben wir eine flache Rippe. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Pegelunterschied einem Schritt entspricht, ist dies eine Steigung. </font><font style="vertical-align: inherit;">Es ist egal, ob es hoch oder runter geht. </font><font style="vertical-align: inherit;">In allen anderen Fällen bekommen wir eine Pause.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = elevation2 - elevation1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">1</span></span> || delta == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Slope; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Cliff; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir auch eine bequeme Methode hinzu </font></font><code>HexCell.GetEdgeType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den Typ der Zellkante in eine bestimmte Richtung zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction].elevation ); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Müssen wir nicht prüfen, ob in dieser Richtung ein Nachbar existiert?</font></font></b> <div class="spoiler_text">   ,       ,     .      ,    <code>NullReferenceException</code> .       ,    ,    - .    ,     .       . <br><br> ,        ,  ,       .    - ,   <code>NullReferenceException</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie Leisten nur für Hänge </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Art der Verbindung bestimmen können, können wir entscheiden, ob Leisten eingefügt werden sollen. </font><font style="vertical-align: inherit;">Ändern Sie dies </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er nur für die Pisten Leisten erstellt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An dieser Stelle können wir den zuvor auskommentierten Code auskommentieren, damit er Ebenen und Ausschnitte verarbeiten kann. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/bb8/1e6/15abb81e60a35fb6383ff8be8b0a17dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Stufen werden nur an den Hängen erstellt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leisten mit Leisten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eckfugen sind komplexer als Kantenfugen, da sie nicht an zwei, sondern an drei Zellen beteiligt sind. </font><font style="vertical-align: inherit;">Jede Ecke ist mit drei Kanten verbunden, die Ebenen, Hänge oder Klippen sein können. </font><font style="vertical-align: inherit;">Daher gibt es viele mögliche Konfigurationen. </font><font style="vertical-align: inherit;">Wie bei Rippengelenken fügen wir der </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Methode </font><font style="vertical-align: inherit;">eine </font><font style="vertical-align: inherit;">Triangulation </font><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere neue Methode erfordert die Eckpunkte eines eckigen Dreiecks und verbundener Zellen. </font><font style="vertical-align: inherit;">Ordnen Sie die Verbindungen der Einfachheit halber so an, dass Sie wissen, welche Zelle die kleinste Höhe hat. </font><font style="vertical-align: inherit;">Danach können wir von links unten und rechts mit der Arbeit beginnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b24/351/681/b243516810fc9f0e8c44a5cb12f74cff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eckverbindung.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">feststellen, welche der Zellen die niedrigste ist. </font><font style="vertical-align: inherit;">Zuerst prüfen wir, ob sich die triangulierte Zelle unter ihren Nachbarn befindet oder auf dem gleichen Niveau wie die niedrigste. </font><font style="vertical-align: inherit;">Wenn ja, können wir es als unterste Zelle verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die tiefste Prüfung fehlschlägt, bedeutet dies, dass der nächste Nachbar die niedrigste Zelle ist. </font><font style="vertical-align: inherit;">Für die richtige Ausrichtung müssen wir das Dreieck gegen den Uhrzeigersinn drehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der erste Test fehlschlägt, müssen Sie zwei benachbarte Zellen vergleichen. </font><font style="vertical-align: inherit;">Wenn der Nachbar der Rippe der niedrigste ist, müssen Sie sich im Uhrzeigersinn drehen, andernfalls - gegen den Uhrzeigersinn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v4, neighbor, v5, nextNeighbor, v2, cell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8a/736/794/f8a736794c4e52c54ab018dcd55feba0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehen Sie gegen den Uhrzeigersinn, keine Drehung, Drehung im Uhrzeigersinn.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hangtriangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu wissen, wie man einen Winkel trianguliert, müssen wir verstehen, mit welchen Arten von Kanten wir es zu tun haben. </font><font style="vertical-align: inherit;">Um diese Aufgabe zu vereinfachen, fügen wir eine </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weitere bequeme Methode zum Erkennen der Steigung zwischen zwei beliebigen Zellen hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell otherCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, otherCell.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese neue Methode </font></font><code>HexMesh.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Arten der linken und rechten Kante zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beide Rippen Steigungen sind, haben wir links und rechts Leisten. </font><font style="vertical-align: inherit;">Da die untere Zelle die niedrigste ist, wissen wir außerdem, dass diese Steigungen ansteigen. </font><font style="vertical-align: inherit;">Darüber hinaus haben die linke und die rechte Zelle die gleiche Höhe, dh die Verbindung der Oberkante ist flach. </font><font style="vertical-align: inherit;">Wir können diesen Fall als "Hang-Hang-Ebene" oder MTP bezeichnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b75/4a3/f9e/b754a3f9eccdb6baada2a51fef2c4301.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Pisten und ein Flugzeug, SSP.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden prüfen, ob wir uns in dieser Situation befinden, und wenn ja, werden wir eine neue Methode aufrufen </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach kehren wir von der Methode zurück. </font><font style="vertical-align: inherit;">Fügen Sie diese Prüfung vor dem alten Triangulationscode ein, damit er das ursprüngliche Dreieck ersetzt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir drinnen nichts tun </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden einige Eckknotenpunkte mit zwei Hängen zu Hohlräumen. </font><font style="vertical-align: inherit;">Ob die Verbindung leer wird oder nicht, hängt davon ab, welche der Zellen niedriger ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/a54/2ea/26ba542eaed793e064e478cbdbc5f109.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Leere. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Lücke zu füllen, müssen wir die linke und rechte Kante durch einen Raum verbinden. </font><font style="vertical-align: inherit;">Der Ansatz hier ist der gleiche wie beim Verbinden von Kanten, jedoch innerhalb eines dreifarbigen Dreiecks anstelle eines zweifarbigen Vierecks. </font><font style="vertical-align: inherit;">Beginnen wir noch einmal mit der ersten Stufe, die jetzt ein Dreieck ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebf/a76/823/ebfa76823e5dba45fd97daa1f052b1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Stufe des Dreiecks. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir gehen wieder direkt zur letzten Etappe. </font><font style="vertical-align: inherit;">Dies ist das Viereck, das ein Trapez bildet. </font><font style="vertical-align: inherit;">Der einzige Unterschied zu den Kantenverbindungen besteht darin, dass es sich nicht um zwei, sondern um vier Farben handelt.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/ab2/20b/99eab220bcbdda36896dbb1640995b33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Stufe des Vierecks. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Stufen zwischen ihnen sind ebenfalls Vierecke.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2, c3, c4); } AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b46/8bb/c69/b468bbc6989ae33c9a810f5e641f2446.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Stufen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwei Steigungsvarianten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fall mit zwei Steigungen weist zwei Variationen mit unterschiedlichen Ausrichtungen auf, je nachdem, welche der Zellen der Boden ist. </font><font style="vertical-align: inherit;">Wir können sie finden, indem wir die Links-Rechts-Kombinationen auf Steigungsebene und Ebenenneigung überprüfen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b17/736/3ca/b177363ca9391a96905ce2a0717020d9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATP und MSS. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die rechte Kante flach ist, sollten wir links und nicht unten Leisten erstellen. </font><font style="vertical-align: inherit;">Wenn der linke Rand flach ist, müssen Sie rechts beginnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus diesem Grund werden die Leisten ohne Unterbrechung um die Zellen herumgeführt, bis sie die Klippe oder das Ende der Karte erreichen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/359/68c/4d835968ce882e260a2b4f7ec23979ab.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feste Leisten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschmelzung von Hängen und Klippen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit der Verbindung von Hang und Klippe? </font><font style="vertical-align: inherit;">Wenn wir wissen, dass der linke Rand ein Hang und der rechte Rand eine Klippe ist, was ist dann der obere Rand? </font><font style="vertical-align: inherit;">Es kann nicht flach sein, aber es kann entweder ein Hang oder eine Klippe sein.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/6bc/0d3/dd96bc0d3fb89e029687c7b9c9312cc5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/07d/d22/04907dd22fc5da80ba59fa2dbb6abb82.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/463/24c/c57/46324cc57e9c3e79a21378c932e09ed9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOS und COO. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen wir eine neue Methode hinzu, um alle Fälle von Hangklippen zu behandeln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte als letzte Option aufgerufen werden, </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der linke Rand eine Steigung ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie triangulieren wir das? </font><font style="vertical-align: inherit;">Diese Aufgabe kann in zwei Teile unterteilt werden: untere und obere.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterteil </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der untere Teil hat links Leisten und rechts eine Klippe. </font><font style="vertical-align: inherit;">Wir müssen sie irgendwie kombinieren. </font><font style="vertical-align: inherit;">Der einfachste Weg, dies zu tun, besteht darin, die Leisten so zusammenzudrücken, dass sie sich in der rechten Ecke treffen. </font><font style="vertical-align: inherit;">Dadurch werden die Leisten angehoben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/8e7/d53/d118e7d538c25cba75a31ca37c6096cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompression von Leisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich möchten wir jedoch nicht, dass sie sich in der rechten Ecke treffen, da dies die oben möglicherweise vorhandenen Leisten beeinträchtigt. </font><font style="vertical-align: inherit;">Außerdem können wir mit einer sehr hohen Klippe umgehen, wodurch wir sehr stark fallende und dünne Dreiecke bekommen. </font><font style="vertical-align: inherit;">Stattdessen werden wir sie auf einen Grenzpunkt komprimieren, der entlang einer Klippe liegt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df5/131/efa/df5131efa8069569630306b4cc8eb9b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompression an der Grenze. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Positionieren wir den Grenzpunkt eine Ebene über der unteren Zelle. </font><font style="vertical-align: inherit;">Sie können es durch Interpolation basierend auf dem Höhenunterschied finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um sicherzustellen, dass wir es richtig verstanden haben, bedecken wir den gesamten unteren Teil mit einem Dreieck. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); AddTriangle(begin, left, boundary); AddTriangleColor(beginCell.color, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03e/534/ab9/03e534ab927d5709aca721ccfd9bdc80.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unteres Dreieck. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Rand an der richtigen Stelle platziert haben, können wir mit der Triangulation der Leisten fortfahren. </font><font style="vertical-align: inherit;">Beginnen wir erst wieder von der ersten Stufe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c2/4fc/3c1/6c24fc3c19580573b89d3259b855a692.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Stufe der Komprimierung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Mal wird die letzte Stufe auch ein Dreieck sein.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/6db/5cb/0356db5cbaf4bd936ea4235af34eb1d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Stufe der Komprimierung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und alle Zwischenschritte sind auch Dreiecke.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/987/744/6e698774450ec3502f52537936d8a29e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierte Leisten.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Können wir die Kante nicht gerade halten?</font></font></b> <div class="spoiler_text"> ,     ,       ,       .         .        ,          .    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eckvervollständigung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie unten fertig sind, können Sie nach oben gehen. </font><font style="vertical-align: inherit;">Wenn die Oberkante ein Hang ist, müssen wir wieder die Leisten und die Klippe verbinden. </font><font style="vertical-align: inherit;">Verschieben wir diesen Code in eine separate Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird es einfach sein, die Spitze zu vervollständigen. </font><font style="vertical-align: inherit;">Wenn wir eine Neigung haben, fügen Sie das gedrehte Dreieck des Randes hinzu. </font><font style="vertical-align: inherit;">Ansonsten reicht ein einfaches Dreieck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/ed2/8fb/bc5ed28fbb4a1a1f0015dafac63f5ec0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59c/45b/241/59c45b2413d30e196fc195796e4b07e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Triangulation beider Teile.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gespiegelte Fälle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die Fälle von „Hangklippen“ untersucht. </font><font style="vertical-align: inherit;">Es gibt auch zwei Spiegelgehäuse, von denen jedes links eine Klippe hat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c00/726/f4f/c00726f4fc6ef078b33782047f4e6b4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS und CCA. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden den vorherigen Ansatz verwenden, mit geringfügigen Unterschieden aufgrund einer Änderung der Ausrichtung. </font><font style="vertical-align: inherit;">Wir kopieren es </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ändern es entsprechend.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, left, b); Color boundaryColor = Color.Lerp(beginCell.color, leftCell.color, b); TriangulateBoundaryTriangle( right, rightCell, begin, beginCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie diese Fälle hinzu </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/a9b/7e6/3d9a9b7e606cefd475ca14f53a48a683.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/495/6f4/3234956f44e8bcbd63d055a9a7f89c36.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trianguliertes OSS und CCA.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Doppelklippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzigen verbleibenden nichtplanaren Fälle sind die unteren Zellen mit Klippen auf beiden Seiten. </font><font style="vertical-align: inherit;">In diesem Fall kann die obere Rippe beliebig flach, geneigt oder klippenförmig sein. </font><font style="vertical-align: inherit;">Wir interessieren uns nur für den Fall „Cliff-Cliff-Slope“, da er nur Vorsprünge haben wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich gibt es zwei verschiedene Versionen des „Cliff-Cliff-Slope“, je nachdem welche Seite höher ist. </font><font style="vertical-align: inherit;">Sie sind Spiegelbilder voneinander. </font><font style="vertical-align: inherit;">Bezeichnen wir sie als OOSP und OOSL.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/038/df7/b9f038df7a7d23da542430652adbd038.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/0b2/013/3c30b2013db25c9288ad551ec529c07b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/e0d/151/7aee0d1512d324b1bd3c8e91f1b4134d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOSP und OOSL. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können beide Fälle </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch Aufrufen von Methoden </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit unterschiedlichen Zellrotationen </font><font style="vertical-align: inherit;">abdecken </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erzeugt jedoch eine seltsame Triangulation. </font><font style="vertical-align: inherit;">Dies liegt daran, dass wir jetzt von oben nach unten triangulieren. </font><font style="vertical-align: inherit;">Aus diesem Grund wird unsere Grenze als negativ interpoliert, was falsch ist. </font><font style="vertical-align: inherit;">Die Lösung besteht darin, immer positive Interpolatoren zu haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/f3d/bf8/ae8f3dbf8d5e2781cff2437d8ce4ad70.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/710/922/0aa/7109220aa668eae0d9904f48d7bd30ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trianguliertes OOSP und OOSL.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben alle Fälle untersucht, die eine besondere Behandlung erfordern, um die korrekte Triangulation der Leisten sicherzustellen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/280/86f/dc228086f73f694a351ec127e0e75e45.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplette Triangulation mit Leisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können ein bisschen aufräumen, indem </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die Operatoren loswerden </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und stattdessen Blöcke verwenden </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Block </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deckt alle verbleibenden Fälle ab, die noch nicht behandelt wurden. </font><font style="vertical-align: inherit;">Diese Fälle sind RFP (Plane-Plane-Plane), OOP, LLC und LLC. </font><font style="vertical-align: inherit;">Alle von ihnen sind von einem Dreieck bedeckt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/4da/58b/9444da58b33b9558b88fa8bb80102e34.png"></div><br> <i>  .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">unitypackage</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424257/">https://habr.com/ru/post/de424257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424245/index.html">Write Telegram Client - Einfach</a></li>
<li><a href="../de424247/index.html">KotlinConf 2018 Live - Sehen Sie sich die Sendung vom 4. bis 5. Oktober an</a></li>
<li><a href="../de424249/index.html">Materialien vom Treffen #RuPostgres - Videos, Präsentationen, Analyse des Quiz und Fotobericht</a></li>
<li><a href="../de424251/index.html">Wir betrachten Statistiken über Experimente auf hh.ru.</a></li>
<li><a href="../de424255/index.html">So verwenden Sie die statische Analyse richtig</a></li>
<li><a href="../de424259/index.html">Sicherheitswoche 36: Telnet sollte geschlossen sein</a></li>
<li><a href="../de424261/index.html">So lösen Sie Programmierprobleme</a></li>
<li><a href="../de424263/index.html">IDA Pro aktualisieren. Wir beheben Pfosten von Prozessormodulen</a></li>
<li><a href="../de424265/index.html">Bewertung des Elektrofahrrads Twitter Mantis E-1</a></li>
<li><a href="../de424267/index.html">Wie debuggen wir ein selbst geschriebenes ECS in einem Browser auf einem Spieleserver?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>