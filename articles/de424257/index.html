<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûø üíÆ ‚ú® Sechseckkarten in Einheit: Teile 1-3 ‚è™ üåö üßôüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem √úbersetzer: Dieser Artikel ist der erste einer detaillierten (27 Teile) Reihe von Tutorials zum Erstellen von Karten aus Sechsecken. Dies so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sechseckkarten in Einheit: Teile 1-3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424257/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg" alt="Bild"></div><br>  <i>Von einem √úbersetzer: Dieser Artikel ist der erste einer detaillierten (27 Teile) Reihe von Tutorials zum Erstellen von Karten aus Sechsecken.</i>  <i>Dies sollte ganz am Ende der Tutorials geschehen.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 1-3: Netz, Farben und Zellenh√∂hen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 4-7: Unebenheiten, Fl√ºsse und Stra√üen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 8-11: Wasser, Landformen und W√§lle</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 12-15: Speichern und Laden, Texturen, Entfernungen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 16-19: Weg finden, Spielerkader, Animationen</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 20-23: Nebel des Krieges, Kartenforschung, Verfahrensgenerierung</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teile 24-27: Wasserkreislauf, Erosion, Biomes, zylindrische Karte</a> <br><br><h1>  Teil 1: Eingriff aus Sechsecken </h1><br><h2>  Inhaltsverzeichnis </h2><br><ul><li>  Wandle Quadrate in Sechsecke um. </li><li>  Triangulieren Sie ein Sechseckgitter. </li><li>  Wir arbeiten mit kubischen Koordinaten. </li><li>  Wir interagieren mit Gitterzellen. </li><li>  Erstelle einen In-Game-Editor. </li></ul><br>  Dieses Tutorial ist der Beginn einer Reihe √ºber Sechseckkarten.  Hexagon-Netze werden in vielen Spielen verwendet, insbesondere in Strategien, einschlie√ülich Age of Wonders 3, Civilization 5 und Endless Legend.  Wir werden mit den Grundlagen beginnen, nach und nach neue Funktionen hinzuf√ºgen und als Ergebnis ein komplexes Relief auf der Basis von Sechsecken erstellen. <br><a name="habracut"></a><br>  In diesem Tutorial wird davon ausgegangen, dass Sie bereits die <i>Mesh Basics-</i> Reihe studiert haben, die mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">prozeduralen Raster</a> beginnt.  Es wurde unter Unity 5.3.1 erstellt.  Die Serie verwendet mehrere Versionen von Unity.  Der letzte Teil wurde in Unity 2017.3.0p3 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54e/065/633/54e065633ba41c99214f720278b68336.png"></div><br>  <i>Eine einfache Karte von Sechsecken.</i> <br><br><h2>  √úber Sechsecke </h2><br>  Warum werden Sechsecke ben√∂tigt?  Wenn wir ein Raster ben√∂tigen, ist es logisch, Quadrate zu verwenden.  Quadrate sind sehr einfach zu zeichnen und zu positionieren, haben aber auch einen Nachteil.  Schauen Sie sich ein einzelnes Quadrat des Gitters und dann seine Nachbarn an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/d4f/9b8/48fd4f9b87d5aa2381d9b03dbae704ae.png"></div><br>  <i>Der Platz und seine Nachbarn.</i> <br><br>  Insgesamt hat der Platz acht Nachbarn.  Vier davon k√∂nnen durch √úberqueren des Randes des Quadrats erreicht werden.  Dies sind horizontale und vertikale Nachbarn.  Die anderen vier k√∂nnen durch √úberqueren der Ecke des Platzes erreicht werden.  Dies sind diagonale Nachbarn. <br><br>  Wie gro√ü ist der Abstand zwischen den Zentren benachbarter quadratischer Gitterzellen?  Wenn die Kantenl√§nge 1 ist, ist die Antwort f√ºr horizontale und vertikale Nachbarn 1. F√ºr diagonale Nachbarn ist die Antwort jedoch ‚àö2. <br><br>  Der Unterschied zwischen den beiden Arten von Nachbarn f√ºhrt zu Schwierigkeiten.  Wenn wir diskrete Bewegungen verwenden, wie kann man dann die Bewegung entlang der Diagonale wahrnehmen?  Soll ich es √ºberhaupt zulassen?  Wie kann das Erscheinungsbild organischer gestaltet werden?  Unterschiedliche Spiele verwenden unterschiedliche Ans√§tze mit ihren Vor- und Nachteilen.  Ein Ansatz besteht darin, √ºberhaupt kein quadratisches Gitter zu verwenden, sondern stattdessen Sechsecke zu verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/47a/9a1/77247a9a1784bdbe1b736672460b95bf.png"></div><br>  <i>Sechseck und seine Nachbarn.</i> <br><br>  Im Gegensatz zu einem Quadrat hat ein Sechseck nicht acht, sondern sechs Nachbarn.  Alle diese Nachbarn grenzen an die R√§nder, es gibt keine Ecknachbarn.  Das hei√üt, es gibt nur eine Art von Nachbarn, was viel vereinfacht.  Nat√ºrlich ist ein Sechseckgitter schwerer zu bauen als ein Quadrat, aber wir k√∂nnen damit umgehen. <br><br>  Bevor wir beginnen, m√ºssen wir die Gr√∂√üe der Sechsecke bestimmen.  Die Kantenl√§nge sei gleich 10 Einheiten.  Da das Sechseck aus einem Kreis von sechs gleichseitigen Dreiecken besteht, betr√§gt der Abstand vom Zentrum zu einem beliebigen Winkel ebenfalls 10. Dieser Wert bestimmt den Au√üenradius der sechseckigen Zelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdb/a2f/82f/cdba2f82fb30358f0d2ca31c95f133d5.png"></div><br>  <i>Der √§u√üere und innere Radius des Sechsecks.</i> <br><br>  Es gibt auch einen Innenradius, der der Abstand von der Mitte zu jeder der Kanten ist.  Dieser Parameter ist wichtig, da der Abstand zwischen den Mittelpunkten der Nachbarn gleich diesem Wert mal zwei ist.  Der Innenradius ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;">s </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;">q </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;">r </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;">t </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;">3</font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"> 2</font></span></span></font><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mtext" id="MJXp-Span-8">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;"></font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.098ex" height="2.419ex" viewBox="0 -780.1 5209 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="1631" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="1993" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="4708" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> \ frac {\ sqrt {3}} {2} </script>  vom √§u√üeren Radius, das hei√üt in unserem Fall <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mn" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;">q </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;">3</font></span></span></font><span class="MJXp-mtext" id="MJXp-Span-19">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.954ex" height="2.298ex" viewBox="0 -728.2 2994 989.6" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-35" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="1220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="1680" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="2132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="2493" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 5 \ sqrt {3} </script>  .  Lassen Sie uns diese Parameter der Einfachheit halber in eine statische Klasse einordnen. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMetrics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wie leitet man den Wert des Innenradius ab?</b> <div class="spoiler_text">  Nimm eines der sechs Dreiecke eines Sechsecks.  Der Innenradius entspricht der H√∂he dieses Dreiecks.  Diese H√∂he kann erhalten werden, indem das Dreieck in zwei regul√§re Dreiecke geteilt und dann der Satz von Pythagoras verwendet wird. <br><br>  Daher f√ºr die L√§nge der Rippe <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.083ex" height="1.523ex" viewBox="0 -535.3 466.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> e </script>  Innenradius ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mtext" id="MJXp-Span-29">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">t</span><span class="MJXp-mrow" id="MJXp-Span-34"><span class="MJXp-msubsup" id="MJXp-Span-35"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-37" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">e</span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-43">2</span><span class="MJXp-msubsup" id="MJXp-Span-44"><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-46" style="vertical-align: 0.5em;">2</span></span></span><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-48">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">t</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mn" id="MJXp-Span-54">3</span><span class="MJXp-msubsup" id="MJXp-Span-55"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-57" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-58"><span class="MJXp-mo" id="MJXp-Span-59" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-60">4</span></span><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">e</span><span class="MJXp-mtext" id="MJXp-Span-63">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">t</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-mn" id="MJXp-Span-69">3</span></span><span class="MJXp-mrow" id="MJXp-Span-70"><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-72">2</span><span class="MJXp-mtext" id="MJXp-Span-73">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">a</span><span class="MJXp-mo" id="MJXp-Span-76" style="margin-left: 0em; margin-right: 0.222em;">.</span><span class="MJXp-mn" id="MJXp-Span-77">0</span><span class="MJXp-mo" id="MJXp-Span-78" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-79">886</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="52.148ex" height="3.037ex" viewBox="0 -950 22452.6 1307.5" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="1631" y="0"></use><g transform="translate(1993,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="659" y="513"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2212" x="1142" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-28" x="2143" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="2532" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2F" x="2999" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="3499" y="0"></use><g transform="translate(4000,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="550" y="513"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-3D" x="7114" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="8420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="8890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="9350" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="9802" y="0"></use><g transform="translate(10163,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="659" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2F" x="1420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-34" x="1921" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-3D" x="12863" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="13919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-73" x="14636" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-71" x="15105" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-72" x="15566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="16017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-33" x="16379" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2F" x="16879" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-32" x="17380" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-63" x="18130" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="18564" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2E" x="19093" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-30" x="19538" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-2C" x="20039" y="0"></use><g transform="translate(20484,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-38"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-38" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMAIN-36" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-65" x="21986" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> \ sqrt {e ^ 2 - (e / 2) ^ 2} = \ sqrt {3e ^ 2/4} = e \ sqrt {3} / 2 \ ca. 0,886e </script>  . </div></div><br>  Wenn wir dies bereits tun, bestimmen wir die Positionen der sechs Ecken relativ zur Mitte der Zelle.  Es ist zu beachten, dass es zwei M√∂glichkeiten gibt, das Sechseck auszurichten: mit einer scharfen oder flachen Seite nach oben.  Wir werden die Ecke aufstellen.  Beginnen wir in diesem Winkel und f√ºgen den Rest im Uhrzeigersinn hinzu.  Legen Sie sie so auf die XZ-Ebene, dass die Sechsecke auf dem Boden liegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b2/0eb/95a/5b20eb95ac844ed93a117b7d37f90e11.png"></div><br>  <i>M√∂gliche Orientierungen.</i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius) };</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einheitspaket</a> <br><br><h2>  Vernetzung </h2><br>  Um ein Sechseckgitter zu erstellen, ben√∂tigen wir Gitterzellen.  Erstellen Sie zu diesem Zweck die <code>HexCell</code> Komponente.  Lassen Sie es vorerst leer, da wir noch keine bestimmten Zellen verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br>  Erstellen Sie zun√§chst ein Standardebenenobjekt, f√ºgen Sie eine Zellenkomponente hinzu und verwandeln Sie alles in ein Fertighaus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/f1f/3ab/b61f1f3ab3210349434c2aff8c9ac374.png"></div><br>  <i>Verwendung einer Ebene als Fertighaus einer sechseckigen Zelle.</i> <br><br>  Nun gehen wir ins Netz.  Erstellen wir eine einfache Komponente mit allgemeinen Variablen f√ºr Zellenbreite, -h√∂he und -fertigung.  F√ºgen Sie dann der Szene ein Spielobjekt mit dieser Komponente hinzu. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell cellPrefab; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/749/12e/cad74912e6a951918b4a3d0f4b9bb6bb.png"></div><br>  <i>Sechseck-Netzobjekt.</i> <br><br>  Beginnen wir mit der Erstellung eines regelm√§√üigen Quadrats von Quadraten, da wir bereits wissen, wie das geht.  Speichern wir die Zellen in einem Array, um darauf zugreifen zu k√∂nnen. <br><br>  Da die Ebenen standardm√§√üig eine Gr√∂√üe von 10 x 10 Einheiten haben, verschieben wir jede Zelle um diesen Betrag. <br><br><pre> <code class="cs hljs"> HexCell[] cells; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[height * width]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; height; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { CreateCell(x, z, i++); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = x * <span class="hljs-number"><span class="hljs-number">10f</span></span>; position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * <span class="hljs-number"><span class="hljs-number">10f</span></span>; HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/560/321/d11560321e63ac581846776aa5b658b6.png"></div><br>  <i>Quadratisches Gitter von Flugzeugen.</i> <br><br>  So haben wir ein sch√∂nes festes Gitter aus quadratischen Zellen.  Aber welche Zelle ist wo?  Dies ist nat√ºrlich leicht zu √ºberpr√ºfen, aber es gibt Schwierigkeiten mit Sechsecken.  Es w√§re praktisch, wenn wir gleichzeitig die Koordinaten aller Zellen sehen k√∂nnten. <br><br><h3>  Koordinatenanzeige </h3><br>  F√ºgen Sie der Szene Leinwand hinzu, indem Sie <i>GameObject / UI / Canvas</i> ausw√§hlen und sie zu einem <i>untergeordneten Element</i> unseres <i>Netzobjekts</i> machen.  Da diese Zeichenfl√§che nur zur Information dient, entfernen wir ihre Raycaster-Komponente.  Sie k√∂nnen auch das Ereignissystemobjekt l√∂schen, das automatisch zur Szene hinzugef√ºgt wurde, da wir es derzeit nicht ben√∂tigen. <br><br>  Stellen Sie den <i>Render-Modus</i> auf " <i>Weltraum"</i> und drehen Sie ihn um 90 Grad entlang der X-Achse, sodass die Leinwand √ºber dem Raster liegt.  Drehpunkt und Position auf Null setzen.  Geben Sie ihm einen leichten vertikalen Versatz, damit der Inhalt oben ist.  Breite und H√∂he sind uns nicht wichtig, da wir den Inhalt selbst arrangieren.  Wir k√∂nnen den Wert auf 0 setzen, um das gro√üe Rechteck im Szenenfenster zu entfernen. <br><br>  Als letzten Schliff erh√∂hen Sie die <i>dynamischen Pixel pro Einheit</i> auf 10. Wir garantieren daher, dass Textobjekte eine ausreichende Texturaufl√∂sung verwenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/d5e/34e/d37d5e34e417e5d703d2915ef2e6ad19.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/c37/273/374c37273c1e8e61befc30543efca5b2.png"></div><br>  <i>Leinwand f√ºr Gitterkoordinaten von Sechsecken.</i> <br><br>  Um die Koordinaten anzuzeigen, erstellen Sie ein <i>Textobjekt</i> ( <i>GameObject / UI / Text</i> ) und verwandeln Sie es in ein Fertighaus.  Zentrieren Sie die Anker und drehen Sie sie, und stellen Sie die Gr√∂√üe auf 5 x 15 ein. Der Text sollte auch horizontal und vertikal in der Mitte ausgerichtet sein.  Stellen Sie die Schriftgr√∂√üe auf 4 ein. Schlie√ülich m√∂chten wir den Standardtext nicht verwenden und verwenden keinen <i>Rich-Text</i> .  Au√üerdem spielt es f√ºr uns keine Rolle, ob das <i>Raycast-Ziel aktiviert</i> ist, da es f√ºr unsere Leinwand immer noch nicht ben√∂tigt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/c09/d55/f15c09d55444941d69d563940806340f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6d/0df/ab2/d6d0dfab20e21276e48a2ca5bdc36503.png"></div><br>  <i>Fertighausetikett.</i> <br><br>  Jetzt m√ºssen wir dem Raster etwas √ºber Leinwand und Fertighaus erz√§hlen.  F√ºgen Sie am Anfang ihres Skripts <code>using UnityEngine.UI;</code>  um bequem auf den Typ <code>UnityEngine.UI.Text</code> .  Ein vorgefertigtes Etikett ben√∂tigt eine gemeinsam genutzte Variable, und Canvas kann durch Aufrufen von <code>GetComponentInChildren</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text cellLabelPrefab; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fae/b30/599/faeb3059923e68e4b072a5b401086072.png"></div><br>  <i>Verbindungsfertige Tags.</i> <br><br>  Nachdem Sie das Fertighaus des Etiketts verbunden haben, k√∂nnen Sie seine Instanzen erstellen und die Koordinaten der Zelle anzeigen.  F√ºgen Sie zwischen X und Z ein Zeilenumbruchzeichen ein, sodass sie in separaten Zeilen angezeigt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = x.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e8/1e2/9b0/0e81e29b0fd80afb2f7056a5b8ed829d.png"></div><br>  <i>Koordinatenanzeige.</i> <br><br><h3>  Sechseckpositionen </h3><br>  Jetzt, da wir jede Zelle visuell erkennen k√∂nnen, k√∂nnen wir sie verschieben.  Wir wissen, dass der Abstand zwischen benachbarten hexagonalen Zellen in X-Richtung dem doppelten Innenradius entspricht.  Wir werden es benutzen.  Au√üerdem sollte der Abstand zur n√§chsten Zellenreihe 1,5-mal gr√∂√üer sein als der √§u√üere Radius. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/269/f40/6e4269f40ead27d2ddb0dd75a1154d99.png"></div><br>  <i>Geometrie benachbarter Sechsecke.</i> <br><br><pre> <code class="cs hljs"> position.x = x * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ca/d03/034/5cad03034d4aacacf5ccd49dccf0af3a.png"></div><br>  <i>Wir wenden Abst√§nde zwischen Sechsecken ohne Offsets an.</i> <br><br>  Nat√ºrlich liegen die Ordnungsreihen der Sechsecke nicht genau √ºbereinander.  Jede Zeile ist entlang der X-Achse um den Wert des Innenradius versetzt.  Dieser Wert kann erhalten werden, indem die H√§lfte von Z zu X addiert und dann mit dem doppelten Innenradius multipliziert wird. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/e06/f65/75ce06f65db02737bddf223d45f6b8f3.png"></div><br>  <i>Durch die richtige Platzierung der Sechsecke entsteht ein rautenf√∂rmiges Gitter.</i> <br><br>  Obwohl wir auf diese Weise die Zellen an den richtigen Positionen der Sechsecke platziert haben, f√ºllt unser Gitter jetzt eher die Raute als das Rechteck.  Wir arbeiten viel einfacher mit rechteckigen Gittern. Lassen Sie uns also die Zellen wieder in Betrieb nehmen.  Dies kann durch Zur√ºckschieben eines Teils des Versatzes erfolgen.  In jeder zweiten Zeile m√ºssen alle Zellen um einen weiteren Schritt zur√ºckgeschoben werden.  Dazu m√ºssen wir das Ergebnis der ganzzahligen Division von Z durch 2 subtrahieren, bevor wir multiplizieren. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/429/30a/51942930aa48daab518847429e4c8b74.png"></div><br>  <i>Die Position der Sechsecke in einem rechteckigen Bereich.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Hexagon-Rendering </h2><br>  Nachdem die Zellen korrekt platziert wurden, k√∂nnen wir die realen Sechsecke anzeigen.  Zuerst m√ºssen wir die Ebenen entfernen, damit wir alle Komponenten au√üer <code>HexCell</code> aus dem Zellen- <code>HexCell</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/32a/214/48f32a214e6ef61f580a0147a5f310da.png"></div><br>  <i>Es gibt keine Flugzeuge mehr.</i> <br><br>  Wie in den Tutorials zu den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzgrundlagen verwenden</a> wir ein Netz, um das gesamte Netz zu rendern.  Dieses Mal werden wir jedoch die Anzahl der erforderlichen Eckpunkte und Dreiecke nicht voreingestellt.  Stattdessen werden wir Listen verwenden. <br><br>  Erstellen Sie eine neue <code>HexMesh</code> Komponente, <code>HexMesh</code> um unser Netz k√ºmmert.  Es erfordert einen Netzfilter und einen Renderer, ein Netz und Listen f√ºr Scheitelpunkte und Dreiecke. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMesh</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Mesh hexMesh; List&lt;Vector3&gt; vertices; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } }</code> </pre> <br>  Erstellen Sie mit dieser Komponente ein neues untergeordnetes Objekt f√ºr dieses Netz.  Er erh√§lt automatisch einen Mesh-Renderer, ihm wird jedoch kein Material zugewiesen.  F√ºgen Sie daher das Standardmaterial hinzu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/831/2ab/f2a8312ab61274a7563aeeb7860c3609.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/bf1/710/8abbf17103e93485e696daf3a94bb277.png"></div><br>  <i>Hex-Mesh-Objekt.</i> <br><br>  <code>HexGrid</code> kann nun sein Sechsecknetz auf dieselbe Weise abrufen, wie er die Leinwand gefunden hat. <br><br><pre> <code class="cs hljs"> HexMesh hexMesh; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ }</code> </pre> <br>  Nach dem Wachnetz sollte es dem Netz befehlen, seine Zellen zu triangulieren.  Wir m√ºssen sicher sein, dass dies nach der Awake-Komponente des Hex-Netzes geschieht.  Da <code>Start</code> sp√§ter aufgerufen wird, geben Sie dort den entsprechenden Code ein. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br>  Diese <code>HexMesh.Triangulate</code> Methode kann jederzeit aufgerufen werden, auch wenn die Zellen bereits zuvor trianguliert wurden.  Daher sollten wir zun√§chst alte Daten bereinigen.  Wenn wir alle Zellen durchlaufen, triangulieren wir sie einzeln.  Nach Abschluss dieses Vorgangs weisen wir dem Netz die generierten Scheitelpunkte und Dreiecke zu und berechnen abschlie√üend die Netznormalen neu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); triangles.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } hexMesh.vertices = vertices.ToArray(); hexMesh.triangles = triangles.ToArray(); hexMesh.RecalculateNormals(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Da die Sechsecke aus Dreiecken bestehen, erstellen wir eine bequeme Methode zum Hinzuf√ºgen eines Dreiecks basierend auf den Positionen von drei Eckpunkten.  Es werden nur die Eckpunkte der Reihe nach hinzugef√ºgt.  Er addiert auch die Indizes dieser Eckpunkte, um ein Dreieck zu bilden.  Der Index des ersten Scheitelpunkts entspricht der L√§nge der Liste der Scheitelpunkte, bevor neue Scheitelpunkte hinzugef√ºgt werden.  Vergessen Sie dies nicht, wenn Sie Scheitelpunkte hinzuf√ºgen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Jetzt k√∂nnen wir unsere Zellen triangulieren.  Beginnen wir mit dem ersten Dreieck.  Sein erster Gipfel befindet sich in der Mitte des Sechsecks.  Die beiden anderen Eckpunkte sind der erste und der zweite Winkel relativ zur Mitte. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">0</span></span>], center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/d2b/ca3/860d2bca3ec0d1c95bd66082735021f7.png"></div><br>  <i>Das erste Dreieck jeder Zelle.</i> <br><br>  Das hat funktioniert, also lasst uns alle sechs Dreiecke umrunden. <br><br><pre> <code class="cs hljs"> Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">K√∂nnen Spitzen geteilt werden?</b> <div class="spoiler_text">  Ja, das kannst du.  Tats√§chlich k√∂nnen wir es sogar noch besser machen und nur vier statt sechs Dreiecke zum Rendern verwenden.  Wenn wir dies jedoch aufgeben, werden wir unsere Arbeit vereinfachen, und es wird richtig sein, da in den folgenden Tutorials alles komplizierter wird.  Die Optimierung von Eckpunkten und Dreiecken in dieser Phase wird uns in Zukunft behindern. </div></div><br>  Leider f√ºhrt dieser Prozess zu einer <code>IndexOutOfRangeException</code> .  Dies liegt daran, dass das letzte Dreieck versucht, die siebte Ecke zu erhalten, die nicht existiert.  Nat√ºrlich sollte er zur√ºckgehen und als letzten Scheitelpunkt der ersten Ecke verwenden.  Oder wir k√∂nnen die erste Ecke in <code>HexMetrics.corners</code> , um nicht √ºber die Grenzen hinauszugehen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8d/277/e13/c8d277e139df24953e9b381fabca2a42.png"></div><br>  <i>Sechsecke vollst√§ndig.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Sechseckige Koordinaten </h2><br>  Schauen wir uns noch einmal die Koordinaten der Zellen an, jetzt im Kontext eines Sechseckgitters.  Die Z-Koordinate sieht gut aus und die X-Koordinate im Zickzack.  Dies ist ein Nebeneffekt des Linienversatzes, um einen rechteckigen Bereich abzudecken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/745/502/73f745502f1d8d20245bd22edc99a3ce.png"></div><br>  <i>Versetzte Koordinaten mit hervorgehobenen Nulllinien.</i> <br><br>  Bei der Arbeit mit Sechsecken sind solche Versatzkoordinaten nicht einfach zu handhaben.  <code>HexCoordinates</code> wir eine Struktur <code>HexCoordinates</code> , die zum Konvertieren in ein anderes Koordinatensystem verwendet werden kann.  Machen wir es serialisierbar, damit Unity es speichern kann und es im Wiedergabemodus neu kompiliert wird.  Wir machen diese Koordinaten auch unver√§nderlich, indem wir die √∂ffentlichen schreibgesch√ºtzten Eigenschaften verwenden. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { X = x; Z = z; } }</code> </pre> <br>  F√ºgen Sie eine statische Methode hinzu, um einen Satz von Koordinaten aus normalen Versatzkoordinaten zu erstellen.  Im Moment werden wir diese Koordinaten einfach kopieren. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z); } }</code> </pre> <br>  Wir f√ºgen auch praktische Methoden zur Konvertierung von Zeichenfolgen hinzu.  Die <code>ToString</code> Methode gibt standardm√§√üig einen Strukturtypnamen zur√ºck, was f√ºr uns nicht sehr n√ºtzlich ist.  Wir definieren es neu, damit es die Koordinaten in einer Zeile zur√ºckgibt.  Wir werden auch eine Methode zum Anzeigen von Koordinaten in separaten Zeilen hinzuf√ºgen, da wir bereits ein solches Schema verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br>  Jetzt k√∂nnen wir viele Koordinaten an unsere <code>HexCell</code> Komponente √ºbergeben. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; }</code> </pre> <br>  √Ñndern Sie <code>HexGrid.CreateCell</code> so, dass die neuen Koordinaten verwendet werden k√∂nnen. <br><br><pre> <code class="cs hljs"> HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines();</code> </pre> <br>  Wiederholen wir nun diese X-Koordinaten so, dass sie entlang einer geraden Achse ausgerichtet sind.  Dies kann durch Aufheben der horizontalen Verschiebung erfolgen.  Das resultierende Ergebnis wird √ºblicherweise als Axialkoordinaten bezeichnet. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x - z / <span class="hljs-number"><span class="hljs-number">2</span></span>, z); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/1bf/29d/4331bf29dbf016e466a3636b5cd90311.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ab/03d/7af/4ab03d7afdef480fe4657ae86901fd1a.png"></div><br>  <i>Axialkoordinaten.</i> <br><br>  Dieses zweidimensionale Koordinatensystem erm√∂glicht es uns, die Bewegung der Verschiebung in vier Richtungen nacheinander zu beschreiben.  Zwei verbleibende Richtungen erfordern jedoch noch besondere Aufmerksamkeit.  Dies macht uns klar, dass es eine dritte Dimension gibt.  Und tats√§chlich w√ºrden wir, wenn wir die Dimension von X horizontal spiegeln w√ºrden, die fehlende Dimension von Y erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32c/39b/9b7/32c39b9b7705099d7bcb8e525aa6fe48.png"></div><br>  <i>Die Y-Messung wird angezeigt.</i> <br><br>  Da diese Messungen von X und Y Spiegelkopien voneinander sind, ergibt die Addition ihrer Koordinaten immer das gleiche Ergebnis, wenn Z konstant bleibt.  Wenn Sie alle drei Koordinaten addieren, erhalten wir immer Null.  Wenn Sie eine Koordinate erh√∂hen, m√ºssen Sie die andere reduzieren.  Tats√§chlich gibt uns dies sechs m√∂gliche Bewegungsrichtungen.  Solche Koordinaten werden normalerweise als kubisch bezeichnet, da sie dreidimensional sind und die Topologie einem W√ºrfel √§hnelt. <br><br>  Da die Summe aller Koordinaten Null ist, k√∂nnen wir immer eine der Koordinaten von den anderen beiden erhalten.  Da wir bereits die X- und Z-Koordinaten speichern, m√ºssen wir die Y-Koordinate nicht speichern. <br>  Wir k√∂nnen eine Eigenschaft hinzuf√ºgen, die sie bei Bedarf auswertet, und sie in Zeichenfolgenmethoden verwenden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -X - Z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c36/ad9/d32/c36ad9d322193e811fd6c59b5d76249a.png"></div><br>  <i>Kubische Koordinaten.</i> <br><br><h3>  Inspektorkoordinaten </h3><br>  W√§hlen Sie im Wiedergabemodus eine der Gitterzellen aus.  Es stellt sich heraus, dass der Inspektor seine Koordinaten nicht anzeigt, <code>HexCell.coordinates</code> nur die <code>HexCell.coordinates</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/a1d/a0e/d02a1da0e906223abcb9aeeb46ce7477.png"></div><br>  <i>Der Inspektor zeigt die Koordinaten nicht an.</i> <br><br>  Obwohl dies kein gro√ües Problem ist, w√§re es gro√üartig, die Koordinaten anzuzeigen.  Unity zeigt keine Koordinaten an, da diese nicht als serialisierbare Felder markiert sind.  Um sie anzuzeigen, m√ºssen Sie explizit serialisierbare Felder f√ºr X und Z angeben. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, z; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ea/264/fff/5ea264fffa724e10205c41c8191ad78b.png"></div><br>  X- und Z-Koordinaten werden jetzt angezeigt, k√∂nnen jedoch ge√§ndert werden.  Wir brauchen das nicht, weil die Koordinaten festgelegt werden m√ºssen.  Es ist auch nicht sehr gut, dass sie untereinander angezeigt werden. <br><br>  Wir k√∂nnen es besser machen: Definieren Sie unsere eigene Eigenschaftsschublade f√ºr den <code>HexCoordinates</code> Typ.  Erstellen Sie ein <code>HexCoordinatesDrawer</code> Skript und f√ºgen Sie es in den <i>Editor-</i> Ordner ein, da dieses Skript nur f√ºr den Editor bestimmt ist. <br><br>  Die Klasse muss <code>UnityEditor.PropertyDrawer</code> und ben√∂tigt das Attribut <code>UnityEditor.CustomPropertyDrawer</code> , um es einem geeigneten Typ zuzuordnen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(HexCoordinates))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCoordinatesDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { }</code> </pre> <br>  Eigenschaftsschubladen zeigen ihren Inhalt mit der <code>OnGUI</code> Methode an.  Mit dieser Methode konnten serialisierbare Eigenschaftsdaten und die Bezeichnung des Felds, zu dem sie geh√∂ren, innerhalb des Bildschirmrechtecks ‚Äã‚Äãgezeichnet werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Wir extrahieren die Werte von x und z aus der Eigenschaft und verwenden sie dann, um einen neuen Satz von Koordinaten zu erstellen.  Zeichnen Sie dann das GUI-Label an der ausgew√§hlten Position mit unserer <code>HexCoordinates.ToString</code> Methode. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates( property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"x"</span></span>).intValue, property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"z"</span></span>).intValue ); GUI.Label(position, coordinates.ToString()); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d6/d0f/852/1d6d0f852f744b6b5080a54478a3f4bf.png"></div><br>  <i>Koordinaten ohne Pr√§fixbezeichnung.</i> <br><br>  Dadurch werden die Koordinaten angezeigt, aber jetzt fehlt der Feldname.  Diese Namen werden normalerweise mit der <code>EditorGUI.PrefixLabel</code> Methode gerendert.  Als Bonus wird ein ausgerichtetes Rechteck zur√ºckgegeben, das dem Leerzeichen rechts neben dieser Beschriftung entspricht. <br><br><pre> <code class="cs hljs"> position = EditorGUI.PrefixLabel(position, label); GUI.Label(position, coordinates.ToString());</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6c/d34/856/a6cd348569c891e063c6fc515d075d04.png"></div><br>  <i>Koordinaten mit einem Etikett.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Einheitspaket</a> <br><br><h2>  Zellen ber√ºhren </h2><br>  Ein Sechseckgitter ist nicht sehr interessant, wenn wir nicht damit interagieren k√∂nnen.  Die einfachste Interaktion besteht darin, die Zelle zu ber√ºhren. F√ºgen wir also Unterst√ºtzung hinzu.  Im <code>HexGrid</code> f√ºgen wir diesen Code einfach direkt in <code>HexGrid</code> .  Wenn es anf√§ngt zu funktionieren, werden wir es an einen anderen Ort verschieben. <br><br>  Um eine Zelle zu ber√ºhren, k√∂nnen Sie von der Position des Mauszeigers aus Strahlen in die Szene senden.  Wir k√∂nnen den gleichen Ansatz wie im Tutorial zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzdeformation verwenden</a> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { TouchCell(hit.point); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + position); }</code> </pre> <br>  Bisher macht der Code nichts.  Wir m√ºssen dem Gitter einen Kollider hinzuf√ºgen, damit der Strahl mit etwas kollidieren kann.  Daher geben wir das <code>HexMesh</code> Collider-Netz an. <br><br><pre> <code class="cs hljs"> MeshCollider meshCollider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); ‚Ä¶ }</code> </pre> <br>  Weisen Sie dem Collider nach Abschluss der Triangulation ein Netz zu. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">K√∂nnen wir nicht einfach Box Collider verwenden?</b> <div class="spoiler_text">  Wir k√∂nnen, aber es wird nicht genau mit dem Umriss unseres Gitters √ºbereinstimmen.  Ja, und unser Raster wird nicht lange flach bleiben, aber dies ist ein Thema f√ºr zuk√ºnftige Tutorials. </div></div><br>  Jetzt k√∂nnen wir das Gitter ber√ºhren!  Aber welche Zelle ber√ºhren wir?  Um dies herauszufinden, m√ºssen wir die Ber√ºhrungsposition in die Koordinaten der Sechsecke umwandeln.  Dies ist eine Arbeit f√ºr <code>HexCoordinates</code> , daher erkl√§ren wir, dass es eine statische <code>FromPosition</code> Methode gibt. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + coordinates.ToString()); }</code> </pre> <br>  Wie bestimmt diese Methode, welche Koordinate zur Position geh√∂rt?  Wir k√∂nnen beginnen, indem wir x durch die horizontale Breite des Sechsecks teilen.  Und da die Y-Koordinate ein Spiegelbild der X-Koordinate ist, ergibt ein negatives x y. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -x; }</code> </pre> <br>  Dies w√ºrde uns nat√ºrlich die richtigen Koordinaten geben, wenn Z Null w√§re.  Wir m√ºssen uns erneut verschieben, wenn wir uns entlang Z bewegen. Alle zwei Zeilen m√ºssen wir um eine Einheit nach links verschieben. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = position.z / (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">3f</span></span>); x -= offset; y -= offset;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen erweisen sich unsere x- und y-Werte als Ganzzahlen in der Mitte jeder Zelle. </font><font style="vertical-align: inherit;">Wenn wir sie daher auf die n√§chste ganze Zahl runden, m√ºssen wir die Koordinaten erhalten. </font><font style="vertical-align: inherit;">Wir berechnen auch Z und erhalten so die endg√ºltigen Koordinaten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iX = Mathf.RoundToInt(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iY = Mathf.RoundToInt(y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iZ = Mathf.RoundToInt(-x -y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ergebnisse sehen vielversprechend aus, aber sind diese Koordinaten korrekt? </font><font style="vertical-align: inherit;">Bei sorgf√§ltiger Untersuchung k√∂nnen Sie feststellen, dass wir manchmal die Koordinaten erhalten, deren Summe ungleich Null ist! </font><font style="vertical-align: inherit;">Aktivieren Sie die Benachrichtigung, um sicherzustellen, dass dies wirklich geschieht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"rounding error!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten tats√§chlich Benachrichtigungen. </font><font style="vertical-align: inherit;">Wie beheben wir diesen Fehler? </font><font style="vertical-align: inherit;">Es entsteht nur neben den Kanten zwischen den Sechsecken. </font><font style="vertical-align: inherit;">Das hei√üt, das Runden von Koordinaten verursacht Probleme. </font><font style="vertical-align: inherit;">Welche Koordinate ist in die falsche Richtung gerundet? </font><font style="vertical-align: inherit;">Je weiter wir uns von der Mitte der Zelle entfernen, desto runder werden wir. </font><font style="vertical-align: inherit;">Daher ist es logisch anzunehmen, dass die am meisten gerundete Koordinate falsch ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann besteht die L√∂sung darin, die Koordinate mit dem gr√∂√üten Rundungsdelta zu l√∂schen und sie aus den Werten der beiden anderen neu zu erstellen. </font><font style="vertical-align: inherit;">Da wir jedoch nur X und Z ben√∂tigen, k√∂nnen wir Y nicht neu erstellen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dX = Mathf.Abs(x - iX); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dY = Mathf.Abs(y - iY); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dZ = Mathf.Abs(-x -y - iZ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt; dY &amp;&amp; dX &gt; dZ) { iX = -iY - iZ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dZ &gt; dY) { iZ = -iX - iY; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sechsecke Malvorlagen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt, da wir die richtige Zelle ber√ºhren k√∂nnen, ist die Zeit f√ºr echte Interaktion gekommen. </font><font style="vertical-align: inherit;">Lassen Sie uns die Farbe jeder Zelle √§ndern, in die wir gelangen. </font><font style="vertical-align: inherit;">F√ºgen Sie f√ºr die </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">benutzerdefinierten Farben der Standardzelle und der betroffenen Zelle hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color defaultColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color touchedColor = Color.magenta;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/89a/d05/33d89ad0522ace10075800607aac71b2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auswahl der Zellenfarbe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allgemeinen Farbfeld hinzuf√ºgen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es der Standardfarbe zu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen auch </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Farbinformationen </font><font style="vertical-align: inherit;">erg√§nzen </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;Color&gt; colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); ‚Ä¶ hexMesh.vertices = vertices.ToArray(); hexMesh.colors = colors.ToArray(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Triangulieren m√ºssen wir nun jedem Dreieck Farbdaten hinzuf√ºgen. </font><font style="vertical-align: inherit;">Zu diesem Zweck erstellen wir eine separate Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur√ºck zu </font></font><code>HexGrid.TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Konvertieren Sie zun√§chst die Koordinaten der Zelle in den entsprechenden Index des Arrays. </font><font style="vertical-align: inherit;">F√ºr ein quadratisches Gitter w√§re dies nur X plus Z multipliziert mit der Breite, aber in unserem Fall m√ºssen wir auch einen Versatz von der H√§lfte Z hinzuf√ºgen. Dann nehmen wir die Zelle, √§ndern ihre Farbe und triangulieren das Netz erneut.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºssen wir wirklich das gesamte Netz neu triangulieren?</font></font></b> <div class="spoiler_text">    ,       .       .    ,    ,     .       . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = touchedColor; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir die Zellen jetzt einf√§rben k√∂nnen, sind visuelle √Ñnderungen noch nicht sichtbar. </font><font style="vertical-align: inherit;">Dies liegt daran, dass der Shader standardm√§√üig keine Scheitelpunktfarben verwendet. </font><font style="vertical-align: inherit;">Wir m√ºssen unsere eigenen schreiben. </font><font style="vertical-align: inherit;">Erstellen Sie einen neuen Standard-Shader ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assets / Create / Shader / Default Surface Shader</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Es m√ºssen nur zwei √Ñnderungen vorgenommen werden. </font><font style="vertical-align: inherit;">F√ºgen Sie zun√§chst Farbdaten zu der Eingabestruktur hinzu. </font><font style="vertical-align: inherit;">Zweitens multiplizieren Sie die Albedo mit dieser Farbe. </font><font style="vertical-align: inherit;">Wir interessieren uns nur f√ºr RGB-Kan√§le, weil das Material undurchsichtig ist.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/VertexColors" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie mit diesem Shader ein neues Material und lassen Sie das Maschennetz dieses Material verwenden. </font><font style="vertical-align: inherit;">Dank dessen erscheinen die Farben der Zellen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/efe/be1/223efebe1bdda83c9b383dac32197c6e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbige Zellen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bekomme seltsame Schattenartefakte!</font></font></b> <div class="spoiler_text">    Unity        .          ,   ,   Z-.            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karteneditor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir nun wissen, wie man Farben √§ndert, erstellen wir einen einfachen In-Game-Editor. </font><font style="vertical-align: inherit;">Diese Funktionalit√§t gilt nicht f√ºr Funktionen </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, daher werden wir sie </font></font><code>TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine allgemeine Methode mit einem zus√§tzlichen Farbparameter umwandeln. </font><font style="vertical-align: inherit;">L√∂schen Sie auch das Feld </font></font><code>touchedColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Color color</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = color; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Komponente </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verschieben Sie die Methoden </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">dorthin </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie ein gemeinsames Feld hinzu, um auf das Sechseckraster, ein Array von Farben und ein privates Feld zu verweisen, um die aktive Farbe zu verfolgen. </font><font style="vertical-align: inherit;">F√ºgen Sie abschlie√üend eine allgemeine Methode zum Ausw√§hlen einer Farbe hinzu und lassen Sie sie zun√§chst die erste Farbe ausw√§hlen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color activeColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SelectColor(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { hexGrid.ColorCell(hit.point, activeColor); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeColor = colors[index]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine weitere Zeichenfl√§che hinzu, wobei Sie die Standardeinstellungen beibehalten. </font><font style="vertical-align: inherit;">F√ºgen Sie eine Komponente hinzu </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, definieren Sie mehrere Farben und verbinden Sie sie mit einem Sechseckraster. </font><font style="vertical-align: inherit;">Dieses Mal ben√∂tigen wir ein Ereignissystemobjekt, das automatisch neu erstellt wurde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/0d6/be4/d180d6be4c656688f4ec6c4f5789bdba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vierfarbiger Sechskant-Karteneditor. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie der Leinwand ein Bedienfeld zum Speichern von Farbw√§hlern hinzu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Bedienfeld</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">F√ºgen Sie ihre Umschaltgruppe hinzu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponenten / Benutzeroberfl√§che / Umschaltgruppe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Machen Sie das Panel klein und platzieren Sie es in der Ecke des Bildschirms.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/b05/4db/63fb054dbb5c64fce6c4671283df6e6a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbbedienfeld mit Umschaltgruppe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºllen Sie nun das Bedienfeld mit Schaltern f√ºr jede Farbe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Toggle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Solange wir uns nicht mit der Erstellung einer komplexen Benutzeroberfl√§che besch√§ftigen, reicht eine einfache manuelle Konfiguration aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/40e/ffc/eef40effcb9510ba924186b766a1fee0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/0e4/595/d580e45954552b134082a9379af2eb8c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Schalter f√ºr jede Farbe. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie den ersten Schalter ein. </font><font style="vertical-align: inherit;">Machen Sie au√üerdem alle Schalter zu Teilen der Umschaltgruppe, sodass jeweils nur einer ausgew√§hlt werden kann. </font><font style="vertical-align: inherit;">Verbinden Sie sie schlie√ülich mit </font></font><code>SelectColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">unseres Editors. </font><font style="vertical-align: inherit;">Dies kann √ºber die Schaltfl√§che "+" der Benutzeroberfl√§che des Ereignisses " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed" erfolgen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">W√§hlen Sie das Karteneditorobjekt aus und w√§hlen Sie dann die gew√ºnschte Methode aus der Dropdown-Liste aus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/e05/0af/7b4e050afca862a244607248834676aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schalter. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Ereignis √ºbergibt ein boolesches Argument, das bestimmt, ob der Schalter bei jeder √Ñnderung eingeschaltet wird. </font><font style="vertical-align: inherit;">Aber es ist uns egal. </font><font style="vertical-align: inherit;">Stattdessen m√ºssen wir manuell ein ganzzahliges Argument √ºbergeben, das dem Farbindex entspricht, den wir verwenden m√∂chten. </font><font style="vertical-align: inherit;">Lassen Sie daher den Wert 0 f√ºr den ersten Schalter, setzen Sie den Wert 1 auf den zweiten und so weiter.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann wird die Switch-Event-Methode aufgerufen?</font></font></b> <div class="spoiler_text">       .      ,    ,   . <br><br>      ,         ,    .  ,  <code>SelectColor</code>   .  ,      . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/0bb/8f4/35a0bb8f4425b0c821836f9aa9afda16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√§rbung in mehreren Farben. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl die Benutzeroberfl√§che funktioniert, gibt es ein nerviges Detail. </font><font style="vertical-align: inherit;">Bewegen Sie das Bedienfeld so, dass es das Sechseckgitter bedeckt, um es zu sehen. </font><font style="vertical-align: inherit;">Bei der Auswahl einer neuen Farbe werden auch die Zellen unter der Benutzeroberfl√§che eingef√§rbt. </font><font style="vertical-align: inherit;">Das hei√üt, wir interagieren gleichzeitig mit der Benutzeroberfl√§che und dem Raster. </font><font style="vertical-align: inherit;">Dies ist ein unerw√ºnschtes Verhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann behoben werden, indem das Ereignissystem gefragt wird, ob es die Position des Cursors √ºber einem Objekt bestimmt hat. </font><font style="vertical-align: inherit;">Da sie nur √ºber UI-Objekte Bescheid wei√ü, wird uns dies mitteilen, dass wir mit der UI interagieren. </font><font style="vertical-align: inherit;">Daher m√ºssen wir die Eingabe nur dann selbst verarbeiten, wenn dies nicht der Fall ist.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 2: Mischen von Zellfarben </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsverzeichnis </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbinden Sie die Nachbarn. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpolieren Sie die Farben zwischen den Dreiecken. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie Mischbereiche. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vereinfachen Sie die Geometrie. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir den Grundstein f√ºr das Raster gelegt und die M√∂glichkeit zum Bearbeiten von Zellen hinzugef√ºgt. </font><font style="vertical-align: inherit;">Jede Zelle hat ihre eigene Volltonfarbe und die Farben an den Zellenr√§ndern √§ndern sich dramatisch. </font><font style="vertical-align: inherit;">In diesem Tutorial erstellen wir √úbergangszonen, in denen die Farben benachbarter Zellen gemischt werden.</font></font><br><cut></cut><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/518/132/8ca518132084099a6159027d4a345710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glatte √úberg√§nge zwischen Zellen.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachbarzellen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir eine Gl√§ttung zwischen den Farben der Zellen durchf√ºhren, m√ºssen wir herausfinden, welche der Zellen nebeneinander liegen. </font><font style="vertical-align: inherit;">Jede Zelle hat sechs Nachbarn, die in Richtung der Kardinalpunkte identifiziert werden k√∂nnen. </font><font style="vertical-align: inherit;">Wir erhalten die folgenden Richtungen: Nordosten, Osten, S√ºdosten, S√ºdwesten, Westen und Nordwesten. </font><font style="vertical-align: inherit;">Erstellen wir eine Aufz√§hlung f√ºr sie und f√ºgen sie in eine separate Skriptdatei ein.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist Aufz√§hlung?</font></font></b> <div class="spoiler_text"> <code>enum</code>     ,     .            .      ,      .  ,        . <br><br>  enum     .   ,     integer  .   ,    -  ,    integer. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/e0e/37f/181e0e37fdd59ab37214cc909409351c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sechs Nachbarn, sechs Richtungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array </font><font style="vertical-align: inherit;">hinzu, um diese Nachbarn zu speichern </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obwohl wir es allgemein machen k√∂nnen, werden wir es stattdessen privat machen und den Zugriff auf Methoden unter Verwendung von Anweisungen erm√∂glichen. </font><font style="vertical-align: inherit;">Wir machen es auch serialisierbar, damit die Bindungen bei der Neukompilierung nicht verloren gehen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] HexCell[] neighbors;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºssen wir alle Verbindungen zu Nachbarn speichern?</font></font></b> <div class="spoiler_text">       ,       .     ‚Äî    ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird das Array der Nachbarn im Inspektor angezeigt. </font><font style="vertical-align: inherit;">Da jede Zelle sechs Nachbarn hat, legen </font><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">f√ºr unser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Cell-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighaus </font><font style="vertical-align: inherit;">die Gr√∂√üe von Array 6 fest.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/8c1/a2e/6ef8c1a2ee9478b007faefcef2516934.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Fertighaus ist Platz f√ºr sechs Nachbarn. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir nun eine allgemeine Methode hinzu, um einen Zellnachbarn in eine Richtung zu erhalten. </font><font style="vertical-align: inherit;">Da der Richtungswert immer im Bereich von 0 bis 5 liegt, m√ºssen wir nicht pr√ºfen, ob sich der Index innerhalb des Arrays befindet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie eine Methode hinzu, um einen Nachbarn anzugeben. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Beziehungen der Nachbarn sind bidirektional. </font><font style="vertical-align: inherit;">Wenn Sie einen Nachbarn in eine Richtung setzen, ist es daher logisch, einen Nachbarn sofort in die entgegengesetzte Richtung zu setzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; cell.neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction.Opposite()] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b86/616/15c/b8661615ceece04f7f4c16fa1c032be4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbarn in entgegengesetzte Richtungen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies deutet nat√ºrlich darauf hin, dass wir Anweisungen f√ºr den gegen√ºberliegenden Nachbarn anfordern k√∂nnen. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies implementieren, indem wir eine Erweiterungsmethode f√ºr erstellen </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Um die entgegengesetzte Richtung zu erhalten, m√ºssen Sie zum Original 3 hinzuf√ºgen. Dies funktioniert jedoch nur f√ºr die ersten drei Richtungen, f√ºr den Rest m√ºssen Sie 3 subtrahieren.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexDirectionExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Opposite</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> ? (direction + <span class="hljs-number"><span class="hljs-number">3</span></span>) : (direction - <span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist eine Erweiterungsmethode?</font></font></b> <div class="spoiler_text">   ‚Äî      ,       - .       ‚Äî , , ,    .         <code>this</code> .      ,     . <br><br>        ? ,  ,       ,      .    ?    ‚Äî .  ,      ,        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachbarverbindung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen den Nachbarlink in initialisieren </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn wir Zellen Zeile f√ºr Zeile von links nach rechts durchlaufen, wissen wir, welche Zellen bereits erstellt wurden. </font><font style="vertical-align: inherit;">Dies sind die Zellen, mit denen wir uns verbinden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am einfachsten ist die E - W - Verbindung. </font><font style="vertical-align: inherit;">Die erste Zelle jeder Reihe hat keinen √∂stlichen Nachbarn. </font><font style="vertical-align: inherit;">Aber alle anderen Zellen haben es. </font><font style="vertical-align: inherit;">Und diese Nachbarn werden vor der Zelle erstellt, mit der wir gerade arbeiten. </font><font style="vertical-align: inherit;">Deshalb k√∂nnen wir sie verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/3bf/16f/7873bf16fdecde4ff216cc30b206ce89.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verbindung von E nach W w√§hrend der Erstellung von Zellen.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.color = defaultColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/560/08e/8b6/56008e8b6b2c16f3da710a2cedebb7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die √∂stlichen und westlichen Nachbarn sind miteinander verbunden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen zwei weitere bidirektionale Verbindungen erstellen. </font><font style="vertical-align: inherit;">Da dies die Verbindungen zwischen verschiedenen Linien des Gitters sind, k√∂nnen wir nur mit der vorherigen Linie kommunizieren. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die erste Zeile vollst√§ndig √ºberspringen m√ºssen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Linien im Zickzack sind, m√ºssen sie unterschiedlich verarbeitet werden. </font><font style="vertical-align: inherit;">Lassen Sie uns zuerst mit geraden Linien umgehen. </font><font style="vertical-align: inherit;">Da alle Zellen in solchen Zeilen einen Nachbarn auf SE haben, k√∂nnen wir sie damit verbinden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/e56/419/7d5e56419ed4a0fb7b2c506061543561.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung von NW nach SE f√ºr gerade Linien.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht z &amp; 1?</font></font></b> <div class="spoiler_text"> <code>&amp;&amp;</code> ‚Äî    ,  <code>&amp;</code> ‚Äî    .     ,         .      1,      1. , <code>10101010 &amp; 00001111</code>  <code>00001010</code> . <br><br>     .    0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,         0. <br><br>      ,  ,    .    0,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen uns mit Nachbarn in der SW verbinden, mit Ausnahme der ersten Zelle jeder Zeile, die diese nicht hat. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed1/f7a/73c/ed1f7a73c9e09970a041e4596668626b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung von NE nach SW f√ºr gerade Linien.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungerade Linien folgen der gleichen Logik, jedoch spiegelbildlich. </font><font style="vertical-align: inherit;">Nach Abschluss dieses Vorgangs sind alle Nachbarn in unserem Netz verbunden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; width - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/eee/ff1/00beeeff163b36232bd37f6076c34c90.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Nachbarn sind verbunden. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist nicht jede Zelle mit genau sechs Nachbarn verbunden. </font><font style="vertical-align: inherit;">Zellen an der Gittergrenze haben mindestens zwei und nicht mehr als f√ºnf Nachbarn. </font><font style="vertical-align: inherit;">Und das muss ber√ºcksichtigt werden.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/4a9/1c5/e7a4a91c55e7cc2574eed105f7b9a110.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachbarn f√ºr jede Zelle. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farbmischung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen von Farben erschwert die Triangulation jeder Zelle. </font><font style="vertical-align: inherit;">Lassen Sie uns daher den Triangulationscode in einem separaten Teil trennen. </font><font style="vertical-align: inherit;">Da wir jetzt Anweisungen haben, verwenden wir sie anstelle von numerischen Indizes, um Teile anzuzeigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction], center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir jetzt Richtungen verwenden, w√§re es praktisch, Winkel mit Richtungen zu erhalten und nicht die Konvertierung in Indizes durchzuf√ºhren. </font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dazu m√ºssen Sie </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei statische Methoden </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Als Bonus k√∂nnen wir so die Auswahl der Winkel privat machen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mehrere Farben auf einem Dreieck </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher hat die Methode </font></font><code>HexMesh.AddTriangleColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur ein Farbargument. </font><font style="vertical-align: inherit;">Es kann nur ein einfarbiges Dreieck erstellt werden. </font><font style="vertical-align: inherit;">Erstellen wir eine Alternative, die separate Farben f√ºr jeden Scheitelpunkt unterst√ºtzt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir anfangen, Farben zu mischen! </font><font style="vertical-align: inherit;">Beginnen wir einfach mit der Nachbarfarbe f√ºr die beiden anderen Eckpunkte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) ); HexCell neighbor = cell.GetNeighbor(direction); AddTriangleColor(cell.color, neighbor.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies f√ºhrt leider dazu </font></font><code>NullReferenceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dass die Zellen an der Grenze keine sechs Nachbarn haben. </font><font style="vertical-align: inherit;">Was sollen wir tun, wenn ein Nachbar fehlt? </font><font style="vertical-align: inherit;">Seien wir pragmatisch und verwenden die Zelle selbst als Ersatz.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was macht der Betreiber?</font></font></b> <div class="spoiler_text">    null-coalescing operator.   ,  <code>a ?? b</code> ‚Äî      <code>a != null ? a : b</code> . <br><br>   ,     -   Unity   .           <code>null</code> .        . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/558/667/3755586675e7126b25e776f1283ec8b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Mischung von Farben, aber es wird falsch gemacht.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wohin gingen die Koordinatenbeschriftungen?</font></font></b> <div class="spoiler_text">   ,       UI. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Farbmittelung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen von Farben funktioniert, aber die Ergebnisse sind offensichtlich falsch. </font><font style="vertical-align: inherit;">Die Farbe an den R√§ndern der Sechsecke sollte der Durchschnitt zweier benachbarter Zellen sein.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Color edgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddTriangleColor(cell.color, edgeColor, edgeColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/079/b26/aff079b261e39c1959d004c0ddf3a58f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rippen mischen. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl wir an den R√§ndern mischen, erhalten wir immer noch scharfe Farbr√§nder. </font><font style="vertical-align: inherit;">Dies geschieht, weil jeder Scheitelpunkt des Sechsecks von drei Sechsecken geteilt wird.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/8f2/507/19e8f2507f011213c1514ea20ce04906.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei Nachbarn, vier Farben. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass wir auch Nachbarn in der vorherigen und n√§chsten Richtung ber√ºcksichtigen m√ºssen. </font><font style="vertical-align: inherit;">Das hei√üt, wir erhalten vier Farben in zwei Dreiergruppen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir </font></font><code>HexDirectionExtensions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Additionsmethoden f√ºr einen bequemen √úbergang zur vorherigen und n√§chsten Richtung hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NE ? HexDirection.NW : (direction - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NW ? HexDirection.NE : (direction + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir alle drei Nachbarn bekommen und Drei-Wege-Mischen durchf√ºhren. </font></font><br><br><pre> <code class="cs hljs"> HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/b19/778/430b197786bb2bde51fb528946561733.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An den Ecken mischen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So erhalten wir die richtigen Farb√ºberg√§nge mit Ausnahme des Netzrandes. </font><font style="vertical-align: inherit;">Die Randzellen stimmen nicht mit den Farben der fehlenden Nachbarn √ºberein, daher sehen wir hier immer noch scharfe R√§nder. </font><font style="vertical-align: inherit;">Im Allgemeinen liefert unser derzeitiger Ansatz jedoch keine guten Ergebnisse. </font><font style="vertical-align: inherit;">Wir brauchen eine bessere Strategie. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mischbereiche </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Mischen √ºber die gesamte Oberfl√§che des Sechsecks f√ºhrt zu verschwommenem Chaos. </font><font style="vertical-align: inherit;">Wir k√∂nnen einzelne Zellen nicht klar sehen. </font><font style="vertical-align: inherit;">Die Ergebnisse k√∂nnen erheblich verbessert werden, indem nur neben den Kanten der Sechsecke gemischt wird. </font><font style="vertical-align: inherit;">In diesem Fall beh√§lt der innere Bereich der Sechsecke eine feste Farbe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/82a/ff6/53e82aff62f060a51ef5645accd45d03.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontinuierliche Schattierung von Cent mit Mischbereichen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie gro√ü sollte der feste Bereich im Vergleich zum Mischbereich sein? </font><font style="vertical-align: inherit;">Unterschiedliche Verteilungen f√ºhren zu unterschiedlichen Ergebnissen. </font><font style="vertical-align: inherit;">Wir werden diesen Bereich als Bruchteil des Au√üenradius definieren. </font><font style="vertical-align: inherit;">Lassen Sie es gleich 75% sein. </font><font style="vertical-align: inherit;">Dies wird uns zu zwei neuen Metriken f√ºhren, die insgesamt 100% betragen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - solidFactor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch Erstellen dieses neuen festen F√ºllfaktors k√∂nnen wir Methoden schreiben, um die Winkel fester innerer Sechsecke zu erhalten. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * solidFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * solidFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie es </font><font style="vertical-align: inherit;">jetzt </font><font style="vertical-align: inherit;">so, dass diese festen Schattierungswinkel anstelle der urspr√ºnglichen Winkel verwendet werden. </font><font style="vertical-align: inherit;">Wir lassen die Farben vorerst gleich.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d40/eb5/326/d40eb5326b0e0457e55ae2752897efc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feste Sechsecke ohne Kanten.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation von Mischbereichen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen den leeren Raum ausf√ºllen, den wir durch Reduzieren der Dreiecke erstellt haben. </font><font style="vertical-align: inherit;">In jeder Richtung hat dieser Raum die Form eines Trapezes. </font><font style="vertical-align: inherit;">Um es abzudecken, k√∂nnen Sie das Viereck (Quad) verwenden. </font><font style="vertical-align: inherit;">Daher werden wir Methoden erstellen, um ein Viereck und seine Farben hinzuzuf√ºgen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/bc9/ce5/c2fbc9ce504e0e8df61b194f20c83f3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trapezrippe.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3, Color c4</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); colors.Add(c4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es neu, so dass das Dreieck eine Farbe erh√§lt und das Viereck eine Mischung zwischen einer Volltonfarbe und den Farben zweier Winkel ausf√ºhrt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); Vector3 v3 = center + HexMetrics.GetFirstCorner(direction); Vector3 v4 = center + HexMetrics.GetSecondCorner(direction); AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor( cell.color, cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aea/8de/d01/aea8ded01fc8928ec64293b11b335a91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen mit Trapezrippen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Br√ºcken zwischen Rippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bild wird besser, aber die Arbeit ist noch nicht abgeschlossen. </font><font style="vertical-align: inherit;">Das Mischen von Farben zwischen zwei Nachbarn wird durch benachbarte Zellen kontaminiert. </font><font style="vertical-align: inherit;">Um dies zu vermeiden, m√ºssen wir die Ecken des Trapezes abschneiden und in ein Rechteck verwandeln. </font><font style="vertical-align: inherit;">Danach wird er eine Br√ºcke zwischen der Zelle und ihrem Nachbarn bauen und L√ºcken an den Seiten hinterlassen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/acf/602/b76acf602ad32b7001117a17c0e6c72f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Br√ºcke zwischen den Rippen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen neue Positionen finden </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, beginnend mit </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann entlang der Br√ºcke bis zum Rand der Zelle gehen. </font><font style="vertical-align: inherit;">Wie wird die Br√ºcke verschoben? </font><font style="vertical-align: inherit;">Wir k√∂nnen es finden, indem wir den Mittelpunkt zwischen den beiden entsprechenden Winkeln nehmen und dann den Mischungskoeffizienten darauf anwenden. </font><font style="vertical-align: inherit;">Das wird reichen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * blendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur√ºck zu </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es ist jetzt logisch, eine Option hinzuzuf√ºgen </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die nur zwei Farben erfordert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c1); colors.Add(c2); colors.Add(c2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie es </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass richtig gemischte Br√ºcken zwischen den Nachbarn entstehen.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor(cell.color, (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/0bd/fb3/2880bdfb3ae5b97a5907164fc8b71774.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtig gestrichene Br√ºcken mit Eckabst√§nden.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L√ºcken f√ºllen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir eine dreieckige L√ºcke an der Verbindungsstelle von drei Zellen gebildet. </font><font style="vertical-align: inherit;">Wir haben diese L√ºcken durch Ausschneiden der dreieckigen Seiten des Trapezes erhalten. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Dreiecke zur√ºckbekommen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich zun√§chst ein Dreieck vor, das mit einem vorherigen Nachbarn verbunden ist. </font><font style="vertical-align: inherit;">Sein erster Scheitelpunkt hat eine Zellfarbe. </font><font style="vertical-align: inherit;">Die Farbe des zweiten Peaks ist eine Mischung aus drei Farben. </font><font style="vertical-align: inherit;">Und der letzte Gipfel hat die gleiche Farbe wie der Punkt in der Mitte der Br√ºcke.</font></font><br><br><pre> <code class="cs hljs"> Color bridgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddQuadColor(cell.color, bridgeColor); AddTriangle(v1, center + HexMetrics.GetFirstCorner(direction), v3); AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, bridgeColor );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/d75/a50/b7fd75a50368ba2bcb79595fa1c58329.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast alles ist fertig. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein anderes Dreieck funktioniert auf die gleiche Weise, au√üer dass die Br√ºcke nicht den dritten, sondern den zweiten Gipfel ber√ºhrt.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, center + HexMetrics.GetSecondCorner(direction)); AddTriangleColor( cell.color, bridgeColor, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/7b2/d71/9a57b2d71d5db4aa2c22a2aba954babe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volle F√§rbung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir sch√∂ne Mischbereiche, die wir jeder Gr√∂√üe geben k√∂nnen. </font><font style="vertical-align: inherit;">Die Kanten k√∂nnen nach Belieben verschwommen oder scharf gemacht werden. </font><font style="vertical-align: inherit;">Sie k√∂nnen jedoch feststellen, dass das Mischen in der N√§he des Netzrandes immer noch nicht korrekt implementiert ist. </font><font style="vertical-align: inherit;">Und wieder werden wir es f√ºr sp√§ter belassen und uns vorerst auf ein anderes Thema konzentrieren.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber die √úberg√§nge zwischen den Farben sind immer noch h√§sslich</font></font></b> <div class="spoiler_text">     .            .            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rippenfusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen Sie sich die Topologie unseres Rasters an. </font><font style="vertical-align: inherit;">Welche Formen fallen hier auf? </font><font style="vertical-align: inherit;">Wenn Sie die Grenze nicht beachten, k√∂nnen wir drei verschiedene Arten von Formularen unterscheiden. </font><font style="vertical-align: inherit;">Es gibt einfarbige Sechsecke, zweifarbige Rechtecke und dreifarbige Dreiecke. </font><font style="vertical-align: inherit;">Alle diese drei Farben erscheinen an der Verbindungsstelle der drei Zellen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a27/370/ae7/a27370ae7474595516c3186adb393590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drei visuelle Strukturen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle zwei Sechsecke sind also durch eine rechteckige Br√ºcke verbunden. </font><font style="vertical-align: inherit;">Und alle drei Sechsecke sind durch ein Dreieck verbunden. </font><font style="vertical-align: inherit;">Wir f√ºhren jedoch eine komplexere Triangulation durch. </font><font style="vertical-align: inherit;">Jetzt verwenden wir zwei Vierecke anstelle von einem, um ein Paar Sechsecke zu verbinden. </font><font style="vertical-align: inherit;">Und um die drei Sechsecke zu verbinden, verwenden wir sechs Dreiecke. </font><font style="vertical-align: inherit;">Das ist zu redundant. </font><font style="vertical-align: inherit;">Wenn wir uns direkt mit einer Form verbinden w√ºrden, m√ºssten wir keine Farbmittelung vornehmen. </font><font style="vertical-align: inherit;">Daher k√∂nnten wir mit weniger Komplexit√§t, weniger Arbeit und weniger Dreiecken auskommen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/448/ef3/e5d448ef31208fd42f3e7e73138c3b48.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§rter als n√∂tig.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum brauchen wir das √ºberhaupt?</font></font></b> <div class="spoiler_text"> ,        .   ,     ,   .   ,        ,     .       ,   ,   . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direkte √úberbr√ºckung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt bestehen unsere Br√ºcken zwischen den Rippen aus zwei Vierecken. Um sie auf das n√§chste Sechseck auszudehnen, m√ºssen wir die L√§nge der Br√ºcke verdoppeln. Dies bedeutet, dass wir nicht mehr zwei Winkel mitteln m√ºssen </font></font><code>HexMetrics.GetBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Stattdessen addieren wir sie einfach und multiplizieren sie dann mit dem Mischfaktor.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * blendFactor; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/8d6/33f/f168d633fff07b5ecd6bf361e14e0edd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Br√ºcken √ºberspannten die gesamte L√§nge und √ºberlappten sich. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken stellen jetzt direkte Verbindungen zwischen Sechsecken her. </font><font style="vertical-align: inherit;">Wir erzeugen aber immer noch zwei Vierecke pro Verbindung, eines in jede Richtung. </font><font style="vertical-align: inherit;">Das hei√üt, nur einer von ihnen sollte Br√ºcken zwischen zwei Zellen schaffen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachen wir zuerst unseren Triangulationscode. </font><font style="vertical-align: inherit;">Wir l√∂schen alles, was mit den Dreiecken der Kanten und der Farbmischung zu tun hat. </font><font style="vertical-align: inherit;">Verschieben Sie dann den Code, der das Viereck der Br√ºcke zur neuen Methode hinzuf√ºgt. </font><font style="vertical-align: inherit;">Wir √ºbergeben die ersten beiden Eckpunkte an diese Methode, damit wir sie nicht neu berechnen m√ºssen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); TriangulateConnection(direction, cell, v1, v2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Triangulation von Verbindungen leicht begrenzen. </font><font style="vertical-align: inherit;">Zun√§chst f√ºgen wir die Bridge nur hinzu, wenn Sie mit der NE-Verbindung arbeiten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == HexDirection.NE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/7ac/53f/cfa7ac53f3fbab322c4c481f29ec1cac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Br√ºcken sind nur in Richtung NE. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass wir alle Verbindungen abdecken k√∂nnen, indem wir sie nur in die ersten drei Richtungen triangulieren: NE, E und SE.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/568/698/e07/568698e079839a5ff4108083c6f71d8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle internen Br√ºcken und Br√ºcken an den Grenzen. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben alle Verbindungen zwischen zwei benachbarten Zellen abgedeckt. </font><font style="vertical-align: inherit;">Wir haben aber auch einige Br√ºcken, die von der Zelle ins Nirgendwo f√ºhren. </font><font style="vertical-align: inherit;">Lassen Sie uns sie loswerden und raus, </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Nachbarn raus sind. </font><font style="vertical-align: inherit;">Das hei√üt, wir m√ºssen die fehlenden Nachbarn nicht mehr durch die Zelle selbst ersetzen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/54c/21d/5a254c21d71cf66817a1ee42b7f02ddd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur interne Br√ºcken.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dreiecksgelenke </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir die dreieckigen L√ºcken wieder schlie√üen. </font><font style="vertical-align: inherit;">Lassen Sie uns dies f√ºr ein Dreieck tun, das mit dem n√§chsten Nachbarn verbunden ist. </font><font style="vertical-align: inherit;">Und dies muss wieder nur getan werden, wenn ein Nachbar existiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie wird die Position des dritten Gipfels sein? </font><font style="vertical-align: inherit;">Ich habe als Ersatz eingef√ºgt </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber das ist offensichtlich falsch. </font><font style="vertical-align: inherit;">Da jede Kante dieser Dreiecke mit der Br√ºcke verbunden ist, k√∂nnen wir sie finden, indem wir entlang der Br√ºcke zum n√§chsten Nachbarn gehen.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/256/bde/b5c256bde3a05d41287ca96007e208f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir machen wieder die vollst√§ndige Triangulation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sind wir fertig? </font><font style="vertical-align: inherit;">Noch nicht, denn jetzt erstellen wir √ºberlappende Dreiecke. </font><font style="vertical-align: inherit;">Da die drei Zellen eine gemeinsame Dreiecksverbindung haben, m√ºssen sie nur f√ºr zwei Verbindungen hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">Daher werden NE und E. ausreichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next())); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Teil 3: H√∂hen </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhaltsverzeichnis </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenh√∂he hinzuf√ºgen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulieren Sie die H√§nge. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setzen Sie die Leisten ein. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kombinieren Sie Felsvorspr√ºnge und Klippen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In diesem Teil des Tutorials werden wir Unterst√ºtzung f√ºr verschiedene H√∂henstufen hinzuf√ºgen und spezielle √úberg√§nge zwischen ihnen erstellen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/24a/e1f/8da24ae1f70e4770264ed0ab05d183ef.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂hen und Leisten.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellenh√∂he </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben unsere Karte in separate Zellen unterteilt, die einen flachen Bereich abdecken. </font><font style="vertical-align: inherit;">Jetzt geben wir jeder Zelle ihre eigene H√∂he. </font><font style="vertical-align: inherit;">Wir werden diskrete H√∂henstufen verwenden, um sie als ganzzahliges Feld in zu speichern </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie gro√ü kann jede nachfolgende H√∂he sein? </font><font style="vertical-align: inherit;">Wir k√∂nnen jeden Wert verwenden, also setzen wir ihn als eine andere Konstante </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden einen Schritt von f√ºnf Einheiten verwenden, damit die √úberg√§nge deutlich sichtbar sind. </font><font style="vertical-align: inherit;">In einem echten Spiel w√ºrde ich einen kleineren Schritt verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zellen √§ndern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher konnten wir nur die Farbe der Zelle √§ndern, jetzt k√∂nnen wir ihre H√∂he √§ndern. </font><font style="vertical-align: inherit;">Daher </font></font><code>HexGrid.ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reicht uns </font><font style="vertical-align: inherit;">die Methode </font><font style="vertical-align: inherit;">nicht aus. </font><font style="vertical-align: inherit;">Dar√ºber hinaus k√∂nnen wir in Zukunft weitere Optionen f√ºr die Zellbearbeitung hinzuf√ºgen, sodass wir einen neuen Ansatz ben√∂tigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benennen Sie </font></font><code>ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in um </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und machen Sie es so, dass anstatt die Farbe der Zelle festzulegen, die Zelle an der angegebenen Position zur√ºckgegeben wird. </font><font style="vertical-align: inherit;">Da diese Methode nichts anderes √§ndert, m√ºssen wir die Zellen sofort triangulieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[index]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird sich der Editor mit dem Zellwechsel befassen. </font><font style="vertical-align: inherit;">Nach Abschluss der Arbeiten muss das Gitter erneut trianguliert werden. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu eine allgemeine Methode hinzu </font></font><code>HexGrid.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit er mit neuen Methoden arbeiten kann. </font><font style="vertical-align: inherit;">Geben wir ihm eine neue Methode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die alle √Ñnderungen an der Zelle behandelt und anschlie√üend das Raster aktualisiert.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCell(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir k√∂nnen die H√∂hen einfach √§ndern, indem wir der gew√ºnschten Zelle die gew√ºnschte H√∂henstufe zuweisen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bei Farben ben√∂tigen wir eine Methode zum Festlegen der aktiven H√∂henstufe, die wir der Benutzeroberfl√§che zuordnen. </font><font style="vertical-align: inherit;">Um Werte aus dem H√∂henintervall auszuw√§hlen, verwenden wir den Schieberegler. </font><font style="vertical-align: inherit;">Da die Schieberegler mit float arbeiten, erfordert unsere Methode einen Parameter vom Typ float. </font><font style="vertical-align: inherit;">Wir werden es einfach in eine Ganzzahl konvertieren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation</span></span></span><span class="hljs-function">)</span></span> { activeElevation = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)elevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie einen Schieberegler auf der Leinwand hinzu ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / Create / Slider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und platzieren Sie ihn unter dem </font><i><font style="vertical-align: inherit;">Farbbedienfeld</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir machen es vertikal von unten nach oben, so dass es optisch den H√∂hen entspricht. </font><font style="vertical-align: inherit;">Wir beschr√§nken es auf Ganzzahlen und erstellen ein geeignetes Intervall, z. B. von 0 bis 6. Dann h√§ngen wir das Ereignis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an die </font><i><font style="vertical-align: inherit;">Hex Map Editor-</font></i></font><code>SetElevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objektmethode an </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Methode muss aus der dynamischen Liste ausgew√§hlt werden, damit sie mit dem Wert des Schiebereglers aufgerufen wird.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05f/6c5/93c/05f6c593cc553c4f4a86f9c2e9012156.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/0a5/e8b/7c60a5e8bfebd2ec87d2daaeeb148be6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂henregler.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> H√∂henvisualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim √Ñndern einer Zelle stellen wir jetzt sowohl Farbe als auch H√∂he ein. </font><font style="vertical-align: inherit;">Obwohl wir im Inspektor sehen k√∂nnen, dass sich die H√∂he tats√§chlich √§ndert, ignoriert der Triangulationsprozess sie immer noch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es reicht aus, die vertikale lokale Position der Zelle zu √§ndern, wenn wir die H√∂he √§ndern. </font><font style="vertical-align: inherit;">Machen Sie die Methode der Einfachheit halber </font></font><code>HexCell.elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">privat und f√ºgen Sie eine allgemeine Eigenschaft hinzu </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir die vertikale Position der Zelle beim Bearbeiten der H√∂he √§ndern. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erfordert nat√ºrlich kleine √Ñnderungen an </font></font><code>HexMapEditor.EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/5de/6eb/6525de6ebae59208507af3e8b744bab5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellen mit unterschiedlichen H√∂hen.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndert sich der Mesh-Collider an die neue H√∂he?</font></font></b> <div class="spoiler_text">    Unity          mesh collider  null.  ,    ,      null    .   .     (     )  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zellenh√∂hen sind jetzt sichtbar, aber es gibt zwei Probleme. </font><font style="vertical-align: inherit;">Erstens. </font><font style="vertical-align: inherit;">Zellmarkierungen verschwinden unter den erhabenen Zellen. </font><font style="vertical-align: inherit;">Zweitens ignorieren Verbindungen zwischen Zellen die H√∂he. </font><font style="vertical-align: inherit;">Lass es uns reparieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern Sie die Position der Zellbezeichnungen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Derzeit werden UI-Beschriftungen f√ºr Zellen nur einmal erstellt und platziert. Danach vergessen wir sie. </font><font style="vertical-align: inherit;">Um ihre vertikalen Positionen zu aktualisieren, m√ºssen wir sie verfolgen. </font><font style="vertical-align: inherit;">Lassen Sie uns jedem einen </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seinen UI-Labels geben, damit Sie ihn sp√§ter aktualisieren k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform uiRect;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie sie am Ende zu </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.uiRect = label.rectTransform; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir die Eigenschaft </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so erweitern, dass sich auch die Position der Benutzeroberfl√§che der Zelle √§ndert. </font><font style="vertical-align: inherit;">Da das Leinwandnetz der Sechsecke gedreht wird, m√ºssen die Beschriftungen in negativer Richtung entlang der Z-Achse und nicht auf der positiven Seite der Y-Achse verschoben werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = elevation * -HexMetrics.elevationStep; uiRect.localPosition = uiPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/b81/c97/c72b81c970b2bddfe2b2ce6d22471dc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags mit H√∂he.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schaffung von Pisten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir die Flachzellenverbindungen in Steigungen umwandeln. </font><font style="vertical-align: inherit;">Dies geschieht in </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei Kantenverbindungen m√ºssen wir die H√∂he des anderen Endes der Br√ºcke neu definieren.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei Eckfugen m√ºssen wir dasselbe mit der Br√ºcke zum n√§chsten Nachbarn tun. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; AddTriangle(v2, v4, v5); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49b/548/792/49b5487921c6844b7a282e049a97bbd9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbindung unter Ber√ºcksichtigung der H√∂he. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt unterst√ºtzen wir Zellen in unterschiedlichen H√∂hen mit den richtigen Schr√§gfugen zwischen ihnen. </font><font style="vertical-align: inherit;">Aber lasst uns hier nicht aufh√∂ren. </font><font style="vertical-align: inherit;">Wir werden diese Pisten interessanter machen. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rippenfugen mit Leisten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerade H√§nge sehen nicht sehr attraktiv aus. </font><font style="vertical-align: inherit;">Wir k√∂nnen sie in mehrere Schritte unterteilen, indem wir Schritte hinzuf√ºgen. </font><font style="vertical-align: inherit;">Dieser Ansatz wird im Spiel Endless Legend verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel k√∂nnen wir an jedem Hang zwei Leisten einf√ºgen. </font><font style="vertical-align: inherit;">Infolgedessen verwandelt sich ein gro√üer Hang in drei kleine, zwischen denen sich zwei flache Bereiche befinden. </font><font style="vertical-align: inherit;">Um ein solches Schema zu triangulieren, m√ºssen wir jede Verbindung in f√ºnf Stufen trennen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce3/08b/82d/ce308b82db1bb0c72c387cc9da480d54.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Vorspr√ºnge am Hang. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Anzahl der Stufen f√ºr die Steigung einstellen </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und daraus die Anzahl der Stufen berechnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terracesPerSlope = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terraceSteps = terracesPerSlope * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Idealfall k√∂nnten wir einfach jeden Schritt entlang der Steigung interpolieren. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht ganz trivial, da sich die Y-Koordinate nur in ungeraden Stufen √§ndern sollte. </font><font style="vertical-align: inherit;">Andernfalls erhalten wir keine flachen Leisten. </font><font style="vertical-align: inherit;">F√ºgen wir hierf√ºr eine spezielle Interpolationsmethode hinzu </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die horizontale Interpolation ist einfach, wenn wir die Gr√∂√üe des Interpolationsschritts kennen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> horizontalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / terraceSteps; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie funktioniert die Interpolation zwischen zwei Werten?</font></font></b> <div class="spoiler_text">     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">a</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.074ex" viewBox="0 -772.3 429.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-62" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6">b</script>      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7">t</script>  .  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">t</script>  0,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9">a</script>  .    1,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.074ex" viewBox="0 -772.3 429.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-62" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-10">b</script>  .  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11">t</script>  -  0  1, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhj4980FWdFYFJ4isL3P4Ceg7d9psw#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-12">a</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">b</span></span></span><script type="math/tex" id="MathJax-Element-13">b</script>  .       : <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-99"><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-101">1</span><span class="MJXp-mo" id="MJXp-Span-102" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">t</span><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">a</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">b</span></span></span><script type="math/tex" id="MathJax-Element-14">(1 - t)a + tb</script>  . <br><br>  ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-111">1</span><span class="MJXp-mo" id="MJXp-Span-112" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-113">t</span><span class="MJXp-mo" id="MJXp-Span-114" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115">a</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118">b</span><span class="MJXp-mo" id="MJXp-Span-119" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">a</span><span class="MJXp-mo" id="MJXp-Span-121" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">a</span><span class="MJXp-mo" id="MJXp-Span-124" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">b</span><span class="MJXp-mo" id="MJXp-Span-127" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">a</span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">t</span><span class="MJXp-mo" id="MJXp-Span-131" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">b</span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">a</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-15">(1 - t)a + tb = a - ta + tb = a + t(b - a)</script>  .        <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">a</span></span></span><script type="math/tex" id="MathJax-Element-16">a</script>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-138"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">b</span></span></span><script type="math/tex" id="MathJax-Element-17">b</script>   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">b</span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">a</span><span class="MJXp-mo" id="MJXp-Span-145" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-18">(b - a)</script>  .  ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um Y nur in ungeraden Stadien zu √§ndern, k√∂nnen wir verwenden </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-146"><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-149"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-150"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-153"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-154" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-155"><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19">(step + 1) / 2</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir eine ganzzahlige Division verwenden, wird die Reihe 1, 2, 3, 4 in 1, 1, 2, 2 umgewandelt. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> verticalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (terracesPerSlope + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = ((step + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.verticalTerraceStepSize; ay += (<span class="hljs-keyword"><span class="hljs-keyword">by</span></span> - ay) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir eine Methode zum Interpolieren von Leisten f√ºr Farben hinzu. </font><font style="vertical-align: inherit;">Interpolieren Sie sie einfach so, als ob die Verbindungen flach w√§ren.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color a, Color b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Color.Lerp(a, b, h); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Triangulation der Kantenverbindung komplizierter wird, entfernen wir den entsprechenden Code aus </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und platzieren ihn in einer separaten Methode. </font><font style="vertical-align: inherit;">In den Kommentaren werde ich den Quellcode speichern, um in Zukunft darauf zu verweisen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep; TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color); ‚Ä¶ } void TriangulateEdgeTerraces ( Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell ) { AddQuad(beginLeft, beginRight, endLeft, endRight); AddQuadColor(beginCell.color, endCell.color); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beginnen wir mit dem ersten Schritt des Prozesses. </font><font style="vertical-align: inherit;">Wir werden unsere speziellen Interpolationsmethoden verwenden, um das erste Quad zu erstellen. </font><font style="vertical-align: inherit;">In diesem Fall sollte eine kurze Steigung erzeugt werden, die steiler als die urspr√ºngliche ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/434/174/aea/434174aea469a4ba7da285ff02d4467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt beim Erstellen einer Kante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt werden wir sofort zur letzten Stufe √ºbergehen und alles dazwischen √ºberspringen. </font><font style="vertical-align: inherit;">Dies wird die Verbindung der Kanten vervollst√§ndigen, wenn auch bisher mit einer unregelm√§√üigen Form.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/1be/b3e/c6f1beb3ee6663cf8984130dc3d9378e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Schritt beim Erstellen einer Kante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwischenschritte k√∂nnen durch die Schleife hinzugef√ºgt werden. </font><font style="vertical-align: inherit;">In jeder Phase werden die letzten beiden vorherigen Scheitelpunkte die neuen ersten. </font><font style="vertical-align: inherit;">Gleiches gilt f√ºr Farbe. </font><font style="vertical-align: inherit;">Nach der Berechnung der neuen Vektoren und Farben wird ein weiteres Quad hinzugef√ºgt.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c2; v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, i); v4 = HexMetrics.TerraceLerp(beginRight, endRight, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2); } AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/20f/64c/e6d20f64c28feaa5329f085d8a5b673a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Zwischenschritte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben alle Kantenfugen zwei Leisten oder eine andere Zahl, die Sie in angeben </font></font><code>HexMetrics.terracesPerSlope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bis wir Leisten f√ºr Eckverbindungen erstellt haben, werden wir dies nat√ºrlich f√ºr sp√§ter belassen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/37b/4f9/4f337b4f9ba0092144e1148b10a4970b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Kantenfugen haben Leisten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbindungstypen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Umr√ºsten aller Kantenfugen in Leisten ist keine so gute Idee. </font><font style="vertical-align: inherit;">Sie sehen nur dann gut aus, wenn der H√∂henunterschied nur eine Ebene betr√§gt. </font><font style="vertical-align: inherit;">Mit einem gr√∂√üeren Unterschied werden jedoch schmale Leisten mit gro√üen L√ºcken zwischen ihnen erzeugt, und dies sieht nicht sehr sch√∂n aus. </font><font style="vertical-align: inherit;">Au√üerdem m√ºssen wir nicht f√ºr alle Verbindungen Leisten erstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns dies formalisieren und drei Arten von Kanten definieren: eine Ebene, eine Neigung und eine Klippe. </font><font style="vertical-align: inherit;">Erstellen wir hierf√ºr eine Aufz√§hlung.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexEdgeType { Flat, Slope, Cliff }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann man feststellen, um welche Art von Verbindung es sich handelt? </font><font style="vertical-align: inherit;">Dazu k√∂nnen wir eine </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">hinzuf√ºgen </font><font style="vertical-align: inherit;">, die zwei H√∂henstufen verwendet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die H√∂hen gleich sind, haben wir eine flache Rippe. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Pegelunterschied einem Schritt entspricht, ist dies eine Steigung. </font><font style="vertical-align: inherit;">Es ist egal, ob es hoch oder runter geht. </font><font style="vertical-align: inherit;">In allen anderen F√§llen bekommen wir eine Pause.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = elevation2 - elevation1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">1</span></span> || delta == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Slope; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Cliff; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir auch eine bequeme Methode hinzu </font></font><code>HexCell.GetEdgeType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den Typ der Zellkante in eine bestimmte Richtung zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction].elevation ); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºssen wir nicht pr√ºfen, ob in dieser Richtung ein Nachbar existiert?</font></font></b> <div class="spoiler_text">   ,       ,     .      ,    <code>NullReferenceException</code> .       ,    ,    - .    ,     .       . <br><br> ,        ,  ,       .    - ,   <code>NullReferenceException</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen Sie Leisten nur f√ºr H√§nge </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Art der Verbindung bestimmen k√∂nnen, k√∂nnen wir entscheiden, ob Leisten eingef√ºgt werden sollen. </font><font style="vertical-align: inherit;">√Ñndern Sie dies </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so, dass er nur f√ºr die Pisten Leisten erstellt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An dieser Stelle k√∂nnen wir den zuvor auskommentierten Code auskommentieren, damit er Ebenen und Ausschnitte verarbeiten kann. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/bb8/1e6/15abb81e60a35fb6383ff8be8b0a17dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Stufen werden nur an den H√§ngen erstellt. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leisten mit Leisten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eckfugen sind komplexer als Kantenfugen, da sie nicht an zwei, sondern an drei Zellen beteiligt sind. </font><font style="vertical-align: inherit;">Jede Ecke ist mit drei Kanten verbunden, die Ebenen, H√§nge oder Klippen sein k√∂nnen. </font><font style="vertical-align: inherit;">Daher gibt es viele m√∂gliche Konfigurationen. </font><font style="vertical-align: inherit;">Wie bei Rippengelenken f√ºgen wir der </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neuen Methode </font><font style="vertical-align: inherit;">eine </font><font style="vertical-align: inherit;">Triangulation </font><font style="vertical-align: inherit;">hinzu </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unsere neue Methode erfordert die Eckpunkte eines eckigen Dreiecks und verbundener Zellen. </font><font style="vertical-align: inherit;">Ordnen Sie die Verbindungen der Einfachheit halber so an, dass Sie wissen, welche Zelle die kleinste H√∂he hat. </font><font style="vertical-align: inherit;">Danach k√∂nnen wir von links unten und rechts mit der Arbeit beginnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b24/351/681/b243516810fc9f0e8c44a5cb12f74cff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eckverbindung.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss </font><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">feststellen, welche der Zellen die niedrigste ist. </font><font style="vertical-align: inherit;">Zuerst pr√ºfen wir, ob sich die triangulierte Zelle unter ihren Nachbarn befindet oder auf dem gleichen Niveau wie die niedrigste. </font><font style="vertical-align: inherit;">Wenn ja, k√∂nnen wir es als unterste Zelle verwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die tiefste Pr√ºfung fehlschl√§gt, bedeutet dies, dass der n√§chste Nachbar die niedrigste Zelle ist. </font><font style="vertical-align: inherit;">F√ºr die richtige Ausrichtung m√ºssen wir das Dreieck gegen den Uhrzeigersinn drehen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der erste Test fehlschl√§gt, m√ºssen Sie zwei benachbarte Zellen vergleichen. </font><font style="vertical-align: inherit;">Wenn der Nachbar der Rippe der niedrigste ist, m√ºssen Sie sich im Uhrzeigersinn drehen, andernfalls - gegen den Uhrzeigersinn.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v4, neighbor, v5, nextNeighbor, v2, cell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8a/736/794/f8a736794c4e52c54ab018dcd55feba0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drehen Sie gegen den Uhrzeigersinn, keine Drehung, Drehung im Uhrzeigersinn.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hangtriangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu wissen, wie man einen Winkel trianguliert, m√ºssen wir verstehen, mit welchen Arten von Kanten wir es zu tun haben. </font><font style="vertical-align: inherit;">Um diese Aufgabe zu vereinfachen, f√ºgen wir eine </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weitere bequeme Methode zum Erkennen der Steigung zwischen zwei beliebigen Zellen hinzu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell otherCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, otherCell.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwenden diese neue Methode </font></font><code>HexMesh.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Arten der linken und rechten Kante zu bestimmen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beide Rippen Steigungen sind, haben wir links und rechts Leisten. </font><font style="vertical-align: inherit;">Da die untere Zelle die niedrigste ist, wissen wir au√üerdem, dass diese Steigungen ansteigen. </font><font style="vertical-align: inherit;">Dar√ºber hinaus haben die linke und die rechte Zelle die gleiche H√∂he, dh die Verbindung der Oberkante ist flach. </font><font style="vertical-align: inherit;">Wir k√∂nnen diesen Fall als "Hang-Hang-Ebene" oder MTP bezeichnen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b75/4a3/f9e/b754a3f9eccdb6baada2a51fef2c4301.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zwei Pisten und ein Flugzeug, SSP.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden pr√ºfen, ob wir uns in dieser Situation befinden, und wenn ja, werden wir eine neue Methode aufrufen </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach kehren wir von der Methode zur√ºck. </font><font style="vertical-align: inherit;">F√ºgen Sie diese Pr√ºfung vor dem alten Triangulationscode ein, damit er das urspr√ºngliche Dreieck ersetzt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir drinnen nichts tun </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, werden einige Eckknotenpunkte mit zwei H√§ngen zu Hohlr√§umen. </font><font style="vertical-align: inherit;">Ob die Verbindung leer wird oder nicht, h√§ngt davon ab, welche der Zellen niedriger ist.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/a54/2ea/26ba542eaed793e064e478cbdbc5f109.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine Leere. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die L√ºcke zu f√ºllen, m√ºssen wir die linke und rechte Kante durch einen Raum verbinden. </font><font style="vertical-align: inherit;">Der Ansatz hier ist der gleiche wie beim Verbinden von Kanten, jedoch innerhalb eines dreifarbigen Dreiecks anstelle eines zweifarbigen Vierecks. </font><font style="vertical-align: inherit;">Beginnen wir noch einmal mit der ersten Stufe, die jetzt ein Dreieck ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebf/a76/823/ebfa76823e5dba45fd97daa1f052b1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Stufe des Dreiecks. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir gehen wieder direkt zur letzten Etappe. </font><font style="vertical-align: inherit;">Dies ist das Viereck, das ein Trapez bildet. </font><font style="vertical-align: inherit;">Der einzige Unterschied zu den Kantenverbindungen besteht darin, dass es sich nicht um zwei, sondern um vier Farben handelt.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/ab2/20b/99eab220bcbdda36896dbb1640995b33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Stufe des Vierecks. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Stufen zwischen ihnen sind ebenfalls Vierecke.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2, c3, c4); } AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b46/8bb/c69/b468bbc6989ae33c9a810f5e641f2446.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Stufen.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zwei Steigungsvarianten </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Fall mit zwei Steigungen weist zwei Variationen mit unterschiedlichen Ausrichtungen auf, je nachdem, welche der Zellen der Boden ist. </font><font style="vertical-align: inherit;">Wir k√∂nnen sie finden, indem wir die Links-Rechts-Kombinationen auf Steigungsebene und Ebenenneigung √ºberpr√ºfen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b17/736/3ca/b177363ca9391a96905ce2a0717020d9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATP und MSS. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die rechte Kante flach ist, sollten wir links und nicht unten Leisten erstellen. </font><font style="vertical-align: inherit;">Wenn der linke Rand flach ist, m√ºssen Sie rechts beginnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus diesem Grund werden die Leisten ohne Unterbrechung um die Zellen herumgef√ºhrt, bis sie die Klippe oder das Ende der Karte erreichen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/359/68c/4d835968ce882e260a2b4f7ec23979ab.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feste Leisten. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einheitspaket</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschmelzung von H√§ngen und Klippen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist mit der Verbindung von Hang und Klippe? </font><font style="vertical-align: inherit;">Wenn wir wissen, dass der linke Rand ein Hang und der rechte Rand eine Klippe ist, was ist dann der obere Rand? </font><font style="vertical-align: inherit;">Es kann nicht flach sein, aber es kann entweder ein Hang oder eine Klippe sein.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/6bc/0d3/dd96bc0d3fb89e029687c7b9c9312cc5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/07d/d22/04907dd22fc5da80ba59fa2dbb6abb82.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/463/24c/c57/46324cc57e9c3e79a21378c932e09ed9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOS und COO. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen wir eine neue Methode hinzu, um alle F√§lle von Hangklippen zu behandeln.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sollte als letzte Option aufgerufen werden, </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der linke Rand eine Steigung ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie triangulieren wir das? </font><font style="vertical-align: inherit;">Diese Aufgabe kann in zwei Teile unterteilt werden: untere und obere.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unterteil </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der untere Teil hat links Leisten und rechts eine Klippe. </font><font style="vertical-align: inherit;">Wir m√ºssen sie irgendwie kombinieren. </font><font style="vertical-align: inherit;">Der einfachste Weg, dies zu tun, besteht darin, die Leisten so zusammenzudr√ºcken, dass sie sich in der rechten Ecke treffen. </font><font style="vertical-align: inherit;">Dadurch werden die Leisten angehoben.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/8e7/d53/d118e7d538c25cba75a31ca37c6096cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompression von Leisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich m√∂chten wir jedoch nicht, dass sie sich in der rechten Ecke treffen, da dies die oben m√∂glicherweise vorhandenen Leisten beeintr√§chtigt. </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen wir mit einer sehr hohen Klippe umgehen, wodurch wir sehr stark fallende und d√ºnne Dreiecke bekommen. </font><font style="vertical-align: inherit;">Stattdessen werden wir sie auf einen Grenzpunkt komprimieren, der entlang einer Klippe liegt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df5/131/efa/df5131efa8069569630306b4cc8eb9b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompression an der Grenze. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Positionieren wir den Grenzpunkt eine Ebene √ºber der unteren Zelle. </font><font style="vertical-align: inherit;">Sie k√∂nnen es durch Interpolation basierend auf dem H√∂henunterschied finden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um sicherzustellen, dass wir es richtig verstanden haben, bedecken wir den gesamten unteren Teil mit einem Dreieck. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); AddTriangle(begin, left, boundary); AddTriangleColor(beginCell.color, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03e/534/ab9/03e534ab927d5709aca721ccfd9bdc80.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unteres Dreieck. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir den Rand an der richtigen Stelle platziert haben, k√∂nnen wir mit der Triangulation der Leisten fortfahren. </font><font style="vertical-align: inherit;">Beginnen wir erst wieder von der ersten Stufe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c2/4fc/3c1/6c24fc3c19580573b89d3259b855a692.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste Stufe der Komprimierung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Mal wird die letzte Stufe auch ein Dreieck sein.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/6db/5cb/0356db5cbaf4bd936ea4235af34eb1d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Stufe der Komprimierung. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und alle Zwischenschritte sind auch Dreiecke.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/987/744/6e698774450ec3502f52537936d8a29e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komprimierte Leisten.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">K√∂nnen wir die Kante nicht gerade halten?</font></font></b> <div class="spoiler_text"> ,     ,       ,       .         .        ,          .    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eckvervollst√§ndigung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie unten fertig sind, k√∂nnen Sie nach oben gehen. </font><font style="vertical-align: inherit;">Wenn die Oberkante ein Hang ist, m√ºssen wir wieder die Leisten und die Klippe verbinden. </font><font style="vertical-align: inherit;">Verschieben wir diesen Code in eine separate Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt wird es einfach sein, die Spitze zu vervollst√§ndigen. </font><font style="vertical-align: inherit;">Wenn wir eine Neigung haben, f√ºgen Sie das gedrehte Dreieck des Randes hinzu. </font><font style="vertical-align: inherit;">Ansonsten reicht ein einfaches Dreieck.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/ed2/8fb/bc5ed28fbb4a1a1f0015dafac63f5ec0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59c/45b/241/59c45b2413d30e196fc195796e4b07e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndige Triangulation beider Teile.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gespiegelte F√§lle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die F√§lle von ‚ÄûHangklippen‚Äú untersucht. </font><font style="vertical-align: inherit;">Es gibt auch zwei Spiegelgeh√§use, von denen jedes links eine Klippe hat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c00/726/f4f/c00726f4fc6ef078b33782047f4e6b4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS und CCA. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden den vorherigen Ansatz verwenden, mit geringf√ºgigen Unterschieden aufgrund einer √Ñnderung der Ausrichtung. </font><font style="vertical-align: inherit;">Wir kopieren es </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √§ndern es entsprechend.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, left, b); Color boundaryColor = Color.Lerp(beginCell.color, leftCell.color, b); TriangulateBoundaryTriangle( right, rightCell, begin, beginCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie diese F√§lle hinzu </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/a9b/7e6/3d9a9b7e606cefd475ca14f53a48a683.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/495/6f4/3234956f44e8bcbd63d055a9a7f89c36.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trianguliertes OSS und CCA.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Doppelklippen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzigen verbleibenden nichtplanaren F√§lle sind die unteren Zellen mit Klippen auf beiden Seiten. </font><font style="vertical-align: inherit;">In diesem Fall kann die obere Rippe beliebig flach, geneigt oder klippenf√∂rmig sein. </font><font style="vertical-align: inherit;">Wir interessieren uns nur f√ºr den Fall ‚ÄûCliff-Cliff-Slope‚Äú, da er nur Vorspr√ºnge haben wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich gibt es zwei verschiedene Versionen des ‚ÄûCliff-Cliff-Slope‚Äú, je nachdem welche Seite h√∂her ist. </font><font style="vertical-align: inherit;">Sie sind Spiegelbilder voneinander. </font><font style="vertical-align: inherit;">Bezeichnen wir sie als OOSP und OOSL.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/038/df7/b9f038df7a7d23da542430652adbd038.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/0b2/013/3c30b2013db25c9288ad551ec529c07b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/e0d/151/7aee0d1512d324b1bd3c8e91f1b4134d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOSP und OOSL. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen beide F√§lle </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch Aufrufen von Methoden </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit unterschiedlichen Zellrotationen </font><font style="vertical-align: inherit;">abdecken </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erzeugt jedoch eine seltsame Triangulation. </font><font style="vertical-align: inherit;">Dies liegt daran, dass wir jetzt von oben nach unten triangulieren. </font><font style="vertical-align: inherit;">Aus diesem Grund wird unsere Grenze als negativ interpoliert, was falsch ist. </font><font style="vertical-align: inherit;">Die L√∂sung besteht darin, immer positive Interpolatoren zu haben.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/f3d/bf8/ae8f3dbf8d5e2781cff2437d8ce4ad70.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/710/922/0aa/7109220aa668eae0d9904f48d7bd30ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trianguliertes OOSP und OOSL.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fegen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir haben alle F√§lle untersucht, die eine besondere Behandlung erfordern, um die korrekte Triangulation der Leisten sicherzustellen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/280/86f/dc228086f73f694a351ec127e0e75e45.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplette Triangulation mit Leisten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen ein bisschen aufr√§umen, indem </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die Operatoren loswerden </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und stattdessen Bl√∂cke verwenden </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Block </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deckt alle verbleibenden F√§lle ab, die noch nicht behandelt wurden. </font><font style="vertical-align: inherit;">Diese F√§lle sind RFP (Plane-Plane-Plane), OOP, LLC und LLC. </font><font style="vertical-align: inherit;">Alle von ihnen sind von einem Dreieck bedeckt.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/4da/58b/9444da58b33b9558b88fa8bb80102e34.png"></div><br> <i>  .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">unitypackage</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424257/">https://habr.com/ru/post/de424257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424245/index.html">Write Telegram Client - Einfach</a></li>
<li><a href="../de424247/index.html">KotlinConf 2018 Live - Sehen Sie sich die Sendung vom 4. bis 5. Oktober an</a></li>
<li><a href="../de424249/index.html">Materialien vom Treffen #RuPostgres - Videos, Pr√§sentationen, Analyse des Quiz und Fotobericht</a></li>
<li><a href="../de424251/index.html">Wir betrachten Statistiken √ºber Experimente auf hh.ru.</a></li>
<li><a href="../de424255/index.html">So verwenden Sie die statische Analyse richtig</a></li>
<li><a href="../de424259/index.html">Sicherheitswoche 36: Telnet sollte geschlossen sein</a></li>
<li><a href="../de424261/index.html">So l√∂sen Sie Programmierprobleme</a></li>
<li><a href="../de424263/index.html">IDA Pro aktualisieren. Wir beheben Pfosten von Prozessormodulen</a></li>
<li><a href="../de424265/index.html">Bewertung des Elektrofahrrads Twitter Mantis E-1</a></li>
<li><a href="../de424267/index.html">Wie debuggen wir ein selbst geschriebenes ECS in einem Browser auf einem Spieleserver?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>