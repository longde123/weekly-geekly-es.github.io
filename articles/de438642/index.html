<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ℹ️ 🚃 💩 Die Grundlagen der reaktiven Programmierung mit RxJS ✉️ ❎ 🛵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 1. Reaktivität und Flüsse 
 Diese Artikelserie konzentriert sich auf die Reaktivität und ihre Anwendung in JS unter Verwendung einer so wunderbar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen der reaktiven Programmierung mit RxJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438642/"><h3>  Teil 1. Reaktivität und Flüsse </h3><br>  Diese Artikelserie konzentriert sich auf die Reaktivität und ihre Anwendung in JS unter Verwendung einer so wunderbaren Bibliothek wie RxJS. <br><br>  Artikelserie "Grundlagen der reaktiven Programmierung mit RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Bediener und Rohre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Observable höherer Ordnung</a> </li></ul><br><br>  <b>Für wen dieser Artikel ist</b> : Im Grunde werde ich hier die Grundlagen erklären, daher ist der Artikel in erster Linie für Anfänger in dieser Technologie gedacht.  Gleichzeitig hoffe ich, dass erfahrene Entwickler etwas Neues für sich lernen können.  Das Verständnis erfordert Kenntnisse über js (es5 / es6). <br><br>  <b>Motivation</b> : Ich bin RxJS zum ersten Mal begegnet, als ich anfing, mit Angular zu arbeiten.  Damals hatte ich Schwierigkeiten, den Reaktivitätsmechanismus zu verstehen.  Die Tatsache, dass zu Beginn meiner Arbeit die meisten Artikel der alten Version der Bibliothek gewidmet waren, trug zu den Schwierigkeiten bei.  Ich musste viel Dokumentation lesen, verschiedene Handbücher, um zumindest etwas zu verstehen.  Und erst nach einiger Zeit wurde mir klar, wie „alles arrangiert ist“.  Um anderen das Leben zu erleichtern, habe ich beschlossen, alles in die Regale zu stellen. <br><a name="habracut"></a><br><h4>  Was ist Reaktivität? </h4><br>  Es ist schwierig, eine Antwort auf einen scheinbar gebräuchlichen Begriff zu finden.  Kurz gesagt: Reaktivität ist die Fähigkeit, auf Änderungen zu reagieren.  Aber über welche Veränderungen sprechen wir?  Zunächst zu Datenänderungen.  Betrachten Sie ein Beispiel: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 5 -   </span></span></code> </pre> <a name="push"></a><br>  Dieses Beispiel zeigt das bekannte imperative Programmierparadigma.  Im Gegensatz zum imperativen Ansatz baut der reaktive Ansatz auf Push-Change-Propagationsstrategien auf.  Die Push-Strategie impliziert, dass bei Datenänderungen dieselben Änderungen „durchgesetzt“ werden und die von ihnen abhängigen Daten automatisch aktualisiert werden.  So würde sich unser Beispiel verhalten, wenn eine Push-Strategie angewendet würde: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 6 -   sum  </span></span></code> </pre><br>  Dieses Beispiel zeigt einen reaktiven Ansatz.  Es ist erwähnenswert, dass dieses Beispiel nichts mit der Realität zu tun hat. Ich habe es nur gegeben, um den Unterschied in den Ansätzen zu zeigen.  Reaktiver Code in realen Anwendungen sieht ganz anders aus, und bevor wir mit dem Üben fortfahren, sollten wir über eine weitere wichtige Komponente der Reaktivität sprechen. <br><br><h4>  Datenstrom </h4><br>  Wenn Sie sich den Begriff „reaktive Programmierung“ in Wikipedia ansehen, erhalten Sie auf der Website die folgende Definition: „Reaktive Programmierung ist ein Programmierparadigma, das sich auf Datenflüsse und die Verbreitung von Änderungen konzentriert.“  Aus dieser Definition können wir schließen, dass die Reaktivität auf zwei Hauptwalen basiert.  Ich habe oben die Verteilung der Änderungen erwähnt, daher werden wir nicht weiter darauf eingehen.  Wir sollten jedoch mehr über Datenströme sprechen.  Schauen wir uns das folgende Beispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     const eventsArray = []; input.addEventListener('keyup', event =&gt; eventsArray.push(event) ); //      eventsArray</span></span></code> </pre><br>  Wir hören uns das Keyup-Ereignis an und fügen das Ereignisobjekt in unser Array ein.  Im Laufe der Zeit kann unser Array Tausende von KeyboardEvent-Objekten enthalten.  Es ist erwähnenswert, dass unser Array nach Zeit sortiert ist - der Index späterer Ereignisse ist größer als der Index früherer Ereignisse.  Ein solches Array ist ein vereinfachtes Datenflussmodell.  Warum vereinfacht?  Weil das Array nur Daten speichern kann.  Wir können das Array auch iterieren und seine Elemente irgendwie verarbeiten.  Das Array kann uns jedoch nicht mitteilen, dass ein neues Element hinzugefügt wurde.  Um herauszufinden, ob dem Array neue Daten hinzugefügt wurden, müssen wir sie erneut durchlaufen. <br><br>  Aber was wäre, wenn unser Array uns darüber informieren könnte, dass neue Daten darin angekommen sind?  Ein solches Array könnte mit Sicherheit als Stream bezeichnet werden.  Wir kommen also zur Definition des Flusses.  Ein Stream ist ein nach Zeit sortiertes Datenarray, das anzeigen kann, dass sich die Daten geändert haben. <br><br><h4>  Beobachtbar </h4><br>  Nachdem wir nun wissen, was Flüsse sind, arbeiten wir mit ihnen.  In RxJS werden Streams durch die Observable-Klasse dargestellt.  Um einen eigenen Stream zu erstellen, rufen Sie einfach den Konstruktor dieser Klasse auf und übergeben Sie die Abonnementfunktion als Argument: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); })</code> </pre><br>  Durch Aufrufen des Konstruktors der Observable-Klasse erstellen wir einen neuen Thread.  Als Argument haben wir die Abonnementfunktion an den Konstruktor übergeben.  Die Abonnementfunktion ist eine reguläre Funktion, die einen Beobachter als Parameter verwendet.  Der Betrachter selbst ist ein Objekt, das drei Methoden hat: <br><br><ul><li>  next - wirft einen neuen Wert in den Stream </li><li>  error - wirft einen Fehler in den Stream, woraufhin der Stream endet </li><li>  complete - beendet den Thread </li></ul><br>  Also haben wir einen Thread erstellt, der zwei Werte ausgibt und beendet. <br><br><h4>  Abonnement </h4><br>  Wenn wir den vorherigen Code ausführen, passiert nichts.  Wir werden nur einen neuen Stream erstellen und den Link dazu in der beobachtbaren Variablen speichern, aber der Stream selbst wird niemals einen einzigen Wert ausgeben.  Dies liegt daran, dass Threads „faule“ Objekte sind und nichts für sich tun.  Damit unser Stream Werte ausgibt und wir diese Werte verarbeiten können, müssen wir den Stream „abhören“.  Sie können dies tun, indem Sie die subscribe-Methode für das beobachtbare Objekt aufrufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer = { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value), <span class="hljs-comment"><span class="hljs-comment">// 1, 2 error: error =&gt; console.error(error), // complete: () =&gt; console.log("completed") // completed }; observable.subscribe(observer);</span></span></code> </pre><br>  Wir identifizierten unseren Beobachter und beschrieben drei Methoden für ihn: als nächstes Fehler, vollständig.  Methoden protokollieren einfach Daten, die als Parameter übergeben werden.  Dann rufen wir die Subscribe-Methode auf und übergeben unseren Beobachter an sie.  Im Moment des Aufrufs von subscribe wird die Subscription-Funktion aufgerufen, die wir beim Deklarieren unseres Streams an den Konstruktor übergeben haben.  Als nächstes wird der Code der Abonnementfunktion ausgeführt, der zwei Werte an unseren Beobachter übergibt und dann den Stream beendet. <br><br>  Sicherlich haben viele eine Frage, was passiert, wenn wir den Stream erneut abonnieren?  Alles wird gleich sein: Der Stream übergibt wieder zwei Werte an den Beobachter und endet.  Bei jedem Aufruf der Subscribe-Methode wird eine Subscription-Funktion aufgerufen und der gesamte Code erneut ausgeführt.  Daraus können wir schließen: Unabhängig davon, wie oft wir den Stream abonnieren, erhalten unsere Beobachter dieselben Daten. <br><br><h4>  Abbestellen </h4><a name="timer"></a><br>  Versuchen wir nun, ein komplexeres Beispiel zu implementieren.  Wir werden einen Timer schreiben, der Sekunden ab dem Zeitpunkt des Abonnements zählt und diese an Beobachter weiterleitet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  setInterval(() =&gt; { observer.next(counter++); //          }, 1000); }); timer.subscribe({ next: console.log //    });</span></span></code> </pre><br>  Der Code ist recht einfach.  Innerhalb der Abonnementfunktion deklarieren wir eine Zählervariable.  Dann schließen wir mit Closure über die Pfeilfunktion in setInterval auf die Variable.  Und jede Sekunde übergeben wir die Variable an den Beobachter, danach erhöhen wir sie.  Abonnieren Sie als Nächstes den Stream und geben Sie nur eine Methode an - next.  Machen Sie sich keine Sorgen, dass wir keine anderen Methoden angekündigt haben.  Keine der Beobachtermethoden ist erforderlich.  Wir können sogar ein leeres Objekt übergeben, aber in diesem Fall wird der Thread verschwendet. <br><br>  Nach dem Start sehen wir die begehrten Protokolle, die jede Sekunde erscheinen.  Wenn Sie möchten, können Sie den Stream mehrmals experimentieren und abonnieren.  Sie werden sehen, dass jeder der Threads unabhängig von den anderen ausgeführt wird. <br><br>  Wenn Sie darüber nachdenken, wird unser Thread während der gesamten Lebensdauer der gesamten Anwendung ausgeführt, da wir keine Logik zum Abbrechen von setInterval haben und in der Abonnementfunktion die vollständige Methode nicht aufgerufen wird.  Aber was ist, wenn wir den Thread brauchen, um zu enden? <br><br>  In der Tat ist alles sehr einfach.  Wenn Sie sich die Dokumentation ansehen, sehen Sie, dass die Subscribe-Methode ein Subscription-Objekt zurückgibt.  Dieses Objekt verfügt über eine Abmeldemethode.  Wir nennen es und unser Beobachter wird keine Werte mehr vom Stream empfangen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = timer.subscribe({<span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log}); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> subscription.unsubscribe(), <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   5 </span></span></code> </pre><br>  Nach dem Start sehen wir, dass der Zähler bei 4 stoppt. Obwohl wir uns vom Stream abgemeldet haben, funktioniert unsere setInterval-Funktion weiterhin.  Sie erhöht unseren Zähler jede Sekunde und gibt ihn an den Dummy-Beobachter weiter.  Um dies zu verhindern, müssen Sie die Logik zum Abbrechen des Intervalls schreiben.  Dazu müssen Sie eine neue Funktion aus der Abonnementfunktion zurückgeben, in der die Kündigungslogik implementiert wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Jetzt können wir aufatmen.  Nach dem Aufrufen der Methode zum Abbestellen wird unsere Funktion zum Abbestellen aufgerufen, mit der das Intervall gelöscht wird. <br><br><h4>  Fazit </h4><br>  Dieser Artikel zeigt die Unterschiede zwischen imperativen und reaktiven Ansätzen sowie Beispiele für die Erstellung eigener Flows.  Im nächsten Teil werde ich darüber sprechen, welche anderen Methoden zum Erstellen von Threads existieren und wie sie angewendet werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438642/">https://habr.com/ru/post/de438642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438632/index.html">Hardcore 2D RPG Gamedev Diaries, Vol.0 - INTRO oder "How I Got Here"</a></li>
<li><a href="../de438634/index.html">In Büros ist es entweder zu heiß oder zu kalt: Gibt es eine bessere Möglichkeit, die Temperatur anzupassen?</a></li>
<li><a href="../de438636/index.html">Fehlerhafte Einbettung von Funktionen in Go</a></li>
<li><a href="../de438638/index.html">Wir analysieren das Protokoll der Pager-Nachrichten POCSAG, Teil 2</a></li>
<li><a href="../de438640/index.html">Offene elektronische Hochgeschwindigkeitswährung</a></li>
<li><a href="../de438644/index.html">Die Sicherheit von Algorithmen für maschinelles Lernen. Schützen und Testen von Modellen mit Python</a></li>
<li><a href="../de438646/index.html">Informationen zum Erstellen von Budget-Stereobildern auf Fingern (Stereogramm, Anaglyphe, Stereoskop)</a></li>
<li><a href="../de438648/index.html">Vergleich von BI-Systemen (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../de438650/index.html">Rakete 9M729. Ein paar Worte zum „Verstoß“ gegen den INF-Vertrag</a></li>
<li><a href="../de438652/index.html">Portabelization IDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>