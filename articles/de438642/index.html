<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÑπÔ∏è üöÉ üí© Die Grundlagen der reaktiven Programmierung mit RxJS ‚úâÔ∏è ‚ùé üõµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil 1. Reaktivit√§t und Fl√ºsse 
 Diese Artikelserie konzentriert sich auf die Reaktivit√§t und ihre Anwendung in JS unter Verwendung einer so wunderbar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Grundlagen der reaktiven Programmierung mit RxJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438642/"><h3>  Teil 1. Reaktivit√§t und Fl√ºsse </h3><br>  Diese Artikelserie konzentriert sich auf die Reaktivit√§t und ihre Anwendung in JS unter Verwendung einer so wunderbaren Bibliothek wie RxJS. <br><br>  Artikelserie "Grundlagen der reaktiven Programmierung mit RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Bediener und Rohre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3. Observable h√∂herer Ordnung</a> </li></ul><br><br>  <b>F√ºr wen dieser Artikel ist</b> : Im Grunde werde ich hier die Grundlagen erkl√§ren, daher ist der Artikel in erster Linie f√ºr Anf√§nger in dieser Technologie gedacht.  Gleichzeitig hoffe ich, dass erfahrene Entwickler etwas Neues f√ºr sich lernen k√∂nnen.  Das Verst√§ndnis erfordert Kenntnisse √ºber js (es5 / es6). <br><br>  <b>Motivation</b> : Ich bin RxJS zum ersten Mal begegnet, als ich anfing, mit Angular zu arbeiten.  Damals hatte ich Schwierigkeiten, den Reaktivit√§tsmechanismus zu verstehen.  Die Tatsache, dass zu Beginn meiner Arbeit die meisten Artikel der alten Version der Bibliothek gewidmet waren, trug zu den Schwierigkeiten bei.  Ich musste viel Dokumentation lesen, verschiedene Handb√ºcher, um zumindest etwas zu verstehen.  Und erst nach einiger Zeit wurde mir klar, wie ‚Äûalles arrangiert ist‚Äú.  Um anderen das Leben zu erleichtern, habe ich beschlossen, alles in die Regale zu stellen. <br><a name="habracut"></a><br><h4>  Was ist Reaktivit√§t? </h4><br>  Es ist schwierig, eine Antwort auf einen scheinbar gebr√§uchlichen Begriff zu finden.  Kurz gesagt: Reaktivit√§t ist die F√§higkeit, auf √Ñnderungen zu reagieren.  Aber √ºber welche Ver√§nderungen sprechen wir?  Zun√§chst zu Daten√§nderungen.  Betrachten Sie ein Beispiel: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 5 -   </span></span></code> </pre> <a name="push"></a><br>  Dieses Beispiel zeigt das bekannte imperative Programmierparadigma.  Im Gegensatz zum imperativen Ansatz baut der reaktive Ansatz auf Push-Change-Propagationsstrategien auf.  Die Push-Strategie impliziert, dass bei Daten√§nderungen dieselben √Ñnderungen ‚Äûdurchgesetzt‚Äú werden und die von ihnen abh√§ngigen Daten automatisch aktualisiert werden.  So w√ºrde sich unser Beispiel verhalten, wenn eine Push-Strategie angewendet w√ºrde: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 6 -   sum  </span></span></code> </pre><br>  Dieses Beispiel zeigt einen reaktiven Ansatz.  Es ist erw√§hnenswert, dass dieses Beispiel nichts mit der Realit√§t zu tun hat. Ich habe es nur gegeben, um den Unterschied in den Ans√§tzen zu zeigen.  Reaktiver Code in realen Anwendungen sieht ganz anders aus, und bevor wir mit dem √úben fortfahren, sollten wir √ºber eine weitere wichtige Komponente der Reaktivit√§t sprechen. <br><br><h4>  Datenstrom </h4><br>  Wenn Sie sich den Begriff ‚Äûreaktive Programmierung‚Äú in Wikipedia ansehen, erhalten Sie auf der Website die folgende Definition: ‚ÄûReaktive Programmierung ist ein Programmierparadigma, das sich auf Datenfl√ºsse und die Verbreitung von √Ñnderungen konzentriert.‚Äú  Aus dieser Definition k√∂nnen wir schlie√üen, dass die Reaktivit√§t auf zwei Hauptwalen basiert.  Ich habe oben die Verteilung der √Ñnderungen erw√§hnt, daher werden wir nicht weiter darauf eingehen.  Wir sollten jedoch mehr √ºber Datenstr√∂me sprechen.  Schauen wir uns das folgende Beispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     const eventsArray = []; input.addEventListener('keyup', event =&gt; eventsArray.push(event) ); //      eventsArray</span></span></code> </pre><br>  Wir h√∂ren uns das Keyup-Ereignis an und f√ºgen das Ereignisobjekt in unser Array ein.  Im Laufe der Zeit kann unser Array Tausende von KeyboardEvent-Objekten enthalten.  Es ist erw√§hnenswert, dass unser Array nach Zeit sortiert ist - der Index sp√§terer Ereignisse ist gr√∂√üer als der Index fr√ºherer Ereignisse.  Ein solches Array ist ein vereinfachtes Datenflussmodell.  Warum vereinfacht?  Weil das Array nur Daten speichern kann.  Wir k√∂nnen das Array auch iterieren und seine Elemente irgendwie verarbeiten.  Das Array kann uns jedoch nicht mitteilen, dass ein neues Element hinzugef√ºgt wurde.  Um herauszufinden, ob dem Array neue Daten hinzugef√ºgt wurden, m√ºssen wir sie erneut durchlaufen. <br><br>  Aber was w√§re, wenn unser Array uns dar√ºber informieren k√∂nnte, dass neue Daten darin angekommen sind?  Ein solches Array k√∂nnte mit Sicherheit als Stream bezeichnet werden.  Wir kommen also zur Definition des Flusses.  Ein Stream ist ein nach Zeit sortiertes Datenarray, das anzeigen kann, dass sich die Daten ge√§ndert haben. <br><br><h4>  Beobachtbar </h4><br>  Nachdem wir nun wissen, was Fl√ºsse sind, arbeiten wir mit ihnen.  In RxJS werden Streams durch die Observable-Klasse dargestellt.  Um einen eigenen Stream zu erstellen, rufen Sie einfach den Konstruktor dieser Klasse auf und √ºbergeben Sie die Abonnementfunktion als Argument: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); })</code> </pre><br>  Durch Aufrufen des Konstruktors der Observable-Klasse erstellen wir einen neuen Thread.  Als Argument haben wir die Abonnementfunktion an den Konstruktor √ºbergeben.  Die Abonnementfunktion ist eine regul√§re Funktion, die einen Beobachter als Parameter verwendet.  Der Betrachter selbst ist ein Objekt, das drei Methoden hat: <br><br><ul><li>  next - wirft einen neuen Wert in den Stream </li><li>  error - wirft einen Fehler in den Stream, woraufhin der Stream endet </li><li>  complete - beendet den Thread </li></ul><br>  Also haben wir einen Thread erstellt, der zwei Werte ausgibt und beendet. <br><br><h4>  Abonnement </h4><br>  Wenn wir den vorherigen Code ausf√ºhren, passiert nichts.  Wir werden nur einen neuen Stream erstellen und den Link dazu in der beobachtbaren Variablen speichern, aber der Stream selbst wird niemals einen einzigen Wert ausgeben.  Dies liegt daran, dass Threads ‚Äûfaule‚Äú Objekte sind und nichts f√ºr sich tun.  Damit unser Stream Werte ausgibt und wir diese Werte verarbeiten k√∂nnen, m√ºssen wir den Stream ‚Äûabh√∂ren‚Äú.  Sie k√∂nnen dies tun, indem Sie die subscribe-Methode f√ºr das beobachtbare Objekt aufrufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer = { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value), <span class="hljs-comment"><span class="hljs-comment">// 1, 2 error: error =&gt; console.error(error), // complete: () =&gt; console.log("completed") // completed }; observable.subscribe(observer);</span></span></code> </pre><br>  Wir identifizierten unseren Beobachter und beschrieben drei Methoden f√ºr ihn: als n√§chstes Fehler, vollst√§ndig.  Methoden protokollieren einfach Daten, die als Parameter √ºbergeben werden.  Dann rufen wir die Subscribe-Methode auf und √ºbergeben unseren Beobachter an sie.  Im Moment des Aufrufs von subscribe wird die Subscription-Funktion aufgerufen, die wir beim Deklarieren unseres Streams an den Konstruktor √ºbergeben haben.  Als n√§chstes wird der Code der Abonnementfunktion ausgef√ºhrt, der zwei Werte an unseren Beobachter √ºbergibt und dann den Stream beendet. <br><br>  Sicherlich haben viele eine Frage, was passiert, wenn wir den Stream erneut abonnieren?  Alles wird gleich sein: Der Stream √ºbergibt wieder zwei Werte an den Beobachter und endet.  Bei jedem Aufruf der Subscribe-Methode wird eine Subscription-Funktion aufgerufen und der gesamte Code erneut ausgef√ºhrt.  Daraus k√∂nnen wir schlie√üen: Unabh√§ngig davon, wie oft wir den Stream abonnieren, erhalten unsere Beobachter dieselben Daten. <br><br><h4>  Abbestellen </h4><a name="timer"></a><br>  Versuchen wir nun, ein komplexeres Beispiel zu implementieren.  Wir werden einen Timer schreiben, der Sekunden ab dem Zeitpunkt des Abonnements z√§hlt und diese an Beobachter weiterleitet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  setInterval(() =&gt; { observer.next(counter++); //          }, 1000); }); timer.subscribe({ next: console.log //    });</span></span></code> </pre><br>  Der Code ist recht einfach.  Innerhalb der Abonnementfunktion deklarieren wir eine Z√§hlervariable.  Dann schlie√üen wir mit Closure √ºber die Pfeilfunktion in setInterval auf die Variable.  Und jede Sekunde √ºbergeben wir die Variable an den Beobachter, danach erh√∂hen wir sie.  Abonnieren Sie als N√§chstes den Stream und geben Sie nur eine Methode an - next.  Machen Sie sich keine Sorgen, dass wir keine anderen Methoden angek√ºndigt haben.  Keine der Beobachtermethoden ist erforderlich.  Wir k√∂nnen sogar ein leeres Objekt √ºbergeben, aber in diesem Fall wird der Thread verschwendet. <br><br>  Nach dem Start sehen wir die begehrten Protokolle, die jede Sekunde erscheinen.  Wenn Sie m√∂chten, k√∂nnen Sie den Stream mehrmals experimentieren und abonnieren.  Sie werden sehen, dass jeder der Threads unabh√§ngig von den anderen ausgef√ºhrt wird. <br><br>  Wenn Sie dar√ºber nachdenken, wird unser Thread w√§hrend der gesamten Lebensdauer der gesamten Anwendung ausgef√ºhrt, da wir keine Logik zum Abbrechen von setInterval haben und in der Abonnementfunktion die vollst√§ndige Methode nicht aufgerufen wird.  Aber was ist, wenn wir den Thread brauchen, um zu enden? <br><br>  In der Tat ist alles sehr einfach.  Wenn Sie sich die Dokumentation ansehen, sehen Sie, dass die Subscribe-Methode ein Subscription-Objekt zur√ºckgibt.  Dieses Objekt verf√ºgt √ºber eine Abmeldemethode.  Wir nennen es und unser Beobachter wird keine Werte mehr vom Stream empfangen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = timer.subscribe({<span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log}); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> subscription.unsubscribe(), <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   5 </span></span></code> </pre><br>  Nach dem Start sehen wir, dass der Z√§hler bei 4 stoppt. Obwohl wir uns vom Stream abgemeldet haben, funktioniert unsere setInterval-Funktion weiterhin.  Sie erh√∂ht unseren Z√§hler jede Sekunde und gibt ihn an den Dummy-Beobachter weiter.  Um dies zu verhindern, m√ºssen Sie die Logik zum Abbrechen des Intervalls schreiben.  Dazu m√ºssen Sie eine neue Funktion aus der Abonnementfunktion zur√ºckgeben, in der die K√ºndigungslogik implementiert wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Jetzt k√∂nnen wir aufatmen.  Nach dem Aufrufen der Methode zum Abbestellen wird unsere Funktion zum Abbestellen aufgerufen, mit der das Intervall gel√∂scht wird. <br><br><h4>  Fazit </h4><br>  Dieser Artikel zeigt die Unterschiede zwischen imperativen und reaktiven Ans√§tzen sowie Beispiele f√ºr die Erstellung eigener Flows.  Im n√§chsten Teil werde ich dar√ºber sprechen, welche anderen Methoden zum Erstellen von Threads existieren und wie sie angewendet werden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438642/">https://habr.com/ru/post/de438642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438632/index.html">Hardcore 2D RPG Gamedev Diaries, Vol.0 - INTRO oder "How I Got Here"</a></li>
<li><a href="../de438634/index.html">In B√ºros ist es entweder zu hei√ü oder zu kalt: Gibt es eine bessere M√∂glichkeit, die Temperatur anzupassen?</a></li>
<li><a href="../de438636/index.html">Fehlerhafte Einbettung von Funktionen in Go</a></li>
<li><a href="../de438638/index.html">Wir analysieren das Protokoll der Pager-Nachrichten POCSAG, Teil 2</a></li>
<li><a href="../de438640/index.html">Offene elektronische Hochgeschwindigkeitsw√§hrung</a></li>
<li><a href="../de438644/index.html">Die Sicherheit von Algorithmen f√ºr maschinelles Lernen. Sch√ºtzen und Testen von Modellen mit Python</a></li>
<li><a href="../de438646/index.html">Informationen zum Erstellen von Budget-Stereobildern auf Fingern (Stereogramm, Anaglyphe, Stereoskop)</a></li>
<li><a href="../de438648/index.html">Vergleich von BI-Systemen (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../de438650/index.html">Rakete 9M729. Ein paar Worte zum ‚ÄûVersto√ü‚Äú gegen den INF-Vertrag</a></li>
<li><a href="../de438652/index.html">Portabelization IDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>