<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 🔂 🍠 Ketikkan kode Anda akhirnya ↘️ 👎🏿 💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Habr! 


 Suatu hari, saya sekali lagi mendapat kode jenis 


if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken cha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketikkan kode Anda akhirnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462655/"><p>  Hai Habr! </p><br><p>  Suatu hari, saya sekali lagi mendapat kode jenis </p><br><pre><code class="plaintext hljs">if(someParameter.Volatilities.IsEmpty()) { // We have to report about the broken channels, however we could not differ it from just not started cold system. // Therefore write this case into the logs and then in case of emergency IT Ops will able to gather the target line Log.Info("Channel {0} is broken or was not started yet", someParameter.Key) }</code> </pre> <br><p>  Ada satu fitur yang agak penting dalam kode: penerima sangat ingin tahu apa yang sebenarnya terjadi.  Memang, dalam satu kasus kami memiliki masalah dengan sistem, dan dalam kasus lain, kami hanya melakukan pemanasan.  Namun, model tidak memberi kami ini (untuk menyenangkan pengirim, yang sering menjadi penulis model). <br>  Selain itu, bahkan fakta "mungkin ada sesuatu yang salah" berasal dari kenyataan bahwa koleksi <code>Volatilities</code> kosong.  Yang dalam beberapa kasus mungkin benar. </p><br><p>  Saya yakin bahwa sebagian besar pengembang yang berpengalaman dalam kode melihat garis yang berisi pengetahuan rahasia dalam gaya "jika kombinasi flag ini diset, maka kami diminta untuk membuat A, B dan C" (walaupun ini tidak terlihat oleh model itu sendiri). </p><br><p>  Dari sudut pandang saya, penghematan semacam itu pada struktur kelas memiliki dampak yang sangat negatif pada proyek di masa depan, mengubahnya menjadi serangkaian peretasan dan penopang, secara bertahap mengubah kode yang lebih mudah atau kurang nyaman menjadi warisan. </p><br><p>  <strong>Penting:</strong> dalam artikel ini saya memberikan contoh yang berguna untuk proyek di mana beberapa pengembang (dan bukan satu), plus yang akan diperbarui dan diperluas untuk setidaknya 5-10 tahun.  Semua ini tidak masuk akal jika proyek memiliki satu pengembang selama lima tahun, atau jika tidak ada perubahan yang direncanakan setelah rilis.  Dan itu masuk akal, jika proyek hanya diperlukan untuk beberapa bulan, tidak ada gunanya berinvestasi dalam model data yang jelas. </p><br><p>  Namun, jika Anda melakukan permainan lama - selamat datang di kucing. </p><a name="habracut"></a><br><h1 id="ispolzuyte-pattern-visitor">  Gunakan pola pengunjung </h1><br><p>  Seringkali bidang yang sama berisi objek yang dapat memiliki makna semantik yang berbeda (seperti dalam contoh).  Namun, untuk menyelamatkan kelas, pengembang hanya menyisakan satu jenis, menyediakannya dengan bendera (atau komentar dengan gaya "jika tidak ada apa pun di sini, maka tidak ada yang dihitung").  Pendekatan serupa mungkin menutupi kesalahan (yang buruk untuk proyek, tetapi nyaman bagi tim yang memasok layanan, karena bug tidak terlihat dari luar).  Opsi yang lebih benar, yang memungkinkan bahkan di ujung kabel untuk mengetahui apa yang sebenarnya terjadi, adalah menggunakan antarmuka + pengunjung. </p><br><p>  Dalam kasus ini, contoh dari header berubah menjadi kode formulir: </p><br><pre> <code class="plaintext hljs">class Response { public IVolatilityResponse Data { get; } } interface IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) } class VolatilityValues : IVolatilityResponse { public Surface Data; TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } class CalculationIsBroken : IVolatilityResponse { TOutput Visit&lt;TInput, TOutput&gt;(IVolatilityResponseVisitor&lt;TInput, TOutput&gt; visitor, TInput input) =&gt; visitor.Visit(this, input); } interface IVolatilityResponseVisitor&lt;TInput, TOutput&gt; { TOutput Visit(VolatilityValues instance, TInput input); TOutput Visit(CalculationIsBroken instance, TInput input); }</code> </pre> <br><p>  Dengan pemrosesan semacam ini: </p><br><ul><li>  Kami membutuhkan lebih banyak kode.  Sayangnya, jika kita ingin mengekspresikan lebih banyak informasi dalam model, itu harus lebih. </li><li>  Karena pewarisan semacam ini, kami tidak dapat lagi membuat cerita <code>Response</code> ke <code>json</code> / <code>protobuf</code> , karena informasi jenis hilang di sana.  Kami harus membuat wadah khusus yang akan melakukan ini (misalnya, Anda bisa membuat kelas yang berisi bidang terpisah untuk setiap implementasi, tetapi hanya satu yang akan diisi). </li><li>  Memperluas model (yaitu, menambahkan kelas-kelas baru) membutuhkan perluasan <code>IVolatilityResponseVisitor&lt;TInput, TOutput&gt;</code> , yang berarti kompiler akan memaksanya untuk didukung dalam kode.  Programmer tidak akan lupa untuk memproses tipe baru, jika tidak proyek tidak akan dikompilasi. </li><li>  Karena pengetikan statis, kami tidak perlu menyimpan dokumentasi di suatu tempat dengan kemungkinan kombinasi bidang, dll.  Kami menjelaskan semua opsi yang mungkin dalam kode yang dapat dimengerti oleh kompiler dan orang tersebut.  Kami tidak akan memiliki desync antara dokumentasi dan kode, karena kami dapat melakukannya tanpa yang pertama. </li></ul><br><h2 id="pro-ogranichenie-nasledovaniya-v-drugih-yazykah">  Tentang pembatasan warisan dalam bahasa lain </h2><br><p>  Sejumlah bahasa lain (misalnya, <code>Scala</code> atau <code>Kotlin</code> ) memiliki kata kunci yang memungkinkan Anda untuk melarang pewarisan dari jenis tertentu, dalam kondisi tertentu.  Jadi, pada tahap kompilasi, kita tahu semua kemungkinan keturunan tipe kita. </p><br><p>  Secara khusus, contoh di atas dapat ditulis ulang di <code>Kotlin</code> seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: IVolatilityResponse ) <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityResponse</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VolatilityValues</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>: Surface } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CalculationIsBroken</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VolatilityResponse</span></span></span></span>()</code> </pre><br><p>  Ternyata sedikit kurang dari kode, tetapi sekarang dalam proses kompilasi kita tahu bahwa semua kemungkinan <code>VolatilityResponse</code> berada di file yang sama dengan itu, yang berarti bahwa kode berikut tidak akan dikompilasi, karena kami tidak melalui semua nilai yang mungkin dari kelas. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString() }</code> </pre> <br><p>  Namun, perlu diingat bahwa pemeriksaan semacam itu hanya berfungsi untuk panggilan fungsional.  Kode di bawah ini akan dikompilasi tanpa kesalahan: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResponseString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">VolatilityResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> VolatilityValues -&gt; println(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.toString()) } }</code> </pre> <br><h1 id="ne-vse-primitivnye-tipy-oznachayut-odno-i-to-zhe">  Tidak semua tipe primitif memiliki arti yang sama </h1><br><p>  Pertimbangkan pengembangan yang relatif tipikal untuk basis data.  Kemungkinan besar, di suatu tempat dalam kode Anda akan memiliki pengidentifikasi objek.  Sebagai contoh: </p><br><pre> <code class="plaintext hljs">class Group { public int Id { get; } public string Name { get; } } class User { public int Id { get; } public int GroupId { get; } public string Name { get; } }</code> </pre> <br><p>  Sepertinya kode standar.  Jenisnya bahkan cocok dengan yang ada di database.  Namun, pertanyaannya adalah: apakah kode di bawah ini benar? </p><br><pre> <code class="plaintext hljs">public bool IsInGroup(User user, Group group) { return user.Id == group.Id; } public User CreateUser(string name, Group group) { return new User { Id = group.Id, GroupId = group.Id, name = name } }</code> </pre> <br><p>  Jawabannya kemungkinan besar tidak, karena kami membandingkan <code>Id</code> pengguna dan <code>Id</code> grup dalam contoh pertama.  Dan di yang kedua, kita secara keliru menetapkan <code>id</code> dari <code>Group</code> sebagai <code>id</code> dari <code>User</code> . </p><br><p>  Anehnya, ini cukup mudah untuk diperbaiki: dapatkan saja tipe <code>GroupId</code> , <code>UserId</code> , dan sebagainya.  Dengan demikian, pembuatan <code>User</code> tidak akan berfungsi lagi, karena tipe Anda tidak akan bertemu.  Yang sangat keren, karena Anda bisa memberi tahu kompiler tentang model. </p><br><p>  Selain itu, metode dengan parameter yang sama akan bekerja dengan baik untuk Anda, karena sekarang mereka tidak akan diulang: </p><br><pre> <code class="plaintext hljs">public void SetUserGroup(UserId userId, GroupId groupId) { /* some sql code */ }</code> </pre> <br><p>  Namun, mari kita kembali ke contoh perbandingan pengidentifikasi.  Ini sedikit lebih rumit, karena Anda harus mencegah kompiler dari membandingkan yang tak tertandingi selama proses pembangunan. </p><br><p>  Dan Anda dapat melakukan ini sebagai berikut: </p><br><pre> <code class="plaintext hljs">class GroupId { public int Id { get; } public bool Equals(GroupId groupId) =&gt; Id == groupId?.Id; [Obsolete("GroupId can be equal only with GroupId", error: true)] public override bool Equals(object obj) =&gt; Equals(obj as GroupId) public static bool operator==(GroupId id1, GroupId id2) { if(ReferenceEquals(id1, id2)) return true; if(ReferenceEquals(id1, null) || ReferenceEquals(id2, null)) return false; return id1.Id == id2.Id; } [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(object _, GroupId __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") [Obsolete("GroupId can be equal only with GroupId", error: true)] public static bool operator==(GroupId _, object __) =&gt; throw new NotSupportedException("GroupId can be equal only with GroupId") }</code> </pre> <br><p>  Sebagai hasilnya: </p><br><ul><li>  Kami lagi membutuhkan lebih banyak kode.  Sayangnya, jika Anda ingin memberikan lebih banyak informasi kepada kompiler, Anda sering perlu menulis lebih banyak baris. </li><li>  Kami telah membuat tipe baru (kami akan berbicara tentang optimasi di bawah), yang kadang-kadang dapat sedikit menurunkan kinerja. </li><li>  Dalam kode kami: <br><ul><li>  Kami telah melarang untuk membingungkan pengidentifikasi.  Baik kompiler dan pengembang sekarang jelas melihat bahwa tidak mungkin untuk <code>GroupId</code> bidang <code>GroupId</code> ke bidang <code>GroupId</code> </li><li>  Kita dilarang membandingkan yang tak tertandingi.  Saya <code>IEquitable</code> bahwa kode perbandingan tidak sepenuhnya selesai (juga diinginkan untuk mengimplementasikan antarmuka <code>IEquitable</code> , Anda juga harus menerapkan metode <code>GetHashCode</code> ), jadi contohnya tidak hanya perlu disalin ke proyek.  Namun, idenya sendiri jelas: kami secara eksplisit melarang kompiler untuk mengungkapkan ketika jenis yang salah dibandingkan.  Yaitu  alih-alih mengatakan "apakah buah ini sama?"  kompiler sekarang melihat "apakah pir sama dengan apel?". </li></ul></li></ul><br><h2 id="nemnogo-esche-ob-sql-i-ob-ogranicheniyah">  Sedikit lebih banyak tentang sql dan batasan </h2><br><p>  Seringkali dalam aplikasi kami untuk jenis, aturan tambahan diperkenalkan yang mudah diverifikasi.  Dalam kasus terburuk, sejumlah fungsi terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">void SetName(string name) { if(name == null || name.IsEmpty() || !name[0].IsLetter || !name[0].IsCapital || name.Length &gt; MAX_NAME_COLUMN_LENGTH) { throw .... } /**/ }</code> </pre> <br><p>  Artinya, fungsi mengambil jenis input yang cukup luas, dan kemudian menjalankan pemeriksaan.  Ini umumnya tidak terjadi karena: </p><br><ul><li>  Kami tidak menjelaskan kepada programmer dan kompiler apa yang kami inginkan di sini. </li><li>  Dalam fungsi lain yang serupa, Anda harus menyalin cek. </li><li>  Ketika kami menerima <code>string</code> yang akan menunjukkan <code>name</code> , kami tidak langsung jatuh, tetapi untuk beberapa alasan eksekusi lanjutan jatuh pada beberapa instruksi prosesor nanti. </li></ul><br><p>  Perilaku yang benar: </p><br><ul><li>  Buat jenis yang terpisah (dalam kasus kami, tampaknya, <code>Name</code> ). </li><li>  Di dalamnya, lakukan semua validasi dan pemeriksaan yang diperlukan. </li><li>  Bungkus <code>string</code> di <code>Name</code> secepat mungkin untuk mendapatkan kesalahan secepat mungkin. </li></ul><br><p>  Sebagai hasilnya, kita mendapatkan: </p><br><ul><li>  Lebih sedikit kode, karena kami memeriksa cek untuk <code>name</code> di konstruktor. </li><li>  Strategi <em>Gagal Cepat</em> - sekarang, setelah menerima nama yang bermasalah, kita akan langsung jatuh, alih-alih memanggil beberapa metode lagi, tetapi masih jatuh.  Selain itu, alih-alih kesalahan dari database dari tipe tipe tipe terlalu besar, kami segera menemukan bahwa tidak masuk akal untuk mulai memproses nama tersebut. </li><li>  Sudah lebih sulit bagi kita untuk mencampur argumen jika tanda tangan fungsinya adalah: <code>void UpdateData(Name name, Email email, PhoneNumber number)</code> .  Lagi pula, sekarang kita melewati bukan tiga <code>string</code> identik, tetapi tiga entitas yang berbeda. </li></ul><br><h2 id="nemnogo-o-privedenii-tipov">  Sedikit tentang casting </h2><br><p>  Memperkenalkan pengetikan yang cukup ketat, kita juga tidak boleh lupa bahwa saat mentransfer data ke Sql, kita masih perlu mendapatkan pengenal nyata.  Dan dalam hal ini, masuk akal untuk sedikit memperbarui jenis yang membungkus satu <code>string</code> : </p><br><ul><li>  Tambahkan implementasi antarmuka antarmuka bentuk <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code>  <code>interface IValueGet&lt;TValue&gt;{ TValue Wrapped { get; } }</code> .  Dalam hal ini, di lapisan terjemahan di Sql, kita bisa mendapatkan nilainya secara langsung </li><li>  Alih-alih membuat banyak jenis yang kurang lebih identik dalam kode, Anda dapat membuat leluhur abstrak, dan mewarisi sisanya.  Hasilnya adalah kode formulir: </li></ul><br><pre> <code class="plaintext hljs">interface IValueGet&lt;TValue&gt; { TValue Wrapped { get; } } abstract class BaseWrapper : IValueGet&lt;TValue&gt; { protected BaseWrapper(TValue initialValue) { Wrapped = initialValue; } public TValue Wrapped { get; private set; } } sealed class Name : BaseWrapper&lt;string&gt; { public Name(string value) :base(value) { /*no necessary validations*/ } } sealed class UserId : BaseWrapper&lt;int&gt; { public UserId(int id) :base(id) { /*no necessary validations*/ } }</code> </pre> <br><h1 id="proizvoditelnost">  Performa </h1><br><p>  Berbicara tentang membuat sejumlah besar jenis, Anda seringkali dapat memenuhi dua argumen dialektik: </p><br><ul><li>  Semakin banyak tipe, kode sarang dan il, semakin lambat perangkat lunaknya, karena semakin sulit bagi jit untuk mengoptimalkan program.  Oleh karena itu, pengetikan yang ketat semacam ini akan menyebabkan rem serius dalam proyek. </li><li>  Semakin banyak pembungkus, semakin banyak aplikasi memakan memori.  Oleh karena itu, menambahkan pembungkus akan secara serius meningkatkan persyaratan RAM. </li></ul><br><p>  Sebenarnya, kedua argumen sering diberikan tanpa fakta, namun: </p><br><ul><li>  Bahkan, di sebagian besar aplikasi di java yang sama, string (dan byte array) mengambil memori utama.  Artinya, membuat pembungkus umumnya tidak akan terlihat oleh pengguna akhir.  Namun, karena jenis pengetikan ini, kami mendapatkan nilai tambah yang penting: ketika menganalisis dump memori, Anda dapat mengevaluasi kontribusi apa yang dibuat oleh masing-masing tipe Anda terhadap memori.  Bagaimanapun, Anda melihat bukan hanya daftar garis anonim yang tersebar di proyek.  Sebaliknya, kita bisa memahami jenis objek apa yang lebih besar.  Plus, karena fakta bahwa hanya Wrappers yang memiliki string dan objek besar lainnya, lebih mudah bagi Anda untuk memahami kontribusi masing-masing jenis pembungkus tertentu terhadap memori bersama. </li><li>  Argumen tentang optimasi jit sebagian benar, tetapi tidak sepenuhnya lengkap.  Memang, karena pengetikan yang ketat, perangkat lunak Anda mulai menyingkirkan banyak pemeriksaan di pintu masuk ke fungsi.  Semua model Anda diperiksa kecukupannya dalam desainnya.  Dengan demikian, dalam kasus umum, Anda akan memiliki lebih sedikit pemeriksaan (cukup dengan hanya memerlukan jenis yang benar).  Selain itu, karena fakta bahwa cek ditransfer ke konstruktor, dan tidak diolesi oleh kode, menjadi lebih mudah untuk menentukan yang mana dari mereka yang benar-benar membutuhkan waktu. </li><li>  Sayangnya, dalam artikel ini saya tidak dapat memberikan tes kinerja lengkap, yang membandingkan proyek dengan sejumlah besar mikrotipe dan dengan pengembangan klasik, hanya menggunakan <code>int</code> , <code>string</code> , dan tipe primitif lainnya.  Alasan utama adalah bahwa untuk ini, Anda harus terlebih dahulu membuat proyek tebal yang khas untuk pengujian, dan kemudian membenarkan bahwa proyek khusus ini adalah yang khas.  Dan dengan poin kedua, semuanya rumit, karena dalam kehidupan nyata proyeknya sangat berbeda.  Namun, akan agak aneh untuk melakukan tes sintetis, karena, seperti yang sudah saya katakan, pembuatan objek mikrotipe di aplikasi Enterprise, menurut pengukuran saya, selalu mengambil sumber daya yang dapat diabaikan (pada tingkat kesalahan pengukuran). </li></ul><br><h2 id="kak-mozhno-optimizirovat-kod-sostoyaschiy-iz-bolshogo-chisla-podobnyh-mikrotipov">  Bagaimana Anda dapat mengoptimalkan kode yang terdiri dari sejumlah besar mikrotipe tersebut. </h2><br><p>  <strong>Penting: Anda</strong> harus berurusan dengan optimasi seperti itu hanya ketika Anda menerima fakta yang dijamin bahwa itu adalah mikrotipe yang memperlambat aplikasi.  Dalam pengalaman saya, situasi seperti itu agak tidak mungkin.  Dengan probabilitas yang lebih tinggi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">logger yang sama akan memperlambat</a> Anda, karena setiap operasi sedang menunggu flush ke disk (semuanya dapat diterima pada komputer pengembang dengan M.2 SSD, tetapi pengguna dengan HDD lama melihat hasil yang sama sekali berbeda). </p><br><p>  Namun, triknya sendiri: </p><br><ul><li>  Gunakan tipe yang bermakna alih-alih yang referensi.  Ini dapat berguna jika Wrapper juga bekerja dengan tipe yang signifikan, yang berarti bahwa secara teori Anda dapat meneruskan semua informasi yang diperlukan melalui tumpukan.  Meskipun harus diingat bahwa akselerasi hanya akan terjadi jika kode Anda benar-benar sering menderita GC justru karena mikrotipe. <br><ul><li>  <code>struct</code> di .Net dapat menyebabkan tinju / unboxing yang sering.  Dan pada saat yang sama, struktur seperti itu mungkin memerlukan lebih banyak memori dalam koleksi <code>Dictionary</code> / <code>Map</code> (karena array dialokasikan dengan margin di dalamnya). </li><li>  tipe <code>inline</code> dari Kotlin / Scala memiliki penerapan terbatas.  Misalnya, Anda tidak bisa menyimpan beberapa bidang di dalamnya (yang terkadang dapat berguna untuk menyimpan nilai <code>ToString</code> / <code>GetHashCode</code> ). </li><li>  Sejumlah pengoptimal dapat mengalokasikan memori pada stack.  Secara khusus, .Net <a href="">melakukan ini untuk objek sementara kecil</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GraalVM di Jawa dapat</a> mengalokasikan objek pada stack, tetapi kemudian menyalinnya ke heap jika harus dikembalikan (cocok untuk kode yang kaya dalam kondisi). </li></ul></li><li>  Gunakan objek interniran (yaitu, coba ambil objek yang sudah jadi, yang dibuat sebelumnya). <br><ul><li>  Jika konstruktor memiliki satu argumen, maka Anda bisa membuat cache di mana kuncinya adalah argumen ini, dan nilainya adalah objek yang dibuat sebelumnya.  Dengan demikian, jika variasi objek cukup kecil, Anda bisa menggunakan kembali yang sudah jadi. </li><li>  Jika suatu objek memiliki beberapa argumen, maka Anda cukup membuat objek baru, dan kemudian memeriksa untuk melihat apakah ada dalam cache.  Jika ada yang serupa, maka lebih baik mengembalikan yang sudah dibuat. </li><li>  Skema seperti itu memperlambat kerja para desainer, karena <code>Equals</code> / <code>GetHashCode</code> harus dilakukan untuk semua argumen.  Namun, ini juga mempercepat perbandingan objek di masa mendatang, jika Anda menyimpan nilai hash, karena dalam kasus ini, jika mereka berbeda, maka objeknya berbeda.  Dan benda-benda identik seringkali memiliki satu tautan. </li><li>  Namun, optimasi ini akan mempercepat program, karena <code>GetHashCode</code> / <code>Equals</code> lebih cepat (lihat paragraf di atas).  Plus, masa hidup objek baru (yang, bagaimanapun, dalam cache) akan turun secara dramatis, sehingga mereka hanya akan masuk ke Generasi 0. </li></ul></li><li>  Saat membuat objek baru, periksa parameter input, dan jangan sesuaikan.  Terlepas dari kenyataan bahwa saran ini sering masuk dalam paragraf tentang gaya pengkodean, pada kenyataannya, ini memungkinkan Anda untuk meningkatkan efektivitas program.  Misalnya, jika objek Anda memerlukan string dengan hanya SURAT BESAR, maka dua pendekatan yang sering digunakan untuk memeriksa: membuat <code>ToUpperInvariant</code> dari argumen, atau periksa dalam satu lingkaran bahwa semua huruf besar.  Dalam kasus pertama, baris baru dijamin akan dibuat, dalam kasus kedua, iterator maksimum dibuat.  Akibatnya, Anda menghemat memori (namun, dalam kedua kasus, setiap karakter masih akan diperiksa, sehingga kinerja hanya akan meningkat dalam konteks pengumpulan sampah yang lebih jarang). </li></ul><br><h1 id="vyvod">  Kesimpulan </h1><br><p>  Sekali lagi, saya akan mengulangi poin penting dari judul: semua hal yang dijelaskan dalam artikel masuk akal dalam proyek-proyek besar yang telah dikembangkan dan digunakan selama bertahun-tahun.  Di tempat-tempat yang berarti mengurangi biaya dukungan dan mengurangi biaya penambahan fungsi baru.  Dalam kasus lain, sering kali paling masuk akal untuk membuat produk secepat mungkin tanpa repot dengan tes, model, dan "kode yang baik". </p><br><p>  Namun, untuk proyek jangka panjang, masuk akal untuk menggunakan pengetikan yang paling ketat, di mana dalam model ini kita dapat secara ketat menggambarkan nilai apa yang mungkin pada prinsipnya. </p><br><p>  Jika layanan Anda terkadang dapat mengembalikan hasil yang tidak berfungsi, maka ungkapkan dalam model dan perlihatkan secara eksplisit kepada pengembang.  Jangan menambahkan ribuan bendera dengan deskripsi dalam dokumentasi. </p><br><p>  Jika tipe Anda bisa sama dalam program, tetapi intinya berbeda dalam bisnis, maka definisikan sama persis.  Jangan mencampurnya, bahkan jika jenis bidangnya sama. </p><br><p>  Jika Anda memiliki pertanyaan tentang produktivitas, terapkan metode ilmiah dan ikuti tes (atau lebih baik, minta orang independen untuk memeriksa semua ini).  Dalam skenario ini, Anda benar-benar akan mempercepat program, dan tidak hanya membuang waktu tim.  Namun, yang sebaliknya juga benar: jika ada kecurigaan bahwa program atau pustaka Anda lambat, maka lakukan tes.  Tidak perlu mengatakan bahwa semuanya baik-baik saja, cukup tunjukkan dalam jumlah. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462655/">https://habr.com/ru/post/id462655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462635/index.html">Quantum, atau di sana dan di belakang: algoritma baru untuk mempelajari transisi kuantum-klasik</a></li>
<li><a href="../id462641/index.html">52 Karakteristik Manajer Produk Ideal</a></li>
<li><a href="../id462643/index.html">Tentukan individu yang saling tergantung pada struktur papan menggunakan python</a></li>
<li><a href="../id462649/index.html"># 18 Mosdroid Argon - laporkan</a></li>
<li><a href="../id462653/index.html">LTE sebagai simbol kemerdekaan</a></li>
<li><a href="../id462657/index.html">Ulasan & Tes Pengisi Daya SkyRC B6 Nano</a></li>
<li><a href="../id462659/index.html">Memulai dengan Analisis Statis PVS-Studio untuk Pengembangan C ++ di Linux</a></li>
<li><a href="../id462661/index.html">Berkenalan dengan analisa statis PVS-Studio saat mengembangkan program C ++ di Linux</a></li>
<li><a href="../id462663/index.html">Berenang, menari (!) Dan goyang: kegiatan apa yang benar-benar diinginkan</a></li>
<li><a href="../id462665/index.html">Keamanan Helm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>