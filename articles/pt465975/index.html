<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öñÔ∏è üôçüèæ ü§πüèª Guia SQL: Como escrever consultas melhor (parte 2) ü§¥üèº üõ•Ô∏è ü§Ø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artigo continuado Guia SQL: Como escrever consultas melhor (parte 1) 

 Da solicita√ß√£o aos planos de execu√ß√£o 
 Saber que os antipatterns n√£o s√£o est√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Guia SQL: Como escrever consultas melhor (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/">  Artigo continuado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia SQL: Como escrever consultas melhor (parte 1)</a> <br><br><h2>  Da solicita√ß√£o aos planos de execu√ß√£o </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg">  Saber que os antipatterns n√£o s√£o est√°ticos e evoluem √† medida que voc√™ cresce como desenvolvedor de SQL, e o fato de haver muitas coisas a considerar ao pensar em alternativas tamb√©m significa que evitar antipatterns e reescrever consultas pode ser bastante dif√≠cil tarefa.  Qualquer ajuda pode ser √∫til, e √© por isso que uma abordagem mais estruturada para a otimiza√ß√£o de consultas usando algumas ferramentas pode ser mais eficaz. <br><br>  Tamb√©m deve ser observado que alguns dos antipadr√µes mencionados na √∫ltima se√ß√£o est√£o enraizados em problemas de desempenho, como os operadores <code>AND</code> , <code>OR</code> e <code>NOT</code> e sua aus√™ncia ao usar √≠ndices.  Pensar no desempenho requer n√£o apenas uma abordagem mais estruturada, mas tamb√©m uma abordagem mais profunda. <br><br>  No entanto, essa abordagem estruturada e aprofundada ser√° baseada principalmente no plano de consulta, que, como voc√™ se lembra, √© o resultado de uma consulta analisada primeiro em uma "√°rvore de an√°lise" ou "√°rvore de an√°lise" e determina exatamente qual algoritmo usado para cada opera√ß√£o e como sua execu√ß√£o √© coordenada. <br><a name="habracut"></a><br><h2>  Otimiza√ß√£o de consulta </h2><br>  Conforme voc√™ l√™ a introdu√ß√£o, pode ser necess√°rio verificar e configurar os planos que s√£o compilados manualmente pelo otimizador.  Nesses casos, voc√™ precisar√° analisar sua solicita√ß√£o novamente, observando o plano de solicita√ß√£o. <br><br>  Para acessar esse plano, voc√™ deve usar as ferramentas fornecidas pelo sistema de gerenciamento de banco de dados.  As seguintes ferramentas podem estar √† sua disposi√ß√£o: <br><br><ul><li>  Alguns pacotes cont√™m ferramentas que geram uma representa√ß√£o gr√°fica do plano de consulta.  Considere o seguinte exemplo: <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li>  Outras ferramentas fornecer√£o uma descri√ß√£o textual do plano de consulta.  Um exemplo √© a instru√ß√£o <code>EXPLAIN PLAN</code> no Oracle, mas o nome da instru√ß√£o depende do DBMS com o qual voc√™ est√° trabalhando.  Em outros lugares, voc√™ pode encontrar <code>EXPLAIN</code> (MySQL, PostgreSQL) ou <code>EXPLAIN QUERY PLAN</code> (SQLite). </li></ul><br>  <b>Observe</b> que, ao trabalhar com o PostgreSQL, voc√™ pode fazer uma distin√ß√£o entre <code>EXPLAIN</code> , onde voc√™ simplesmente obt√©m uma descri√ß√£o que informa como o planejador pretende executar a consulta sem execut√°-la, enquanto <code>EXPLAIN ANALYZE</code> realmente executa a consulta e retorna a an√°lise. planos de solicita√ß√£o esperados e reais.  De um modo geral, um plano de execu√ß√£o real √© um plano no qual uma solicita√ß√£o √© realmente executada, enquanto um plano de execu√ß√£o de avalia√ß√£o determina o que ele far√° sem atender √† solicita√ß√£o.  Embora isso seja logicamente equivalente, o plano de execu√ß√£o real √© muito mais √∫til, pois cont√©m informa√ß√µes e estat√≠sticas adicionais sobre o que realmente aconteceu quando a solicita√ß√£o foi executada. <br><br>  No restante desta se√ß√£o, voc√™ aprender√° mais sobre <code>EXPLAIN</code> e <code>ANALYZE</code> , al√©m de como us√°-los para obter mais informa√ß√µes sobre o plano de consulta e seu poss√≠vel desempenho.  Para fazer isso, comece com alguns exemplos nos quais voc√™ trabalhar√° com duas tabelas: <code>one_million</code> e <code>half_million</code> . <br><br>  Voc√™ pode obter as informa√ß√µes atuais da tabela <code>one_million</code> usando <code>EXPLAIN</code> ;  Coloque-o diretamente acima da solicita√ß√£o e, ap√≥s execut√°-la, ele retornar√° o plano de consulta para voc√™: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br>  Nesse caso, voc√™ v√™ que o custo da solicita√ß√£o √© <code>0.00..18584.82</code> e o n√∫mero de linhas √© <code>1025082</code> .  A largura do n√∫mero de colunas √© <code>36</code> . <br><br>  Al√©m disso, voc√™ pode atualizar as estat√≠sticas usando <code>ANALYZE</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br>  Al√©m de <code>EXPLAIN</code> e <code>ANALYZE</code> , voc√™ tamb√©m pode obter o tempo de execu√ß√£o real com <code>EXPLAIN ANALYZE</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br>  A desvantagem de usar <code>EXPLAIN ANALYZE</code> √© que a consulta √© realmente executada, portanto, tenha cuidado com isso! <br><br>  At√© o momento, todos os algoritmos que voc√™ viu s√£o <code>Seq Scan</code> (Sequential Scan) ou Full Table Scan: essa √© uma varredura realizada em um banco de dados em que cada linha da tabela varrida √© lida em ordem serial e as colunas encontradas s√£o verificadas quanto a conformidade com a condi√ß√£o ou n√£o.  Em termos de desempenho, as verifica√ß√µes sequenciais definitivamente n√£o s√£o o melhor plano de execu√ß√£o, porque voc√™ ainda est√° fazendo uma verifica√ß√£o completa da tabela.  No entanto, isso n√£o √© t√£o ruim quando a tabela n√£o cabe na mem√≥ria: as leituras sequenciais s√£o bem r√°pidas, mesmo em discos lentos. <br><br>  Voc√™ aprender√° mais sobre isso mais tarde, quando falarmos sobre verifica√ß√£o de √≠ndice. <br><br>  No entanto, existem outros algoritmos.  Tome, por exemplo, este plano de consulta para uma conex√£o: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br>  Voc√™ v√™ que o otimizador de consultas escolheu <code>Hash Join</code> aqui!  Lembre-se desta opera√ß√£o, pois voc√™ precisar√° dela para avaliar a complexidade de tempo de sua solicita√ß√£o.  Por enquanto, observe que n√£o h√° √≠ndice em <code>half_million.counter</code> , que adicionamos no seguinte exemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br>  Voc√™ percebe que, ao criar o √≠ndice, o otimizador de consulta decidiu agora usar a <code>Merge join</code> ao varrer o <code>Index Scan</code> √çndice. <br><br>  <b>Observe</b> a diferen√ßa entre as verifica√ß√µes de √≠ndice e as de tabela completa ou verifica√ß√µes seq√ºenciais: a primeira, tamb√©m chamada de ‚Äúverifica√ß√µes de tabela‚Äù, verifica os dados ou as p√°ginas de √≠ndice para encontrar os registros correspondentes, enquanto a segunda verifica cada linha da tabela. <br><br>  Voc√™ v√™ que o tempo de execu√ß√£o geral diminuiu e o desempenho deve ser melhor, mas h√° duas varreduras de √≠ndice, o que torna a mem√≥ria mais importante aqui, especialmente se a tabela n√£o se encaixar nela.  Nesses casos, voc√™ deve primeiro executar uma varredura completa do √≠ndice, que √© realizada usando leituras sequenciais r√°pidas e n√£o √© um problema, mas voc√™ tem muitas opera√ß√µes de leitura aleat√≥ria para selecionar linhas pelo valor do √≠ndice.  Essas s√£o opera√ß√µes de leitura aleat√≥ria que geralmente s√£o v√°rias ordens de magnitude mais lentas que as seq√ºenciais.  Nesses casos, uma verifica√ß√£o completa da tabela realmente acontece mais rapidamente que uma verifica√ß√£o completa do √≠ndice. <br><br>  <b>Dica:</b> se voc√™ quiser saber mais sobre EXPLAIN ou considerar exemplos com mais detalhes, leia a se√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compreendendo o Explique de</a> Guillaume Lelarge. <br><br><h2>  Complexidade de tempo e Big O </h2><br>  Agora que voc√™ analisou brevemente o plano de consulta, pode come√ßar a se aprofundar e pensar em desempenho em termos mais formais usando a teoria da complexidade computacional.  Este √© um campo da ci√™ncia da computa√ß√£o te√≥rica, que, entre outras coisas, se concentra na classifica√ß√£o de problemas computacionais, dependendo de sua complexidade;  Esses problemas computacionais podem ser algoritmos, mas tamb√©m consultas. <br><br>  No entanto, para consultas, elas n√£o s√£o necessariamente classificadas de acordo com sua complexidade, mas, dependendo do tempo necess√°rio para conclu√≠-las e obter resultados.  Isso √© chamado de complexidade de tempo e voc√™ pode usar a grande nota√ß√£o O para formular ou medir esse tipo de complexidade. <br><br>  Com a designa√ß√£o O grande, voc√™ expressa o tempo de execu√ß√£o em termos da rapidez com que cresce em rela√ß√£o √† entrada, √† medida que a entrada se torna arbitrariamente grande.  A nota√ß√£o O grande exclui coeficientes e membros de ordem inferior, para que voc√™ possa se concentrar na parte importante do tempo de execu√ß√£o da sua consulta: sua taxa de crescimento.  Quando expressos dessa maneira, descartando os coeficientes e os termos de ordem inferior, eles dizem que a complexidade do tempo √© descrita assintoticamente.  Isso significa que o tamanho da entrada vai para o infinito. <br><br>  Em uma linguagem de banco de dados, a complexidade determina quanto tempo leva para concluir uma consulta conforme o tamanho das tabelas de dados e, portanto, o banco de dados aumenta. <br><br>  <b>Observe</b> que o tamanho do seu banco de dados aumenta n√£o apenas com o aumento da quantidade de dados nas tabelas, mas o fato de que existem √≠ndices tamb√©m desempenham um papel importante no tamanho. <br><br>  Estimando a complexidade de tempo do seu plano de consulta <br><br>  Como voc√™ viu anteriormente, o plano de execu√ß√£o, entre outras coisas, determina qual algoritmo √© usado para cada opera√ß√£o, o que permite expressar logicamente cada tempo de execu√ß√£o da consulta como uma fun√ß√£o do tamanho da tabela inclu√≠da no plano de consulta, que √© chamada de fun√ß√£o de complexidade.  Em outras palavras, voc√™ pode usar a grande nota√ß√£o O e o plano de execu√ß√£o para avaliar a complexidade e o desempenho da consulta. <br><br>  Nas se√ß√µes a seguir, voc√™ ter√° uma vis√£o geral dos quatro tipos de complexidade de tempo e ver√° alguns exemplos de como a complexidade de tempo das consultas pode variar, dependendo do contexto em que √© executada. <br><br>  Dica: os √≠ndices fazem parte dessa hist√≥ria! <br><br>  <b>No entanto, deve-se observar</b> que existem diferentes tipos de √≠ndices, diferentes planos de execu√ß√£o e diferentes implementa√ß√µes para diferentes bancos de dados; portanto, as dificuldades tempor√°rias listadas abaixo s√£o muito gerais e podem variar dependendo de configura√ß√µes espec√≠ficas. <br><br><h3>  O (1): Tempo constante </h3><br>  Eles dizem que um algoritmo funciona em tempo constante se precisar da mesma quantidade de tempo, independentemente do tamanho dos dados de entrada.  Quando se trata de uma consulta, ela ser√° executada em tempo constante se a mesma quantidade de tempo for necess√°ria, independentemente do tamanho da tabela. <br><br>  Esse tipo de consulta n√£o √© realmente comum, mas aqui est√° um exemplo: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br>  A complexidade do tempo √© constante, pois uma linha arbitr√°ria √© selecionada na tabela.  Portanto, o per√≠odo de tempo n√£o deve depender do tamanho da tabela. <br><br><h3>  Tempo Linear: O (n) </h3><br>  Eles dizem que o algoritmo funciona em tempo linear, se o tempo de execu√ß√£o for diretamente proporcional ao tamanho dos dados de entrada, ou seja, o tempo aumenta linearmente com o tamanho dos dados de entrada.  Para bancos de dados, isso significa que o tempo de execu√ß√£o ser√° diretamente proporcional ao tamanho da tabela: √† medida que o n√∫mero de linhas na tabela aumenta, o tempo de execu√ß√£o da consulta aumenta. <br><br>  Um exemplo √© uma consulta com uma <code>WHERE</code> para uma coluna n√£o indexada: ser√° necess√°ria uma varredura de tabela completa ou <code>Seq Scan</code> , o que levar√° √† complexidade do tempo O (n).  Isso significa que cada linha deve ser lida para encontrar a linha com o identificador (ID) desejado.  Voc√™ n√£o possui nenhuma restri√ß√£o, portanto, √© necess√°rio contar todas as linhas, mesmo que a primeira linha corresponda √† condi√ß√£o. <br><br>  Considere tamb√©m o exemplo de consulta a seguir, que ter√° complexidade O (n) se n√£o houver √≠ndice no campo <code>i_id</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li>  O precedente tamb√©m significa que outras consultas, como consultas para calcular o n√∫mero de linhas <code>COUNT (*) FROM TABLE;</code>  ter√° complexidade de tempo <i>O (n)</i> , pois ser√° necess√°ria uma verifica√ß√£o completa da tabela porque o n√∫mero total de linhas n√£o foi salvo para a tabela.  Caso contr√°rio, a complexidade do tempo seria semelhante a <i>O (1)</i> . <br></li></ul><br>  O tempo de execu√ß√£o linear est√° intimamente relacionado ao tempo de execu√ß√£o dos planos que possuem jun√ß√µes de tabela.  Aqui est√£o alguns exemplos: <br><br><ul><li>  A jun√ß√£o de hash tem a complexidade esperada de O (M + N) .O algoritmo cl√°ssico de jun√ß√£o de hash para unir internamente duas tabelas primeiro prepara a tabela de hash da tabela menor.  As entradas da tabela de hash consistem em um atributo de conex√£o e sua sequ√™ncia.  A tabela de hash √© acessada aplicando a fun√ß√£o hash ao atributo de conex√£o.  Depois que a tabela de hash √© criada, uma tabela grande √© varrida e as linhas correspondentes da tabela menor s√£o encontradas pesquisando a tabela de hash. </li><li>  As jun√ß√µes de mesclagem geralmente t√™m complexidade O (M + N), mas isso depende muito dos √≠ndices da coluna de jun√ß√£o e, se n√£o houver √≠ndice, se as linhas s√£o classificadas de acordo com as chaves usadas na jun√ß√£o: <ul><li>  Se as duas tabelas forem classificadas de acordo com as chaves usadas na jun√ß√£o, a consulta ter√° uma complexidade de tempo de O (M + N). </li><li>  Se ambas as tabelas tiverem um √≠ndice para colunas unidas, o √≠ndice j√° suportar√° essas colunas na ordem e a classifica√ß√£o n√£o ser√° necess√°ria.  A dificuldade ser√° O (M + N). </li><li>  Se nenhuma das tabelas tiver um √≠ndice nas colunas conectadas, voc√™ deve primeiro classificar as duas tabelas, para que a complexidade pare√ßa O (M log M + N log N). </li><li>  Se apenas uma das tabelas tiver um √≠ndice nas colunas conectadas, somente a tabela que n√£o possui um √≠ndice dever√° ser classificada antes que a etapa de jun√ß√£o ocorra, para que a complexidade se pare√ßa com O (M + N log N). </li></ul></li><li>  Para jun√ß√µes aninhadas, a complexidade √© geralmente O (MN).  Essa associa√ß√£o √© efetiva quando uma ou ambas as tabelas s√£o extremamente pequenas (por exemplo, menos de 10 registros), o que √© uma situa√ß√£o muito comum na avalia√ß√£o de consultas, pois algumas subconsultas s√£o gravadas para retornar apenas uma linha. </li></ul><br>  <b>Lembre-se: uma</b> jun√ß√£o aninhada √© uma jun√ß√£o que compara cada registro em uma tabela com cada registro em outra. <br><br><h3>  Tempo logar√≠tmico: O (log (n)) </h3><br>  Diz-se que um algoritmo funciona em tempo logar√≠tmico se o tempo de execu√ß√£o for proporcional ao logaritmo do tamanho da entrada;  Para consultas, isso significa que elas ser√£o executadas se o tempo de execu√ß√£o for proporcional ao logaritmo do tamanho do banco de dados. <br><br>  Essa complexidade de tempo logar√≠tmica √© v√°lida para planos de consulta em que uma <code>Index Scan</code> ou um √≠ndice em cluster √© verificado.  Um √≠ndice clusterizado √© um √≠ndice em que o n√≠vel final do √≠ndice cont√©m as linhas reais da tabela.  Um √≠ndice em cluster √© semelhante a qualquer outro √≠ndice: √© definido em uma ou mais colunas.  Eles formam uma chave de √≠ndice.  A chave de cluster √© a coluna de chaves de um √≠ndice em cluster.  A varredura de um √≠ndice em cluster √© basicamente a opera√ß√£o de ler seu DBMS para uma linha ou linhas de cima para baixo em um √≠ndice em cluster. <br><br>  Considere o seguinte exemplo de consulta, em que h√° um √≠ndice para <code>i_id</code> e que geralmente resulta em complexidade de O (log (n)): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br>  Observe que sem um √≠ndice, a complexidade do tempo seria O (n). <br><br><h3>  Tempo quadr√°tico: O (n ^ 2) </h3><br>  Acredita-se que o algoritmo seja executado em tempo quadr√°tico, se o tempo de execu√ß√£o for proporcional ao quadrado do tamanho da entrada.  Novamente, para bancos de dados, isso significa que o tempo de execu√ß√£o da consulta √© proporcional ao quadrado do tamanho do banco de dados. <br><br>  Um poss√≠vel exemplo de uma consulta quadr√°tica de complexidade de tempo √© o seguinte: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br>  A complexidade m√≠nima pode ser O (n log (n)), mas a complexidade m√°xima pode ser O (n ^ 2) com base nas informa√ß√µes de √≠ndice dos atributos de conex√£o. <br><br>  Para resumir, voc√™ tamb√©m pode dar uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na seguinte folha de dicas</a> para avaliar o desempenho da consulta com base na complexidade do tempo e na efic√°cia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  Ajuste de SQL </h2><br>  Dado o plano de execu√ß√£o da consulta e a complexidade do tempo, voc√™ pode personalizar ainda mais sua consulta SQL.  Voc√™ pode come√ßar concentrando-se nos seguintes pontos: <br><br><ul><li>  Substitua varreduras completas desnecess√°rias de tabela por varreduras de √≠ndice; </li><li>  Certifique-se de que a ordem de jun√ß√£o ideal seja aplicada. </li><li>  Verifique se os √≠ndices s√£o usados ‚Äã‚Äãda melhor maneira.  E </li><li>  Armazenamento em cache de verifica√ß√µes de texto completo de tabelas pequenas (verifica√ß√µes de tabela completa de tabela pequena em cache.) √â usado. </li></ul><br><h2>  Uso adicional do SQL </h2><br>  Parab√©ns!  Voc√™ chegou ao final deste artigo, que apenas deu uma pequena olhada no desempenho das consultas SQL.  Espero que voc√™ tenha mais informa√ß√µes sobre antipadr√µes, o otimizador de consulta e as ferramentas que voc√™ pode usar para analisar, avaliar e interpretar a complexidade do seu plano de consulta.  No entanto, voc√™ ainda tem muito a descobrir!  Se voc√™ quiser saber mais, leia o livro ‚ÄúDatabase Management Systems‚Äù de R. Ramakrishnan e J. Gehrke. <br><br>  Por fim, n√£o quero negar o StackOverflow de voc√™ nesta cita√ß√£o: <br><blockquote>  Meu antipadr√£o favorito n√£o verifica seus pedidos. <br><br>  No entanto, √© aplic√°vel quando: <br><br><ul><li>  Sua consulta fornece mais de uma tabela. </li><li>  Voc√™ acha que possui o design ideal para a solicita√ß√£o, mas n√£o tenta verificar suas suposi√ß√µes. </li><li>  Voc√™ aceita a primeira solicita√ß√£o de trabalho, sem saber o qu√£o perto est√° do ideal. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465975/">https://habr.com/ru/post/pt465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465959/index.html">√Årvore geneal√≥gica dentro de git</a></li>
<li><a href="../pt465961/index.html">Aprenda Internet Marketing por conta pr√≥pria: mais de 50 cursos gratuitos</a></li>
<li><a href="../pt465963/index.html">Biografia de sal√°rios na Alemanha 2019</a></li>
<li><a href="../pt465969/index.html">A corre√ß√£o pol√≠tica penetra na R√∫ssia atrav√©s de livros sobre como projetar chips no SystemVerilog para n√£o iniciantes</a></li>
<li><a href="../pt465973/index.html">10 reportagens em v√≠deo mais populares do 404fest 2018</a></li>
<li><a href="../pt465977/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 31. CDP, Syslog e NTP</a></li>
<li><a href="../pt465979/index.html">Lembre-se de que ^ W √© exatamente o que voc√™ precisa. Experi√™ncia usando Anki. Parte 1 (introdut√≥ria, pen√∫ltima)</a></li>
<li><a href="../pt465981/index.html">Minha experi√™ncia em administra√ß√£o do IBM DB2 Express-C quando usada com 1C: Enterprise</a></li>
<li><a href="../pt465983/index.html">Intel Comet Lake: um pouco de 14 nm na d√©cima gera√ß√£o</a></li>
<li><a href="../pt465985/index.html">Aceleramos o processamento distribu√≠do de grandes gr√°ficos usando estruturas probabil√≠sticas de dados e n√£o apenas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>