<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♑️ 👨🏻‍🎤 🧠 Refleksi pada TDD. Mengapa metodologi ini tidak dikenal secara luas 🖐🏼 👵🏻 👂🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Untuk waktu yang lama dan hampir tidak berhasil, kami telah mencari kepala yang cerdas yang ingin menggulingkan Tn. Kent Beck di pasar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Refleksi pada TDD. Mengapa metodologi ini tidak dikenal secara luas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/427853/">  Halo, Habr! <br><br>  Untuk waktu yang lama dan hampir tidak berhasil, kami telah mencari kepala yang cerdas yang ingin menggulingkan Tn. Kent Beck di pasar - yaitu, kami mencari seseorang yang siap untuk menulis buku tentang TDD untuk kami.  Dengan contoh nyata, cerita tentang kerucut dan prestasi Anda sendiri.  Ada sangat sedikit buku tentang hal ini, dan Anda tidak akan membantah klasik ... mungkin itu sebabnya kami belum bertemu kepala ini. <br><br>  Oleh karena itu, kami memutuskan untuk tidak hanya mengingatkan diri sendiri lagi bahwa kami mencari orang seperti itu, tetapi juga untuk menawarkan terjemahan artikel yang agak kontroversial, yang penulisnya, Doug Arcuri, berbagi pemikirannya sendiri tentang mengapa TDD tidak pernah menjadi arus utama.  Mari kita bahas apakah dia benar, dan jika tidak, mengapa. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/gy/lr/2o/gylr2oryutx_6nqvbabp1mayby4.png"><br><br>  <i>Ini bukan pengantar pengembangan melalui pengujian.</i>  <i>Di sini saya akan mempresentasikan ide-ide saya sendiri tentang me-reboot disiplin ini dan berbicara tentang kesulitan praktis pengujian unit.</i> <br><br>  Programmer legendaris Kent Beck adalah penulis metodologi (pengembangan melalui pengujian) TDD dalam pengertian modernnya.  Kent juga, bersama dengan Erich Gamma, berkontribusi pada penciptaan JUnit, kerangka pengujian yang banyak digunakan. <br><br>  Dalam bukunya yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan XP</a> (edisi kedua), Kent menjelaskan bagaimana <b>prinsip</b> - <b>prinsip</b> dibentuk di persimpangan <b>nilai</b> - <b>nilai</b> dan <b>praktik</b> .  Jika Anda membuat daftar konsep dan menggantinya dalam semacam formula, Anda akan mendapatkan transformasi. <br><br><pre><code class="hljs powershell">[<span class="hljs-type"><span class="hljs-type">KISS</span></span>, <span class="hljs-type"><span class="hljs-type">Quality</span></span>, <span class="hljs-type"><span class="hljs-type">YAGNI</span></span>, <span class="hljs-type"><span class="hljs-type">...</span></span>] + [<span class="hljs-type"><span class="hljs-type">Testing</span></span>, <span class="hljs-type"><span class="hljs-type">Specs</span></span>, <span class="hljs-type"><span class="hljs-type">...</span></span>] == [<span class="hljs-type"><span class="hljs-type">TDD</span></span>, <span class="hljs-type"><span class="hljs-type">...</span></span>]</code> </pre> <br>  Saya sangat menghormati pekerjaan ini, yang bagi Kent merupakan pekerjaan seumur hidup - tidak hanya untuk mahakarya pemrogramannya, tetapi juga karena fakta bahwa dia tanpa lelah mengeksplorasi esensi <b>kepercayaan</b> , <b>keberanian</b> , <b>pelimpahan</b> , <b>kesederhanaan</b> , dan <b>kerentanan</b> .  Semua atribut ini sangat diperlukan untuk penemuan Extreme Programming (XP). <br><br>  TDD adalah prinsip dan <b>disiplin</b> yang ditaati di komunitas XP.  Disiplin ini sudah berusia 19 tahun. <br><br>  Pada artikel ini saya akan membagikan pendapat saya tentang bagaimana TDD berhasil berasimilasi.  Kemudian saya akan membagikan pengamatan pribadi yang menarik yang muncul selama sesi TDD saya.  Akhirnya, saya akan mencoba menjelaskan mengapa TDD tidak menembak sekeras kelihatannya.  Ayo pergi. <br><br>  <b>TDD, penelitian dan profesionalisme</b> <br><br>  Selama 19 tahun terakhir, disiplin TDD telah menjadi bahan perdebatan di komunitas pemrograman. <br>  Pertanyaan pertama yang akan ditanyakan oleh analis profesional adalah "berapa persentase pengembang yang menggunakan TDD hari ini?"  Jika Anda bertanya kepada teman Robert Martin (Paman Bob) dan teman Kent Beck tentang ini, jawabannya akan menjadi "100%". <br><br>  Just Paman Bob yakin bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mungkin menganggap diri Anda seorang profesional jika Anda tidak mempraktikkan pengembangan melalui pengujian</a> . <br><br>  Paman Bob telah terlibat erat dalam disiplin ini selama beberapa tahun, jadi wajar untuk memperhatikannya dalam ulasan ini.  Paman Bob membela TDD dan secara signifikan memperluas batas-batas disiplin ini.  Anda dapat yakin bahwa saya sangat menghormati Paman Bob dan dogmatismenya yang pragmatis. <br><br>  Namun, tidak ada yang mengajukan pertanyaan berikut: "setelah semua, berlatih berarti" menggunakan secara sadar "- tetapi itu tidak memungkinkan untuk menilai persentase, kan?"  Menurut pendapat subjektif saya, kebanyakan programmer <b>tidak berurusan dengan</b> TDD bahkan untuk periode simbolik apa pun. <br><br>  Kenyataannya adalah kita benar-benar tidak tahu angka-angka ini, karena tidak ada yang secara aktif menyelidiki persentase ini.  Semua data spesifik terbatas pada sejumlah kecil perusahaan yang dikumpulkan di situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WeDoTDD</a> .  Di sini Anda akan menemukan statistik perusahaan seperti itu, wawancara dengan mereka yang berlatih TDD sepanjang waktu, tetapi daftar ini tidak besar.  Selain itu, itu tidak lengkap, karena bahkan pencarian sederhana mengungkapkan organisasi besar lainnya yang terlibat dalam TDD - tetapi, mungkin, tidak pada kapasitas penuh. <br><br>  Jika kita tidak tahu berapa banyak perusahaan yang mempraktikkan TDD, pertanyaan berikut muncul: "Seberapa efektif TDD, dilihat dari kemampuannya yang terukur"? <br>  Anda mungkin akan senang bahwa selama bertahun-tahun sejumlah penelitian telah dilakukan yang mengkonfirmasi efektivitas TDD.  Di antara mereka pasti ada laporan otoritatif dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBM</a> , University of North Carolina dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">University of Helsinki</a> . <br><br><img src="https://habrastorage.org/webt/2p/qx/vt/2pqxvtwfp0c4pq8y-tynkuezulc.png"><br><br>  <i>Diagram ekspresif diambil dari laporan dari Universitas Helsinki.</i> <br><br>  Hingga taraf tertentu, laporan ini membuktikan bahwa kepadatan kesalahan dapat dikurangi hingga 40-60%, yang membutuhkan lebih banyak pekerjaan;  runtime meningkat 15-35%.  Angka-angka ini sudah mulai dilacak dalam buku-buku dan metodologi industri baru, khususnya di komunitas DevOps. <br><br>  Sebagian menjawab pertanyaan-pertanyaan ini, kita beralih ke yang terakhir: "Apa yang bisa saya andalkan ketika saya mulai berlatih TDD?"  Untuk jawaban itu saya merumuskan pengamatan pribadi saya tentang TDD.  Mari kita beralih ke mereka. <br><br>  <b>1. TDD membutuhkan pendekatan verbal</b> <br><br>  Ketika berlatih TDD, kita mulai menemui fenomena "penunjukan target."  Sederhananya, proyek singkat seperti mempersiapkan tes gagal dan sukses adalah tantangan intelektual yang serius bagi pengembang.  Pengembang harus mengartikulasikan dengan jelas: "Saya percaya bahwa tes ini akan berhasil" dan "Saya percaya bahwa tes ini akan gagal" atau "Saya tidak yakin, biarkan saya bercermin setelah saya mencoba pendekatan ini." <br><br>  IDE telah menjadi untuk pengembang yang bebek karet yang memohon untuk secara aktif berbicara dengannya.  Paling tidak, di perusahaan TDD, percakapan seperti ini harus bergabung menjadi buzz berkelanjutan. <br><br>  Pikirkan dulu - lalu ambil langkah Anda berikutnya (atau langkah-langkah). <br><br>  Penguatan seperti itu memainkan peran kunci dalam komunikasi: memungkinkan Anda tidak hanya untuk memprediksi langkah Anda berikutnya, tetapi juga untuk merangsang Anda untuk menulis kode yang <b>paling sederhana</b> untuk memastikan bahwa tes unit berlalu.  Tentu saja, jika pengembang diam, maka ia hampir pasti akan kehilangan arahnya, setelah itu ia harus kembali ke trek. <br><br>  <b>2. TDD memompa memori motor</b> <br><br>  Pengembang, membuat jalan melalui siklus TDD pertamanya, dengan cepat merasa lelah - setelah semua, proses ini tidak nyaman dan terus-menerus terhenti.  Ini adalah situasi umum dengan aktivitas apa pun yang baru saja dimulai, tetapi belum dikuasai.  Pengembang akan menggunakan jalan pintas, mencoba mengoptimalkan siklus ini untuk mengisi tangannya dan meningkatkan memori motor. <br>  Memori motor sangat diperlukan agar pekerjaan menyenangkan dan berjalan seperti jarum jam.  Dalam TDD, ini diperlukan karena pengulangan tindakan. <br><br>  Dapatkan lembar cheat dengan cara pintas seperti itu.  Dapatkan hasil maksimal dari pintasan keyboard Anda di IDE Anda untuk membuat loop efektif.  Lalu terus mencari. <br><br>  Hanya dalam beberapa sesi, pengembang sempurna menguasai pemilihan cara pintas, khususnya, beberapa sesi cukup untuk merakit dan menjalankan uji coba.  Ketika Anda berlatih membuat artefak baru, menyorot teks, dan menavigasi melalui IDE, semua ini akan tampak alami bagi Anda.  Akhirnya, Anda akan menjadi profesional sejati dan menguasai semua teknik refactoring: khususnya, mengekstraksi, mengganti nama, menghasilkan, membesarkan, memformat ulang, dan keturunan. <br><br>  <b>3. TDD membutuhkan setidaknya sedikit pemikiran atas tindakan mereka terlebih dahulu</b> <br><br>  Setiap kali pengembang berpikir tentang memulai TDD, ia perlu mengingat peta mental singkat dari tugas-tugas yang perlu diselesaikan.  Dalam pendekatan tradisional untuk pemrograman, peta seperti itu tidak selalu ada, dan tugas itu sendiri dapat disajikan "di tingkat makro" atau memiliki sifat penelitian.  Mungkin pengembang tidak tahu bagaimana menyelesaikan masalah, tetapi hanya kira-kira membayangkan tujuan.  Tes unit diabaikan untuk mencapai tujuan ini. <br><br>  Sambil duduk di tempat kerja dan diakhiri dengan "duduk" yang lain - cobalah juga melakukan ritual dari ini.  Pikirkan dan daftar dulu.  Main dengannya.  Daftar lebih lanjut.  Kemudian lanjutkan, lakukan, pikirkan.  Rayakan.  Ulangi beberapa kali.  Kemudian pikirkan lagi dan berhenti. <br><br>  Bersabarlah tentang pekerjaan.  Lacak apa yang sudah dilakukan - centang kotak.  Jangan pernah lipat sampai setidaknya ada satu.  Pikirkan! <br><br>  Mungkin kata-kata dalam daftar akan membutuhkan waktu yang tidak sesuai dengan siklus kerja.  Namun, sebelum Anda mulai, Anda harus memiliki daftar.  Tanpa itu, Anda tidak tahu ke mana Anda akan pindah.  Tidak ada tempat tanpa kartu. <br><br><pre> <code class="hljs erlang-repl">//   // <span class="hljs-string"><span class="hljs-string">""</span></span> -&gt;   // <span class="hljs-string"><span class="hljs-string">"a"</span></span> -&gt;   // <span class="hljs-string"><span class="hljs-string">"aa"</span></span> -&gt;  // <span class="hljs-string"><span class="hljs-string">"racecar"</span></span> -&gt;  // <span class="hljs-string"><span class="hljs-string">"Racecar"</span></span> -&gt;  //   //   </code> </pre> <br>  Pengembang harus membuat <b>daftar tes</b> seperti yang dijelaskan oleh Kent Beck.  Daftar tes memungkinkan Anda untuk memecahkan masalah dalam bentuk siklus yang lancar saling masuk.  Di atas daftar tes, Anda perlu terus-menerus memproses dan memperbarui, meskipun hanya beberapa detik sebelum tes.  Jika daftar tes lulus hampir sepenuhnya minus tahap terakhir, maka hasilnya adalah "merah", dan seluruh tes gagal. <br><br>  <b>4. TDD tergantung pada komunikasi dengan rekan kerja</b> <br><br>  Setelah daftar di atas selesai, beberapa langkah mungkin diblokir, karena mereka tidak cukup jelas menggambarkan apa yang harus dilakukan.  Pengembang tidak mengerti daftar tes.  Sebaliknya juga terjadi - daftar ini terlalu kasar, di mana ada banyak asumsi tentang persyaratan yang belum dirumuskan.  Jika Anda mendapatkan sesuatu seperti ini, segera berhenti. <br><br>  Bertindak tanpa TDD dapat menghasilkan implementasi yang terlalu rumit.  Bekerja dengan gaya TDD, tetapi tanpa berpikir, tanpa daftar, tidak kalah berbahaya. <br><br>  Jika Anda melihat ada celah dalam daftar tes, berdirilah dan ucapkan dengan lantang. <br><br>  Dalam TDD, pengembang harus memahami produk apa yang harus dilakukan, dipandu oleh gagasan persyaratan yang diperlukan dalam interpretasi pemilik - dan tidak lebih.  Jika persyaratan dalam konteks ini tidak jelas, maka daftar tes mulai berantakan.  Kegagalan ini perlu didiskusikan.  Diskusi yang tenang dengan cepat membantu membangun kepercayaan diri dan rasa hormat.  Selain itu, ini adalah bagaimana putaran umpan balik cepat terbentuk. <br><br>  <b>5. TDD membutuhkan arsitektur berulang</b> <br><br>  Kembali ke edisi pertama bukunya XP, Kent menyarankan bahwa tes harus menjadi kekuatan pendorong di balik arsitektur.  Namun, selama beberapa tahun, banyak cerita muncul tentang bagaimana tim-tim sprint menemukan tembok di beberapa sprint. <br><br>  Tentu saja, membangun arsitektur berdasarkan tes tidak rasional.  Paman Bob sendiri setuju dengan para ahli lain bahwa itu tidak baik.  Diperlukan peta yang lebih luas, tetapi tidak terlalu jauh dari daftar tes yang Anda kembangkan “di lapangan”. <br><br>  Bertahun-tahun kemudian, Kent juga menyuarakan tesis ini dalam bukunya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TDD By Example</a> .  <b>Daya saing</b> dan <b>keamanan</b> adalah dua bidang utama di mana TDD tidak dapat menjadi kekuatan pendorong, dan pengembang harus menghadapinya secara terpisah.  Kita dapat mengatakan bahwa daya saing adalah tingkat desain sistem yang berbeda, daya saing perlu dikembangkan oleh iterasi, mengoordinasikan proses ini dengan TDD.  Ini terutama benar hari ini, karena beberapa arsitektur berkembang menuju <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paradigma</a> reaktif dan ekstensi reaktif ( <b>reaktivitas</b> adalah daya saing di puncaknya). <br><br>  Bangun peta yang lebih besar dari keseluruhan organisasi.  Membantu melihat hal-hal sedikit dalam perspektif.  Pastikan Anda dan tim bergerak dalam jalur yang sama. <br><br>  Namun, ide yang paling penting adalah <b>organisasi</b> seluruh sistem, dan satu organisasi TDD tidak disediakan.  Faktanya adalah bahwa tes unit adalah hal tingkat rendah.  Arsitektur iteratif dan orkestrasi TDD kompleks dalam praktiknya dan membutuhkan kepercayaan antara semua anggota tim, pemrograman pasangan dan ulasan kode yang solid.  Tidak sepenuhnya jelas bagaimana mencapai ini, tetapi segera Anda dapat melihat bahwa sesi desain singkat harus dilakukan bersamaan dengan implementasi daftar tes di bidang subjek. <br><br>  <b>6. TDD mengungkapkan kerapuhan unit test dan menurunkan implementasi</b> <br><br>  Tes unit memiliki satu fitur menyenangkan, dan TDD sepenuhnya memberikannya.  Mereka tidak mengizinkan untuk membuktikan kebenarannya.  E.V.Dijkstra bekerja pada masalah ini dan membahas bagaimana bukti matematika mungkin dalam kasus kami yang akan mengisi celah ini. <br><br>  Sebagai contoh, dalam contoh berikut, semua tes yang terkait dengan palindrom tidak sempurna hipotetis yang ditentukan oleh logika bisnis diselesaikan.  Contoh dikembangkan menggunakan metodologi TDD. <br><br><pre> <code class="hljs pgsql">//    @Test fun `Given "", <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> it does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>`() { "".<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>().shouldBeFalse() } @Test fun `Given "a", <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> it does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>`() { "a".<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>().shouldBeFalse() } @Test fun `Given "aa", <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> it validates`() { "aa".<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>().shouldBeTrue() } @Test fun `Given "abba", <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> it validates`() { "abba".<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>().shouldBeTrue() } @Test fun `Given "racecar", <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> it validates`() { "racecar".<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>().shouldBeTrue() } @Test fun `Given "Racecar", <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> it validates`() { "Racecar".<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>().shouldBeTrue() }</code> </pre> <br>  Memang, ada kekurangan dalam tes ini.  Tes unit rapuh bahkan dalam kasus yang paling sepele.  Mereka tidak pernah berhasil membuktikan kebenarannya, karena jika kami mencobanya akan membutuhkan kerja mental yang luar biasa, dan masukan yang diperlukan untuk ini tidak mungkin dibayangkan. <br><br><pre> <code class="hljs pgsql">//   ,      fun String.<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEmpty() || length == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> toLowerCase() == toLowerCase().reversed() //   ,    fun String.<span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>() = length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <code>length &gt; 1</code> dapat disebut <b>implementasi degenerate</b> .  Cukup memadai untuk menyelesaikan tugas, tetapi itu sendiri tidak melaporkan apa pun tentang masalah yang kami coba selesaikan. <br><br>  Pertanyaannya adalah - kapan pengembang harus berhenti menulis tes?  Jawabannya tampak sederhana: ketika itu sudah <b>cukup dari sudut pandang logika bisnis</b> , dan tidak sesuai dengan pembuat kode.  Ini bisa melukai <b>semangat desain</b> kami, dan kesederhanaan bisa <b>membuat orang kesal</b> .  Perasaan-perasaan ini dikompensasi oleh kepuasan saat melihat kode bersih kita sendiri dan pemahaman bahwa kode selanjutnya dapat dengan yakin di-refactored.  Semua kode akan sangat rapi. <br><br>  Perhatikan bahwa untuk semua yang tidak dapat diandalkan, tes unit diperlukan.  Pahami kekuatan dan kelemahan mereka.  Jika gambar lengkap tidak bertambah, mungkin kesenjangan ini akan membantu mengisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian mutasi</a> . <br><br>  TDD memiliki manfaatnya, tetapi metodologi ini dapat mengalihkan kita dari membangun istana pasir yang tidak perlu.  Ya, ini adalah <b>batasan</b> , tetapi berkat itu, Anda dapat bergerak lebih cepat, lebih jauh, dan lebih andal.  Mungkin inilah yang ada dalam pikiran Paman Bob ketika menggambarkan apa, dari sudut pandangnya, artinya <b>menjadi seorang profesional</b> . <br><br>  Tapi!  Tidak peduli seberapa rapuh tes unit bagi kami, mereka adalah mutlak harus.  Merekalah yang mengubah <b>ketakutan</b> menjadi <b>keberanian</b> .  Tes memberikan refactoring kode yang lembut;  selain itu, mereka dapat berfungsi sebagai <b>panduan</b> dan <b>dokumentasi untuk</b> setiap pengembang baru yang dapat segera mendapatkan jalur dan bekerja untuk kepentingan proyek - jika proyek ini dicakup oleh unit test. <br><br>  <b>7. TDD menunjukkan loop terbalik dari pernyataan pengujian</b> <br><br>  Ambil satu langkah lebih jauh.  Untuk memahami dua fenomena berikut, kami mempelajari peristiwa berulang yang aneh.  Untuk memulai, mari kita lihat FizzBuzz.  Ini daftar tes kami. <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    9  15. [OK] /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,  3,  Fizz  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ...</span></span></code> </pre><br>  Kami maju beberapa langkah.  Sekarang tes kami gagal. <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `Given numbers, replace those divisible </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">by</span></span></span><span class="hljs-function"> 3 with "Fizz"`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> machine = FizzBuzz() assertEquals(machine.print(), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FizzBuzz</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span>) { output += <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-string"><span class="hljs-string">"Fizz "</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string"> "</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output.trim() } } Expected &lt;Fizz <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> Fizz <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> Fizz&gt;, <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> &lt;?&gt;.</code> </pre> <br>  Secara alami, jika kita menduplikasi data pernyataan yang diharapkan dalam <code>assertEquals</code> , maka hasil yang diinginkan tercapai, dan pengujian dilakukan. <br><br>  Terkadang tes gagal memberikan hasil yang benar diperlukan untuk lulus tes.  Saya tidak tahu harus menyebutkan nama acara semacam itu ... mungkin <b>pengujian voodoo</b> .  Berapa kali Anda melihat ini - sebagian tergantung pada kemalasan dan etiket Anda saat pengujian, tetapi saya telah memperhatikan hal-hal seperti itu berkali-kali ketika seseorang mencoba untuk mendapatkan implementasi yang bekerja secara normal dengan set data yang siap pakai dan dapat diprediksi. <br><br>  <b>8. TDD menunjukkan urutan transformasi</b> <br><br>  TDD dapat menjebak Anda.  Kebetulan pengembang bingung dalam transformasi yang dilakukan oleh dirinya sendiri, yang ia gunakan untuk mencapai implementasi yang diinginkan.  Pada titik tertentu, kode uji berubah menjadi hambatan di mana kita berhenti. <br><br>  Jalan <b>buntu</b> terbentuk.  Pengembang harus mundur dan melucuti, menghapus beberapa tes untuk keluar dari perangkap ini.  Pengembang tetap tidak terlindungi. <br><br>  Paman Bob kemungkinan akan mengalami kebuntuan selama bertahun-tahun dalam karirnya, setelah itu, tampaknya, ia menyadari bahwa, untuk lulus ujian, Anda perlu menetapkan urutan tindakan yang tepat untuk meminimalkan kemungkinan memasuki jalan buntu.  Selain itu, ia harus menyadari kondisi lain.  <b>Semakin spesifik pengujian, semakin umum kode tersebut</b> . <br><br><img src="https://habrastorage.org/webt/iw/a6/dp/iwa6dpb_ice2v31dtae2ux9a2rs.png"><br><br>  <i>Urutan transformasi.</i>  <i>Anda harus selalu berusaha untuk opsi paling sederhana (di bagian atas daftar).</i> <br><br>  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kondisi prioritas Transisi</a> .  Tampaknya, ada urutan risiko refactoring tertentu, yang siap kami raih setelah lulus tes.  Biasanya yang terbaik adalah memilih opsi konversi yang diperlihatkan di bagian paling atas daftar (paling sederhana) - dalam hal ini, kemungkinan masuk ke jalan buntu tetap minimal. <br><br>  TPP atau <b>Analisis Uji Paman Bob</b> , dapat dikatakan, adalah salah satu fenomena paling menarik, teknologi, dan menarik yang saat ini diamati. <br><br>  Gunakan untuk menjaga kode Anda sesederhana mungkin. <br>  Cetak daftar TPP dan letakkan di meja Anda.  Periksa dengan dia untuk menghindari jalan buntu.  Buat aturan: pesanan harus sederhana. <br><br>  Ini menyimpulkan kisah pengamatan utama saya.  Namun, di bagian akhir artikel saya ingin kembali ke pertanyaan yang kami lupa jawab di awal: "Berapa persentase programmer profesional yang menggunakan TDD hari ini?"  Saya akan menjawab: "Saya pikir ada beberapa dari mereka."  Saya ingin menyelidiki pertanyaan ini di bawah dan mencoba menjelaskan alasannya. <br><br>  <b>Apakah TDD tertanam dalam praktik?</b> <br><br>  Sayangnya tidak.  Secara subyektif, tampaknya persentase pendukungnya rendah, dan saya terus mencari data.  Pengalaman saya dalam merekrut, kepemimpinan tim dan pengembangan diri (yang membuat saya terpesona) memungkinkan saya untuk melakukan pengamatan berikut. <br><br>  <i><b>Alasan 1: Kurang kontak dengan budaya pengujian yang sebenarnya</b></i> <br><br>  Saya bisa berasumsi bahwa sebagian besar pengembang tidak memiliki kesempatan untuk belajar dan bekerja dalam <b>budaya pengujian yang</b> sebenarnya. <br><br>  Budaya pengujian adalah lingkungan di mana pengembang secara sadar berlatih dan meningkatkan dalam seni pengujian.  Mereka terus melatih kolega yang masih belum memiliki pengalaman yang cukup di bidang ini.  Umpan balik telah dibuat di setiap pasangan dan setiap kelompok permintaan yang membantu semua peserta untuk mengembangkan keterampilan pengujian.  Selain itu, ada dukungan serius dan rasa sikut di seluruh hierarki insinyur.  Semua manajer memahami esensi pengujian dan meyakininya.  Ketika tenggat waktu mulai habis, disiplin pengujian tidak dibuang, tetapi terus diikuti. <br><br>  Mereka yang beruntung menguji diri mereka dalam budaya pengujian seperti itu, misalnya, saya memiliki kesempatan untuk melakukan pengamatan seperti itu.        . <br><br> <i><b> 2:   </b></i> <br><br>        TDD, , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">xUnit Patterns</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Effective Unit Testing</a> . , -,   ,     ,    .               . <br><br>            .        ,     .     .  ,     ,     ,  … . <br><br> <i><b> 3:    </b></i> <br><br> :  ,   ,         .   ,   ,     ; - ,  –       . <br><br> <i><b> 4:        </b></i> <br><br>    ,   ,   TDD      .        ,     . <br><br>   ,   ,        : «  ,    ». : , «  » —     . <br><br>        –      . <br><br>  <b>Kesimpulan</b> <br><br>  XP   –    <b></b> , <b></b>  <b></b> .    –       ,    .        TDD. <br><br>      ,     ,        .     «»   ,  ,   –     ,      . <br><br><img src="https://habrastorage.org/webt/dn/wb/o-/dnwbo-sr4yomfsdqjvbpda-csgc.png"><br><br> <i>  XP Explained.      ,  ,     .</i> <br><br>       ,   -      . <br><br>   ,   –  ,       .           , ,        ,       . <br><br> ,        ,         ,     . <br><br>  TDD   « »  ,       .          TDD      .   TDD . <br><br> .  TDD      ,   . TDD —  , , .   ,  TDD      ,   .     ,        . <br><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `Given software, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">when</span></span></span><span class="hljs-function"> we build, then we </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">expect</span></span></span><span class="hljs-function"> tests`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { build(software) shoudHave tests }</code> </pre> <br> , TDD –  ,   <b></b> ,   <b> </b> .     .     ,     ,        ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427853/">https://habr.com/ru/post/id427853/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427841/index.html">Magic Leap Scam</a></li>
<li><a href="../id427843/index.html">Cara tidur benar dan salah</a></li>
<li><a href="../id427845/index.html">Cara memuat jutaan bintang di iPhone</a></li>
<li><a href="../id427847/index.html">Keingintahuan dan penundaan dalam pembelajaran mesin</a></li>
<li><a href="../id427849/index.html">Garis lurus dengan TM. v3.0</a></li>
<li><a href="../id427855/index.html">Mitos MOSDROID di FunCorp</a></li>
<li><a href="../id427857/index.html">Masalah pajak dan hukum untuk freelancer pemula</a></li>
<li><a href="../id427859/index.html">Mengapa keterampilan teknis untuk manajer proyek: jelaskan tentang kasus-kasus</a></li>
<li><a href="../id427861/index.html">Serverless CPaaS - bagaimana Voximplant mengantisipasi hype ini</a></li>
<li><a href="../id427863/index.html">Membuat urutan elemen acak dalam daftar dimensi dan ukuran tabel pivot Excel untuk model tabel kubus SSAS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>