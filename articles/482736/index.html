<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚ÄçüöÄ ‚õπÔ∏è üèõÔ∏è Uso de TSDuck para monitorear flujos de IP (TS) üë®üèæ‚Äçüíº üêò üñ±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy en d√≠a, existen soluciones preparadas (patentadas) para monitorear transmisiones IP (TS), por ejemplo, VB e iQ , tienen un conjunto bastante rico ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso de TSDuck para monitorear flujos de IP (TS)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482736/"><p>  Hoy en d√≠a, existen soluciones preparadas (patentadas) para monitorear transmisiones IP (TS), por ejemplo, <a href="https://bridgetech.tv/all-products/" rel="nofollow">VB</a> e <a href="https://www.telestream.net/pdfs/iq/productsheets/Surveyor_TS_New.pdf" rel="nofollow">iQ</a> , tienen un conjunto bastante rico de funciones y, por lo general, tales soluciones est√°n disponibles para grandes operadores que se ocupan de servicios de TV.  Este art√≠culo describe una soluci√≥n basada en el proyecto de c√≥digo abierto <a href="https://tsduck.io/" rel="nofollow">TSDuck</a> , dise√±ado para minimizar el control de los flujos de IP (TS) por el contador CC (contador de continuidad) y la velocidad de bits.  Una posible aplicaci√≥n es controlar la p√©rdida de paquetes o el flujo completo a trav√©s de un canal L2 alquilado (que no se puede monitorear normalmente, por ejemplo, leyendo los contadores de p√©rdida en las colas). </p><br><h2 id="ochen-kratko-o-tsduck">  Muy breve sobre TSDuck </h2><br><p> TSDuck es un software de c√≥digo abierto (licencia BSD de 2 cl√°usulas) (un conjunto de utilidades de consola y una biblioteca para desarrollar sus utilidades o complementos) para manipular flujos de TS.  Como entrada, puede funcionar con IP (multidifusi√≥n / unidifusi√≥n), http, hls, sintonizadores dvb, demodulador dektec dvb-asi, hay un generador de flujo TS interno y lectura de archivos.  La salida puede ser un archivo, IP (multidifusi√≥n / unidifusi√≥n), hls, dektec dvb-asi y moduladores HiDes, reproductores (mplayer, vlc, xine) y soltar.  Entre la entrada y la salida, puede activar varios procesadores de tr√°fico, por ejemplo, reasignaci√≥n de PID, codificaci√≥n / descifrado, an√°lisis de contadores CC, c√°lculo de tasa de bits y otras operaciones t√≠picas de los flujos TS. </p><a name="habracut"></a><br><p>  En este art√≠culo, se utilizar√°n flujos de IP (multidifusi√≥n) como entrada, se utilizar√°n procesadores bitrate_monitor (por el nombre est√° claro de qu√© se trata) y continuidad (an√°lisis de contadores CC).  Sin ning√∫n problema, puede reemplazar la multidifusi√≥n IP con otro tipo de entrada compatible con TSDuck. </p><br><p>  Hay <a href="https://tsduck.io/download/tsduck/" rel="nofollow">compilaciones / paquetes</a> oficiales <a href="https://tsduck.io/download/tsduck/" rel="nofollow">de</a> TSDuck para la mayor√≠a de los sistemas operativos actuales.  Para Debian, no lo son, pero fue posible ensamblar sin problemas bajo debian 8 y debian 10. </p><br><p>  Luego, se usa TSDuck versi√≥n 3.19-1520, Linux se usa como SO (debian 10 se us√≥ para preparar la soluci√≥n, CentOS 7 se us√≥ para uso real) </p><br><h2 id="podgotovka-tsduck-i-os">  Preparando TSDuck y OS </h2><br><p>  Antes de monitorear flujos reales, debe asegurarse de que TSDuck funcione correctamente y que no haya ca√≠das en el nivel de la tarjeta de red o del sistema operativo (socket).  Esto es necesario para no adivinar m√°s tarde d√≥nde se produjeron las ca√≠das: en la red o "dentro del servidor".  Puede verificar las ca√≠das en el nivel de la tarjeta de red con el comando ethtool -S ethX, el ajuste se realiza con la misma ethtool (por lo general, debe aumentar el b√∫fer RX (-G) y, a veces, desactivar algunas descargas (-K)).  Como recomendaci√≥n general, puede recomendar el uso de un puerto separado para recibir el tr√°fico analizado, si es posible, esto minimiza los falsos positivos asociados con el hecho de que la ca√≠da se produjo de manera coherente en el puerto del analizador debido a la presencia de otro tr√°fico.  Si esto no es posible (se utiliza una mini computadora / NUC con un solo puerto), entonces es altamente deseable priorizar el tr√°fico analizado en relaci√≥n con el resto del dispositivo al que est√° conectado el analizador.  Con respecto a los entornos virtuales, aqu√≠ debe tener cuidado y poder encontrar paquetes descartados comenzando desde el puerto f√≠sico y terminando con la aplicaci√≥n dentro de la m√°quina virtual. </p><br><h3 id="generaciya-i-priyom-potoka-vnutri-hosta">  Generaci√≥n y recepci√≥n de un flujo dentro del host. </h3><br><p>  Como primer paso para preparar TSDuck, generaremos y recibiremos tr√°fico dentro del mismo host usando netns. </p><br><p>  Entorno de cocci√≥n: </p><br><pre><code class="bash hljs">ip netns add P <span class="hljs-comment"><span class="hljs-comment"># netns P,       ip link add type veth # veth- - veth0   netns   (     ) ip link set dev veth1 netns P #veth1 -   netns P (     ) ip netns exec P ifconfig veth1 192.0.2.1/30 up # IP  veth1,      ip netns exec P ip ro add default via 192.0.2.2 #     nents P sysctl net.ipv6.conf.veth0.disable_ipv6=1 # IPv6  veth0 -    ,    TX     ifconfig veth0 up #  veth0 ip route add 239.0.0.1 dev veth0 # ,      239.0.0.1   veth0</span></span></code> </pre> <br><p>  El ambiente est√° listo.  Iniciamos el analizador de tr√°fico: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P tsp --realtime -t \ -I ip 239.0.0.1:1234 \ -P continuity \ -P bitrate_monitor -p 1 -t 1 \ -O drop</code> </pre> <br><p>  donde "-p 1 -t 1" significa que necesita calcular la tasa de bits cada segundo y mostrar informaci√≥n sobre la tasa de bits cada segundo <br>  Iniciamos el generador de tr√°fico con una velocidad de 10 Mbps: </p><br><pre> <code class="bash hljs">tsp -I craft \ -P regulate -b 10000000 \ -O ip -p 7 -e --<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>-port 6000 239.0.0.1:1234</code> </pre> <br><p>  donde "-p 7 -e" significa que necesita empacar 7 paquetes TS en 1 paquete IP y hacerlo duro (-e), es decir  espere siempre 7 paquetes TS del √∫ltimo procesador antes de enviar un paquete IP. </p><br><p>  El analizador comienza a mostrar los mensajes esperados: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:55:44 - bitrate_monitor: 2020/01/03 14:55:44, TS bitrate: 9,970,016 bits/s * 2020/01/03 14:55:45 - bitrate_monitor: 2020/01/03 14:55:45, TS bitrate: 10,022,656 bits/s * 2020/01/03 14:55:46 - bitrate_monitor: 2020/01/03 14:55:46, TS bitrate: 9,980,544 bits/s</code> </pre> <br><p>  Ahora agregue algunas gotas: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P iptables -I INPUT -d 239.0.0.1 -m statistic --mode random --probability 0.001 -j DROP</code> </pre> <br><p>  y aparecen mensajes como estos: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:57:11 - continuity: packet index: 80,745, PID: 0x0000, missing 7 packets * 2020/01/03 14:57:11 - continuity: packet index: 83,342, PID: 0x0000, missing 7 packets</code> </pre> <br><p>  Lo que se espera.  Deshabilite la p√©rdida de paquetes (ip netns exec P iptables -F) e intente aumentar la tasa de bits del generador a 100 Mbps.  El analizador informa un mont√≥n de errores CC y aproximadamente 75 Mbit / s en lugar de 100. Tratamos de averiguar qui√©n tiene la culpa: el generador no tiene tiempo o el problema no est√° en √©l, para esto comenzamos a generar un n√∫mero fijo de paquetes (700,000 paquetes TS = 100,000 paquetes IP): </p><br><pre> <code class="plaintext hljs"># ifconfig veth0 | grep TX TX packets 151825460 bytes 205725459268 (191.5 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 # tsp -I craft -c 700000 -P regulate -b 100000000 -P count -O ip -p 7 -e --local-port 6000 239.0.0.1:1234 * count: PID 0 (0x0000): 700,000 packets # ifconfig veth0 | grep TX TX packets 151925460 bytes 205861259268 (191.7 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code> </pre> <br><p>  Como puede ver, se generaron exactamente 100,000 paquetes IP (151925460-151825460).  Entonces entendemos lo que sucede con el analizador, para esto verificamos con el contador RX en veth1, es estrictamente igual al contador TX en veth0, luego observamos lo que sucede en el nivel del socket: </p><br><pre> <code class="plaintext hljs"># ip netns exec P cat /proc/net/udp sl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode ref pointer drops 133: 010000EF:04D2 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 72338 2 00000000e0a441df 24355</code> </pre> <br><p>  Aqu√≠ puede ver el n√∫mero de ca√≠das = 24355. En los paquetes TS esto es 170485 o 24.36% de 700000, por lo que vemos que el 25% de la tasa de bits perdida son ca√≠das en el z√≥calo udp.  Las ca√≠das en un socket UDP generalmente ocurren debido a la falta de un buffer, mira cu√°l es el tama√±o del buffer de socket predeterminado y el tama√±o m√°ximo del buffer de socket: </p><br><pre> <code class="plaintext hljs"># sysctl net.core.rmem_default net.core.rmem_default = 212992 # sysctl net.core.rmem_max net.core.rmem_max = 212992</code> </pre> <br><p>  Por lo tanto, si las aplicaciones no solicitan expl√≠citamente el tama√±o del b√∫fer, los sockets se crean con un b√∫fer de 208 KB, pero si solicitan m√°s, a√∫n no recibir√°n lo que se solicita.  Dado que en tsp puede establecer el tama√±o del b√∫fer (- tama√±o del b√∫fer) para la entrada IP, no tocaremos el tama√±o del z√≥calo de forma predeterminada, solo establecemos el tama√±o m√°ximo del b√∫fer del z√≥calo y especificamos el tama√±o del b√∫fer expl√≠citamente mediante argumentos tsp: </p><br><pre> <code class="plaintext hljs">sysctl net.core.rmem_max=8388608 ip netns exec P tsp --realtime -t -I ip 239.0.0.1:1234 -b 8388608 -P continuity -P bitrate_monitor -p 1 -t 1 -O drop</code> </pre> <br><p>  Con este ajuste del b√∫fer de socket, la tasa de bits ahora reportada es de aproximadamente 100 Mbit / s, no hay errores de CC. </p><br><p>  Por consumo de CPU por la propia aplicaci√≥n tsp.  En relaci√≥n con un n√∫cleo de la CPU i5-4260U a 1.40 GHz, el an√°lisis de un flujo de 10Mbit / s requiere 3-4% de CPU, 100Mbit / s - 25%, 200Mbit / s - 46%.  Al configurar el% de p√©rdida de paquetes, la carga en la CPU pr√°cticamente no aumenta (pero puede disminuir). </p><br><p>  En un hardware m√°s productivo, fue posible generar y analizar flujos de m√°s de 1 Gb / s sin problemas. </p><br><h3 id="testirovanie-na-realnyh-setevyh-kartah">  Prueba en tarjetas de red reales </h3><br><p>  Despu√©s de probar en un par, debe tomar dos hosts o dos puertos de un host, conectar los puertos entre s√≠, ejecutar el generador en uno y el analizador en el segundo.  No hubo sorpresas, pero en realidad todo depende del hierro, cuanto m√°s d√©bil sea, m√°s interesante ser√°. </p><br><h2 id="ispolzovanie-poluchaemyh-dannyh-sistemoy-monitoringa-zabbix">  Uso de los datos recibidos por el sistema de monitoreo (Zabbix) </h2><br><p>  Tsp no tiene ninguna API legible por m√°quina como SNMP o similar.  Los mensajes CC deben agregarse al menos 1 segundo (con un alto porcentaje de p√©rdida de paquetes, puede haber cientos / miles / decenas de miles por segundo, dependiendo de la tasa de bits). </p><br><p>  Por lo tanto, para guardar informaci√≥n y dibujar gr√°ficos de errores CC y velocidad de bits y hacer alg√∫n tipo de accidente, las siguientes opciones pueden ser m√°s avanzadas: </p><br><ol><li>  Analiza y agrega (seg√∫n CC) la salida de tsp, es decir  convi√©rtalo a la forma deseada. </li><li>  Agregue los complementos tsp y / o procesador bitrate_monitor y la continuidad misma para que el resultado se muestre en un formato legible por m√°quina adecuado para un sistema de monitoreo. </li><li>  Escriba su solicitud en la parte superior de la biblioteca tsduck. </li></ol><br><p>  Obviamente, desde el punto de vista de los costos laborales, la opci√≥n 1 es la m√°s simple, especialmente teniendo en cuenta que tsduck est√° escrito en un lenguaje de bajo nivel (seg√∫n los est√°ndares modernos) (C ++) </p><br><p>  Un prototipo simple del analizador + agregador en bash mostr√≥ que en una transmisi√≥n de 10Mbit / sy una p√©rdida de paquetes del 50% (el peor de los casos), el proceso de bash consumi√≥ 3-4 veces m√°s CPU que el proceso de tsp.  Este escenario es inaceptable.  En realidad, una pieza de este prototipo a continuaci√≥n </p><br><div class="spoiler">  <b class="spoiler_title">Fideos en la fiesta</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash missingPackets=0 ccErrorSeconds=0 regexMissPackets='^\*\ (.+) - continuity:.*missing ([0-9]+) packets$' missingPacketsTime="" ip netns exec P tsp --realtime -t -I ip -b 8388608 "239.0.0.1:1234" -O drop -P bitrate_monitor -p 1 -t 1 -P continuity 2&gt;&amp;1 | \ while read i do #line example:* 2019/12/28 23:41:14 - continuity: packet index: 6,078, PID: 0x0100, missing 5 packets #line example 2: * 2019/12/28 23:55:11 - bitrate_monitor: 2019/12/28 23:55:11, TS bitrate: 4,272,864 bits/s if [[ "$i" == *continuity:* ]] then if [[ "$i" =~ $regexMissPackets ]] then missingPacketsTimeNew="${BASH_REMATCH[1]}" #timestamp (seconds) if [[ "$missingPacketsTime" != "$missingPacketsTimeNew" ]] #new second with CC error then ((ccErrorSeconds += 1)) fi missingPacketsTime=$missingPacketsTimeNew packets=${BASH_REMATCH[2]} #TS missing packets ((missingPackets += packets)) fi elif [[ "$i" == *bitrate_monitor:* ]] then : #... fi done</span></span></code> </pre> </div></div><br><p>  Adem√°s del hecho de que funciona inaceptablemente lento, no hay subprocesos normales en bash, los trabajos de bash son procesos independientes, y tuve que registrar el valor de los paquetes que faltan en el efecto secundario una vez por segundo (cuando recibo mensajes de tasa de bits que vienen cada segundo).  Como resultado, bash se qued√≥ solo y se decidi√≥ escribir un contenedor (analizador + agregador) en golang.  El consumo de CPU de un c√≥digo de golang similar es 4-5 veces menor que el proceso tsp en s√≠.  Acelerar el contenedor reemplazando bash con golang result√≥ ser unas 16 veces y, en general, el resultado es aceptable (sobrecarga en la CPU en un 25% en el peor de los casos).  El archivo fuente en Golang est√° <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">aqu√≠</a> . </p><br><h3 id="zapusk-obyortki">  Lanzamiento del envoltorio </h3><br><p>  Para ejecutar el contenedor, se cre√≥ la plantilla de servicio m√°s simple para systemd ( <a href="https://github.com/inheb/tsduck-stat/tree/master/systemd" rel="nofollow">aqu√≠</a> ).  Se supone que el contenedor en s√≠ est√° compilado en un archivo binario (vaya a construir tsduck-stat.go), ubicado en / opt / tsduck-stat /.  Se supone que golang se usa con soporte para reloj monot√≥nico (&gt; = 1.9). </p><br><p>  Para crear una instancia del servicio, debe ejecutar el comando systemctl enable tsduck-stat@239.0.0.1: 1234, luego comenzar a usar systemctl start tsduck-stat@239.0.0.1: 1234. </p><br><h3 id="discovery-iz-zabbix">  Descubrimiento de Zabbix </h3><br><p>  Para que zabbix pueda descubrir servicios en ejecuci√≥n, se ha creado un <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">generador de lista de grupo</a> (discovery.sh), en el formato necesario para el descubrimiento de Zabbix, se supone que est√° ubicado all√≠, en / opt / tsduck-stat.  Para iniciar el descubrimiento a trav√©s de zabbix-agent, debe agregar el <a href="" rel="nofollow">archivo .conf</a> al directorio con las configuraciones de zabbix-agent para agregar el par√°metro de usuario. </p><br><h3 id="shablon-zabbix">  Plantilla Zabbix </h3><br><p>  <a href="https://github.com/inheb/tsduck-stat/tree/master/zabbix_templates" rel="nofollow">La plantilla creada</a> (tsduck_stat_template.xml) contiene la regla de detecci√≥n autom√°tica, prototipos de elementos de datos, gr√°ficos y disparadores. </p><br><h2 id="kratkiy-cheklist-nu-a-vdrug-kto-to-reshit-vospolzovatsya">  Una breve lista de verificaci√≥n (bueno, ¬øy si alguien decide usarla?) </h2><br><ol><li>  Aseg√∫rese de que tsp no deje caer paquetes en condiciones "ideales" (el generador y el analizador est√°n conectados directamente), si hay ca√≠das, consulte la secci√≥n 2 o el texto del art√≠culo sobre este tema. </li><li>  Realice el ajuste del b√∫fer de socket m√°ximo (net.core.rmem_max = 8388608). </li><li>  Compile tsduck-stat.go (vaya a construir tsduck-stat.go). </li><li>  Coloque la plantilla de servicio en / lib / systemd / system. </li><li>  Inicie los servicios usando systemctl, verifique que los contadores comenzaron a aparecer (grep "" / dev / shm / tsduck-stat / *).  N√∫mero de servicios por el n√∫mero de flujos de multidifusi√≥n.  Aqu√≠ puede que necesite crear una ruta al grupo de multidifusi√≥n, tal vez apague rp_filter o cree una ruta a la fuente ip. </li><li>  Ejecute discovery.sh, aseg√∫rese de que genera json. </li><li>  Adjunte la configuraci√≥n del agente zabbix, reinicie el agente zabbix. </li><li>  Descargue la plantilla en zabbix, apl√≠quela al host en el que se supervisa e instala zabbix-agent, espere unos 5 minutos, vea que han aparecido nuevos elementos de datos, gr√°ficos y disparadores. </li></ol><br><h2 id="rezultat">  Resultado </h2><br><p><img src="https://habrastorage.org/webt/ug/rc/5c/ugrc5c87ctd6rylequ7kdha5lze.png" alt="Gr√°ficos con bitrate y errores CC"></p><br><p>  Para la tarea de detectar la p√©rdida de paquetes es casi suficiente, al menos es mejor que la falta de monitoreo. </p><br><p>  De hecho, las ‚Äúp√©rdidas‚Äù CC pueden ocurrir al pegar videoclips (hasta donde yo s√©, las inserciones se realizan en telecentros locales en la Federaci√≥n de Rusia, es decir, sin contar el contador CC), esto debe recordarse.  En las soluciones patentadas, este problema se omite parcialmente al detectar etiquetas de etiquetas SCTE-35 (si el generador de flujo las agrega). <br>  <strong>UPD: se</strong> agreg√≥ soporte para etiquetas SCTE-35 a la plantilla wrapper y zabbix </p><br><p>  Desde el punto de vista de monitorear la calidad del transporte, no hay suficiente jitter de monitoreo (IAT), porque  El equipo de TV (ya sean moduladores o dispositivos finales) tiene requisitos para este par√°metro y no siempre es posible inflar jitbuffer hasta el infinito.  Y la fluctuaci√≥n de fase puede flotar cuando se utiliza equipo con grandes amortiguadores en tr√°nsito y la QoS no est√° configurada o no est√° bien configurada para transmitir dicho tr√°fico en tiempo real. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482736/">https://habr.com/ru/post/482736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482718/index.html">Pir√°mide invertida como final de su proyecto.</a></li>
<li><a href="../482722/index.html">Fant√°stica historia "Proyecto C. Vanidad de vanidades" (10 min.)</a></li>
<li><a href="../482726/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 328 (23 y 29 de diciembre)</a></li>
<li><a href="../482730/index.html">Encuesta de vacaciones</a></li>
<li><a href="../482734/index.html">Ofuscaci√≥n en tiempo de compilaci√≥n usando NAND / NOR</a></li>
<li><a href="../482740/index.html">Entrevista para el puesto de poeta</a></li>
<li><a href="../482742/index.html">Entrar en el mercado occidental: c√≥mo interactuar con los clientes</a></li>
<li><a href="../482744/index.html">Encontrar una bala de plata: munici√≥n inusual</a></li>
<li><a href="../482748/index.html">Crear un negocio de reserva de taxis en Dubai: ¬øC√≥mo lanzar una aplicaci√≥n de taxi centrada en el cliente como Careem & Hala?</a></li>
<li><a href="../482752/index.html">"Nuevas epopeyas". Comemos el elefante en partes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>