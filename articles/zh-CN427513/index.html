<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♊️ 👇🏼 💃🏾 如何分析线程转储 ☃️ 👨‍👦‍👦 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java Developer课程程序中有很多关于JVM内部的主题。 我们了解收集，字节码，垃圾收集器等的工作机制。 今天，我们将您的注意力转移到一篇有关线程转储的相当有趣的文章的翻译上。 它是什么，如何获得以及如何使用。 

 是否想学习如何分析线程转储？ 深入了解如何在Java中获取线程转储以及以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何分析线程转储</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java Developer</a>课程程序中有很多关于JVM内部的主题。</i>  <i>我们了解收集，字节码，垃圾收集器等的工作机制。</i>  <i>今天，我们将您的注意力转移到一篇有关线程转储的相当有趣的文章的翻译上。</i>  <i>它是什么，如何获得以及如何使用。</i> <br><br> 是否想学习如何分析线程转储？ 深入了解如何在Java中获取线程转储以及以后如何使用它。 <br><a name="habracut"></a><br> 大多数现代Java应用程序都是多线程的。 多线程可以显着扩展应用程序的功能，同时又会带来极大的复杂性。 <br><br> 在单线程应用程序中，可以使用所有资源（共享内存，输入/输出操作等）而无需同步，因为 在任何给定时间，只有一个线程使用该资源。 <br><br> 对于多线程应用程序，当多个线程可以使用所有可用的（通常不止一个）核心处理器（CPU）时，有必要在使程序复杂化和可能提高性能之间找到折衷方案。 如果一切都正确完成，则使用多线程（在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阿姆达尔定律中</a>正式化），可以显着提高应用程序性能。 但是，必须记住要同时提供多个流对共享资源的访问。 在大多数情况下，诸如Spring之类的框架封装了线程，并向用户隐藏了许多技术细节。 但是，在使用现代复杂框架的情况下，可能会出问题，并且作为用户的我们将遇到难以解决的多线程错误。 <br><br> 幸运的是，Java配备了一种特殊的机制，可以在任何给定的时间获取有关所有线程的当前状态的信息-这是线程转储（一种快照）。 在本文中，我们将学习如何为实际大小的应用程序获取线程转储，以及如何分析此转储。 <br><br> 假定读者具有有关多线程编程的基本信息，并且了解线程同步和共享资源使用的问题。 但是，刷新一些基本术语和概念并不是多余的。 <br><br><h4> 基本术语 </h4><br> 乍一看，Java线程转储可能看起来像“中文字母”，以下概念是理解它的关键。 通常，让我们重复多线程的基本术语，这些术语将用于分析转储。 <br><br><ul><li> <strong>线程</strong>或线程是由Java虚拟机（JVM）管理的离散多线程单元。  JVM线程对应于操作系统（OS）中的线程-本机线程，它们实现代码执行机制。 <br><br> 每个线程都有唯一的标识符和名称。 流可以是“恶魔”和“不是恶魔”。 <br><br> 当所有非守护进程线程终止或<i>调用Runtime.exit</i>方法时，程序终止。 工作的“守护程序”不会影响程序的完成。 即  JVM等待所有“非守护程序”完成并关闭；他们没有注意“非守护程序”。 <br><br> 有关更多信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Thread类</a>文档。 <br> 流可能处于以下状态之一： <br><br><ul><li>  <strong>活动线程</strong>或“活动”线程-可以完成某些工作的线程（正常状态）。 </li><li>  <strong>阻塞线程</strong>或“阻塞”-试图进入同步部分（已同步）的线程，但另一个线程已经设法先进入此块，并且随后所有尝试进入同一块的线程均被阻塞。 </li><li>  <strong>等待线程</strong>或“等待”-一个线程，调用了<i>wait</i>方法（可能带有超时），现在正在等待另一个方法在同一对象上执行<i>notify</i>或<i>nonifyAll</i> 。 <br><br> 请注意，如果线程调用带有超时的等待并且该超时已过期，则该线程不被视为“等待”。 </li><li>  <strong>正在休眠的线程</strong>或“正在休眠”的线程-当前未运行的线程，因为 执行Thread.sleep方法（指示“睡眠”的持续时间）。 </li></ul></li><li>  <strong>Monitor</strong>是JVM使用的一种机制，用于提供对单个对象的多线程访问。 该机制使用特殊的<i>synced关键字</i>启动。 <br><br>  Java中的每个对象都有一个可以与线程同步的监视器，即 设置一个锁，以确保在释放该锁之前，没有其他线程可以访问该对象，即 线程-锁的所有者不会退出<i>同步</i>块。 <br><br> 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多信息，</a>请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java语言规范（JLS）</a>的“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">同步”部分（17.1）</a> 。 <br></li><li>  <strong>死锁</strong>是指一个线程（例如A）阻塞了一个资源，它需要另一个被另一个线程（例如B）所阻塞的资源。流B不会释放该资源，因为 为了完成某个操作，他需要一个被线程A阻塞的资源。事实证明，线程A正在等待资源被线程B解锁，后者正在等待另一个资源被线程A解锁。因此，线程正在互相等待。 结果，整个程序挂起并等待线程以某种方式解锁并继续工作。 死锁中可能有许多线程。 这个问题被称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“用餐哲学家的问题”。</a> <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>活锁</strong>是一种情况，线程A迫使线程B执行某些操作，这又使线程A执行初始操作，这又导致线程B进行操作。获得了循环依赖性。 可以想象这是一条狗追尾。 与<i>死锁</i>类似，在Livelock情况下，程序不会进展，即 不会执行有用的操作，但是，在这种情况下，不会阻塞线程。 <br></li></ul><br> 所提供的术语在描述多线程领域时并不详尽，但这足以开始分析线程转储。 <br><br> 可在以下资源中找到更多详细信息： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《 JLS</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Java并发实践》</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第17节</a> <br><br> 使用这些关于Java中流程的简单概念，我们可以创建一个测试应用程序。 对于此应用程序，我们将编译线程转储。 我们将分析产生的转储，并提取有关当前应用程序流的有用信息。 <br><br><h4> 创建一个示例程序 </h4><br> 在创建线程转储之前，我们需要开发一个Java应用程序。 传统的“你好，世界！” 对于我们的目的而言太简单了，而应用程序的中型转储可能太复杂而无法演示。 基于此，我们将创建一个相当简单的应用程序，在其中创建两个线程。 线程陷入僵局： <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br> 该程序创建两个资源：resourceA和resourceB，并启动两个线程：threadLockingResourceAFirst和threadLockingResourceBFirst，这两个线程彼此阻塞。 <br><br> 死锁的原因是线程对资源的“交叉”阻塞。 <br><br> 发生死锁的原因是试图“相互”占用资源，即  threadLockingResourceAFirst线程捕获resourceA资源，threadLockingResourceBFirst线程捕获resourceB资源。 之后，threadLockingResourceAFirst在不释放资源的情况下尝试捕获resourceB，threadLockingResourceBFirst在不释放资源的情况下尝试捕获resourceA。 结果，线程被阻塞。 添加了1s延迟以保证阻塞。 线程正在等待释放必要的资源，但这永远不会发生。 <br><br> 程序的输出将如下所示（每次启动时java.lang.Object @之后的数字将不同）： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br> 这些消息输出后，程序看起来像正在运行（执行该程序的过程尚未完成），而程序则不执行任何工作。 这就是实践中的僵局。 要解决该问题，我们需要手动创建一个踩踏转储并分析线程的状态。 <br><br><h4> 线程转储生成 </h4><br> 实际上，创建线程转储时Java程序可能会崩溃。 但是，在某些情况下（例如，在出现死锁的情况下），该程序不会结束，并且不会创建线程转储，而只是挂起。 要创建此类挂起程序的转储，首先，您需要找出程序进程的标识符，即 进程ID（PID）。 为此，您可以使用JVM Process Status（JPS）实用程序，该实用程序从版本7开始，是Java Development Kit（JDK）的一部分。 要找到我们挂起的程序的进程PID，我们只需在终端（Windows或Linux）中执行jps： <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br> 第一列是正在运行的Java进程的本地虚拟机的标识符（本地VM ID，即lvmid）。 在本地JVM的上下文中，lvmid指向Java进程的PID。 <br><br> 应当注意，该值可能与上述值不同。 第二列是应用程序的名称，它可以指向主类，jar文件的名称，或者等于“ Unknown”。 这完全取决于应用程序的启动方式。 <br><br> 在我们的例子中，应用程序名称DeadlockProgram是程序启动时启动的主要类的名称。 在上面的程序11568的PID的示例中，此信息足以生成线程转储。 要生成转储，我们将从版本7开始使用<strong>jstack</strong>实用程序，它是JDK的一部分。要获取转储，我们将程序的PID <strong>传递</strong>给<strong>jstack</strong>并指定-l标志（创建长列表）。 该实用程序的输出将重定向到文本文件，即  thread_dump.txt： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br> 生成的thread_dump.txt文件包含已挂起程序的线程转储，并包含用于诊断死锁原因的重要信息。 <br><br> 如果JDK在版本7之前使用，则可以使用Linux实用程序-带有-3标志的<strong>kill</strong>生成转储。 调用kill -3将向程序发送SIGQUIT信号。 <br><br> 在我们的情况下，调用将如下所示： <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4> 简单线程转储分析 </h4><br> 打开thread_dump.txt文件，我们将看到以下内容： <br><br><pre> 2018-06-19 16:44:44
全线程转储Java HotSpot（TM）64位服务器VM（10.0.1 + 10混合模式）：
线程类SMR信息：
 _java_thread_list = 0x00000250e5488a00，长度= 13，元素= {
 0x00000250e4979000、0x00000250e4982800、0x00000250e52f2800、0x00000250e4992800，
 0x00000250e4995800、0x00000250e49a5800、0x00000250e49ae800、0x00000250e5324000，
 0x00000250e54cd800、0x00000250e54cf000、0x00000250e54d1800、0x00000250e54d2000，
 0x00000250e54d0800
 }
 “引用处理程序”＃2守护程序prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28等待条件[0x000000b82a9ff000]
    java.lang.Thread.State：RUNNABLE
    在java.lang.ref.Reference.waitForReferencePendingList（java.base@10.0.1/Native方法）
    在java.lang.ref.Reference.processPendingReferences（java.base@10.0.1/Reference.java：174）
    在java.lang.ref.Reference.access $ 000（java.base@10.0.1/Reference.java：44）
    在java.lang.ref.Reference $ ReferenceHandler.run（java.base@10.0.1/Reference.java：138）
   锁定的可拥有同步器：
     -无
 “最终化器”＃3守护程序prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 in Object.wait（）[0x000000b82aaff000]
    java.lang.Thread.State：等待（在对象监视器上）
    在java.lang.Object.wait（java.base@10.0.1/Native方法）
     -等待&lt;0x0000000089509410&gt;（java.lang.ref.ReferenceQueue $ Lock）
    在java.lang.ref.ReferenceQueue.remove（java.base@10.0.1/ReferenceQueue.java：151）
     -等待重新锁定wait（）&lt;0x0000000089509410&gt;（java.lang.ref.ReferenceQueue $ Lock）
    在java.lang.ref.ReferenceQueue.remove（java.base@10.0.1/ReferenceQueue.java：172）
    在java.lang.ref.Finalizer $ FinalizerThread.run（java.base@10.0.1/Finalizer.java：216）
   锁定的可拥有同步器：
     -无
 “信号调度程序”＃4守护程序prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184可运行[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   锁定的可拥有同步器：
     -无
 “附加侦听器”＃5守护程序prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624等待条件[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   锁定的可拥有同步器：
     -无
 “ C2 CompilerThread0”＃6守护程序prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198等待条件[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   没有编译任务
   锁定的可拥有同步器：
     -无
 “ C2 CompilerThread1”＃7守护程序prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98等待条件[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   没有编译任务
   锁定的可拥有同步器：
     -无
 “ C1 CompilerThread2”＃8守护程序prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84等待条件[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   没有编译任务
   锁定的可拥有同步器：
     -无
 “清除线程”＃9守护程序prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0可运行[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   锁定的可拥有同步器：
     -无
 “服务线程”＃10守护程序prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c可运行[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   锁定的可拥有同步器：
     -无
 “ Common-Cleaner”＃11守护程序prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 in Object.wait（）[0x000000b82b2fe000]
    java.lang.Thread.State：TIMED_WAITING（在对象监视器上）
    在java.lang.Object.wait（java.base@10.0.1/Native方法）
     -等待&lt;0x000000008943e600&gt;（java.lang.ref.ReferenceQueue $ Lock）
    在java.lang.ref.ReferenceQueue.remove（java.base@10.0.1/ReferenceQueue.java：151）
     -等待重新锁定wait（）&lt;0x000000008943e600&gt;（java.lang.ref.ReferenceQueue $ Lock）
    在jdk.internal.ref.CleanerImpl.run（java.base@10.0.1/CleanerImpl.java：148）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
    在jdk.internal.misc.InnocuousThread.run（java.base@10.0.1/InnocuousThread.java：134）
   锁定的可拥有同步器：
     -无
 “线程-0”＃12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec等待监视器条目[0x000000b82b4ff000]
    java.lang.Thread.State：已阻止（在对象监视器上）
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
   锁定的可拥有同步器：
     -无
 “ Thread-1”＃13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c等待监视器条目[0x000000b82b5ff000]
    java.lang.Thread.State：已阻止（在对象监视器上）
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
   锁定的可拥有同步器：
     -无
 “ DestroyJavaVM”＃14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c等待条件[0x0000000000000000]
    java.lang.Thread.State：RUNNABLE
   锁定的可拥有同步器：
     -无
 “ VM线程” os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920可运行  
 “ GC线程号0” os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c可运行  
 “ GC线程＃1” os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4可运行  
 “ GC线程＃2” os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8可运行  
 “ GC线程＃3” os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0可运行  
 “ G1主标记” os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068可运行  
 “ G1 Conc＃0” os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28可运行  
 “ G1优化＃0” os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c可运行  
 “ G1优化＃1” os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890可运行  
 “ G1优化＃2” os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8可运行  
 “ G1优化＃3” os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00可运行  
 “ G1 Young RemSet采样” os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4可运行  
 “ VM定期任务线程” os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468等待条件  
 JNI全球参考：2
发现了一个Java级死锁：
 ==============================
 “线程-0”：
  等待锁定监视器0x00000250e4982480（对象0x00000000894465b0，一个java.lang.Object），
  由“ Thread-1”持有
 “线程1”：
  等待锁定监视器0x00000250e4982380（对象0x00000000894465a0，一个java.lang.Object），
  由“线程-0”持有
上面列出的线程的Java堆栈信息：
 ==================================================== =
 “线程-0”：
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
 “线程1”：
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
发现1个死锁。
</pre><br><h3> 介绍性信息 </h3><br> 尽管乍看之下该文件似乎过于复杂和混乱，但实际上，如果逐步将其分解，则相当简单。 <br><br> 第一行表示转储形成的时间，第二行-有关在其上接收到转储的JVM的诊断信息： <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br> 本节中没有流信息。 此处设置了收集转储的系统的一般上下文。 <br><br><h4> 一般流程信息 </h4><br> 以下部分提供有关转储收集时系统中正在运行的线程的信息： <br><br><pre>线程类SMR信息：
 _java_thread_list = 0x00000250e5488a00，长度= 13，元素= {
 0x00000250e4979000、0x00000250e4982800、0x00000250e52f2800、0x00000250e4992800，
 0x00000250e4995800、0x00000250e49a5800、0x00000250e49ae800、0x00000250e5324000，
 0x00000250e54cd800、0x00000250e54cf000、0x00000250e54d1800、0x00000250e54d2000，
 0x00000250e54d0800
 }
</pre><br> 以下部分列出： <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安全内存回收（SMR）信息</a> <br><br> 它包含有关JVM外部线程的信息，即 这些不是虚拟机线程或垃圾回收线程。 如果查看这些线程的地址，则会注意到它们与<i>tid</i>的值相对应<i>-tid</i>的值-操作系统中的“自然铁”（本机）地址，而不是线程ID。 <br><br> 省略号用于隐藏冗余信息： <br><br><pre> “引用处理程序”＃2 ... tid = 0x00000250e4979000 ...
 “终结器”＃3 ... tid = 0x00000250e4982800 ...
 “信号调度器”＃4 ... tid = 0x00000250e52f2800 ...
 “附加监听器”＃5 ... tid = 0x00000250e4992800 ...
 “ C2 CompilerThread0”＃6 ... tid = 0x00000250e4995800 ...
 “ C2 CompilerThread1”＃7 ... tid = 0x00000250e49a5800 ...
 “ C1 CompilerThread2”＃8 ... tid = 0x00000250e49ae800 ...
 “清除线程”＃9 ... tid = 0x00000250e5324000 ...
 “服务线程”＃10 ... tid = 0x00000250e54cd800 ...
 “通用清洁器”＃11 ... tid = 0x00000250e54cf000 ...
 “线程-0”＃12 ... tid = 0x00000250e54d1800 ...
 “线程-1”＃13 ... tid = 0x00000250e54d2000 ...
 “ DestroyJavaVM”＃14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3> 流 </h3><br> 在SMR块之后是线程列表。 我们列表中的第一个线程是引用处理程序： <br><br><pre> “引用处理程序”＃2守护程序prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28等待条件[0x000000b82a9ff000]
    java.lang.Thread.State：RUNNABLE
    在java.lang.ref.Reference.waitForReferencePendingList（java.base@10.0.1/Native方法）
    在java.lang.ref.Reference.processPendingReferences（java.base@10.0.1/Reference.java：174）
    在java.lang.ref.Reference.access $ 000（java.base@10.0.1/Reference.java：44）
    在java.lang.ref.Reference $ ReferenceHandler.run（java.base@10.0.1/Reference.java：138）
   锁定的可拥有同步器：
     -无
</pre><br><h4> 流的简短描述 </h4><br> 每个线程的第一行提供了一般说明。 说明包含以下各项： <br><table><tbody><tr><th width="70"> 部分 </th><th width="100"> 例子 </th><th> 内容描述 </th></tr><tr><td> 名称 </td><td>  “引用处理程序” </td><td> 可读流名称。 可以通过调用<i>Thread</i>对象的<i>setName</i>方法来指定名称。 并通过调用<i>getName</i> </td></tr><tr><td> 编号 </td><td>  ＃2 </td><td> 分配给<i>Thread</i>类的每个对象的唯一ID。 为系统中的线程生成ID。 初始值为1。每个新创建的线程都分配有其自己的ID，该ID之前已增加1。可以使用<i>Thread</i>类<i>的</i>对象的<i>getId</i>函数获得此只读线程属性。 </td></tr><tr><td> 守护程序状态 </td><td> 守护程序 </td><td> 该标志表明线程是恶魔。 如果是恶魔，则将设置标志。 例如，线程<i>-0</i>不是守护程序。 </td></tr><tr><td> 优先权 </td><td>  prio = 10 </td><td>  Java流的数字优先级。 请注意，此优先级不一定与操作系统中关联线程的优先级相对应。 要设置优先级，您可以 <br> 使用<i>Thread</i>类<i>的</i>对象的<i>setPriority</i>方法并获取 <br>  <i>getPriority</i>方法。 </td></tr><tr><td> 操作系统线程优先级 </td><td>  os_prio = 2 </td><td> 操作系统中的优先线程。 该优先级可能与分配给链接的Java线程的优先级不同。 </td></tr><tr><td> 住址 </td><td>  tid = 0x00000250e4979000 </td><td>  Java流的地址。 该地址是<i>Thread</i>类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Java本机接口（JNI）</a>本机对象的指针<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">（</a>通过JNI连接到Java线程的C ++ <i>Thread</i>对象）。 该值是通过将指针投射到此值而获得的 <br>  （与此Java线程关联的C ++对象）为整数。 见 <br>  <a href="">热点/共享/运行时/thread.cpp中的第879行</a> ： <br><pre> st-&gt; print（“ tid =” INTPTR_FORMAT“”，p2i（this））;
</pre><br> 尽管此对象的键（ <i>tid</i> ）看起来像流ID， <br> 实际上，这是<i>JNI C ++线程</i>连接对象的地址，而不是 <br> 返回Java <i>线程</i>的<i>getId</i>方法。 </td></tr><tr><td> 操作系统线程ID </td><td>  nid = 0x3c28 </td><td>  Java线程绑定到的操作系统线程的唯一标识符。 <br> 该值使用以下代码输出： <br>  <a href="">热点/共享/运行时/osThread.cpp中的第42行</a> ： <br><pre> st-&gt; print（“ nid = 0x％x”，thread_id（））;
</pre><br></td></tr><tr><td> 现况 </td><td> 等待条件 </td><td> 当前线程的可读状态。 <br> 此行显示有关流的简单状态的其他信息（请参见下文），可以是 <br> 用于了解线程将要做什么（即线程是否试图获取锁） <br> 或等待解锁条件得到满足）。 </td></tr><tr><td> 最新的Java堆栈指针 </td><td>  [0x000000b82a9ff000] </td><td> 与此流关联的最后一个已知的堆栈指针（SP）。 <br> 该值是使用本机C ++代码和使用JNI的Java代码混合获得的。 该值由函数<i>last_Java_sp（）</i>返回， <br>  <a href="">热点/共享/运行时/ thread.cpp中的第2886行</a> ： <br><pre>   st-&gt; print_cr（“ [” INTPTR_FORMAT“]”， 
     （intptr_t）last_Java_sp（）＆〜right_n_bits（12））;
</pre><br> 对于简单的线程转储，此信息几乎没有用。 但是，在复杂情况下，SP可能会 <br> 用于跟踪锁。 </td></tr></tbody></table><br><h4> 流状态 </h4><br> 第二行是流的当前状态。 枚举列出了可能的流状态： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Thread.State</a> ： <br><br> 新品 <br> 可运行 <br> 封锁 <br> 等待中 <br>  TIMED_WAITING <br> 已终止 <br><br> 有关更多详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">文档</a> 。 <br><br><h4> 线程堆栈跟踪 </h4><br> 下一部分包含进行转储时流的堆栈跟踪。 此堆栈跟踪与未捕获的异常引发的堆栈跟踪非常相似。 它包含转储形成时执行的类和字符串的名称。 对于引用处理程序流，我们看不到任何有趣的东西。 <br><br> 但是，关于Thread-02线程跟踪，有一点与标准跟踪不同： <br><br><pre> “线程-0”＃12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec等待监视器条目[0x000000b82b4ff000]
    java.lang.Thread.State：已阻止（在对象监视器上）
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
   锁定的可拥有同步器：
     -无
</pre><br> 在跟踪中，我们看到已添加了有关锁的信息。 该线程期望对地址为0x00000000894465b0（对象类型为java.lang.Object）的对象进行锁定。 此外，线程本身持有地址为0x00000000894465a0的锁（也是java.lang.Object）。 此信息对以后对死锁的诊断很有用。 <br><br><h4> 捕获的同步原语（可拥有的同步器） </h4><br> 最后一部分列出了流捕获的同步原语。 这些是可用于同步线程（例如锁）的对象。 <br><br> 根据Java的官方文档， <strong>Ownable Synchronizer</strong>是<i>AbstractOwnableSynchronizer</i> （或其子类）的后代，该流可以为同步目的而专门捕获它。 <br><br>  <i>ReentrantLock</i>和<i>write-lock</i>而不是<i>ReentrantReadWriteLock</i>类的<i>读取锁</i>是平台提供的此类“拥有的同步器”的两个很好的示例。 <br><br> 有关此主题的更多信息，您可以参考此 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">发布</a> 。 <br><br><h4>  JVM线程 </h4><br> 转储的下一部分包含有关JVM技术线程的信息，这些信息不是应用程序的一部分，而是与操作系统线程相关联的。 因为 这些流在应用程序外部工作，它们没有流标识符。 通常，这些是垃圾收集器线程和其他技术JVM线程： <br><br><pre> “ VM线程” os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920可运行  
 “ GC线程号0” os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c可运行  
 “ GC线程＃1” os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4可运行  
 “ GC线程＃2” os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8可运行  
 “ GC线程＃3” os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0可运行  
 “ G1主标记” os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068可运行  
 “ G1 Conc＃0” os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28可运行  
 “ G1优化＃0” os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c可运行  
 “ G1优化＃1” os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890可运行  
 “ G1优化＃2” os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8可运行  
 “ G1优化＃3” os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00可运行  
 “ G1 Young RemSet采样” os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4可运行  
 “ VM定期任务线程” os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468等待条件
</pre><br><h4>  JNI全球链接 </h4><br> 本部分指示JVM通过JNI使用的全局引用数。 这些链接不由垃圾收集器提供服务，在某些情况下可能导致内存泄漏。 <br><br><pre> JNI全球参考：2
</pre><br> 在大多数简单情况下，不使用此信息。 但是，必须理解全局引用的重要性。 有关更多详细信息，请参见这篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">文章</a> 。 <br><br><h4> 死锁线程 </h4><br> 最后一部分包含有关找到的死锁的信息。 <br> 如果找不到这些，则该部分将为空。 因为 我们专门开发了一个带锁的应用程序，在本例中就是这样。 在转储期间检测到锁定，并显示以下消息： <br><br><pre>发现了一个Java级死锁：
 ==============================
 “线程-0”：
  等待锁定监视器0x00000250e4982480（对象0x00000000894465b0，一个java.lang.Object），
  由“ Thread-1”持有
 “线程1”：
  等待锁定监视器0x00000250e4982380（对象0x00000000894465a0，一个java.lang.Object），
  由“线程-0”持有
上面列出的线程的Java堆栈信息：
 ==================================================== =
 “线程-0”：
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
 “线程1”：
    在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）
     -等待锁定&lt;0x00000000894465a0&gt;（一个java.lang.Object）
     -锁定&lt;0x00000000894465b0&gt;（一个java.lang.Object）
    在java.lang.Thread.run（java.base@10.0.1/Thread.java：844）
发现1个死锁。
</pre><br> 第一部分描述死锁情况： <br><br> 线程0期望能够捕获监视器（这是对我们应用程序中的<i>synced（secondResource）</i>块的访问），与此同时，该线程持有试图捕获Thread-1的监视器（这正在访问相同的代码片段： <i>Synchronized（secondResource</i> ）。 <br><br> 将此圆形锁称为<strong>死锁</strong> 。 在下面的图片中 <br> 这种情况以图形形式表示： <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br> 在第二小节中，给出了两个阻塞线程的堆栈跟踪。 <br><br> 该堆栈跟踪使我们可以跟踪每个线程的操作，直到发生锁定为止。 <br> 在我们的例子中，如果我们看一下这一行： <br><br>  <i>在DeadlockProgram $ DeadlockRunnable.run（DeadlockProgram.java:34）中</i> ，那么我们将看到代码的问题部分： <br><br><pre> printLockedResource（secondResource）;
</pre><br> 该行是同步块的第一行，这是锁定的原因，并告诉我们，secondResource上的同步是相互锁定的原因。 为了解决这种情况，我们必须确保两个线程在资源resourceA和resourceB上具有相同的同步顺序。 如果这样做，我们将进入以下应用程序： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br> 该应用程序将在没有互锁的情况下结束，因此，我们将获得以下输出（请注意，Object类的地址已更改）： <br><br><pre>线程-0：锁定的资源-&gt; java.lang.Object@1ad895d1
线程-0：锁定的资源-&gt; java.lang.Object@6e41d7dd
线程1：锁定的资源-&gt; java.lang.Object@1ad895d1
线程1：锁定的资源-&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - — Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4> 结论 </h4><br> Thread dump- —      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           — . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump —   « »   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427513/">https://habr.com/ru/post/zh-CN427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427499/index.html">他们在视频流媒体的技术支持中写了些什么？</a></li>
<li><a href="../zh-CN427501/index.html">西摩·帕尔特（Seymour Papert）：辛苦了</a></li>
<li><a href="../zh-CN427505/index.html">推定</a></li>
<li><a href="../zh-CN427507/index.html">西摩·帕特（Seymour Papert）：“无”的美味发现</a></li>
<li><a href="../zh-CN427509/index.html">Web服务器：南桥体验和实践</a></li>
<li><a href="../zh-CN427517/index.html">最有趣的Joker 2018报告概述：EastBanc Technologies版本</a></li>
<li><a href="../zh-CN427519/index.html">@Kubernetes在Mail.Ru小组的聚会：10月29日且始终</a></li>
<li><a href="../zh-CN427521/index.html">2019年突破奖。宣布获得米尔纳奖，布林奖和扎克伯格科学奖。</a></li>
<li><a href="../zh-CN427523/index.html">对冲成功</a></li>
<li><a href="../zh-CN427525/index.html">英特尔酷睿9代的数量和基准</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>