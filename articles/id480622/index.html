<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‰ğŸ¿ ğŸ“ ğŸ» Cara menggunakan kapasitas penyimpanan yang tersedia dengan benar ğŸ¥‹ ğŸ¤¦ğŸ¾ ğŸ‘©ğŸ¾â€ğŸ¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah menggunakan layanan cloud untuk waktu yang lama: surat, penyimpanan, jejaring sosial, pesan instan. Semuanya bekerja dari jarak jauh - kami...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menggunakan kapasitas penyimpanan yang tersedia dengan benar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/480622/">  Kami telah menggunakan layanan cloud untuk waktu yang lama: surat, penyimpanan, jejaring sosial, pesan instan.  Semuanya bekerja dari jarak jauh - kami mengirim pesan dan file, dan semuanya disimpan dan diproses di server jarak jauh.  Cloud gaming juga berfungsi: pengguna terhubung ke layanan, memilih game dan meluncurkan.  Ini nyaman bagi pemain, karena permainan mulai hampir seketika, tidak memakan memori, dan tidak membutuhkan komputer gaming yang kuat. <br><br><img src="https://habrastorage.org/webt/ej/k4/oy/ejk4oyjjh1r3riqgzzd239qu_va.jpeg"><br><br>  Untuk layanan cloud, semuanya berbeda - ia memiliki masalah penyimpanan data.  Setiap permainan dapat berbobot puluhan atau ratusan gigabyte, misalnya, "The Witcher 3" membutuhkan 50 GB, dan "Call of Duty: Black Ops III" - 113. Pada saat yang sama, pemain tidak akan menggunakan layanan dengan 2-3 game, setidaknya beberapa lusinan diperlukan .  Selain menyimpan ratusan game, layanan ini perlu memutuskan berapa banyak penyimpanan yang harus dialokasikan per pemain, dan skala ketika ada ribuan dari mereka. <br><br>  Haruskah semua ini disimpan di server mereka: berapa banyak yang mereka butuhkan, di mana menempatkan pusat data, bagaimana cara "menyinkronkan" data antara beberapa pusat data dengan cepat?  Beli "awan"?  Gunakan mesin virtual?  Apakah mungkin untuk menyimpan data pengguna dengan kompresi 5 kali dan menyediakannya secara real-time?  Bagaimana cara mengecualikan pengaruh pengguna terhadap satu sama lain selama penggunaan mesin virtual yang sama secara konsisten? <br><br>  Semua tugas ini berhasil diselesaikan di Playkey.net - platform game berbasis cloud.  <strong>Vladimir Ryabov</strong> ( <a href="https://habr.com/ru/users/graymansama/" class="user_link">Graymansama</a> ) - kepala departemen administrasi sistem - akan berbicara secara rinci tentang teknologi ZFS untuk FreeBSD, yang membantu dalam hal ini, dan garpu baru ZOL (ZFS di Linux). <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SssLwMbMrQ4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Seribu server perusahaan berlokasi di pusat data jarak jauh di Moskow, London dan Frankfurt.  Ada lebih dari 250 game dalam layanan ini, yang dimainkan oleh 100 ribu pemain sebulan. <br><br><img src="https://habrastorage.org/webt/s6/mv/nw/s6mvnwi5z_b5ltjl_vico2x7ro4.jpeg"><br><br>  Layanan berfungsi seperti ini: permainan berjalan di server perusahaan, pengguna menerima aliran kontrol dari keyboard, mouse atau gamepad, dan aliran video dikirim sebagai tanggapan.  Hal ini memungkinkan Anda untuk memainkan game top-end modern di komputer dengan perangkat keras yang lemah, laptop dengan video terintegrasi, atau di Mac yang tidak dirilis sama sekali untuk game-game ini. <br><br><h2>  Game harus disimpan dan diperbarui </h2><br>  Data utama untuk layanan cloud gaming adalah distribusi game, yang dapat melebihi ratusan GB, dan menghemat pengguna. <br><br>  Ketika kami masih kecil, kami hanya memiliki selusin server dan katalog sederhana 50 game.  Kami menyimpan semua data secara lokal di server, diperbarui secara manual, semuanya baik-baik saja.  Tetapi waktunya telah tiba untuk tumbuh dan kami berangkat <strong>ke awan AWS</strong> . <br><br>  Dengan AWS, kami mendapat beberapa ratus server, tetapi arsitekturnya tidak berubah.  Mereka juga server, tetapi sekarang virtual, dengan disk lokal di mana distribusi permainan berada.  Namun, memperbarui secara manual pada seratus server akan gagal. <br><br>  Kami mulai mencari solusi.  Awalnya kami mencoba memperbarui melalui <strong>rsync</strong> .  Tetapi ternyata ini sangat lambat, dan beban pada simpul utama terlalu banyak.  Tetapi ini bahkan bukan yang terburuk: ketika kami memiliki online rendah, kami mematikan beberapa mesin virtual agar tidak membayar untuk mereka, dan ketika memperbarui, data tidak dituangkan ke server yang dimatikan.  Semuanya dibiarkan tanpa pembaruan. <br><br>  Solusinya adalah torrent - program <strong>BTSync</strong> .  Ini memungkinkan Anda untuk menyinkronkan folder pada sejumlah besar node tanpa secara eksplisit menentukan node pusat. <br><br><h2>  Masalah pertumbuhan </h2><br>  Untuk sementara, semua ini bekerja dengan sangat baik.  Tetapi layanan ini berkembang, ada lebih banyak game dan server.  Jumlah penyimpanan lokal juga meningkat, kami harus membayar lebih dan lebih.  Di awan itu mahal, terutama untuk SSD.  Pada satu titik, bahkan pengindeksan folder biasa untuk memulai sinkronisasi mulai memakan waktu lebih dari satu jam, dan semua server dapat diperbarui selama beberapa hari. <br><br>  BTSync telah menciptakan masalah lain dengan lalu lintas jaringan yang berlebihan.  Pada saat itu, di Amazon dibayar bahkan di antara virtual internal.  Jika peluncur game klasik membuat perubahan kecil pada file besar, maka BTSync segera percaya bahwa seluruh file telah berubah, dan mulai mentransfer sepenuhnya ke semua node.  Akibatnya, bahkan pemutakhiran 15 MB dapat menghasilkan puluhan GB lalu lintas sinkronisasi. <br><br>  Situasi menjadi kritis ketika penyimpanan tumbuh menjadi 1 TB.  Baru saja merilis game baru World of Warships.  Distribusinya memiliki beberapa ratus ribu file kecil.  BTSync tidak dapat mencernanya dan mendistribusikannya ke semua server lain - ini memperlambat distribusi game lain. <br><br>  Semua faktor ini menciptakan dua masalah: <br><br><ul><li>  menghasilkan penyimpanan lokal mahal, tidak nyaman dan sulit diperbarui; </li><li>  awannya sangat mahal. </li></ul><br>  Kami memutuskan untuk kembali ke konsep server fisik kami. <br><br><h2>  Sistem penyimpanan sendiri </h2><br>  Sebelum pindah ke server fisik, kita harus menyingkirkan penyimpanan lokal.  Ini membutuhkan <strong>sistem penyimpanannya</strong> sendiri <strong>- penyimpanan</strong> .  Ini adalah sistem yang menyimpan semua distribusi dan mendistribusikannya secara terpusat ke semua server. <br><br>  Tampaknya tugasnya sederhana - sudah berulang kali diselesaikan.  Namun dengan game ada nuansa.  Misalnya, sebagian besar gim hanya menolak untuk bekerja jika diberi akses hanya baca.  Bahkan dengan start-up biasa yang biasa, mereka suka menulis sesuatu ke file mereka, dan tanpa itu mereka menolak untuk bekerja.  Sebaliknya, jika sejumlah besar pengguna diberikan akses ke satu set distribusi, mereka mulai saling mengalahkan file dengan akses kompetitif. <br><br>  Kami memikirkan masalahnya, memeriksa beberapa kemungkinan solusi, dan datang ke <strong>ZFS - Zettabyte File System di FreeBSD</strong> . <br><br><h2>  ZFS di FreeBSD </h2><br>  Ini bukan sistem file biasa.  Sistem klasik pada awalnya diinstal pada satu perangkat, dan untuk bekerja dengan beberapa disk sudah memerlukan manajer volume. <br><blockquote>  ZFS awalnya dibangun di atas kolam virtual. </blockquote>  Mereka disebut <strong>zpool</strong> dan terdiri dari grup disk atau array RAID.  Seluruh volume disk ini tersedia untuk semua sistem file di dalam zpool.  Itu karena ZFS awalnya dikembangkan sebagai sistem yang akan bekerja dengan sejumlah besar data. <br><br><h3>  Bagaimana ZFS membantu menyelesaikan masalah kami </h3><br>  Sistem ini memiliki <strong>mekanisme</strong> luar biasa <strong>untuk membuat snapshot dan klon</strong> .  Mereka dibuat secara <strong>instan</strong> , dan beratnya hanya beberapa KB.  Ketika kami membuat perubahan pada salah satu klon, itu meningkat dengan volume perubahan ini.  Pada saat yang sama, data di klon yang tersisa tidak berubah dan tetap unik.  Ini memungkinkan Anda untuk mendistribusikan disk <strong>10 TB</strong> dengan akses eksklusif ke pengguna akhir, hanya menghabiskan beberapa KB. <br><br>  Jika klon tumbuh dalam proses membuat perubahan pada sesi game, apakah mereka tidak akan mengambil ruang sebanyak semua game?  Tidak, kami menemukan bahwa bahkan dalam sesi permainan yang cukup panjang, rangkaian perubahan jarang melebihi 100-200 MB - ini tidak penting.  Oleh karena itu, kami dapat memberikan akses penuh ke hard drive berkapasitas tinggi penuh ke beberapa ratus pengguna secara bersamaan, hanya menghabiskan 10 TB dengan ekor. <br><br><h3>  Cara Kerja ZFS </h3><br>  Deskripsinya tampak rumit, tetapi ZFS bekerja cukup sederhana.  Mari kita menganalisis kerjanya dengan contoh sederhana - buat <code>zpool data</code> dari disk <code>zpool create data /dev/da /dev/db /dev/dc</code> tersedia <code>zpool create data /dev/da /dev/db /dev/dc</code> . <br><br>  <em>Catatan</em>  <em>Ini tidak diperlukan untuk produksi, karena jika setidaknya satu disk mati, seluruh kumpulan akan dilupakan.</em>  <em>Lebih baik gunakan grup RAID.</em> <br><br>  Kami membuat <code>zfs create data/games</code> sistem file <code>zfs create data/games</code> , dan di dalamnya perangkat blok dengan nama <code>data/games/disk</code> 10 TB.  Perangkat ini tersedia di <code>/dev/zvol/data/games/disk</code> sebagai disk biasa - Anda dapat melakukan manipulasi yang sama dengannya. <br><br>  Kemudian kesenangan dimulai.  Kami memberikan disk ini melalui <strong>iSCSI ke</strong> panduan pembaruan kami - mesin virtual biasa yang menjalankan Windows.  Kami menghubungkan disk, dan menempatkan game di dalamnya hanya dari Steam, seperti pada komputer di rumah biasa. <br><br>  Isi disk dengan game.  Sekarang tetap mendistribusikan data ini ke <strong>200 server</strong> untuk pengguna akhir. <br><br><ul><li>  Buat snapshot disk ini dan menyebutnya versi pertama - <code>zfs snapshot data/games/disk@ver1</code> .  <strong>Buat clone</strong> <code>zfs clone data/games/disk@ver1 data/games/disk-vm1</code> , yang akan menuju ke mesin virtual pertama. </li><li>  Kami memberikan klon melalui iSCSI dan <strong>KVM meluncurkan</strong> mesin virtual <strong>dengan disk ini</strong> .  Itu memuat, masuk ke kumpulan server yang dapat diakses untuk pengguna, dan mengharapkan pemain. </li><li>  Ketika sesi pengguna selesai, kami mengambil semua simpanan pengguna dari mesin virtual ini dan <strong>meletakkannya di server terpisah</strong> .  Kami <strong>mematikan mesin</strong> virtual <strong>dan menghancurkan klon</strong> - <code>zfs destroy data/games/disk-vm1</code> . </li><li>  Kami kembali ke langkah pertama, lagi buat klon dan mulai mesin virtual. </li></ul><br>  Ini memungkinkan kami untuk memberi setiap pengguna berikutnya <strong>mesin yang selalu bersih</strong> , yang tidak ada perubahan dari pemain sebelumnya.  Disk setelah setiap sesi pengguna dihapus, dan ruang yang ditempati pada sistem penyimpanan dibebaskan.  Kami juga melakukan operasi serupa dengan disk sistem dan dengan semua mesin virtual kami. <br><br>  Baru-baru ini, saya menemukan video di YouTube, di mana pengguna yang puas selama sesi permainan memformat hard drive kami di server, dan sangat senang bahwa dia telah merusak segalanya.  Ya, tolong, hanya untuk membayar - dia bisa bermain dan menikmati.  Bagaimanapun, pengguna berikutnya akan selalu mendapatkan mesin virtual yang bersih dan fungsional, apa pun yang dilakukan sebelumnya. <br><br>  Menurut skema ini, game hanya didistribusikan ke 200 server.  Kami menghitung angka 200 secara eksperimental: ini adalah jumlah server di mana beban kritis pada drive penyimpanan tidak terjadi.  Ini karena <strong>gim memiliki profil memuat yang agak spesifik</strong> : <strong>gim ini</strong> banyak membaca pada tahap peluncuran atau pada tahap pemuatan level, dan selama gim, sebaliknya, praktis tidak menggunakan disk.  Jika profil pemuatan Anda berbeda, maka angkanya akan berbeda. <br><br>  Dalam skema lama, untuk melayani secara simultan 200 pengguna, kami membutuhkan 2.000 TB penyimpanan lokal.  Sekarang kita dapat menghabiskan sedikit lebih dari 10 TB untuk kumpulan data utama, dan masih ada 0,5 TB dalam persediaan untuk perubahan pengguna.  Meskipun ZFS suka ketika memiliki setidaknya 15% ruang kosong di kolam renangnya, menurut saya kami telah menghemat banyak. <br><br><h3>  Bagaimana jika kita memiliki beberapa pusat data? </h3><br>  Mekanisme ini hanya akan berfungsi di dalam satu pusat data, di mana server dengan sistem penyimpanan dihubungkan oleh setidaknya 10 gigabit antarmuka.  Apa yang harus dilakukan jika ada beberapa DC?  Bagaimana cara memperbarui disk utama dengan game (dataset) di antara mereka? <br><br>  Untuk ini, ZFS memiliki solusi sendiri - <strong>mekanisme Kirim / Terima</strong> .  Perintah eksekusi sangat sederhana: <br><pre> <code class="bash hljs">zfs send -v data/games/disk@ver1 | ssh myzfsuser@myserverip zfs receive data/games/disk</code> </pre> <br>  Mekanisme ini memungkinkan Anda mentransfer dari satu sistem penyimpanan ke snapshot lain dari sistem utama.  Untuk pertama kalinya, Anda harus mengirim semua 10 terabyte data yang ditulis ke master node ke sistem penyimpanan kosong.  Tetapi dengan pembaruan berikutnya, kami hanya akan mengirim perubahan dari saat kami membuat snapshot sebelumnya. <br><br>  Sebagai hasilnya, kita mendapatkan: <br><br><ul><li>  <strong>Semua perubahan dilakukan secara terpusat pada satu sistem penyimpanan</strong> .  Kemudian mereka menyebar ke semua pusat data lainnya dalam jumlah berapapun, dan data pada semua node selalu identik. </li><li>  <strong>Mekanisme Kirim / Terima tidak takut terputus</strong> .  Data tidak diterapkan ke dataset utama sampai sepenuhnya ditransmisikan ke slave node.  Jika koneksi terputus, data tidak mungkin rusak, dan ulangi saja prosedur pengiriman. </li><li>  <strong>Setiap node dapat dengan mudah menjadi master node</strong> selama kecelakaan hanya dalam beberapa menit, karena data pada semua node selalu identik. </li></ul><br><h3>  Deduplikasi dan cadangan </h3><br>  ZFS memiliki fitur lain yang bermanfaat - <strong>deduplikasi</strong> .  Fungsi ini membantu <strong>untuk tidak menyimpan dua blok data yang identik</strong> .  Sebaliknya, hanya blok pertama yang disimpan, dan di tempat yang kedua, tautan ke yang pertama disimpan.  Dua file yang identik akan mengambil ruang sebagai satu, dan jika mereka cocok dengan 90%, mereka akan mengisi 110% dari volume aslinya. <br><br>  Fungsi ini banyak membantu kami dalam menyimpan pengguna.  Dalam satu permainan, pengguna yang berbeda memiliki penyimpanan yang serupa, banyak file yang sama.  Melalui penggunaan deduplikasi, kita dapat menyimpan data lima kali lebih banyak.  Rasio deduplikasi kami adalah 5,22.  Secara fisik, kami memiliki 4,43 terabyte, kami mengalikannya dengan faktor, dan kami mendapatkan hampir 23 terabyte data nyata.  Ini menghemat ruang dengan menghindari penyimpanan duplikat. <br><div class="scrollable-table"><table><tbody><tr><td>  NAME </td><td>  Ukuran </td><td>  ALLOC </td><td>  GRATIS </td><td>  DEDUP </td></tr><tr><td>  data </td><td>  7,16 TB </td><td>  4,43 TB </td><td>  2,73 TB </td><td>  5.22x </td></tr></tbody></table></div>  <strong>Jepretan baik untuk cadangan</strong> .  Kami menggunakan teknologi ini pada penyimpanan file kami.  Misalnya, jika Anda menyimpan satu gambar setiap hari selama sebulan, Anda dapat menggunakan klon kapan saja pada hari apa pun di bulan itu dan mengeluarkan file yang hilang atau rusak.  Ini menghilangkan kebutuhan untuk memutar kembali seluruh penyimpanan atau menggunakan salinan lengkapnya. <br><br>  <strong>Kami menggunakan klon untuk membantu pengembang kami</strong> .  Misalnya, mereka ingin mengalami migrasi yang berpotensi berbahaya di pangkalan tempur.  Tidak cepat untuk menggunakan cadangan klasik dari database yang mendekati 1 TB.  Oleh karena itu, kami cukup menghapus klon dari disk dasar dan menambahkannya secara instan ke instance baru.  Sekarang pengembang dapat dengan aman menguji semuanya di sana. <br><br><h3>  API ZFS </h3><br>  Tentu saja, semua ini harus otomatis.  Mengapa naik di server, bekerja dengan tangan Anda, menulis skrip, jika ini dapat diberikan kepada programmer?  Karena itu, kami menulis <a href="https://github.com/drook/zfsapi">API Web</a> sederhana kami. <br><br>  Kami membungkus semua fungsi ZFS standar di dalamnya, memutus akses ke yang berpotensi berbahaya dan dapat merusak seluruh sistem penyimpanan, dan memberikan semua ini kepada programmer.  Sekarang <strong>semua operasi disk secara terpusat</strong> dan dilakukan oleh kode, dan kami <strong>selalu tahu status setiap disk</strong> .  Semuanya bekerja dengan baik. <br><br><h2>  Zool - ZFS di Linux </h2><br>  Kami memusatkan sistem dan berpikir, apakah ini begitu baik?  Memang, sekarang untuk ekstensi apa pun, kita segera perlu membeli beberapa rak server: mereka terikat pada sistem penyimpanan, dan itu tidak masuk akal untuk membagi sistem.  Apa yang harus dilakukan ketika kami memutuskan untuk menggelar demo kecil untuk menunjukkan teknologi kepada mitra di negara lain? <br><br>  Berpikir, kami sampai pada ide lama - untuk <strong>menggunakan drive lokal</strong> , tetapi hanya dengan semua pengalaman dan pengetahuan yang kami terima.  Jika Anda memperluas ide secara lebih global, lalu mengapa tidak memberi pengguna kami kesempatan tidak hanya untuk menggunakan server kami, tetapi juga untuk menyewa komputer mereka? <br><br>  Garpu <strong>ZFS yang</strong> relatif baru <strong>di Linux - Zool</strong> membantu kami dalam hal ini. <br><blockquote>  Sekarang setiap server memiliki penyimpanannya sendiri. </blockquote>  Hanya itu tidak menyimpan data 10 terabyte, seperti dalam kasus instalasi terpusat, tetapi hanya 1-2 distribusi dari game yang dilayaninya.  Satu SSD sudah cukup untuk ini.  Semua ini berfungsi dengan baik: setiap pengguna berikutnya selalu mendapatkan mesin virtual yang bersih, serta pada instalasi tempur. <br><br>  Namun, di sini kami menemui dua masalah. <br><br><h3>  Bagaimana cara memperbarui? </h3><br>  <strong>Perbarui terpusat melalui SSH, seperti yang kami lakukan di pusat data tidak akan berfungsi</strong> .  Pengguna dapat terhubung ke jaringan lokal atau hanya dimatikan, tidak seperti sistem penyimpanan, dan Anda tidak ingin meningkatkan begitu banyak koneksi SSH. <br><br>  Kami mengalami masalah yang sama seperti ketika menggunakan rsync.  Namun, torrent di atas ZFS tidak lagi dapat diperoleh.  Kami dengan cermat memikirkan cara kerja mekanisme Kirim: mengirim semua blok data yang diubah ke penyimpanan akhir, di mana Receive menerapkannya ke dataset saat ini.  Mengapa tidak menulis data ke file, alih-alih mengirimnya ke pengguna akhir? <br><br>  Hasilnya adalah apa yang kita sebut <strong>diff</strong> .  Ini adalah file di mana semua blok yang diubah antara dua foto terakhir secara berurutan ditulis.  Kami meletakkan perbedaan ini pada CDN, dan mengirimkannya ke semua pengguna kami melalui HTTP: itu menghidupkan mesin, melihat bahwa ada pembaruan, kempes dan menerapkannya ke dataset lokal menggunakan Terima. <br><br><h3>  Apa yang harus dilakukan dengan driver? </h3><br>  Server terpusat memiliki konfigurasi yang sama, dan <strong>pengguna akhir selalu memiliki komputer dan kartu video yang berbeda</strong> .  Bahkan jika kita mengisi distribusi OS dengan semua driver yang mungkin sebanyak mungkin, pertama kali dimulai, ia masih ingin menginstal driver ini, maka itu akan restart, dan kemudian, mungkin, lagi.  Karena setiap kali kami memberikan klon bersih, maka semua korsel ini akan muncul setelah setiap sesi pengguna - ini buruk. <br><br>  Kami ingin menjalankan inisialisasi: tunggu hingga Windows dinyalakan, instal semua driver, lakukan semua yang diinginkannya, dan baru kemudian beroperasi pada drive ini.  Tetapi masalahnya adalah bahwa jika Anda membuat perubahan pada dataset utama, pembaruan akan pecah, karena data pada sumber dan pada penerima akan berbeda, dan diff tidak akan berlaku. <br><br>  Namun, ZFS adalah sistem yang fleksibel dan memungkinkan kami membuat penopang kecil. <br><br><ul><li>  Seperti biasa, buat snapshot: <code>zfs snapshot data/games/os@init</code> . </li><li>  Buat klonnya - <code>zfs clone data/games/os@init data/games/os-init</code> - dan jalankan dalam mode inisialisasi. </li><li>  Kami menunggu semua driver untuk menginstal dan semuanya akan reboot. </li><li>  Matikan mesin virtual dan potret kembali.  Tapi kali ini, bukan dari dataset asli, tetapi dari klon inisialisasi: <code>zfs snapshot data/games/os-init@ver1</code> . </li><li>  Kami membuat klon foto dengan semua driver yang diinstal.  Ini tidak akan lagi reboot: <code>zfs clone data/games/os-init@ver1 data/games/os-vm1</code> . </li><li>  Kemudian kami mengerjakan kelompok klasik. </li></ul><br>  Sekarang sistem ini berada pada tahap pengujian alpha.  Kami mengujinya pada pengguna sungguhan tanpa pengetahuan Linux, tetapi mereka berhasil menyebarkan semuanya di rumah.  Tujuan utama kami adalah agar setiap pengguna cukup mencolokkan USB flash drive yang dapat di-boot ke komputer mereka, sambungkan drive SSD tambahan dan menyewakannya di platform cloud kami. <br><br>  Kami hanya membahas sebagian kecil fungsi ZFS.  Sistem ini dapat melakukan banyak hal yang lebih menarik dan berbeda, tetapi hanya sedikit orang yang tahu tentang ZFS - pengguna tidak ingin membicarakannya.  Saya harap setelah artikel ini pengguna baru akan muncul di komunitas ZFS. <br><br><blockquote>  Berlangganan <a href="https://t.me/DevOpsConfChannel">saluran telegram</a> atau <a href="http://eepurl.com/bN_0E1">buletin</a> untuk mempelajari tentang artikel dan video baru dari konferensi <a href="https://devopsconf.io/">DevOpsConf</a> .  Selain buletin, kami mengumpulkan berita dari konferensi mendatang dan memberi tahu, misalnya, apa yang akan menarik bagi penggemar DevOps di <a href="https://www.highload.ru/spb/2020">Saint HighLoad ++</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480622/">https://habr.com/ru/post/id480622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480608/index.html">Rust Mengungguli C ++ dengan Hasil Game Benchmark</a></li>
<li><a href="../id480612/index.html">Buat perubahan ini untuk memenuhi standar aksesibilitas desain web.</a></li>
<li><a href="../id480614/index.html">ENUM cepat</a></li>
<li><a href="../id480618/index.html">Permainan elektronik Tic Tac Toe. Apa yang telah saya lakukan?</a></li>
<li><a href="../id480620/index.html">SD-WAN dan DNA untuk membantu administrator: fitur arsitektur dan praktik</a></li>
<li><a href="../id480626/index.html">Warisan sistem dan proses warisan atau 90 hari pertama dalam peran CTO</a></li>
<li><a href="../id480642/index.html">Pengantar Linux ELF: Memahami dan Menganalisis</a></li>
<li><a href="../id480644/index.html">Manifesto tentang penghapusan 146 KUHP dan boikot Sberbank dan pemegang hak cipta-parasit. Untuk open source dan nginx</a></li>
<li><a href="../id480646/index.html">Habr - artikel terbaik, penulis, dan statistik 2019</a></li>
<li><a href="../id480650/index.html">Rambut siapa yang lebih kuat: morfologi rambut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>