<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📙 🏴󠁧󠁢󠁳󠁣󠁴󠁿 👨‍🔬 Eksperimen Pikiran: Berkibar saat Pergi ⚙️ 👉🏽 🍱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baru-baru ini, saya menemukan Flutter - kerangka kerja baru dari Google untuk mengembangkan aplikasi mobile lintas platform - dan bahkan memiliki kese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eksperimen Pikiran: Berkibar saat Pergi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435960/"><p>  Baru-baru ini, saya menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flutter</a> - kerangka kerja baru dari Google untuk mengembangkan aplikasi mobile lintas platform - dan bahkan memiliki kesempatan untuk menunjukkan dasar-dasar Flutter kepada seseorang yang belum pernah diprogram sebelumnya.  Flutter sendiri ditulis di Dart - bahasa yang lahir di browser Chrome dan lolos ke dunia konsol - dan itu membuat saya berpikir "hmm, tapi Flutter bisa ditulis dalam Go!". </p><br><p>  Kenapa tidak  Baik Go dan Dart dibuat oleh Google, keduanya dikompilasi dengan bahasa yang dikompilasi - membalikkan beberapa peristiwa dengan sedikit berbeda, Go akan menjadi kandidat yang sangat baik untuk mengimplementasikan proyek skala besar seperti Flutter.  Seseorang akan mengatakan - tidak ada kelas, generik, dan pengecualian di Go, jadi tidak cocok. </p><br><p>  Jadi mari kita berpura-pura bahwa Flutter sudah ditulis di Go.  Bagaimana kode akan terlihat dan secara umum, apakah akan berfungsi? </p><br><p><img src="https://habrastorage.org/webt/9r/4y/cv/9r4ycvikoillhjboi5olwnta4nm.png"></p><a name="habracut"></a><br>
<h1 id="chto-ne-tak-s-dart">  Apa yang salah dengan Dart? </h1><br><p>  Saya telah mengikuti bahasa ini sejak awal sebagai alternatif untuk JavaScript di browser.  Dart dibangun ke dalam browser Chrome untuk beberapa waktu dan harapannya adalah itu akan menggantikan JS.  Sangat menyedihkan membaca pada Maret 2015 bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan Dart telah dihapus dari Chrome</a> . </p><br><p>  Dart itu sendiri luar biasa!  Yah, pada dasarnya, setelah JavaScript, bahasa apa pun hebat, tetapi setelah, katakan, Go, Dart tidak begitu indah.  tapi cukup baik.  Ini memiliki semua fitur yang mungkin dan tidak dapat dibayangkan - kelas, generik, pengecualian, futures, async-waiting, loop acara, JIT / AOT, pengumpul sampah, kelebihan fungsi - nama fitur yang dikenal dari teori bahasa pemrograman dan di Dart akan dengan proporsi tinggi probabilitas.  Dart memiliki sintaks khusus untuk hampir semua chip - sintaks khusus untuk getter / setter, sintaks khusus untuk konstruktor disingkat, sintaks khusus untuk sintaks khusus dan banyak lagi. </p><br><p>  Ini membuat Dart langsung dari pandangan pertama menjadi akrab bagi orang-orang yang telah memprogram dalam bahasa pemrograman apa pun sebelumnya, dan itu hebat.  Tetapi mencoba menjelaskan semua fitur istimewa yang berlimpah ini dalam contoh "Halo, dunia" yang sederhana, saya menemukan bahwa, sebaliknya, itu mempersulit pengembangan. </p><br><ul><li>  <strong>semua "khusus" fitur bahasa membingungkan</strong> - "metode khusus yang disebut konstruktor", "sintaks khusus untuk inisialisasi otomatis", "sintaks khusus untuk parameter bernama", dll. </li><li>  <strong>semuanya "tersembunyi" membingungkan</strong> - "dari impor apa fungsi ini? tersembunyi, melihat kode yang tidak dapat Anda temukan", "mengapa ada konstruktor di kelas ini, tetapi tidak di kelas ini? ada di sana, tetapi disembunyikan" dan seterusnya </li><li>  <strong>semuanya "ambigu" bingung</strong> - "jadi di sini untuk membuat parameter fungsi dengan atau tanpa nama?", "haruskah konst atau final?", "di sini menggunakan sintaks fungsi normal atau '' disingkat dengan panah ''", dll. </li></ul><br><p>  Pada prinsipnya, trinitas ini - "khusus", "tersembunyi" dan "ambigu" - tidak buruk menangkap esensi dari apa yang orang sebut "sihir" dalam bahasa pemrograman.  Ini adalah fitur yang dibuat untuk menyederhanakan penulisan kode, tetapi pada kenyataannya menyulitkan pembacaan dan pemahamannya. </p><br><p>  Dan inilah tepatnya area di mana Go mengambil posisi yang secara fundamental berbeda dari bahasa lain, dan dengan kuat memegang pertahanan.  Go adalah bahasa yang nyaris tanpa sihir - jumlah "tersembunyi", "istimewa" dan "ambigu" di dalamnya diminimalkan.  Tapi Go memiliki kekurangannya. </p><br><h1 id="chto-ne-tak-s-go">  Apa yang salah dengan Go? </h1><br><p>  Karena kita berbicara tentang Flutter, yang merupakan kerangka kerja UI, mari kita pertimbangkan Go sebagai alat untuk menggambarkan dan bekerja dengan UI.  Secara umum, kerangka kerja UI adalah tantangan yang luar biasa dan hampir selalu membutuhkan solusi khusus.  Salah satu pendekatan yang paling sering di UI adalah penciptaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DSL</a> - bahasa khusus domain - diimplementasikan dalam bentuk perpustakaan atau kerangka kerja yang dirancang khusus untuk kebutuhan UI.  Dan paling sering Anda bisa mendengar pendapat bahwa Go secara objektif adalah bahasa yang buruk untuk DSL. </p><br><p>  Intinya, DSL berarti menciptakan bahasa baru - istilah dan kata kerja - tempat pengembang dapat beroperasi.  Kode di atasnya harus dengan jelas menggambarkan fitur utama dari antarmuka grafis dan komponennya, cukup fleksibel untuk memberikan kebebasan pada imajinasi perancang, dan pada saat yang sama cukup kaku untuk membatasinya sesuai dengan aturan tertentu.  Misalnya, Anda harus dapat menempatkan tombol di beberapa wadah, dan meletakkan ikon di tempat yang tepat di tombol ini, tetapi kompiler harus mengembalikan kesalahan jika Anda mencoba memasukkan tombol, misalnya, teks. </p><br><p>  Plus, bahasa untuk menggambarkan UI sering bersifat deklaratif - memberikan kesempatan untuk menggambarkan antarmuka dalam bentuk "apa yang ingin saya lihat", dan biarkan kerangka itu sendiri mengerti dari kode mana dan bagaimana menjalankannya. </p><br><p>  Beberapa bahasa pada awalnya dikembangkan dengan tugas-tugas seperti itu yang terlihat, tetapi tidak Go.  Tampaknya menulis Flutter on Go akan menjadi tugas lain! </p><br><h1 id="oda-flutter">  Oda Flutter </h1><br><p>  Jika Anda tidak terbiasa dengan Flutter, maka saya sangat merekomendasikan menghabiskan akhir pekan berikutnya menonton video pendidikan atau membaca tutorial, yang jumlahnya banyak.  Karena Flutter, tanpa ragu, membalikkan aturan permainan dalam pengembangan aplikasi seluler.  Dan, sangat mungkin, tidak hanya ponsel - sudah ada penyaji (dalam hal Flutter, embedders) untuk meluncurkan aplikasi Flutter sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi dekstop asli</a> , dan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi web</a> . </p><br><p> Mudah dipelajari, logis, dilengkapi dengan perpustakaan besar widget indah tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Desain Material</a> (dan tidak hanya), ia memiliki komunitas yang hebat dan besar dan penyetelan yang sangat baik (jika Anda suka kemudahan bekerja dengan <code>go build/run/test</code> di Go, maka di Flutter Anda akan mendapatkan pengalaman serupa). </p><br><p>  Setahun yang lalu, saya perlu menulis aplikasi seluler kecil (untuk iOS dan Android, tentu saja), dan saya menyadari bahwa kompleksitas pengembangan aplikasi berkualitas tinggi untuk kedua platform terlalu besar (aplikasi itu bukan tugas utama) - Saya harus memasang iklan dan membayar uang untuk itu.  Bahkan, menulis aplikasi yang tidak rumit, tetapi berkualitas tinggi dan bekerja pada semua perangkat adalah tugas yang mustahil bahkan untuk orang dengan pengalaman pemrograman hampir 20 tahun.  Dan itu selalu omong kosong bagiku. </p><br><p>  Dengan Flutter, saya menulis ulang aplikasi ini dalam jam 3 sore, sambil mempelajari kerangka itu sendiri dari awal.  Jika seseorang mengatakan kepada saya bahwa ini mungkin sedikit lebih awal, saya tidak akan mempercayainya. </p><br><p>  Terakhir kali saya melihat peningkatan produktivitas yang serupa dengan penemuan teknologi baru adalah 5 tahun yang lalu ketika saya menemukan Go.  Momen itu mengubah hidup saya. </p><br><p>  Jadi saya sarankan mulai belajar Flutter dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial ini sangat bagus</a> . </p><br><h1 id="hello-world-na-flutter">  "Halo, Dunia" di Flutter </h1><br><p>  Saat Anda membuat aplikasi baru melalui <code>flutter create</code> , Anda akan mendapatkan program seperti itu dengan judul, teks, penghitung, dan tombol yang menambah penghitung. </p><br><p><img src="https://habrastorage.org/webt/_1/iu/9g/_1iu9gibgfkoiyadzl0kb8be_j4.gif"></p><br><p>  Saya pikir ini adalah contoh yang bagus.  untuk menulisnya di Flutter imajiner kami on Go.  Ini memiliki hampir semua konsep dasar kerangka kerja di mana Anda dapat menguji ide tersebut.  Mari kita lihat kodenya (ini satu file): </p><br><pre> <code class="plaintext hljs">import 'package:flutter/material.dart'; void main() =&gt; runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } }</code> </pre> <br><p>  Mari kita menganalisis kode di bagian-bagian, menganalisis apa dan bagaimana cocok di Go, dan lihat berbagai opsi yang kita miliki. </p><br><h2 id="perevodim-kod-na-go">  Kami menerjemahkan kode di mana pun </h2><br><p>  Awal akan sederhana dan mudah - mengimpor dependensi dan meluncurkan fungsi <code>main()</code> .  Tidak ada yang rumit atau menarik di sini, perubahannya hampir sintaksis: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { app := NewApp() flutter.Run(app) }</code> </pre> <br><p>  Satu-satunya perbedaan adalah bahwa alih-alih meluncurkan <code>MyApp()</code> - fungsi yang merupakan konstruktor, yang merupakan fungsi khusus yang disembunyikan di dalam kelas yang disebut MyApp - kita cukup memanggil fungsi <code>NewApp()</code> eksplisit dan tidak tersembunyi <code>NewApp()</code> .  Dia melakukan hal yang sama, tetapi jauh lebih jelas untuk menjelaskan dan memahami apa itu, bagaimana itu dimulai dan bagaimana cara kerjanya. </p><br><h3 id="klassy-vidzhetov">  Kelas widget </h3><br><p>  Di Flutter, semuanya terdiri dari widget.  Dalam Flutter versi Dart, setiap widget diimplementasikan sebagai kelas yang mewarisi kelas khusus untuk widget dari Flutter. </p><br><p>  Tidak ada kelas di Go, dan karenanya tidak ada hierarki kelas, karena dunia tidak berorientasi objek, dan bahkan lebih tidak hirarkis.  Untuk programmer yang hanya mengenal model OOP yang berorientasi kelas, ini mungkin sebuah wahyu, tetapi sebenarnya tidak.  Dunia adalah grafik konsep, proses, dan interaksi terjalin raksasa.  Itu tidak terstruktur sempurna, tetapi tidak kacau, dan mencoba untuk memerasnya ke dalam hierarki kelas adalah cara yang paling dapat diandalkan untuk membuat basis kode tidak dapat dibaca dan kikuk - persis seperti apa basis kode yang paling untuk saat ini. </p><br><p><img src="https://habrastorage.org/webt/gd/9f/ad/gd9fadtyygideailxszfgw2cs_k.png"></p><br><p>  Saya sangat menghargai Go karena penciptanya mengambil kesulitan untuk memikirkan kembali konsep kelas yang ada di mana-mana ini dan menerapkannya dalam konsep OOP yang jauh lebih sederhana dan lebih kuat, yang, bukannya kebetulan, ternyata lebih dekat dengan apa yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada dalam pikiran</a> pencipta OOP, Alan Kay, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam pikiran</a> . </p><br><p>  Di Go, kami mewakili abstraksi apa pun dalam bentuk tipe - struktur tertentu: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Dalam Flutter versi Dart, <code>MyApp</code> harus mewarisi <code>StatelessWidget</code> dan mengganti metode <code>build</code> .  Ini diperlukan untuk menyelesaikan dua masalah: </p><br><ol><li>  berikan widget kami ( <code>MyApp</code> ) beberapa properti / metode khusus </li><li>  aktifkan Flutter untuk memanggil kode kami dalam proses build / render </li></ol><br><p>  Saya tidak tahu bagian dalam Flutter, jadi katakanlah item nomor 1 tidak dipertanyakan, dan kita hanya perlu melakukannya.  Go memiliki solusi yang unik dan jelas untuk ini: jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyematan</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Kode ini akan menambahkan semua properti dan metode <code>flutter.Core</code> ke tipe <code>MyApp</code> kami.  Saya menyebutnya <code>Core</code> bukan <code>Widget</code> , karena, pertama, tipe embedding belum menjadikan <code>MyApp</code> kami <code>MyApp</code> widget, dan kedua, nama ini sangat baik digunakan dalam kerangka kerja GopherJS Vecty (sesuatu seperti React, only for Go).  Saya akan menyentuh pada topik kesamaan antara Vecty dan Flutter sedikit kemudian. </p><br><p>  Poin kedua - implementasi metode <code>build()</code> , yang akan dapat menggunakan mesin Flutter - juga dipecahkan secara sederhana dan jelas di Go.  Kita hanya perlu menambahkan metode dengan tanda tangan tertentu yang memenuhi antarmuka tertentu yang didefinisikan di suatu tempat di perpustakaan Flutter fiksi kami di Go: </p><br><p>  flutter.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Widget <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Build(ctx BuildContext) Widget }</code> </pre> <br><p>  Dan sekarang main.go kami: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyApp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core <span class="hljs-comment"><span class="hljs-comment">// ... } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.MaterialApp() }</span></span></code> </pre> <br><p>  Kami dapat melihat beberapa perbedaan di sini: </p><br><ul><li>  kode ini agak lebih verbose - <code>BuildContext</code> , <code>Widget</code> dan <code>MaterialApp</code> menunjuk ke impor <code>BuildContext</code> di depannya. </li><li>  kode ini sedikit tidak berdasar - tidak ada kata seperti <code>extends Widget</code> atau <code>@override</code> </li><li>  Metode <code>Build()</code> dimulai dengan huruf kapital, karena itu berarti "publisitas" dari metode di Go.  Di Dart, publisitas ditentukan oleh apakah nama dimulai dengan garis bawah (_) atau tidak. </li></ul><br><p>  Jadi, untuk membuat widget di Flutter on Go, kita perlu menyematkan <code>flutter.Core</code> ketik dan mengimplementasikan antarmuka <code>flutter.Widget</code> .  Kami menemukan jawabannya, menggali lebih jauh. </p><br><h2 id="sostoyanie">  Ketentuan </h2><br><p>  Ini adalah salah satu hal yang benar-benar membingungkan saya di Flutter.  Ada dua kelas yang berbeda - <code>StatelessWidget</code> dan <code>StatefulWidget</code> .  Bagi saya, "widget stateless" adalah widget yang sama, hanya tanpa, hmm, data, status - mengapa datang dengan kelas baru?  Tapi oke, saya bisa hidup dengannya. </p><br><p>  Tetapi lebih jauh - lebih lanjut, Anda tidak bisa hanya mewarisi kelas lain ( <code>StatefulWidget</code> ), tetapi Anda harus menulis keajaiban seperti itu (IDE akan melakukannya untuk Anda, tetapi bukan intinya): </p><br><pre> <code class="plaintext hljs">class MyHomePage extends StatefulWidget { @override _MyHomePageState createState() =&gt; _MyHomePageState(); } class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold() } }</code> </pre> <br><p>  Hmm, mari kita lihat apa yang terjadi di sini. </p><br><p>  Pada dasarnya, tugasnya adalah ini: tambahkan status ke widget - penghitung, dalam kasus kami - dan beri tahu mesin Flutter saat kami mengubah status untuk menggambar ulang widget.  Ini adalah kompleksitas masalah yang sebenarnya (kompleksitas esensial dalam istilah Brooks). </p><br><p>  Yang lainnya adalah kompleksitas yang tidak disengaja.  Flutter on Dart hadir dengan kelas <code>State</code> baru yang menggunakan obat generik dan menggunakan widget sebagai parameter tipe.  Selanjutnya, kelas <code>_MyHomePageState</code> , yang mewarisi keadaan <code>State  MyApp</code> ... oke, Anda masih bisa mencernanya.  Tapi mengapa metode <code>build()</code> didefinisikan oleh kelas State, dan bukan kelas widgetnya?  Brrr .... </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jawaban untuk pertanyaan ini</a> ada di Flutter FAQ dan jawaban singkatnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipertimbangkan</a> secara cukup rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> - untuk menghindari kelas bug tertentu ketika mewarisi <code>StatefulWidget</code> .  Dengan kata lain, ini adalah solusi untuk menyelesaikan masalah desain OOP berorientasi kelas.  Cantik. </p><br><p>  Bagaimana kita melakukan ini di Go? </p><br><p>  Pertama, saya pribadi secara pribadi lebih suka untuk tidak membuat entitas terpisah untuk "negara" - <code>State</code> .  Bagaimanapun, kita sudah memiliki keadaan di setiap jenis tertentu - ini hanya bidang struktur.  Bahasa telah memberi kita esensi ini, sehingga untuk berbicara.  Membuat entitas lain yang serupa hanya akan membingungkan programmer. </p><br><p>  Tantangannya, tentu saja, adalah memberi Flutter kemampuan untuk merespons perubahan keadaan (bagaimanapun juga, inilah inti dari pemrograman reaktif).  Dan jika kita dapat "meminta" pengembang untuk menggunakan fungsi khusus ( <code>setState()</code> ), maka dengan cara yang sama kita dapat meminta untuk menggunakan fungsi khusus untuk memberi tahu mesin kapan harus digambar ulang dan kapan tidak.  Pada akhirnya, tidak semua perubahan negara memerlukan penggambaran ulang, dan di sini kita akan memiliki kontrol lebih besar: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyHomePage <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { flutter.Core counter <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.Scaffold() } // incrementCounter increments widgets's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) // or m.Rerender() // or m.NeedsUpdate() }</span></span></code> </pre> <br><p>  Anda dapat bermain <code>NeedsUpdate()</code> main dengan opsi penamaan yang berbeda - Saya suka <code>NeedsUpdate()</code> karena keterusterangannya dan fakta bahwa ini adalah properti widget (diperoleh dari <code>flutter.Core</code> ), tetapi metode global <code>flutter.Rerender()</code> juga terlihat bagus.  Benar, itu memberikan perasaan yang salah bahwa widget akan segera digambar ulang dengan segera, tetapi tidak demikian - itu akan digambar ulang pada pembaruan bingkai berikutnya, dan frekuensi pemanggilan metode bisa jauh lebih tinggi daripada frekuensi render - tetapi mesin Flutter kami harus sudah menangani hal ini. </p><br><p>  Tapi idenya adalah kita baru saja memecahkan masalah yang diperlukan tanpa menambahkan: </p><br><ul><li>  tipe baru </li><li>  obat generik </li><li>  aturan khusus untuk kondisi membaca / menulis </li><li>  metode khusus baru yang ditimpa </li></ul><br><p>  Plus, API jauh lebih jelas dan lebih mudah dipahami - cukup tambahkan penghitung (seperti yang Anda lakukan dalam program lain) dan minta Flutter untuk menggambar ulang widget.  Ini hanya apa yang tidak terlalu jelas jika kita hanya memanggil <code>setState</code> - yang bukan hanya fungsi khusus untuk pengaturan keadaan, itu adalah fungsi yang mengembalikan fungsi (wtf?) Di mana kita sudah melakukan sesuatu dengan keadaan.  Sekali lagi, sihir tersembunyi dalam bahasa dan kerangka membuatnya sangat sulit untuk memahami dan membaca kode. </p><br><p>  Dalam kasus kami, kami memecahkan masalah yang sama, kode lebih sederhana dan dua kali lebih pendek. </p><br><h2 id="vidzhety-s-sostoyaniem-v-drugih-vidzhetah">  Sebutkan widget di widget lain </h2><br><p>  Sebagai kelanjutan logis dari topik, mari kita lihat bagaimana "widget negara" digunakan dalam widget lain di Flutter: </p><br><pre> <code class="plaintext hljs">@override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', home: MyHomePage(title: 'Flutter Demo Home Page'), ); }</code> </pre> <br><p>  <code>MyHomePage</code> sini adalah "widget negara" (memiliki penghitung), dan kami membuatnya dengan memanggil konstruktor <code>MyHomePage()</code> selama pembuatan ... Tunggu, apa? </p><br><p>  <code>build()</code> dipanggil untuk menggambar ulang widget, sangat mungkin berkali-kali per detik.  Mengapa kita harus membuat widget, terutama dengan status, setiap kali selama rendering?  Itu tidak masuk akal. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ternyata</a> Flutter menggunakan pemisahan antara <code>Widget</code> dan <code>State</code> untuk menyembunyikan inisialisasi / manajemen negara ini dari programmer (lebih banyak hal tersembunyi, lebih banyak!).  Itu membuat widget baru setiap kali, tetapi negara, jika sudah dibuat, secara otomatis ditemukan dan dilampirkan ke widget.  Keajaiban ini terjadi tanpa terlihat dan saya tidak tahu cara kerjanya - Anda perlu membaca kode. </p><br><p>  Saya menganggap itu sebagai kejahatan nyata dalam pemrograman untuk bersembunyi dan bersembunyi dari programmer sebanyak mungkin, membenarkannya dengan ergonomi.  Saya yakin bahwa programmer statistik rata-rata tidak akan membaca kode Flutter untuk memahami bagaimana sihir ini bekerja, dan tidak mungkin untuk memahami bagaimana dan apa yang saling berhubungan. </p><br><p>  Untuk versi Go, saya pasti tidak ingin sihir yang tersembunyi seperti itu, dan akan lebih memilih inisialisasi yang eksplisit dan terlihat, bahkan jika itu berarti kode yang sedikit lebih tidak berdasar.  Pendekatan Flutter terhadap Dart juga dapat diimplementasikan, tetapi saya suka Go karena meminimalkan sihir, dan saya ingin melihat filosofi yang sama dalam kerangka kerja.  Karenanya, saya akan menulis kode untuk widget dengan status di pohon widget seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// MyApp is our top application widget. type MyApp struct { flutter.Core homePage *MyHomePage } // NewMyApp instantiates a new MyApp widget func NewMyApp() *MyApp { app := &amp;MyApp{} app.homePage = &amp;MyHomePage{} return app } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx flutter.BuildContext) flutter.Widget { return m.homePage } // MyHomePage is a home page widget. type MyHomePage struct { flutter.Core counter int } // Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return flutter.Scaffold() } // incrementCounter increments app's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) }</span></span></code> </pre> <br><p>  Kode ini kehilangan versi Dart karena jika saya ingin menghapus <code>homePage</code> dari pohon widget dan menggantinya dengan yang lain, maka saya harus menghapusnya di tiga tempat, bukan satu.  Tetapi sebagai gantinya, kami mendapatkan gambaran lengkap tentang apa, di mana dan bagaimana hal itu terjadi, di mana memori dialokasikan, siapa yang memanggil siapa, dan seterusnya - kode di telapak tangan Anda jelas dan mudah dibaca. </p><br><p>  Ngomong-ngomong, Flutter juga memiliki yang namanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StatefulBuilder</a> , yang menambahkan lebih banyak keajaiban dan memungkinkan Anda untuk membuat widget dengan status aktif. </p><br><h1 id="dsl">  DSL </h1><br><p>  Sekarang mari kita ambil bagian yang menyenangkan.  Bagaimana kami akan mewakili pohon widget on Go?  Kami ingin itu terlihat ringkas, bersih, mudah untuk refactor dan berubah, menggambarkan hubungan spasial antara widget (widget yang secara visual dekat, harus dekat dan dalam deskripsi), dan pada saat yang sama cukup fleksibel untuk menggambarkan secara sewenang-wenang. kode seperti penangan acara. </p><br><p>  Tampaknya bagi saya bahwa opsi pada Dart cukup indah dan fasih: </p><br><pre> <code class="plaintext hljs">return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text('You have pushed the button this many times:'), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), );</code> </pre> <br><p>  Setiap widget memiliki konstruktor yang menerima parameter opsional, dan apa yang membuat catatan sangat bagus di sini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parameter bernama dari fungsi</a> . </p><br><h2 id="imenovannye-parametry">  Parameter yang Dinamai </h2><br><p>  Jika Anda tidak terbiasa dengan istilah ini, maka dalam banyak bahasa parameter fungsi disebut "posisional", karena posisi mereka penting bagi fungsi: </p><br><pre> <code class="plaintext hljs">Foo(arg1, arg2, arg3)</code> </pre> <br><p>  , dan dalam hal parameter bernama, semuanya diputuskan dengan namanya dalam panggilan: </p><br><pre> <code class="plaintext hljs">Foo(name: arg1, description: arg2, size: arg3)</code> </pre> <br><p>  Ini menambahkan teks, tetapi menyimpan klik dan bergerak di sekitar kode, dalam upaya untuk memahami apa arti parameter. </p><br><p>  Dalam kasus pohon widget, mereka memainkan peran kunci dalam keterbacaan.  Bandingkan kode yang sama seperti di atas, tetapi tanpa parameter bernama: </p><br><pre> <code class="plaintext hljs">return Scaffold( AppBar( Text(widget.title), ), Center( Column( MainAxisAlignment.center, &lt;Widget&gt;[ Text('You have pushed the button this many times:'), Text( '$_counter', Theme.of(context).textTheme.display1, ), ], ), ), FloatingActionButton( _incrementCounter, 'Increment', Icon(Icons.add), ), );</code> </pre> <br><p>  Bukan itu.  benar kan  Tidak hanya lebih sulit untuk dipahami (Anda perlu mengingat apa arti setiap parameter dan jenisnya, dan ini adalah beban kognitif yang signifikan), tetapi juga tidak memberi kami kebebasan dalam memilih parameter mana yang ingin kami transfer.  Misalnya, Anda mungkin tidak ingin <code>FloatingActionButton</code> untuk aplikasi Material Anda, jadi Anda tidak menentukannya dalam parameter.  Tanpa parameter bernama, kita harus memaksa semua widget yang mungkin untuk ditentukan, atau menggunakan sihir dengan refleksi untuk mencari tahu widget mana yang ditransfer. </p><br><p>  Dan karena tidak ada kelebihan fungsi dan parameter bernama di Go, ini tidak akan menjadi tugas yang mudah untuk Go. </p><br><h1 id="derevo-vidzhetov-v-go">  Buka pohon widget </h1><br><h2 id="versiya-1">  Versi 1 </h2><br><p>  Mari kita melihat lebih dekat objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scaffold</a> , yang merupakan pembungkus yang nyaman untuk aplikasi mobile.  Ini memiliki beberapa properti - appBar, drawe, home, bottomNavigationBar, floatingActionBar - dan ini semua adalah widget.  Saat membuat pohon widget, kita sebenarnya harus menginisialisasi objek ini, lalu meneruskannya dengan properti widget yang disebutkan di atas.  Nah, ini tidak terlalu berbeda dengan kreasi dan inisialisasi objek yang biasa. </p><br><p>  Mari kita coba pendekatan dahi: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flutter.NewScaffold( flutter.NewAppBar( flutter.Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), ), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, flutter.NewCenter( flutter.NewColumn( flutter.MainAxisCenterAlignment, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []flutter.Widget{ flutter.Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), flutter.Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), flutter.FloatingActionButton( flutter.NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, ), )</code> </pre> <br><p>  Bukan kode UI yang paling indah, pasti.  Kata <code>flutter</code> mana-mana dan bertanya.  untuk menyembunyikannya (sebenarnya, saya seharusnya menyebut <code>material</code> paket, bukan <code>flutter</code> , tetapi bukan esensi), parameter anonim sama sekali tidak jelas, dan <code>nil</code> ini secara terbuka membingungkan di mana-mana. </p><br><h2 id="versiya-2">  Versi 2 </h2><br><p>  Karena sebagian besar kode masih akan menggunakan satu jenis atau fungsi lain dari paket <code>flutter</code> , kita dapat menggunakan format "dot import" untuk mengimpor paket ke namespace kami dan dengan demikian "menyembunyikan" nama paket: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span></code> </pre> <br><p>  Sekarang alih-alih <code>flutter.Text</code> . <code>Text</code> kita hanya bisa menulis <code>Text</code> .  Ini biasanya praktik yang buruk, tetapi kami bekerja dengan kerangka kerja, dan impor ini akan secara harfiah di setiap baris.  Dari praktik saya, ini adalah kasus persis di mana impor tersebut dapat diterima - misalnya, seperti ketika menggunakan kerangka kerja yang bagus untuk menguji <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GoConvey</a> . </p><br><p>  Mari kita lihat bagaimana kode akan terlihat: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold( NewAppBar( Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), ), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, NewCenter( NewColumn( MainAxisCenterAlignment, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), FloatingActionButton( NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, ), )</code> </pre> <br><p>  Sudah lebih baik, tetapi parameter nil-s dan tidak bernama ini .... </p><br><h2 id="versiya-3">  Versi 3 </h2><br><p>  Mari kita lihat seperti apa kode itu jika kita menggunakan refleksi (kemampuan untuk memeriksa kode saat program sedang berjalan) untuk menganalisis parameter yang diteruskan.  Pendekatan ini digunakan dalam beberapa kerangka kerja HTTP awal on Go ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">martini</a> , misalnya), dan dianggap sebagai praktik yang sangat buruk - tidak aman, kehilangan kenyamanan sistem jenisnya, relatif lambat dan menambah keajaiban pada kode - tetapi untuk percobaan Anda dapat mencoba: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold( NewAppBar( Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>), ), NewCenter( NewColumn( MainAxisCenterAlignment, []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>), Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), ctx.Theme.textTheme.display1), }, ), ), FloatingActionButton( NewIcon(icons.Add), <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, m.onPressed, ), )</code> </pre> <br><p>  Tidak buruk, dan sepertinya versi asli dari Dart, tetapi kurangnya parameter bernama masih sangat menyakitkan mata. </p><br><h2 id="versiya-4">  Versi 4 </h2><br><p>  Mari mundur sedikit dan bertanya pada diri sendiri apa yang ingin kita lakukan.  Kami tidak perlu secara buta menyalin pendekatan Dart (meskipun itu akan menjadi bonus yang bagus - ada sedikit untuk mengajar orang-orang yang sudah terbiasa dengan Flutter on Dart).  Bahkan, kita hanya membuat objek baru dan menetapkan properti padanya. </p><br><p>  Bisakah mencoba cara ini? </p><br><pre> <code class="go hljs">scaffold := NewScaffold() scaffold.AppBar = NewAppBar(Text(<span class="hljs-string"><span class="hljs-string">"Flutter Go app"</span></span>)) column := NewColumn() column.MainAxisAlignment = MainAxisCenterAlignment counterText := Text(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter)) counterText.Style = ctx.Theme.textTheme.display1 column.Children = []Widget{ Text(<span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>), counterText, } center := NewCenter() center.Child = column scaffold.Home = center icon := NewIcon(icons.Add), fab := NewFloatingActionButton() fab.Icon = icon fab.Text = <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> fab.Handler = m.onPressed scaffold.FloatingActionButton = fab <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scaffold</code> </pre> <br><p>    ,         " ",         . -,       –   ,      . -,      ,            . </p><br><p> ,       UI   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GTK</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt</a> . , ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>  Qt 5: </p><br><pre> <code class="plaintext hljs"> QGridLayout *layout = new QGridLayout(this); layout-&gt;addWidget(new QLabel(tr("Object name:")), 0, 0); layout-&gt;addWidget(m_objectName, 0, 1); layout-&gt;addWidget(new QLabel(tr("Location:")), 1, 0); m_location-&gt;setEditable(false); m_location-&gt;addItem(tr("Top")); m_location-&gt;addItem(tr("Left")); m_location-&gt;addItem(tr("Right")); m_location-&gt;addItem(tr("Bottom")); m_location-&gt;addItem(tr("Restore")); layout-&gt;addWidget(m_location, 1, 1); QDialogButtonBox *buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, this); connect(buttonBox, &amp;QDialogButtonBox::rejected, this, &amp;QDialog::reject); connect(buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;QDialog::accept); layout-&gt;addWidget(buttonBox, 2, 0, 1, 2);</code> </pre><br><p>   ,   -      . ,  ,    ,           . </p><br><h2 id="versiya-5">  5 </h2><br><p>   ,     –          -.  Sebagai contoh: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold(ScaffoldParams{ AppBar: NewAppBar(AppBarParams{ Title: Text(TextParams{ Text: <span class="hljs-string"><span class="hljs-string">"My Home Page"</span></span>, }), }), Body: NewCenter(CenterParams{ Child: NewColumn(ColumnParams{ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text(TextParams{ Text: <span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, }), Text(TextParams{ Text: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton( FloatingActionButtonParams{ OnPressed: m.incrementCounter, Tooltip: <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, Child: NewIcon(IconParams{ Icon: Icons.add, }), }, ), }) }</code> </pre> <br><p> ! ,   .    <code>...Params</code>    ,          .  , ,       Go    ,       ,     . </p><br><p> -,     <code>...Params</code> ,       .    (proposal)     — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"  "</a> .  ,     <code>FloatingActionButtonParameters{...}</code>  <code>{...}</code>    .     : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Widget</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewScaffold({ AppBar: NewAppBar({ Title: Text({ Text: <span class="hljs-string"><span class="hljs-string">"My Home Page"</span></span>, }), }), Body: NewCenter({ Child: NewColumn({ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text({ Text: <span class="hljs-string"><span class="hljs-string">"You have pushed the button this many times:"</span></span>, }), Text({ Text: fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton({ OnPressed: m.incrementCounter, Tooltip: <span class="hljs-string"><span class="hljs-string">"Increment"</span></span>, Child: NewIcon({ Icon: Icons.add, }), }, ), }) }</code> </pre> <br><p>        Dart!         . </p><br><h2 id="versiya-6">  6 </h2><br><p>   ,         .  ,    ,    ,       ,   . </p><br><p>   ,    ,   ,      -,     –     : </p><br><pre> <code class="go hljs">button := NewButton(). WithText(<span class="hljs-string"><span class="hljs-string">"Click me"</span></span>). WithStyle(MyButtonStyle1)</code> </pre> <br><p>  atau </p><br><pre> <code class="go hljs">button := NewButton(). Text(<span class="hljs-string"><span class="hljs-string">"Click me"</span></span>). Style(MyButtonStyle1)</code> </pre> <br><p>     Scaffold-    : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx flutter.BuildContext) flutter.Widget { return NewScaffold(). AppBar(NewAppBar(). Text("Flutter Go app")). Child(NewCenter(). Child(NewColumn(). MainAxisAlignment(MainAxisCenterAlignment). Children([]Widget{ Text("You have pushed the button this many times:"), Text(fmt.Sprintf("%d", m.counter)). Style(ctx.Theme.textTheme.display1), }))). FloatingActionButton(NewFloatingActionButton(). Icon(NewIcon(icons.Add)). Text("Increment"). Handler(m.onPressed)) }</span></span></code> </pre> <br><p>        Go –       , .      Dart-,       : </p><br><ul><li>    </li><li>  "" </li><li>      </li><li>       </li></ul><br><p>          <code>New...()</code>   –  ,   .       ,    — <strong>"  ,      ,   ,      ,    ,     ,      –        "</strong> . </p><br><p>   ,   , 5-  6-    . </p><br><h1 id="finalnaya-versiya-koda">    </h1><br><p>         "hello, world"   Flutter  Go: </p><br><p> main.go </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { flutter.Run(NewMyApp()) }</code> </pre> <br><p> app.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> <span class="hljs-comment"><span class="hljs-comment">// MyApp is our top application widget. type MyApp struct { Core homePage *MyHomePage } // NewMyApp instantiates a new MyApp widget func NewMyApp() *MyApp { app := &amp;MyApp{} app.homePage = &amp;MyHomePage{} return app } // Build renders the MyApp widget. Implements Widget interface. func (m *MyApp) Build(ctx BuildContext) Widget { return m.homePage }</span></span></code> </pre> <br><p> home_page.go: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> hello <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/flutter/flutter"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// MyHomePage is a home page widget. type MyHomePage struct { Core counter int } // Build renders the MyHomePage widget. Implements Widget interface. func (m *MyHomePage) Build(ctx BuildContext) Widget { return NewScaffold(ScaffoldParams{ AppBar: NewAppBar(AppBarParams{ Title: Text(TextParams{ Text: "My Home Page", }), }), Body: NewCenter(CenterParams{ Child: NewColumn(ColumnParams{ MainAxisAlignment: MainAxisAlignment.center, Children: []Widget{ Text(TextParams{ Text: "You have pushed the button this many times:", }), Text(TextParams{ Text: fmt.Sprintf("%d", m.counter), Style: ctx.textTheme.display1, }), }, }), }), FloatingActionButton: NewFloatingActionButton( FloatingActionButtonParameters{ OnPressed: m.incrementCounter, Tooltip: "Increment", Child: NewIcon(IconParams{ Icon: Icons.add, }), }, ), }) } // incrementCounter increments app's counter by one. func (m *MyHomePage) incrementCounter() { m.counter++ flutter.Rerender(m) }</span></span></code> </pre> <br><p>   ! </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><h4 id="pohozhest-s-vecty">   Vecty </h4><br><p>        ,      ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vecty</a> .  , ,  , ,  Vecty    DOM/CSS/JS,  Flutter            ,        120   .   ,   Vecty  ,     Flutter  Go  Vecty . </p><br><h4 id="luchshee-ponimanie-dizayna-flutter">    Flutter </h4><br><p>         –        ,   .            Flutter,         . </p><br><h4 id="nedostatki-go">  Go </h4><br><p>    <strong>"  Flutter    Go?"</strong>    <strong>""</strong> ,  , , ,        ,   Flutter, , ,     ""   .      ,    Go       . </p><br><p>  ,  <strong>   Go    </strong> .                 .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>    Go, , ,    -.    –      ,         ,        . </p><br><p>           Go.              –       ,      . </p><br><h4 id="mysli-o-buduschem-flutter">    Flutter </h4><br><p>      ,  Flutter  ,     ,       .  "/ "   ,  Dart    ( , ,     ).    Dart,  ,      (,    )    DartVM  V8,  Flutter    –   Flutter      -. </p><br><p> ,     .          .  ,           ,  1.0     . , -      . </p><br><p>    game changer,     Flutter ,           ,           . </p><br><p>            UI –  Flutter,    . </p><br><h1 id="ssylki">  Referensi </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://flutter.io</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flutter Tutorial for Beginners — Build iOS and Android Apps</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go proposal: An Improved, Golang-Cohesive Design for Named Arguments</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go proposal: spec: untyped composite literals</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435960/">https://habr.com/ru/post/id435960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435950/index.html">Pusat data modular dalam layanan Large Hadron Collider</a></li>
<li><a href="../id435952/index.html">Siapa "tuan rumah yang tidak dicuci"?</a></li>
<li><a href="../id435954/index.html">Mengembangkan modul untuk boneka dengan kit pengembangan boneka</a></li>
<li><a href="../id435956/index.html">PHP Digest No. 147 (1 - 14 Januari 2019)</a></li>
<li><a href="../id435958/index.html">Intisari bahan-bahan segar dari dunia frontend selama minggu terakhir No. 347 (7 - 13 Januari 2019)</a></li>
<li><a href="../id435962/index.html">Peringatan 25 tahun Aeron: sensasi dan kesan versi Aeron Remastered yang diperbarui</a></li>
<li><a href="../id435964/index.html">Ethereum berencana menjadi 99% lebih ekonomis</a></li>
<li><a href="../id435968/index.html">Tinjauan Algoritma Pembelajaran Mesin Mendalam untuk Robot</a></li>
<li><a href="../id435970/index.html">Panduan Pemula untuk Pengembangan Server Web dengan Node.js</a></li>
<li><a href="../id435972/index.html">Memperkenalkan pemrograman reaktif di Spring</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>