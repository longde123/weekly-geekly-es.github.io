<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèæ üë®üèº‚Äçüîß üíï Die Zukunft von WebAssembly als ‚ÄûSkill Tree‚Äú üë®üèø‚Äç‚úàÔ∏è üíú üñáÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Leute haben WebAssembly irgendwie falsch verstanden. Es gibt Leute, die glauben, dass alles bereit ist, da Browser WebAssembly bereits unterst√º...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Zukunft von WebAssembly als ‚ÄûSkill Tree‚Äú</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/428347/">  Einige Leute haben WebAssembly irgendwie falsch verstanden.  Es gibt Leute, die glauben, dass alles bereit ist, da Browser WebAssembly bereits unterst√ºtzen (seit 2017).  Noch nicht einmal in der N√§he, nur MVP (minimal lebensf√§higes Produkt) ist bereit.  Ich kann mir vorstellen, woher die Wurzel dieses Fehlers stammt: Nach der MVP-Ver√∂ffentlichung versprachen die Entwickler, die Abw√§rtskompatibilit√§t auf der Ebene von "Jeder jetzt geschriebene Code <b>wird</b> in Zukunft funktionieren" beizubehalten.  Dies bedeutet jedoch nicht, dass die Entwicklung von WebAssembly abgeschlossen ist, √ºberhaupt nicht!  Viele Funktionen werden derzeit entwickelt und sind f√ºr die nahe Zukunft geplant.  Und wenn sie implementiert werden, wird sich alles sehr √§ndern. <br><br>  Sie k√∂nnen versuchen, sich all diese Funktionen in einem Spiel in Form eines F√§higkeitsbaums vorzustellen.  Wir haben ein paar ‚Äûgrundlegende‚Äú (bereits implementierte Funktionen) und einen ganzen Baum mit vielen Zweigen und Bl√§ttern, die sich im Laufe der Zeit √∂ffnen und uns immer mehr Kraft geben. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="Bild"></a> <br>  Schauen wir uns an, was wir jetzt schon haben und was wir noch entdecken m√ºssen. <br>  ( <b>Unter dem Schnitt viele Bilder, Verkehr</b> ) <br><a name="habracut"></a><br><h2>  Minimum Viable Product (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="Bild"><br>  Ganz am Anfang der Geschichte von WebAssembly steht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> , mit dem C ++ - Code in JavaScript-Code kompiliert werden konnte.  Dies erm√∂glichte es uns, eine gro√üe Anzahl von C ++ - Bibliotheken in die Welt des Webs zu √ºbertragen, ohne die es unm√∂glich w√§re, Code auf h√∂herer Ebene auszuf√ºhren.  Der generierte JS-Code war alles andere als ideal und arbeitete langsam (im Vergleich zu seiner nativen Version).  Trotzdem haben die Mozilla-Ingenieure einige M√∂glichkeiten gefunden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um</a> es schneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu machen</a> .  Die wichtigste war die Zuweisung einer Teilmenge der Sprache, die mit Geschwindigkeiten ausgef√ºhrt werden konnte, die mit den Ausf√ºhrungsgeschwindigkeiten des nativen Codes vergleichbar waren.  Diese Teilmenge wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asm.js genannt.</a> <br><br>  Entwickler anderer Browser bemerkten und sch√§tzten die Geschwindigkeit von asm.js, alle g√§ngigen Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erhielten</a> ihre Unterst√ºtzung.  Aber das hat die Geschichte nicht beendet.  Das war erst der Anfang.  Es gab immer noch Raum, um schneller zu arbeiten.  Aber sie gingen bereits √ºber Javascript hinaus.  Es stellte sich heraus, dass der native Code (zum Beispiel in C ++) nicht in Javascript kompiliert werden musste, sondern in etwas anderem.  In etwas Neues, speziell als schnelle Alternative zu JS erstellt.  Und so entstand WebAssembly. <br><br>  Was ist in der ersten Version von WebAssembly enthalten?  Was war genug, um den stolzen Titel ‚ÄûMinimum Viable Product‚Äú zu erhalten? <br><br><h3>  F√§higkeit: Ziel-Compiler-Plattform </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="Bild"><br><br>  Die Programmierer, die an WebAssembly arbeiteten, verstanden, dass ihre Aufgabe nicht darin bestand, nur C oder C ++ zu unterst√ºtzen.  Die Aufgabe bestand darin, die M√∂glichkeit zu geben, Code in einer beliebigen Sprache in WebAssembly zu kompilieren.  Es musste sich um einen solchen ‚ÄûAssembler‚Äú handeln, der im Browser ausgef√ºhrt werden sollte, so wie der Maschinencode der Desktop-Anwendung beispielsweise auf der x86-Plattform ausgef√ºhrt wird.  Diese neue Sprache sollte sich jedoch nicht auf eine bestimmte Plattform st√ºtzen. Ihr Ziel sollte eine abstrakte Plattform auf einer h√∂heren Ebene sein, deren spezifische Implementierung bereits von den auf dieser Hardware verwendeten Anweisungen abh√§ngen w√ºrde. <br><br><h3>  F√§higkeit: schnelle Codeausf√ºhrung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="Bild"><br><br>  Alles musste schnell gehen.  Warum sollte man sich sonst mit dieser ganzen Geschichte besch√§ftigen?  Am Ende sollte der Benutzer in der Lage sein, wirklich "schwere" Anwendungen auszuf√ºhren, Top-Spiele im Browser zu spielen usw. <br><br><h3>  F√§higkeit: Kompaktheit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="Bild"><br><br>  Es ist nicht nur wichtig, wie schnell der Code ausgef√ºhrt wird, sondern auch, wie schnell er geladen wird.  Benutzer sind an Desktop-Anwendungen gew√∂hnt, die sehr schnell gestartet werden (da sie lokal installiert sind und √ºber alle erforderlichen Ressourcen verf√ºgen).  Webanwendungen werden auch relativ schnell ausgef√ºhrt, da sie nicht so viele Ressourcen gleichzeitig laden.  Dies stellt uns vor eine neue Herausforderung: Wenn wir eine neue Art von Webanwendung mit einer so gro√üen Codebasis wie die klassische Desktop-Anwendung erstellen m√∂chten, die jedoch aus dem Internet heruntergeladen werden kann, sollte der Code so kompakt wie m√∂glich sein. <br><br><h3>  F√§higkeit: Speicherzugriff </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="Bild"><br><br>  Unsere neuen Anwendungen m√ºssen auch etwas anders mit dem Speicher arbeiten als der JavaScript-Code.  Ben√∂tigen Sie direkten Zugriff auf Speicherbl√∂cke.  Dies liegt an der Besonderheit der Sprachen C und C ++, in denen es Zeiger gibt.  Ein Zeiger ist grob gesagt eine Variable, die eine Adresse im Speicher enth√§lt.  Eine Anwendung kann Daten an dieser Adresse lesen, √§ndern und sogar eine Arithmetik f√ºr einen Zeiger verwenden, um von der angegebenen Adresse im Speicher vorw√§rts zu ‚Äûgehen‚Äú.  Eine gro√üe Menge von C / C ++ - Code verwendet Zeiger, um die Effizienz seiner Arbeit zu steigern. Die Erstellung einer Zielplattform f√ºr solchen Code ist ohne die Unterst√ºtzung von Zeigern nicht m√∂glich. <br><br>  Wir k√∂nnen jedoch nicht zulassen, dass aus dem Internet heruntergeladener Code direkten Zugriff auf den Speicher unseres Prozesses hat - dies ist zu gef√§hrlich.  Wir m√ºssen eine Umgebung erstellen, in der einerseits der in WebAssembly kompilierte native Code den direkten Speicherzugriff zul√§sst, andererseits den Bereich, in dem Daten bearbeitet werden d√ºrfen, streng einschr√§nkt. <br><br>  Zu diesem Zweck verwendet WebAssembly das "lineare Speichermodell".  Dies wird mithilfe von TypedArrays implementiert - so etwas wie ein Array in JavaScript, enth√§lt jedoch nur einen sequentiellen Satz von Bytes im Speicher.  Wenn Sie etwas einf√ºgen m√∂chten, verwenden Sie den Zugriff auf das Element √ºber den Index (der eine Adresse im Speicher sein kann).  Somit gibt dieses Array vor, ein Speicherblock f√ºr C ++ - Code zu sein. <br><br><h3>  Neue Leistung! </h3><br>  Mit all dem k√∂nnen die Benutzer die Desktop-Anwendung endlich in einem Browser mit ungef√§hr der gleichen Leistung ausf√ºhren, als w√§re sie nativ.  Das ist ungef√§hr dieser Funktionsumfang und wurde als "Minimum Viable Product" (MVP) bezeichnet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="Bild"><br><br>  Zu diesem Zeitpunkt k√∂nnten einige Anwendungen tats√§chlich bereits unter WebAssembly erstellt werden und im Browser Geld verdienen.  Aber es war noch ein langer Weg vor uns. <br><br><h2>  Schwergewichtige Desktop-Anwendungen </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="Bild"><br><br>  Der n√§chste wichtige Schritt sollte die M√∂glichkeit sein, wirklich gro√üe Desktop-Anwendungen zu starten.  K√∂nnen Sie sich vorstellen, dass die Vollversion von Photoshop in einem Browser ausgef√ºhrt wird?  Und Sie haben es nicht installiert, sondern nur den Link ge√∂ffnet - und jetzt haben Sie die 100% ige Leistung dieses Produkts mit nativer Geschwindigkeit, der neuesten Version mit allen Updates und Korrekturen, auf jedem Ger√§t. <br><br>  Und davon sind wir nicht weit entfernt - Beispiele tauchen bereits auf.  Zum Beispiel AutoCAD.  Und auch Adobe Lightroom.  Aber seien wir ehrlich - in der aktuellen Implementierung von WebAssembly ist nicht alles bereit, um wirklich gro√üe Anwendungen zu starten.  Engp√§sse werden genau hier untersucht und behoben, wenn Sie diesen Artikel lesen. <br><br><h3>  F√§higkeit: Multithreading </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="Bild"><br><br>  Nat√ºrlich brauchen wir Multithreading.  Moderne Computer haben viele Kerne.  Wir m√ºssen sie nutzen k√∂nnen. <br><br><h3>  F√§higkeit: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="Bild"><br><br>  Neben Multithreading gibt es eine weitere Technologie, die eine effizientere Implementierung der parallelen Datenverarbeitung erm√∂glicht.  Dies ist SIMD: Verarbeitung mehrerer Datenbl√∂cke gleichzeitig durch einen einzigen Befehl.  Ein wichtiger Aspekt f√ºr eine wirklich schnelle WebAssembly. <br><br><h3>  F√§higkeit: 64-Bit-Adressierung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="Bild"><br><br>  Ein weiteres wichtiges Merkmal der modernen Hardwarearchitektur, das in WebAssembly noch nicht verf√ºgbar ist, ist die Unterst√ºtzung der 64-Bit-Speicheradressierung.  Alles ist einfach: Mit 32-Bit-Adressen k√∂nnen Sie nur 4 GB Speicher verwenden (was f√ºr gro√üe Programme sehr klein ist), aber mit 64-Bit-Adressen sind es bereits bis zu 16 Exabyte (dies ist viel f√ºr moderne Software).  Nat√ºrlich ist nicht nur das theoretische Maximum wichtig, sondern auch das praktische (wie viel Speicher das Betriebssystem Ihnen geben wird).  Auf den meisten modernen Ger√§ten sind jedoch bereits 4 oder mehr GB RAM vorhanden, und diese Anzahl wird zunehmen. <br><br><h3>  F√§higkeit: Stream-Zusammenstellung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="Bild"><br><br>  Wir m√ºssen nicht nur Anwendungen schnell ausf√ºhren.  Wir m√ºssen auch das Zeitintervall zwischen dem Start des Downloads √ºber das Netzwerk und dem Start verk√ºrzen.  Mit der Stream-Kompilierung k√∂nnen Sie mit der Verarbeitung einer WebAssembly-Datei beginnen, bevor sie endg√ºltig heruntergeladen wird.  Wir √ºberpr√ºfen die Anweisungen beim Herunterladen √ºber das Netzwerk.  Das Laden und Kompilieren erfolgt also parallel.  In Firefox-Code konnten wir eine Kompilierungsgeschwindigkeit erreichen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">h√∂her als die Download-Geschwindigkeit</a> war. Das hei√üt, die Verarbeitungszeit eines Codes mit N Bytes war k√ºrzer als die Download-Zeit dieses Codes √ºber das Netzwerk.  Entwickler anderer Browser arbeiten ebenfalls an der Stream-Kompilierung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="Bild"><br><br>  Eine Sache im Zusammenhang mit der Streaming-Kompilierung ist die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei Compilern</a> .  Eine davon (oben beschrieben) funktioniert schnell und erm√∂glicht es Ihnen, den heruntergeladenen Code sofort zu starten.  Er f√ºhrt jedoch nicht alle theoretisch m√∂glichen Optimierungen durch, da dies mehr Zeit erfordert.  Solche Optimierungen werden von einem anderen Compiler durchgef√ºhrt, der im Hintergrund arbeitet.  Sobald er seine Arbeit beendet hat, ersetzt eine Version im Speicher eine andere und funktioniert stattdessen. <br><br>  So erhalten wir sowohl den schnellen Start der Anwendung als auch deren effektiven Betrieb. <br><br><h3>  F√§higkeit: Caching </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="Bild"><br><br>  Wenn wir einmal WebAssembly-Code vom optimierenden Compiler heruntergeladen und kompiliert haben, ist es nicht sinnvoll, dasselbe zu tun, wenn Sie diesen Code auf eine andere Registerkarte laden (oder beim n√§chsten √ñffnen des Browsers, sofern die Anwendung unver√§ndert bleibt).  Kompilierter Code kann (und sollte) zwischengespeichert und dann aus dem Cache verwendet werden. <br><br><h3>  Geschicklichkeit: andere Verbesserungen </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="Bild"><br><br>  Jetzt wird viel dar√ºber diskutiert, welche anderen Verbesserungen m√∂glich sind und worauf sich die Bem√ºhungen der Entwickler konzentrieren sollten.  Etwas wird definitiv realisiert, etwas nicht sofort, etwas wird √ºberhaupt nicht passieren.  Ich werde mit Ihrer Erlaubnis all diese Punkte in der allgemeinen Klasse ‚ÄûSonstige Verbesserungen‚Äú definieren, und was darin enthalten sein wird, werden wir mit der Zeit verstehen. <br><br><h3>  Wo sind wir jetzt </h3><br>  Irgendwo hier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="Bild"><br><br><h4>  Multithreading </h4><br>  F√ºr Multithreading haben wir einen fast fertigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plan</a> , aber einer seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptteile</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SharedArrayBuffers</a> ) musste Anfang dieses Jahres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deaktiviert werden</a> .  Es wird bald wieder eingeschaltet und wir k√∂nnen fortfahren. <br><br><h4>  SIMD </h4><br>  Im Moment aktiv <a href="">entwickelt</a> . <br><br><h4>  64-Bit-Adressierung </h4><br>  F√ºr <a href="">wasm-64</a> haben wir eine ziemlich klare Vorstellung davon, wie die Dinge funktionieren sollten.  Wir basierten auf x86- und ARM-Architekturans√§tzen. <br><br><h4>  Stream-Kompilierung </h4><br>  In Firefox wurde es bereits 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugef√ºgt</a> , andere Browser arbeiten daran. <br><br><h4>  Verwenden von zwei Compilern </h4><br>  In Firefox wurde dies bereits 2017 und in anderen Browsern im Jahr 2018 hinzugef√ºgt. <br><br><h4>  Implizites HTTP-Caching </h4><br>  In Firefox ist die Entwicklung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fast abgeschlossen</a> , es wird bald eine Ver√∂ffentlichung geben. <br><br><h4>  Weitere Verbesserungen </h4><br>  Es gibt eine Diskussion <br><br>  Wie Sie sehen k√∂nnen, befinden sich die meisten Elemente noch in der aktiven Entwicklung.  Dennoch k√∂nnen wir bereits heute Anwendungen sehen, die auf WebAssembly ausgef√ºhrt werden, da die heutigen Funktionen bereits f√ºr jemanden ausreichen.  Sobald alle oben genannten Funktionen verf√ºgbar sind, werden wir eine weitere ‚Äûneue Errungenschaft‚Äú er√∂ffnen und noch mehr neue Anwendungen werden WebAssembly-Unterst√ºtzung erhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="Bild"><br><br><h2>  Javascript-Interaktion </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="Bild"></a> <br><br>  WebAssembly wurde nicht nur als Plattform f√ºr Spiele und schwere Anwendungen entwickelt.  Es kann f√ºr die regelm√§√üige Webentwicklung verwendet werden.  Wir sind uns bewusst, dass heutzutage sehr gro√üe Webanwendungen in Javascript geschrieben sind und nur wenige beschlie√üen, sie in WebAssembly zu √ºbernehmen und vollst√§ndig neu zu schreiben.  Der wichtige Punkt hierbei ist, dass dies nicht notwendig ist.  H√∂chstwahrscheinlich funktionieren die meisten dieser Anwendungen recht gut und nur bei einigen Engp√§ssen mangelt es m√∂glicherweise an Leistung bei Berechnungen, Datenverarbeitungsbandbreite oder mangelnder Funktionalit√§t, da eine JS-Version einer Bibliothek fehlt.  Wir m√∂chten Entwicklern die M√∂glichkeit geben, nur diese Engp√§sse in WebAssembly neu zu schreiben und den Rest des Codes in vertrauter JS zu belassen.  Und das ist schon m√∂glich.  Durch das Umschreiben des Gutenberg-Parsers in Rust und das Erstellen unter WebAssebly gelang es uns beispielsweise, die Produktivit√§t um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">86-fache zu</a> steigern. <br><br>  Aber um eine solche √úbungsmasse und Bequemlichkeit zu schaffen, m√ºssen wir etwas anderes implementieren. <br><br><h3>  F√§higkeit: schnelle Anrufe zwischen JS und WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="Bild"><br><br>  Das Aufrufen von WebAssembly von JS sollte sehr schnell funktionieren.  Durch Hinzuf√ºgen eines kleinen WebAssembly-Moduls sollte der Programmierer keinen Leistungsverlust sp√ºren, selbst wenn dieses Modul sehr oft aufgerufen wird.  Dies ist bei MVP nicht der Fall (da das Ziel von MVP nicht darin bestand, die Leistung solcher Anrufe zu maximieren).  Dieses Problem muss noch behoben werden.  In Firefox haben wir bereits sichergestellt, dass einige JS-&gt; WebAssembly-Aufrufe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits schneller sind als nicht inline JS-&gt; JS-Aufrufe</a> .  Entwickler anderer Browser arbeiten ebenfalls an dieser Aufgabe. <br><br><h3>  Geschicklichkeit: schneller Datenaustausch </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="Bild"><br><br>  Diese Aufgabe ist mit der vorherigen verbunden: Es ist wichtig, nicht nur schnell WebAssembly-Code von JS aufzurufen, sondern auch schnell Daten zwischen diesen zu √ºbertragen.  Es gibt bestimmte Probleme damit.  Zum Beispiel die Tatsache, dass WebAssembly nur Zahlen versteht.  Es sind keine Objekte darin, aber in JS sind sie es.  Es stellt sich heraus, dass wir eine Art √úbersetzungsschicht brauchen.  Es existiert bereits, ist aber immer noch nicht produktiv genug. <br><br><h3>  F√§higkeit: Integration mit ES-Modulen </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="Bild"><br><br>  Die Verwendung des WebAssembly-Moduls sieht jetzt so aus, als w√ºrde eine spezielle API aufgerufen, die das Modul zur Verwendung an Sie zur√ºckgibt.  Dies bedeutet jedoch, dass das WebAssembly-Modul nicht wirklich Teil des JS-Moduldiagramms der Webanwendung ist.  Damit alle Funktionen f√ºr ES-Module verf√ºgbar sind (z. B. Export und Import), muss das WebAssembly-Modul in ES-Module integriert werden k√∂nnen. <br><br><h3>  F√§higkeit: Integration in die Entwicklung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="Bild"><br><br>  Nur importieren und exportieren zu k√∂nnen, bedeutet nicht, ein voll funktionsf√§higes Modul zu werden.  Wir brauchen einen Ort, an dem WebAssembly-Module verteilt werden k√∂nnen.  Was ist das Analogon von npm f√ºr WebAssembly?  Hmm ... wie w√§re es mit npm selbst?  Und was wird das Analogon von Webpack oder Parcel for WebAssembly sein?  Hmm ... was ist mit Webpack und Paket? <br><br>  WebAssembly-Module sollten sich nicht von normalen Modulen unterscheiden. Dies bedeutet, dass sie √ºber dieselbe Infrastruktur verteilt werden k√∂nnen.  Wir brauchen jedoch Tools, um sie in diese Infrastruktur zu integrieren. <br><br><h3>  F√§higkeit: Abw√§rtskompatibilit√§t </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="Bild"><br><br>  Es gibt noch eine andere wichtige Sache, die wir bereitstellen m√ºssen.  Auch in √§lteren Browserversionen sollte alles gut funktionieren.  Auch diejenigen, die keine Ahnung von WebAssembly haben.  Wir m√ºssen sicherstellen, dass der Entwickler nach dem Schreiben des Codes f√ºr WebAssembly nicht die zweite Version desselben Codes in Javascript schreiben muss, nur weil die Site auch in IE11 ge√∂ffnet werden muss. <br><br><h3>  Wo sind wir jetzt </h3><br>  Irgendwo hier: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="Bild"><br><br><h4>  Verkn√ºpfungen zwischen JS und WebAssembly </h4><br>  In Firefox bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert</a> , wird in anderen Browsern gearbeitet. <br><br><h4>  Schneller Datenaustausch </h4><br>  Es gibt mehrere Vorschl√§ge.  Erweitern Sie beispielsweise das Typsystem in WebAssembly um Verweise auf JS-Objekte.  Dies ist m√∂glich, erfordert jedoch das Schreiben von zus√§tzlichem Code (z. B. zum Aufrufen von JS-Methoden), der nicht zu schnell funktioniert.  Um dieses Problem zu l√∂sen, gibt es wiederum mehrere Vorschl√§ge. <br><br>  Es gibt einen weiteren Aspekt im Zusammenhang mit dem Datenaustausch.  Hier geht es darum zu verfolgen, wie lange Daten im Speicher gespeichert werden k√∂nnen.  Wenn Sie Daten im Speicher haben, auf die der JS-Code Zugriff haben soll, m√ºssen Sie diese dort belassen, bis der JS-Code sie liest.  Aber wenn Sie sie f√ºr immer dort lassen, bekommen wir ein Speicherleck.  Wie kann man herausfinden, dass Daten bereits gel√∂scht werden k√∂nnen (der JS-Code hat sie bereits gelesen)?  Diese Verantwortung liegt heute beim Programmierer - alles wird manuell freigegeben.  Sobald der JS-Code die Daten gelesen hat, sollte er so etwas wie die "freie" Funktion aufrufen.  Dieser Ansatz ist jedoch veraltet und f√ºhrt h√§ufig zu Fehlern.  Um dieses Problem zu l√∂sen, haben wir das Konzept von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WeakRef</a> in Javascript eingef√ºhrt.  Dies erm√∂glicht es, Daten auf der Seite des JS-Codes zu lesen und, wenn der Garbage Collector funktioniert, den Speicher im WebAssembly-Modul korrekt zu l√∂schen. <br><br>  All dies befindet sich noch in der Entwicklung.  In der Zwischenzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden</a> im Rust-√ñkosystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools erstellt</a> , die das Schreiben eines solchen Codes f√ºr Sie automatisieren und Teile, die noch nicht implementiert wurden, durch ihre eigene Implementierung ersetzen.  Eines dieser Tools verdient besondere Erw√§hnung.  Es hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasm-bindgen</a> .  Wenn er bemerkt, dass Ihr Rust-Code versucht, JS-Objekte oder DOM-Objekte abzurufen oder zur√ºckzugeben, erstellt er automatisch eine JS-Ebene, die mit Ihrem Rust-Code interagieren kann.  Diese Ebene kann auch mit dem WebAssembly-Modul interagieren, das in einer anderen Sprache geschrieben ist, sodass nicht nur Rust-Programmierer dieses Tool verwenden k√∂nnen. <br><br><h4>  Integration mit ES-Modulen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein</a> Arbeitsplan in diesem Bereich gibt es schon seit geraumer Zeit.  Wir arbeiten gemeinsam mit Entwicklern anderer Browser aktiv daran. <br><br><h4>  Entwicklungsintegration </h4><br>  Es gibt bereits Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasm-pack</a> im Rust-√ñkosystem, mit denen Sie automatisch alles, was Sie f√ºr die Ver√∂ffentlichung ben√∂tigen, in npm packen k√∂nnen.  Und es gibt Leute, die dieses Tool verwenden, um ihre Module zu erstellen. <br><br><h4>  Abw√§rtskompatibilit√§t </h4><br>  Aus Gr√ºnden der Abw√§rtskompatibilit√§t haben wir das Tool wasm2js.  Sie k√∂nnen eine WASM-Datei in eine entsprechende JS-Datei umwandeln.  Dieser Javascript-Code ist nicht schnell, funktioniert jedoch in jedem Browser (einschlie√ülich eines Browsers, der WebAssembly nicht unterst√ºtzt). <br><br>  Wie Sie sehen, stehen wir diesem ‚ÄûErfolg‚Äú sehr nahe.  Und sobald wir dies tun, wird sich der Weg zu zwei weiteren √∂ffnen. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="Bild"></a> <br><br><h2>  JS-Frameworks und JS-kompilierte Sprachen </h2><br>  Die erste ist die M√∂glichkeit, beliebte JS-Frameworks im Schwergewicht auf WebAssebly neu zu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="Bild"><br><br>  Die zweite M√∂glichkeit besteht darin, Programmiersprachen zu aktivieren, die in Javascript kompiliert werden, um sie durch WebAssembly zu ersetzen.  Wir sprechen √ºber Sprachen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scala.js</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reason</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="Bild"><br><br>  F√ºr beide Aufgaben muss WebAssembly eine Reihe neuer Funktionen auf hoher Ebene unterst√ºtzen. <br><br><h3>  F√§higkeit: M√ºllsammler </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="Bild"><br><br>  Wir m√ºssen aus mehreren Gr√ºnden in einen browserbasierten Garbage Collector integriert werden.  Erinnern wir uns zun√§chst an die Aufgabe, JS-Frameworks (oder Teile davon) neu zu schreiben.  Es kann erforderlich sein. ,  React      DOM-,     Rust   .     -     .   DOM     ,         ,        . ,    ,     ,      .      ,   . <br><br>        JS-.       - ,   .           ,      ,       Javascript.  JS-          WebAssembly-,            JS-. <br><br>       (  ),       .    ,   ,    . WebAssembly        ,   . <br><br>       Scala.js, Reason, Kotlin  Elm ‚Äî     Javascript,        .   WebAssembly      ‚Äî          WebAssembly             (    ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="Bild"><br><br>    . ,  ,  Rust,   .    ‚Äî .            ‚Äî    .       WebAssembly     . <br><br>  ,    Javascript.          ‚Äî -           - .   WebAssembly-  JS-,     ‚Äî      .   Rust, ,     .   ,       . <br><br><h3> :  </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="Bild"><br><br>   ,    JS-,    .         Javascript-.         WebAssembly. <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="Bild"><br><br>       ,   " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ".       ,        ‚Äî              .         ,        WebAssembly. <br><br><h3>   ? </h3><br> -  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="Bild"><br><br><h4>   </h4><br>  Die Implementierung der Garbage Collection wird derzeit in zwei Richtungen durchgef√ºhrt: Dies sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typisierte Objekte</a> f√ºr JS und tats√§chlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Garbage Collector f√ºr WebAssembly</a> .  Mit typisierten Objekten k√∂nnen Sie die klare Struktur des Objekts beschreiben.  Es gibt bereits eine Vision, wie dies funktionieren soll, und sie wird auf dem bevorstehenden TC39-Treffen er√∂rtert.  Dementsprechend kann der GC f√ºr WebAssembly f√ºr seine eigenen Zwecke auf die obige Struktur zugreifen.  An der Umsetzung wird bereits gearbeitet. <br><br>  Sobald beide Teile fertig sind, erhalten wir durch die Interaktion von JS und WebAssembly ein System, das auf allen Ebenen verstehen kann, woraus das Objekt besteht, und dessen interne Daten effektiv nutzt.  Wir haben bereits einen funktionierenden Prototyp.  Der Prototyp kann jedoch nicht einfach √ºbernommen und freigegeben werden - wir m√ºssen einige Zeit f√ºr Standardisierung und √úberarbeitungen aufwenden.  Wir gehen davon aus, dass es irgendwann im Jahr 2019 ver√∂ffentlicht wird. <br><br><h4>  Ausnahmebehandlung </h4><br>  Die Arbeiten an <a href="">Ausnahmen werden</a> derzeit erforscht und entwickelt.  Wir pr√ºfen verschiedene Vorschl√§ge, versuchen sie umzusetzen und sehen, wie effektiv sie funktionieren. <br><br><h4>  Debuggen </h4><br>  F√ºr das Debuggen gibt es bereits Unterst√ºtzung in den Firefox-Entwicklertools.  Aber das Ideal ist noch weit weg.  Wir m√∂chten dem Entwickler seinen Quellcode und seine aktuelle Position darin zeigen und nicht nur Assembler-Anweisungen.  Wir m√ºssen Unterst√ºtzung f√ºr Symboldateien entwickeln und implementieren, die es uns erm√∂glichen, jede Codeanweisung mit der Quellzeile zu korrelieren.  <a href="">Derzeit wird</a> an der Spezifikation dieses Mechanismus gearbeitet. <br><br><h4>  Schwanz ruft </h4><br>  <a href="">Es ist eine Arbeit in Arbeit</a> . <br><br>  Wenn alle oben genannten Schritte abgeschlossen sind, k√∂nnen wir davon ausgehen, dass wir den Erfolg ‚ÄûIn JS kompilierte JS-Frameworks und -Sprachen‚Äú erreicht haben. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="Bild"></a> <br><br>  Es war also ein Plan, um ‚ÄûErfolge‚Äú im Browser zu erzielen.  Was passiert au√üerhalb des Browsers? <br><br><h2>  Aus dem Browser </h2><br>  Vielleicht war Ihnen die Kombination der W√∂rter "au√üerhalb des Browsers" peinlich.  Haben wir wirklich etwas anderes als den Browser, wenn wir √ºber das Web sprechen?  Aber das "Web" haben wir direkt im Namen "WebAssembly".  Tats√§chlich sind HTML, CSS und JavaScript jedoch nur die Spitze des Eisbergs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="Bild"><br><br>  Ja, sie sind am besten sichtbar, weil sie die Benutzeroberfl√§che bilden.  Aber es gibt noch einen anderen sehr wichtigen Teil des Webs - die Verbindungen.  Die Verbindung von allem mit allem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="Bild"><br><br>  Ich kann jetzt auf Ihre Seite verlinken.  Ich brauche weder Ihre noch die Erlaubnis eines anderen.  Ich mache einfach diesen Link und f√ºge ihn meiner Seite hinzu.  Jeder kann ihm folgen und Ihr Inhalt wird angezeigt, der von Ihnen geschriebene Code wird gestartet.  Diese Einfachheit, Verbindungen herzustellen und durch sie zu wechseln, hat unser Internet so geschaffen, wie es ist.  Jetzt haben wir soziale Netzwerke und andere Websites, die das Konzept der ‚ÄûVerkn√ºpfung‚Äú im Wesentlichen um die M√∂glichkeit erweitern, alles anzudocken: Personen, Ger√§te, Unternehmen usw. <br><br>  Bei all diesen Links und Links gibt es jedoch zwei Probleme. <br><br>  Zu was sollte der Link f√ºhren?  Wenn Sie irgendwohin gehen und die Site Ihnen Code bietet, der in Ihrem Browser ausgef√ºhrt werden muss, sollte dieser Code plattform√ºbergreifend sein.  Es sollte zu etwas kompiliert und auf einer Mohnblume, unter Windows, auf einem Android ausgef√ºhrt werden.  √úberall.  Die Portabilit√§t von herunterladbarem Code ist ein wichtiger Bestandteil des Konzepts der Webkonnektivit√§t. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="Bild"><br><br>  Es reicht jedoch nicht aus, nur den Code herunterzuladen und auszuf√ºhren.  Sie m√ºssen verstehen, dass wir nichts √ºber diesen Code wissen.  Wir vertrauen ihm nicht genug, um die volle Kontrolle √ºber den Computer des Benutzers zu geben.  Was ist, wenn es sich um b√∂sartigen Code handelt?  Er kann etwas Schlimmes tun.  Und hier brauchen wir eine Art Sicherheitsmodell.  Wir brauchen eine Sandbox, in der wir einen unbekannten Code einf√ºgen, ihm kontrollierte Tools f√ºr die Arbeit geben k√∂nnen, aber alles, was wichtig und unsicher ist, entfernen k√∂nnen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="Bild"><br><br>  Das Konzept der ‚ÄûKommunikation‚Äú umfasst also zwei Aspekte: Portabilit√§t und Sicherheit.  Wir wissen, dass wir den Code definitiv ausf√ºhren k√∂nnen und dass er uns sicherlich nicht schaden wird.  Warum bestehe ich auf diesen Konzepten und wie unterscheidet sich diese Sicht der Dinge von der Sicht des Webs als Kombination aus HTML, CSS und Javascript?  Weil dieser Ansatz die Ansicht von WebAssembly grundlegend √§ndert. <br><br>  Einerseits k√∂nnen wir uns WebAssembly als ‚Äûein weiteres Tool vorstellen, das in einem modernen Browser verf√ºgbar ist‚Äú.  Und so ist es auch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="Bild"><br><br>  Die Portabilit√§t und Sicherheit der Codeausf√ºhrung √∂ffnen uns jedoch andere T√ºren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="Bild"><br><br><h2>  Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="Bild"><br><br>  Wie kann WebAssembly Node helfen?  Portabilit√§t bringen. <br><br>  Der Knoten bietet mithilfe von Javascript ein relativ hohes Ma√ü an Portabilit√§t.  Es gibt jedoch immer noch viele F√§lle, in denen die Leistung des JS-Codes nicht ausreicht oder nur der richtige JS-Code noch nicht geschrieben wurde, aber es gibt eine native Version davon.  Und dann verwendet Node native Module.  Sie sind in Sprachen wie C geschrieben und m√ºssen f√ºr die spezifische Plattform kompiliert werden, auf der Ihr Knoten ausgef√ºhrt wird. <br><br>  Native Module k√∂nnen entweder w√§hrend der Installation kompiliert werden oder Sie k√∂nnen sie sofort f√ºr eine der g√§ngigen Plattformen bereitstellen.  Beide Ans√§tze sind m√∂glich, aber dies ist nur eine Auswahl von zwei √úbeln: entweder zus√§tzliche Kopfschmerzen f√ºr den Benutzer oder den Autor des Moduls. <br><br>  Wenn Sie sich vorstellen, dass sich diese Module in WebAssembly befinden, m√ºssen sie √ºberhaupt nicht kompiliert werden.  Mit Portability k√∂nnen Sie sie sofort auf jeder Plattform ausf√ºhren, z. B. mit Javascript-Code.  Sie funktionieren jedoch mit der Leistung nativer Versionen. <br><br>  Und hier kommt das Gl√ºck in die Welt von Node in Form der vollst√§ndigen Portabilit√§t von allem und √ºberall.  Sie k√∂nnen die Node-Anwendung von Linux auf Windows portieren - und alles funktioniert ohne Neukompilierung weiter.  Gleichzeitig hat das WebAssembly-Modul keinen Zugriff auf Systemressourcen (es funktioniert in seiner Sandbox).  Aber native (und sogar nicht native) Node-Module funktionieren nicht in der Sandbox, sie haben Zugriff auf alles - das ist die Ideologie von Node.  Damit das WebAssembly-Modul dieselben Funktionen erh√§lt, ist eine zus√§tzliche Zugriffsebene auf Betriebssystemressourcen erforderlich.  So etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POSIX-</a> Funktionen (sie sind nicht notwendig, sie werden nur als Beispiel f√ºr eine relativ stabile und ausreichende Ressourcenzugriffsschnittstelle angegeben). <br><br><h3>  F√§higkeit: tragbare Schnittstelle </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="Bild"><br><br>  Was ben√∂tigen Node-Entwickler, um WebAssembly-Module zu verwenden?  Eine Art Schnittstelle, um auf seine Funktionen zuzugreifen.  Es w√§re sch√∂n, es zu standardisieren.  Nun, damit nicht nur Node diese Funktionen aufrufen kann, sondern auch jeder im Allgemeinen.  Wenn Sie das WebAssembly-Modul in Ihrer Anwendung verwenden m√∂chten, haben wir eine Verbindung hergestellt und verwenden es.  So etwas wie "POSIX for WebAssembly".  PWSIX (tragbare WebAssembly-Systemschnittstelle)? <br><br><h3>  Wo sind wir jetzt </h3><br>  Es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument</a> , das den Mechanismus zum Bereitstellen eines Pfads zu einem Modul anhand seines Namens beschreibt.  Dies wird wahrscheinlich sowohl von Browsern als auch von Node verwendet (sie k√∂nnen unterschiedliche Pfade bereitstellen).  Es gibt zwar keine aktive Entwicklung, aber es wird viel diskutiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="Bild"><br><br>  H√∂chstwahrscheinlich wird es in irgendeiner Form implementiert.  Das ist gut, weil es uns eine Reihe von M√∂glichkeiten er√∂ffnet. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="Bild"></a> <br><br><h2>  CDN, Serverless und Edge Computing </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="Bild"><br><br>  Beispiele sind Dinge wie CDN, Serverless, Edge Computing.  F√§lle, in denen Sie Ihren Code auf den Server einer anderen Person stellen, wodurch die Verf√ºgbarkeit f√ºr Clients sichergestellt wird.  Warum ben√∂tigen Sie hier m√∂glicherweise WebAssembly?  K√ºrzlich gab es einen ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> zu diesem Thema.  Kurz gesagt, es kann erforderlich sein, Code aus verschiedenen Quellen (die sich nicht gegenseitig vertrauen) innerhalb eines Prozesses auszuf√ºhren.  Dieser Code muss voneinander und vom Betriebssystem isoliert sein.  L√∂sungen wie eine virtuelle JS-Maschine (SpiderMonkey oder V8) funktionieren irgendwie, bieten jedoch nicht die gew√ºnschte Leistung und Skalierbarkeit.  Und WebAssembly - gibt. <br><br>  Was ist erforderlich, damit dies funktioniert? <br><br><h3>  F√§higkeit: Laufzeit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="Bild"><br><br>  Wir brauchen eine Laufzeitumgebung und einige Unternehmen erstellen ihre eigenen.  Wir haben bereits WebAssembly-Compiler (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cranelift</a> ) - sie sind schnell und speichereffizient.  Aber der von ihm generierte Code kann nicht in einem Vakuum leben - er muss sich auf etwas verlassen, irgendwie mit der Umgebung interagieren.  Jetzt schreiben einige Unternehmen, wie z. B. Fastly, diese Laufzeitumgebung selbst.  Dies ist jedoch kein sehr guter Ansatz - schlie√ülich werden viele Unternehmen ihn ben√∂tigen und immer wieder die gleiche Arbeit leisten.  Wir k√∂nnten es einmal tun, den Standard erweitern - und jedem eine Menge Ressourcen sparen. <br><br><h3>  Wo sind wir jetzt </h3><br>  Irgendwo hier: <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="Bild"><br><br>  Es gibt noch keinen Laufzeitstandard.  Dies verhindert nicht, dass mehrere unabh√§ngige Laufzeiten, die bereits in realen Projekten verwendet werden, existieren und funktionieren.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WAVM</a> und wasmjit. <br><br>  Wir planen auch die Ver√∂ffentlichung einer Laufzeit, die auf Cranelift basiert und als wasmtime bezeichnet wird.  Und sobald wir etwas standardisiertes und funktionierendes haben, ist dies eine offene Gelegenheit, eine Reihe von Dingen zu entwickeln, wie zum Beispiel ... <br><br><h2>  Tragbare Befehlszeilenprogramme </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="Bild"><br><br>  WebAssembly kann nicht nur im Browser, sondern auch in herk√∂mmlichen Betriebssystemen verwendet werden.  Wir werden nicht √ºber den Kernel sprechen (obwohl es auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Draufg√§nger</a> gibt, die dies winken), aber der WebAssembly-Code funktioniert m√∂glicherweise im Benutzermodus.  Auf diese Weise k√∂nnen Befehlszeilenprogramme erstellt werden, die nach ihrer Erstellung f√ºr jedes Betriebssystem garantiert gleich sind. <br><br><h2>  Internet der Dinge </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="Bild"><br><br>  Mit dem ‚ÄûInternet der Dinge‚Äú sind normalerweise Ger√§te mit geringem Stromverbrauch gemeint (wie tragbare oder verschiedene Sensoren / Controller in ‚ÄûSmart Homes‚Äú).  Einschr√§nkungen der verf√ºgbaren Prozessorressourcen und des Arbeitsspeichers wirken sich negativ auf die F√§higkeit aus, JS-Code dort auszuf√ºhren, aber WebAssembly ist eine ganz andere Sache.  Die Optimierung von Compilern wie Cranelift und einer Laufzeit wie wasmtime wird unter solchen Bedingungen gl√§nzen, da sie nur f√ºr ressourcenschonende Aufgaben geschrieben wurden.  In absolut extremen F√§llen erm√∂glicht WebAssembly sogar das Kompilieren Ihres Moduls in die native Bin√§rdatei der Zielplattform.  Nun, wieder Portabilit√§t - es gibt heutzutage viele dieser IoT-Ger√§te, die auf verschiedenen Plattformen basieren.  Mit WebAssembly m√ºssen Sie sich dar√ºber keine Gedanken machen - der entwickelte Code wird √ºberall ausgef√ºhrt. <br><br><h2>  Schlussfolgerungen </h2><br>  Lassen Sie uns ein wenig zur√ºckspulen und noch einmal einen Blick auf unseren ‚ÄûF√§higkeitsbaum‚Äú werfen. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="Bild"></a> <br><br>  Ich habe diesen Artikel mit der Tatsache begonnen, dass einige Leute nicht verstehen, warum WebAssembly noch nicht fertig ist.  Wie Sie jetzt verstehen k√∂nnen, hat sein Weg kaum begonnen.  Ja, MVP er√∂ffnet bereits einige M√∂glichkeiten.  Wir k√∂nnen bereits etwas in WebAssembly kompilieren und in einem Browser ausf√ºhren.  Aber es liegt noch viel Arbeit vor uns - Unterst√ºtzung f√ºr alles, was Sie f√ºr umfangreiche Anwendungen und Hochsprachen ben√∂tigen, Ersetzen von JS-Frameworks und all diese Dinge, √ºber die ich au√üerhalb des Browsers gesprochen habe.  Wenn dies alles fertig ist, werden wir ein neues Web sehen.  Hohe Leistung, gr√∂√üer, tragbarer.  Es wird keine solche Software mehr geben, die nicht f√ºr die Ausf√ºhrung im Browser geschrieben werden kann: Spiele, Blockchain, Internet der Dinge, Befehlszeilenprogramme - alles wird gestartet. <br><br>  WebAssembly ist nicht abgeschlossen.  Er hat gerade erst begonnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428347/">https://habr.com/ru/post/de428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428337/index.html">Unterhaltsames JavaScript: Ohne geschweifte Klammern</a></li>
<li><a href="../de428339/index.html">Automatisieren Sie es nicht: Schlechte Gesch√§ftstipps</a></li>
<li><a href="../de428341/index.html">Qsan RAID EE-Technologie</a></li>
<li><a href="../de428343/index.html">Ein interessantes Puzzle in C.</a></li>
<li><a href="../de428345/index.html">Anforderungen mit F√§llen abdecken. SuperJob Realit√§ten</a></li>
<li><a href="../de428349/index.html">Gurke in der Cloud: Verwenden von BDD-Skripten f√ºr Produktstresstests</a></li>
<li><a href="../de428357/index.html">Absorption in der Praxis: eine Lebensgeschichte</a></li>
<li><a href="../de428361/index.html">A la perfecci√≥n: Verbesserung von WordPress mit AMP f√ºr WordPress- und Setka Editor-Plugins</a></li>
<li><a href="../de428363/index.html">Jetpack / Hoverboard bauen: Rettungssysteme</a></li>
<li><a href="../de428365/index.html">Die Geschichte, wie sich die Google-Abrechnung ge√§ndert hat oder wie unn√∂tige Kosten vermieden werden k√∂nnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>