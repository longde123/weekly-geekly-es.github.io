<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏾 👨🏼‍🔧 💕 Die Zukunft von WebAssembly als „Skill Tree“ 👨🏿‍✈️ 💜 🖇️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einige Leute haben WebAssembly irgendwie falsch verstanden. Es gibt Leute, die glauben, dass alles bereit ist, da Browser WebAssembly bereits unterstü...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Zukunft von WebAssembly als „Skill Tree“</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/428347/">  Einige Leute haben WebAssembly irgendwie falsch verstanden.  Es gibt Leute, die glauben, dass alles bereit ist, da Browser WebAssembly bereits unterstützen (seit 2017).  Noch nicht einmal in der Nähe, nur MVP (minimal lebensfähiges Produkt) ist bereit.  Ich kann mir vorstellen, woher die Wurzel dieses Fehlers stammt: Nach der MVP-Veröffentlichung versprachen die Entwickler, die Abwärtskompatibilität auf der Ebene von "Jeder jetzt geschriebene Code <b>wird</b> in Zukunft funktionieren" beizubehalten.  Dies bedeutet jedoch nicht, dass die Entwicklung von WebAssembly abgeschlossen ist, überhaupt nicht!  Viele Funktionen werden derzeit entwickelt und sind für die nahe Zukunft geplant.  Und wenn sie implementiert werden, wird sich alles sehr ändern. <br><br>  Sie können versuchen, sich all diese Funktionen in einem Spiel in Form eines Fähigkeitsbaums vorzustellen.  Wir haben ein paar „grundlegende“ (bereits implementierte Funktionen) und einen ganzen Baum mit vielen Zweigen und Blättern, die sich im Laufe der Zeit öffnen und uns immer mehr Kraft geben. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="Bild"></a> <br>  Schauen wir uns an, was wir jetzt schon haben und was wir noch entdecken müssen. <br>  ( <b>Unter dem Schnitt viele Bilder, Verkehr</b> ) <br><a name="habracut"></a><br><h2>  Minimum Viable Product (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="Bild"><br>  Ganz am Anfang der Geschichte von WebAssembly steht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Emscripten</a> , mit dem C ++ - Code in JavaScript-Code kompiliert werden konnte.  Dies ermöglichte es uns, eine große Anzahl von C ++ - Bibliotheken in die Welt des Webs zu übertragen, ohne die es unmöglich wäre, Code auf höherer Ebene auszuführen.  Der generierte JS-Code war alles andere als ideal und arbeitete langsam (im Vergleich zu seiner nativen Version).  Trotzdem haben die Mozilla-Ingenieure einige Möglichkeiten gefunden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um</a> es schneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu machen</a> .  Die wichtigste war die Zuweisung einer Teilmenge der Sprache, die mit Geschwindigkeiten ausgeführt werden konnte, die mit den Ausführungsgeschwindigkeiten des nativen Codes vergleichbar waren.  Diese Teilmenge wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asm.js genannt.</a> <br><br>  Entwickler anderer Browser bemerkten und schätzten die Geschwindigkeit von asm.js, alle gängigen Browser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erhielten</a> ihre Unterstützung.  Aber das hat die Geschichte nicht beendet.  Das war erst der Anfang.  Es gab immer noch Raum, um schneller zu arbeiten.  Aber sie gingen bereits über Javascript hinaus.  Es stellte sich heraus, dass der native Code (zum Beispiel in C ++) nicht in Javascript kompiliert werden musste, sondern in etwas anderem.  In etwas Neues, speziell als schnelle Alternative zu JS erstellt.  Und so entstand WebAssembly. <br><br>  Was ist in der ersten Version von WebAssembly enthalten?  Was war genug, um den stolzen Titel „Minimum Viable Product“ zu erhalten? <br><br><h3>  Fähigkeit: Ziel-Compiler-Plattform </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="Bild"><br><br>  Die Programmierer, die an WebAssembly arbeiteten, verstanden, dass ihre Aufgabe nicht darin bestand, nur C oder C ++ zu unterstützen.  Die Aufgabe bestand darin, die Möglichkeit zu geben, Code in einer beliebigen Sprache in WebAssembly zu kompilieren.  Es musste sich um einen solchen „Assembler“ handeln, der im Browser ausgeführt werden sollte, so wie der Maschinencode der Desktop-Anwendung beispielsweise auf der x86-Plattform ausgeführt wird.  Diese neue Sprache sollte sich jedoch nicht auf eine bestimmte Plattform stützen. Ihr Ziel sollte eine abstrakte Plattform auf einer höheren Ebene sein, deren spezifische Implementierung bereits von den auf dieser Hardware verwendeten Anweisungen abhängen würde. <br><br><h3>  Fähigkeit: schnelle Codeausführung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="Bild"><br><br>  Alles musste schnell gehen.  Warum sollte man sich sonst mit dieser ganzen Geschichte beschäftigen?  Am Ende sollte der Benutzer in der Lage sein, wirklich "schwere" Anwendungen auszuführen, Top-Spiele im Browser zu spielen usw. <br><br><h3>  Fähigkeit: Kompaktheit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="Bild"><br><br>  Es ist nicht nur wichtig, wie schnell der Code ausgeführt wird, sondern auch, wie schnell er geladen wird.  Benutzer sind an Desktop-Anwendungen gewöhnt, die sehr schnell gestartet werden (da sie lokal installiert sind und über alle erforderlichen Ressourcen verfügen).  Webanwendungen werden auch relativ schnell ausgeführt, da sie nicht so viele Ressourcen gleichzeitig laden.  Dies stellt uns vor eine neue Herausforderung: Wenn wir eine neue Art von Webanwendung mit einer so großen Codebasis wie die klassische Desktop-Anwendung erstellen möchten, die jedoch aus dem Internet heruntergeladen werden kann, sollte der Code so kompakt wie möglich sein. <br><br><h3>  Fähigkeit: Speicherzugriff </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="Bild"><br><br>  Unsere neuen Anwendungen müssen auch etwas anders mit dem Speicher arbeiten als der JavaScript-Code.  Benötigen Sie direkten Zugriff auf Speicherblöcke.  Dies liegt an der Besonderheit der Sprachen C und C ++, in denen es Zeiger gibt.  Ein Zeiger ist grob gesagt eine Variable, die eine Adresse im Speicher enthält.  Eine Anwendung kann Daten an dieser Adresse lesen, ändern und sogar eine Arithmetik für einen Zeiger verwenden, um von der angegebenen Adresse im Speicher vorwärts zu „gehen“.  Eine große Menge von C / C ++ - Code verwendet Zeiger, um die Effizienz seiner Arbeit zu steigern. Die Erstellung einer Zielplattform für solchen Code ist ohne die Unterstützung von Zeigern nicht möglich. <br><br>  Wir können jedoch nicht zulassen, dass aus dem Internet heruntergeladener Code direkten Zugriff auf den Speicher unseres Prozesses hat - dies ist zu gefährlich.  Wir müssen eine Umgebung erstellen, in der einerseits der in WebAssembly kompilierte native Code den direkten Speicherzugriff zulässt, andererseits den Bereich, in dem Daten bearbeitet werden dürfen, streng einschränkt. <br><br>  Zu diesem Zweck verwendet WebAssembly das "lineare Speichermodell".  Dies wird mithilfe von TypedArrays implementiert - so etwas wie ein Array in JavaScript, enthält jedoch nur einen sequentiellen Satz von Bytes im Speicher.  Wenn Sie etwas einfügen möchten, verwenden Sie den Zugriff auf das Element über den Index (der eine Adresse im Speicher sein kann).  Somit gibt dieses Array vor, ein Speicherblock für C ++ - Code zu sein. <br><br><h3>  Neue Leistung! </h3><br>  Mit all dem können die Benutzer die Desktop-Anwendung endlich in einem Browser mit ungefähr der gleichen Leistung ausführen, als wäre sie nativ.  Das ist ungefähr dieser Funktionsumfang und wurde als "Minimum Viable Product" (MVP) bezeichnet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="Bild"><br><br>  Zu diesem Zeitpunkt könnten einige Anwendungen tatsächlich bereits unter WebAssembly erstellt werden und im Browser Geld verdienen.  Aber es war noch ein langer Weg vor uns. <br><br><h2>  Schwergewichtige Desktop-Anwendungen </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="Bild"><br><br>  Der nächste wichtige Schritt sollte die Möglichkeit sein, wirklich große Desktop-Anwendungen zu starten.  Können Sie sich vorstellen, dass die Vollversion von Photoshop in einem Browser ausgeführt wird?  Und Sie haben es nicht installiert, sondern nur den Link geöffnet - und jetzt haben Sie die 100% ige Leistung dieses Produkts mit nativer Geschwindigkeit, der neuesten Version mit allen Updates und Korrekturen, auf jedem Gerät. <br><br>  Und davon sind wir nicht weit entfernt - Beispiele tauchen bereits auf.  Zum Beispiel AutoCAD.  Und auch Adobe Lightroom.  Aber seien wir ehrlich - in der aktuellen Implementierung von WebAssembly ist nicht alles bereit, um wirklich große Anwendungen zu starten.  Engpässe werden genau hier untersucht und behoben, wenn Sie diesen Artikel lesen. <br><br><h3>  Fähigkeit: Multithreading </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="Bild"><br><br>  Natürlich brauchen wir Multithreading.  Moderne Computer haben viele Kerne.  Wir müssen sie nutzen können. <br><br><h3>  Fähigkeit: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="Bild"><br><br>  Neben Multithreading gibt es eine weitere Technologie, die eine effizientere Implementierung der parallelen Datenverarbeitung ermöglicht.  Dies ist SIMD: Verarbeitung mehrerer Datenblöcke gleichzeitig durch einen einzigen Befehl.  Ein wichtiger Aspekt für eine wirklich schnelle WebAssembly. <br><br><h3>  Fähigkeit: 64-Bit-Adressierung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="Bild"><br><br>  Ein weiteres wichtiges Merkmal der modernen Hardwarearchitektur, das in WebAssembly noch nicht verfügbar ist, ist die Unterstützung der 64-Bit-Speicheradressierung.  Alles ist einfach: Mit 32-Bit-Adressen können Sie nur 4 GB Speicher verwenden (was für große Programme sehr klein ist), aber mit 64-Bit-Adressen sind es bereits bis zu 16 Exabyte (dies ist viel für moderne Software).  Natürlich ist nicht nur das theoretische Maximum wichtig, sondern auch das praktische (wie viel Speicher das Betriebssystem Ihnen geben wird).  Auf den meisten modernen Geräten sind jedoch bereits 4 oder mehr GB RAM vorhanden, und diese Anzahl wird zunehmen. <br><br><h3>  Fähigkeit: Stream-Zusammenstellung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="Bild"><br><br>  Wir müssen nicht nur Anwendungen schnell ausführen.  Wir müssen auch das Zeitintervall zwischen dem Start des Downloads über das Netzwerk und dem Start verkürzen.  Mit der Stream-Kompilierung können Sie mit der Verarbeitung einer WebAssembly-Datei beginnen, bevor sie endgültig heruntergeladen wird.  Wir überprüfen die Anweisungen beim Herunterladen über das Netzwerk.  Das Laden und Kompilieren erfolgt also parallel.  In Firefox-Code konnten wir eine Kompilierungsgeschwindigkeit erreichen, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">höher als die Download-Geschwindigkeit</a> war. Das heißt, die Verarbeitungszeit eines Codes mit N Bytes war kürzer als die Download-Zeit dieses Codes über das Netzwerk.  Entwickler anderer Browser arbeiten ebenfalls an der Stream-Kompilierung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="Bild"><br><br>  Eine Sache im Zusammenhang mit der Streaming-Kompilierung ist die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei Compilern</a> .  Eine davon (oben beschrieben) funktioniert schnell und ermöglicht es Ihnen, den heruntergeladenen Code sofort zu starten.  Er führt jedoch nicht alle theoretisch möglichen Optimierungen durch, da dies mehr Zeit erfordert.  Solche Optimierungen werden von einem anderen Compiler durchgeführt, der im Hintergrund arbeitet.  Sobald er seine Arbeit beendet hat, ersetzt eine Version im Speicher eine andere und funktioniert stattdessen. <br><br>  So erhalten wir sowohl den schnellen Start der Anwendung als auch deren effektiven Betrieb. <br><br><h3>  Fähigkeit: Caching </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="Bild"><br><br>  Wenn wir einmal WebAssembly-Code vom optimierenden Compiler heruntergeladen und kompiliert haben, ist es nicht sinnvoll, dasselbe zu tun, wenn Sie diesen Code auf eine andere Registerkarte laden (oder beim nächsten Öffnen des Browsers, sofern die Anwendung unverändert bleibt).  Kompilierter Code kann (und sollte) zwischengespeichert und dann aus dem Cache verwendet werden. <br><br><h3>  Geschicklichkeit: andere Verbesserungen </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="Bild"><br><br>  Jetzt wird viel darüber diskutiert, welche anderen Verbesserungen möglich sind und worauf sich die Bemühungen der Entwickler konzentrieren sollten.  Etwas wird definitiv realisiert, etwas nicht sofort, etwas wird überhaupt nicht passieren.  Ich werde mit Ihrer Erlaubnis all diese Punkte in der allgemeinen Klasse „Sonstige Verbesserungen“ definieren, und was darin enthalten sein wird, werden wir mit der Zeit verstehen. <br><br><h3>  Wo sind wir jetzt </h3><br>  Irgendwo hier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="Bild"><br><br><h4>  Multithreading </h4><br>  Für Multithreading haben wir einen fast fertigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plan</a> , aber einer seiner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hauptteile</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SharedArrayBuffers</a> ) musste Anfang dieses Jahres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deaktiviert werden</a> .  Es wird bald wieder eingeschaltet und wir können fortfahren. <br><br><h4>  SIMD </h4><br>  Im Moment aktiv <a href="">entwickelt</a> . <br><br><h4>  64-Bit-Adressierung </h4><br>  Für <a href="">wasm-64</a> haben wir eine ziemlich klare Vorstellung davon, wie die Dinge funktionieren sollten.  Wir basierten auf x86- und ARM-Architekturansätzen. <br><br><h4>  Stream-Kompilierung </h4><br>  In Firefox wurde es bereits 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugefügt</a> , andere Browser arbeiten daran. <br><br><h4>  Verwenden von zwei Compilern </h4><br>  In Firefox wurde dies bereits 2017 und in anderen Browsern im Jahr 2018 hinzugefügt. <br><br><h4>  Implizites HTTP-Caching </h4><br>  In Firefox ist die Entwicklung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fast abgeschlossen</a> , es wird bald eine Veröffentlichung geben. <br><br><h4>  Weitere Verbesserungen </h4><br>  Es gibt eine Diskussion <br><br>  Wie Sie sehen können, befinden sich die meisten Elemente noch in der aktiven Entwicklung.  Dennoch können wir bereits heute Anwendungen sehen, die auf WebAssembly ausgeführt werden, da die heutigen Funktionen bereits für jemanden ausreichen.  Sobald alle oben genannten Funktionen verfügbar sind, werden wir eine weitere „neue Errungenschaft“ eröffnen und noch mehr neue Anwendungen werden WebAssembly-Unterstützung erhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="Bild"><br><br><h2>  Javascript-Interaktion </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="Bild"></a> <br><br>  WebAssembly wurde nicht nur als Plattform für Spiele und schwere Anwendungen entwickelt.  Es kann für die regelmäßige Webentwicklung verwendet werden.  Wir sind uns bewusst, dass heutzutage sehr große Webanwendungen in Javascript geschrieben sind und nur wenige beschließen, sie in WebAssembly zu übernehmen und vollständig neu zu schreiben.  Der wichtige Punkt hierbei ist, dass dies nicht notwendig ist.  Höchstwahrscheinlich funktionieren die meisten dieser Anwendungen recht gut und nur bei einigen Engpässen mangelt es möglicherweise an Leistung bei Berechnungen, Datenverarbeitungsbandbreite oder mangelnder Funktionalität, da eine JS-Version einer Bibliothek fehlt.  Wir möchten Entwicklern die Möglichkeit geben, nur diese Engpässe in WebAssembly neu zu schreiben und den Rest des Codes in vertrauter JS zu belassen.  Und das ist schon möglich.  Durch das Umschreiben des Gutenberg-Parsers in Rust und das Erstellen unter WebAssebly gelang es uns beispielsweise, die Produktivität um das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">86-fache zu</a> steigern. <br><br>  Aber um eine solche Übungsmasse und Bequemlichkeit zu schaffen, müssen wir etwas anderes implementieren. <br><br><h3>  Fähigkeit: schnelle Anrufe zwischen JS und WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="Bild"><br><br>  Das Aufrufen von WebAssembly von JS sollte sehr schnell funktionieren.  Durch Hinzufügen eines kleinen WebAssembly-Moduls sollte der Programmierer keinen Leistungsverlust spüren, selbst wenn dieses Modul sehr oft aufgerufen wird.  Dies ist bei MVP nicht der Fall (da das Ziel von MVP nicht darin bestand, die Leistung solcher Anrufe zu maximieren).  Dieses Problem muss noch behoben werden.  In Firefox haben wir bereits sichergestellt, dass einige JS-&gt; WebAssembly-Aufrufe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits schneller sind als nicht inline JS-&gt; JS-Aufrufe</a> .  Entwickler anderer Browser arbeiten ebenfalls an dieser Aufgabe. <br><br><h3>  Geschicklichkeit: schneller Datenaustausch </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="Bild"><br><br>  Diese Aufgabe ist mit der vorherigen verbunden: Es ist wichtig, nicht nur schnell WebAssembly-Code von JS aufzurufen, sondern auch schnell Daten zwischen diesen zu übertragen.  Es gibt bestimmte Probleme damit.  Zum Beispiel die Tatsache, dass WebAssembly nur Zahlen versteht.  Es sind keine Objekte darin, aber in JS sind sie es.  Es stellt sich heraus, dass wir eine Art Übersetzungsschicht brauchen.  Es existiert bereits, ist aber immer noch nicht produktiv genug. <br><br><h3>  Fähigkeit: Integration mit ES-Modulen </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="Bild"><br><br>  Die Verwendung des WebAssembly-Moduls sieht jetzt so aus, als würde eine spezielle API aufgerufen, die das Modul zur Verwendung an Sie zurückgibt.  Dies bedeutet jedoch, dass das WebAssembly-Modul nicht wirklich Teil des JS-Moduldiagramms der Webanwendung ist.  Damit alle Funktionen für ES-Module verfügbar sind (z. B. Export und Import), muss das WebAssembly-Modul in ES-Module integriert werden können. <br><br><h3>  Fähigkeit: Integration in die Entwicklung </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="Bild"><br><br>  Nur importieren und exportieren zu können, bedeutet nicht, ein voll funktionsfähiges Modul zu werden.  Wir brauchen einen Ort, an dem WebAssembly-Module verteilt werden können.  Was ist das Analogon von npm für WebAssembly?  Hmm ... wie wäre es mit npm selbst?  Und was wird das Analogon von Webpack oder Parcel for WebAssembly sein?  Hmm ... was ist mit Webpack und Paket? <br><br>  WebAssembly-Module sollten sich nicht von normalen Modulen unterscheiden. Dies bedeutet, dass sie über dieselbe Infrastruktur verteilt werden können.  Wir brauchen jedoch Tools, um sie in diese Infrastruktur zu integrieren. <br><br><h3>  Fähigkeit: Abwärtskompatibilität </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="Bild"><br><br>  Es gibt noch eine andere wichtige Sache, die wir bereitstellen müssen.  Auch in älteren Browserversionen sollte alles gut funktionieren.  Auch diejenigen, die keine Ahnung von WebAssembly haben.  Wir müssen sicherstellen, dass der Entwickler nach dem Schreiben des Codes für WebAssembly nicht die zweite Version desselben Codes in Javascript schreiben muss, nur weil die Site auch in IE11 geöffnet werden muss. <br><br><h3>  Wo sind wir jetzt </h3><br>  Irgendwo hier: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="Bild"><br><br><h4>  Verknüpfungen zwischen JS und WebAssembly </h4><br>  In Firefox bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">implementiert</a> , wird in anderen Browsern gearbeitet. <br><br><h4>  Schneller Datenaustausch </h4><br>  Es gibt mehrere Vorschläge.  Erweitern Sie beispielsweise das Typsystem in WebAssembly um Verweise auf JS-Objekte.  Dies ist möglich, erfordert jedoch das Schreiben von zusätzlichem Code (z. B. zum Aufrufen von JS-Methoden), der nicht zu schnell funktioniert.  Um dieses Problem zu lösen, gibt es wiederum mehrere Vorschläge. <br><br>  Es gibt einen weiteren Aspekt im Zusammenhang mit dem Datenaustausch.  Hier geht es darum zu verfolgen, wie lange Daten im Speicher gespeichert werden können.  Wenn Sie Daten im Speicher haben, auf die der JS-Code Zugriff haben soll, müssen Sie diese dort belassen, bis der JS-Code sie liest.  Aber wenn Sie sie für immer dort lassen, bekommen wir ein Speicherleck.  Wie kann man herausfinden, dass Daten bereits gelöscht werden können (der JS-Code hat sie bereits gelesen)?  Diese Verantwortung liegt heute beim Programmierer - alles wird manuell freigegeben.  Sobald der JS-Code die Daten gelesen hat, sollte er so etwas wie die "freie" Funktion aufrufen.  Dieser Ansatz ist jedoch veraltet und führt häufig zu Fehlern.  Um dieses Problem zu lösen, haben wir das Konzept von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WeakRef</a> in Javascript eingeführt.  Dies ermöglicht es, Daten auf der Seite des JS-Codes zu lesen und, wenn der Garbage Collector funktioniert, den Speicher im WebAssembly-Modul korrekt zu löschen. <br><br>  All dies befindet sich noch in der Entwicklung.  In der Zwischenzeit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden</a> im Rust-Ökosystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tools erstellt</a> , die das Schreiben eines solchen Codes für Sie automatisieren und Teile, die noch nicht implementiert wurden, durch ihre eigene Implementierung ersetzen.  Eines dieser Tools verdient besondere Erwähnung.  Es heißt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasm-bindgen</a> .  Wenn er bemerkt, dass Ihr Rust-Code versucht, JS-Objekte oder DOM-Objekte abzurufen oder zurückzugeben, erstellt er automatisch eine JS-Ebene, die mit Ihrem Rust-Code interagieren kann.  Diese Ebene kann auch mit dem WebAssembly-Modul interagieren, das in einer anderen Sprache geschrieben ist, sodass nicht nur Rust-Programmierer dieses Tool verwenden können. <br><br><h4>  Integration mit ES-Modulen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein</a> Arbeitsplan in diesem Bereich gibt es schon seit geraumer Zeit.  Wir arbeiten gemeinsam mit Entwicklern anderer Browser aktiv daran. <br><br><h4>  Entwicklungsintegration </h4><br>  Es gibt bereits Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wasm-pack</a> im Rust-Ökosystem, mit denen Sie automatisch alles, was Sie für die Veröffentlichung benötigen, in npm packen können.  Und es gibt Leute, die dieses Tool verwenden, um ihre Module zu erstellen. <br><br><h4>  Abwärtskompatibilität </h4><br>  Aus Gründen der Abwärtskompatibilität haben wir das Tool wasm2js.  Sie können eine WASM-Datei in eine entsprechende JS-Datei umwandeln.  Dieser Javascript-Code ist nicht schnell, funktioniert jedoch in jedem Browser (einschließlich eines Browsers, der WebAssembly nicht unterstützt). <br><br>  Wie Sie sehen, stehen wir diesem „Erfolg“ sehr nahe.  Und sobald wir dies tun, wird sich der Weg zu zwei weiteren öffnen. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="Bild"></a> <br><br><h2>  JS-Frameworks und JS-kompilierte Sprachen </h2><br>  Die erste ist die Möglichkeit, beliebte JS-Frameworks im Schwergewicht auf WebAssebly neu zu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="Bild"><br><br>  Die zweite Möglichkeit besteht darin, Programmiersprachen zu aktivieren, die in Javascript kompiliert werden, um sie durch WebAssembly zu ersetzen.  Wir sprechen über Sprachen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scala.js</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reason</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="Bild"><br><br>  Für beide Aufgaben muss WebAssembly eine Reihe neuer Funktionen auf hoher Ebene unterstützen. <br><br><h3>  Fähigkeit: Müllsammler </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="Bild"><br><br>  Wir müssen aus mehreren Gründen in einen browserbasierten Garbage Collector integriert werden.  Erinnern wir uns zunächst an die Aufgabe, JS-Frameworks (oder Teile davon) neu zu schreiben.  Es kann erforderlich sein. ,  React      DOM-,     Rust   .     -     .   DOM     ,         ,        . ,    ,     ,      .      ,   . <br><br>        JS-.       - ,   .           ,      ,       Javascript.  JS-          WebAssembly-,            JS-. <br><br>       (  ),       .    ,   ,    . WebAssembly        ,   . <br><br>       Scala.js, Reason, Kotlin  Elm —     Javascript,        .   WebAssembly      —          WebAssembly             (    ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="Bild"><br><br>    . ,  ,  Rust,   .    — .            —    .       WebAssembly     . <br><br>  ,    Javascript.          — -           - .   WebAssembly-  JS-,     —      .   Rust, ,     .   ,       . <br><br><h3> :  </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="Bild"><br><br>   ,    JS-,    .         Javascript-.         WebAssembly. <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="Bild"><br><br>       ,   " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ".       ,        —              .         ,        WebAssembly. <br><br><h3>   ? </h3><br> -  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="Bild"><br><br><h4>   </h4><br>  Die Implementierung der Garbage Collection wird derzeit in zwei Richtungen durchgeführt: Dies sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typisierte Objekte</a> für JS und tatsächlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Garbage Collector für WebAssembly</a> .  Mit typisierten Objekten können Sie die klare Struktur des Objekts beschreiben.  Es gibt bereits eine Vision, wie dies funktionieren soll, und sie wird auf dem bevorstehenden TC39-Treffen erörtert.  Dementsprechend kann der GC für WebAssembly für seine eigenen Zwecke auf die obige Struktur zugreifen.  An der Umsetzung wird bereits gearbeitet. <br><br>  Sobald beide Teile fertig sind, erhalten wir durch die Interaktion von JS und WebAssembly ein System, das auf allen Ebenen verstehen kann, woraus das Objekt besteht, und dessen interne Daten effektiv nutzt.  Wir haben bereits einen funktionierenden Prototyp.  Der Prototyp kann jedoch nicht einfach übernommen und freigegeben werden - wir müssen einige Zeit für Standardisierung und Überarbeitungen aufwenden.  Wir gehen davon aus, dass es irgendwann im Jahr 2019 veröffentlicht wird. <br><br><h4>  Ausnahmebehandlung </h4><br>  Die Arbeiten an <a href="">Ausnahmen werden</a> derzeit erforscht und entwickelt.  Wir prüfen verschiedene Vorschläge, versuchen sie umzusetzen und sehen, wie effektiv sie funktionieren. <br><br><h4>  Debuggen </h4><br>  Für das Debuggen gibt es bereits Unterstützung in den Firefox-Entwicklertools.  Aber das Ideal ist noch weit weg.  Wir möchten dem Entwickler seinen Quellcode und seine aktuelle Position darin zeigen und nicht nur Assembler-Anweisungen.  Wir müssen Unterstützung für Symboldateien entwickeln und implementieren, die es uns ermöglichen, jede Codeanweisung mit der Quellzeile zu korrelieren.  <a href="">Derzeit wird</a> an der Spezifikation dieses Mechanismus gearbeitet. <br><br><h4>  Schwanz ruft </h4><br>  <a href="">Es ist eine Arbeit in Arbeit</a> . <br><br>  Wenn alle oben genannten Schritte abgeschlossen sind, können wir davon ausgehen, dass wir den Erfolg „In JS kompilierte JS-Frameworks und -Sprachen“ erreicht haben. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="Bild"></a> <br><br>  Es war also ein Plan, um „Erfolge“ im Browser zu erzielen.  Was passiert außerhalb des Browsers? <br><br><h2>  Aus dem Browser </h2><br>  Vielleicht war Ihnen die Kombination der Wörter "außerhalb des Browsers" peinlich.  Haben wir wirklich etwas anderes als den Browser, wenn wir über das Web sprechen?  Aber das "Web" haben wir direkt im Namen "WebAssembly".  Tatsächlich sind HTML, CSS und JavaScript jedoch nur die Spitze des Eisbergs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="Bild"><br><br>  Ja, sie sind am besten sichtbar, weil sie die Benutzeroberfläche bilden.  Aber es gibt noch einen anderen sehr wichtigen Teil des Webs - die Verbindungen.  Die Verbindung von allem mit allem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="Bild"><br><br>  Ich kann jetzt auf Ihre Seite verlinken.  Ich brauche weder Ihre noch die Erlaubnis eines anderen.  Ich mache einfach diesen Link und füge ihn meiner Seite hinzu.  Jeder kann ihm folgen und Ihr Inhalt wird angezeigt, der von Ihnen geschriebene Code wird gestartet.  Diese Einfachheit, Verbindungen herzustellen und durch sie zu wechseln, hat unser Internet so geschaffen, wie es ist.  Jetzt haben wir soziale Netzwerke und andere Websites, die das Konzept der „Verknüpfung“ im Wesentlichen um die Möglichkeit erweitern, alles anzudocken: Personen, Geräte, Unternehmen usw. <br><br>  Bei all diesen Links und Links gibt es jedoch zwei Probleme. <br><br>  Zu was sollte der Link führen?  Wenn Sie irgendwohin gehen und die Site Ihnen Code bietet, der in Ihrem Browser ausgeführt werden muss, sollte dieser Code plattformübergreifend sein.  Es sollte zu etwas kompiliert und auf einer Mohnblume, unter Windows, auf einem Android ausgeführt werden.  Überall.  Die Portabilität von herunterladbarem Code ist ein wichtiger Bestandteil des Konzepts der Webkonnektivität. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="Bild"><br><br>  Es reicht jedoch nicht aus, nur den Code herunterzuladen und auszuführen.  Sie müssen verstehen, dass wir nichts über diesen Code wissen.  Wir vertrauen ihm nicht genug, um die volle Kontrolle über den Computer des Benutzers zu geben.  Was ist, wenn es sich um bösartigen Code handelt?  Er kann etwas Schlimmes tun.  Und hier brauchen wir eine Art Sicherheitsmodell.  Wir brauchen eine Sandbox, in der wir einen unbekannten Code einfügen, ihm kontrollierte Tools für die Arbeit geben können, aber alles, was wichtig und unsicher ist, entfernen können. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="Bild"><br><br>  Das Konzept der „Kommunikation“ umfasst also zwei Aspekte: Portabilität und Sicherheit.  Wir wissen, dass wir den Code definitiv ausführen können und dass er uns sicherlich nicht schaden wird.  Warum bestehe ich auf diesen Konzepten und wie unterscheidet sich diese Sicht der Dinge von der Sicht des Webs als Kombination aus HTML, CSS und Javascript?  Weil dieser Ansatz die Ansicht von WebAssembly grundlegend ändert. <br><br>  Einerseits können wir uns WebAssembly als „ein weiteres Tool vorstellen, das in einem modernen Browser verfügbar ist“.  Und so ist es auch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="Bild"><br><br>  Die Portabilität und Sicherheit der Codeausführung öffnen uns jedoch andere Türen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="Bild"><br><br><h2>  Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="Bild"><br><br>  Wie kann WebAssembly Node helfen?  Portabilität bringen. <br><br>  Der Knoten bietet mithilfe von Javascript ein relativ hohes Maß an Portabilität.  Es gibt jedoch immer noch viele Fälle, in denen die Leistung des JS-Codes nicht ausreicht oder nur der richtige JS-Code noch nicht geschrieben wurde, aber es gibt eine native Version davon.  Und dann verwendet Node native Module.  Sie sind in Sprachen wie C geschrieben und müssen für die spezifische Plattform kompiliert werden, auf der Ihr Knoten ausgeführt wird. <br><br>  Native Module können entweder während der Installation kompiliert werden oder Sie können sie sofort für eine der gängigen Plattformen bereitstellen.  Beide Ansätze sind möglich, aber dies ist nur eine Auswahl von zwei Übeln: entweder zusätzliche Kopfschmerzen für den Benutzer oder den Autor des Moduls. <br><br>  Wenn Sie sich vorstellen, dass sich diese Module in WebAssembly befinden, müssen sie überhaupt nicht kompiliert werden.  Mit Portability können Sie sie sofort auf jeder Plattform ausführen, z. B. mit Javascript-Code.  Sie funktionieren jedoch mit der Leistung nativer Versionen. <br><br>  Und hier kommt das Glück in die Welt von Node in Form der vollständigen Portabilität von allem und überall.  Sie können die Node-Anwendung von Linux auf Windows portieren - und alles funktioniert ohne Neukompilierung weiter.  Gleichzeitig hat das WebAssembly-Modul keinen Zugriff auf Systemressourcen (es funktioniert in seiner Sandbox).  Aber native (und sogar nicht native) Node-Module funktionieren nicht in der Sandbox, sie haben Zugriff auf alles - das ist die Ideologie von Node.  Damit das WebAssembly-Modul dieselben Funktionen erhält, ist eine zusätzliche Zugriffsebene auf Betriebssystemressourcen erforderlich.  So etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">POSIX-</a> Funktionen (sie sind nicht notwendig, sie werden nur als Beispiel für eine relativ stabile und ausreichende Ressourcenzugriffsschnittstelle angegeben). <br><br><h3>  Fähigkeit: tragbare Schnittstelle </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="Bild"><br><br>  Was benötigen Node-Entwickler, um WebAssembly-Module zu verwenden?  Eine Art Schnittstelle, um auf seine Funktionen zuzugreifen.  Es wäre schön, es zu standardisieren.  Nun, damit nicht nur Node diese Funktionen aufrufen kann, sondern auch jeder im Allgemeinen.  Wenn Sie das WebAssembly-Modul in Ihrer Anwendung verwenden möchten, haben wir eine Verbindung hergestellt und verwenden es.  So etwas wie "POSIX for WebAssembly".  PWSIX (tragbare WebAssembly-Systemschnittstelle)? <br><br><h3>  Wo sind wir jetzt </h3><br>  Es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokument</a> , das den Mechanismus zum Bereitstellen eines Pfads zu einem Modul anhand seines Namens beschreibt.  Dies wird wahrscheinlich sowohl von Browsern als auch von Node verwendet (sie können unterschiedliche Pfade bereitstellen).  Es gibt zwar keine aktive Entwicklung, aber es wird viel diskutiert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="Bild"><br><br>  Höchstwahrscheinlich wird es in irgendeiner Form implementiert.  Das ist gut, weil es uns eine Reihe von Möglichkeiten eröffnet. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="Bild"></a> <br><br><h2>  CDN, Serverless und Edge Computing </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="Bild"><br><br>  Beispiele sind Dinge wie CDN, Serverless, Edge Computing.  Fälle, in denen Sie Ihren Code auf den Server einer anderen Person stellen, wodurch die Verfügbarkeit für Clients sichergestellt wird.  Warum benötigen Sie hier möglicherweise WebAssembly?  Kürzlich gab es einen ausgezeichneten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht</a> zu diesem Thema.  Kurz gesagt, es kann erforderlich sein, Code aus verschiedenen Quellen (die sich nicht gegenseitig vertrauen) innerhalb eines Prozesses auszuführen.  Dieser Code muss voneinander und vom Betriebssystem isoliert sein.  Lösungen wie eine virtuelle JS-Maschine (SpiderMonkey oder V8) funktionieren irgendwie, bieten jedoch nicht die gewünschte Leistung und Skalierbarkeit.  Und WebAssembly - gibt. <br><br>  Was ist erforderlich, damit dies funktioniert? <br><br><h3>  Fähigkeit: Laufzeit </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="Bild"><br><br>  Wir brauchen eine Laufzeitumgebung und einige Unternehmen erstellen ihre eigenen.  Wir haben bereits WebAssembly-Compiler (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cranelift</a> ) - sie sind schnell und speichereffizient.  Aber der von ihm generierte Code kann nicht in einem Vakuum leben - er muss sich auf etwas verlassen, irgendwie mit der Umgebung interagieren.  Jetzt schreiben einige Unternehmen, wie z. B. Fastly, diese Laufzeitumgebung selbst.  Dies ist jedoch kein sehr guter Ansatz - schließlich werden viele Unternehmen ihn benötigen und immer wieder die gleiche Arbeit leisten.  Wir könnten es einmal tun, den Standard erweitern - und jedem eine Menge Ressourcen sparen. <br><br><h3>  Wo sind wir jetzt </h3><br>  Irgendwo hier: <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="Bild"><br><br>  Es gibt noch keinen Laufzeitstandard.  Dies verhindert nicht, dass mehrere unabhängige Laufzeiten, die bereits in realen Projekten verwendet werden, existieren und funktionieren.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WAVM</a> und wasmjit. <br><br>  Wir planen auch die Veröffentlichung einer Laufzeit, die auf Cranelift basiert und als wasmtime bezeichnet wird.  Und sobald wir etwas standardisiertes und funktionierendes haben, ist dies eine offene Gelegenheit, eine Reihe von Dingen zu entwickeln, wie zum Beispiel ... <br><br><h2>  Tragbare Befehlszeilenprogramme </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="Bild"><br><br>  WebAssembly kann nicht nur im Browser, sondern auch in herkömmlichen Betriebssystemen verwendet werden.  Wir werden nicht über den Kernel sprechen (obwohl es auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Draufgänger</a> gibt, die dies winken), aber der WebAssembly-Code funktioniert möglicherweise im Benutzermodus.  Auf diese Weise können Befehlszeilenprogramme erstellt werden, die nach ihrer Erstellung für jedes Betriebssystem garantiert gleich sind. <br><br><h2>  Internet der Dinge </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="Bild"><br><br>  Mit dem „Internet der Dinge“ sind normalerweise Geräte mit geringem Stromverbrauch gemeint (wie tragbare oder verschiedene Sensoren / Controller in „Smart Homes“).  Einschränkungen der verfügbaren Prozessorressourcen und des Arbeitsspeichers wirken sich negativ auf die Fähigkeit aus, JS-Code dort auszuführen, aber WebAssembly ist eine ganz andere Sache.  Die Optimierung von Compilern wie Cranelift und einer Laufzeit wie wasmtime wird unter solchen Bedingungen glänzen, da sie nur für ressourcenschonende Aufgaben geschrieben wurden.  In absolut extremen Fällen ermöglicht WebAssembly sogar das Kompilieren Ihres Moduls in die native Binärdatei der Zielplattform.  Nun, wieder Portabilität - es gibt heutzutage viele dieser IoT-Geräte, die auf verschiedenen Plattformen basieren.  Mit WebAssembly müssen Sie sich darüber keine Gedanken machen - der entwickelte Code wird überall ausgeführt. <br><br><h2>  Schlussfolgerungen </h2><br>  Lassen Sie uns ein wenig zurückspulen und noch einmal einen Blick auf unseren „Fähigkeitsbaum“ werfen. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="Bild"></a> <br><br>  Ich habe diesen Artikel mit der Tatsache begonnen, dass einige Leute nicht verstehen, warum WebAssembly noch nicht fertig ist.  Wie Sie jetzt verstehen können, hat sein Weg kaum begonnen.  Ja, MVP eröffnet bereits einige Möglichkeiten.  Wir können bereits etwas in WebAssembly kompilieren und in einem Browser ausführen.  Aber es liegt noch viel Arbeit vor uns - Unterstützung für alles, was Sie für umfangreiche Anwendungen und Hochsprachen benötigen, Ersetzen von JS-Frameworks und all diese Dinge, über die ich außerhalb des Browsers gesprochen habe.  Wenn dies alles fertig ist, werden wir ein neues Web sehen.  Hohe Leistung, größer, tragbarer.  Es wird keine solche Software mehr geben, die nicht für die Ausführung im Browser geschrieben werden kann: Spiele, Blockchain, Internet der Dinge, Befehlszeilenprogramme - alles wird gestartet. <br><br>  WebAssembly ist nicht abgeschlossen.  Er hat gerade erst begonnen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428347/">https://habr.com/ru/post/de428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428337/index.html">Unterhaltsames JavaScript: Ohne geschweifte Klammern</a></li>
<li><a href="../de428339/index.html">Automatisieren Sie es nicht: Schlechte Geschäftstipps</a></li>
<li><a href="../de428341/index.html">Qsan RAID EE-Technologie</a></li>
<li><a href="../de428343/index.html">Ein interessantes Puzzle in C.</a></li>
<li><a href="../de428345/index.html">Anforderungen mit Fällen abdecken. SuperJob Realitäten</a></li>
<li><a href="../de428349/index.html">Gurke in der Cloud: Verwenden von BDD-Skripten für Produktstresstests</a></li>
<li><a href="../de428357/index.html">Absorption in der Praxis: eine Lebensgeschichte</a></li>
<li><a href="../de428361/index.html">A la perfección: Verbesserung von WordPress mit AMP für WordPress- und Setka Editor-Plugins</a></li>
<li><a href="../de428363/index.html">Jetpack / Hoverboard bauen: Rettungssysteme</a></li>
<li><a href="../de428365/index.html">Die Geschichte, wie sich die Google-Abrechnung geändert hat oder wie unnötige Kosten vermieden werden können</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>