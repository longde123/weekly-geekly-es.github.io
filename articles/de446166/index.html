<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíê ‚öìÔ∏è üë©üèæ‚Äçüè´ Einfacher Sprintf ASN1 Codec üèÅ üë©‚Äçüë¶‚Äçüë¶ üíáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die ASN.1-Transportsyntax definiert eine einzigartige Methode zum Konvertieren von Werten von Variablen g√ºltigen Typs in eine Folge von Bytes zur √úber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einfacher Sprintf ASN1 Codec</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446166/"><img src="https://habrastorage.org/webt/hp/r5/am/hpr5amyaiz885olowpmujn0aad8.png" alt="Bild" align="left">  Die ASN.1-Transportsyntax definiert eine einzigartige Methode zum Konvertieren von Werten von Variablen g√ºltigen Typs in eine Folge von Bytes zur √úbertragung √ºber ein Netzwerk.  In ASN.1 hei√üt es Basic Encoding Rules (BER).  Regeln sind rekursiv, daher ist das Codieren von zusammengesetzten Objekten eine Verkettung von codierten Sequenzen von Komponentenobjekten.  Das ASN.1-Protokoll beschreibt die Datenstruktur in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einfachen und verst√§ndlichen Sprache</a> . <br><a name="habracut"></a><br>  Jeder √ºbertragene Wert - sowohl der Basiswert als auch der abgeleitete Typ - besteht aus drei Feldern: <br><br><ul><li>  Kennung; </li><li>  Datenfeldl√§nge (in Bytes); </li><li>  Datenfeld. </li></ul><br>  Wenn Sie immer die L√§nge des Datenfelds angeben (ich halte dies f√ºr eine gute Vorgehensweise), wird das Flag am Ende des Datenfelds nicht verwendet. <br><br>  Es gibt viele verschiedene kostenpflichtige und kostenlose Compiler f√ºr ASN.1 f√ºr verschiedene Programmiersprachen, aber wir m√∂chten etwas sehr Einfaches zur Hand haben. <br><br>  Die √ºberwiegende Mehrheit der Softwareentwickler findet den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ASN.1-</a> Standardkomplex.  Das habe ich mir bis vor kurzem auch gedacht.  Sie arbeiten fast t√§glich im Bereich PKI / PKI / Kryptographie und besch√§ftigen sich mit ASN1-Strukturen in Form von X509-Zertifikaten, Zertifikatsanforderungen und Listen widerrufener Zertifikate.  Und die Liste geht weiter.  W√§hrend ich an einem Dienstprogramm zum Erstellen einer Zertifikatanforderung im PKCS # 10-Format mit dem Generieren eines Schl√ºsselpaars auf einem PKCS # 11-Token / einer Smartcard arbeitete, musste ich nat√ºrlich insbesondere die asn1-Struktur des √∂ffentlichen Schl√ºssels bilden, um sie in die Zertifikatanforderung zu schreiben :: <br><br><pre><code class="erlang hljs">C-Sequence C-Sequence (&lt;&gt;) Object Identifier (&lt;&gt;) &lt;oid public key&gt; C-Sequence (&lt;&gt;) Object Identifier (&lt;&gt;) &lt;oid  &gt; Object Identifier (&lt;&gt;) &lt;oid &gt; Bit String (&lt;&gt;) &lt;  &gt;</code> </pre> <br>  Da wir das PKCS # 11-Token mit Unterst√ºtzung der russischen Kryptographie als kryptografisches Informationsschutzwerkzeug verwendet haben, wurde das Quellmaterial f√ºr diese Struktur aus dem Token gem√§√ü der folgenden Vorlage erhalten: <br><br><pre> <code class="cpp hljs"> CK_BYTE gostr3410par[<span class="hljs-number"><span class="hljs-number">12</span></span>]; CK_BYTE gostr3411par[<span class="hljs-number"><span class="hljs-number">12</span></span>]; CK_ULONG gostr3410par_len; CK_ULONG gostr3411par_len; CK_BYTE pubkey[<span class="hljs-number"><span class="hljs-number">128</span></span>]; CK_ULONG pubkeu_len; CK_KEY_TYPE key_type; CK_ATTRIBUTE templ_pk[] = { . . . {CKA_GOSTR3410PARAMS, gostr3410par, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gostr3410par)}, {CKA_GOSTR3411PARAMS, gostr3411par, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(gostr3410par)}, {CKA_VALUE, pubkey, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(pubkey)}, {CKA_KEY_TYPE, &amp;key_type, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(key_type)} }</code> </pre> <br>  Direkt aus dieser Struktur werden die Werte des Attributs CKA_VALUE, das den Wert des √∂ffentlichen Schl√ºssels enth√§lt, und die Werte der Attribute CKA_GOSTR3410PARAMS und CKA_GOSTR3411PARAMS, die die Oids des Signaturparameters und des Hash-Parameters enthalten, zum Ausf√ºllen von asn1-publickeyinfo verwendet. <br><br>  Das Attribut CKA_KEY_TYPE, das die Werte CKK_GOSTR3410 und CKK_GOSTR3410_512 annehmen kann (unter den Bedingungen, unter denen der Signaturalgorithmus von GOST R 34.10-2001 weiterhin funktioniert), definiert den Schl√ºsselpaaralgorithmus mehrdeutig.  Wenn der Wert des Attributs CKA_KEY_TYPE gleich CKK_GOSTR3410_512 ist, zeigt er nat√ºrlich eindeutig auf den Algorithmus GOST R 34.10-2012 mit einer Schl√ºssell√§nge von 512 Bit (oid = 1.2.643.7.1.1.1.2).  Wenn es jedoch einfach gleich CKK_GOSTR3410 ist, besteht Unklarheit dar√ºber, zu welchem ‚Äã‚ÄãSchl√ºsseltyp dieser Schl√ºssel geh√∂rt: GOST R 34.10-2001 oder es ist immer noch GOST R 34.10-2012 mit einer Schl√ºssell√§nge von 256 Bit.  Das Attribut CKA_GOSTR3411PARAMS hilft, diese Mehrdeutigkeit zu beheben. <br><br>  Wir stellen sofort fest, dass die Parameter CKA_GOSTR3410PARAMS und CKA_GOSTR3411PARAMS auf dem Token gem√§√ü den Empfehlungen von TK-26 als von oid codierte Objektkennung gespeichert werden, zum Beispiel: <br><br>  \ x06 \ x06 \ x2a \ x85 \ x03 \ x02 \ x02 \ x13, wobei das Nullbyte den Sequenztyp bestimmt (0x06 ist die Objektkennung, siehe Tabelle unten), das zweite Byte die L√§nge angibt (im allgemeinen Fall kann die L√§nge mehrere Bytes dauern). aber mehr dazu weiter unten) das Datenfeld, in dem oid in bin√§rer Form gespeichert ist. <br><br>  Wenn dieser Parameter die oid des Hash-Algorithmus GOST R 34.10-2012 mit einer L√§nge von 256 Bit enth√§lt (oid = 1.2.643.7.1.1.2.2, in bin√§rer Form "\ x2a \ x 85 \ x 03 \ x 07 \ x 01 \ x 01 \ x 02 \ x02 "), dann muss der Schl√ºsseltyp als GOST R 34.10-2012 mit einer Schl√ºssell√§nge von 256 Bit eingestellt werden.  Ansonsten ist es der Schl√ºssel von GOST R 34.10-2001.  Der Algorithmus zum Bestimmen des Schl√ºsseltyps kann folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs">. . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (curr_attr_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; curr_attr_idx &lt; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(templ_pk)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(templ_pk[<span class="hljs-number"><span class="hljs-number">0</span></span>])); curr_attr_idx++){ curr_attr = &amp;templ_pk[curr_attr_idx]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!curr_attr-&gt;pValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } swith (curr_attr-&gt;type) { . . . <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_VALUE: <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> pubkey_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_GOSTR3410PARAMS: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> gostr3410par_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_GOSTR3410PARAMS: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> gostr3411par_len = curr_attr-&gt;ulValueLen; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CKA_KEY_TYPE: ulattr = curr_attr-&gt;pValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ulattr == CKK_GOSTR3410) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!memmem(gostr3411par), gostr3411par_len,<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2001*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, <span class="hljs-string"><span class="hljs-string">"1.2.643.2.2.19"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1(<span class="hljs-string"><span class="hljs-string">"\x06\x06\x2a\x85\x03\x02\x02\x13"</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2012-256*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, (<span class="hljs-string"><span class="hljs-string">"1 2 643 7 1 1 1 1"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1 (<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07\x01\x01\x01\x01"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*ulattr == CKK_GOSTR3410_512) { <span class="hljs-comment"><span class="hljs-comment">/*    34.10-2012-512*/</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(oid_key_type, (<span class="hljs-string"><span class="hljs-string">"1 2 643 7 1 1 1 2"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(oid_key_type_asn1 (<span class="hljs-string"><span class="hljs-string">"\x06\x08\x2a\x85\x03\x07\x01\x01\x01\x02"</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"tclpkcs11_perform_pki_keypair CKK_GOSTR ERROR\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; . . . } } . . .</code> </pre> <br>  Jetzt haben wir alle Quelldaten zum Erstellen der √∂ffentlichen Schl√ºsselstruktur asn1. <br><br>  Denken Sie daran, dass jedes Element der asn1-Struktur aus drei Feldern besteht: <br><br><ul><li>  Kennung; </li><li>  Datenfeldl√§nge (in Bytes); </li><li>  Datenfeld. </li></ul><br>  Hier ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> Codierungstabelle f√ºr einige Arten von Bezeichnern, die in PKI / PKI verwendet werden: <br><br><table width="200"><tbody><tr><th>  <b>Typ Name</b> </th><th>  <b>Kurzbeschreibung</b> </th><th>  <b>Typdarstellung in DER-Codierung</b> </th></tr><tr><td>  Sequenz </td><td>  Wird verwendet, um eine Datenstruktur zu beschreiben, die aus verschiedenen Typen besteht. </td><td>  30 </td></tr><tr><td>  INTEGER </td><td>  Ganze Zahl. </td><td>  02 </td></tr><tr><td>  OBJECT IDENTIFIER </td><td>  Eine Folge von ganzen Zahlen. </td><td>  06 </td></tr><tr><td>  UTCTime </td><td>  Tempor√§rer Typ, enth√§lt 2 Ziffern zur Bestimmung des Jahres </td><td>  17 </td></tr><tr><td>  Generalisierte Zeit </td><td>  Erweiterter Zeittyp, enth√§lt 4 Ziffern zur Angabe des Jahres. </td><td>  18 </td></tr><tr><td>  SET </td><td>  Beschreibt die Datenstruktur verschiedener Typen. </td><td>  31 </td></tr><tr><td>  UTF8String </td><td>  Beschreibt Zeichenfolgendaten. </td><td>  0C </td></tr><tr><td>  Null </td><td>  Eigentlich NULL </td><td>  05 </td></tr><tr><td>  BIT STRING </td><td>  Typ zum Speichern einer Folge von Bits. </td><td>  03 </td></tr><tr><td>  OCTET STRING </td><td>  Typ zum Speichern einer Folge von Bytes </td><td>  04 </td></tr></tbody></table><br>  Bei der Arbeit mit asn1-Strukturen wird der gr√∂√üte Schock f√ºr Uneingeweihte durch die Methode zum Codieren der L√§nge des Datenfelds verursacht, insbesondere beim Bilden, und wenn Sie die Computerarchitektur (littleendien, bigendien) ber√ºcksichtigen.  Das ist eine ganze <a href="">Wissenschaft</a> .  Bei der Er√∂rterung des Algorithmus zur Bildung dieses Feldes kam mir die Idee, die Sprintf-Funktion zu verwenden, die selbst die Architektur ber√ºcksichtigt, und wie die Anzahl der Bytes zum Speichern der L√§nge bestimmt wird, zeigt der Funktionscode, der einen Puffer mit dem Datentypbezeichner und der Datenl√§nge erstellt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap_id_with_length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">//  unsigned long length, //  unsigned long *lenasn) //  asn1- { // unsigned long length; int buflen = 0; unsigned char *buf; char *format; char *buf_for_len[100]; const char *s; /*       */ char f0[] = "%02x%02x"; char f1[] = "%02x81%02x"; char f2[] = "%02x82%04x"; char f3[] = "%02x83%06x"; char f4[] = "%02x84%08x"; /*        */ buflen = ( length &lt; 0x80 ? 1: length &lt;= 0xff ? 2: length &lt;= 0xffff ? 3: length &lt;= 0xffffff ? 4: 5); /*   asn-*/ buf = malloc(length + buflen); // buf = malloc(buflen); /*        sprintf*/ switch (buflen - 1) { case 0: format = f0; break; case 1: format = f1; break; case 2: format = f2; break; case 3: format = f3; break; case 4: format = f4; break; } // sprintf    little  bigendian       sprintf((char*)buf_for_len, (const char *)format, type, length); length = 0; /* asn1-*/ fprintf(stderr, "ASN1 - :%s\n", buf_for_len); /*     */ for (s=(const char *)buf_for_len; *s; s +=2 ) { if (!hexdigitp (s) || (!hexdigitp (s+1) &amp;&amp; hexdigitp (s+1) != 0) ){ fprintf (stderr, "invalid hex digits in \"%s\"\n", buf_for_len); *lenasn = 0; return NULL; } ((unsigned char*)buf)[length++] = xtoi_2 (s); } *lenasn = length; return (buf); }</span></span></span></span></span></span></code> </pre> <br>  Die Funktion gibt einen Zeiger auf einen Puffer mit einer asn1-Struktur zur√ºck, der unter Ber√ºcksichtigung der L√§nge der Daten zugewiesen wird.  Es bleibt, diese Daten mit einem Versatz um die L√§nge des Headers in den empfangenen Puffer zu kopieren.  Die L√§nge des Headers wird √ºber den Parameter lenasn zur√ºckgegeben. <br><br>  Um zu √ºberpr√ºfen, wie diese Funktion funktioniert, schreiben wir ein einfaches Dienstprogramm: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define digitp(p) (*(p) &gt;= '0' &amp;&amp; *(p) &lt;= '9') #define hexdigitp(a) (digitp (a) \ || (*(a) &gt;= 'A' &amp;&amp; *(a) &lt;= 'F') \ || (*(a) &gt;= 'a' &amp;&amp; *(a) &lt;= 'f')) #define xtoi_1(p) (*(p) &lt;= '9'? (*(p)- '0'): \ *(p) &lt;= 'F'? (*(p)-'A'+10):(*(p)-'a'+10)) #define xtoi_2(p) ((xtoi_1(p) * 16) + xtoi_1((p)+1)) int main (int argc, char *argv[]) { unsigned char *hdrasn; unsigned char type; unsigned long length; unsigned long lenasn; if (argc != 3) { fprintf (stderr, "Usage: wrap_id_with_length &lt;id&gt; &lt;length&gt;\n"); exit(-1); } type = atoi(argv[1]); length = atol(argv[2]); fprintf (stderr, "&lt;id=%02x&gt; &lt;length=%lu&gt;\n", type, length); if (length == 0) { fprintf (stderr, "Bad length=%s\nUsage: wrap_id_with_length &lt;id&gt; &lt;length&gt;\n", argv[2]); exit(-1); } hdrasn = wrap_id_with_length(type, length, &amp;lenasn); fprintf (stderr, "Length asn1-buffer=%lu, LEN_HEADER=%lu, LEN_DATA=%lu\n", lenasn, lenasn - length, length); }</span></span></span></span></code> </pre> <br>  Speichern Sie es zusammen mit der Funktion wrap_id_with_length in der Datei wrap_id_with_length.c. <br><br>  Wir senden: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$cc</span></span> ‚Äìo wrap_id_with_length wrap_id_with_length.c $</code> </pre> <br>  F√ºhren Sie das resultierende Programm mit verschiedenen Quelldaten aus.  Der Datentyp wird durch eine Dezimalzahl angegeben: <br><br><pre> <code class="bash hljs">bash-4.3$ ./wrap_id_with_length 06 8 &lt;id=06&gt; &lt;length=8&gt; ASN1 - :0608 Length asn1-buffer=10, LEN_HEADER=2, LEN_DATA=8 bash-4.3$ ./wrap_id_with_length 06 127 &lt;id=06&gt; &lt;length=127&gt; ASN1 - :067f Length asn1-buffer=129, LEN_HEADER=2, LEN_DATA=127 bash-4.3$ ./wrap_id_with_length 48 128 &lt;id=30&gt; &lt;length=128&gt; ASN1 - :308180 Length asn1-buffer=131, LEN_HEADER=3, LEN_DATA=128 bash-4.3$ ./wrap_id_with_length 48 4097 &lt;id=30&gt; &lt;length=4097&gt; ASN1 - :30821001 Length asn1-buffer=4101, LEN_HEADER=4, LEN_DATA=4097 bash-4.3$</code> </pre><br>  Sie k√∂nnen die Richtigkeit der Bildung des Headers mit einem beliebigen Taschenrechner √ºberpr√ºfen: <br><br><img src="https://habrastorage.org/webt/kj/rp/4s/kjrp4sc9ddsk6fhjhkohe8tkotu.png"><br><br>  Wir sind alle bereit, jede ASN1-Struktur zu bilden.  Nehmen Sie jedoch zuerst kleine √Ñnderungen an der Funktion wrap_id_with_length vor und rufen Sie sie auf <br><br><div class="spoiler">  <b class="spoiler_title">wrap_for_asn1:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap_for_asn1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *prefix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prefix_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *wrap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wrap_len, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenasn)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buflen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *buf; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *format; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf_for_len[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f0[] = <span class="hljs-string"><span class="hljs-string">"%02x%02x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f1[] = <span class="hljs-string"><span class="hljs-string">"%02x81%02x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f2[] = <span class="hljs-string"><span class="hljs-string">"%02x82%04x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f3[] = <span class="hljs-string"><span class="hljs-string">"%02x83%06x"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> f4[] = <span class="hljs-string"><span class="hljs-string">"%02x84%08x"</span></span>; length = prefix_len + wrap_len; buflen += ( length &lt;= <span class="hljs-number"><span class="hljs-number">0x80</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xff</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xffff</span></span> ? <span class="hljs-number"><span class="hljs-number">3</span></span>: length &lt;= <span class="hljs-number"><span class="hljs-number">0xffffff</span></span> ? <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>); buf = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(length + buflen); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (buflen - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: format = f0; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: format = f1; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: format = f2; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: format = f3; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: format = f4; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// sprintf    little  bigendian    sprintf((char*)buf_for_len, (const char *)format, type, length); length = 0; for (s=buf_for_len; *s; s +=2 ) { if (!hexdigitp (s) || (!hexdigitp (s+1) &amp;&amp; hexdigitp (s+1) != 0) ){ fprintf (stderr, "invalid hex digits in \"%s\"\n", buf_for_len); } ((unsigned char*)buf)[length++] = xtoi_2 (s); } if (prefix_len &gt; 0) { memcpy(buf + length, prefix, prefix_len); } memcpy(buf + length + prefix_len, wrap, wrap_len); *lenasn = (unsigned long)(length + prefix_len + wrap_len); return (buf); }</span></span></code> </pre> <br></div></div><br>  Wie Sie sehen k√∂nnen, sind die √Ñnderungen minimal.  Als Eingabeparameter werden die Daten selbst hinzugef√ºgt, die innerhalb der Funktion in eine asn1-Struktur gepackt werden.  Dar√ºber hinaus k√∂nnen dem Eingang zwei Puffer gleichzeitig zugef√ºhrt werden.  Es scheint uns bequem. <br><br>  Bevor wir einen Testfall pr√§sentieren, geben wir die Codes von drei weiteren Funktionen an.  Die erste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oid2buffer-</a> Funktion konvertiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oids</a> von der gepunkteten Dezimalform in die DER-Codierung.  Wir ben√∂tigen diese Funktion, um insbesondere Oids des Schl√ºsselpaars zu konvertieren (siehe oben). <br><br><div class="spoiler">  <b class="spoiler_title">Der Funktionstext ist hier:</b> <div class="spoiler_text">  statischer char * oid2buffer (char * oid_str, unsigned long * len) { <br>  char * curstr; <br>  char * curstr1; <br>  char * nextstr; <br>  unsigned int firstval; <br>  unsigned int secondval; <br>  unsigned int val; <br>  vorzeichenloser char buf [5]; <br>  int count; <br>  unsigned char oid_hex [100]; <br>  char * res; <br>  int i; <br>  if (oid_str == NULL) { <br>  * len = 0; <br>  return NULL; <br>  }} <br>  * len = 0; <br>  curstr = strdup ((const char *) oid_str); <br>  curstr1 = curstr; <br>  nextstr = strchr (curstr, '.'); <br>  if (nextstr == NULL) { <br>  * len = 0; <br>  return NULL; <br>  }} <br>  * nextstr = '\ 0'; <br>  firstval = atoi (curstr); <br>  curstr = nextstr + 1; <br>  nextstr = strchr (curstr, '.'); <br>  if (nextstr) { <br>  * nextstr = '\ 0'; <br>  }} <br>  secondval = atoi (curstr); <br>  if (firstval&gt; 2) { <br>  * len = 0; <br>  return NULL; <br>  }} <br>  if (secondval&gt; 39) { <br>  * len = 0; <br>  return NULL; <br>  }} <br>  oid_hex [0] = (vorzeichenloses Zeichen) ((erster Wert * 40) + zweiter Wert); <br>  i = 1; <br>  while (nextstr) { <br>  curstr = nextstr + 1; <br><br>  nextstr = strchr (curstr, '.'); <br><br>  if (nextstr) { <br>  * nextstr = '\ 0'; <br>  }} <br><br>  Memset (buf, 0, sizeof (buf)); <br>  val = atoi (curstr); <br>  count = 0; <br>  if (curstr [0]! = '0') <br>  while (val) { <br>  buf [count] = (val &amp; 0x7f); <br>  val = val &gt;&gt; 7; <br>  count ++; <br>  }} <br>  sonst { <br>  buf [count] = (val &amp; 0x7f); <br>  val = val &gt;&gt; 7; <br>  count ++; <br>  }} <br>  while (count--) { <br>  if (count) { <br>  oid_hex [i] = buf [count] |  0x80; <br>  } else { <br>  oid_hex [i] = buf [count]; <br>  }} <br>  i ++; <br>  }} <br>  }} <br>  res = (char *) malloc (i); <br>  if (res) { <br>  memcpy (res, oid_hex, i); <br>  * len = i; <br>  }} <br>  frei (curstr1); <br>  return res; <br>  }} <br></div></div><br>  Mit den beiden anderen Funktionen kann der Bin√§rpuffer in eine Hexadezimalzahl (buffer2hex) konvertiert werden und umgekehrt (hex2buffer). <br><br><div class="spoiler">  <b class="spoiler_title">Diese Funktionen sind hier:</b> <div class="spoiler_text">  statisches Zeichen * <br>  buffer2hex (const unsigned char * src, size_t len) <br>  { <br>  int i; <br>  char * dest; <br>  char * res; <br>  dest = (char *) malloc (len * 2 + 1); <br>  res = dest; <br>  if (dest) <br>  { <br>  f√ºr (i = 0; i &lt;len; i ++, dest + = 2) <br>  sprintf (dest, "% 02X", src [i]); <br>  }} <br>  return res; <br>  }} <br><br>  statische Leere * <br>  hex2buffer (const char * string, size_t * r_length) <br>  { <br>  const char * s; <br>  vorzeichenloser char * -Puffer; <br>  size_t L√§nge; <br><br>  buffer = malloc (strlen (string) / 2 + 1); <br>  L√§nge = 0; <br>  f√ºr (s = string; * s; s + = 2) <br>  { <br>  if (! hexdigitp (s) ||! hexdigitp (s + 1)) { <br>  fprintf (stderr, "ung√ºltige Hex-Ziffern in"% s "\ n", Zeichenfolge); <br>  }} <br>  ((vorzeichenloser char *) Puffer) [L√§nge ++] = xtoi_2 (s); <br>  }} <br>  * r_length = L√§nge; <br>  R√ºckgabepuffer; <br>  }} <br></div></div><br>  Diese Funktionen sind sehr praktisch f√ºr das Debuggen, und h√∂chstwahrscheinlich haben viele sie. <br><br>  Und jetzt kehren wir zur L√∂sung der Aufgabe zur√ºck und erhalten eine asn1-Struktur des √∂ffentlichen Schl√ºssels.  Wir werden ein Dienstprogramm schreiben, das die asn1-Struktur des √∂ffentlichen Schl√ºssels in der Datei ASN1_PIBINFO.der generiert und speichert. <br><br><div class="spoiler">  <b class="spoiler_title">Dieses Dienstprogramm befindet sich hier:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;stdint.h&gt; #include &lt;string.h&gt; #define digitp(p) (*(p) &gt;= '0' &amp;&amp; *(p) &lt;= '9') #define hexdigitp(a) (digitp (a) \ || (*(a) &gt;= 'A' &amp;&amp; *(a) &lt;= 'F') \ || (*(a) &gt;= 'a' &amp;&amp; *(a) &lt;= 'f')) #define xtoi_1(p) (*(p) &lt;= '9'? (*(p)- '0'): \ *(p) &lt;= 'F'? (*(p)-'A'+10):(*(p)-'a'+10)) #define xtoi_2(p) ((xtoi_1(p) * 16) + xtoi_1((p)+1)) /*   oid2buffer*/ /*   buffer2hex  hex2buffer*/ /*   wrap_for_asn1*/ int main() { int fd; unsigned char *asn, *asn1, *asn2, *asn3, *pubkeyalgo; unsigned char* pubkey_bin; //  char gost3410par[] = "\x06\x7\x2a\x85\x03\x02\x02\x23\x01"; unsigned long gost3410par_len = sizeof(gost3410par) - 1; char gost3411par[] = "\x06\x8\x2a\x85\x03\x07\x01\x01\x02\x02"; unsigned long gost3411par_len = sizeof(gost3411par) - 1; unsigned char pubkey_hex[] = "9af03570ed0c54cd4953f11ab19e551022cd48603326c1b9b630b1cff74e5a160ba1718166cc22bf70f82bdc957d924c501b9332491cb3a36ce45770f05487b5"; char pubkey_oid_2001[] = "1.2.643.2.2.19"; char pubkey_oid_2012_256[] = "1.2.643.7.1.1.1.1"; char pubkey_oid_2012_512[] = "1.2.643.7.1.1.1.2"; unsigned long pubkey_len, pubkey_len_full, len10, len11, len12, lenalgo; unsigned char *pkalgo; unsigned long pkalgo_len; uint16_t x = 1; /* 0x0001 */ printf("%s\n", *((uint8_t *) &amp;x) == 0 ? "big-endian" : "little-endian"); ////pubkeyinfo //      if (!memmem(gost3411par, 8, "\x2a\x85\x03\x07", 4)) { //   34.11-94,     34.10-2001 - 1.2.643.2.2.19 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2001, &amp;lenalgo); } else if (!memcmp(gost3411par, "\x2a\x85\x03\x07\x01\x01\x02\x02", 8)){ //   34.11-2012-256,     34.10-2012-256 - 1.2.643.7.1.1.1.1 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2012_256, &amp;lenalgo); } else { //   34.11-2012-512,     34.10-2012-512 - 1.2.643.7.1.1.1.2 pubkeyalgo = (unsigned char *)oid2buffer(pubkey_oid_2012_512, &amp;lenalgo); } pubkey_bin =(unsigned char*)hex2buffer((const char *)pubkey_hex, &amp;pubkey_len); //    asn1 = wrap_for_asn1_bin('\x04', (unsigned char *)"", 0, pubkey_bin, pubkey_len, &amp;pubkey_len); asn = wrap_for_asn1_bin('\x03', (unsigned char *)"\x00", 1, asn1, pubkey_len, &amp;pubkey_len_full); fprintf(stderr, "PUBLIC_VALUE=%s\n", buffer2hex(asn, pubkey_len_full)); free(asn1); //  asn3 = wrap_for_asn1_bin('\x30', (unsigned char*)gost3410par, gost3410par_len, (unsigned char *)gost3411par, gost3411par_len, &amp;len12); fprintf(stderr, "\nPARAMS len12=%lu, FULL=%s\n", len12, buffer2hex(asn3, len12)); //   pkalgo = wrap_for_asn1_bin('\x06', (unsigned char *)"", 0, pubkeyalgo, lenalgo, &amp;pkalgo_len); //     asn2 = wrap_for_asn1_bin('\x30', pkalgo, pkalgo_len, asn3, len12, &amp;len11); fprintf(stderr, "PubKEY=%s\n", buffer2hex(asn3, len11)); asn1 = wrap_for_asn1_bin('\x30', asn2, len11, asn, pubkey_len_full, &amp;len10); free(asn2); free(asn3); fprintf(stderr, "\n%s\n", buffer2hex(asn1, len10)); fd = open ("ASN1_PUBINFO.der", O_TRUNC|O_RDWR|O_CREAT,S_IRWXO); write(fd, asn1, len10); close(fd); free(asn1); chmod("ASN1_PUBINFO.der", 0666); }</span></span></span></span></code> </pre> <br></div></div><br>  Um das Ergebnis zu √ºberpr√ºfen, verwenden wir die Dienstprogramme derdump und pp aus dem NSS-Paket. <br><br>  Das erste Dienstprogramm zeigt uns die asn1-Struktur des √∂ffentlichen Schl√ºssels: <br><br><pre> <code class="bash hljs">$ derdump -i ASN1_PUBINFO.der C-Sequence (102) C-Sequence (31) Object Identifier (8) 1 2 643 7 1 1 1 2 (GOST R 34.10-2012 Key 512) C-Sequence (19) Object Identifier (7) 1 2 643 2 2 35 1 Object Identifier (8) 1 2 643 7 1 1 2 2 (GOST R 34.11-2012 256) Bit String (67) 00 04 40 9a f0 35 70 ed 0c 54 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 49 53 f1 1a b1 9e 55 10 22 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> 48 60 33 26 c1 b9 b6 30 b1 cf f7 4e 5a 16 0b a1 71 81 66 cc 22 bf 70 f8 2b dc 95 7d 92 4c 50 1b 93 32 49 1c b3 a3 6c e4 57 70 f0 54 87 b5 $</code> </pre> <br>  Die zweite zeigt den Inhalt des Schl√ºssels: <br><br><pre> <code class="bash hljs">$ pp -t pk -i ASN1_PUBINFO.der Public Key: Subject Public Key Info: Public Key Algorithm: GOST R 34.10-2012 512 Public Key: PublicValue: 9a:f0:35:70:ed:0c:54:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:49:53:f1:1a:b1:9e:55:10: 22:<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span>:48:60:33:26:c1:b9:b6:30:b1:cf:f7:4e:5a:16: 0b:a1:71:81:66:cc:22:bf:70:f8:2b:dc:95:7d:92:4c: 50:1b:93:32:49:1c:b3:a3:6c:e4:57:70:f0:54:87:b5 GOSTR3410Params: OID.1.2.643.2.2.35.1 GOSTR3411Params: GOST R 34.11-2012 256 $</code> </pre> <br>  Wer m√∂chte, kann dies beispielsweise mit dem Dienstprogramm openssl, vorzugsweise mit einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angeschlossenen GOST-</a> Engine, √ºberpr√ºfen: <br><br><pre> <code class="bash hljs">$ /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/lirssl_csp_64/bin/lirssl_static asn1parse -inform DER -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ASN1_PUBINFO.der 0:d=0 hl=2 l= 102 cons: SEQUENCE 2:d=1 hl=2 l= 31 cons: SEQUENCE 4:d=2 hl=2 l= 8 prim: OBJECT :GOST R 34.10-2012 with 512 bit modulus 14:d=2 hl=2 l= 19 cons: SEQUENCE 16:d=3 hl=2 l= 7 prim: OBJECT :id-GostR3410-2001-CryptoPro-A-ParamSet 25:d=3 hl=2 l= 8 prim: OBJECT :GOST R 34.11-2012 with 256 bit <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> 35:d=1 hl=2 l= 67 prim: BIT STRING $</code> </pre> <br>  Wie Sie sehen k√∂nnen, wird die resultierende ASN1-Struktur √ºberall erfolgreich getestet. <br><br>  Der vorgeschlagene Algorithmus und das vorgeschlagene Dienstprogramm zum Bilden von asn1-Strukturen erfordern keine Verwendung von ASN1-Compilern und Erweiterungsbibliotheken (das gleiche openssl) und erwiesen sich als sehr bequem zu verwenden.  Wir werden sie im n√§chsten Artikel zur√ºckrufen, wenn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Pas-</a> W√ºnsche erf√ºllt werden und ein grafisches Dienstprogramm vorgestellt wird, das nicht nur Zertifikate analysiert und deren G√ºltigkeit √ºberpr√ºft, sondern auch ein Schl√ºsselpaar f√ºr PKCS # 11-Token generiert, eine Anforderung f√ºr ein qualifiziertes Zertifikat generiert und signiert.  Mit dieser Anforderung k√∂nnen Sie sicher zur Zertifizierungsstelle gehen, um ein Zertifikat zu erhalten.  Vor den Fragen stelle ich sofort fest, dass im letzteren Fall das Token als kryptografisches Informationsschutzsystem im Zertifizierungssystem des FSB von Russland zertifiziert sein muss. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446166/">https://habr.com/ru/post/de446166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446144/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 292 (25. M√§rz - 31. M√§rz)</a></li>
<li><a href="../de446148/index.html">Linux Kernel 5.0 - Schreiben von Simple Block Device unter blk-mq</a></li>
<li><a href="../de446150/index.html">Maschinelles Lernen ohne Python, Anaconda und andere Reptilien</a></li>
<li><a href="../de446152/index.html">Commando VM - Kali Linux Alternative f√ºr Windows</a></li>
<li><a href="../de446162/index.html">Wie man ein "intelligenter Junior" wird. Pers√∂nliche Erfahrung</a></li>
<li><a href="../de446172/index.html">Limit Messages API VK - was zu tun ist</a></li>
<li><a href="../de446174/index.html">Yandex.Alice und Telegram Bot in PHP mit einer einzigen Funktionalit√§t</a></li>
<li><a href="../de446176/index.html">Tankerkennung in einem Videostream mithilfe maschineller Lernmethoden (+2 Videos auf Elbrus- und Baikal-Plattformen)</a></li>
<li><a href="../de446180/index.html">War MongoDB √ºberhaupt die richtige Wahl?</a></li>
<li><a href="../de446184/index.html">TDD-Anwendungen auf Spring Boot: Feinabstimmung der Tests und Arbeiten mit dem Kontext</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>