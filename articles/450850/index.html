<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò§ üõÑ üéâ Hacia un futuro m√°s brillante para compiladores inteligentes üîô ü§æüèΩ üçØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ahora, el tema del aprendizaje autom√°tico y la inteligencia artificial es extremadamente popular, por el momento, gracias a la potencia inform√°tica de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hacia un futuro m√°s brillante para compiladores inteligentes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450850/">  Ahora, el tema del aprendizaje autom√°tico y la inteligencia artificial es extremadamente popular, por el momento, gracias a la potencia inform√°tica de las computadoras, las ideas y los algoritmos que han surgido durante mucho tiempo se pueden implementar y mejorar significativamente.  Casi todos los d√≠as puedes leer noticias sobre nuevos logros en esta √°rea.  Adem√°s, el aprendizaje autom√°tico se utiliza en casi todas las √°reas ... y el desarrollo de compiladores no es una excepci√≥n.  Sin embargo, el √°rea es bastante espec√≠fica y tiene sus propias caracter√≠sticas y dificultades para crear compiladores inteligentes.  Al mismo tiempo, hay muchos estudios sobre este tema y se han llevado a cabo durante mucho tiempo tanto en el entorno acad√©mico como en diversas empresas. <br><br>  ¬øD√≥nde exactamente est√°n tratando de aplicar m√©todos de aprendizaje autom√°tico al crear compiladores?  ¬øY por qu√© hasta ahora los compiladores "inteligentes" no se han convertido en parte de la vida diaria del desarrollador? <br><a name="habracut"></a><br><h2>  Opciones para usar el aprendizaje autom√°tico en el desarrollo del compilador </h2><br>  Comencemos con la primera pregunta sobre usos espec√≠ficos del aprendizaje autom√°tico.  El hecho es que los compiladores modernos son sistemas complejos con una gran cantidad de optimizaciones que le permiten obtener un c√≥digo de m√°quina m√°s eficiente.  Sin embargo, algunas de las optimizaciones y otras tareas, como la asignaci√≥n de registros, son NP completas, lo que obliga a los desarrolladores de compiladores a usar algoritmos heur√≠sticos.  Como resultado, la mayor√≠a de los compiladores tienen una gran cantidad de indicadores de optimizaci√≥n que le permiten configurar la heur√≠stica utilizada.  En LLVM, casi todos los pasajes tienen varias opciones ocultas que pueden afectar su funcionamiento, se pueden usar con el indicador ‚Äìmllvm al llamar a clang o en la utilidad opt.  Sin embargo, esta variedad de indicadores est√° oculta detr√°s de las opciones que se usan con mucha m√°s frecuencia, que contienen muchas configuraciones a la vez y generalmente se denominan niveles de optimizaci√≥n.  Para los compiladores C / C ++, estos son conocidos por la mayor√≠a de -O1, -O2, -O3 para optimizar el tiempo de ejecuci√≥n y -Os para optimizar el tama√±o del c√≥digo.  Pero, desafortunadamente, el c√≥digo √≥ptimo no siempre es el resultado (los expertos en ensambladores pueden reescribir el c√≥digo generado de la mejor manera), mucho depende del c√≥digo fuente en un lenguaje de alto nivel, arquitectura de procesador, caracter√≠sticas de lenguaje, etc. <br><br>  A pesar de que hoy en d√≠a los procesadores modernos tienen suficiente RAM y un rendimiento bastante alto, todav√≠a hay √°reas donde el rendimiento de la aplicaci√≥n, la eficiencia energ√©tica y el tama√±o del c√≥digo de la m√°quina juegan un papel clave.  Ejemplos de tales √°reas incluyen el desarrollo de software para sistemas embebidos con una cantidad limitada de RAM, procesamiento de se√±al digital, sistemas en tiempo real, etc.  Por lo tanto, en los casos en que necesite obtener un c√≥digo de m√°quina de alto rendimiento para sistemas lo suficientemente grandes, la selecci√≥n de las opciones de compilaci√≥n correctas que brinden el mejor resultado es una tarea importante.  Adem√°s, el problema del peor tiempo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecuci√≥n</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WCET</a> ) no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha</a> desaparecido cuando los sistemas en tiempo real necesitan calcular y minimizar, si es posible, el tiempo de ejecuci√≥n de una tarea espec√≠fica en la plataforma.  Hasta ahora, los programadores que trabajan con sistemas con una cantidad limitada de RAM no pueden confiar completamente en los compiladores y, a menudo, optimizan independientemente el c√≥digo de m√°quina generado. <br><br>  Es dif√≠cil para una persona predecir qu√© optimizaciones dar√°n un buen resultado y cu√°les pueden dar lugar a regresiones, porque para esto necesita comprender bien las complejidades de los algoritmos heur√≠sticos utilizados, un buen conocimiento de la estructura y los pasos del compilador utilizado, y tambi√©n conocer completamente el c√≥digo del programa compilado, que El proceso de desarrollo de aplicaciones actual es imposible.  Como resultado, identificar las mejores opciones de compilaci√≥n para un programa para una persona se convierte en una tarea de b√∫squeda exhaustiva de varias combinaciones de opciones y medidas de rendimiento y tama√±os de c√≥digo. <br><br>  Adem√°s, existe una limitaci√≥n en la forma de una unidad de compilaci√≥n con la que puede trabajar y para la que puede elegir opciones.  Entonces, para C / C ++, este sigue siendo un archivo que puede contener una gran cantidad de c√≥digo, lo que, quiz√°s, ser√≠a √∫til para optimizar de diferentes maneras, pero por el momento esto no es posible.  Por lo tanto, un compilador "inteligente" que podr√≠a entrenar y luego obtener un c√≥digo bien optimizado para una variedad de casos es un sue√±o para algunos desarrolladores. <br><br><h2>  Investigaci√≥n y soluciones existentes </h2><br>  Naturalmente, el problema de la selecci√≥n autom√°tica de opciones de compilaci√≥n ha sido de inter√©s para los investigadores durante muchos a√±os.  Uno de los proyectos m√°s famosos es el desarrollo de G. Fursin e investigadores de su equipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MILEPOST GCC</a> , que es una versi√≥n del compilador gcc que puede seleccionar pases de optimizaci√≥n basados ‚Äã‚Äãen la capacitaci√≥n previa en la muestra de datos obtenida.  En este trabajo, utilizamos un conjunto de 55 caracter√≠sticas para resolver el problema y un modelo bastante simple basado en la idea de distribuir buenas soluciones basadas en el algoritmo K de los vecinos m√°s cercanos.  Fue este desarrollo el que mostr√≥ que los pases de optimizaci√≥n de ajuste pueden conducir a un c√≥digo que es dos veces m√°s r√°pido que el c√≥digo obtenido usando la opci√≥n de optimizaci√≥n m√°xima est√°ndar -O3. <br><br>  Tambi√©n hay estudios de G. Pekhimenko y A.D.  Brown para IBM TPO ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Toronto Portable Optimizer</a> ).  Su tarea principal era seleccionar valores seleccionables heur√≠sticamente para optimizaciones y el conjunto de transformaciones de c√≥digo.  Para la implementaci√≥n, se utiliz√≥ la regresi√≥n log√≠stica, lo que hizo posible realizar ajustes de multas efectivos para un entrenamiento m√°s r√°pido.  El clasificador fue construido en Matlab.  La probabilidad de uso se calcul√≥ para cada pase, y se us√≥ si era m√°s del 50%.  Como resultado de la caracter√≠stica que intentaron reducir en este estudio, fue el tiempo de compilaci√≥n est√°tico. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A.Askhari</a> particip√≥ en la selecci√≥n directa de opciones de compilaci√≥n para todo el programa para minimizar el tiempo de ejecuci√≥n, el tiempo de compilaci√≥n, el tama√±o del c√≥digo y el consumo de energ√≠a.  Para esto, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">utilizaron</a> el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cTuning Framework</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Collective Mind Framework</a> desarrollados por G. Fursin y A. Lokhmotov (tambi√©n desarrollado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> ). <br><br>  Tambi√©n hay estudios de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M. Stephenson y S. Amarasinge de</a> seleccionar optimizaciones para ciertos algoritmos especialmente importantes (asignaci√≥n de registros, PREFETCHING DE DATOS, FORMACI√ìN DE HIPERBLOQUE).  Para cada funci√≥n, sus propias caracter√≠sticas se utilizaron en consecuencia.  Para la soluci√≥n, se utiliz√≥ un algoritmo gen√©tico.  Las pruebas del producto desarrollado se llevaron a cabo en el Open Research Compiler (ORC). <br><br>  Tambi√©n hay un proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MAGEEC</a> (compilador eficiente de energ√≠a guiado por m√°quina), cuyos objetivos son algo diferentes.  La infraestructura desarrollada utiliza el aprendizaje autom√°tico para seleccionar las optimizaciones necesarias para generar el c√≥digo con la m√°xima eficiencia energ√©tica para sistemas inform√°ticos de alto rendimiento.  MAGEEC est√° dise√±ado para funcionar con gcc y LLVM.  Este compilador es parte del proyecto m√°s grande TSERO (Total Software Energy Reporting and Optimization). <br><br>  Una investigaci√≥n directamente relacionada con LLVM es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LLVMTuner</a> , un producto de software desarrollado en la Universidad de Illinois por I. Chen y W. Adwe.  En 2017, se present√≥ un informe que describe los resultados disponibles en ese momento.  En este trabajo, optimizamos ciclos individuales "calientes".  Este marco est√° dise√±ado para la configuraci√≥n automatizada de grandes programas.  LLVMTuner se ejecuta en el middleware LLVM IR, utiliza perfiles para identificar bucles activos y luego ajusta autom√°ticamente la heur√≠stica para ellos.  La atenci√≥n se centra en los ciclos de nivel superior.  Los ciclos seleccionados y cualquier funci√≥n de llamada se transfieren a un m√≥dulo separado, que est√° sujeto a las optimizaciones necesarias.  Esta soluci√≥n le permite obtener un rendimiento mejorado en programas grandes. <br><br><h2>  Problemas existentes </h2><br>  Sin embargo, no existe un compilador ampliamente utilizado que ajuste independientemente la heur√≠stica de la optimizaci√≥n de pasadas.  Cual es el problema  Como sabe, la efectividad de los m√©todos de aprendizaje autom√°tico y la calidad de los modelos obtenidos dependen de la elecci√≥n correcta de las caracter√≠sticas y la calidad de los datos para el entrenamiento (a pesar de la existencia de algoritmos menos sensibles a los datos "ruidosos").  Sin conocer la estructura y los algoritmos utilizados en el compilador, no es f√°cil seleccionar un conjunto completo y suficiente de caracter√≠sticas para el entrenamiento, aunque existen algunas bastante claras y l√≥gicas, por ejemplo, el tama√±o del ciclo, el n√∫mero de salidas del ciclo, etc.  Por lo tanto, es dif√≠cil desarrollar una soluci√≥n universal adecuada para muchos compiladores a la vez, y no es un hecho que generalmente sea posible.  Adem√°s, es probable que esto no sea necesario. <br><br>  Dado que el desarrollo de compiladores debe ser eficiente y factible en un tiempo bastante corto, es natural que incluso las grandes empresas desarrollen sus compiladores industriales basados ‚Äã‚Äãen soluciones preparadas.  La mayor√≠a de las soluciones modernas se pueden dividir en dos categor√≠as: ejecutando en m√°quinas virtuales, por ejemplo, JVM - compiladores JIT, y compiladores basados ‚Äã‚Äãen LLVM, un sistema que implementa una m√°quina virtual con instrucciones similares a RISC - compiladores est√°ticos y din√°micos.  Por supuesto, todav√≠a existen soluciones propias de las empresas, pero se est√°n volviendo menos competitivas debido a la falta de una gran comunidad involucrada en el desarrollo de las tecnolog√≠as utilizadas en ellas.  Como resultado, hoy en d√≠a muchas grandes empresas como Google, Apple, Adobe, ARM utilizan LLVM para desarrollar sus propias soluciones.  Por supuesto, gcc sigue siendo el compilador principal para C / C ++, existen otras soluciones para otros lenguajes, pero de todos modos, si, por ejemplo, se encuentra una soluci√≥n para LLVM, esto ya cubrir√° una parte decente de los compiladores existentes actualmente. <br><br>  La recopilaci√≥n de caracter√≠sticas para el entrenamiento tambi√©n se convierte en un gran problema, ya que los compiladores de m√∫ltiples pasos transforman fuertemente la representaci√≥n intermedia, y las caracter√≠sticas recopiladas en la etapa inicial no son muy relevantes para las optimizaciones posteriores del compilador, estas caracter√≠sticas pueden cambiar con una alta probabilidad.  Adem√°s, tiene sentido recopilar por separado para diferentes tipos de elementos: m√≥dulos, ciclos, bloques base, ya que las optimizaciones generalmente est√°n dise√±adas para cambiar un tipo particular de elemento, en LLVM, incluso de acuerdo con este criterio, los pasajes se dividen. <br><br>  Pero, en primer lugar, surge la cuesti√≥n de identificar los elementos para los cuales es necesario recopilar caracter√≠sticas.  Hay muchas formas de calcular identificadores √∫nicos que se pueden guardar durante todas las optimizaciones, por ejemplo: <br><br><ul><li>  Hash de front end basado en AST </li><li>  n√∫meros √∫nicos asignados en el an√°lisis frontal </li><li>  N√∫mero de 64 bits generado sobre la base de arcos en CFG (gr√°fico de flujo de control) utilizando una suma de verificaci√≥n (similar a PGO (Optimizaci√≥n guiada por perfil) en LLVM) </li></ul><br>  Sin embargo, debe guardar correctamente estos identificadores durante las transformaciones, cuando los elementos pueden fusionarse en uno, dividirse, crear nuevos y eliminar los originales, lo cual no es una tarea f√°cil. <br><br>  En segundo lugar, es dif√≠cil, en principio, evaluar los l√≠mites de los ciclos fuente, los bloques base, etc., escritos en el c√≥digo fuente, en el IR ya convertido.  Por ejemplo, debido a la generaci√≥n de m√∫ltiples etapas del c√≥digo de m√°quina adoptado por LLVM, la informaci√≥n sobre las unidades base de la m√°quina se pierde despu√©s de la generaci√≥n del c√≥digo seg√∫n las instrucciones de la m√°quina en AsmPrinter.  Y, en consecuencia, tambi√©n se pierde informaci√≥n sobre los identificadores de los bloques y ciclos base, para lo cual, por ejemplo, se mide el desplazamiento desde el comienzo de la funci√≥n, por lo tanto, con este m√©todo, solo en la etapa de generaci√≥n del c√≥digo de m√°quina se puede obtener el desplazamiento en forma de n√∫mero de bytes.  Sin embargo, en las etapas posteriores de generaci√≥n de c√≥digo de m√°quina cuando se trabaja con fragmentos de m√°quina, se pueden agregar varias alineaciones, que cambian el tama√±o de las instrucciones tomadas en cuenta anteriormente, y tambi√©n se agregan instrucciones nop.  Debido a esto, para los bloques base al final de las funciones grandes, el error de c√°lculo puede ser muy grande, hasta un cambio completo a otro bloque / ciclo.  Y aunque algunas de las transformaciones en las etapas posteriores se pueden rastrear y tener en cuenta, esto no dar√° garant√≠as para la precisi√≥n de las mediciones, ya que el tama√±o de las instrucciones puede variar hasta el enlazador. <br><br><img src="https://habrastorage.org/webt/af/xw/2-/afxw2-jziob0rhikr1nqaw_wmai.png"><br><br>  Como puede ver, incluso la colecci√≥n de atributos sobre la base de la cual se necesita capacitaci√≥n es bastante complicada y requiere mucho tiempo, y que en el futuro probablemente se convierta en el conjunto de entrada para el modelo capacitado para la toma de decisiones.  Y no hay soluciones obvias para estos problemas, lo que complica el trabajo inmediato asociado con el aprendizaje autom√°tico y atrae a un gran n√∫mero de personas debido a la falta de suficientes conjuntos de datos.  Bueno, las dificultades t√≠picas de encontrar soluciones a los problemas de aprendizaje autom√°tico, elegir modelos, m√©todos, determinar el subconjunto correcto de atributos con una gran cantidad de ellos, etc.  existe en este caso.  Casi todos los que se han encontrado con el aprendizaje autom√°tico saben sobre ellos y, tal vez, algo √∫nico y espec√≠fico para los compiladores no est√° aqu√≠. <br><br>  Es dif√≠cil predecir cu√°ndo los compiladores inteligentes se generalizar√°n.  Los compiladores modernos tambi√©n tienen otros problemas que es poco probable que se resuelvan con este m√©todo, y que en este momento probablemente sean m√°s prioritarios.  Sin embargo, los compiladores ya se han vuelto mucho m√°s inteligentes de lo que eran al comienzo de su aparici√≥n, y este proceso continuar√°, aunque puede ser algo m√°s lento de lo que a la mayor√≠a de los desarrolladores les gustar√≠a. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/450850/">https://habr.com/ru/post/450850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450838/index.html">Por qu√© la unidad no se atribuye a los n√∫meros primos, y cu√°ndo generalmente se consideraba un n√∫mero</a></li>
<li><a href="../450840/index.html">La √∫ltima linterna est√° cansada o ¬øEl parpadeo salvar√° a Bielorrusia (upd. Spinner?)</a></li>
<li><a href="../450844/index.html">Introducci√≥n a la asignaci√≥n de ejemplos</a></li>
<li><a href="../450846/index.html">Las maravillas del empaque de Microsoft: el kernel de Linux en Windows 10 y el motor IE dentro de Chromium Edge</a></li>
<li><a href="../450848/index.html">Sobre el f√≥sforo amarillo y la naturaleza de p√°nico del hombre</a></li>
<li><a href="../450854/index.html">Experiencia en el desarrollo de un activo de Unity para encontrar un camino en el espacio 3D</a></li>
<li><a href="../450858/index.html">Reuni√≥n de redes de c√≥digo abierto - ahora en Yandex.Cloud # 3.2019</a></li>
<li><a href="../450860/index.html">Toma inteligente REDMOND SkyPort 100S</a></li>
<li><a href="../450862/index.html">@Pythonetc Abril 2019</a></li>
<li><a href="../450864/index.html">Consejos y trucos de mi canal de Telegram @pythonetc, abril de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>