<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 ✋🏽 🧑🏽‍🤝‍🧑🏼 Mit Ghidra einen einfachen Riss brechen - Teil 2 🖕🏾 👨🏿‍🚒 👨‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im ersten Teil des Artikels haben wir mit Ghidra automatisch ein einfaches Crack-Programm analysiert (das wir von crackmes.one heruntergeladen haben)....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mit Ghidra einen einfachen Riss brechen - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447488/">  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil des</a> Artikels haben wir mit Ghidra automatisch ein einfaches Crack-Programm analysiert (das wir von crackmes.one heruntergeladen haben).  Wir haben herausgefunden, wie "unverständliche" Funktionen direkt in der Dekompilerliste umbenannt werden können, und haben auch den Algorithmus des "Top Level" -Programms verstanden, d. H.  was von <b>main () gemacht wird</b> . <br><br>  In diesem Teil werden wir, wie versprochen, die Analyse der Funktion <strong>_construct_key () aufnehmen</strong> , die, wie wir herausgefunden haben, für das Lesen der an das Programm übertragenen Binärdatei und das Überprüfen der gelesenen Daten verantwortlich ist. <br><a name="habracut"></a><br><h2>  Schritt 5 - Übersicht über die Funktion _construct_key () </h2><br>  Schauen wir uns gleich die vollständige Liste dieser Funktion an: <br><br><div class="spoiler">  <b class="spoiler_title">Listing _construct_key ()</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** __cdecl _construct_key(FILE *param_1) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iVar1; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sVar2; uint uVar3; uint local_3c; byte local_36; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_35; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_34; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_30 [<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *local_20; undefined4 local_19; undefined local_15; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **local_14; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_10; local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_14 == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { local_19 = <span class="hljs-number"><span class="hljs-number">0</span></span>; local_15 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_19,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); iVar1 = _text((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;local_19,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); _text(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(local_14[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *local_14; local_30[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; local_30[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *local_14 + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; local_20 = *local_14 + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; local_10 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (local_10 &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { local_35 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_35,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*local_30[local_10] != local_35) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_36 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_36,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_36 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)local_36; _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); sVar2 = _text(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sVar2 != *(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>)) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } local_3c = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_3c,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); local_3c = local_3c + <span class="hljs-number"><span class="hljs-number">7</span></span>; uVar3 = _text(param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (local_3c &lt; uVar3) { _free_key(local_14); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } *(uint *)(local_30[local_10] + <span class="hljs-number"><span class="hljs-number">0x108</span></span>) = local_3c; _text(param_1,local_3c,<span class="hljs-number"><span class="hljs-number">0</span></span>); local_10 = local_10 + <span class="hljs-number"><span class="hljs-number">1</span></span>; } local_34 = <span class="hljs-number"><span class="hljs-number">0</span></span>; _text(&amp;local_34,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(*local_14 + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) == local_34) { _text(<span class="hljs-string"><span class="hljs-string">"Markers seem to still exist"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _free_key(local_14); local_14 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_14; }</code> </pre> <br></div></div><br>  Mit dieser Funktion machen wir dasselbe wie zuvor mit <strong>main ()</strong> - zunächst werden wir die "verschleierten" Funktionsaufrufe durchgehen.  Wie erwartet stammen alle diese Funktionen aus den Standard-C-Bibliotheken. Ich werde das Verfahren zum erneuten Umbenennen von Funktionen nicht beschreiben - kehren Sie gegebenenfalls zum ersten Teil des Artikels zurück.  Durch das Umbenennen wurden folgende Standardfunktionen „gefunden“: <br><br><ul><li>  fread () </li><li>  strncmp () </li><li>  strlen () </li><li>  ftell () </li><li>  fseek () </li><li>  setzt () </li></ul><br>  Wir haben die entsprechenden Wrapper-Funktionen in unserem Code umbenannt (diejenigen, die der Dekompiler dreist hinter dem Wort <strong>_text</strong> versteckt <strong>hat</strong> ), indem <strong>wir</strong> Index 2 hinzugefügt haben (damit es nicht zu Verwechslungen mit den ursprünglichen C-Funktionen kommt).  Fast alle diese Funktionen dienen zum Arbeiten mit Dateistreams.  Es ist nicht überraschend - ein kurzer Blick auf den Code reicht aus, um zu verstehen, dass er nacheinander Daten aus einer Datei liest (deren Deskriptor als einziger Parameter an die Funktion übergeben wird) und die gelesenen Daten mit einem bestimmten zweidimensionalen Array von <strong>local_14</strong> Bytes vergleicht. <br><br>  Nehmen wir an, dass dieses Array Daten zur Schlüsselüberprüfung enthält.  Nennen Sie es, sagen Sie <strong>key_array</strong> .  Da Sie mit Hydra nicht nur Funktionen, sondern auch Variablen umbenennen können, werden wir dies verwenden und das unverständliche <strong>local_14</strong> in ein verständlicheres <strong>key_array umbenennen</strong> .  Dies geschieht auf die gleiche Weise wie bei Funktionen: über das Menü der rechten Maustaste ( <strong>lokal umbenennen</strong> ) oder über die <strong>L-</strong> Taste auf der Tastatur. <br><br>  Unmittelbar nach der Deklaration lokaler Variablen wird eine bestimmte Funktion <strong>_prepare_key () aufgerufen</strong> : <br><br><pre> <code class="cpp hljs">key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)__prepare_key(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; }</code> </pre><br>  Wir kehren zu <strong>_prepare_key () zurück</strong> . Dies ist die 3. Verschachtelungsebene in unserer <strong>Aufrufhierarchie</strong> : <strong>main () -&gt; _construct_key () -&gt; _prepare_key ()</strong> .  In der Zwischenzeit akzeptieren wir, dass es dieses zweidimensionale "Test" -Array erstellt und irgendwie initialisiert.  Und nur wenn dieses Array nicht leer ist, setzt die Funktion ihre Arbeit fort, wie der <b>else-</b> Block unmittelbar nach der obigen Bedingung zeigt. <br><br>  Als nächstes liest das Programm die ersten 4 Bytes aus der Datei und vergleicht sie mit dem entsprechenden Abschnitt des Arrays <b>key_array</b> .  (Der folgende Code ist nach dem Umbenennen, einschließlich der Variablen <b>local_19,</b> ich habe <b>first_4bytes</b> umbenannt.) <br><br><pre> <code class="cpp hljs">first_4bytes = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   4    */</span></span> fread2(&amp;first_4bytes,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,param_1); <span class="hljs-comment"><span class="hljs-comment">/*   key_array[1][0...3] */</span></span> iVar1 = strncmp2((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;first_4bytes,*(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iVar1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ... }</code> </pre><br>  Eine weitere Ausführung erfolgt daher nur, wenn die ersten 4 Bytes übereinstimmen (denken Sie daran).  Dann lesen wir 2 2-Byte-Blöcke aus der Datei (und dasselbe <b>key_array</b> wird als Puffer zum Schreiben von Daten verwendet): <br><br><pre> <code class="cpp hljs">fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1); fread2(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,param_1);</code> </pre><br>  Und wieder - weiter funktioniert die Funktion nur, wenn die nächste Bedingung erfüllt ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (*(<span class="hljs-keyword"><span class="hljs-keyword">short</span></span> *)(key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) == <span class="hljs-number"><span class="hljs-number">5</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//   ... }</span></span></code> </pre><br>  Es ist leicht zu erkennen, dass der erste der oben gelesenen 2-Byte-Blöcke die Nummer 5 und der zweite die Nummer 4 sein sollte (der Datentyp <b>short</b> belegt auf 32-Bit-Plattformen nur 2 Byte). <br><br>  Als nächstes ist dies: <br><br><pre> <code class="cpp hljs">local_30[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; <span class="hljs-comment"><span class="hljs-comment">// .. key_array[0] local_30[1] = *key_array + 0x10c; local_30[2] = *key_array + 0x218; local_30[3] = *key_array + 0x324; local_20 = *key_array + 0x430;</span></span></code> </pre><br>  Hier sehen wir, dass das <b>local_30-</b> Array (deklariert als char * local_30 [4]) die Offsets des <b>key_array-</b> Zeigers enthält.  Das heißt, <b>local_30</b> ist ein Array von Markierungszeilen, in die die Daten aus der Datei wahrscheinlich gelesen werden.  Unter dieser Annahme habe ich <b>local_30</b> in <b>marker</b> umbenannt.  In diesem Codeabschnitt erscheint nur die letzte Zeile etwas verdächtig, wobei die Zuweisung des letzten Versatzes (bei Index 0x430, d. H. 1072) nicht vom nächsten <b>Markierungselement</b> , sondern von einer separaten Variablen <b>local_20</b> ( <b>char *</b> ) ausgeführt wird.  Aber wir werden es noch herausfinden, aber jetzt - lass uns weitermachen! <br><br>  Als nächstes warten wir auf einen Zyklus: <br><br><pre> <code class="cpp hljs"> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// local_10   i while (i &lt; 5) { // ... i = i + 1; }</span></span></code> </pre><br>  Das heißt,  Nur 5 Iterationen von 0 bis einschließlich 4.  In der Schleife beginnt sofort das Lesen aus der Datei und das Überprüfen der Übereinstimmung mit unserem <b>Marker-</b> Array: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c_marker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_35 /*  .    */ fread2(&amp;c_marker, 1, 1, param_1); if (*markers[i] != c_marker) { /*    -      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Das heißt, das nächste Byte aus der Datei wird in die Variable <b>c_marker</b> (im ursprünglichen dekompilierten Code - <b>local_35</b> ) <b>eingelesen</b> und auf Übereinstimmung mit dem ersten Zeichen des i-ten <b>Markierungselements</b> überprüft.  Im Falle einer <b>Nichtübereinstimmung wird das</b> Array <b>key_array</b> aufgehoben und ein leerer Doppelzeiger zurückgegeben.  Weiter unten im Code sehen wir, dass dies immer dann geschieht, wenn die gelesenen Daten nicht mit den Verifizierungsdaten übereinstimmen. <br><br>  Aber hier, wie sie sagen, "ist der Hund begraben."  Schauen wir uns diesen Zyklus genauer an.  Es hat 5 Iterationen, wie wir herausgefunden haben.  Sie können dies überprüfen, wenn Sie möchten, indem Sie sich den Assembler-Code ansehen: <br><br><img src="https://habrastorage.org/webt/si/b4/q8/sib4q8jsxe2zyxpxi2gcwy0vfba.png"><br><br><img src="https://habrastorage.org/webt/tr/8q/oh/tr8qoh9ayg-7v9t6rv1vwtsuy_c.png"><br><br>  In der Tat vergleicht der CMP-Befehl den Wert der Variablen <b>local_10</b> (wir haben bereits <b>i</b> ) mit der Zahl 4, und wenn der Wert <i>kleiner oder gleich</i> 4 ist (der JLE-Befehl), erfolgt der Übergang zur Bezeichnung <b>LAB_004017eb</b> , d. H.  Beginn des Zykluskörpers.  Das heißt,  Die Bedingung wird für <b>i</b> = 0, 1, 2, 3 und 4 erfüllt - nur 5 Iterationen!  Alles wäre in Ordnung, aber <b>Marker werden</b> auch von dieser Variablen in einer Schleife indiziert, und schließlich wird dieses Array mit nur 4 Elementen deklariert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *markers [<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre><br>  Also versucht jemand eindeutig, jemanden zu täuschen :) Erinnerst du dich, ich sagte, dass diese Zeile zweifelhaft ist? <br><br><pre> <code class="cpp hljs">local_20 = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>;</code> </pre><br>  Einfach so!  Schauen Sie sich einfach die gesamte Liste der Funktion an und versuchen Sie, mindestens einen weiteren Verweis auf die Variable <b>local_20</b> zu finden.  Sie ist nicht da!  Wir schließen daraus: Dieser Offset sollte auch im <b>Marker-</b> Array gespeichert werden, und das Array selbst sollte 5 Elemente enthalten.  Lass es uns reparieren.  Gehen Sie zur Variablendeklaration, <b>drücken Sie Strg + L</b> (Variable erneut eingeben) und ändern Sie die Größe des Arrays mutig auf 5: <br><br><img src="https://habrastorage.org/webt/t0/sq/xw/t0sqxw-hbw5dqo9mca3m43r5cei.png"><br><br>  Fertig.  Scrollen Sie nach unten zum Code, um <b>Markern</b> Zeigerversätze <b>zuzuweisen</b> , und - siehe da!  - Eine unverständliche zusätzliche Variable verschwindet und alles passt zusammen: <br><br><pre> <code class="cpp hljs">markers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = *key_array; markers[<span class="hljs-number"><span class="hljs-number">1</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>; markers[<span class="hljs-number"><span class="hljs-number">2</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>; markers[<span class="hljs-number"><span class="hljs-number">3</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>; markers[<span class="hljs-number"><span class="hljs-number">4</span></span>] = *key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ...   !</span></span></code> </pre><br>  Wir kehren zu unserer <b>while-Schleife zurück</b> (im Quellcode ist dies höchstwahrscheinlich der Fall, aber das ist uns egal).  Als nächstes wird das Byte aus der Datei erneut gelesen und sein Wert überprüft: <br><br><pre> <code class="cpp hljs">byte n_strlen1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_36 /*  .    */ fread2(&amp;n_strlen1,1,1,param_1); if (n_strlen1 == 0) { /*      */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  OK, dieses <b>n_strlen1</b> muss ungleich Null sein.  Warum?  Sie werden es jetzt sehen, aber gleichzeitig werden Sie verstehen, warum ich dieser Variablen den folgenden Namen gegeben habe: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   n_strlen1)  (markers[i] + 0x104) */</span></span> *(uint *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = (uint)n_strlen1; <span class="hljs-comment"><span class="hljs-comment">/*    (n_strlen1)  (--&gt;  ?) */</span></span> fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,*(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> *)(markers[i] + <span class="hljs-number"><span class="hljs-number">0x104</span></span>),param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   sVar2 if (n_strlen2 != *(size_t *)(markers[i] + 0x104)) { /*    (n_strlen2)  == n_strlen1 */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Ich habe Kommentare hinzugefügt, zu denen alles klar sein sollte.  <b>N_strlen1</b> Bytes werden aus der Datei gelesen und als Folge von Zeichen (dh als Zeichenfolge) im <b>Marker [i]</b> <b>-Array</b> gespeichert - also nach dem entsprechenden „ <b>Stoppsymbol</b> “, das dort bereits von <b>key_array geschrieben wurde</b> .  Das Speichern des Wertes <b>n_strlen1</b> in <b>Markern [i]</b> bei Offset 0x104 (260) spielt hier keine Rolle (siehe erste Zeile im obigen Code).  Tatsächlich kann dieser Code wie folgt optimiert werden (und dies ist sicherlich im Quellcode der Fall): <br><br><pre> <code class="cpp hljs">fread2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1, param_1); n_strlen2 = strlen2(markers[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n_strlen2 != (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>) n_strlen1) { ... }</code> </pre><br>  Es wird auch überprüft, ob die Länge der gelesenen Zeile <b>n_strlen1 ist</b> .  Dies mag unnötig erscheinen, da dieser Parameter an die <b>Fread-</b> Funktion übergeben wurde, <b>Fread jedoch</b> <i>nicht mehr als</i> so viele angegebene Bytes liest und weniger als angegeben lesen kann, z. B. wenn der Dateiende-Marker (EOF) erreicht wird.  Das heißt, alles ist streng: Die Länge der Zeile (in Bytes) wird in der Datei angegeben, dann geht die Zeile selbst - und genau fünfmal.  Aber wir sind uns selbst voraus. <br><br>  Weitere Gewässer dieser Code (den ich auch sofort kommentiert habe): <br><br><pre> <code class="cpp hljs">uint n_pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_3c /*  .    */ fread2(&amp;n_pos,1,1,param_1); /*   7 */ n_pos = n_pos + 7; /*     */ uint n_filepos = ftell2(param_1); //   uVar3 if (n_pos &lt; n_filepos) { /* n_pos   &gt;= n_filepos */ _free_key(key_array); return (char **)0x0; }</span></span></code> </pre><br>  Hier ist es noch einfacher: Wir nehmen das nächste Byte aus der Datei, addieren 7 und vergleichen den resultierenden Wert mit der aktuellen Cursorposition im Dateistream, die mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ftell () erhalten wurde</a> .  Der Wert von <b>n_pos</b> darf nicht kleiner als die Cursorposition sein (d. H. Versetzt in Bytes vom Anfang der Datei). <br><br>  Die letzte Zeile in der Schleife: <br><br><pre> <code class="cpp hljs">fseek2(param_1,n_pos,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Das heißt,  <b>Ordnen Sie</b> den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dateicursor (</a> von Anfang an) an der Position an, die von <b>n_pos</b> durch die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fseek () angegeben</a> wird.  OK, wir führen alle diese Operationen fünfmal in der Schleife aus.  Die Funktion <b>_construct_key () endet mit dem</b> folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_lastmarker = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   local_34 /*   4    (int32) */ fread2(&amp;i_lastmarker,4,1,param_1); if (*(int *)(*key_array + 0x53c) == i_lastmarker) { /*    == key_array[0][1340] ...   :) */ puts2("Markers seem to still exist"); } else { _free_key(key_array); key_array = (char **)0x0; }</span></span></code> </pre><br>  Daher sollte der letzte Datenblock in der Datei ein 4-Byte-Integer-Wert sein und dem Wert in <b>key_array [0] [1340] entsprechen</b> .  In diesem Fall erhalten wir eine Glückwunschbotschaft in der Konsole.  Ansonsten kehrt das leere Array immer noch ohne Lob zurück :) <br><br><h2>  Schritt 6 - Übersicht über die Funktion __prepare_key () </h2><br>  Wir haben nur noch eine nicht zusammengesetzte Funktion - <b>__prepare_key ()</b> .  Wir haben bereits vermutet, dass darin die Verifizierungsdaten in Form des Arrays <b>key_array</b> generiert werden, das dann in der Funktion <b>_construct_key ()</b> verwendet wird, um die Daten aus der Datei zu überprüfen.  Es bleibt abzuwarten, welche Art von Daten es gibt! <br><br>  Ich werde diese Funktion nicht im Detail analysieren und sofort eine vollständige Auflistung mit Kommentaren nach allen notwendigen Umbenennungen von Variablen geben: <br><br><div class="spoiler">  <b class="spoiler_title">__Prepare_key () Funktionsliste</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ** __prepare_key(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **key_array; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* key_array = new char*[2]; // 2 4-  (char*) */</span></span> key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key_array == (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>) { key_array = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **)<span class="hljs-number"><span class="hljs-number">0x0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0x540</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[0] = new char[1340] */</span></span> *key_array = pvVar1; pvVar1 = calloc2(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* key_array[1] = new char[8] */</span></span> key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = pvVar1; <span class="hljs-comment"><span class="hljs-comment">/* "VOID" */</span></span> *(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 5  4 (2- ) */</span></span> *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">4</span></span>) = <span class="hljs-number"><span class="hljs-number">5</span></span>; *(undefined2 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">6</span></span>) = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* key_array[0][0] = 'b' */</span></span> *(undefined *)*key_array = <span class="hljs-number"><span class="hljs-number">0x62</span></span>; *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x104</span></span>) = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'W' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x218</span></span>) = <span class="hljs-number"><span class="hljs-number">0x57</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'p' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x324</span></span>) = <span class="hljs-number"><span class="hljs-number">0x70</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 'l' */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x10c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x6c</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 152 ( ASCII) */</span></span> *(undefined *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x430</span></span>) = <span class="hljs-number"><span class="hljs-number">0x98</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   = 1122 (int32) */</span></span> *(undefined4 *)((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)*key_array + <span class="hljs-number"><span class="hljs-number">0x53c</span></span>) = <span class="hljs-number"><span class="hljs-number">0x462</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_array; }</code> </pre><br></div></div><br>  Der einzige Ort, der in Betracht gezogen werden sollte, ist diese Zeile: <br><br><pre> <code class="cpp hljs">*(undefined4 *)key_array[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0x404024</span></span>;</code> </pre><br>  Wie verstehe ich, dass hier die Zeile "VOID" liegt?  Tatsache ist, dass 0x404024 die Adresse im Adressraum des Programms ist, das <b>zum</b> Abschnitt <b>.rdata führt</b> .  Durch Doppelklicken auf diesen Wert können wir klar erkennen, was sich dort befindet: <br><br><img src="https://habrastorage.org/webt/8a/eu/0j/8aeu0jkpr-ea7euhrlcgvm0rxq8.png"><br><br>  Dasselbe kann übrigens aus dem Assembler-Code für diese Zeile verstanden werden: <br><br> <code>004015da c7 00 24 MOV dword ptr [EAX], .rdata = 56h V <br> 40 40 00 <br></code> <br>  Die der VOID-Zeile entsprechenden Daten befinden sich ganz am Anfang des <b>.rdata-</b> Abschnitts (bei einem Versatz von Null von der entsprechenden Adresse). <br><br>  Am Ende dieser Funktion sollte also ein zweidimensionales Array mit den folgenden Daten gebildet werden: <br><br> <code>[0] [0]:'b' [268]:'l' [536]:'W' [804]:'p' [1072]:152 [1340]:1122 <br> [1] [0-3]:"VOID" [4-5]:5 [6-7]:4 <br></code> <br><h2>  Schritt 7 - Bereiten Sie die Binärdatei für den Riss vor </h2><br>  Jetzt können wir mit der Synthese der Binärdatei beginnen.  Alle ersten Daten in unseren Händen: <br>  1) Verifizierungsdaten ("Stoppsymbole") und ihre Positionen im Verifizierungsarray; <br>  2) die Reihenfolge der Daten in der Datei <br><br>  <b>Stellen</b> wir die Struktur der <b>gesuchten</b> Datei gemäß dem Algorithmus der Funktion <b>_construct_key () wieder her</b> .  Die Reihenfolge der Daten in der Datei ist also wie folgt: <br><br><div class="spoiler">  <b class="spoiler_title">Dateistruktur</b> <div class="spoiler_text"><ol><li>  4 Bytes == key_array [1] [0 ... 3] == "VOID" </li><li>  2 Bytes == key_array [1] [4] == 5 </li><li>  2 Bytes == key_array [1] [6] == 4 </li><li>  1 Byte == key_array [0] [0] == 'b' (Token) </li><li>  1 Byte == (nächste Zeilenlänge) == n_strlen1 </li><li>  n_strlen1 Bytes == (beliebiger String) == n_strlen1 </li><li>  1 Byte == (+7 == nächster Token) == n_pos </li><li>  1 Byte == key_array [0] [0] == 'l' (Token) </li><li>  1 Byte == (nächste Zeilenlänge) == n_strlen1 </li><li>  n_strlen1 Bytes == (beliebiger String) == n_strlen1 </li><li>  1 Byte == (+7 == nächster Token) == n_pos </li><li>  1 Byte == key_array [0] [0] == 'W' (Token) </li><li>  1 Byte == (nächste Zeilenlänge) == n_strlen1 </li><li>  n_strlen1 Bytes == (beliebiger String) == n_strlen1 </li><li>  1 Byte == (+7 == nächster Token) == n_pos </li><li>  1 Byte == key_array [0] [0] == 'p' (Token) </li><li>  1 Byte == (nächste Zeilenlänge) == n_strlen1 </li><li>  n_strlen1 Bytes == (beliebiger String) == n_strlen1 </li><li>  1 Byte == (+7 == nächster Token) == n_pos </li><li>  1 Byte == key_array [0] [0] == 152 (Token) </li><li>  1 Byte == (nächste Zeilenlänge) == n_strlen1 </li><li>  n_strlen1 Bytes == (beliebiger String) == n_strlen1 </li><li>  1 Byte == (+7 == nächster Token) == n_pos </li><li>  4 Bytes == (key_array [1340]) == 1122 </li></ol><br></div></div><br>  Aus Gründen der Übersichtlichkeit habe ich in Excel ein solches Tablet mit den Daten der gewünschten Datei erstellt: <br><br><img src="https://habrastorage.org/webt/kr/i-/7a/kri-7arjlro0ye_los64uhakbfq.png"><br><br>  Hier in der 7. Zeile - die Daten selbst in Form von Zeichen und Zahlen, in der 6. Zeile - ihre hexadezimalen Darstellungen, in der 8. Zeile - die Größe jedes Elements (in Bytes), in der 9. Zeile - der Versatz relativ zum Anfang der Datei.  Diese Ansicht ist sehr praktisch, weil  Mit dieser Option können Sie beliebige Zeilen in die zukünftige Datei eingeben (mit einer gelben Füllung markiert), während die Werte der Längen dieser Zeilen sowie die Positionsversätze des nächsten Stoppsymbols automatisch durch Formeln berechnet werden, wie es der Programmalgorithmus erfordert.  Oben (in den Zeilen 1 bis 4) ist die Struktur des Check-Arrays <b>key_array dargestellt</b> . <br><br>  Das Excel selbst sowie andere Quellenmaterialien für den Artikel können hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . <br><br><h3>  Generierung und Validierung von Binärdateien </h3><br>  Das einzige, was noch übrig bleibt, ist, die gewünschte Datei im Binärformat zu generieren und sie mit unserem Crack zu füttern.  Um die Datei zu generieren, habe ich ein einfaches Python-Skript geschrieben: <br><br><div class="spoiler">  <b class="spoiler_title">Skript zum Generieren der Datei</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys, os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess out_str = [<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">' solved'</span></span>, <span class="hljs-string"><span class="hljs-string">' this'</span></span>, <span class="hljs-string"><span class="hljs-string">' crackme!'</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_path, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> outfile: outfile.write(<span class="hljs-string"><span class="hljs-string">'VOID'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'2h'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'b'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos = <span class="hljs-number"><span class="hljs-number">10</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">0</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'l'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">1</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'W'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">2</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(<span class="hljs-string"><span class="hljs-string">'p'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">3</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">152</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]))) outfile.write(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>].encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>)) pos += <span class="hljs-number"><span class="hljs-number">3</span></span> + len(out_str[<span class="hljs-number"><span class="hljs-number">4</span></span>]) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, pos - <span class="hljs-number"><span class="hljs-number">6</span></span>)) outfile.write(struct.pack(<span class="hljs-string"><span class="hljs-string">'i'</span></span>, <span class="hljs-number"><span class="hljs-number">1122</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) != <span class="hljs-number"><span class="hljs-number">2</span></span>: print(<span class="hljs-string"><span class="hljs-string">'USAGE: {this_script.py} path_to_crackme[.exe]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.isfile(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]): print(<span class="hljs-string"><span class="hljs-string">'File "{}" unavailable!'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file_path = os.path.splitext(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-string"><span class="hljs-string">'.dat'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: write_file(file_path) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: outputstr = subprocess.check_output(<span class="hljs-string"><span class="hljs-string">'"{}" -f "{}"'</span></span>.format(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], file_path), stderr=subprocess.STDOUT) print(outputstr.decode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> err: print(err) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre><br></div></div><br>  Das Skript nimmt den Pfad zu den Rissen als einen einzelnen Parameter, generiert dann eine Binärdatei mit dem Schlüssel im selben Verzeichnis und ruft die Risse mit dem entsprechenden Parameter auf, wodurch die Programmausgabe in die Konsole übersetzt wird. <br><br>  Verwenden Sie das <b>Strukturpaket,</b> um Textdaten in Binärdaten zu konvertieren.  Mit der <b>pack ()</b> -Methode können Sie Binärdaten in einem Format schreiben, in dem der Datentyp angegeben ist ("B" = "Byte", "i" = int usw.), und Sie können auch die Reihenfolge angeben ("&gt;" = "Big" -endian "," &lt;"=" Little-endian ").  Die Standardreihenfolge ist Little-Endian.  Weil  Wir haben bereits im ersten Artikel festgestellt, dass dies genau unser Fall ist, dann geben wir nur den Typ an. <br><br>  Der gesamte Code gibt den gefundenen Programmalgorithmus wieder.  Als die Zeile, die gedruckt werden soll, wenn sie erfolgreich ist, habe ich angegeben "Ich habe dieses Crackme gelöst!"  (Sie können dieses Skript so ändern, dass eine beliebige Zeile angegeben werden kann.) <br><br>  Überprüfen Sie die Ausgabe: <br><br><img src="https://habrastorage.org/webt/th/mx/pz/thmxpzy22t8leydwou56w3emrze.png"><br><br>  Hurra, alles funktioniert!  Nachdem wir ein wenig geschwitzt und einige Funktionen aussortiert hatten, konnten wir den Programmalgorithmus vollständig wiederherstellen und ihn „knacken“.  Natürlich ist dies nur ein einfacher Riss, ein Testprogramm und sogar das des 2. Schwierigkeitsgrades (von 5, die auf dieser Site angeboten werden).  In der Realität werden wir uns mit einer komplexen Hierarchie von Aufrufen und Dutzenden - Hunderten von Funktionen und in einigen Fällen - verschlüsselten Abschnitten von Daten, Müllcode und anderen Verschleierungstechniken bis hin zur Verwendung interner virtueller Maschinen und P-Codes befassen ... Aber das ist, wie sie sagen, bereits eine ganz andere Geschichte. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Materialien für den Artikel.</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de447488/">https://habr.com/ru/post/de447488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de447474/index.html">Ein Miniatur-Funktions-Decatron-Analogon für die Harwell Dekatron-Computer-Replik und nicht nur</a></li>
<li><a href="../de447476/index.html">Festlegen von LaTeX in erhabenem Text</a></li>
<li><a href="../de447478/index.html">Die Illusion von Unveränderlichkeit und Vertrauen als Grundlage der Teamentwicklung</a></li>
<li><a href="../de447480/index.html">Kosmonautik-Tag 2019: Ereignisse nach Stadt</a></li>
<li><a href="../de447482/index.html">Cyber ​​Law School. 5 Tage digitales Recht intensiv</a></li>
<li><a href="../de447490/index.html">So verbessern Sie Ihren Schreibstil auf Englisch: 5 Tipps</a></li>
<li><a href="../de447494/index.html">Nachhaltigkeit GAN-Lernen (tiefer graben)</a></li>
<li><a href="../de447496/index.html">Verwalten von Himbeeren über Websockets</a></li>
<li><a href="../de447498/index.html">Fotobericht von JPoint 2019 + Ankündigung von Joker 2019 in St. Petersburg</a></li>
<li><a href="../de447500/index.html">Warum Betreiber von eSIM Angst bekommen haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>