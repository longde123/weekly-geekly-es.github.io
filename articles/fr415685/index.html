<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇ üë®üèΩ‚Äçüè´ üé£ Divulgation de la m√©moire du noyau dans le syst√®me d'exploitation moderne üññ ü§† üíÉüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sous le cutter se trouve la traduction de la premi√®re partie du document Detecting Kernel Memory Disclosure with x86 Emulation and Taint Tracking ( Ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Divulgation de la m√©moire du noyau dans le syst√®me d'exploitation moderne</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415685/"><p> Sous le cutter se trouve la traduction de la <strong>premi√®re partie du</strong> document <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Detecting Kernel Memory Disclosure with x86 Emulation and Taint Tracking</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article Project Zero</a> ) de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mateusz Jurczyk</a> . </p><br><p>  Dans la partie traduite du document: </p><br><ul><li>  Sp√©cificit√©s du langage de programmation C (dans le cadre du probl√®me d'extension de m√©moire) </li><li>  les sp√©cificit√©s du fonctionnement des noyaux Windows et Linux (dans le cadre du probl√®me d'extension m√©moire) </li><li>  importance de la divulgation de la m√©moire du noyau et impact sur la s√©curit√© du syst√®me d'exploitation </li><li>  m√©thodes et techniques existantes pour d√©tecter et contrer la divulgation de la m√©moire du noyau </li></ul><br><p>  Bien que le document se concentre sur les m√©canismes de communication entre le noyau privil√©gi√© du syst√®me d'exploitation et les applications utilisateur, l'essence du probl√®me peut √™tre g√©n√©ralis√©e pour tout transfert de donn√©es entre diff√©rents domaines de s√©curit√©: l'hyperviseur est la machine invit√©e, le service syst√®me privil√©gi√© (d√©mon) est l'application graphique, le client r√©seau est le serveur, etc. . </p><br><p><img src="https://habrastorage.org/webt/ne/uy/1q/neuy1q8npc2ba-y3vcaycx9kqxe.jpeg" alt="KDPV"></p><a name="habracut"></a><br><h2 id="vvedenie">  Pr√©sentation </h2><br><p>  L'une des t√¢ches des syst√®mes d'exploitation modernes est d'assurer la s√©paration des privil√®ges entre les applications utilisateur et le noyau du syst√®me d'exploitation.  Premi√®rement, cela inclut le fait que l'influence de chaque programme sur l'ex√©cution doit √™tre limit√©e par une certaine politique de s√©curit√©, et deuxi√®mement, que les programmes ne peuvent acc√©der qu'aux informations qu'ils sont autoris√©s √† lire.  Le second est difficile √† fournir, √©tant donn√© les propri√©t√©s du langage C (le langage de programmation principal utilis√© dans le d√©veloppement du noyau), qui rendent extr√™mement difficile le transfert s√©curis√© des donn√©es entre diff√©rents domaines de s√©curit√©. </p><br><p>  Les syst√®mes d'exploitation modernes fonctionnant sur des plates-formes x86 / x86-64 sont multithread et utilisent un mod√®le client-serveur dans lequel les applications en mode utilisateur (clients) sont ex√©cut√©es ind√©pendamment et appellent le noyau du syst√®me d'exploitation (serveur) avec l'intention de travailler avec une ressource g√©r√©e par le syst√®me.  Le m√©canisme utilis√© par le code du mode utilisateur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">anneau 3</a> ) pour appeler un ensemble pr√©d√©fini de fonctions du noyau (anneau 0) est appel√© appels syst√®me ou (bri√®vement) appels syst√®me.  Un appel syst√®me typique est illustr√© √† la figure 1: <br><img src="https://habrastorage.org/webt/dh/p3/hr/dhp3hruaqmh7onhd0mweycvv4bg.png" alt="Figure 1: appel syst√®me"><br>  <em>Figure 1: cycle de vie des appels syst√®me.</em> </p><br><p>  Il est tr√®s important d'√©viter de fuir par inadvertance le contenu de la m√©moire du noyau lors de l'interaction avec des programmes en mode utilisateur.  Il existe un risque important de divulgation de donn√©es sensibles du noyau.  Les donn√©es peuvent √™tre implicitement transmises dans les param√®tres de sortie des appels syst√®me s√ªrs (√† d'autres points de vue). </p><br><p>  La divulgation de la m√©moire syst√®me privil√©gi√©e se produit lorsque le noyau du syst√®me d'exploitation renvoie une r√©gion de m√©moire plus grande (exc√©dentaire) que n√©cessaire pour stocker les informations correspondantes (contenues √† l'int√©rieur).  Souvent, les octets redondants contiennent des donn√©es qui ont √©t√© remplies dans un contexte diff√©rent, puis la m√©moire n'a pas √©t√© pr√©-initialis√©e, ce qui emp√™cherait la diffusion d'informations dans de nouvelles structures de donn√©es. </p><br><h2 id="specifika-yazyka-programmirovaniya-c">  Sp√©cificit√©s du langage de programmation C </h2><br><p>  Dans cette section, nous examinons plusieurs aspects du langage C qui sont les plus importants pour le probl√®me d'extension de m√©moire. </p><br><h4 id="neopredelennoe-sostoyanie-neinicializirovannyh-peremennyh">  √âtat ind√©fini de variables non initialis√©es </h4><br><p>  Les variables individuelles de types simples (tels que char ou int), ainsi que les membres des structures de donn√©es (tableaux, structures et unions) restent dans un √©tat ind√©fini jusqu'√† la premi√®re initialisation (qu'ils soient plac√©s sur la pile ou sur le tas).  Citations pertinentes de la sp√©cification C11 (ISO / IEC 9899: 201x Draft de comit√© N1570, avril 2011): </p><br><blockquote>  6.7.9 Initialisation <br>  ... <br>  10 Si un objet qui a une dur√©e de stockage automatique n'est pas initialis√© explicitement, <u>sa valeur est ind√©termin√©e</u> . <br><br>  7.22.3.4 La fonction malloc <br>  ... <br>  2 La fonction malloc alloue de l'espace √† un objet dont la taille est sp√©cifi√©e par la taille et <u>dont la valeur est ind√©termin√©e</u> . <br><br>  7.22.3.5 La fonction realloc <br>  ... <br>  2 La fonction realloc d√©salloue l'ancien objet point√© par ptr et renvoie un pointeur sur un nouvel objet dont la taille est sp√©cifi√©e par taille.  Le contenu du nouvel objet doit √™tre le m√™me que celui de l'ancien objet avant la d√©sallocation, jusqu'√† la moindre des tailles nouvelle et ancienne.  Tous les octets du nouvel objet au-del√† de la taille de l'ancien objet <u>ont des valeurs ind√©termin√©es</u> . </blockquote><p>  La partie qui s'applique au code syst√®me est la plus pertinente pour les objets situ√©s sur la pile, car le noyau du syst√®me d'exploitation a g√©n√©ralement des interfaces d'allocation dynamique avec leur propre s√©mantique (pas n√©cessairement compatible avec la biblioth√®que C standard, comme cela sera d√©crit plus loin). </p><br><p>  √Ä notre connaissance, aucun des trois compilateurs C les plus populaires pour Windows et Linux (compilateur Microsoft C / C ++, gcc, LLVM) ne cr√©e de code qui pr√©-initialise les variables non initialis√©es par le programmeur sur la pile en mode Release-build (ou son √©quivalent).  Il existe des options de compilation pour marquer les cadres de pile avec des octets sp√©ciaux - marqueurs (/ RTC dans Microsoft Visual Studio, par exemple) mais ils ne sont pas utilis√©s dans les versions Release pour des raisons de performances.  Par cons√©quent, les variables non initialis√©es de la pile <em>h√©ritent des</em> anciennes valeurs des zones de m√©moire correspondantes. </p><br><p>  Prenons un exemple d'impl√©mentation standard d'un appel syst√®me fictif Windows qui multiplie un entier d'entr√©e par deux et renvoie le r√©sultat de la multiplication (Listing 1).  √âvidemment, dans le cas sp√©cial (InputValue == 0), la variable OutputValue reste non initialis√©e et est recopi√©e sur le client.  Cette erreur vous permet d'ouvrir quatre octets de m√©moire de pile de noyau pour chaque appel. </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMultiplyByTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD InputValue, LPDWORD OutputPointer)</span></span></span><span class="hljs-function"> </span></span>{ DWORD OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InputValue != <span class="hljs-number"><span class="hljs-number">0</span></span>) { OutputValue = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; } *OutputPointer = OutputValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Exemple de code 1: √©tendre la m√©moire via une variable locale non initialis√©e.</em> </p><br><p>  Les fuites via une variable locale non initialis√©e ne sont pas tr√®s courantes dans la pratique: d'une part, les compilateurs modernes d√©tectent et avertissent souvent de tels probl√®mes, d'autre part, ces fuites sont des erreurs fonctionnelles qui peuvent √™tre d√©tect√©es lors du d√©veloppement ou des tests.  Cependant, le deuxi√®me exemple (dans le Listing 2) montre qu'une fuite peut √©galement se produire via le champ de structure. </p><br><p>  Dans ce cas, le champ de structure r√©serv√© n'est jamais explicitement utilis√© dans le code, mais est toujours copi√© en mode utilisateur et, par cons√©quent, expose √©galement quatre octets de m√©moire du noyau au code appelant.  Cet exemple montre clairement que l'initialisation de chaque champ de chaque structure retourn√©e au client pour toutes les branches d'ex√©cution de code n'est pas une t√¢che facile.  Dans de nombreux cas, l'initialisation forc√©e semble illogique, surtout si ce champ ne joue aucun r√¥le pratique.  Mais c'est le fait qu'une variable (ou champ de structure) non initialis√©e sur la pile (ou sur le tas) accepte le contenu des donn√©es pr√©c√©demment stock√©es dans cette zone m√©moire (dans le cadre d'une autre op√©ration), se situe au c≈ìur du probl√®me d'extension m√©moire du noyau. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; DWORD Product; DWORD Reserved; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtArithOperations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.Product = InputValue * <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 2: Extension de m√©moire via un champ de structure r√©serv√©.</em> </p><br><h4 id="vyravnivanie-struktur-i-zapolnyayuschie-padding-bayty">  Alignement des structures et des octets de remplissage </h4><br><p>  L'initialisation de tous les champs de la structure de sortie est un bon d√©but pour √©viter d'√©tendre la m√©moire.  Mais cela ne suffit pas pour garantir que dans la repr√©sentation de bas niveau, il n'y a pas d'octets non initialis√©s.  Revenons √† la sp√©cification C11: </p><br><blockquote>  6.5.3.4 Les op√©rateurs sizeof et Alignof <br>  ... <br>  4 [...] Lorsqu'il est appliqu√© √† un op√©rande qui a une structure ou un type d'union, le r√©sultat est le nombre total d'octets dans un tel objet, <u>y compris le remplissage interne et final</u> . <br><br>  6.2.8 Alignement d'objets <br>  1 Les types d'objet complets ont des exigences d'alignement qui imposent des <u>restrictions sur les adresses auxquelles les objets de ce type peuvent √™tre attribu√©s</u> .  Un alignement est une valeur enti√®re int√©gr√©e d√©finie par l'impl√©mentation repr√©sentant le nombre d'octets entre des adresses successives auxquelles un objet donn√© peut √™tre allou√©.  [...] <br><br>  6.7.2.1 Structure et sp√©ci Ô¨Å cateurs d'union <br>  ... <br>  17 <u>Il peut y avoir un rembourrage sans nom √† la fin d'une structure ou d'union</u> . </blockquote><p>  Autrement dit, les compilateurs en langage C pour les architectures x86 (-64) utilisent l'alignement naturel des champs de structure (ayant un type primitif): chacun de ces champs est align√© de N octets, o√π N est la taille du champ.  En outre, des structures et des jointures enti√®res sont √©galement align√©es lorsqu'elles sont d√©clar√©es dans un tableau et l'exigence d'alignement des champs imbriqu√©s est satisfaite.  Pour garantir l'alignement, des octets de remplissage implicites sont ins√©r√©s dans les structures si n√©cessaire.  Bien qu'ils ne soient pas directement accessibles dans le code source, ces octets h√©ritent √©galement des anciennes valeurs des zones de m√©moire et peuvent transmettre des informations au mode utilisateur. </p><br><p>  Dans l'exemple du Listing 3, la structure SYSCALL_OUTPUT est renvoy√©e au code appelant.  Il contient des champs de 4 et 8 octets, s√©par√©s par 4 octets de remplissage, n√©cessaires pour que l'adresse du champ LargeSum devienne un multiple de 8.  Malgr√© le fait que les deux champs sont correctement initialis√©s, les octets de remplissage ne sont pas d√©finis explicitement, ce qui conduit √† nouveau √† l'expansion de la m√©moire de la pile du noyau.  L'emplacement sp√©cifique de la structure en m√©moire est illustr√© √† la figure 2. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SYSCALL_OUTPUT</span></span></span><span class="hljs-class"> {</span></span> DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; OutputStruct.LargeSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 3: √©tendre la m√©moire en alignant la structure.</em> </p><br><p><img src="https://habrastorage.org/webt/pw/i1/1a/pwi11anmkjf_ujlkogv2bjmbsuo.png" alt="Figure 2: alignement de la structure"><br>  Figure 2: Repr√©sentation de la structure en m√©moire avec alignement en t√™te. </p><br><p>  Les fuites par les alignements sont relativement courantes, car un grand nombre de param√®tres de sortie des appels syst√®me sont repr√©sent√©s par des structures.  Le probl√®me est particuli√®rement aigu pour les plates-formes 64 bits, o√π la taille des pointeurs, size_t et types similaires augmente de 4 √† 8 octets, ce qui entra√Æne l'apparition du remplissage n√©cessaire pour aligner les champs de ces structures. </p><br><p>  √âtant donn√© que les octets de remplissage ne peuvent pas √™tre adress√©s dans le code source, il est n√©cessaire d'utiliser memset ou une fonction similaire pour r√©initialiser toute la zone m√©moire de la structure avant d'initialiser l'un de ses champs et de le copier en mode utilisateur, par exemple: </p><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;OutputStruct, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(OutputStruct));</code> </pre> <br><p>  Cependant, Seacord RC dans son livre "The CERT C Coding Standard, Second Edition: 98 Rules for Developing Safe, Reliable, and Secure Systems. Addison-Wesley Professional" 2014 indique que ce n'est pas une solution id√©ale parce que les octets de remplissage ) peut encore √™tre <em>supprim√©</em> apr√®s avoir appel√© memset, par exemple, comme effet secondaire des op√©rations avec des champs adjacents.  La pr√©occupation peut √™tre justifi√©e par l'√©nonc√© suivant dans la sp√©cification C: </p><br><blockquote>  6.2.6 Repr√©sentations des types <br>  6.2.6.1 G√©n√©ral <br>  ... <br>  6 <u>Lorsqu'une valeur est stock√©e dans un objet de type structure ou union</u> , y compris dans un objet membre, les octets de la repr√©sentation d'objet qui correspondent √† <u>tout octet de remplissage prennent des valeurs non sp√©cifi√©es</u> .  [...] </blockquote><p>  Cependant, dans la pratique, aucun des compilateurs C que nous avons test√©s n'a lu ou √©crit en dehors des zones de m√©moire des champs explicitement d√©clar√©s.  Il semble que cette opinion soit partag√©e par les d√©veloppeurs de syst√®mes d'exploitation qui utilisent memset. </p><br><h4 id="obedineniya-unions-i-polya-raznogo-razmera">  Unions et champs de diff√©rentes tailles </h4><br><p>  Les jointures sont une autre construction complexe du langage C dans le contexte de la communication avec du code d'appel moins privil√©gi√©.  Consid√©rez comment la sp√©cification C11 d√©crit la repr√©sentation des unions en m√©moire: </p><br><blockquote>  6.2.5 Types <br>  ... <br>  20 Un certain nombre de types d√©riv√©s peuvent √™tre construits √† partir des types d'objet et de fonction, comme suit: [...] <u>Un type d'union d√©crit un ensemble non vide chevauchant d'objets membres</u> , chacun ayant un nom √©ventuellement sp√©cifi√© et un type √©ventuellement distinct. <br><br>  6.7.2.1 Structure et sp√©ci Ô¨Å cateurs d'union <br>  ... <br>  6 Comme indiqu√© au 6.2.5, une structure est un type compos√© d'une s√©quence de membres, dont le stockage est allou√© dans une s√©quence ordonn√©e, et <u>une union est un type compos√© d'une s√©quence de membres dont le stockage se chevauche</u> . <br>  ... <br>  16 <u>La taille d'un syndicat est suffisante pour contenir le plus grand de ses membres</u> .  La valeur d'au plus un des membres peut √™tre stock√©e √† tout moment dans un objet union. </blockquote><p>  Le probl√®me est que si l'union se compose de plusieurs champs de tailles diff√©rentes et qu'un seul champ de taille plus petite est explicitement initialis√©, les octets restants allou√©s pour prendre en charge les grands champs restent non initialis√©s.  Examinons un exemple de gestionnaire d'appels syst√®me hypoth√©tique, illustr√© dans le listing 4, ainsi que l'allocation de m√©moire d'union SYSCALL_OUTPUT illustr√©e dans la figure 3. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> _SYSCALL_OUTPUT { DWORD Sum; QWORD LargeSum; } SYSCALL_OUTPUT, *PSYSCALL_OUTPUT; <span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtSmallSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD InputValue, PSYSCALL_OUTPUT OutputPointer )</span></span></span><span class="hljs-function"> </span></span>{ SYSCALL_OUTPUT OutputStruct; OutputStruct.Sum = InputValue + <span class="hljs-number"><span class="hljs-number">2</span></span>; RtlCopyMemory(OutputPointer, &amp;OutputStruct, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SYSCALL_OUTPUT)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Exemple de code 4: √©tendre la m√©moire en initialisant partiellement une union.</em> </p><br><p><img src="https://habrastorage.org/webt/pa/8y/ck/pa8yckhciassiwm9yc19nssczwo.png" alt="Figure 3: aligneur une jointure"><br>  <em>Figure 3: Repr√©sentation de l'union en m√©moire avec alignement.</em> </p><br><p>  Il s'av√®re que la taille totale de l'union SYSCALL_OUTPUT est de 8 octets (en raison de la taille du plus grand champ LargeSum).  Cependant, la fonction d√©finit uniquement la valeur du champ plus petit, laissant 4 octets de fin non initialis√©s, ce qui entra√Æne par la suite une fuite vers leur application cliente. </p><br><p>  Une impl√©mentation s√©curis√©e doit uniquement d√©finir le champ Sum dans l'espace d'adressage utilisateur et ne pas copier l'int√©gralit√© de l'objet avec des zones de m√©moire potentiellement inutilis√©es.  Un autre correctif consiste √† appeler la fonction memset pour annuler une copie de l'union dans la m√©moire du noyau avant de d√©finir l'un de ses champs et de le retransf√©rer en mode utilisateur. </p><br><h4 id="nebezopasnyy-sizeof">  Taille dangereuse </h4><br><p>  Comme indiqu√© dans les deux sections pr√©c√©dentes, l'utilisation de l'op√©rateur sizeof peut contribuer directement ou indirectement √† r√©v√©ler la m√©moire du noyau, provoquant la copie de plus de donn√©es que pr√©c√©demment initialis√©es. </p><br><p>  C ne poss√®de pas l'appareil n√©cessaire pour transf√©rer en toute s√©curit√© des donn√©es du noyau vers l'espace utilisateur - ou, plus g√©n√©ralement, entre diff√©rents contextes de s√©curit√©.  Le langage ne contient pas de m√©tadonn√©es d'ex√©cution qui peuvent indiquer explicitement quels octets ont √©t√© d√©finis dans chaque structure de donn√©es utilis√©e pour interagir avec le noyau du syst√®me d'exploitation.  En cons√©quence, la responsabilit√© incombe au programmeur, qui doit d√©terminer quelles parties de chaque objet doivent √™tre transmises au code appelant.  Si cela est fait correctement, vous devez √©crire une fonction de copie s√©curis√©e distincte pour chaque structure de sortie utilis√©e dans les appels syst√®me.  Ce qui, √† son tour, entra√Ænera un gonflement de la taille du code, une d√©t√©rioration de sa lisibilit√© et, en g√©n√©ral, sera une t√¢che fastidieuse et longue. </p><br><p>  D'un autre c√¥t√©, il est pratique et simple de copier toute la zone m√©moire du noyau avec un seul appel memcpy et l'argument sizeof, et de laisser le client d√©terminer quelles parties de la sortie seront utilis√©es.  Il s'av√®re que cette approche est utilis√©e aujourd'hui sous Windows et Linux.  Et lorsqu'un cas sp√©cifique de fuite d'informations est d√©tect√©, un correctif avec un appel memset est imm√©diatement fourni et distribu√© par le fabricant du syst√®me d'exploitation.  Malheureusement, cela ne r√©sout pas le probl√®me dans le cas g√©n√©ral. </p><br><h2 id="specifika-konkretnyh-os">  Sp√©cificit√©s du syst√®me d'exploitation </h2><br><p>  Il existe certaines solutions de conception du noyau, m√©thodes de programmation et mod√®les de code qui affectent la vuln√©rabilit√© du syst√®me d'exploitation aux vuln√©rabilit√©s d'extension de m√©moire.  Ils sont examin√©s dans les sous-sections suivantes. </p><br><h4 id="pereispolzovanie-dinamicheskoy-pamyati">  R√©utilisation de la m√©moire dynamique </h4><br><p>  Les allocateurs actuels de m√©moire dynamique (en mode utilisateur et en mode noyau) sont hautement optimis√©s, car leurs performances ont un impact significatif sur les performances de l'ensemble du syst√®me.  L'une des optimisations les plus importantes est la r√©utilisation de la m√©moire: lorsqu'elle est lib√©r√©e, la m√©moire correspondante est rarement compl√®tement supprim√©e, mais elle est enregistr√©e dans la liste des r√©gions pr√™tes √† √™tre renvoy√©es la prochaine fois qu'elle est allou√©e.  Pour √©conomiser les cycles CPU, les zones de m√©moire par d√©faut ne sont pas effac√©es entre la d√©sallocation et la nouvelle allocation.  √Ä la suite de cela, il s'av√®re que deux parties non connect√©es du noyau fonctionnent avec la m√™me plage de m√©moire pendant une courte p√©riode.  Cela signifie que la fuite du contenu de la m√©moire dynamique du noyau vous permet de r√©v√©ler les donn√©es de divers composants du syst√®me d'exploitation. </p><br><p>  Dans les paragraphes suivants, nous donnons un bref aper√ßu des allocateurs utilis√©s dans les noyaux Windows et Linux, et leurs qualit√©s les plus remarquables. </p><br><p>  <strong>Windows</strong> <br>  La fonction cl√© du gestionnaire de pool de noyau Windows est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ExAllocatePoolWithTag</a> , qui peut √™tre appel√©e directement ou via l'un des shells disponibles: ExAllocatePool {‚àÖ, Ex, WithQuotaTag, WithTagPriority}.  Aucune de ces fonctions ne vide le contenu de la m√©moire retourn√©e, par d√©faut ou via des drapeaux d'entr√©e.  Au contraire, ils ont tous l'avertissement suivant dans leur documentation MSDN respective: </p><br><blockquote>  Remarque La m√©moire allou√©e par la fonction n'est pas initialis√©e.  Un pilote en mode noyau doit d'abord mettre √† z√©ro cette m√©moire s'il veut la rendre visible aux logiciels en mode utilisateur (pour √©viter de divulguer des contenus potentiellement privil√©gi√©s). </blockquote><p>  Le code appelant peut s√©lectionner l'un des six principaux types de pools: NonPagedPool, NonPagedPoolNx, NonPagedPoolSession, NonPagedPoolSessionNx, PagedPool et PagedPoolSession.  Chacun d'eux a une r√©gion distincte dans l'espace d'adressage virtuel, et donc les zones de m√©moire allou√©es ne peuvent √™tre r√©utilis√©es que dans le m√™me type de pool.  La fr√©quence de r√©utilisation des morceaux de m√©moire est tr√®s √©lev√©e et les zones mises √† z√©ro ne sont g√©n√©ralement renvoy√©es que si un enregistrement appropri√© n'est pas trouv√© dans les listes de c√¥t√© ou si la demande est si grande que de nouvelles pages de m√©moire sont n√©cessaires.  En d'autres termes, il n'existe actuellement pratiquement aucun facteur emp√™chant la divulgation de la m√©moire de pool dans Windows, et presque toutes ces erreurs peuvent √™tre utilis√©es pour divulguer des donn√©es sensibles √† partir de diff√©rentes parties du noyau. </p><br><p>  <strong>Linux</strong> <br>  Le noyau Linux poss√®de trois interfaces principales pour l'allocation dynamique de m√©moire: </p><br><ul><li>  <strong>kmalloc</strong> - une fonction commune utilis√©e pour allouer des blocs de m√©moire de taille arbitraire (continue dans l'espace d'adressage virtuel et physique), utilise l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">allocation de m√©moire de dalle</a> . </li><li>  <strong>kmem_cache_create</strong> et <strong>kmem_cache_alloc</strong> - un m√©canisme sp√©cialis√© pour allouer des objets de taille fixe (structures, par exemple), utilise √©galement l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">allocation de m√©moire de dalle</a> . </li><li>  <strong>vmalloc</strong> est une fonction d'allocation rarement utilis√©e qui renvoie des r√©gions dont la continuit√© n'est pas garantie au niveau de la m√©moire physique. </li></ul><br><p>  Ces fonctions (par elles-m√™mes) ne garantissent pas que les r√©gions s√©lectionn√©es ne contiendront pas d'anciennes donn√©es (potentiellement confidentielles), ce qui permet d'ouvrir la m√©moire du tas du noyau.  Cependant, le code appelant peut demander la m√©moire annul√©e de plusieurs mani√®res: </p><br><ul><li>  La fonction <strong>kmalloc</strong> a un analogue de <strong>kzalloc</strong> , ce qui garantit que la m√©moire retourn√©e est effac√©e. </li><li>  L'indicateur __GFP_ZERO facultatif peut √™tre transmis √† <strong>kmalloc</strong> , <strong>kmem_cache_alloc</strong> et √† d'autres fonctions pour obtenir le m√™me r√©sultat. </li><li>  <strong>kmem_cache_create</strong> accepte un pointeur sur une fonction constructeur optionnelle qui est appel√©e pour pr√©-initialiser chaque objet avant de le renvoyer au code appelant.  Le constructeur peut √™tre impl√©ment√© comme un wrapper autour d'un memset pour mettre √† z√©ro une zone de m√©moire donn√©e. </li></ul><br><p>  Nous consid√©rons la disponibilit√© de ces options comme des conditions favorables √† la s√©curit√© du noyau, car elles encouragent les d√©veloppeurs √† prendre des d√©cisions √©clair√©es et leur permettent de simplement travailler avec les fonctions d'allocation de m√©moire existantes au lieu d'ajouter des appels de memset suppl√©mentaires apr√®s chaque allocation de m√©moire dynamique. </p><br><h4 id="massivy-fiksirovannogo-razmera">  Tableaux de taille fixe </h4><br><p>  L'acc√®s √† un certain nombre de ressources OS peut √™tre obtenu par leurs noms de test.  La vari√©t√© des ressources nomm√©es dans Windows est tr√®s grande, par exemple: fichiers et r√©pertoires, cl√©s et valeurs des cl√©s de registre, fen√™tres, polices et bien plus encore.  Pour certains d'entre eux, la longueur du nom est limit√©e et est exprim√©e par une constante, telle que MAX_PATH (260) ou LF_FACESIZE (32).  Dans de tels cas, les d√©veloppeurs du noyau simplifient souvent le code en d√©clarant les tampons de taille maximale et en les copiant dans leur ensemble (par exemple, en utilisant le mot-cl√© sizeof) au lieu de travailler uniquement avec la partie correspondante de la ligne.  Cela est particuli√®rement utile si les cha√Ænes sont membres de structures plus grandes.  Ces objets peuvent √™tre d√©plac√©s librement dans la m√©moire sans se soucier de la gestion des pointeurs vers la m√©moire dynamique. </p><br><p>  Comme vous vous en doutez, les grands tampons sont rarement utilis√©s compl√®tement et l'espace de stockage restant n'est souvent pas vid√©.  Cela peut entra√Æner des fuites particuli√®rement graves de longues zones contigu√´s de m√©moire du noyau.  Dans l'exemple du Listing 5, l'appel syst√®me utilise la fonction RtlGetSystemPath pour charger le chemin syst√®me dans le tampon local, et si l'appel r√©ussit, les 260 octets sont transmis √† l'appelant, quelle que soit la longueur de ligne r√©elle. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtGetSystemPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PCHAR OutputPath)</span></span></span><span class="hljs-function"> </span></span>{ CHAR SystemPath[MAX_PATH]; NTSTATUS Status; Status = RtlGetSystemPath(SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(Status)) { RtlCopyMemory(OutputPath, SystemPath, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SystemPath)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre> <br><p>  <em>Listing 5: √©tendre la m√©moire en initialisant partiellement le tampon de cha√Æne.</em> </p><br><p>  La r√©gion de m√©moire copi√©e dans l'espace utilisateur dans cet exemple est illustr√©e √† la figure 4. </p><br><p><img src="https://habrastorage.org/webt/ki/8j/5z/ki8j5zyo73i5k4o12grlolwsrhk.png" alt="Figure 4: m√©moire tampon de cha√Æne partiellement initialis√©e"><br>  <em>Figure 4: M√©moire d'un tampon de ligne partiellement initialis√©.</em> </p><br><p>  Une impl√©mentation s√©curis√©e ne doit renvoyer que le chemin demand√© et non la totalit√© du tampon utilis√© pour le stockage.  Cet exemple montre une fois de plus comment l'estimation de la taille des donn√©es avec l'op√©rateur sizeof (utilis√© comme param√®tre pour RtlCopyMemory) peut √™tre compl√®tement incorrecte en ce qui concerne la quantit√© r√©elle de donn√©es que le noyau doit transmettre √† la zone utilisateur. </p><br><h4 id="proizvolnyy-razmer-vyhodnyh-dannyh-sistemnogo-vyzova">  Taille de sortie d'appel syst√®me arbitraire </h4><br><p>  La plupart des appels syst√®me acceptent des pointeurs vers la sortie en mode utilisateur ainsi que la taille du tampon.  Dans la plupart des cas, les informations de taille ne doivent √™tre utilis√©es que pour d√©terminer si le tampon fourni est suffisant pour recevoir la sortie d'appel syst√®me.  N'utilisez pas toute la taille du tampon de sortie fourni pour sp√©cifier la quantit√© de m√©moire √† copier.  Cependant, nous voyons des cas o√π le noyau essaiera d'utiliser chaque octet du tampon de sortie de l'utilisateur, sans compter la quantit√© de donn√©es r√©elles qui doivent √™tre copi√©es.  Un exemple de ce comportement est illustr√© dans le Listing 6. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NtMagicValues</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPDWORD OutputPointer, DWORD OutputLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OutputLength &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DWORD)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_BUFFER_TOO_SMALL; } LPDWORD KernelBuffer = Allocate(OutputLength); KernelBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xbadc0ffe</span></span>; KernelBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0xcafed00d</span></span>; RtlCopyMemory(OutputPointer, KernelBuffer, OutputLength); Free(KernelBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STATUS_SUCCESS; }</code> </pre> <br><p>  <em>Listing 6: √©tendre la m√©moire via un tampon de sortie de taille arbitraire.</em> </p><br><p>  Le but d'un appel syst√®me est de fournir au code appelant trois valeurs sp√©ciales de 32 bits, occupant un total de 12 octets.  Bien que la v√©rification de la taille de tampon correcte au tout d√©but de la fonction soit correcte, l'utilisation de l'argument OutputLength doit s'arr√™ter l√†.  Sachant que le tampon de sortie est suffisamment grand pour enregistrer le r√©sultat, le noyau peut allouer 12 octets de m√©moire, le remplir et copier le contenu dans le tampon en mode utilisateur fourni.  Au lieu de cela, un appel syst√®me alloue un bloc de pool (en outre, avec une longueur contr√¥l√©e par l'utilisateur) et copie toute la m√©moire allou√©e dans l'espace utilisateur.  Il s'av√®re que tous les octets, √† l'exception des 12 premiers, ne sont pas initialis√©s et sont ouverts par erreur √† l'utilisateur, comme le montre la figure 5. </p><br><p><img src="https://habrastorage.org/webt/m7/hy/dj/m7hydjfgkhaqgizxuhr2xcmv8jw.png" alt="Figure 5: M√©moire tampon arbitraire"><br>  <em>Figure 5: M√©moire tampon de taille arbitraire.</em> </p><br><p>  Le sch√©ma d√©crit dans cette section est particuli√®rement courant pour Windows.  Une erreur similaire peut fournir √† un attaquant une primitive extr√™mement utile pour l'extension de la m√©moire: </p><br><ul><li> ,      Windows,                  .            ,       . </li><li>              .   ,     ,                .      ,    (   ‚Äî  )  . </li></ul><br><p>  ,        .      ,     ,       . </p><br><h2 id="faktory-sposobstvuyuschie-poyavleniyu-oshibok-raskrytiya-pamyati"> ,      </h2><br><p>     ,           .         ,          Windows    . </p><br><p> <strong>  </strong> <br>  ,       ,   .        ,      : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AddressSanitizer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PageHeap</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Special Pool</a> .  , ,   -          .         ,         .   ,         ,       ,           ,        ,       .       <em></em>     ,      (   ). </p><br><p>  ,             ,  ,       .               ,                  . </p><br><p> <strong>,    API</strong> <br>           API,   Windows (Win32/User32 API). API         ,   ,          ,     .     ,  ,        , ,      .              <em></em>  . </p><br><h2 id="znachimost-i-vliyanie-na-bezopasnost-sistemy">       </h2><br><p>   ,             .          ,            .      ,     <em></em>       ,       ,      .        ,         ,    . </p><br><p>  ,      ,          .     ,       KASLR (Kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Address Space Layout Randomization</a> ),                .  :   Windows,    Hacking Team   2015  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Juan Vazquez. Revisiting an Info Leak</a> )         (derandomize)     win32k.sys,       . ,         Matt Tait'  Google Project Zero ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Kernel-mode ASLR leak via uninitialized memory returned to usermode by NtGdiGetTextMetrics</a> )     MS15-080 (CVE-2015-2433). </p><br><p> <strong></strong> <br>       (/)   ,      ,      (control Ô¨Çow),  :   ,   ,   ,   ,   StackGuard  Linux  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">/GS  Windows</a> .    ,             .        ,   ,            . </p><br><p> <strong>  (/)</strong> <br>    (/)    ,    ,      ,    :  ,   ,  ,     .               ,     ,      .         .  ,         ( ,    )   ,  ,      . </p><br><h2 id="drugie-suschestvuyuschie-issledovaniya">    </h2><br><p><img src="https://habrastorage.org/webt/wp/ky/ap/wpkyap5uiyz52hrghshrxxve1v0.jpeg" alt="KDPV # 2"></p><br><h4 id="microsoft-windows"> Microsoft Windows </h4><br><p> <strong></strong> <br>  2015            Windows.   2015  Matt Tait           win32k!NtGdiGetTextMetrics.          Windows   Hacking Team.   ,      ,       ,    0-day       Windows. </p><br><p>    2015, WanderingGlitch (HP Zero Day Initiative)          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Acknowledgments ‚Äì 2015</a> ).           Ruxcon 2016 (  )    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Leaking Windows Kernel Pointers"</a> . </p><br><p>  ,   2017 fanxiaocao  pjf  IceSword Lab (Qihoo 360)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Automatically Discovering Windows Kernel Information Leak Vulnerabilities"</a> ,    ,      14   2017  (8      ).        Bochspwn Reloaded,             ,            .        VMware     (Bochs)         .   ,  Bochspwn Reloaded,                . </p><br><p>         ,  ,    2010-2011          ,     win32k: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Challenge: On 32bit Windows7, explain where the upper 16bits of eax come from after a call to NtUserRegisterClassExWOW()"</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Subtle information disclosure in WIN32K.SYS syscall return values"</a> .          Windows 8,   2015  Matt Tait ,           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google Project Zero Bug Tracker</a> . </p><br><p> <strong></strong> <br>       (   ),  ,    2017   - Windows        -,   : Joseph Bialek ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Anyone notice my change to the Windows IO Manager to generically kill a class of info disclosure? BuÔ¨ÄeredIO output buÔ¨Äer is always zero'd"</a> .      ,  IOCTL-          . </p><br><p>        ,   Visual Studio 15.5   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">POD-</a> ,       "= {0}",   .       ,      padding- ()   . </p><br><h4 id="linux"> Linux </h4><br><p>    Windows,   Linux        ,         2010 .        ,             (  )   (    ) .  ,        Windows  Linux         ,        ‚Äî ,    . </p><br><p> <strong></strong> <br>    ,   Linux       .   "Linux kernel vulnerabilities: State-of-the-art defenses and open problems"   2010    2011   28    .   2017-  "Securing software systems by preventing information leaks" Lu K.    59  ,    2013-   2016-.          . : Rosenberg  Oberheide    25 ,     Linux  2009-2010 ,     .          Linux c <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PaX-hardened</a> . Vasiliy Kulikov   25   2010-2011 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   Coccinelle</a> .  , Mathias Krause <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   21      2013 </a>   50      . </p><br><p>    ,      ,           Linux.     ‚Äî   -Wuninitialized (  gcc,   LLVM),          .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  kmemcheck</a> ,      Valgrind'   .        ,        .         ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KernelAddressSANitizer</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KernelMemorySANitizer</a> .      KMSAN    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syzkaller</a> (   ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> 19    </a> ,        . </p><br><p>               Linux.  2014 ‚Äî 2016  Peir¬¥o      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Coccinelle</a>     ,      Linux  3.12: "Detecting stack based kernel information leaks" International Joint Conference SOCO14-CISIS14-ICEUTE14, pages 321‚Äì331 (Springer, 2014)  "An analysis on the impact and detection of kernel stack infoleaks" Logic Journal of the IGPL.         ,          .  2016- Lu       UniSan ‚Äî   ,    ,                 :   ,   .            ,        20%     (350   1800),      19     Linux  Android. </p><br><p>             ‚Äî    (multi-variant program execution),            ,      .           ,             .     ,  KASLR,   -,         .         ,  2006    DieHard: probabilistic memory safety for unsafe languages,   2017  ‚Äî BUDDY: Securing software systems by preventing information leaks.     John North   "Identifying Memory Address Disclosures" 2015- . ,  SafeInit (Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities)  ,          ,            .       , ,   ,        Linux. </p><br><p> <strong></strong> <br>                  ,   .      ,       :     ,        .     ,  , -    ,             .                   . </p><br><p>        CONFIG_PAGE_POISONING  CONFIG_DEBUG_SLAB,       -.       -,      .        , ,  ,       Linux. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grsecurity</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PaX</a>    .  ,   PAX_MEMORY_SANITIZE   ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">slab</a> ,    (        ‚Äî   ).  ,  PAX_MEMORY_STRUCTLEAK     ,    (  ),       .         padding- (),          100% .  ,      ‚Äî PAX_MEMORY_STACKLEAK,            .      ,      ,        .       (Kernel Self Protection Project)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> STACKLEAK</a>   . </p><br><p>               Linux: </p><br><div class="spoiler"> <b class="spoiler_title">Secure deallocation, Chow  , 2005</b> <div class="spoiler_text"><p> Chow, Jim and PfaÔ¨Ä, Ben and GarÔ¨Ånkel, Tal and Rosenblum, Mendel. Shredding Your Garbage: Reducing Data Lifetime Through Secure Deallocation. In USENIX Security Symposium, pages 22‚Äì22, 2005. </p></div></div><br><p>  ,       ,          ( )  .         Linux     . </p><br><div class="spoiler"> <b class="spoiler_title">Split Kernel, Kurmus  Zippel, 2014</b> <div class="spoiler_text"><p> Kurmus, Anil and Zippel, Robby. A tale of two kernels: Towards ending kernel hardening wars with split kernel. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 1366‚Äì1377. ACM, 2014. </p></div></div><br><p>      ,           . </p><br><div class="spoiler"> <b class="spoiler_title">SafeInit, Milburn  , 2017</b> <div class="spoiler_text"><p> Milburn, Alyssa and Bos, Herbert and GiuÔ¨Ärida, Cristiano. SafeInit: Comprehensive and Practical Mitigation of Uninitialized Read Vulnerabilities. In Proceedings of the 2017 Annual Network and Distributed System Security Symposium (NDSS)(San Diego, CA), 2017. </p></div></div><br><p>         ,      ,         . </p><br><div class="spoiler"> <b class="spoiler_title">UniSan, Lu  , 2016</b> <div class="spoiler_text"><p> Lu, Kangjie and Song, Chengyu and Kim, Taesoo and Lee, Wenke. UniSan: Proactive kernel memory initialization to eliminate data leakages. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 920‚Äì932. ACM, 2016. </p></div></div><br><p>    SafeInit         ,  ,       ,      ,      . </p><br><p>       ,  Linux             . </p><br><h2 id="vmesto-epiloga-ot-perevodchika">   ( ) </h2><br><p>        ,    ,          (      ).  :  (),     , ,    ,   ( - )     .   ,          . , ,        . </p><br><p>     ,             : </p><br><ul><li> Bochspwn Reloaded ‚Äì detection with software x86 emulation </li><li> Windows bug reproduction techniques </li><li> Alternative detection methods </li><li> Other data sinks </li><li> Future work </li><li> Other system instrumentation schemes </li></ul><br><p>  ,     :)          ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415685/">https://habr.com/ru/post/fr415685/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415675/index.html">R√©sum√© des nouvelles de PostgreSQL. Num√©ro 8</a></li>
<li><a href="../fr415677/index.html">Les villes en croissance ont du mal √† d√©placer les masses de personnes verticalement et en surface</a></li>
<li><a href="../fr415679/index.html">Pourquoi les enfants riches montrent de bons r√©sultats dans une exp√©rience de guimauve</a></li>
<li><a href="../fr415681/index.html">L'histoire de la cr√©ation de l'interpr√®te en langue des signes</a></li>
<li><a href="../fr415683/index.html">Essayez-vous dans la programmation Q #</a></li>
<li><a href="../fr415687/index.html">Fintech Digest: la Banque centrale oblige les banques √† v√©rifier les appareils clients √† partir desquels l'argent est transf√©r√©</a></li>
<li><a href="../fr415689/index.html">Nous jouons bataille navale sur BGP</a></li>
<li><a href="../fr415691/index.html">Comparaison de tri Exchange</a></li>
<li><a href="../fr415695/index.html">Google a admis qu'il voulait √©galement acheter GitHub</a></li>
<li><a href="../fr415699/index.html">Trois courtes histoires de registre Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>