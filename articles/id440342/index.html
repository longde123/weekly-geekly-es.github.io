<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏿 🐲 🗝️ Kode C # Universal untuk NET dan JavaScript 🕺 🕴🏽 👎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 2013, saat bekerja di layanan foto GFRANQ, saya berpartisipasi dalam pengembangan layanan web eponymous untuk penerbitan dan pemrosesan foto. Fil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kode C # Universal untuk NET dan JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440342/"><p>  Pada 2013, saat bekerja di layanan foto GFRANQ, saya berpartisipasi dalam pengembangan layanan web eponymous untuk penerbitan dan pemrosesan foto.  Filter dan transformasi didefinisikan dalam file dengan parameter, dan semua pemrosesan dilakukan di server.  Selama pengembangan layanan, ada kebutuhan untuk mendukung transformasi ini di sisi klien untuk pratinjau.  Menurut Larry Wall, salah satu keutamaan seorang programmer adalah kemalasan.  Oleh karena itu, sebagai pemrogram yang benar-benar malas, kami memikirkan kemungkinan menggunakan kode yang sama di sisi server dan klien.  Seluruh pengembangan dilakukan dalam C #.  Setelah meneliti perpustakaan dan beberapa upaya, kami dengan bangga menyimpulkan bahwa ini mungkin dan mulai menulis kode universal. </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ir/gs/y0/irgsy0wvrqkk5ybw0elxt5nagfk.png"></div><p></p><br><p> Mengapa artikel ini dibutuhkan?  Memang, 6 tahun telah berlalu sejak 2013, dan banyak teknologi telah kehilangan relevansinya, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Script #</a> .  Di sisi lain, yang baru telah muncul.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bridge.NET</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blazor</a> berdasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebAssembly yang</a> mewah. </p><br><p>  Meskipun demikian, beberapa ide masih bisa digunakan.  Pada artikel ini saya mencoba menggambarkannya sedetail mungkin.  Saya berharap bahwa penyebutan Silverlight dan Flash akan menyebabkan senyum dengan sedikit nostalgia, dan bukan keinginan untuk mengkritik solusi lama.  Lagi pula, mereka telah berkontribusi pada pengembangan industri web. </p><a name="habracut"></a><br><h2 id="contents">  Isi </h2><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tujuan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deskripsi filter</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deskripsi kolase</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memilih Platform untuk Pemrosesan Foto</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerjemahkan C # ke dalam Javascript</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keuntungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kekurangan</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan alias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke File</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catatan tentang Implementasi .NET</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gunakan buang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan kunci</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyimpan topeng di memori</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Catatan tentang Implementasi JavaScript</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minifikasi</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minifikasi manual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minifikasi Otomatis</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mode Debug dan Rilis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Properti crossOrigin</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Optimalisasi</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Nilai yang Dihitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengubah Gambar menjadi Array Piksel</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh Kode</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jenderal</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendeteksi Apakah Suatu String Adalah Angka</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Divisi integer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memutar dan Memutar Gambar Menggunakan Canvas dan Bitmap</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memuat Gambar Sinkron dan Asinkron</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hanya Skrip #</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mendeteksi Jenis dan Versi Peramban</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering Garis Dash-dot</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Animasi rotasi</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> </li></ul><br><br><h2 id="goal">  Tujuan </h2><br><p>  Tantangannya adalah untuk mengimplementasikan kolase foto dan fungsionalitas pengeditan foto berbasis filter pada sisi klien dan, jika mungkin, pada sisi server juga.  Sebagai permulaan, saya akan membahas bagaimana filter dan kolase diimplementasikan. </p><br><h3 id="description-of-filters">  Deskripsi filter </h3><br><p>  Dalam konteks proyek kami, <strong>filter</strong> adalah serangkaian tindakan yang dilakukan dalam Photoshop dan diterapkan pada foto tertentu.  Berikut adalah contoh tindakan tersebut: </p><br><ul><li>  Penyesuaian kecerahan </li><li>  Penyesuaian kontras </li><li>  Penyesuaian saturasi </li><li>  Penyesuaian kurva warna </li><li>  Masking dalam mode yang berbeda </li><li>  Membingkai </li><li>  ... </li></ul><br><p>  Kami membutuhkan format tertentu untuk menggambarkan tindakan ini.  Tentu, ada format umum seperti JSON dan XML, tetapi diputuskan untuk membuat format sendiri karena alasan berikut: </p><br><ul><li>  Perlu arsitektur kode platform-independen (.NET, JavaScript, WinPhone, dll.) </li><li>  Perlu format filter non-hierarkis yang sederhana, yang membuatnya mudah untuk menulis parser </li><li>  Data XML dan JSON lebih banyak memakan memori (dalam kasus khusus ini) </li></ul><br><p>  Berikut ini urutan tindakan untuk filter <strong>Film XPro</strong> : </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y_/oy/ad/y_oyadt7qubbsa9an37h32ostqs.png"></div><br><p>  Selain mengedit foto dengan filter, kami perlu memotong dan memutar gambar.  Ya, saya tahu bahwa ada plugin jQuery untuk memotong dan memutar gambar, tetapi tampaknya kelebihan beban dan menyimpang dari arsitektur universal proyek. </p><br><h3 id="description-of-collages">  Deskripsi kolase </h3><br><p>  <strong>Kolase</strong> adalah susunan beberapa foto mini ke dalam satu foto utuh (dengan atau tanpa menggunakan topeng).  Itu juga diperlukan untuk memungkinkan pengguna untuk menarik dan melepaskan gambar yang tersedia ke kolase, mengubah posisi dan skala mereka.  Kolase Anda mungkin terlihat seperti ini: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/250/1f8/0842501f87761a3c128b5f117719b10c.jpg"></div><br><p> Fitur kolase menyiratkan menggunakan format sederhana untuk menyimpan persegi panjang dengan koordinat relatif dari <code>0</code> hingga <code>1</code> , alamat foto, dan data modifikasi gambar.  Koordinat relatif digunakan karena transformasi sisi klien yang sama diterapkan ke gambar ukuran besar di sisi server. </p><br><h2 id="implementation">  Implementasi </h2><br><p>  Kami harus memilih platform yang memungkinkan pengguna bekerja dengan filter dan kolase </p><br><h3 id="choosing-a-platform-for-photo-processing">  Memilih Platform untuk Pemrosesan Foto </h3><br><p>  Ada beberapa teknologi Rich Internet Application ( <strong>RIA</strong> ) seperti: </p><br><ul><li>  Adobe flash </li><li>  Microsoft silverlight </li><li>  HTML 5 + JavaScript </li><li>  Klien asli </li></ul><br><p>  Untuk alasan yang jelas, Flash dan HTML adalah satu-satunya teknologi yang pantas mendapat perhatian karena sisanya tidak kompatibel lintas platform.  Selanjutnya, klien Silverlight mulai mati.  Meskipun saya sangat suka konsep <del>  garam </del>  NaCl, sayangnya, teknologi ini hanya didukung oleh browser Chrome dan belum diketahui kapan akan didukung (dan apakah akan pernah didukung) oleh browser populer lainnya.  <em>Catatan dari 2019: itu akan dan namanya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WebAssembly</a> .</em> </p><br><p>  Pilihan ini dibuat untuk mendukung platform HTML5 yang trendi dan progresif, yang fungsinya saat ini didukung oleh iOS, berbeda dengan Flash.  Pilihan ini juga didasarkan pada kenyataan bahwa ada banyak perpustakaan, yang memungkinkan Anda untuk mengkompilasi kode C # ke dalam Javascript.  Anda juga dapat menggunakan Visual Studio untuk tujuan ini.  Detail diberikan di bawah ini. </p><br><h3 id="translating-c-into-javascript">  Menerjemahkan C # ke dalam Javascript </h3><br><p>  HTML 5 + JavaScript telah dipilih sebagai platform di bagian sebelumnya.  Jadi itu meninggalkan kita pertanyaan, apakah mungkin untuk menulis kode C # universal yang dapat dikompilasi untuk .NET dan JavaScript. </p><br><p>  Dengan demikian, sejumlah perpustakaan untuk menyelesaikan tugas ditemukan: </p><br><ul><li>  Jsil </li><li>  Sharpkit </li><li>  Skrip # </li><li>  Dan beberapa lainnya tersedia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GitHub</a> . </li></ul><br><p>  Akibatnya, diputuskan untuk menggunakan <strong>Script #</strong> karena fakta bahwa JSIL bekerja langsung dengan majelis dan menghasilkan kode yang kurang murni (meskipun mendukung berbagai fitur bahasa C # yang lebih luas) dan SharpKit adalah produk komersial.  Untuk perbandingan terinci dari alat-alat ini, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertanyaan tentang stackoverflow</a> . </p><br><p>  Singkatnya, ScriptSharp dibandingkan dengan JavaScript yang ditulis secara manual memiliki pro dan kontra berikut: </p><br><h4 id="advantages">  Keuntungan </h4><br><ul><li>  Kemungkinan untuk menulis kode C # universal yang dapat dikompilasi ke .NET dan platform lainnya (WinPhone, Mono) </li><li>  Pengembangan bahasa C # yang sangat diketik mendukung OOP </li><li>  Dukungan untuk fitur IDE (pelengkapan otomatis dan refactoring) </li><li>  Kemampuan untuk mendeteksi sebagian besar kesalahan pada tahap kompilasi </li></ul><br><h4 id="disadvantages">  Kekurangan </h4><br><ul><li>  Redundansi dan penyimpangan kode JavaScript yang dihasilkan (karena mscorlib). </li><li>  Dukungan hanya untuk ISO-2 (tidak ada kelebihan fungsi atau tipe, ekstensi, dan inferensi generik) </li></ul><br><h3 id="structure">  Struktur </h3><br><p>  Proses kompilasi kode C # yang sama ke dalam .NET dan Javascript dapat diilustrasikan dengan skema berikut: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/8ba/bce/32c/8babce32c532d3b3954cdabebabb0e06.png" width="70%" alt="Terjemahan C # ke Skema .NET &amp; JavaScript"></div><br><p>  Meskipun .NET dan HTML5 adalah teknologi yang sama sekali berbeda, mereka juga memiliki fitur serupa.  Ini juga berlaku untuk bekerja dengan grafik.  Misalnya, .NET mendukung <strong>Bitmap</strong> , JavaScript mendukung analognya - <strong>Kanvas</strong> .  Hal yang sama berlaku dengan <strong>Grafik</strong> , <strong>Konteks</strong> , dan array piksel.  Untuk menggabungkan semuanya dalam satu kode, diputuskan untuk mengembangkan arsitektur berikut: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/89c/427/74c/89c42774cf90bdc873a0c34619cf7207.png" width="50%" alt="Konteks Umum .NET &amp; JavaScript Graphics"></div><br><p>  Tentu saja, ini tidak terbatas pada dua platform.  Sebagai tindak lanjut direncanakan untuk menambahkan dukungan untuk WinPhone, dan kemudian, mungkin, Android dan iOS. </p><br><p>  Perlu dicatat bahwa ada dua jenis operasi grafis: </p><br><ul><li>  <strong>Menggunakan fungsi API</strong> ( <code>DrawImage</code> , <code>Arc</code> , <code>MoveTo</code> , <code>LineTo</code> ).  Kinerja tinggi dan dukungan untuk akselerasi perangkat keras adalah keunggulan kompetitif yang penting.  Kekurangannya adalah mereka dapat diimplementasikan secara berbeda pada platform yang berbeda. </li><li>  <strong>Pixel demi pixel.</strong>  Dukungan untuk implementasi segala efek dan cakupan lintas platform adalah di antara manfaatnya.  Kerugiannya adalah kinerja yang rendah.  Namun, Anda dapat mengurangi kerugian dengan paralelisasi, shader, dan tabel yang dihitung sebelumnya (kami akan membahasnya lebih lanjut di bagian selanjutnya tentang pengoptimalan). </li></ul><br><p>  Seperti yang dapat Anda lihat, <strong>Grafik</strong> kelas abstrak menjelaskan semua metode untuk bekerja dengan grafik;  metode ini diimplementasikan untuk berbagai platform di kelas turunan.  Alias ​​berikut ditulis untuk abstrak dari Bitmap dan kelas Canvas juga.  Versi WinPhone juga menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pola adaptor</a> . </p><br><h4 id="using-alias">  Menggunakan alias </h4><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP using System.Html; using System.Html.Media.Graphics; using System.Runtime.CompilerServices; using Bitmap = System.Html.CanvasElement; using Graphics = System.Html.Media.Graphics.CanvasContext2D; using ImageData = System.Html.Media.Graphics.ImageData; using Image = System.Html.ImageElement; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET using System.Drawing; using System.Drawing.Imaging; using System.Drawing.Drawing2D; using Bitmap = System.Drawing.Bitmap; using Graphics = System.Drawing.Graphics; using ImageData = System.Drawing.Imaging.BitmapData; using Image = System.Drawing.Bitmap; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Sayangnya, tidak mungkin untuk membuat alias untuk tipe dan array yang tidak aman, dengan kata lain, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alias ​​to pointer (byte *) di C #</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PixelArray = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*, <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PixelArray = <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]</code> </pre> <br><p>  Untuk melakukan pemrosesan piksel yang cepat menggunakan kode C # yang tidak dikelola, sementara pada saat yang sama mengkompilasinya ke Script #, kami memperkenalkan skema berikut dengan bantuan arahan: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP PixelArray data = context.GetPixelArray(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET byte* data = context.GetPixelArray(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Array <code>data</code> selanjutnya digunakan untuk mengimplementasikan berbagai operasi pixel demi pixel (seperti masking, fisheye, penyesuaian saturasi, dan sebagainya), baik secara paralel maupun tidak. </p><br><h4 id="links-to-files">  Tautan ke File </h4><br><p>  Proyek terpisah ditambahkan ke solusi untuk setiap platform, tetapi, tentu saja, Mono, Script #, dan bahkan Silverlight tidak dapat merujuk ke rakitan .NET yang biasa.  Untungnya, Visual Studio memiliki mekanisme untuk menambahkan tautan ke file, yang memungkinkan Anda untuk menggunakan kembali kode yang sama di berbagai proyek. </p><br><p>  Arahan <code>DOTNET</code> ( <code>DOTNET</code> , <code>SCRIPTSHARP</code> ) didefinisikan dalam properti proyek dalam Simbol Kompilasi Bersyarat. </p><br><h3 id="notes-on-net-implementation">  Catatan tentang Implementasi .NET </h3><br><p>  Abstraksi dan alias di atas membantu kami untuk menulis kode C # dengan redundansi yang rendah.  Selanjutnya, saya ingin menunjukkan masalah dengan platform .NET dan JavaScript yang kami hadapi ketika mengembangkan kode solusi. </p><br><h4 id="using-dispose">  Gunakan buang </h4><br><p>  Harap dicatat bahwa penyertaan instance dari kelas C #, yang mengimplementasikan antarmuka <code>IDisposable</code> , memerlukan pemanggilan metode <strong><code>Dispose</code></strong> atau terapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pernyataan Menggunakan</a> .  Dalam proyek ini, kelas-kelas ini adalah Bitmap dan Konteks.  Apa yang saya katakan di atas bukan hanya teori, itu sebenarnya memiliki aplikasi praktis: Memproses sejumlah besar foto ukuran besar (hingga 2400 x 2400 dpi) di ASP.NET Developer Server x86 menghasilkan pengecualian memori.  Masalah ini diselesaikan setelah menambahkan <code>Dispose</code> di tempat yang tepat.  Beberapa saran bermanfaat lainnya tentang manipulasi gambar diberikan dalam artikel berikut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">20 Kesalahan Pengubahan Ukuran Gambar</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.NET Memory Leak: Untuk membuang atau tidak membuang, itulah pertanyaan 1 GB</a> . </p><br><h4 id="using-lock">  Menggunakan kunci </h4><br><p>  Dalam JavaScript, ada perbedaan antara gambar yang sudah diunggah dengan tag <code>img</code> , yang <code>img</code> Anda dapat menentukan sumber dan acara pemuatan, dan kanvas yang ditandai <code>canvas</code> , di mana Anda dapat menggambar sesuatu.  Dalam .NET elemen-elemen ini diwakili oleh kelas <code>Bitmap</code> sama.  Dengan demikian, alias Bitmap dan Gambar di .NET menunjuk ke kelas yang sama <code>System.Drawing.Bitmap</code> . Bitmap seperti yang ditunjukkan di atas. </p><br><p>  Namun demikian, pemisahan ini menjadi <code>img</code> dan <code>canvas</code> dalam JavaScript juga sangat membantu dalam versi .NET.  Intinya adalah bahwa filter menggunakan topeng preloaded dari utas yang berbeda;  dengan demikian, pola <strong>kunci</strong> diperlukan untuk menghindari pengecualian selama sinkronisasi (gambar disalin dengan <strong>kunci</strong> dan hasilnya digunakan tanpa mengunci): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloneImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Image image</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP Bitmap result = (Bitmap)Document.CreateElement("canvas"); result.Width = image.Width; result.Height = image.Height; Graphics context = (Graphics)result.GetContext(Rendering.Render2D); context.DrawImage(image, 0, 0); return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> Bitmap result; lock (image) result = new Bitmap(image); return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><p>  Bagaimanapun, <strong>kunci</strong> juga harus digunakan ketika mengakses properti dari objek yang disinkronkan (Faktanya, semua properti adalah metode). </p><br><h4 id="storing-masks-in-memory">  Menyimpan topeng di memori </h4><br><p>  Untuk mempercepat pemrosesan, semua masker yang berpotensi digunakan untuk filter dimuat ke dalam memori ketika server dimulai.  Apa pun format topengnya, Bitmap yang diunggah ke server menggunakan <code>4 * 2400 * 2400</code> atau <code>≈24 MB</code> memori (ukuran gambar maksimum adalah <code>2400 * 2400</code> ; jumlah byte per piksel adalah 4).  Semua masker untuk filter (≈30) dan kolase (40) akan mengkonsumsi 1,5 GB - itu tidak banyak untuk server;  Namun, seiring dengan meningkatnya jumlah topeng, jumlah ini dapat meningkat secara signifikan.  Di masa mendatang, kami mungkin akan menggunakan teknik kompresi untuk masker yang disimpan dalam memori (dalam format .jpg dan .png) diikuti dengan dekompresi bila perlu.  Sebenarnya ukurannya bisa dikurangi hingga 300 kali lipat.  Keuntungan tambahan dari pendekatan ini adalah bahwa penyalinan gambar terkompresi berjalan lebih cepat dibandingkan dengan yang besar;  dengan demikian, operasi <strong>kunci</strong> akan memakan waktu lebih sedikit dan utas akan diblokir lebih jarang. </p><br><h3 id="notes-on-javascript-implementation">  Catatan tentang Implementasi JavaScript </h3><br><h4 id="minification">  Minifikasi </h4><br><p>  Saya menolak untuk menggunakan istilah "kebingungan" karena alasan berikut: istilah ini hampir tidak berlaku untuk bahasa open-source sepenuhnya, yang dalam kasus kami adalah JavaScript.  Namun, penganoniman pengidentifikasi dapat mengacaukan keterbacaan kode dan logika.  Dan yang paling penting, teknik ini akan secara signifikan mengurangi ukuran skrip (versi terkompresi adalah ≈80 KB). </p><br><p>  Ada dua pendekatan untuk minifikasi JavaScript: </p><br><ul><li>  <strong>Minifikasi manual,</strong> yang dilakukan pada tahap generasi menggunakan ScriptSharp. </li><li>  <strong>Pengotomatisasi otomatis,</strong> yang dilakukan setelah tahap pembuatan menggunakan alat eksternal seperti Google Closure Compiler, Yui dan alat lainnya. </li></ul><br><h5 id="manual-minification">  Minifikasi manual </h5><br><p>  Untuk mempersingkat nama metode, kelas, dan atribut kami menggunakan sintaks ini sebelum deklarasi entitas yang disebutkan di atas.  Tentu saja, tidak perlu melakukan itu jika Anda bekerja dengan metode yang dipanggil dari skrip dan kelas eksternal (publik). </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP &amp;&amp; !DEBUG [ScriptName("a0")] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><p>  Bagaimanapun, variabel lokal tidak dapat dikecilkan.  Ini membangun mencemari kode dan merusak keterbacaan kode, yang juga merupakan kerugian serius.  Namun, teknik ini dapat secara signifikan mengurangi jumlah kode JavaScript yang dihasilkan dan mengacaukannya juga. </p><br><p>  Kerugian lain adalah bahwa Anda perlu mengawasi nama-nama pendek seperti itu jika mereka mengganti nama metode dan nama bidang (terutama, nama-nama yang diganti dalam kelas anak) karena dalam kasus ini Skrip # tidak akan peduli dengan nama berulang.  Namun, itu tidak akan mengizinkan kelas digandakan. </p><br><p>  Omong-omong, fungsi minifikasi untuk metode dan bidang pribadi dan internal sudah ditambahkan ke versi Script # yang dikembangkan. </p><br><h5 id="automated-minification">  Minifikasi Otomatis </h5><br><p>  Meskipun ada banyak alat untuk minifikasi JavaScript, saya menggunakan Google Closure Compiler untuk mereknya dan kualitas kompresi yang baik.  Kerugian dari alat minifikasi Google adalah tidak dapat memampatkan file CSS;  sebaliknya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YUI</a> berhasil mengatasi tantangan ini.  Bahkan, Skrip # juga dapat memperkecil skrip tetapi menangani tantangan ini jauh lebih buruk daripada Google Penutupan. </p><br><p>  Alat minifikasi Google memiliki beberapa tingkat kompresi: spasi putih, sederhana, dan canggih.  Kami telah memilih level Sederhana untuk proyek;  meskipun, tingkat Mahir memungkinkan kita untuk mencapai kualitas kompresi maksimum, itu memerlukan kode yang ditulis sedemikian rupa sehingga metode dapat diakses dari luar kelas.  Pengecilan ini sebagian dilakukan secara manual menggunakan Script #. </p><br><h4 id="debug-and-release-modes">  Mode Debug dan Rilis </h4><br><p>  Perpustakaan Debug dan Rilis ditambahkan ke halaman ASP.NET sebagai berikut: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Gfranq.JavaScriptFilters.HtmlHelper.IsDebug</span></span></span><span class="hljs-tag">) { %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/mscorlib.debug.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/imgProcLib.debug.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> } </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span><span class="hljs-tag"> { %&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/mscorlib.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Scripts/imgProcLib.js"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">%</span></span></span><span class="hljs-tag"> } %&gt;</span></span></code> </pre> <br><p>  Dalam proyek ini, kami meminimalkan skrip dan memfilter file deskripsi. </p><br><h4 id="crossorigin-property">  Properti crossOrigin </h4><br><p>  Untuk mengakses piksel beberapa gambar tertentu, kita perlu mengubahnya menjadi kanvas terlebih dahulu.  Tetapi ini dapat menyebabkan kesalahan Cross Origin Request Security (CORS).  Dalam kasus kami, masalahnya diselesaikan sebagai berikut: </p><br><ul><li>  Mengatur <code>crossOrigin = ''</code> di sisi server. </li><li>  Menambahkan header spesifik ke paket HTTP di sisi server. </li></ul><br><p>  Karena ScriptSharp tidak mendukung properti ini untuk elemen img, kode berikut ditulis: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Imported</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AdvImage</span></span> { [IntrinsicProperty] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> CrossOrigin { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { } } }</code> </pre> <br><p>  Lalu, kita akan menggunakannya seperti ini: </p><br><pre> <code class="plaintext hljs">((AdvImage)(object)result).CrossOrigin = "";</code> </pre> <br><p>  Teknik ini memungkinkan Anda untuk menambahkan fitur apa pun ke objek tanpa kesalahan kompilasi.  Khususnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti <code>wheelDelta</code> belum diimplementasikan</a> di ScriptSharp (setidaknya dalam versi 0.7.5).  Properti ini menunjukkan jumlah roda gulir, yang digunakan untuk membuat kolase.  Itu sebabnya diimplementasikan dengan cara ini.  Retas kotor dengan properti seperti itu tidak baik;  biasanya, Anda perlu melakukan perubahan pada proyek.  Tetapi hanya sebagai catatan, saya belum menemukan cara untuk mengkompilasi ScriptSharp dari sumber. </p><br><p>  Gambar tersebut mengharuskan server untuk mengembalikan header berikut dalam header responsnya (di Global.asax): </p><br><pre> <code class="cs hljs">Response.AppendHeader(<span class="hljs-string"><span class="hljs-string">"Access-Control-Allow-Origin"</span></span>, <span class="hljs-string"><span class="hljs-string">"\*"</span></span>);</code> </pre> <br><p>  Untuk informasi lebih lanjut tentang Cross Origin Request Security, kunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://enable-cors.org/</a> . </p><br><h3 id="optimizations">  Optimalisasi </h3><br><h4 id="using-the-precalculated-values">  Menggunakan Nilai yang Dihitung </h4><br><p>  Kami menggunakan optimasi untuk beberapa operasi seperti penyesuaian kecerahan, kontras, dan kurva warna melalui perhitungan awal komponen warna yang dihasilkan (r, g, b) untuk semua nilai yang mungkin dan penggunaan lebih lanjut dari array yang diperoleh untuk mengubah warna piksel secara langsung .  Perlu dicatat bahwa optimasi semacam ini hanya cocok untuk operasi di mana warna piksel yang dihasilkan tidak terpengaruh oleh piksel yang berdekatan. </p><br><p>  Perhitungan komponen warna yang dihasilkan untuk semua nilai yang mungkin: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>; i++) { r[i] = ActionFuncR(i); g[i] = ActionFuncG(i); b[i] = ActionFuncB(i); }</code> </pre> <br><p>  Penggunaan komponen warna yang dihitung sebelumnya: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; data.Length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { data[i] = r[data[i]]; data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = g[data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]]; data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = b[data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>]]; }</code> </pre> <br><p>  Jika operasi tabel seperti itu berjalan satu per satu, maka tidak perlu menghitung gambar antara - Anda hanya dapat melewati array komponen warna.  Karena kode bekerja cukup cepat pada sisi klien dan sisi server, diputuskan untuk mengesampingkan penerapan optimasi ini.  Selain itu, optimasi menyebabkan beberapa perilaku yang tidak diinginkan.  Namun, saya akan memberi Anda daftar optimasi: </p><br><table><tbody><tr><td>  Kode asli </td><td>  Kode yang dioptimalkan </td></tr><tr><td>  `` `cs <br>  // Perhitungan nilai untuk tabel pertama. <br>  untuk (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc1R (i); <br>  g [i] = ActionFunc1G (i); <br>  b [i] = ActionFunc1B (i); <br>  } <br>  // ... <br><br>  // Perhitungan gambar perantara yang dihasilkan. <br>  untuk (int i = 0; i &lt;data.Panjang; i + = 4) <br>  { <br>  data [i] = r [data [i]]; <br>  data [i + 1] = g [data [i + 1]]; <br>  data [i + 2] = b [data [i + 2]]; <br>  } <br>  // ... <br><br>  // Perhitungan nilai untuk tabel kedua. <br>  untuk (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc2R (i); <br>  g [i] = ActionFunc2G (i); <br>  b [i] = ActionFunc2B (i); <br>  } <br>  // ... <br><br>  // Perhitungan gambar yang dihasilkan. <br>  untuk (int i = 0; i &lt;data.Panjang; i + = 4) <br>  { <br>  data [i] = r [data [i]]; <br>  data [i + 1] = g [data [i + 1]]; <br>  data [i + 2] = b [data [i + 2]]; <br>  } <br>  `` `` <br><br></td><td>  `` `cs <br>  // Perhitungan nilai untuk tabel pertama. <br>  untuk (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = ActionFunc1R (i); <br>  g [i] = ActionFunc1G (i); <br>  b [i] = ActionFunc1B (i); <br>  } <br>  // ... <br><br>  // Perhitungan nilai untuk tabel kedua. <br>  tr = r.Clone (); <br>  tg = g.Clone (); <br>  tb = b.Clone (); <br>  untuk (int i = 0; i &lt;256; i ++) <br>  { <br>  r [i] = tr [ActionFunc2R (i)]; <br>  g [i] = tg [ActionFunc2G (i)]; <br>  b [i] = tb [ActionFunc2B (i)]; <br>  } <br>  // ... <br><br>  // Perhitungan gambar yang dihasilkan. <br>  untuk (int i = 0; i &lt;data.Panjang; i + = 4) <br>  { <br>  data [i] = r [data [i]]; <br>  data [i + 1] = g [data [i + 1]]; <br>  data [i + 2] = b [data [i + 2]]; <br>  } <br>  `` `` <br><br></td></tr></tbody></table><br><p>  Tetapi inipun belum semuanya.  Jika Anda melihat tabel di sebelah kanan, Anda akan melihat bahwa array baru dibuat menggunakan metode <code>Clone</code> .  Sebenarnya, Anda bisa mengubah pointer ke array lama dan baru alih-alih menyalin array itu sendiri (ini mengingat analogi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buffering ganda</a> ). </p><br><h4 id="converting-an-image-to-an-array-of-pixels">  Mengubah Gambar menjadi Array Piksel </h4><br><p>  Profiler JavaScript di Google Chrome mengungkapkan bahwa fungsi <code>GetImageData</code> (yang digunakan untuk mengubah kanvas ke array piksel) berjalan cukup lama.  Informasi ini, omong-omong, dapat ditemukan di berbagai artikel tentang pengoptimalan kanvas dalam JavaScript. </p><br><p>  Namun, jumlah panggilan fungsi ini dapat diminimalkan.  Yaitu, kita dapat menggunakan array piksel yang sama untuk operasi piksel demi piksel, dengan analogi dengan pengoptimalan sebelumnya. </p><br><h2 id="code-examples">  Contoh Kode </h2><br><p>  Dalam contoh di bawah ini, saya akan memberikan fragmen kode yang menurut saya menarik dan bermanfaat.  Agar artikelnya tidak terlalu panjang, saya telah menyembunyikan contoh di bawah spoiler. </p><br><h3 id="general">  Jenderal </h3><br><h4 id="detecting-whether-a-string-is-a-number">  Mendeteksi Apakah Suatu String Adalah Angka </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsNumeric</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !SCRIPTSHARP return ((Number)int.Parse(n)).ToString() != "NaN"; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> double number; return double.TryParse(n, out number); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br><h4 id="integer-division">  Divisi integer </h4><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = n / k; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP result = Math.Floor(n / k); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return result; }</span></span></code> </pre> <br><h4 id="rotating-and-flipping-an-image-using-canvas-and-bitmap">  Memutar dan Memutar Gambar Menggunakan Canvas dan Bitmap </h4><br><p>  Harap dicatat bahwa dalam kanvas html5 gambar dapat diputar 90 dan 180 derajat hanya menggunakan matriks, sementara .NET menyediakan fungsionalitas yang ditingkatkan.  Dengan demikian, fungsi presisi yang tepat untuk bekerja dengan piksel ditulis. </p><br><p>  Perlu dicatat juga bahwa rotasi sisi 90 derajat dalam versi .NET dapat memberikan hasil yang salah.  Karena itu, Anda perlu membuat <code>Bitmap</code> baru setelah menggunakan fungsi <code>RotateFlip</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateFlip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap, RotFlipType rotFlipType</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP int t, i4, j4, w, h, c; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.RotateNoneFlipNone) return bitmap; GraphicsContext context; PixelArray data; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.RotateNoneFlipX) { context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = bitmap.Width; h = bitmap.Height; for (int i = 0; i &lt; h; i++) { c = (i + 1) * w * 4 - 4; for (int j = 0; j &lt; w / 2; j++) { i4 = (i * w + j) * 4; j4 = j * 4; t = (int)data[i4]; data[i4] = data[c - j4]; data[c - j4] = t; t = (int)data[i4 + 1]; data[i4 + 1] = data[c - j4 + 1]; data[c - j4 + 1] = t; t = (int)data[i4 + 2]; data[i4 + 2] = data[c - j4 + 2]; data[c - j4 + 2] = t; t = (int)data[i4 + 3]; data[i4 + 3] = data[c - j4 + 3]; data[c - j4 + 3] = t; } } context.PutImageData(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate180FlipNone || rotFlipType == RotFlipType.Rotate180FlipX) { context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = bitmap.Width; h = bitmap.Height; c = w * 4 - 4; int dlength4 = data.Length - 4; for (int i = 0; i &lt; data.Length / 4 / 2; i++) { i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate180FlipNone) j4 = i4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> j4 = (Math.Truncate((double)i / w) * w + (w - i % w)) * 4; t = (int)data[j4]; data[j4] = data[dlength4 - i4]; data[dlength4 - i4] = t; t = (int)data[j4 + 1]; data[j4 + 1] = data[dlength4 - i4 + 1]; data[dlength4 - i4 + 1] = t; t = (int)data[j4 + 2]; data[j4 + 2] = data[dlength4 - i4 + 2]; data[dlength4 - i4 + 2] = t; t = (int)data[j4 + 3]; data[j4 + 3] = data[dlength4 - i4 + 3]; data[dlength4 - i4 + 3] = t; } context.PutImageData(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { Bitmap tempBitmap = PrivateUtils.CreateCloneBitmap(bitmap); GraphicsContext tempContext = GraphicsContext.GetContext(tempBitmap); PixelArray temp = tempContext.GetPixelArray(); t = bitmap.Width; bitmap.Width = bitmap.Height; bitmap.Height = t; context = GraphicsContext.GetContext(bitmap); data = context.GetPixelArray(); w = tempBitmap.Width; h = tempBitmap.Height; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate90FlipNone || rotFlipType == RotFlipType.Rotate90FlipX) { c = w * h - w; for (int i = 0; i &lt; temp.Length / 4; i++) { t = Math.Truncate((double)i / h); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate90FlipNone) i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> i4 = (t * h + (h - i % h)) * 4; j4 = (c - w * (i % h) + t) * 4; //j4 = (w * (h - 1 - i4 % h) + i4 / h) * 4; data[i4] = temp[j4]; data[i4 + 1] = temp[j4 + 1]; data[i4 + 2] = temp[j4 + 2]; data[i4 + 3] = temp[j4 + 3]; } } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate270FlipNone || rotFlipType == RotFlipType.Rotate270FlipX) { c = w - 1; for (int i = 0; i &lt; temp.Length / 4; i++) { t = Math.Truncate((double)i / h); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rotFlipType == RotFlipType.Rotate270FlipNone) i4 = i * 4; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> i4 = (t * h + (h - i % h)) * 4; j4 = (c + w * (i % h) - t) * 4; // j4 = w * (1 + i4 % h) - i4 / h - 1; data[i4] = temp[j4]; data[i4 + 1] = temp[j4 + 1]; data[i4 + 2] = temp[j4 + 2]; data[i4 + 3] = temp[j4 + 3]; } } context.PutImageData(); } return bitmap; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> DOTNET Bitmap result = null; switch (rotFlipType) { case RotFlipType.RotateNoneFlipNone: result = bitmap; break; case RotFlipType.Rotate90FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate90FlipNone); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate270FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate270FlipNone); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate180FlipNone: bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone); result = bitmap; break; case RotFlipType.RotateNoneFlipX: bitmap.RotateFlip(RotateFlipType.RotateNoneFlipX); result = bitmap; break; case RotFlipType.Rotate90FlipX: bitmap.RotateFlip(RotateFlipType.Rotate90FlipX); result = new Image(bitmap); bitmap.Dispose(); break; case RotFlipType.Rotate180FlipX: bitmap.RotateFlip(RotateFlipType.Rotate180FlipX); result = bitmap; break; case RotFlipType.Rotate270FlipX: bitmap.RotateFlip(RotateFlipType.Rotate270FlipX); result = new Image(bitmap); bitmap.Dispose(); break; } return result; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br><h4 id="synchronous-and-asynchronous-image-loading">  Memuat Gambar Sinkron dan Asinkron </h4><br><p>  Perhatikan bahwa dalam versi Script # kami menentukan fungsi <code>CollageImageLoad</code> yang berbeda, yang dipanggil setelah memuat gambar, sedangkan dalam versi .NET proses ini berlangsung secara bersamaan (dari sistem file atau Internet). </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CollageData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> smallMaskPath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bigMaskPath, List&lt;CollageDataPart&gt; dataParts</span></span></span><span class="hljs-function">)</span></span> { SmallMaskImagePath = smallMaskPath; BigMaskImagePath = bigMaskPath; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SCRIPTSHARP CurrentMask = PrivateUtils.CreateEmptyImage(); CurrentMask.AddEventListener("load", CollageImageLoad, false); CurrentMask.Src = CurrentMaskImagePath; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> CurrentMask = PrivateUtils.LoadBitmap(CurrentMaskImagePath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!CurrentMaskImagePath.Contains("http://") &amp;&amp; !CurrentMaskImagePath.Contains("https://")) CurrentMask = Bitmap(CurrentMaskImagePath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { var request = WebRequest.Create(CurrentMaskImagePath); using (var response = request.GetResponse()) using (var stream = response.GetResponseStream()) CurrentMask = (Bitmap)Bitmap.FromStream(stream); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DataParts = dataParts; }</span></span></code> </pre> </div></div><br><h3 id="script-only">  Hanya Skrip # </h3><br><h4 id="detecting-the-type-and-version-of-a-browser">  Mendeteksi Jenis dan Versi Peramban </h4><br><p>  Fungsi ini digunakan untuk menentukan kemampuan drag &amp; drop di berbagai browser.  Saya sudah mencoba menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modernizr</a> , tetapi mengembalikan Safari itu dan (dalam kasus saya, itu adalah versi Win) IE9 mengimplementasikannya.  Dalam praktiknya, peramban ini gagal menerapkan kemampuan seret &amp; lepas dengan benar. </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BrowserVersion { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { DetectBrowserTypeAndVersion(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _browserVersion; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectBrowserTypeAndVersion</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_browserDetected) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> userAgent = Window.Navigator.UserAgent.ToLowerCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"opera"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Opera; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"chrome"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Chrome; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"safari"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Safari; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"firefox"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) _browser = BrowserType.Firefox; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"msie"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numberIndex = userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">"msie"</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span>; _browser = BrowserType.IE; _browserVersion = userAgent.Substring(numberIndex, userAgent.IndexOf(<span class="hljs-string"><span class="hljs-string">';'</span></span>, numberIndex)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _browser = BrowserType.Unknown; _browserDetected = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> </div></div><br><h4 id="rendering-a-dash-dot-line">  Rendering Garis Dash-dot </h4><br><p>  Kode ini digunakan untuk persegi panjang untuk memotong gambar.  Terima kasih atas ide untuk semua orang yang menjawab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertanyaan</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di stackoverflow</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawDahsedLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GraphicsContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dashArray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dashArray == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) dashArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] { <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashCount = dashArray.Length; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = x2 - x1; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dy = y2 - y1; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> xSlope = Math.Abs(dx) &gt; Math.Abs(dy); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> slope = xSlope ? dy / dx : dx / dy; context.MoveTo(x1, y1); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> distRemaining = Math.Sqrt(dx * dx + dy * dy); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (distRemaining &gt;= <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dashLength = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Min(distRemaining, dashArray[dashIndex % dashCount]); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> step = Math.Sqrt(dashLength * dashLength / (<span class="hljs-number"><span class="hljs-number">1</span></span> + slope * slope)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xSlope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) step = -step; x1 += step; y1 += slope * step; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dy &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) step = -step; x1 += slope * step; y1 += step; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dashIndex % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) context.LineTo(x1, y1); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> context.MoveTo(x1, y1); distRemaining -= dashLength; dashIndex++; } }</code> </pre> </div></div><br><h4 id="rotation-animation">  Animasi rotasi </h4><br><p>  fungsi <code>setInterval</code> digunakan untuk mengimplementasikan animasi rotasi gambar.  Perhatikan bahwa gambar hasil dihitung selama animasi sehingga tidak ada jeda pada akhir animasi. </p><br><div class="spoiler">  <b class="spoiler_title">Kode sumber</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rotate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cw</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_rotating &amp;&amp; !_flipping) { _rotating = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _cw = cw; RotFlipType oldRotFlipType = _curRotFlipType; _curRotFlipType = RotateRotFlipValue(_curRotFlipType, _cw); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentStep = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stepCount = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(RotateFlipTimeSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span> / StepTimeTicks); Bitmap result = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; _interval = Window.SetInterval(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentStep &lt; stepCount) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> absAngle = GetAngle(oldRotFlipType) + currentStep / stepCount * Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span> * (_cw ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>); DrawRotated(absAngle); currentStep++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Window.ClearInterval(_interval); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Draw(result); _rotating = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }, StepTimeTicks); result = GetCurrentTransformResult(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_rotating) Draw(result); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawRotated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotAngle</span></span></span><span class="hljs-function">)</span></span> { _resultContext.FillColor = FillColor; _resultContext.FillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _result.Width, _result.Height); _resultContext.Save(); _resultContext._graphics.Translate(_result.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, _result.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); _resultContext._graphics.Rotate(-rotAngle); _resultContext._graphics.Translate(-_origin.Width / <span class="hljs-number"><span class="hljs-number">2</span></span>, -_origin.Height / <span class="hljs-number"><span class="hljs-number">2</span></span>); _resultContext._graphics.DrawImage(_origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); _resultContext.Restore(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap bitmap</span></span></span><span class="hljs-function">)</span></span> { _resultContext.FillColor = FillColor; _resultContext.FillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _result.Width, _result.Height); _resultContext.Draw2(bitmap, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_result.Width - bitmap.Width) / <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((_result.Height - bitmap.Height) / <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> </div></div><br><h2 id="conclusion">  Kesimpulan </h2><br><p>  Artikel ini menjelaskan bagaimana bahasa C # (menggabungkan kode yang tidak dikelola dan kompilasi untuk JavaScript) dapat digunakan untuk membuat solusi lintas platform yang sesungguhnya.  Terlepas dari fokus pada .NET dan JavaScript, kompilasi ke Android, iOS (dengan menggunakan Mono), dan Windows Phone juga dimungkinkan berdasarkan pendekatan ini, yang tentu saja memiliki jebakan.  Kode ini agak berlebihan karena sifatnya yang universal, tetapi tidak mempengaruhi kinerja karena operasi grafis biasanya memakan waktu lebih lama. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440342/">https://habr.com/ru/post/id440342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440330/index.html">Secara singkat tentang abstraksi</a></li>
<li><a href="../id440332/index.html">Database di awan: kepada siapa dan mengapa - pendapat spesialis Data Egret</a></li>
<li><a href="../id440334/index.html">Buka webinar "Pengembangan sistem yang sangat dimuat dalam PHP"</a></li>
<li><a href="../id440336/index.html">HTML kami hilang</a></li>
<li><a href="../id440338/index.html">Cara memastikan ketersediaan layanan web di cloud jika terjadi kegagalan pusat data</a></li>
<li><a href="../id440344/index.html">InterNyet - bagaimana Internet ditemukan di Uni Soviet dan mengapa itu tidak berhasil</a></li>
<li><a href="../id440346/index.html">Pada akhir Februari, Microsoft akan memperkenalkan kacamata VR HoloLens 2</a></li>
<li><a href="../id440350/index.html">Flying Bear Tornado 2 - beruang baru telah tiba</a></li>
<li><a href="../id440352/index.html">Retas massal VKontakte [XSS-worm]</a></li>
<li><a href="../id440354/index.html">Acara digital di Moskow 18-24 Februari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>