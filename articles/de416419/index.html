<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆓 🚑 👨🏻‍🍳 Zufälliger zweidimensionaler Höhlengenerator 📧 👈 🛌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 Wenn Sie zu faul sind, um sich um Ihre Zeit zu kümmern und ein Level für Ihr Spiel zu erstellen, sind Sie bei uns genau richtig. 

 In diese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zufälliger zweidimensionaler Höhlengenerator</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416419/"><h2>  Vorwort </h2><br>  Wenn Sie zu <s>faul sind, um sich</s> um Ihre Zeit <s>zu kümmern</s> und ein Level für Ihr Spiel zu erstellen, sind Sie bei uns genau richtig. <br><br>  In diesem Artikel erfahren Sie ausführlich, wie Sie am Beispiel von Hochland und Höhlen eine von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vielen anderen</a> Generierungsmethoden anwenden können.  Wir werden den <i>Aldous-Broder-</i> Algorithmus betrachten und wie man die erzeugte Höhle schöner macht. <br><br>  Am Ende des Lesens des Artikels sollten Sie ungefähr Folgendes erhalten: <br><br><div class="spoiler">  <b class="spoiler_title">Zusammenfassung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jk/zh/jj/jkzhjjuzbr7ab8m9rbf2xqbqbmc.png"><br></div></div><a name="habracut"></a><br><h2>  Theorie </h2><br><h4>  Berg </h4><br>  Um ehrlich zu sein, kann die Höhle von Grund auf neu erstellt werden, aber wird sie irgendwie hässlich sein?  In der Rolle der <i>"Plattform"</i> für die Platzierung von Minen habe ich eine Bergkette gewählt. <br>  Dieser Berg wird ganz einfach erzeugt: Lassen Sie uns ein <i>zweidimensionales Array</i> und eine <i>variable Höhe haben</i> , die anfänglich der halben Länge des <i>Arrays</i> in der zweiten Dimension entspricht;  Wir gehen einfach die Spalten durch und füllen etwas mit allen Zeilen in der Spalte auf einen <i>variablen</i> Höhenwert aus, wobei wir ihn mit einer zufälligen Chance nach oben oder unten ändern. <br><br><h4>  Höhle </h4><br>  Um die Dungeons selbst zu generieren, habe ich - <i>wie mir schien</i> - einen hervorragenden Algorithmus gewählt.  In einfachen Worten kann dies wie folgt erklärt werden: Selbst wenn wir zwei (vielleicht zehn) Variablen <b>X</b> und <b>Y</b> und ein zweidimensionales Array von 50 mal 50 haben, geben wir diesen Variablen Zufallswerte innerhalb unseres Arrays, zum Beispiel <b>X = 26</b> und <b>Y = 28</b> .  Danach führen wir die gleichen Aktionen mehrmals aus: Wir erhalten eine Zufallszahl von Null bis <p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">A</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">z</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11">V</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">n</span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.267em; margin-right: 0.267em;">∗</span><span class="MJXp-mn" id="MJXp-Span-21">2</span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> Anzahl der Variablen * 2 </script></p>  in unserem Fall bis zu <i>vier</i> ;  und dann ändern wir uns abhängig von der Anzahl der abgebrochenen Personen <br>  unsere Variablen: <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: X += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: X -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: Y += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: Y -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Dann prüfen wir natürlich, ob eine Variable außerhalb der Grenzen unseres Feldes liegt: <br><br><pre> <code class="hljs xml"> X = X <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag"> ? </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">X</span></span></span><span class="hljs-tag"> &gt;</span></span>= 50 ? 49 : X); Y = Y <span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag"> ? </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:</span></span></span><span class="hljs-tag"> (</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Y</span></span></span><span class="hljs-tag"> &gt;</span></span>= 50 ? 49 : Y);</code> </pre><br>  Nach all diesen Überprüfungen tun wir etwas in den neuen <b>X-</b> und <b>Y-</b> Werten für unser Array <i>(zum Beispiel: Fügen Sie dem Element einen hinzu)</i> . <br><br><pre> <code class="hljs powershell">array[<span class="hljs-type"><span class="hljs-type">X</span></span>, <span class="hljs-type"><span class="hljs-type">Y</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><h2>  Vorbereitung </h2><br>  Zeichnen wir zur Vereinfachung der Implementierung und Visualisierung unserer Methoden die resultierenden Objekte?  Ich bin so froh, dass es dir nichts ausmacht!  Wir werden dies mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Texture2D</a> tun. <br><br>  Zum Arbeiten benötigen wir nur zwei Skripte: <br><blockquote>  <b>Bei ground_libray dreht</b> sich der Artikel.  Hier erzeugen und reinigen und zeichnen wir </blockquote><blockquote>  <b>ground_generator</b> ist das, was unser ground_libray verwenden wird </blockquote>  Lassen Sie den ersten <i>statisch sein</i> und erben Sie nichts: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ground_libray</span></span></span></span></code> </pre> <br>  Und die zweite ist normal, nur brauchen wir die <b>Update-</b> Methode nicht. <br><br>  Lassen Sie uns außerdem mit der <b>SpriteRenderer-</b> Komponente ein Spielobjekt auf der Bühne <b>erstellen</b> <br><br><h2>  Praktischer Teil </h2><br><h4>  Woraus besteht es? </h4><br>  Um mit Daten zu arbeiten, verwenden wir ein zweidimensionales Array.  Sie können eine Reihe verschiedener Typen verwenden, von <b>Byte</b> oder <b>Int</b> bis hin zu <b>Farbe</b> , aber ich glaube, dass dies am besten möglich ist: <br><br><div class="spoiler">  <b class="spoiler_title">Neuer Typ</b> <div class="spoiler_text">  Wir schreiben dieses Ding in <b>ground_libray</b> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">block</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">block</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color col</span></span></span><span class="hljs-function">)</span></span> { color = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] { col.r, col.g, col.b }; } }</code> </pre><br></div></div><br>  Ich werde dies durch die Tatsache erklären, dass wir damit sowohl unser Array <i>speichern</i> als auch es bei Bedarf <i>ändern</i> können. <br><br><h4>  Massiv </h4><br>  Bevor wir mit der Erzeugung des Berges beginnen, bestimmen wir den Ort, an dem wir ihn <i>lagern werden</i> . <br><br>  Im Skript <b>ground_generator habe</b> ich <b>Folgendes</b> geschrieben: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ground_size = <span class="hljs-number"><span class="hljs-number">128</span></span>; ground_libray.block[,] ground; Texture2D myT;</code> </pre><br>  <b>ground_size</b> - die Größe unseres Feldes ( <b>dh</b> das Array besteht aus 16384 Elementen). <br>  <b>ground_libray.block [,]</b> <i>ground</i> - das ist unser Feld für die Erzeugung. <br>  <b>Texture2D</b> <i>myT</i> ist das, worauf wir <i>zurückgreifen</i> werden. <br><br><div class="spoiler">  <b class="spoiler_title">Wie wird es funktionieren?</b> <div class="spoiler_text">  Das Prinzip der Arbeit mit uns wird wie <b>folgt sein</b> - wir werden einige <b>ground_libray-</b> Methoden von <b>ground_generator aufrufen</b> und dem ersten unser <b>Bodenfeld</b> geben. <br></div></div><br>  Erstellen wir die erste Methode im Skript ground_libray: <br><br><div class="spoiler">  <b class="spoiler_title">Bergbau</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mount_noise = <span class="hljs-number"><span class="hljs-number">0.02f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_mount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block[,] b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_now = b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; h_now; y++) { b[x, y] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> block(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); h_now += Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - mount_noise) ? (Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>) : <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Und sofort werden wir versuchen zu verstehen, was hier passiert: Wie gesagt, wir gehen einfach die Spalten unseres Arrays <b>b durch</b> und ändern gleichzeitig die Höhenvariable <b>h_now</b> , die ursprünglich gleich der Hälfte <b>128</b> <i>(64) war</i> .  Aber es gibt noch etwas Neues - <b>mount_noise</b> .  Diese Variable ist für die Möglichkeit <b>verantwortlich</b> , <b>h_now zu</b> ändern, denn wenn Sie die Höhe sehr oft ändern, <b>sieht</b> der Berg wie ein <i>Kamm aus</i> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Farbe</b> <div class="spoiler_text">  Ich habe sofort eine leicht <i>bräunliche</i> Farbe eingestellt, lass es zumindest einige sein - in Zukunft werden wir sie nicht brauchen. <br></div></div><br>  Gehen <b>wir</b> nun zu <b>ground_generator</b> und schreiben dies in die <b>Start-</b> Methode: <br><br><pre> <code class="cs hljs"> ground = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ground_libray.block [ground_size, ground_size]; ground_libray.generate_mount(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ground);</code> </pre><br>  Wir initialisieren den variablen <b>Boden,</b> <s>sobald dies erforderlich ist</s> . <br>  Senden Sie es <b>anschließend</b> ohne Erklärung an <b>ground_libray</b> . <br>  Also haben wir den Berg erzeugt. <br><br><h4>  Warum kann ich meinen Berg nicht sehen? </h4><br>  Zeichnen wir jetzt, was wir haben! <br><br>  Zum Zeichnen schreiben wir die folgende Methode in unser <b>ground_libray</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">block[,] b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Texture2D t</span></span></span><span class="hljs-function">)</span></span> { t = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2D(b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>), b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>)); t.filterMode = FilterMode.Point; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b[x, y] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { t.SetPixel(x, y, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } t.SetPixel(x, y, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color( b[x, y].color[<span class="hljs-number"><span class="hljs-number">0</span></span>], b[x, y].color[<span class="hljs-number"><span class="hljs-number">1</span></span>], b[x, y].color[<span class="hljs-number"><span class="hljs-number">2</span></span>] ) ); } t.Apply(); }</code> </pre><br>  Hier geben wir niemandem mehr unser Feld, wir geben nur eine Kopie davon <i>(obwohl wir aufgrund der Wortklasse etwas mehr als nur eine Kopie gegeben haben)</i> .  Wir werden dieser Methode auch unsere <b>Texture2D</b> geben. <br><br>  Die ersten beiden Zeilen: Wir erstellen unsere Textur in der <b>Größe des Feldes</b> und <b>entfernen die Filterung</b> . <br><br>  Danach gehen wir unser gesamtes Array-Feld durch und haben nichts erstellt <i>(die Klasse muss initialisiert werden)</i> - wir zeichnen ein leeres Feld, andernfalls, wenn es nicht leer ist - zeichnen wir das, was wir gespeichert haben, in das Element. <br></div></div><br>  Und wenn wir fertig sind, gehen wir <b>natürlich</b> zu <b>ground_generator</b> und fügen <b>Folgendes</b> hinzu: <br><br><pre> <code class="cs hljs"> ground = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ground_libray.block [ground_size, ground_size]; ground_libray.generate_mount(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ground); <span class="hljs-comment"><span class="hljs-comment">//   ground_libray.paint(ground, ref myT); GetComponent&lt;SpriteRenderer&gt;().sprite = Sprite.Create(myT, new Rect(0, 0, ground_size, ground_size), Vector3.zero );</span></span></code> </pre><br>  Aber egal wie viel wir auf unsere Textur zeichnen, im Spiel können wir es nur sehen, indem wir diese Leinwand auf etwas legen: <br><br>  <b>SpriteRenderer</b> akzeptiert <b>Texture2D nirgendwo</b> , aber nichts hindert uns daran, aus dieser Textur ein <i>Sprite zu</i> erstellen - <b>Sprite.Create</b> ( <b>Textur</b> , <b>Rechteck mit den Koordinaten der unteren linken Ecke und der oberen rechten Ecke</b> , der <b>Koordinate der Achse</b> ). <br><br>  Diese Linien werden als die neuesten bezeichnet, wir werden den Rest über der <b>Malmethode</b> hinzufügen! <br><br><h4>  Meins </h4><br>  Jetzt müssen wir unsere Felder mit zufälligen Höhlen füllen.  Für solche Aktionen erstellen wir auch eine separate Methode in <b>ground_libray</b> .  Ich möchte sofort die Parameter der Methode erklären: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> block[,] b -     . <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thick -    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size -         Color outLine -  </code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Höhle</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_cave</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block[,] b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thick, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, Color outLine</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xNow = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yNow = Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { b[xNow, yNow] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; make_thick(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> b, thick, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] { xNow, yNow }, outLine); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: xNow += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: xNow -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: yNow += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: yNow -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } xNow = xNow &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (xNow &gt;= b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>) ? b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> : xNow); yNow = yNow &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (yNow &gt;= b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>) ? b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span> : yNow); } }</code> </pre> <br>  Zunächst haben wir unsere Variablen <b>X</b> und <b>Y</b> deklariert, aber ich habe sie nur <b>xNow</b> bzw. <b>yNow genannt</b> . <br><br>  Das erste, nämlich <b>xNow</b> , erhält einen zufälligen Wert von Null bis zur Größe des Feldes in der ersten Dimension. <br><br>  Und das zweite - <b>yNow</b> - erhält ebenfalls einen zufälligen Wert: von Null bis zur Mitte des Feldes in der zweiten Dimension.  <i>Warum?</i>  Wir erzeugen unseren Berg aus der Mitte, die Chance, dass er bis zur "Decke" wächst, ist <i>nicht groß</i> .  Aus diesem Grund halte ich es nicht für relevant, Höhlen in der Luft zu erzeugen. <br><br>  Danach geht sofort eine Schleife, deren Anzahl von Ticks vom Größenparameter abhängt.  Bei jedem Tick aktualisieren wir das Feld an den <b>Positionen</b> <b>xNow</b> und <b>yNow</b> und erst dann aktualisieren wir sie selbst <i>(</i> <b>Feldaktualisierungen</b> <i>können am Ende vorgenommen werden - Sie werden den Unterschied nicht spüren).</i> <br><br>  Es gibt auch eine <b>make_thick-</b> Methode, in deren Parametern wir unser <b>Feld übergeben</b> , die <b>Breite des Höhlenstrichs</b> , die <b>aktuelle Aktualisierungsposition der Höhle</b> und die <b>Farbe des Strichs</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Schlaganfall</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_thick</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block[,] b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] start, Color o</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (start[<span class="hljs-number"><span class="hljs-number">0</span></span>] - t); x &lt; (start[<span class="hljs-number"><span class="hljs-number">0</span></span>] + t); x++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (start[<span class="hljs-number"><span class="hljs-number">1</span></span>] - t); y &lt; (start[<span class="hljs-number"><span class="hljs-number">1</span></span>] + t); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || y &gt;= b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b[x, y] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; b[x, y] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> block(o); } } }</code> </pre><br>  Die Methode verwendet die an sie übergebene Startkoordinate und malt in einem Abstand <b>t</b> alle Blöcke in der Farbe <b>o neu</b> - alles ist sehr einfach! <br></div></div><br></div></div><br>  <b>Fügen</b> wir <b>nun</b> diese Zeile zu unserem <b>ground_generator hinzu</b> : <br><br><pre> <code class="cs hljs">ground_libray.make_cave(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ground, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">0.3f</span></span>));</code> </pre><br>  Sie können das Skript <b>ground_generator</b> als Komponente auf unserem Objekt installieren und überprüfen, wie es funktioniert! <br><br><img src="https://habrastorage.org/webt/l3/n5/st/l3n5stambbjalez4h3a4liinkyq.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mehr über die Höhlen ...</b> <div class="spoiler_text"><ul><li>  Um mehr Höhlen zu <b>erstellen</b> , können Sie die Methode <b>make_cave</b> mehrmals <b>aufrufen</b> <i>(verwenden Sie eine Schleife).</i> </li><li>  Durch Ändern des Größenparameters wird die Höhle nicht immer vergrößert, sie wird jedoch häufig größer </li><li>  Durch Ändern des <b>Thick-</b> Parameters erhöhen Sie die Anzahl der Operationen erheblich: <br>  Wenn der Parameter 3 ist, beträgt die Anzahl der Quadrate in einem Radius von <b>3</b> <b>36</b> , sodass bei einer Parametergröße von <b>40.000</b> die Anzahl der Operationen <b>36 * 40.000 = 1440000 beträgt</b> </li></ul><br></div></div><br><h4>  Höhlenkorrektur </h4><br><img src="https://habrastorage.org/webt/iv/bj/xj/ivbjxj0mhsc2lyktv6-r9n74o5g.png"><br><br>  Haben Sie bemerkt, dass die Höhle in dieser Ansicht nicht besonders gut aussieht?  Zu viele zusätzliche Details <i>(vielleicht denken Sie anders)</i> . <br><br>  Um Einschlüsse von <i># 4d4d4d</i> loszuwerden, schreiben wir diese Methode in <b>ground_libray</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Reiniger</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear_caves</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block[,] b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b[x, y] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (solo(b, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] { x, y })) b[x, y] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre><br>  Es wird jedoch schwierig sein zu verstehen, was hier vor sich geht, wenn Sie nicht wissen, was die <b>Solofunktion</b> bewirkt: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">block[,] b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rad, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] start</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (start[<span class="hljs-number"><span class="hljs-number">0</span></span>] - rad); x &lt;= (start[<span class="hljs-number"><span class="hljs-number">0</span></span>] + rad); x++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (start[<span class="hljs-number"><span class="hljs-number">1</span></span>] - rad); y &lt;= (start[<span class="hljs-number"><span class="hljs-number">1</span></span>] + rad); y++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || y &gt;= b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b[x, y] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) cnt += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cnt &gt;= min) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  In den Parametern dieser Funktion müssen unser <b>Feld</b> , der <b>Radius der Punktüberprüfung</b> , die <b>„Zerstörungsschwelle“</b> und die <b>Koordinaten des zu überprüfenden Punktes</b> vorhanden sein. <br>  Hier ist eine detaillierte Erklärung, was diese Funktion tut: <br><blockquote>  int cnt ist der Zähler der aktuellen "Schwelle" <br>  Als nächstes folgen zwei Zyklen, die alle Punkte um den einen herum überprüfen, dessen Koordinaten zum <b>Starten übergeben werden</b> .  Wenn es einen <b>leeren Punkt gibt</b> , fügen wir einen zu <b>cnt</b> hinzu. Wenn wir die <i>"Schwelle der Zerstörung" erreichen, geben</i> wir die Wahrheit zurück - der Punkt <i>ist überflüssig</i> .  Ansonsten berühren wir sie nicht. <br><br>  Ich habe die Zerstörungsschwelle auf <i>13</i> leere Punkte festgelegt, und der Überprüfungsradius beträgt <i>2</i> <i>(dh es werden 24 Punkte überprüft, ohne den zentralen Punkt).</i> <br></blockquote><div class="spoiler">  <b class="spoiler_title">Beispiel</b> <div class="spoiler_text">  Dieser bleibt unversehrt, da es nur <b>9</b> leere Punkte gibt. <br><br><img src="https://habrastorage.org/webt/di/vf/mi/divfmifh9a7xojkprbkyqfdt5im.png"><br><br>  Aber dieser hatte kein Glück - ungefähr <b>14</b> leere Punkte <br><br><img src="https://habrastorage.org/webt/w6/ls/ab/w6lsabduc8vbb8s2le9xgaacy0q.png"><br></div></div><br>  Eine kurze Beschreibung des Algorithmus: <i>Wir gehen das gesamte Feld durch und überprüfen alle Punkte, um festzustellen, ob sie benötigt werden.</i> <br></div></div><br>  Als nächstes fügen wir einfach die folgende Zeile zu unserem <b>ground_generator hinzu</b> : <br><br><pre> <code class="cs hljs">ground_libray.clear_caves(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ground);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Zusammenfassung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ri/zn/8r/rizn8rrubua8zpkz2ihdg-xbaji.png"><br></div></div><br>  <i>Wie wir sehen können, gingen die meisten unnötigen Partikel einfach weg.</i> <br><br><h4>  Fügen Sie etwas Farbe hinzu </h4><br>  Unser Berg sieht sehr eintönig aus, ich finde es langweilig. <br><br>  Fügen wir etwas Farbe hinzu.  Fügen Sie die Methode <b>level_paint</b> zu <b>ground_libray hinzu</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Über die Berge malen</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">level_paint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block[,] b, Color[] all_c</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; b.GetLength(<span class="hljs-number"><span class="hljs-number">0</span></span>); x++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lvl_div = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lvl_now = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = b.GetLength(<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; y--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b[x, y] != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; lvl_div == <span class="hljs-number"><span class="hljs-number">-1</span></span>) lvl_div = y / all_c.Length; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b[x, y] == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; b[x, y] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> block(all_c[lvl_now]); lvl_now += counter &gt;= lvl_div ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; lvl_now = (lvl_now &gt;= all_c.Length) ? (all_c.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>) : lvl_now; counter = counter &gt;= lvl_div ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (counter += <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } &lt;/ &lt;cut /&gt;source&gt;           .    ,       ,   .       ,      .          &lt;b&gt;Y &lt;/b&gt;  ,      . &lt;/spoiler&gt;     &lt;b&gt;ground_generator &lt;/b&gt; : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"cs"</span></span>&gt; ground_libray.level_paint(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ground, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color[<span class="hljs-number"><span class="hljs-number">3</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0.6f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.05f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), });</code> </pre><br>  Ich habe nur 3 Farben gewählt: <i>Grün</i> , <i>Dunkelrot</i> und <i>Dunkelgrau</i> . <br>  Natürlich können Sie sowohl die Anzahl der Farben als auch die Werte der einzelnen Farben ändern.  Es stellte sich so heraus: <br><br><div class="spoiler">  <b class="spoiler_title">Zusammenfassung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oh/5c/mp/oh5cmpywublde_gjvenbun7xili.png"><br></div></div><br>  <b>Trotzdem</b> sieht es zu streng aus, um den Farben ein wenig Zufälligkeit zu verleihen. Wir werden diese Eigenschaft in <b>ground_libray</b> schreiben: <br><br><div class="spoiler">  <b class="spoiler_title">Zufällige Farben</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_randomize = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> crnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Random.Range(<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - color_randomize, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> + color_randomize); } }</code> </pre><br>  Und jetzt in den <b>Methoden</b> <b>level_paint</b> und <b>make_thick</b> , in den Zeilen, in denen wir Farben zuweisen, zum Beispiel in <b>make_thick</b> : <br><br><pre> <code class="cs hljs">b[x, y] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> block(o);</code> </pre> <br>  Wir werden dies schreiben: <br><br><pre> <code class="cs hljs">b[x, y] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> block(o * crnd);</code> </pre> <br>  Und in <b>level_paint</b> <br><br><pre> <code class="cs hljs">b[x, y] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> block(all_c[lvl_now] * crnd);</code> </pre> <br></div></div><br>  Am Ende sollte alles ungefähr so ​​aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">Zusammenfassung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/jk/zh/jj/jkzhjjuzbr7ab8m9rbf2xqbqbmc.png"><br></div></div><br></div></div><br><h2>  Nachteile </h2><br>  Angenommen, wir haben ein Feld von 1024 mal 1024, wir müssen 24 Höhlen erzeugen, deren Kantenstärke 4 beträgt und deren Größe 80.000 beträgt. <br><br>  1024 * 1024 + 24 * 64 * 80.000 = <b>5.368.832.000.000</b> Operationen. <br><br>  Diese Methode eignet sich nur zum Generieren kleiner Module für die Spielwelt. Es ist <b>unmöglich, jeweils</b> etwas sehr Großes <b>zu</b> generieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416419/">https://habr.com/ru/post/de416419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416409/index.html">5 häufige Fehler bei der Entwicklung von Strategien und Möglichkeiten, mit ihnen umzugehen</a></li>
<li><a href="../de416411/index.html">Geschichten mit Daten erzählen</a></li>
<li><a href="../de416413/index.html">Kam, sah, verallgemeinerte: eingetaucht in Java Generics</a></li>
<li><a href="../de416415/index.html">Wir bewegen alles in der Testbaugruppe Vivaldi 1.16.1230.3</a></li>
<li><a href="../de416417/index.html">"Heavenly River" - China wird einen künstlichen Regen von beispielloser Kraft erzeugen</a></li>
<li><a href="../de416421/index.html">Ein Spaziergang in der Boxengasse oder wie IaaS-Technologien Rennteams helfen</a></li>
<li><a href="../de416423/index.html">Wie die Russen an den amerikanischen Prozessor erinnerten oder eine Überprüfung des AdvoCam-FD8 Gold-II DVR (GPS + GLONASS)</a></li>
<li><a href="../de416425/index.html">Lokale Autorisierung ohne Passwort in Ubuntu</a></li>
<li><a href="../de416427/index.html">Was wir im Juni gelesen haben: Nachrichten über Angular, JWT, Blockchain-Skandal und ein bisschen Zen</a></li>
<li><a href="../de416429/index.html">Beabsichtigte Gestaltungsprinzipien für Jakarta EE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>