<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚇 ⚔️ 🚴🏻 Podman dan Buildah untuk Pengguna Docker 👩🏿‍🤝‍👩🏼 😨 👨🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meskipun ada banyak blog dan tutorial bagus tentang Podman dan Buildah, pengguna Docker jelas tidak memiliki penjelasan yang jelas dan ringkas tentang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Podman dan Buildah untuk Pengguna Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/467105/">  Meskipun ada banyak blog dan tutorial bagus tentang Podman dan Buildah, pengguna Docker jelas tidak memiliki penjelasan yang jelas dan ringkas tentang bagaimana mereka beralih ke Podman, mengapa Buildah diperlukan dalam masalah lain seperti ini. <br><br><img src="https://habrastorage.org/webt/m9/de/um/m9deumkiupstpwlpynelflvucxo.png" width="100%"><br><br>  Kami akan mencoba menjawab pertanyaan-pertanyaan ini dan memberi tahu Anda cara bermigrasi dengan mulus dari Docker ke Podman. <br><a name="habracut"></a><br><h3>  Cara Kerja Docker </h3><br>  Mari kita mulai dengan menjelaskan cara kerja Docker untuk memahami mengapa Podman dan Buildah muncul.  Seperti yang Anda ketahui, perintah Docker hanya berfungsi saat proses daemon Docker sedang berjalan.  Gagasan dengan daemon, tampaknya, adalah untuk mengumpulkan di satu tempat semua hal keren yang dilakukan Docker, dan pada saat yang sama mengatur API yang berguna untuk bekerja dengannya di masa depan.  Seperti yang ditunjukkan pada gambar di bawah, daemon Docker berisi semua fungsi yang diperlukan untuk melakukan tugas-tugas berikut: <br><br><ul><li>  Tarik dan dorong operasi saat bekerja dengan registri gambar; </li><li>  Membuat salinan gambar di penyimpanan wadah lokal dan menambahkan lapisan ke wadah ini; </li><li>  Melakukan perubahan pada wadah dan menghapus gambar wadah dari repositori lokal pada host; </li><li>  Meminta kernel OS untuk meluncurkan wadah di namespace, cgroup yang sesuai, dll. </li></ul><br>  Intinya, daemon Docker menangani semua pekerjaan dengan pendaftar, gambar, wadah, dan kernel.  Dan Anda hanya memberi tahu dia apa yang harus dilakukan melalui antarmuka baris perintah (CLI). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/ot/n9/rpotn9q5ovfti-d-jv2m7yyhbta.png"></div><br><br>  Di sini kita tidak akan menimbang pro dan kontra dari pendekatan ini, ketika semuanya dikumpulkan dalam satu proses setan.  Banyak argumen dapat dibuat untuknya, dan pada saat kemunculan Docker, itu masuk akal.  Namun, dengan penggunaan Docker yang aktif, pertanyaan mulai muncul padanya, misalnya, seperti: <br><br><ul><li>  Satu proses berarti satu titik kegagalan; </li><li>  Proses daemon memiliki semua proses anak (menjalankan wadah); </li><li>  Ketika iblis pergi, proses anak tetap yatim; </li><li>  Perakitan kontainer memiliki lubang keamanan; </li><li>  Untuk melakukan operasi Docker, pengguna perlu hak akses root penuh. </li></ul><br>  Ada keluhan lain.  Seseorang mungkin tidak setuju dengan ini atau mengatakan bahwa kekurangan ini telah dihilangkan, tetapi kita tidak akan berdebat.  Pengembang Podman percaya bahwa mereka telah berhasil menyelesaikan banyak masalah ini, dan jika Anda ingin memanfaatkan Podman, maka artikel ini cocok untuk Anda. <br><br>  Inti dari Podman adalah untuk berinteraksi dengan registry gambar, dengan wadah dan penyimpanan gambar, serta dengan kernel Linux, bukan melalui daemon, tetapi langsung melalui proses runC, yang bertanggung jawab untuk meluncurkan kontainer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bf/a8/xo/bfa8xofe89azm6tc_bx71brzhcs.png"></div><br><br>  Sekarang setelah kami mengetahui sebagian motif pengembang Podman, saatnya untuk membahas apa arti transisi ke Podman bagi pengguna.  Dan di sini kita perlu memahami dan mengklarifikasi (kami akan melakukannya di bawah) berikut ini: <br><br><ul><li>  Podman menggantikan Docker.  Pada saat yang sama, tidak perlu lagi memulai beberapa jenis proses daemon, seperti daemon Docker; </li><li>  Perintah Docker yang familier bekerja dengan cara yang sama di Podman; </li><li>  Podman tidak menyimpan wadah dan gambar di tempat yang sama dengan Docker; </li><li>  Gambar Podman dan Docker kompatibel; </li><li>  Di lingkungan Kubernetes, Podman mampu lebih dari Docker; </li><li>  Dan juga kita akan menganalisis apa itu Buildah dan mengapa itu diperlukan. </li></ul><br><h3>  Instalasi Podman </h3><br>  Jika Anda menggunakan Docker, Anda dapat menghapusnya saat Anda memutuskan untuk beralih.  Namun, Anda dapat meninggalkan Docker saat mencoba Podman.  Ada beberapa <a href="">pelajaran</a> bermanfaat dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo</a> hebat yang mungkin berguna untuk dibaca dan dilihat sebagai permulaan sehingga Anda dapat lebih memahami proses transisi.  Salah satu contoh dalam demo membutuhkan Docker untuk menunjukkan kompatibilitas. <br><br>  Untuk menginstal Podman di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Red Hat Enterprise Linux</a> 7.6 atau yang lebih baru, gunakan yang berikut ini;  jika Anda menggunakan Fedora, ganti yum dengan dnf: <br><br><pre><code class="plaintext hljs"># yum -y install podman</code> </pre> <br><h3>  Podman menggunakan perintah yang sama dengan Docker </h3><br>  Podman dirancang agar mudah dipindahkan dari Docker.  Karenanya, semua tim yang Anda kenal dari Docker bekerja dengan cara yang sama di Podman.  Selain itu, dikatakan bahwa skrip panggilan Docker akan berfungsi dengan baik jika Anda membuat alias yang sesuai, seperti ini: alias docker = podman - coba saja.  Tentu saja, sebelum itu Anda perlu menghentikan Docker (systemctl stop docker).  Selain itu, Anda dapat menginstal paket podman-docker, yang akan melakukan semua konversi yang diperlukan untuk Anda.  Itu hanya menempatkan skrip di / usr / bin / docker yang menjalankan Podman dengan argumen yang sama yang digunakan Docker. <br><br>  Perintah Docker yang biasa, seperti tarik, dorong, bangun, jalankan, komit, beri tag, dll., Semuanya ada di Podman.  Lihat manual Podman untuk informasi lebih lanjut.  Perbedaan penting adalah bahwa di Podman beberapa tim telah menambahkan flag kenyamanan, misalnya, flag --all (-a) untuk perintah podman rm dan podman rmi, yang menurut banyak orang akan sangat berguna. <br><br>  Selain itu, Podman dapat dijalankan sebagai pengguna biasa, tanpa hak akses root.  Benar, sejauh ini ini hanya berfungsi di Fedora dan dengan Podman 1.0, dan di RHEL akan muncul mulai dengan versi 7.7 dan 8.1.  Ini telah dimungkinkan berkat perbaikan dalam perlindungan pengguna.  Berjalan sebagai pengguna biasa berarti bahwa secara default Podman menyimpan gambar dan wadah di direktori home pengguna, kami akan membahas ini secara lebih rinci di bagian selanjutnya.  Untuk mempelajari lebih lanjut tentang cara menjalankan Podman tanpa hak akses root, lihat artikel Dan Walsh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara kerja Podman tanpa root?</a>  . <br><br><h3>  Podman dan gambar kontainer </h3><br>  Saat Anda pertama kali memasukkan perintah gambar podman, Anda kemungkinan besar akan berkecil hati, karena Anda tidak akan melihat gambar Docker yang telah diunduh ke komputer Anda sebelumnya.  Faktanya adalah, repositori Podman lokal terletak di folder / var / lib / container, dan bukan di direktori / var / lib / docker.  Ini dilakukan tidak hanya seperti itu, tetapi sebagai bagian dari struktur penyimpanan baru yang memenuhi standar OCI (Open Containers Initiative). <br><br>  Pada 2015, Docker, Red Hat, CoreOS, SUSE, Google, dan penentu tren penampung Linux lainnya menciptakan Open Container Initiative, sebuah badan independen untuk mengelola spesifikasi standar untuk format gambar kontainer dan runtime-nya.  Sebagai bagian dari OCI, proyek wadah / gambar dan wadah / penyimpanan dibuat di GitHub. <br><br>  Karena Podman dapat dijalankan tanpa hak root, ia membutuhkan tempat terpisah untuk merekam gambar.  Oleh karena itu, repositori Podman terletak di direktori home user ~ / .local / share / container.  Ini membantu menghindari situasi di mana mereka dapat menulis semuanya di / var / lib / container, dan terkait dengan praktik lain yang berbahaya dari sudut pandang keamanan.  Selain itu, sekarang setiap pengguna memiliki wadahnya sendiri yang terpisah, sehingga beberapa pengguna dapat bekerja secara bersamaan pada host sekaligus.  Setelah selesai bekerja, pengguna dapat mendorong-kirim ke registri umum untuk membuat gambar mereka tersedia untuk orang lain. <br><br>  Saat beralih dari Docker ke Podman, mengetahui jalur lokasi kontainer baru akan berguna saat debugging, serta ketika Anda ingin menghapus repositori lokal dengan perintah rm -rf / var / lib / wadah untuk memulai dari awal.  Namun, dengan beralih ke Podman, Anda kemungkinan besar akan mulai menggunakan opsi -semua baru untuk perintah podman rm dan podman rmi alih-alih perintah ini. <br><br><h3>  Kompatibilitas kontainer antara Podman dan runtime lainnya </h3><br>  Terlepas dari lokasi berbeda dari repositori lokal, Docker dan Podman membuat gambar kontainer yang kompatibel dengan standar OCI.  Podman dapat menggunakan pendaftar kontainer populer, seperti Quay.io atau Docker Hub, serta pendaftar pribadi di kedua arah (dorong dan tarik).  Misalnya, dengan Podman, Anda dapat mengunduh dan menjalankan gambar Fedora terbaru dari Docker Hub.  Jika Anda tidak menentukan registri, Podman secara default akan mencari pendaftar yang terdaftar di file Registries.conf, mengikuti urutan yang ditentukan dalam file ini.  Awalnya, yang pertama dalam file ini adalah registri Docker Hub. <br><br><pre> <code class="plaintext hljs">$ podman pull fedora:latest $ podman run -it fedora bash</code> </pre><br>  Gambar yang telah diunggah ke registri menggunakan Docker dapat diunduh dan dijalankan menggunakan Podman.  Misalnya, jika kami membuat gambar myfedora menggunakan Docker dan mengunggahnya ke repositori Quay.io kami (ipbabble), maka Anda dapat mengunduhnya menggunakan Podman, berikut caranya: <br><br><pre> <code class="plaintext hljs">$ podman pull quay.io/ipbabble/myfedora:latest $ podman run -it myfedora bash</code> </pre><br>  Podman memungkinkan Anda untuk dengan mudah dan elegan memindahkan gambar antara direktori / var / lib / docker dan / var / lib / container menggunakan perintah push dan pull, misalnya: <br><br><pre> <code class="plaintext hljs">$ podman push myfedora docker-daemon:myfedora:latest</code> </pre><br>  Jelas bahwa jika Anda menghilangkan docker-daemon dalam contoh ini, pengiriman push akan pergi ke Docker Hub.  Jika Anda menentukan quay.io/myquayid/myfedora, gambar akan diunggah ke registri Quay.io (di sini myquayid adalah nama akun kami di Quay.io): <br><br><pre> <code class="plaintext hljs">$ podman push myfedora quay.io/myquayid/myfedora:latest</code> </pre><br>  Jika Anda memutuskan bahwa Anda siap untuk meninggalkan Docker, untuk mencopotnya, cukup tutup daemon dan kemudian hapus paket Docker menggunakan manajer paket.  Tetapi sebelum itu, pastikan untuk mengunduh semua gambar yang Anda butuhkan menggunakan Docker ke registri eksternal (bukan lokal) sehingga Anda dapat mengunduhnya dari sana nanti.  Atau Anda dapat menggunakan Podman untuk mengunduhnya dari repositori Docker lokal ke repositori Podman OCI lokal.  Misalnya, di RHEL, transfer gambar fedora dilakukan seperti ini: <br><br><pre> <code class="plaintext hljs"># systemctl stop docker # podman pull docker-daemon:fedora:latest # yum -y remove docker # optional</code> </pre><br><h3>  Podman memudahkan untuk beralih ke Kubernetes </h3><br>  Podman menawarkan sejumlah fitur tambahan - dibandingkan dengan Docker - yang berguna bagi pengembang dan operator TI saat bekerja dengan Kubernetes, khususnya, perintah yang berguna yang tidak dimiliki Docker.  Jika Anda terbiasa dengan Docker dan mempertimbangkan untuk pindah ke Kubernetes / OpenShift sebagai platform wadah, maka Podman akan berguna. <br><br>  Podman dapat menghasilkan file YAML Kubernetes berdasarkan wadah yang sedang berjalan menggunakan perintah podman generate kube.  Dan ketika men-debug pod yang sedang berjalan, di samping perintah standar untuk bekerja dengan kontainer, Anda juga dapat menggunakan perintah podman pod.  Untuk informasi lebih lanjut tentang bagaimana Podman membantu beralih ke Kubernetes, lihat artikel Brent Baude Podman sekarang dapat memudahkan transisi ke Kubernetes dan CRI-O. <br><br><h3>  Buildah - apa itu dan mengapa </h3><br>  Buildah muncul lebih awal dari Podman.  Dan ini kadang-kadang mengecilkan hati pengguna Docker: “Mengapa pembela Podman tiba-tiba berbicara tentang Buildah?  Podman tidak tahu bagaimana membangun? " <br><br>  Kami segera meyakinkan, Podman bisa, dan melakukannya seperti Docker.  Yaitu, perakitan dapat dilakukan baik menggunakan Dockerfile dan perintah podman build, atau Anda dapat memulai wadah, melakukan perubahan yang diperlukan dan kemudian mengkomitnya (mengeksekusi komit), membuat tag baru dalam gambar wadah.  Dalam interpretasi kami, Buildah adalah serangkaian perintah untuk membuat dan mengelola gambar kontainer, dan karenanya memberikan kontrol yang jauh lebih baik ketika bekerja dengan gambar.  Perintah build Podman sebagian berisi fungsionalitas Buildah dan menggunakan kode program yang sama untuk build seperti Buildah itu sendiri. <br><br>  Cara paling efisien untuk menggunakan Buildah adalah dengan menulis skrip Bash untuk membuat gambar, seperti halnya Anda menulis untuk Dockerfile. <br><br>  Adapun kronologi penampilan Buildah dan Podman, peristiwa terjadi kira-kira sebagai berikut.  Ketika Kubernetes belajar untuk bekerja dengan CRI-O berdasarkan pada standar OCI untuk runtime kontainer, daemon Docker tidak lagi diperlukan.  Artinya, tidak perlu lagi memasang Docker di semua node cluster Kubernetes untuk menjalankan pod dan kontainer di dalamnya.  Kubernetes sekarang dapat memanggil CRI-O, dan yang satu dapat menjalankan RunC secara langsung, yang, pada gilirannya, memulai proses kontainer.  Namun, jika pada saat yang sama kami ingin menggunakan cluster Kubernetes yang sama tidak hanya untuk peluncuran, tetapi juga untuk perakitan kontainer (seperti, misalnya, di OpenShift), maka kami memerlukan alat build baru yang tidak akan bergantung pada daemon Docker dan , sebagai akibatnya, tidak akan memerlukan instalasi Docker.  Selain itu, alat seperti itu, yang dibuat atas dasar wadah / penyimpanan dan proyek wadah / gambar, akan menghilangkan risiko keamanan yang terkait dengan soket terbuka daemon Docker selama perakitan, dan banyak pengguna Docker khawatir tentang risiko ini. <br><br>  Dan Buildah menjadi alat yang sangat baru (namanya bertuliskan "membangun" dan meniru aksen Boston dari manajer proyek Dan Walsh sambil mengucapkan kata "pembangun").  Informasi lebih lanjut tentang Buildah dapat ditemukan di buildah.io, serta blog dan panduan tautan di akhir artikel ini. <br><br>  Ada beberapa detail lainnya untuk dipelajari jika Anda ingin menggunakan Buildah: <br><br><ol><li>  Ini memberikan kontrol yang lebih tepat ketika membuat lapisan gambar.  Secara khusus, ini memungkinkan Anda untuk melakukan apa yang ingin dilakukan banyak pengguna wadah - lakukan banyak perubahan sekaligus hanya dengan satu lapisan. </li><li>  Lari Buildah dan Lari Podman adalah dua hal yang berbeda.  Karena Buildah dirancang untuk membangun gambar, perintah jalankan-nya pada dasarnya sama dengan perintah RUN di Dockerfile.  William Henry, salah satu pengembang Buildah, mengenang bagaimana solusi ini muncul: “Saya entah bagaimana mengeluh bahwa beberapa port atau mount tidak berfungsi sama sekali seperti yang saya harapkan.  Dan Walsh (@rhatdan) menimbang segalanya dan mengatakan bahwa Buildah seharusnya tidak bekerja dengan wadah dengan cara ini sama sekali.  Semua, tidak ada lagi pemetaan port dan tidak ada volume mount.  Kami menghapus flag-flag ini dan menggunakan buildah run sebagai gantinya untuk menjalankan perintah yang diperlukan ketika membangun gambar kontainer, misalnya, buildah run dnf -y install nginx. " </li><li>  Buildah dapat membuat gambar dari awal (scratch image).  Artinya, gambar di mana tidak ada apa-apa, secara harfiah.  Memang, jika Anda melihat penyimpanan kontainer yang dibuat sebagai hasil dari buildah dari perintah awal, akan ada direktori kosong.  Ini sangat berguna dari sudut pandang membuat gambar super ringan yang hanya berisi paket-paket yang diperlukan untuk menjalankan aplikasi. </li></ol><br>  Mengapa membangun dari awal?  Mari kita bandingkan gambar pengembangan aplikasi Java dengan gambarnya untuk lingkungan produksi atau untuk lingkungan pementasan.  Pada tahap pengembangan, gambar mungkin berisi kompiler Java, Maven, dan alat-alat lain yang dibutuhkan pengembang.  Tetapi ketika menerjemahkan ke dalam produksi, hanya Java runtime dan paket Anda harus tetap di dalam gambar.  Dan omong-omong, untuk menghapus berlebihan, Anda tidak perlu manajer paket sama sekali, seperti DNF / YUM, dan Anda bahkan tidak perlu Bash - Anda dapat melakukan segalanya melalui antarmuka Buildah CLI, seperti yang ditunjukkan pada gambar di bawah ini, di mana wadah multilayer tradisional ada di sebelah kiri dan wadah satu lapis berada di sebelah kanan dan wadah satu lapis berada di sebelah kanan. gambar awal.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun Gambar Wadah Buildah untuk Kubernet</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo pengantar Buildah</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">detail</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lanjut</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/kd/w5/qqkdw5dmlj4c5fuyxsi7chc1pew.png"></div><br><br>  Kembali ke kronologi.  Jadi, Kubernetes belajar untuk bekerja dengan CRI-O dan runC, dan untuk build yang kami menumpuk Buildah - semuanya, bisakah Anda menolak dari Docker pada host Kubernet?  Tidak, debugging masih ada.  Bagaimana mengatasi masalah dengan kontainer jika tuan rumah tidak memiliki alat yang sesuai?  Jangan menaruh Docker di atasnya, kalau tidak kita kembali ke setan dan semua upaya sia-sia.  Dan kemudian Podman memasuki lokasi. <br><br>  Artinya, Podman memecahkan dua masalah sekaligus.  Pertama, ini memungkinkan operator TI untuk memeriksa wadah dan gambar menggunakan perintah yang sudah dikenal.  Dan kedua, dia memberikan alat yang sama ini kepada pengembang.  Akibatnya, semua pengguna Docker - baik pengembang maupun operator - dapat beralih ke Podman dan dengan tenang melakukan tugas yang sebelumnya mereka gunakan Docker, serta menyelesaikan serangkaian tugas baru. <br><br><h3>  Sumber daya yang dibutuhkan: </h3><br><ul><li>  Situs web untuk proyek Podman.io dan Buildah.io. </li><li>  Proyek di github.com/containers (terhubung, pelajari sumbernya dan lihat apa yang sedang dikembangkan: <br><ul><li>  libpod (Podman); </li><li>  buildah; </li><li>  gambar (kode untuk bekerja dengan wadah gambar OCI); </li><li>  penyimpanan (kode untuk penyimpanan gambar kontainer lokal). </li></ul><br></li></ul><br><h3>  Tautan yang bermanfaat: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wadah tanpa daemon: Podman dan Buildah tersedia di RHEL 7.6 dan RHEL 8 Beta</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Podman: Mengelola pod dan kontainer dalam runtime kontainer lokal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengelola layanan sistem kemas dengan Podman (Mengelola wadah podman menggunakan systemd)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Membangun Gambar Kontainer Buildah untuk Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Podman sekarang dapat mempermudah transisi ke Kubernetes dan CRI-O</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertimbangan Keamanan untuk Container Runtimes (Perekaman video kinerja Dan Walsh di KubeCon 2018)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan dan penyebaran tepi IoT dengan kontainer melalui OpenShift: Bagian 1 (Merakit dan menguji kontainer ARM64 pada platform OpenShift menggunakan sing podman, qemu, binfmt_misc dan Ansible)</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467105/">https://habr.com/ru/post/id467105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467093/index.html">Memata-matai program Anda dengan Strace</a></li>
<li><a href="../id467095/index.html">Lebih mudah daripada kedengarannya. 20</a></li>
<li><a href="../id467097/index.html">Menggunakan Paging library dengan Realm</a></li>
<li><a href="../id467099/index.html">Hapi untuk anak kecil</a></li>
<li><a href="../id467101/index.html">Epik menciptakan robot dengan aroma anjing</a></li>
<li><a href="../id467107/index.html">Cara menjalankan beberapa saluran pipa menggunakan GitLab CI / CD</a></li>
<li><a href="../id467109/index.html">Bagaimana QA mengatur otomatisasi pengujian pada suatu proyek. Satu cara praktis</a></li>
<li><a href="../id467111/index.html">Kiat radikal tentang cara menggantung lebih sedikit di ponsel Anda</a></li>
<li><a href="../id467113/index.html">Bagaimana cara menjaga pengguna di situs? Rahasia kegunaan</a></li>
<li><a href="../id467115/index.html">“Ls” atipikal - Edisi Habr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>