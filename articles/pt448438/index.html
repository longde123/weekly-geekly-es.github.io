<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üßëüèæ‚Äçü§ù‚ÄçüßëüèΩ üéæ Limitando a velocidade de processamento de solicita√ß√µes ou como n√£o organizar um ataque DDoS ao seu cliente üê¨ üë∂üèª ü§òüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Äs vezes, ao desenvolver um produto de alta carga, surge uma situa√ß√£o em que √© necess√°rio processar n√£o o maior n√∫mero poss√≠vel de solicita√ß√µes, mas l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Limitando a velocidade de processamento de solicita√ß√µes ou como n√£o organizar um ataque DDoS ao seu cliente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448438/"><p> √Äs vezes, ao desenvolver um produto de alta carga, surge uma situa√ß√£o em que √© necess√°rio processar n√£o o maior n√∫mero poss√≠vel de solicita√ß√µes, mas limitar o n√∫mero de solicita√ß√µes por unidade de tempo.  No nosso caso, esse √© o n√∫mero de notifica√ß√µes por push enviadas aos usu√°rios finais.  Leia mais sobre algoritmos de limita√ß√£o de taxa, seus pr√≥s e contras - sob o corte. </p><br><a name="habracut"></a><br><p>  Primeiro, um pouco sobre n√≥s.  Pushwoosh √© um servi√ßo b2b para comunica√ß√£o entre nossos clientes e seus usu√°rios.  Fornecemos √†s empresas solu√ß√µes abrangentes para comunica√ß√£o com os usu√°rios por meio de notifica√ß√µes push, email e outros canais de comunica√ß√£o.  Al√©m de realmente enviar mensagens, oferecemos ferramentas para segmentar o p√∫blico, coletar e processar estat√≠sticas e muito mais.  Para fazer isso, criamos um produto de alta carga na jun√ß√£o de muitas tecnologias, das quais apenas uma pequena parte √© PHP, Golang, PostgreSQL, MongoDB, Apache Kafka.  Muitas de nossas solu√ß√µes s√£o exclusivas, por exemplo, notifica√ß√µes de alta velocidade.  Processamos mais de 2 bilh√µes de solicita√ß√µes de API por dia, temos mais de 3 bilh√µes de dispositivos em nosso banco de dados e, durante todo o tempo, enviamos mais de 500 bilh√µes de notifica√ß√µes para esses dispositivos. </p><br><p>  E aqui chegamos a uma situa√ß√£o em que as notifica√ß√µes precisam ser entregues a milh√µes de dispositivos n√£o o mais r√°pido poss√≠vel (como na j√° mencionada alta velocidade), mas limitando artificialmente a velocidade, para que os servidores de nossos clientes aos quais os usu√°rios acessam quando abrem a notifica√ß√£o n√£o caiam no mesmo tempo carga. <br></p><br><p>  Aqui, v√°rios algoritmos de limita√ß√£o de taxa v√™m em nosso aux√≠lio, o que nos permite limitar o n√∫mero de solicita√ß√µes por unidade de tempo.  Como regra, isso √© usado, por exemplo, ao projetar uma API, pois dessa maneira podemos proteger o sistema contra excesso acidental ou malicioso de solicita√ß√µes, resultando em um atraso ou nega√ß√£o de servi√ßo para outros clientes.  Se a limita√ß√£o de taxa for implementada, todos os clientes ser√£o limitados a um n√∫mero fixo de solicita√ß√µes por unidade de tempo.  Al√©m disso, a limita√ß√£o de taxa pode ser usada ao acessar partes do sistema associadas a dados confidenciais;  Portanto, se um invasor obtiver acesso a eles, n√£o poder√° acessar rapidamente todos os dados. <br></p><br><p>  Existem muitas maneiras diferentes de implementar o limite de taxa.  Neste artigo, consideraremos os pr√≥s e os contras de v√°rios algoritmos, bem como os problemas que podem surgir ao dimensionar essas solu√ß√µes. <br></p><br><h2>  Algoritmos de limite de velocidade de processamento de solicita√ß√µes </h2><br><h3>  Balde com vazamento (balde com vazamento) </h3><br><p>  <i>O Leaky Bucket</i> √© um algoritmo que fornece a abordagem mais simples e intuitiva para limitar a velocidade de processamento usando uma fila, que pode ser representada como um "bucket" contendo solicita√ß√µes.  Quando uma solicita√ß√£o √© recebida, ela √© adicionada ao final da fila.  Em intervalos regulares, o primeiro elemento da fila √© processado.  Isso tamb√©m √© conhecido como fila <abbr title="Primeiro a entrar - Primeiro a sair">FIFO</abbr> .  Se a fila estiver cheia, solicita√ß√µes adicionais ser√£o descartadas (ou "vazadas"). <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fo/jw/hy/fojwhyst1w3e6fij2eh6lsb04y8.gif" alt="Balde de token de renderiza√ß√£o"></div><br><p>  A vantagem desse algoritmo √© que ele suaviza as explos√µes e processa solicita√ß√µes aproximadamente na mesma velocidade, √© f√°cil de implementar em um √∫nico servidor ou balanceador de carga, √© eficiente no uso de mem√≥ria, pois o tamanho da fila para cada usu√°rio √© limitado. <br>  No entanto, com um aumento acentuado no tr√°fego, a fila pode ser preenchida com solicita√ß√µes antigas e privar o sistema da capacidade de processar solicita√ß√µes mais recentes.  Ele tamb√©m n√£o garante que os pedidos sejam processados ‚Äã‚Äãem um hor√°rio fixo.  Al√©m disso, se voc√™ carregar balanceadores para fornecer toler√¢ncia a falhas ou aumentar a taxa de transfer√™ncia, dever√° implementar uma pol√≠tica de coordena√ß√£o e garantir restri√ß√µes globais entre eles. <br></p><br><p>  H√° uma varia√ß√£o desse algoritmo - bucket de <i>token</i> ("bucket com tokens" ou "algoritmo de cesta de marcadores"). <br></p><br><p>  Em tal implementa√ß√£o, os tokens s√£o adicionados ao "bucket" a uma velocidade constante e, ao processar a solicita√ß√£o, o token do "bucket" √© exclu√≠do;  se n√£o houver tokens suficientes, a solicita√ß√£o ser√° descartada.  Voc√™ pode simplesmente usar o registro de data e hora como tokens. <br></p><br><p>  Existem varia√ß√µes usando v√°rios "baldes", enquanto o tamanho e a taxa de recebimento de tokens neles podem ser diferentes para "baldes" individuais.  Se n√£o houver tokens suficientes no primeiro "bucket" para processar a solicita√ß√£o, sua presen√ßa no segundo etc. ser√° verificada, mas a prioridade do processamento da solicita√ß√£o ser√° reduzida (como regra, isso √© usado no design de interfaces de rede quando, por exemplo, voc√™ pode alterar o valor do campo Pacote processado por <abbr title="Ponto de c√≥digo de servi√ßos diferenciados">DSCP</abbr> ). <br></p><br><p>  A principal diferen√ßa da implementa√ß√£o do <i>Leaky Bucket</i> √© que os tokens podem acumular quando o sistema est√° ocioso e as explos√µes podem ocorrer mais tarde, enquanto as solicita√ß√µes ser√£o processadas (j√° que existem tokens suficientes), enquanto o <i>Leaky Bucket √©</i> garantido para suavizar a carga mesmo em caso de inatividade. <br></p><br><h3>  Janela fixa </h3><br><p>  Esse algoritmo usa uma janela de n segundos para rastrear solicita√ß√µes.  Normalmente, valores como 60 segundos (minutos) ou 3600 segundos (hora) s√£o usados.  Cada solicita√ß√£o recebida aumenta o contador dessa janela.  Se o contador exceder um determinado valor limite, a solicita√ß√£o ser√° descartada.  Normalmente, a janela √© determinada pelo limite inferior do intervalo de tempo atual, ou seja, quando a janela tem 60 segundos de largura, a solicita√ß√£o que chega √†s 12:00:03 vai para a janela 12:00:00. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w3/lz/di/w3lzdijb2gk80a6rltf7rs2ejz8.gif" alt="Janela fixa de renderiza√ß√£o"></div><br><p>  A vantagem desse algoritmo √© que ele fornece o processamento de solicita√ß√µes mais recentes, sem depender do processamento de solicita√ß√µes antigas.  No entanto, uma √∫nica explos√£o de tr√°fego perto da borda da janela pode dobrar o n√∫mero de solicita√ß√µes processadas, pois permite solicita√ß√µes para a janela atual e a pr√≥xima janela por um curto per√≠odo de tempo.  Al√©m disso, se muitos usu√°rios estiverem aguardando a redefini√ß√£o do contador de janelas, por exemplo, no final da hora, eles poder√£o provocar um aumento na carga neste momento, devido ao fato de acessar a API ao mesmo tempo. <br></p><br><h3>  Log deslizante </h3><br><p>  Esse algoritmo envolve o rastreamento de registros de data e hora de cada solicita√ß√£o do usu√°rio.  Esses registros s√£o armazenados, por exemplo, em um conjunto ou tabela de hash e classificados por hora;  registros fora do intervalo monitorado s√£o descartados.  Quando chega uma nova solicita√ß√£o, calculamos o n√∫mero de registros para determinar a frequ√™ncia das solicita√ß√µes.  Se a solicita√ß√£o estiver fora da quantidade permitida, ela ser√° descartada. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/8a/9z/nv8a9zz0_ycg7sm4htfair2fk44.gif" alt="Log deslizante de visualiza√ß√£o"></div><br><p>  A vantagem desse algoritmo √© que ele n√£o est√° sujeito a problemas que surgem nas bordas da <i>janela fixa</i> , ou seja, o limite de velocidade ser√° rigorosamente observado.  Al√©m disso, como as solicita√ß√µes de cada cliente s√£o monitoradas individualmente, n√£o h√° crescimento de carga de pico em determinados pontos, o que √© outro problema do algoritmo anterior. <br></p><br><p>  No entanto, o armazenamento de informa√ß√µes sobre cada solicita√ß√£o pode ser caro, al√©m disso, cada solicita√ß√£o exige o c√°lculo do n√∫mero de solicita√ß√µes anteriores, potencialmente em todo o cluster, como resultado da qual essa abordagem n√£o √© escal√°vel para lidar com grandes explos√µes de tr√°fego e ataques de nega√ß√£o de servi√ßo. <br></p><br><h3>  Janela de correr </h3><br><p>  Essa √© uma abordagem h√≠brida que combina o baixo custo de processamento de uma <i>janela fixa</i> e o manuseio avan√ßado de situa√ß√µes de fronteira <i>Sliding Log</i> .  Como na <i>janela fixa</i> simples, rastreamos o contador de cada janela e, em seguida, levamos em conta o valor ponderado da frequ√™ncia de solicita√ß√£o da janela anterior com base no carimbo de data / hora atual para suavizar as explos√µes de tr√°fego.  Por exemplo, se 25% do tempo da janela atual j√° passou, consideramos 75% das solicita√ß√µes da janela anterior.  A quantidade relativamente pequena de dados necess√°rios para rastrear cada chave nos permite dimensionar e trabalhar em um grande cluster. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/yz/ps/jxyzpszmkozfruckcg2s5lhsmd0.gif" alt="Janela deslizante de visualiza√ß√£o"></div><br><p>  Esse algoritmo permite escalar a limita√ß√£o da taxa, mantendo um bom desempenho.  Al√©m disso, √© uma maneira compreens√≠vel de transmitir aos clientes informa√ß√µes sobre como limitar o n√∫mero de solicita√ß√µes e tamb√©m evita os problemas que surgem ao implementar outros algoritmos de limita√ß√£o de taxa. <br></p><br><h2>  Limita√ß√£o de taxas em sistemas distribu√≠dos </h2><br><h3>  Pol√≠ticas de sincroniza√ß√£o </h3><br><p>  Se voc√™ deseja definir a limita√ß√£o da taxa global ao acessar um cluster que consiste em v√°rios n√≥s, √© necess√°rio implementar uma pol√≠tica de restri√ß√£o.  Se cada n√≥ rastreasse apenas sua pr√≥pria restri√ß√£o, o usu√°rio poderia ignor√°-lo simplesmente enviando solicita√ß√µes para n√≥s diferentes.  De fato, quanto maior o n√∫mero de n√≥s, maior a probabilidade de o usu√°rio exceder o limite global. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nb/iq/30/nbiq30phqg_b0zibtuoagajyl50.gif" alt="Visualiza√ß√£o da falta de sincroniza√ß√£o"></div><br><p>  A maneira mais f√°cil de definir limites √© configurar uma "sess√£o permanente" no balanceador para que o usu√°rio seja direcionado para o mesmo n√≥.  As desvantagens desse m√©todo s√£o a falta de toler√¢ncia a falhas e problemas de dimensionamento quando os n√≥s do cluster est√£o sobrecarregados. <br></p><br><p>  A melhor solu√ß√£o, que permite regras mais flex√≠veis para o balanceamento de carga, √© usar um data warehouse centralizado (de sua escolha).  Ele pode armazenar contadores do n√∫mero de solicita√ß√µes para cada janela e usu√°rio.  Os principais problemas dessa abordagem s√£o o aumento do tempo de resposta devido a solicita√ß√µes de armazenamento e condi√ß√µes de corrida. <br></p><br><h3>  Condi√ß√µes da corrida </h3><br><p>  Um dos maiores problemas com um data warehouse centralizado √© a possibilidade de condi√ß√µes de corrida ao competir.  Isso acontece quando voc√™ usa a abordagem natural de obter e definir, na qual extrai o contador atual, incrementa-o e envia o valor resultante de volta para a loja.  O problema com esse modelo √© que, durante o tempo necess√°rio para concluir o ciclo completo dessas opera√ß√µes (isto √©, ler, incrementar e gravar), outras solicita√ß√µes podem ser recebidas, em cada uma das quais o contador ser√° armazenado com um valor (inferior) inv√°lido.  Isso permite que o usu√°rio envie mais solicita√ß√µes do que o algoritmo de limita√ß√£o de taxa fornece. <br></p><br><p>  Uma maneira de evitar esse problema √© definir um bloqueio em torno da chave em quest√£o, impedindo o acesso a ler ou gravar outros processos no contador.  No entanto, isso pode rapidamente se tornar um gargalo de desempenho e n√£o aumenta muito, especialmente ao usar servidores remotos, como Redis, como um armazenamento de dados adicional. <br></p><br><p>  Uma abordagem muito melhor √© o set-then-get, que depende de operadores at√¥micos, o que permite incrementar e verificar rapidamente o contador sem interferir nas opera√ß√µes at√¥micas. <br></p><br><h3>  Otimiza√ß√£o de desempenho </h3><br><p>  Outra desvantagem do uso de um data warehouse centralizado √© o aumento do tempo de resposta devido ao atraso na verifica√ß√£o dos contadores usados ‚Äã‚Äãpara implementar a limita√ß√£o de taxa (tempo de <i>ida e volta</i> ou "atraso de <i>ida e volta</i> ").  Infelizmente, mesmo a verifica√ß√£o de armazenamento r√°pido, como o Redis, resultar√° em atrasos adicionais de alguns milissegundos por solicita√ß√£o. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vn/y_/oc/vny_ocyqyqddljb5lbqnd5wlrgw.gif" alt="Tempo de ida e volta da visualiza√ß√£o"></div><br><p>  Para definir a restri√ß√£o com um atraso m√≠nimo, √© necess√°rio realizar verifica√ß√µes na mem√≥ria local.  Isso pode ser feito relaxando as condi√ß√µes para verificar a velocidade e, eventualmente, usando um modelo consistente. <br></p><br><p>  Por exemplo, cada n√≥ pode criar um ciclo de sincroniza√ß√£o de dados no qual ser√° sincronizado com o reposit√≥rio.  Cada n√≥ transmite periodicamente o valor do contador para cada usu√°rio e a janela que afetou, para o armazenamento, que atualizar√° os valores atomicamente.  Em seguida, o n√≥ pode receber novos valores e atualizar dados na mem√≥ria local.  Esse ciclo permitir√° que todos os n√≥s do cluster estejam atualizados. <br></p><br><p>  O per√≠odo durante o qual os n√≥s s√£o sincronizados deve ser personaliz√°vel.  Intervalos de sincroniza√ß√£o mais curtos levar√£o a menos discrep√¢ncia de dados quando a carga for distribu√≠da igualmente entre v√°rios n√≥s do cluster (por exemplo, no caso em que o balanceador determine os n√≥s de acordo com o princ√≠pio "round-robin"), enquanto intervalos mais longos criar√£o menos carga de leitura / grava√ß√£o para o armazenamento e reduza o custo em cada n√≥ para receber dados sincronizados. <br></p><br><h2>  Compara√ß√£o de algoritmos de limita√ß√£o de taxa </h2><br><p>  Especificamente, no nosso caso, n√£o devemos rejeitar solicita√ß√µes de clientes para a API, mas com base nos dados, pelo contr√°rio, n√£o os criamos;  no entanto, n√£o temos o direito de "perder" solicita√ß√µes.  Para fazer isso, ao enviar uma notifica√ß√£o, usamos o par√¢metro send_rate, que indica o n√∫mero m√°ximo de notifica√ß√µes que enviaremos por segundo ao enviar. <br></p><br><p>  Portanto, temos um certo Trabalhador executando o trabalho no tempo alocado (no meu exemplo, lendo de um arquivo), que recebe a interface RateLimitingInterface como uma entrada, informando se √© poss√≠vel executar uma solicita√ß√£o em um determinado momento e por quanto tempo ela ser√° executada. <br></p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateLimitingInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $rate Expected send rate */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $rate)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> float $currentTime Current timestamp in microseconds * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canDoWork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float $currentTime)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span>; }</code> </pre> <br><p>  Todos os exemplos de c√≥digo podem ser encontrados no GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br></p><br><p>  Explicarei imediatamente por que voc√™ precisa transferir um intervalo de tempo para o Worker.  O fato √© que √© muito caro executar um daemon separado para processar o envio de uma mensagem com um limite de velocidade; portanto, send_rate √© realmente usado como o par√¢metro "n√∫mero de notifica√ß√µes por unidade de tempo", que √© de 0,01 a 1 segundo, dependendo da carga. <br></p><br><p>  De fato, processamos at√© 100 solicita√ß√µes diferentes com send_rate por segundo, alocando 1 / N segundos para processar cada quantum de tempo, em que N √© o n√∫mero de pushs processados ‚Äã‚Äãpor esse daemon.  O par√¢metro mais interessante para n√≥s durante o processamento √© se o send_rate ser√° respeitado (pequenos erros s√£o permitidos em uma dire√ß√£o ou outra) e a carga em nosso hardware (o n√∫mero m√≠nimo de acessos a armazenamentos, CPU e consumo de mem√≥ria). <br></p><br><p>  Para come√ßar, vamos descobrir em que momentos o Worker realmente funciona.  Para simplificar, este exemplo processou um arquivo de 10.000 linhas com send_rate = 1000 (ou seja, lemos 1000 linhas por segundo no arquivo). <br></p><br>  Nas capturas de tela, os marcadores marcam os momentos e o n√∫mero de chamadas de fgets para todos os algoritmos.  Na realidade, isso pode ser um apelo a um banco de dados, a um recurso de terceiros ou a qualquer outra consulta, cujo n√∫mero queremos limitar por unidade de tempo. <br><br><p>  Na escala X - o tempo desde o in√≠cio do processamento, de 0 a 10 segundos, cada segundo √© dividido em d√©cimos, portanto, o cronograma √© de 0 a 100). <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/vk/9u/tbvk9usi0mai17koyki16flm6im.png" alt="Opera√ß√£o de token bucket"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/77/t0/av/77t0avq7kqwhkm_4tqlcurek4qc.png" alt="Opera√ß√£o de algoritmo de janela fixa"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w9/xo/yi/w9xoyihrbuezu0exbewj8mru9mm.png" alt="A opera√ß√£o do algoritmo Sliding Log"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ye/u0/etyeu0hvzzd4hygu8outelbr2ru.png" alt="Opera√ß√£o do algoritmo da janela deslizante"></div><br><p>  Vimos que, apesar de todos os algoritmos lidarem com a observ√¢ncia de send_rate (para isso, eles s√£o destinados), a <i>Janela Fixa</i> e o <i>Log Deslizante</i> "distribuem" toda a carga quase simultaneamente, o que n√£o nos serve muito, enquanto o <i>Token Bucket</i> e <i>Sliding O Windows o</i> distribui uniformemente por unidade de tempo (com exce√ß√£o do pico de carga no momento do in√≠cio, devido √† falta de dados sobre a carga em momentos anteriores). <br></p><br><p>  Como, na realidade, o c√≥digo geralmente n√£o funciona com o sistema de arquivos local, mas com um armazenamento de terceiros, a resposta pode ser adiada, pode haver problemas de rede e muitos outros problemas, tentaremos verificar como esse algoritmo se comportar√° quando as solicita√ß√µes demorarem algum tempo n√£o era.  Por exemplo, ap√≥s 4 e 6 segundos. <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fj/lj/gg/fjljggb06hkp7yannsyvtt3b_rw.png" alt="Atraso na opera√ß√£o do bucket de token"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/jp/nw/qqjpnw6rtcp7wmgmnsu3omlqkrw.png" alt="Janela fixa com atraso"></div><br><p>  Aqui, pode parecer que a <i>Janela Fixa</i> n√£o funcionou corretamente e processou duas vezes mais do que as solicita√ß√µes esperadas no primeiro e de 7 a 8 segundos, mas na verdade n√£o √© assim, pois o tempo √© contado a partir do momento do lan√ßamento no gr√°fico e o algoritmo usa o timestamp atual do unix . <br></p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yh/0k/-k/yh0k-ko8ragfy0mb1n4vcjj8c2o.png" alt="Opera√ß√£o de registro atrasado"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wh/jx/ww/whjxwwdpzkgxx1hikrb2ogpag-o.png" alt="Opera√ß√£o de janela deslizante com atraso"></div><br><p>  Em geral, nada mudou fundamentalmente, mas vemos que o <i>Token Bucket</i> suaviza a carga mais suavemente e nunca excede o limite de taxa especificado, mas o <i>Log Deslizante</i> em caso de inatividade pode exceder o valor permitido. <br></p><br><h2>  Conclus√£o </h2><br><p>  Examinamos todos os algoritmos b√°sicos para implementar a limita√ß√£o de taxa, cada um com seus pr√≥s e contras e √© adequado para v√°rias tarefas.  Esperamos que, depois de ler este artigo, voc√™ escolha o algoritmo mais adequado para resolver seu problema. <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448438/">https://habr.com/ru/post/pt448438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448424/index.html">55 anos depois: ic√¥nicos consoles de cult de mainframe IBM System / 360</a></li>
<li><a href="../pt448430/index.html">Pro Content 2019: tr√™s relat√≥rios r√≠gidos e detalhados</a></li>
<li><a href="../pt448432/index.html">Radia√ß√£o adesiva: radioatividade induzida, contamina√ß√£o radioativa, descontamina√ß√£o ...</a></li>
<li><a href="../pt448434/index.html">Principais empresas de desenvolvimento de aplicativos para dispositivos m√≥veis</a></li>
<li><a href="../pt448436/index.html">Camada de convolu√ß√£o: t√©cnicas de otimiza√ß√£o de multiplica√ß√£o de matrizes</a></li>
<li><a href="../pt448440/index.html">Centenas de milhares de pagamentos feitos por cidad√£os ao STSI e ao FSSP eram de dom√≠nio p√∫blico</a></li>
<li><a href="../pt448442/index.html">SSD GIGABYTE Aorus RGB M.2: pequeno e remoto para LEDs RGB (1 parte)</a></li>
<li><a href="../pt448444/index.html">Livrar-se do medo do primeiro emprego</a></li>
<li><a href="../pt448448/index.html">Relat√≥rio SWIFT: O volume de fundos roubados por hackers de bancos diminuiu dez vezes tr√™s anos ap√≥s o hack em US $ 100 milh√µes</a></li>
<li><a href="../pt448450/index.html">Ferramentas de an√°lise da Web para comerciantes iniciantes, comerciantes de produtos e an√°lises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>