<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏿 👍🏻 👃🏽 Web Worker plus facile que vous ne le pensiez 👨‍🔬 👩‍🌾 👁‍🗨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, une méthode <em>eval</em> sale, dangereuse, instable et effrayante sera décrite. Donc, si vous n'êtes pas à l'aise avec cela, arrête...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Web Worker plus facile que vous ne le pensiez</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/462325/"><p><img src="https://habrastorage.org/webt/ve/ti/ox/vetioxg-vqohhdt25j7qmzayvww.jpeg" alt="Web Worker plus facile que vous ne le pensiez"></p><br><p> Dans cet article, une méthode <code>&lt;em&gt;eval&lt;/em&gt;</code> sale, dangereuse, instable et effrayante sera décrite.  Donc, si vous n'êtes pas à l'aise avec cela, arrêtez de lire maintenant. </p><br><p>  Tout d'abord, certains problèmes de commodité n'ont pas été résolus: dans le code envoyé aux travailleurs Web, la fermeture ne peut pas être utilisée. </p><br><hr><br><p>  Nous aimons tous les nouvelles technologies et nous aimons tous que les nouvelles technologies soient pratiques à utiliser.  Cependant, ce n'est pas exactement le cas avec les travailleurs du Web.  les travailleurs Web acceptent des fichiers ou des liens vers des fichiers, ce qui n'est pas pratique.  Il serait bon de pouvoir confier n'importe quelle tâche aux travailleurs Web, pas seulement du code spécifiquement planifié. </p><br><p>  De quoi avons-nous besoin pour rendre les travailleurs du Web plus pratiques à utiliser?  Je crois que c'est la suivante: </p><br><ul><li>  Une possibilité de lancer dans les travailleurs Web n'importe quel code à tout moment </li><li>  Une possibilité d'envoyer aux travailleurs Web des données compliquées (instances de classe, fonctions) </li><li>  Une possibilité de recevoir une promesse avec une réponse d'un web travailleur. </li></ul><a name="habracut"></a><br><p>  Essayons de l'écrire.  Pour commencer, nous aurons besoin d'un protocole de communication entre un travailleur Web et la fenêtre principale.  En général, un protocole n'est qu'une structure et des types de données utilisés pour la communication entre une fenêtre de navigateur et un travailleur Web.  C'est assez simple.  Vous pouvez l'utiliser ou écrire votre propre version.  Chaque message aura un ID et des données typiques d'un type de message spécifique.  Au départ, nous aurons deux types de messages pour les travailleurs Web: </p><br><ul><li>  Ajout de bibliothèques / fichiers à un travailleur Web </li><li>  Lancer. </li></ul><br><h2 id="a-file-that-will-be-inside-a-web-worker">  Un fichier qui sera à l'intérieur d'un travailleur Web </h2><br><p>  Avant d'écrire un travailleur Web, nous devons décrire un fichier qui s'y trouvera, prenant en charge le protocole décrit ci-dessus.  J'aime la programmation orientée objet (POO), donc ce sera une classe nommée workerBody.  Cette classe doit s'abonner à un événement depuis la fenêtre parent. </p><br><pre> <code class="javascript hljs">self.onmessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessage(message.data); };</code> </pre><br><p>  Nous pouvons maintenant écouter les événements de la fenêtre parent.  Nous avons deux types d'événements: ceux qui impliquent une réponse et tout le reste.  Faisons des événements: \ <br>  Les bibliothèques et les fichiers sont ajoutés à un travailleur Web à l'aide de l'API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">importScripts</a> . </p><br><p>  Et maintenant la partie la plus effrayante: pour lancer une fonction aléatoire, nous utiliserons <em>eval</em> . </p><br><pre> <code class="javascript hljs">... onMessage(message) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.ADD_LIBS: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addLibs(message.libs); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.WORK: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doWork(message); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } doWork(message) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processor = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(message.job); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parser.parse(message.params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = processor(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &amp;&amp; result.then &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> result.then === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { result.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: data }); }, (error) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { error = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(error); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: error }); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: result }); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }); } } send(data) { data.body = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._serializer.serialize(data.body); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { self.postMessage(data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toSet = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: data.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }; self.postMessage(toSet); } }</code> </pre> <br><p>  La méthode <em>onMessage</em> est chargée de recevoir un message et de choisir un gestionnaire, <em>doWork</em> lance une fonction envoyée et <em>envoie</em> envoie une réponse à la fenêtre parent. </p><br><h2 id="parser-and-serializer">  Analyseur et sérialiseur </h2><br><p>  Maintenant que nous avons le contenu du travailleur Web, nous devons apprendre à sérialiser et analyser toutes les données, afin qu'elles puissent être envoyées au travailleur Web.  Commençons par un sérialiseur.  Nous voulons pouvoir envoyer au travailleur Web toutes les données, y compris les instances de classe, les classes et les fonctions, tandis que la capacité native du travailleur Web permet d'envoyer uniquement des données de type JSON.  Pour contourner cela, nous aurons besoin de _ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">eval</a> _.  Nous encapsulerons toutes les données que JSON ne peut pas accepter dans les structures de piqûres correspondantes et les lancerons de l'autre côté.  Pour préserver l'immuabilité, les données reçues seront clonées à la volée, remplaçant tout ce qui ne peut pas être sérialisé par des méthodes ordinaires par des objets de service, qui seront remplacés de l'autre côté par un analyseur.  À première vue, cette tâche n'est pas difficile, mais il existe de nombreux pièges.  La limitation la plus effrayante de cette approche est l'incapacité à utiliser la fermeture, ce qui conduit à un style d'écriture de code légèrement différent.  Commençons par la partie la plus simple, la fonction.  Tout d'abord, nous devons apprendre à distinguer une fonction d'un constructeur de classe.  Faisons ça: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isFunction(Factory){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Factory.prototype) { <span class="hljs-comment"><span class="hljs-comment">// Arrow function has no prototype return true; } const prototypePropsLength = Object.getOwnPropertyNames(Factory.prototype) .filter(item =&gt; item !== 'constructor') .length; return prototypePropsLength === 0 &amp;&amp; Serializer.getClassParents(Factory).length === 1; } static getClassParents(Factory) { const result = [Factory]; let tmp = Factory; let item = Object.getPrototypeOf(tmp); while (item.prototype) { result.push(item); tmp = item; item = Object.getPrototypeOf(tmp); } return result.reverse(); }</span></span></code> </pre><br><p>  Tout d'abord, nous allons vérifier si la fonction a un prototype.  Si ce n'est pas le cas, c'est certainement une fonction.  Ensuite, nous regardons le nombre de fonctionnalités du prototype.  Si elle n'a qu'un constructeur et que la fonction n'est pas le successeur d'une autre classe, nous la considérons comme une fonction. </p><br><p>  Lorsque nous découvrons une fonction, nous la remplaçons simplement par un objet de service avec les champs __type = "serialized-function" et le modèle correspond au modèle de cette fonction (func.toString ()). </p><br><p>  Pour l'instant, nous allons sauter la classe et regarder l'instance de classe.  Plus tard, nous devrons faire la distinction entre les objets normaux et les instances de classe. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isInstance(some) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> = some.<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>; if (!<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !Serializer.isNative(<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); } static isNative(data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/function .*?\(\) \{ \[native code\] \}/</span></span>.test(data.toString()); }</code> </pre> <br><p>  Nous pensons qu'un objet est régulier s'il n'a pas de constructeur ou si son constructeur est une fonction native.  Une fois que nous avons découvert une instance de classe, nous la remplacerons par un objet de service avec les champs suivants: </p><br><ul><li>  __type: 'instance-sérialisée' </li><li>  les données sont des données contenues dans l'instance </li><li>  index est l'index de classe de cette instance dans la liste des classes de service. </li></ul><br><p>  Pour envoyer des données, nous devons créer un champ supplémentaire, dans lequel nous stockons une liste des classes uniques que nous envoyons.  Cependant, il y a un défi: découvrir une classe, nous devons prendre non seulement son modèle, mais aussi les modèles de toutes les classes parentes et les enregistrer en tant que classes indépendantes, de sorte que chaque classe parente n'est envoyée qu'une seule fois, ce qui permet également d'économiser instanceof proof.  La découverte d'une classe est facile: c'est une fonction qui a échoué à notre preuve Serializer.isFunction.  Lors de l'ajout d'une classe, nous vérifions la présence de cette classe dans la liste des données sérialisées et n'ajoutons que des classes uniques.  Le code qui assemble une classe dans un modèle est assez volumineux et est disponible <a href="">ici</a> . </p><br><p>  Dans l'analyseur, nous vérifions d'abord toutes les classes qui nous sont envoyées et les compilons si elles n'ont pas été envoyées.  Ensuite, nous vérifions récursivement chaque champ de données et remplaçons les objets de service par des données compilées.  La partie la plus intéressante est les instances de classe.  Nous avons une classe et des données qui étaient dans son instance, mais nous ne pouvons pas simplement créer une instance car une demande de constructeur peut nécessiter des paramètres que nous n'avons pas.  Nous obtenons cela de la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Object.create</a> presque oubliée, qui crée un objet avec un prototype défini.  De cette façon, nous évitons de demander un constructeur, obtenons une instance de classe et copions simplement les propriétés dans l'instance. </p><br><h2 id="creating-a-web-worker">  Création d'un travailleur Web </h2><br><p>  Pour qu'un travailleur Web fonctionne correctement, nous avons besoin d'un analyseur et d'un sérialiseur au sein du travailleur Web et à l'extérieur.  Nous prenons donc un sérialiseur et le transformons, l'analyseur et le corps du travailleur Web en modèle.  À partir du modèle, nous créons un blob et créons un lien de téléchargement sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">URL.createObjectURL</a> (cette méthode peut ne pas fonctionner pour certaines «Content-Security-Policy»).  Cette méthode est également utile pour lancer du code aléatoire à partir d'une chaîne. </p><br><pre> <code class="javascript hljs">_createworker(customworker) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = <span class="hljs-string"><span class="hljs-string">`var Myworker = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._createTemplate(customworker)}</span></span></span><span class="hljs-string">;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([template], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> worker(URL.createObjectURL(blob)); } _createTemplate(workerBody) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Name = Serializer.getFnName(workerBody); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Name) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unnamed worker Body class! Please add name to worker Body class!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'(function () {'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Serializer, <span class="hljs-string"><span class="hljs-string">'Serializer'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Parser, <span class="hljs-string"><span class="hljs-string">'Parser'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(workerBody, <span class="hljs-string"><span class="hljs-string">'workerBody'</span></span>), <span class="hljs-string"><span class="hljs-string">`return new workerBody(Serializer, Parser)})();`</span></span> ].join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); }</code> </pre><br><h2 id="outcome">  Résultat </h2><br><p>  Nous avons donc obtenu une bibliothèque simple à utiliser qui peut envoyer n'importe quel code au travailleur Web.  Il prend en charge les classes TypeScript, par exemple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = workerWrapper.create(); wrapper.process(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This code in worker. Cannot use closure! // do some hard work return 100; // or return Promise.resolve(100) }, params).then((result) =&gt; { // result = 100; }); wrapper.terminate() // terminate for kill worker process</span></span></code> </pre> <br><h2 id="future-development">  Développement futur </h2><br><p>  Malheureusement, cette bibliothèque est loin d'être idéale.  Nous devons ajouter le support des setters et des getters pour les classes, les objets, les prototypes et les fonctionnalités statiques.  En outre, nous devons ajouter la mise en cache, un lancement de script alternatif sans <em>eval</em> , en utilisant <code>URL.createObjectURL</code> place.  Enfin, un fichier avec le contenu du travailleur Web doit être ajouté à l'assemblage (au cas où la création à la volée n'est pas disponible), etc.  Visitez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462325/">https://habr.com/ru/post/fr462325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462313/index.html">Trucs et astuces de ma chaîne Telegram @pythonetc, juillet 2019</a></li>
<li><a href="../fr462315/index.html">Efficacité énergétique des bureaux: comment réduire la consommation énergétique réelle?</a></li>
<li><a href="../fr462317/index.html">Conseils pour optimiser votre architecture Laravel avec AWS</a></li>
<li><a href="../fr462321/index.html">Référencement international | Facteurs de classement SEO internationaux</a></li>
<li><a href="../fr462323/index.html">Obésité - Détendez-vous et impliquez</a></li>
<li><a href="../fr462327/index.html">Squeak d'une tumeur cancéreuse: les scientifiques de NUST «MISiS» ont développé une échographie laser pour le diagnostic du cancer</a></li>
<li><a href="../fr462329/index.html">Déplacement du bloc d'alimentation vers l'avant du châssis</a></li>
<li><a href="../fr462331/index.html">Jouet GAZ-66 sur le panneau de commande. 2e partie</a></li>
<li><a href="../fr462333/index.html">Création d'un chatbot de conversation simple en python</a></li>
<li><a href="../fr462335/index.html">Ne pas lire, relire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>