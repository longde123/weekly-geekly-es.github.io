<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≠ üëºüèª üëáüèª Questions de partage de vie üèáüèø üà≤ üï¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chaque d√©veloppeur a pos√© des questions sur le cycle de vie de l'activit√©: qu'est-ce qu'un service de liaison, comment enregistrer l'√©tat de l'interfa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Questions de partage de vie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/426215/"><img src="https://habrastorage.org/webt/iq/rl/ci/iqrlcirhwliuqufp0rlca6brqfk.jpeg"><br><br><p>  Chaque d√©veloppeur a pos√© des questions sur le cycle de vie de l'activit√©: qu'est-ce qu'un service de liaison, comment enregistrer l'√©tat de l'interface lorsque l'√©cran est pivot√© et en quoi le fragment diff√®re de l'activit√©. <br>  Chez FunCorp, nous avons accumul√© une liste de questions sur des sujets similaires, mais avec certaines nuances.  Je veux en partager certains avec vous. </p><a name="habracut"></a><br><p>  <strong>1.</strong> Tout le monde sait que si vous ouvrez la deuxi√®me activit√© au-dessus de la premi√®re et faites pivoter l'√©cran, la cha√Æne d'appels du cycle de vie ressemblera √† ceci: </p><br><div class="spoiler">  <b class="spoiler_title">Activit√© d'ouverture</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Tourner</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Retour en arri√®re</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> </p></div></div><br><p>  Et que se passera-t-il si la deuxi√®me activit√© est transparente? </p><br><p>  <strong>Solution</strong> </p><br><p>  Dans le cas d'une activit√© top transparente, en termes de logique, tout est l√©g√®rement diff√©rent.  Pr√©cis√©ment parce qu'il est transparent, apr√®s la rotation, il faut restaurer le contenu et l'activit√© qui se trouve directement en dessous.  Par cons√©quent, l'ordre des appels sera l√©g√®rement diff√©rent: </p><br><div class="spoiler">  <b class="spoiler_title">Activit√© d√©couverte</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Tourner</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>FirstActivity: onResume</em> <em><br></em>  <em>FirstActivity: onPause</em> </p></div></div><br><p>  <strong>2.</strong> Aucune application ne peut se passer de l'ajout dynamique d'une vue, mais il faut parfois d√©placer la m√™me vue entre diff√©rents √©crans.  Le m√™me objet peut-il √™tre ajout√© simultan√©ment √† deux activit√©s diff√©rentes?  Que se passe-t-il si je le cr√©e avec le contexte de l'application et que je souhaite l'ajouter √† diff√©rentes activit√©s en m√™me temps? </p><br><p>  <strong>Pourquoi est-ce n√©cessaire?</strong> <br>  Il existe des biblioth√®ques ¬´peu agr√©ables¬ª qui contiennent une logique m√©tier importante dans les vues personnalis√©es, et recr√©er ces vues au sein de chaque nouvelle activit√© est une mauvaise d√©cision, car  Je veux avoir un seul ensemble de donn√©es. </p><br><p><img src="https://habrastorage.org/webt/zs/-e/zk/zs-ezkaoyfadfd-xmrh-fhbm0pa.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/_r/yz/ie/_ryzienmkhodnc2lqx8mqiouj44.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/lz/y1/6g/lzy16g4ls7spgu9jqs8dqbpiaaa.jpeg" width="200" height="350"></p><br><p>  <strong>Solution</strong> </p><br><p>  Rien n'emp√™che de cr√©er une vue avec le contexte de l'application.  Il appliquera simplement des styles par d√©faut qui ne sont li√©s √† aucune activit√©.  Vous pouvez √©galement d√©placer cette vue entre diff√©rentes activit√©s sans probl√®me, mais vous devez vous assurer qu'elle est ajout√©e √† un seul parent </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addViewInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, LayoutParams params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> preventRequestLayout)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child.getParent() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"The specified child already has a parent. "</span></span> + <span class="hljs-string"><span class="hljs-string">"You must call removeView() on the child's parent first."</span></span>); } ... }</code> </pre> <br><p>  Vous pouvez, par exemple, vous abonner √† ActivityLifecycleCallbacks, supprimer onStop (removeView) de l'activit√© en cours, ajouter onStart √† la prochaine ouverture (addView). </p><br><p>  <strong>3. Le</strong> fragment peut √™tre ajout√© par ajout et remplacement.  Et quelle est la diff√©rence entre ces deux options en termes d'ordre d'appeler les m√©thodes du cycle de vie?  Quels sont les avantages de chacun d'eux? </p><br><p>  <strong>Solution</strong> </p><br><p>  M√™me si vous ajoutez un fragment via replace, cela ne signifie pas qu'il est compl√®tement remplac√©.  Cela signifie qu'√† ce stade du conteneur, sa vue sera remplac√©e, par cons√©quent, onDestroyView sera appel√© pour le fragment actuel et onCreateView sera appel√© √† nouveau lors du retour. </p><br><br><p>  Cela change √† peu pr√®s les r√®gles du jeu.  Vous devez d√©tacher tous les contr√¥leurs et classes associ√©s √† l'interface utilisateur dans onDestroyView.  Il est n√©cessaire de s√©parer clairement la r√©ception des donn√©es n√©cessaires au fragment et le remplissage de la vue (listes, etc.), car le remplissage et la rupture de la vue auront lieu beaucoup plus souvent que la r√©ception de donn√©es (lecture de certaines donn√©es de la base de donn√©es). </p><br><p>  Il existe √©galement des nuances avec la r√©cup√©ration d'√©tat: par exemple, onSaveInstanceState vient parfois apr√®s onDestroyView.  En outre, il convient de garder √† l'esprit que si null est entr√© dans onViewStateRestored, cela signifie que vous n'avez pas besoin de restaurer quoi que ce soit, mais pas de r√©initialiser √† l'√©tat par d√©faut. </p><br><p>  Si nous parlons de la commodit√© entre l'ajout et le remplacement, alors le remplacement est plus √©conomique en m√©moire si vous avez une navigation profonde (nous avons une profondeur de navigation utilisateur de l'un des KPI du produit).  Il est √©galement beaucoup plus pratique de remplacer la barre d'outils par replace, car dans onCreateView vous pouvez la r√©injecter.  Parmi les avantages de l'ajout: moins de probl√®mes avec le cycle de vie, lorsque vous revenez, je ne recr√©e pas la vue et je n'ai pas besoin de remplir quoi que ce soit. </p><br><p>  <strong>4.</strong> Parfois, vous devez toujours travailler directement avec les services et m√™me avec les services de liaison.  L'activit√© interagit avec l'un de ces services (une seule activit√©).  Il se connecte au service et y transf√®re des donn√©es.  Lorsque vous tournez l'√©cran, notre activit√© est d√©truite, et nous sommes oblig√©s de rebondir de ce service.  Mais s'il n'y a pas de connexion, le service est d√©truit, et apr√®s avoir tourn√©, bind sera un service compl√®tement diff√©rent.  Comment vous assurer que lorsque vous activez le service reste en ligne? </p><br><p>  <strong>Solution</strong> </p><br><p>  Si vous connaissez une belle solution, √©crivez dans les commentaires.  Seulement quelque chose de similaire me vient √† l'esprit: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); ThreadsUtils.postOnUiThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ unbindService(mConnection); } }); }</code> </pre> <br><p>  <strong>5.</strong> R√©cemment, nous avons refait la navigation √† l'int√©rieur de notre application sur Single Activity (en utilisant l'une des biblioth√®ques disponibles).  Auparavant, chaque √©cran d'application √©tait une activit√© distincte, maintenant la navigation fonctionne sur des fragments.  Le probl√®me du retour √† l'activit√© au milieu de la pile a √©t√© r√©solu par des drapeaux d'intention.  Comment puis-je retourner au fragment au milieu de la pile? </p><br><p>  <strong>Solution</strong> </p><br><p>  Oui, FragmentManager ne fournit pas de solutions pr√™tes √† l'emploi.  Cicerone fait quelque chose de similaire en lui-m√™me: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BackTo command)</span></span></span><span class="hljs-function"> </span></span>{ String key = command.getScreenKey(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { backToRoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = localStackCopy.indexOf(key); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = localStackCopy.size(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size - index; i++) { localStackCopy.pop(); } fragmentManager.popBackStack(key, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { backToUnexisting(command.getScreenKey()); } } }</code> </pre> <br><p>  <strong>6.</strong> En outre, nous nous sommes r√©cemment d√©barrass√©s d'un composant aussi inefficace et complexe que ViewPager, car la logique d'interaction avec lui est tr√®s compliqu√©e et le comportement des fragments est impr√©visible dans certains cas.  Dans certains fragments, nous avons utilis√© des fragments internes.  Que se passe-t-il lors de l'utilisation de fragments dans des √©l√©ments RecycleView? </p><br><p>  <strong>Solution</strong> </p><br><p>  En g√©n√©ral, il n'y aura rien de mal.  Le fragment sera ajout√© et affich√© sans aucun probl√®me.  La seule chose √† laquelle nous sommes confront√©s est des incoh√©rences avec son cycle de vie.  L'impl√©mentation sur ViewPager g√®re le cycle de vie des fragments via setUserVisibleHint, et RecycleView fait tout le front sans penser √† la visibilit√© et √† l'accessibilit√© r√©elles des fragments. </p><br><p>  <strong>7.</strong> Pour la m√™me raison que nous sommes pass√©s de ViewPager, nous avons rencontr√© le probl√®me de la restauration de l'√©tat.  Dans le cas des fragments, cela a √©t√© mis en ≈ìuvre par le framework: aux bons endroits, nous avons simplement red√©fini onSaveInstanceState et enregistr√© toutes les donn√©es n√©cessaires dans le Bundle.  Lorsque vous recr√©ez le ViewPager, tous les fragments ont √©t√© restaur√©s par le FragmentManager et ont renvoy√© leur √©tat.  Que faire avec RecycleView et son ViewHolder? </p><br><p>  <strong>Solution</strong> </p><br><p>  ¬´Vous devez tout √©crire dans la base de donn√©es et y lire √† chaque fois¬ª, dites-vous.  Ou la logique d'enregistrement de l'√©tat doit √™tre ext√©rieure et la liste n'est qu'un affichage.  Dans un monde id√©al, c'est.  Mais dans notre cas, chaque √©l√©ment de la liste est un √©cran complexe avec sa propre logique.  Par cons√©quent, j'ai d√ª inventer mon v√©lo dans le style "faisons la m√™me logique que dans le ViewPager et fragment": </p><br><div class="spoiler">  <b class="spoiler_title">Adaptateur</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecycleViewGalleryAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclerView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Adapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryItemViewHolder</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String RV_STATE_KEY = <span class="hljs-string"><span class="hljs-string">"RV_STATE"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bundle mSavedState; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder.isAttached()) { holder.detach(); } holder.attach(createArgs(position, getItemViewType(position))); restoreItemState(holder); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Bundle adapterState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); saveItemsState(adapterState); bundle.putBundle(RV_STATE_KEY, adapterState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bundle == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mSavedState = bundle.getBundle(RV_STATE_KEY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mSavedState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } String stateKey = String.valueOf(holder.getGalleryItemId()); Bundle state = mSavedState.getBundle(stateKey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mSavedState = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } holder.restoreState(state); mSavedState.remove(stateKey); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemsState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ GalleryItemHolder holder = getCurrentGalleryViewItem(); saveItemState(outState, (GalleryItemViewHolder) holder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle, GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Bundle itemState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); holder.saveState(itemState); bundle.putBundle(String.valueOf(holder.getGalleryItemId()), itemState); } }</code> </pre> </div></div><br><p>  √Ä Fragment.onSaveInstanceState, nous lisons l'√©tat des supports dont nous avons besoin et les mettons dans le Bundle.  Lors de la recr√©ation des supports, nous obtenons le bundle enregistr√© et sur onBindViewHolder nous passons les √©tats trouv√©s √† l'int√©rieur des supports: </p><br><p>  <strong>8.</strong> De quoi cela nous menace-t-il? </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity); ViewGroup root = findViewById(R.id.default_id); ViewGroup view1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinearLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view1.setId(R.id.default_id); root.addView(view1); ViewGroup view2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view2.setId(R.id.default_id); view1.addView(view2); ViewGroup view3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RelativeLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view3.setId(R.id.default_id); view2.addView(view3); }</code> </pre> <br><p>  <strong>Solution</strong> </p><br><p>  En fait, il n'y a rien de mal √† cela.  Dans la m√™me RecycleView, les listes d'√©l√©ments avec le m√™me identifiant sont stock√©es.  Cependant, il y a encore une petite nuance: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends View&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findViewTraversal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@IdRes </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == mID) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View[] where = mChildren; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = mChildrenCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { View v = where[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { v = v.findViewById(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) v; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  Cela devrait √™tre soigneusement si nous avons des √©l√©ments avec le m√™me identifiant dans la hi√©rarchie, car  c'est toujours le premier √©l√©ment trouv√© qui est toujours renvoy√©, et √† diff√©rents niveaux de l'appel findViewById, il peut s'agir d'objets diff√©rents. </p><br><p>  <strong>9.</strong> Vous tombez de TooLargeTransaction lorsque vous faites pivoter l'√©cran (oui, ici notre ViewPager est toujours indirectement √† bl√¢mer).  Comment trouver le coupable? </p><br><p>  <strong>Solution</strong> </p><br><p>  Tout est assez simple: bloquez ActivityLifecycleCallbacks sur l'application, interceptez tout onActivitySaveInstanceState et analysez tout ce qui se trouve √† l'int√©rieur du bundle.  L√†, vous pouvez obtenir le statut de toutes les vues et de tous les fragments √† l'int√©rieur de cette activit√©. </p><br><p>  Voici un exemple de la fa√ßon dont nous obtenons l'√©tat des fragments du bundle: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Tries to find saved [FragmentState] in bundle using 'android:support:fragments' key. */</span></span> fun Bundle.getFragmentsStateList(): List&lt;FragmentBundle&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val fragmentManagerState: FragmentManagerState? = getParcelable(<span class="hljs-string"><span class="hljs-string">"android:support:fragments"</span></span>) val active = fragmentManagerState?.mActive ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyList() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> active.filter { it.mSavedFragmentState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }.map { fragmentState -&gt; FragmentBundle(fragmentState.mClassName, fragmentState.mSavedFragmentState) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Assert.fail(throwable) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ application.registerActivityLifecycleCallbacks(object : SimpleActivityLifecycleCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivitySaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle?)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onActivitySaveInstanceState(activity, outState) outState?.let { ThreadsUtils.runOnMainThread { trackActivitySaveState(activity, outState) } } } }) } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackActivitySaveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle)</span></span></span><span class="hljs-function"> </span></span>{ val sizeInBytes = outState.getSizeInBytes() val fragmentsInfos = outState.getFragmentsStateList() ?.map { mapFragmentsSaveInstanceSaveInfo(it) } ... }</code> </pre> <br><p>  Ensuite, nous calculons simplement la taille du Bundle et l'enregistrons: </p><br><pre> <code class="java hljs"> fun Bundle.getSizeInBytes(): Int { val parcel = Parcel.obtain() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parcel.writeValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) parcel.dataSize() } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { parcel.recycle() } }</code> </pre><br><p>  <strong>10.</strong> Supposons que nous ayons une activit√© et un ensemble de d√©pendances sur elle.  Dans certaines conditions, nous devons recr√©er un ensemble de ces d√©pendances (par exemple, en cliquant sur une certaine exp√©rience avec une autre interface utilisateur).  Comment mettons-nous cela en ≈ìuvre? </p><br><p>  <strong>Solution</strong> </p><br><p>  Bien s√ªr, vous pouvez bricoler avec des drapeaux et en faire une sorte de red√©marrage ¬´b√©quille¬ª de l'activit√© gr√¢ce au lancement de l'intention.  Mais en fait, tout est tr√®s simple - l'activit√© a une m√©thode de recr√©ation. </p><br><p>  Tr√®s probablement, la plupart de ces connaissances ne vous seront pas utiles, car vous ne venez pas √† chacun d'eux d'une bonne vie.  Cependant, certains d'entre eux montrent bien comment une personne sait raisonner et proposer des solutions.  Nous utilisons des questions similaires dans les entretiens.  Si vous avez des t√¢ches int√©ressantes que l'on vous a demand√© de r√©soudre lors des entretiens, ou si vous les d√©finissez vous-m√™me, √©crivez-les dans les commentaires - ce sera int√©ressant √† discuter! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426215/">https://habr.com/ru/post/fr426215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426205/index.html">Avec la sortie de Chrome, 70 000 sites prot√©g√©s par des certificats Symantec ne seront plus fiables</a></li>
<li><a href="../fr426207/index.html">Il fera bient√¥t froid: apprenez √† conna√Ætre Pekatherm et choisissez des gants chauffants</a></li>
<li><a href="../fr426209/index.html">PeerTube 1.0: h√©bergement vid√©o sans centre de donn√©es et co√ªts d'investissement</a></li>
<li><a href="../fr426211/index.html">Allez vs Javascript. Comment √©crire des projets IoT</a></li>
<li><a href="../fr426213/index.html">Un groupe d'employ√©s de la station-service a √©t√© arr√™t√©, qui, √† l'aide de logiciels et d'√©lectronique, a corrig√© et organis√© 5% en ne faisant pas le plein √† la station-service</a></li>
<li><a href="../fr426217/index.html">Comment la s√©curit√© de votre syst√®me d'exploitation Windows est-elle organis√©e?</a></li>
<li><a href="../fr426223/index.html">D√©veloppement Android et r√©solution des probl√®mes de d√©veloppement</a></li>
<li><a href="../fr426227/index.html">Comment "cultiver" Kaggle</a></li>
<li><a href="../fr426229/index.html">Code de conduite: Pourquoi les d√©veloppeurs de noyau Linux menac√©s de supprimer leur code - Comprendre le conflit</a></li>
<li><a href="../fr426231/index.html">La Grande-Bretagne veut r√©glementer Internet - quelles nouvelles lois affecteront</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>