<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👾 🐻 💛 Análise de abordagens de ligação de módulo no Node.js 👨🏼‍🔬 🌛 📯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muitos desenvolvedores do Node.js. usam dependências físicas do módulo (exclusivamente) usando o require () para ligar módulos, mas há outras abordage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Análise de abordagens de ligação de módulo no Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438546/"> Muitos desenvolvedores do Node.js. usam dependências físicas do módulo (exclusivamente) usando o require () para ligar módulos, mas há outras abordagens com seus prós e contras.  Vou falar sobre eles neste artigo.  Quatro abordagens serão consideradas: <br><br><ul><li>  Dependências rígidas (require ()) </li><li>  Injeção de Dependência </li><li>  Localizador de Serviços </li><li>  Contêineres de dependência incorporados (contêiner DI) </li></ul><a name="habracut"></a><br><h4>  Um pouco sobre módulos </h4><br>  Módulos e arquitetura modular são a base do Node.js.  Os módulos fornecem encapsulamento (ocultando detalhes de implementação e abrindo apenas a interface usando module.exports), reutilização de código, divisão lógica em arquivos.  Quase todos os aplicativos Node.js consistem em muitos módulos que precisam interagir de alguma forma.  Se você vincular incorretamente os módulos ou até deixar a interação dos módulos desviar, poderá descobrir rapidamente que o aplicativo começa a "desmoronar": alterações no código em um local levam a uma quebra em outro e o teste de unidade se torna simplesmente impossível.  Idealmente, os módulos devem ter alta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conectividade</a> , mas baixo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acoplamento</a> . <br><br><h2>  Vícios difíceis </h2><br>  Uma forte dependência de um módulo em outro ocorre quando require () é usado.  Essa é uma abordagem eficaz, simples e comum.  Por exemplo, queremos apenas conectar o módulo responsável pela interação com o banco de dados: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js const db = require('db'); //    ...</span></span></code> </pre> <br><h4>  Prós: </h4><br><ul><li>  Simplicidade </li><li>  Organização visual dos módulos </li><li>  Depuração fácil </li></ul><br><h4>  Contras: </h4><br><ul><li>  Dificuldade para reutilizar o módulo (por exemplo, se quisermos usar nosso módulo repetidamente, mas com uma instância diferente do banco de dados) </li><li>  Dificuldade para teste de unidade (você precisa criar uma instância de banco de dados fictícia e, de alguma forma, passá-la ao módulo) </li></ul><br><h4>  Resumo: </h4><br>  A abordagem é boa para pequenas aplicações ou protótipos, bem como para conectar módulos sem estado: fábricas, designers e conjuntos de recursos. <br><br><h2>  Injeção de Dependência </h2><br>  A idéia principal da injeção de dependência é transferir dependências de um componente externo para o módulo.  Assim, a forte dependência no módulo é eliminada e torna-se possível reutilizá-lo em diferentes contextos (por exemplo, com diferentes instâncias de banco de dados). <br><br>  A injeção de dependência pode ser implementada passando a dependência no argumento do construtor ou definindo as propriedades do módulo, mas na prática é melhor usar o primeiro método.  Vamos aplicar a implementação de dependências na prática, criando uma instância do banco de dados usando a fábrica e passando-a para o nosso módulo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Módulo externo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbFactory = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OurModule = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./ourModule.js'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dbInstance = dbFactory.createInstance(<span class="hljs-string"><span class="hljs-string">'instance1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = OurModule(dbInstance);</code> </pre> <br>  Agora, não podemos apenas reutilizar nosso módulo, mas também escrever facilmente um teste de unidade para ele: basta criar um objeto simulado para a instância do banco de dados e passá-lo ao módulo. <br><br><h4>  Prós: </h4><br><ul><li>  Facilidade de escrever testes de unidade </li><li>  Aumentar a reutilização dos módulos </li><li>  Menor envolvimento, maior conectividade </li><li>  Mudar a responsabilidade pela criação de dependências para um nível mais alto - geralmente isso melhora a legibilidade do programa, uma vez que dependências importantes são coletadas em um único local e não distribuídas por módulos </li></ul><br><h4>  Contras: </h4><br><ul><li>  A necessidade de um design de dependência mais completo: por exemplo, uma certa ordem de inicialização do módulo deve ser seguida </li><li>  A complexidade do gerenciamento de dependências, especialmente quando há muitos </li><li>  Deterioração da compreensibilidade do código do módulo: escrever o código do módulo quando uma dependência vem de fora é mais difícil, porque não podemos olhar diretamente para essa dependência. </li></ul><br><h4>  Resumo: </h4><br>  A injeção de dependência aumenta a complexidade e o tamanho do aplicativo, mas, em troca, permite a reutilização e facilita o teste.  O desenvolvedor deve decidir o que é mais importante para ele em um caso específico - a simplicidade de uma dependência difícil ou as possibilidades mais amplas de introdução de uma dependência. <br><br><h2>  Localizador de Serviços </h2><br>  A idéia é ter um registro de dependência que atue como intermediário ao carregar uma dependência com qualquer módulo.  Em vez de ligação direta, as dependências são solicitadas pelo módulo ao localizador de serviço.  Obviamente, os módulos têm uma nova dependência - o próprio localizador de serviço.  Um exemplo de localizador de serviço é o sistema do módulo Node.js.: os módulos solicitam uma dependência usando require ().  No exemplo a seguir, criaremos um localizador de serviço, registramos instâncias de banco de dados e nosso módulo nele. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// serviceLocator.js const dependencies = {}; const factories = {}; const serviceLocator = {}; serviceLocator.register = (name, instance) =&gt; { //[2] dependencies[name] = instance; }; serviceLocator.factory = (name, factory) =&gt; { //[1] factories[name] = factory; }; serviceLocator.get = (name) =&gt; { //[3] if(!dependencies[name]) { const factory = factories[name]; dependencies[name] = factory &amp;&amp; factory(serviceLocator); if(!dependencies[name]) { throw new Error('Cannot find module: ' + name); } } return dependencies[name]; };</span></span></code> </pre> <br>  Módulo externo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> serviceLocator = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./serviceLocator.js'</span></span>)(); serviceLocator.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); serviceLocator.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = serviceLocator.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Nosso módulo: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (serviceLocator) =&gt; { const db = serviceLocator.get('db'); const someValue = serviceLocator.get('someParameter'); const ourModule = {}; //  ,   ... return ourModule; };</span></span></code> </pre> <br>  Deve-se notar que o localizador de serviço armazena fábricas de serviço em vez de instâncias, e isso faz sentido.  Temos os benefícios da inicialização lenta e agora não precisamos nos preocupar com a ordem de inicialização dos módulos - todos os módulos serão inicializados quando necessário.  Além disso, tivemos a oportunidade de armazenar parâmetros no localizador de serviço (consulte "someParameter"). <br><br><h4>  Prós: </h4><br><ul><li>  Facilidade de escrever testes de unidade </li><li>  Reutilizar um módulo é mais fácil do que com um vício intenso </li><li>  Engajamento reduzido, maior conectividade em comparação com o vício intenso </li><li>  Mudando a responsabilidade de criar dependências para um nível superior </li><li>  Não é necessário seguir a ordem de inicialização do módulo </li></ul><br><h4>  Contras: </h4><br><ul><li>  Reutilizar um módulo é mais difícil do que implementar uma dependência (devido à dependência adicional do localizador de serviço) </li><li>  Legibilidade: é ainda mais difícil entender o que a dependência exigida pelo localizador de serviço faz </li><li>  Maior envolvimento comparado à injeção de dependência </li></ul><br><h4>  Sumário </h4><br>  Em geral, um localizador de serviço é semelhante à injeção de dependência; de certa forma, é mais fácil (não há ordem de inicialização); em alguns casos, é mais difícil (menor do que a possibilidade de reutilizar código). <br><br><h2>  Contêineres de dependência incorporados (contêiner DI) </h2><br>  O localizador de serviço tem uma desvantagem, devido à qual raramente é aplicado na prática - a dependência dos módulos no próprio localizador.  Contêineres de dependência incorporados (contêineres DI) não têm essa desvantagem.  De fato, este é o mesmo localizador de serviço com uma função adicional que determina as dependências do módulo antes de criar sua instância.  Você pode determinar as dependências do módulo analisando e extraindo argumentos do construtor do módulo (em JavaScript, é possível converter um link para uma função em uma string usando toString ()).  Este método é adequado se o desenvolvimento for puramente para o servidor.  Se o código do cliente é gravado, ele é freqüentemente minificado e não faz sentido extrair os nomes dos argumentos.  Nesse caso, a lista de dependências pode ser passada como uma matriz de seqüências de caracteres (no Angular.js, com base no uso de contêineres DI, essa abordagem é usada).  Implementamos o contêiner de DI usando a análise de argumentos do construtor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fnArgs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'parse-fn-args'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dependencies = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factories = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = {}; diContainer.factory = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { factories[name] = factory; }; diContainer.register = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, dep</span></span></span><span class="hljs-function">) =&gt;</span></span> { dependencies[name] = dep; }; diContainer.get = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> factory = factories[name]; dependencies[name] = factory &amp;&amp; diContainer.inject(factory); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!dependencies[name]) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Cannot find module: '</span></span> + name); } } diContainer.inject = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">factory</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> args = fnArgs(factory) .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependency</span></span></span><span class="hljs-function"> =&gt;</span></span> diContainer.get(dependency)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependencies[name]; };</code> </pre> <br>  Comparado ao localizador de serviço, o método injetar foi adicionado, o que determina as dependências do módulo antes de criar sua instância.  O código do módulo externo não mudou muito: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> diContainer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./diContainer.js'</span></span>)(); diContainer.register(<span class="hljs-string"><span class="hljs-string">'someParameter'</span></span>, <span class="hljs-string"><span class="hljs-string">'someValue'</span></span>); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'db'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'db'</span></span>)); diContainer.factory(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ourModule = diContainer.get(<span class="hljs-string"><span class="hljs-string">'ourModule'</span></span>);</code> </pre> <br>  Nosso módulo tem exatamente a mesma aparência de uma injeção simples de dependência: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ourModule.js module.exports = (db) =&gt; { //       ... };</span></span></code> </pre> <br>  Agora, nosso módulo pode ser chamado com a ajuda de um contêiner de DI e transmitindo diretamente as instâncias de dependência necessárias, usando uma injeção simples de dependência. <br><br><h4>  Prós: </h4><br><ul><li>  Facilidade de escrever testes de unidade </li><li>  Fácil reutilização de módulos </li><li>  Menor envolvimento, maior conectividade dos módulos (especialmente em comparação com um localizador de serviço) </li><li>  Mudando a responsabilidade de criar dependências para um nível superior </li><li>  Não há necessidade de acompanhar a inicialização do módulo </li></ul><br><h4>  O maior menos: </h4><br><ul><li>  Complicação significativa da lógica de ligação do módulo </li></ul><br><h4>  Sumário </h4><br>  Essa abordagem é mais difícil de entender e contém um pouco mais de código, mas vale a pena o tempo gasto por causa de seu poder e elegância.  Em projetos pequenos, essa abordagem pode ser redundante, mas deve ser considerada se um aplicativo grande estiver sendo projetado. <br><br><h2>  Conclusão </h2><br>  As abordagens básicas para a ligação de módulos no Node.js. foram consideradas.  Como geralmente acontece, a “bala de prata” não existe, mas o desenvolvedor deve estar ciente das alternativas possíveis e escolher a solução mais adequada para cada caso específico. <br><br>  O artigo é baseado em um capítulo do livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Node.js. Design Patterns</a> , lançado em 2017.  Infelizmente, muitas coisas no livro já estão desatualizadas, então não recomendo 100% a leitura, mas algumas coisas ainda são relevantes hoje. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438546/">https://habr.com/ru/post/pt438546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438536/index.html">Sob o capô do chatbot: o que o RocketBot pode e como funciona</a></li>
<li><a href="../pt438538/index.html">Teamlead Conf 2019 Msk: sobre outro formato de comunicação</a></li>
<li><a href="../pt438540/index.html">Tendências em gerenciamento de documentos e armazenamento de dados para 2019</a></li>
<li><a href="../pt438542/index.html">Como criamos um serviço de recomendação para a seleção de roupas em redes neurais</a></li>
<li><a href="../pt438544/index.html">Assistimos a filmes em casa: 10 materiais sobre a construção de um home theater e a escolha de equipamentos</a></li>
<li><a href="../pt438548/index.html">Lombok, sources.jar e depuração conveniente</a></li>
<li><a href="../pt438550/index.html">Outro manifesto</a></li>
<li><a href="../pt438554/index.html">Gerenciando estado e eventos entre componentes no GameObject</a></li>
<li><a href="../pt438556/index.html">Serrar dados confortavelmente</a></li>
<li><a href="../pt438560/index.html">Escrevendo o XGBoost a partir do zero - parte 1: árvores de decisão</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>