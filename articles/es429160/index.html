<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôã üëàüèº üóØÔ∏è Nintendo DS Console GPU y caracter√≠sticas interesantes üöµüèΩ üï§ üë®üèª‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me gustar√≠a contarle sobre el funcionamiento de la consola GPU de Nintendo DS, sus diferencias con las GPU modernas, y tambi√©n expresar mi opini√≥n sob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nintendo DS Console GPU y caracter√≠sticas interesantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429160/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uc/yy/rg/ucyyrgszova3-3kx-wpaxjbonwk.jpeg"></div><br>  Me gustar√≠a contarle sobre el funcionamiento de la consola GPU de Nintendo DS, sus diferencias con las GPU modernas, y tambi√©n expresar mi opini√≥n sobre por qu√© usar Vulkan en lugar de OpenGL en emuladores no traer√° ninguna ventaja. <br><br>  Realmente no conozco Vulkan, pero por lo que le√≠, est√° claro para m√≠ que Vulkan difiere de OpenGL en que funciona en un nivel inferior, lo que permite a los programadores administrar la memoria de la GPU y cosas similares.  Esto puede ser √∫til para emular consolas m√°s modernas que usan API gr√°ficas patentadas que proporcionan niveles de control no disponibles en OpenGL. <br><a name="habracut"></a><br>  Por ejemplo, el renderizador de hardware blargSNES: uno de sus trucos es que durante algunas operaciones con diferentes colores de buffer, se usa un buffer de profundidad / stencil.  En OpenGL, esto no es posible. <br><br>  Adem√°s, queda menos basura entre la aplicaci√≥n y la GPU, lo que significa que si se implementa correctamente, el rendimiento ser√° mayor.  Si bien los controladores OpenGL est√°n llenos de optimizaciones para casos de uso est√°ndar e incluso para juegos espec√≠ficos, en Vulkan la aplicaci√≥n en s√≠ misma debe estar bien escrita en primer lugar. <br><br>  Es decir, en esencia, "la gran responsabilidad viene con gran fuerza". <br><br>  No soy un especialista en API 3D, as√≠ que volvamos a eso.  Lo que s√© bien: consola GPU DS. <br><br>  Ya se han escrito varios art√≠culos sobre sus partes individuales ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre sus cu√°druples sofisticados</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre tonter√≠as con viewport</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre las caracter√≠sticas divertidas del rasterizador</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre la sorprendente implementaci√≥n del suavizado</a> ), pero en este art√≠culo consideraremos el dispositivo como un todo, pero con todos los detalles jugosos.  Al menos eso es todo lo que sabemos. <br><br>  La GPU en s√≠ es un hardware bastante antiguo y obsoleto.  Est√° limitado a 2048 pol√≠gonos y / o 6144 v√©rtices por cuadro.  La resoluci√≥n es 256x192.  Incluso si cuadruplica esto, el rendimiento no ser√° un problema.  En condiciones √≥ptimas, DS puede generar hasta 122880 pol√≠gonos por segundo, lo cual es rid√≠culo para los est√°ndares de las GPU modernas. <br><br>  Ahora pasemos a los detalles de la GPU.  En la superficie, parece bastante est√°ndar, pero en el fondo su trabajo es muy diferente del trabajo de las GPU modernas, lo que hace que la emulaci√≥n de algunas funciones sea m√°s complicada. <br><br>  La GPU se divide en dos partes: un motor de geometr√≠a y un motor de renderizado.  El motor de geometr√≠a procesa los v√©rtices resultantes, construye pol√≠gonos y los transforma para que pueda pasarlos al motor de representaci√≥n, que (lo adivin√≥) dibuja todo en la pantalla. <br><br><h2>  Motor de geometr√≠a </h2><br>  Transportador geom√©trico bastante est√°ndar. <br><br>  Vale la pena mencionar que toda la aritm√©tica se realiza en enteros de punto fijo, porque DS no admite n√∫meros de punto flotante. <br><br>  El motor de geometr√≠a se emula completamente mediante programaci√≥n (GPU3D.cpp), es decir, no se aplica mucho a lo que usamos para renderizar gr√°ficos, pero de todos modos te contar√© m√°s al respecto. <br><br>  1. Transformaci√≥n e iluminaci√≥n.  Los v√©rtices resultantes y las coordenadas de textura se convierten utilizando conjuntos de matrices 4x4.  Adem√°s de los colores de v√©rtice, se aplica iluminaci√≥n.  Aqu√≠ todo es bastante est√°ndar, lo √∫nico no est√°ndar es c√≥mo funcionan las coordenadas de textura (1.0 = un DS texel).  Tambi√©n vale la pena mencionar todo el sistema de pilas de matriz, que en un grado u otro son la implementaci√≥n de hardware de glPushMatrix (). <br><br>  2. Configuraci√≥n de pol√≠gonos.  Los v√©rtices convertidos se ensamblan en pol√≠gonos, que pueden ser tri√°ngulos, cuadr√°ngulos (quads), franjas de tri√°ngulos o franjas de cuadr√°ngulos.  Los quads se procesan de forma nativa y no se convierten en tri√°ngulos, lo cual es bastante problem√°tico porque las GPU modernas solo admiten tri√°ngulos.  Sin embargo, parece que a alguien se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">le ocurri√≥ una soluci√≥n</a> que necesito probar. <br><br>  3. Drop.  Los pol√≠gonos se pueden eliminar seg√∫n la orientaci√≥n en la pantalla y el modo de selecci√≥n seleccionado.  Tambi√©n esquema bastante est√°ndar.  Sin embargo, necesito descubrir c√≥mo funciona esto para los quads. <br><br>  4. Truncamiento.  Se eliminan los pol√≠gonos m√°s all√° del alcance de la visibilidad.  Los pol√≠gonos que se extienden parcialmente m√°s all√° de esta regi√≥n est√°n truncados.  Este paso no crea nuevos pol√≠gonos, pero agrega v√©rtices a los existentes.  De hecho, cada uno de los 6 planos de truncamiento puede agregar un v√©rtice al pol√≠gono, es decir, como resultado, podemos obtener hasta 10 v√©rtices.  En la secci√≥n sobre el motor de renderizado, te dir√© c√≥mo lidiamos con esto. <br><br>  5. Convertir a ventana gr√°fica.  Las coordenadas X / Y se convierten en coordenadas de pantalla.  Las coordenadas Z se convierten para ajustarse en un intervalo de b√∫fer de profundidad de 24 bits. <br><br>  Lo interesante es c√≥mo se procesan las coordenadas W: est√°n "normalizadas" para ajustarse en un intervalo de 16 bits.  Para esto, se toma cada coordenada W del pol√≠gono, y si es mayor que 0xFFFF, entonces se desplaza hacia la derecha 4 posiciones para caber en 16 bits.  Por el contrario, si la coordenada es menor que 0x1000, se mueve hacia la izquierda hasta que cae en el intervalo.  Supongo que esto es necesario para obtener buenos intervalos, lo que significa una mayor precisi√≥n durante la interpolaci√≥n. <br><br>  6. Clasificaci√≥n.  Los pol√≠gonos se ordenan para que los pol√≠gonos transl√∫cidos se dibujen primero.  Luego se ordenan por sus coordenadas Y (s√≠), lo cual es necesario para los pol√≠gonos opacos y opcionalmente transl√∫cidos. <br><br>  Adem√°s, esta es la raz√≥n de la restricci√≥n de 2048 pol√≠gonos: para la clasificaci√≥n, deben almacenarse en alg√∫n lugar.  Hay dos bancos de memoria interna asignados para almacenar pol√≠gonos y v√©rtices.  Incluso hay un registro que informa cu√°ntos pol√≠gonos y v√©rtices est√°n almacenados. <br><br><h2>  Motor de renderizado </h2><br>  ¬°Y aqu√≠ comienza la diversi√≥n! <br><br>  Despu√©s de que todos los pol√≠gonos se hayan configurado y ordenado, el motor de renderizado comienza a funcionar. <br><br>  La primera cosa divertida es c√≥mo llena los pol√≠gonos.  Esto es completamente diferente al trabajo de las GPU modernas que realizan el llenado de mosaicos y utilizan algoritmos optimizados con tri√°ngulos.  No s√© c√≥mo funcionan todos, pero vi c√≥mo se hace esto en la GPU de la consola 3DS, y todo se basa en mosaicos all√≠. <br><br>  Sea como fuere, en DS, el renderizado se realiza en cadenas r√°ster.  Los desarrolladores tuvieron que hacer esto para que el renderizado se pudiera realizar en paralelo con los motores de mosaicos bidimensionales de la vieja escuela, que realizan dibujos en l√≠neas de trama.  Hay un peque√±o b√∫fer con 48 l√≠neas de trama que se pueden usar para ajustar algunas l√≠neas de trama. <br><br>  Un rasterizador es un renderizador de pol√≠gonos convexos basados ‚Äã‚Äãen cadenas de trama.  Puede manejar un n√∫mero arbitrario de v√©rtices.  Puede renderizarse incorrectamente si le pasa pol√≠gonos que no son convexos o tienen bordes de intersecci√≥n, por ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ul/ts/vd/ultsvdezpi2riupyjponrg--exq.png"></div><br>  <i>El pol√≠gono es una mariposa.</i>  <i>Todo es correcto y magn√≠fico.</i> <br><br>  Pero, ¬øy si le damos la vuelta? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t0/z-/48/t0z-48rfmcp8ndjpebeydxaof08.png"></div><br>  <i>Ouch</i> <br><br>  ¬øCu√°l es el error aqu√≠?  Dibujemos el contorno del pol√≠gono original para descubrir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nl/mj/tx/nlmjtxlv9qeennvaulabodzsnu0.png"></div><br>  Un renderizador solo puede llenar un espacio por l√≠nea de trama.  Define los bordes izquierdo y derecho comenzando en los picos m√°s altos, y sigue estos bordes hasta que encuentra nuevos picos. <br><br>  En la imagen que se muestra arriba, comienza desde el v√©rtice superior, es decir, la esquina superior izquierda, y contin√∫a llen√°ndose hasta llegar al final del borde izquierdo (v√©rtice inferior izquierdo).  No sabe que los bordes se cruzan. <br><br>  En este punto, busca el siguiente v√©rtice en su borde izquierdo.  Es interesante notar que √©l sabe que no necesita tomar v√©rtices que son m√°s altos que el actual, y tambi√©n sabe que los bordes izquierdo y derecho se han intercambiado.  Por lo tanto, contin√∫a llen√°ndose hasta el final del vertedero. <br><br>  A√±adir√≠a algunos ejemplos m√°s de pol√≠gonos no convexos, pero nos desviaremos demasiado del tema. <br><br>  Comprendamos mejor c√≥mo funcionan las sombras y texturas de Gouraud con un n√∫mero arbitrario de v√©rtices.  Hay algoritmos barc√©ntricos utilizados para interpolar datos a lo largo de un tri√°ngulo, pero ... en nuestro caso, no son adecuados. <br><br>  El procesador DS aqu√≠ tambi√©n tiene su propia implementaci√≥n.  Algunas im√°genes m√°s interesantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p0/-l/qm/p0-lqmqqcinmjrvlzjiw_fsvh5w.png"></div><br>  Los v√©rtices del pol√≠gono son los puntos 1, 2, 3 y 4. Los n√∫meros no corresponden al orden transversal real, pero usted comprende el significado. <br><br>  En la l√≠nea r√°ster actual, el renderizador define los v√©rtices que rodean directamente los bordes (como se mencion√≥ anteriormente, comienza desde los v√©rtices superiores y luego atraviesa los bordes hasta que se completan).  En nuestro caso, estos son v√©rtices 1 y 2 para el borde izquierdo, 3 y 4 para el borde derecho. <br><br>  Las pendientes de los bordes se utilizan para determinar los l√≠mites del espacio, es decir, los puntos 5 y 6. En estos puntos, los atributos de los v√©rtices se interpolan en funci√≥n de las posiciones verticales en los bordes (o posiciones horizontales para los bordes, cuyas pendientes se encuentran principalmente a lo largo del eje X). <br><br>  Luego, para cada p√≠xel en el espacio (por ejemplo, para el punto 7), los atributos basados ‚Äã‚Äãen la posici√≥n X dentro del espacio se interpolan de los atributos previamente calculados en los puntos 5 y 6. <br><br>  Aqu√≠, todos los coeficientes utilizados son iguales al 50% para simplificar el trabajo, pero el significado es claro. <br><br>  No entrar√© en detalles sobre la interpolaci√≥n de atributos, aunque tambi√©n ser√° interesante escribir sobre esto.  De hecho, esta es una interpolaci√≥n correcta desde el punto de vista de la perspectiva, pero tiene simplificaciones y caracter√≠sticas interesantes. <br><br>  Ahora hablemos sobre c√≥mo DS llena los pol√≠gonos. <br><br>  ¬øQu√© reglas de relleno usa?  ¬°Tambi√©n hay muchas cosas interesantes aqu√≠! <br><br>  En primer lugar, existen diferentes reglas de relleno para pol√≠gonos opacos y transl√∫cidos.  Pero lo m√°s importante, estas reglas se aplican <i>p√≠xel por p√≠xel</i> .  Los pol√≠gonos transl√∫cidos pueden tener p√≠xeles opacos y seguir√°n las mismas reglas que los pol√≠gonos opacos.  Puede suponer que para emular tales trucos en las GPU modernas, se requieren varios pases de renderizado. <br><br>  Adem√°s, diferentes atributos de pol√≠gono pueden influir en el renderizado de varias maneras interesantes.  Adem√°s de los b√∫feres de profundidad y color bastante est√°ndar, el procesador tambi√©n tiene <i>un b√∫fer de atributos</i> que rastrea todo tipo de cosas interesantes.  A saber: la identificaci√≥n del pol√≠gono (por separado para pol√≠gonos opacos y transl√∫cidos), translucidez de p√≠xeles, la necesidad de aplicar niebla, si este pol√≠gono se dirige hacia o desde la c√°mara (s√≠, esto tambi√©n) y si el p√≠xel est√° en el borde del pol√≠gono.  Y tal vez algo m√°s. <br><br>  La tarea de emular dicho sistema no ser√° trivial.  Una GPU moderna ordinaria tiene un b√∫fer de plantilla limitado a 8 bits, que est√° lejos de ser suficiente para todo lo que puede almacenar un b√∫fer de atributos.  Necesitamos encontrar una soluci√≥n dif√≠cil. <br><br>  Vamos a resolverlo: <br><br>  * Actualizaci√≥n del b√∫fer de profundidad: se requiere para p√≠xeles opacos, opcional para los transl√∫cidos. <br><br>  * ID de pol√≠gono: las ID de 6 bits se asignan a pol√≠gonos, que se pueden usar para varios prop√≥sitos.  Las ID de pol√≠gono opacas se usan para marcar bordes.  La ID de los pol√≠gonos transl√∫cidos se puede usar para controlar d√≥nde se dibujar√°n: un p√≠xel transl√∫cido no se dibujar√° si la ID del pol√≠gono coincide con la ID del pol√≠gono transl√∫cido que ya est√° en el b√∫fer de atributos.  Adem√°s, ambas ID de pol√≠gono se usan de manera similar para controlar la representaci√≥n de sombras.  Por ejemplo, puede crear una sombra que cubra el piso, pero no el personaje. <br><br>  (Nota: las sombras son solo una implementaci√≥n del b√∫fer de la plantilla, aqu√≠ no hay nada terrible). <br><br>  Vale la pena se√±alar que cuando se procesan p√≠xeles transl√∫cidos, se guarda la ID existente del pol√≠gono opaco, as√≠ como las banderas de borde del √∫ltimo pol√≠gono opaco. <br><br>  * bandera de niebla: determina si se aplicar√° un pase de niebla para este p√≠xel.  El proceso de actualizaci√≥n depende de si el p√≠xel entrante es opaco o transl√∫cido. <br><br>  * bandera de la primera l√≠nea: aqu√≠ hay problemas con ella.  Echa un vistazo a la captura de pantalla: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hb/8m/pb/hb8mpbdxkcher7n0xmaocay2j_4.png"></div><br>  Arenas de la destrucci√≥n, las pantallas de este juego son un conjunto de trucos.  No solo cambian sus coordenadas Y para afectar la clasificaci√≥n Y.  La pantalla que se muestra en esta captura de pantalla es probablemente la peor. <br><br>  Utiliza el caso l√≠mite de la prueba de profundidad: la funci√≥n de comparaci√≥n "menor que" <b>toma valores iguales</b> si el juego <i>dibuja un pol√≠gono mirando a la c√°mara encima de los p√≠xeles opacos del pol√≠gono que se aleja de la c√°mara</i> .  Si exactamente.  Y los valores Z de todos los pol√≠gonos son cero.  Si no emula esta caracter√≠stica, faltar√°n algunos elementos en la pantalla. <br><br>  Creo que esto se hizo para que la parte frontal del objeto siempre fuera visible sobre la parte posterior, incluso cuando son tan planas que los valores Z son los mismos.  Con todos estos trucos y trucos, el renderizador DS es similar a la versi√≥n de hardware de los renderizadores de la era DOS. <br><br>  Sea como fuere, emular este comportamiento a trav√©s de la GPU fue dif√≠cil.  Pero hay otros casos l√≠mite similares de pruebas de profundidad, que tambi√©n deben ser probados y documentados. <br><br>  * banderas de costilla: el renderizador rastrea la ubicaci√≥n de los bordes de los pol√≠gonos.  Se utilizan en las √∫ltimas pasadas, es decir, al marcar bordes y suavizar.  Tambi√©n hay reglas especiales para rellenar pol√≠gonos opacos con suavizado desactivado.  El siguiente diagrama ilustra estas reglas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/pu/hf/eypuhfe9rghuhobfo1r9njkt4wy.png"></div><br>  Nota: ¬°los wireframes se procesan rellenando solo los bordes!  Muy inteligente movimiento. <br><br>  Otra nota divertida sobre el buffer de profundidad: <br><br>  Hay dos modos posibles de almacenamiento en profundidad en DS: almacenamiento en Z y almacenamiento en W.  Esto parece ser bastante est√°ndar, pero solo si no entra en detalles. <br><br>  * Z-buffering utiliza coordenadas Z convertidas para ajustarse en un intervalo de b√∫fer de profundidad de 24 bits.  Las coordenadas Z se interpolan linealmente sobre pol√≠gonos (con algunas rarezas, pero no son particularmente importantes).  No hay nada no est√°ndar aqu√≠ tampoco. <br><br>  * En el almacenamiento en W, las coordenadas W se usan "tal cual".  Las GPU modernas generalmente usan 1 / W, pero DS solo usa aritm√©tica de punto fijo, por lo que usar valores rec√≠procos no es muy conveniente.  Sea como fuere, en este modo, las coordenadas W se interpolan con la correcci√≥n de la perspectiva. <br><br>  As√≠ es como se ven los pases de renderizado final: <br><br>  * marca de borde: los p√≠xeles que tienen marcas de borde configuradas se les asigna un color tomado de la tabla y se determina en funci√≥n de la ID de un pol√≠gono opaco. <br><br>  Ser√°n bordes coloreados de pol√≠gonos.  Vale la pena se√±alar que si se dibuja un pol√≠gono transl√∫cido encima de un pol√≠gono opaco, entonces los bordes del pol√≠gono seguir√°n coloreados. <br><br>  Un efecto secundario del principio de truncamiento: los bordes en los que los pol√≠gonos se cruzan con los bordes de la pantalla tambi√©n ser√°n coloreados.  Por ejemplo, puede notar esto en las capturas de pantalla de Picross 3D. <br><br>  * niebla: se aplica a cada p√≠xel en funci√≥n de los valores de profundidad utilizados para indexar la tabla de densidad de niebla.  Como puede suponer, se aplica a aquellos p√≠xeles que tienen banderas de niebla establecidas en el b√∫fer de atributos. <br><br>  * antialiasing (suavizado): se aplica a los bordes de los pol√≠gonos (opacos).  En funci√≥n de las pendientes de los bordes al representar pol√≠gonos, se calculan los valores de cobertura de p√≠xeles.  En la √∫ltima pasada, estos p√≠xeles se mezclan con los p√≠xeles debajo de ellos usando el mecanismo complicado que describ√≠ en una publicaci√≥n anterior. <br><br>  Antialiasing no debe (y no puede) emularse de esta manera en la GPU, por lo que esto no es importante aqu√≠. <br><br>  Excepto que si la marca del borde y el suavizado se deben aplicar a los mismos p√≠xeles, solo obtienen el tama√±o del borde, pero con un 50% de opacidad. <br><br>  Parece que describ√≠ el proceso de renderizado m√°s o menos bien.  No profundizamos en la mezcla de texturas (combinando colores de v√©rtices y texturas), pero se puede emular en un sombreador de fragmentos.  Lo mismo se aplica al marcado de bordes y la niebla, siempre que encontremos una forma de evitar todo este sistema con un b√∫fer de atributos. <br><br>  Pero en general, quer√≠a transmitir lo siguiente: OpenGL o Vulkan (as√≠ como Direct3D, Glide o cualquier otra cosa) no ayudar√°n aqu√≠.  Nuestras GPU modernas tienen potencia m√°s que suficiente para trabajar con pol√≠gonos sin procesar.  El problema son los detalles y las caracter√≠sticas de la rasterizaci√≥n.  Y ni siquiera se trata de la idealidad de los p√≠xeles, por ejemplo, solo mire el rastreador de problemas del emulador DeSmuME para comprender qu√© problemas encuentran los desarrolladores al renderizar a trav√©s de OpenGL.  Tambi√©n tenemos que lidiar con estos mismos problemas de alguna manera. <br><br>  Tambi√©n noto que usar OpenGL nos permitir√° portar el emulador, por ejemplo, a Switch (porque un usuario de Github llamado Hydr8gon comenz√≥ a crear un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puerto para nuestro emulador en Switch</a> ). <br><br>  Entonces ... des√©ame suerte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429160/">https://habr.com/ru/post/es429160/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429150/index.html">Administrar sus m√≥dulos para CMS usando Composer</a></li>
<li><a href="../es429152/index.html">Componente de navegaci√≥n de Android. Cosas simples que tienes que hacer t√∫ mismo</a></li>
<li><a href="../es429154/index.html">Facturaci√≥n por segunda vez, marketplace y sandboxes para Big Data: ¬øqu√© pueden hacer los entornos de prueba en la nube?</a></li>
<li><a href="../es429156/index.html">Toda la verdad sobre RTOS. Art√≠culo # 19. Sem√°foros: introducci√≥n y servicios b√°sicos.</a></li>
<li><a href="../es429158/index.html">El s√≠ndrome del impostor afecta a los hombres no menos que a las mujeres ... y otros hallazgos de 10,000 entrevistas t√©cnicas</a></li>
<li><a href="../es429162/index.html">"Para hacer cambios, comprender por qu√© la gente se resiste": Jim Holmes sobre Testing Culture</a></li>
<li><a href="../es429166/index.html">Multicristal: de la historia a la especulaci√≥n sobre el futuro</a></li>
<li><a href="../es429168/index.html">A trav√©s del fuego y el agua: la historia de la literatura de ciencia popular rusa</a></li>
<li><a href="../es429172/index.html">1C en Proxmox. Notas generales</a></li>
<li><a href="../es429174/index.html">BlueStacks 4: pruebas en hardware d√©bil + comentarios del desarrollador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>