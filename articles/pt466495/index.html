<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèº üå©Ô∏è üë©üèª‚Äçüé§ Como n√£o errar com a concorr√™ncia no Go üë®üèø‚Äçüè≠ üö≥ üî≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que queremos escrever c√≥digo competitivo? Porque os processadores pararam de crescer ao longo dos mergulhos e come√ßaram a crescer ao longo dos n√∫c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como n√£o errar com a concorr√™ncia no Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/466495/"><p>  Por que queremos escrever c√≥digo competitivo?  Porque os processadores pararam de crescer ao longo dos mergulhos e come√ßaram a crescer ao longo dos n√∫cleos.  O n√∫mero de n√∫cleos de processador est√° aumentando a cada ano, e queremos utiliz√°-los efetivamente.  Go √© o idioma criado para isso.  A documenta√ß√£o diz isso. </p><br><p> Tomamos Go, come√ßamos a escrever c√≥digo competitivo.  Obviamente, esperamos que possamos reduzir facilmente o poder de cada n√∫cleo do nosso processador.  √â isso mesmo? </p><br><p>  <em>Meu nome √© Artemy.</em>  <em>Este post √© uma transcri√ß√£o gratuita da minha conversa com a GopherCon Russia.</em>  <em>Pareceu uma tentativa de dar impulso √†s pessoas que desejam descobrir como escrever um c√≥digo bom e competitivo.</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4U3EaVufuW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>V√≠deo da confer√™ncia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GopherCon na R√∫ssia</a></em> </p><a name="habracut"></a><br><h1 id="modeli-vzaimodeystviya">  Modelos de intera√ß√£o </h1><br><p>  Para entender se o Go realmente torna mais f√°cil para n√≥s, vejamos dois modelos de intera√ß√£o: <strong>Mem√≥ria Compartilhada</strong> e <strong>Passagem de Mensagens</strong> . </p><br><p><img src="https://habrastorage.org/webt/xv/09/f1/xv09f1rq3eum5hnsuwdqdgrj97m.png"></p><br><ul><li><p>  <strong>Mem√≥ria</strong> compartilhada refere-se √† mem√≥ria compartilhada que v√°rios threads usam para trocar dados.  O acesso √† mem√≥ria precisa ser sincronizado.  Essa sincroniza√ß√£o geralmente √© implementada por algum tipo de bloqueio.  Essa abordagem √© considerada comunica√ß√£o impl√≠cita. </p><br></li><li><p>  <strong>O Message Passing</strong> diz que interagiremos explicitamente e, para isso, usaremos os canais nos quais enviaremos mensagens.  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CSP</a> ( <em>Communicating Sequential Processes</em> ) e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelo do ator</a> s√£o baseados nessa abordagem. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/wi/ss/jr/wissjrv4uu2-3ng62qsdtjbunbk.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rob Pike</a> , que √© o pai fundador da Go, diz que voc√™ precisa abandonar a programa√ß√£o de baixo n√≠vel usando a <strong>Mem√≥ria Compartilhada</strong> e usar a abordagem <strong>Message Passing</strong> .  Essa abordagem ajudar√° voc√™ a escrever c√≥digo de maneira mais f√°cil, mais eficiente e, mais importante, com menos bugs.  Go escolhe a abordagem <strong>CSP</strong> .  A mesma abordagem influenciou bastante o desenvolvimento de uma linguagem como Erlang. </p><br><p>  Pergunta: √â verdade que se pegarmos o Go, tudo ficar√° bem? </p><br><p><img src="https://habrastorage.org/webt/ld/uc/px/lducpx4ezb14rvygaamxzz0_-vy.png"></p><br><p>  Me deparei com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estudo</a> em que este tablet foi encontrado.  O tablet mostra os motivos e o n√∫mero de erros relacionados aos bloqueios.  A primeira coluna mostra os produtos que foram levados para o estudo.  Estes s√£o os produtos mais populares escritos em Go.  A coluna Mem√≥ria compartilhada mostra o n√∫mero de bugs que ocorrem devido ao uso inadequado da Mem√≥ria compartilhada, e a coluna Passagem de mensagem, respectivamente, mostra o n√∫mero de bugs devido √† Passagem de mensagens. </p><br><p>  A coisa mais importante nesta placa √© a linha <strong>Total</strong> .  Se voc√™ observar, notar√° que h√° mais erros ao usar o <strong>Message Passing do</strong> que ao usar a <strong>Mem√≥ria Compartilhada</strong> .  Estou certo de que as pessoas que escrevem Kubernetes, Docker ou etcd s√£o desenvolvedores bastante experientes, mas mesmo o <strong>Message Passing</strong> deles n√£o salva dos erros, e esses erros n√£o s√£o menores do que na Mem√≥ria Compartilhada. </p><br><p>  Ent√£o, basta pegar o Go e come√ßar a escrever um c√≥digo sem erros falhar√°. </p><br><h1 id="concurrency-i-parallelism">  Concorr√™ncia e paralelismo </h1><br><p>  Quando come√ßamos a falar sobre desenvolvimento multithread, precisamos introduzir conceitos como <strong>Concorr√™ncia</strong> e <strong>Paralelismo</strong> .  No mundo de Go, h√° a express√£o <em>"simultaneidade n√£o √© paralelismo"</em> .  O ponto principal √© que a <strong>simultaneidade</strong> √© sobre design, ou seja, como projetamos nosso programa.  <strong>Paralelismo</strong> √© apenas uma maneira de executar nosso c√≥digo. </p><br><p><img src="https://habrastorage.org/webt/uk/tr/es/uktresizsgqpphu4mkmjlep00fe.png"></p><br><p>  Se tivermos v√°rios encadeamentos de instru√ß√µes executados simultaneamente, executamos o c√≥digo em paralelo.  Paralelismo requer competi√ß√£o.  N√£o ser√° poss√≠vel paralelizar um programa sem um design competitivo, enquanto a competitividade n√£o exige paralelismo, porque um programa que pode ser executado em muitos n√∫cleos, de fato, pode ser executado em um √∫nico n√∫cleo. </p><br><p>  Go √© uma linguagem que nos ajuda a escrever programas competitivos, nos ajuda a criar design.  Ele permite que voc√™ pense um pouco menos sobre coisas de baixo n√≠vel. </p><br><h1 id="zakon-amdala">  Lei de Amdahl </h1><br><p>  Queremos utilizar os n√∫cleos do processador, escrevemos algum c√≥digo para isso.  Mas surge a pergunta: que tipo de aumento de produtividade obtemos com um aumento no n√∫mero de n√∫cleos.  Portanto, a acelera√ß√£o que podemos obter √©, de fato, limitada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pela lei de Amdal</a> . </p><br><p><img src="https://habrastorage.org/webt/dz/cc/bu/dzccbu8elu2vaogt54-u_gg4m4w.png"></p><br><p>  O que √© acelera√ß√£o?  Acelera√ß√£o √© o tempo em que um programa √© executado em um √∫nico processador dividido pelo tempo em que um programa √© executado em processadores <strong>P.</strong>  A letra <strong>F</strong> ( <em>Fra√ß√£o</em> ) indica a parte do programa que deve ser executada sequencialmente.  E aqui nem √© necess√°rio nos aprofundarmos na f√≥rmula, o principal √© notar que a acelera√ß√£o m√°xima que obtemos com um aumento no n√∫mero de n√∫cleos depende fortemente de <strong>F.</strong>  D√™ uma olhada no gr√°fico para visualizar esse relacionamento. </p><br><p><img src="https://habrastorage.org/webt/uw/c7/bn/uwc7bn5ngru2scvqaphzayuvboc.png"></p><br><p>  Mesmo que tenhamos apenas 5% do programa a ser executado seq√ºencialmente, a acelera√ß√£o m√°xima que obtivermos diminuir√° muito com o aumento do n√∫mero de n√∫cleos.  Voc√™ pode estimar quais s√£o as partes que aumentam <strong>F.</strong> </p><br><p><img src="https://habrastorage.org/webt/4o/pu/a8/4opua82_adysln9-enejf9-m-iu.png"></p><br><h1 id="cpu-bound-vs-io-bound">  Limite de CPU vs Limite de E / S </h1><br><p>  Nem sempre faz sentido usar multithreading.  Primeiro, voc√™ precisa examinar o tipo de carga.  Existem dois tipos de carga: <strong>limite da CPU</strong> e <strong>limite de</strong> <strong>E / S.</strong>  A diferen√ßa √© que, com o limite da CPU, somos limitados pelo desempenho do processador, e com o limite de E / S, a velocidade do nosso subsistema de E / S.  Nem velocidade, mas tempo de espera por uma resposta.  Ficar online - aguardando uma resposta, indo para o disco - novamente esperando por uma resposta.  Qual √© a diferen√ßa, quantos n√∫cleos existem, se na maioria das vezes estamos esperando por uma resposta? </p><br><p><img src="https://habrastorage.org/webt/xp/dk/yl/xpdkylyp6etnvk2qlw0txhjktby.png"></p><br><p>  Portanto, um n√∫cleo ou mil, n√£o obteremos um aumento no desempenho com a carga limitada de E / S.  Mas se tivermos uma carga limitada pela CPU, haver√° uma chance de acelerar ao paralelizar nosso programa. </p><br><p>  Embora existam situa√ß√µes em que a carga limite da CPU aparente, ela realmente se degenera em um limite de E / S.  Se, por exemplo, queremos pegar e somar todos os elementos de uma grande matriz, o que faremos?  Vamos escrever um ciclo, tudo vai funcionar.  Ent√£o pensamos: ‚ÄúEnt√£o, temos v√°rios n√∫cleos.  Vamos pegar, dividir a matriz em peda√ßos e paralelizar a coisa toda. ‚Äù  Qual ser√° o resultado? </p><br><p><img src="https://habrastorage.org/webt/5z/hy/zo/5zhyzoxnnpay_wnc1ypjmwesxeo.png"></p><br><p>  O resultado √© uma situa√ß√£o em que nosso processador processa dados mais rapidamente do que eles conseguem obter da mem√≥ria.  Nesse caso, na maioria das vezes, esperaremos os dados da mem√≥ria e a carga, que parecia estar vinculada √† CPU, na verdade acaba sendo E / S vinculada. </p><br><h1 id="false-sharing">  Compartilhamento falso </h1><br><p>  Al√©m disso, h√° uma hist√≥ria como o <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compartilhamento falso</a></strong> .  Compartilhamento falso √© uma situa√ß√£o em que os kernels come√ßam a interferir entre si.  Existe um primeiro n√∫cleo, existe um segundo n√∫cleo e cada um deles tem seu pr√≥prio <strong>cache L1</strong> .  O cache L1 √© dividido em linhas ( <em>linha de cache</em> ) de 64 bytes.  Quando obtemos alguns dados da mem√≥ria, sempre obtemos nada menos que 64 bytes.  Ao alterar esses dados, desabilitamos os caches de todos os n√∫cleos. </p><br><p><img src="https://habrastorage.org/webt/b4/ug/ne/b4ugnemfq4lkhv22yhxhuxeytdq.png"></p><br><p>  Acontece que, se dois n√∫cleos alteram dados muito pr√≥ximos um do outro ( <em>a uma dist√¢ncia inferior a 64 bytes</em> ), eles come√ßam a interferir entre si, invalidando caches.  Nesse caso, se o programa fosse gravado seq√ºencialmente, ele funcionaria mais r√°pido do que ao usar v√°rios n√∫cleos que interferem um no outro.  Quanto mais n√∫cleos, menor o desempenho. </p><br><h1 id="schedulers">  Agendadores </h1><br><p>  Subiremos para o pr√≥ximo n√≠vel de abstra√ß√£o - para os planejadores. </p><br><p>  Quando o trabalho come√ßa com um c√≥digo competitivo, os agendadores aparecem.  O Go possui o chamado <strong>agendador de espa√ßo do usu√°rio</strong> que opera em <strong>goroutines</strong> .  O sistema operacional tamb√©m possui seu pr√≥prio <strong>agendador</strong> , que opera com <strong>threads do sistema operacional</strong> .  E mesmo o processador n√£o √© t√£o simples.  Por exemplo, os processadores modernos t√™m <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">previs√£o de ramifica√ß√£o</a> e outras maneiras de estragar nossa bela imagem da linearizabilidade do mundo. </p><br><p><img src="https://habrastorage.org/webt/cf/dc/1k/cfdc1kw8l7axejmswctoqpawlmc.png"></p><br><p>  Os agendadores s√£o divididos por tipo de multitarefa.  H√° <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multitarefa cooperativa</a></strong> e <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multitarefa preventiva</a></strong> .  No caso de <strong>multitarefa cooperativa</strong> , o <strong>pr√≥prio processo de</strong> execu√ß√£o <strong>decide</strong> quando precisa transferir o controle para outro processo e, no caso de <strong>multitarefa lotada,</strong> existe <strong>um componente externo</strong> - agendador, que controla a quantidade de recursos alocados ao processo. </p><br><p><img src="https://habrastorage.org/webt/vo/o_/tx/voo_tx_4vfug0jinekpu5f-o-ha.png"></p><br><p>  A multitarefa cooperativa permite que um processo "monopolize" todo o recurso da CPU.  Na multitarefa preemptiva, isso n√£o acontecer√°, porque existe um corpo controlador.  Por√©m, com a multitarefa cooperativa, a altern√¢ncia de contexto √© mais eficiente, porque o processo sabe ao certo em que momento √© melhor dar controle a outro processo.  Na multitarefa preemptiva, o agendador pode interromper o processo a qualquer momento - n√£o √© muito eficiente.  Ao mesmo tempo, na multitarefa preventiva, podemos fornecer o mesmo recurso para cada processo, gra√ßas a um agendador externo. </p><br><p>  O sistema operacional usa um agendador baseado na multitarefa preventiva, pois o sistema operacional √© necess√°rio para garantir condi√ß√µes iguais para cada usu√°rio.  E o Go? </p><br><p><img src="https://habrastorage.org/webt/8d/ry/dd/8drydde54y4ytkr_t2qrcznevvy.png"></p><br><p>  Se lermos a documenta√ß√£o, aprenderemos que o agendador no Go √© preventivo.  Mas, quando come√ßamos a entender, o Go n√£o possui um agendador como componente externo.  No Go, o compilador define pontos de altern√¢ncia de contexto.  E embora n√≥s, como desenvolvedores, n√£o precisemos alternar manualmente o contexto, o controle da altern√¢ncia n√£o √© levado para o componente externo.  Gra√ßas a isso, o Go √© muito eficaz na troca de uma goroutina para outra.  Mas um mal-entendido sobre as caracter√≠sticas do trabalho de um "planejador" pode levar a um comportamento inesperado.  Por exemplo, qual ser√° o resultado desse c√≥digo? </p><br><p><img src="https://habrastorage.org/webt/4p/7i/tm/4p7itmw8_pusfpg5whtkjawfqt4.png"></p><br><p>  Esse c√≥digo ir√° congelar. </p><br><p> Porque  Porque, a princ√≠pio, usando o <code>GOMAXPROCS</code> , <code>GOMAXPROCS</code> o programa a usar apenas um n√∫cleo.  Depois disso, a goroutine foi colocada na fila, dentro da qual um ciclo intermin√°vel deveria funcionar.  Depois esperamos 500 ms e imprimimos <code>x</code> .  Ap√≥s o <code>time.Sleep</code> goroutine ser√° realmente iniciada, mas n√£o haver√° sa√≠da do loop infinito, porque o compilador n√£o colocar√° o ponto de altern√¢ncia de contexto.  O programa congela. </p><br><p>  E se adicionarmos <code>runtime.Gosched()</code> dentro do loop, tudo ficar√° bem, porque indicaremos explicitamente que queremos mudar o contexto. </p><br><p>  Esses recursos tamb√©m precisam saber e lembrar. </p><br><p>  Falamos sobre troca de contexto, mas onde o Go geralmente insere pontos de troca? </p><br><p><img src="https://habrastorage.org/webt/8k/6k/bo/8k6kbop0qpvsimvezerzshdc0qm.png"></p><br><p>  <code>runtime.morestack()</code> e <code>runtime.newstack()</code> geralmente s√£o inseridos no momento em que a fun√ß√£o √© chamada.  <code>runtime.Goshed()</code> n√≥s podemos fornecer a n√≥s mesmos.  E, √© claro, a altern√¢ncia de contexto ocorre durante bloqueios, aumentos de rede e chamadas do sistema.  Voc√™ pode olhar para este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio de</a> t√≥pico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de Kirill Lashkevich</a> .  Muito bom, eu aconselho. </p><br><p>  Vamos mais perto do c√≥digo.  Vamos olhar para os erros. </p><br><h1 id="race-condition">  Condi√ß√£o de corrida </h1><br><p>  Um dos erros mais populares que cometemos √© a <code>Race Condition</code> .  A conclus√£o √© que, quando realizamos, por exemplo, um incremento, na verdade n√£o realizamos uma opera√ß√£o, mas v√°rias: o processador l√™ dados da mem√≥ria para registrar, atualiza o registro e grava dados na mem√≥ria. </p><br><p><img src="https://habrastorage.org/webt/jf/ar/zs/jfarzsk1prxonyme8fx7b1yvg1s.png"></p><br><p>  Essas tr√™s opera√ß√µes n√£o s√£o executadas atomicamente.  Portanto, o planejador a qualquer momento, em qualquer uma dessas opera√ß√µes, pode absorver e dispersar nosso fluxo.  Acontece que a a√ß√£o n√£o est√° conclu√≠da e, por causa disso, detectamos bugs. </p><br><p>  Aqui est√° um exemplo desse c√≥digo (o <em>incremento √© imediatamente decomposto em v√°rias opera√ß√µes</em> ). </p><br><p><img src="https://habrastorage.org/webt/jt/kj/c9/jtkjc97ruwb4ejlt7btjhybjh0u.png"></p><br><p>  O planejador pode antecipar o primeiro encadeamento ap√≥s a execu√ß√£o da primeira linha e o segundo encadeamento ap√≥s verificar a condi√ß√£o.  Nesse caso, os dois fluxos caem na se√ß√£o cr√≠tica e, portanto, √© "cr√≠tico" - os dois fluxos n√£o podem ser inseridos l√° simultaneamente. </p><br><p>  Podemos bloquear usando <code>sync.Mutex</code> do pacote de <code>sync</code> padr√£o.  O bloqueio de acesso nos permite indicar explicitamente que o c√≥digo deve ser executado por um thread por vez.  Com esse c√≥digo, obtemos o que precisamos. </p><br><p><img src="https://habrastorage.org/webt/5w/hf/2w/5whf2wr5xmhbkhxrnarppopowfe.png"></p><br><p>  Os bloqueios s√£o uma opera√ß√£o bastante cara.  Portanto, existem opera√ß√µes at√¥micas no n√≠vel do processador.  Nesse caso, o incremento pode ser feito at√¥mico, substituindo-o <code>atomic.AddInt64</code> opera√ß√£o <code>atomic.AddInt64</code> do pacote <code>atomic</code> . </p><br><p><img src="https://habrastorage.org/webt/-f/1o/rz/-f1orz2g4oar-_b0ef0vk7m4o6y.png"></p><br><p>  Se come√ßarmos a trabalhar com instru√ß√µes at√¥micas, precisamos n√£o apenas escrever atomicamente, mas tamb√©m ler atomicamente.  Se n√£o o fizermos, poder√£o surgir problemas. </p><br><h1 id="optimizacii--what-could-possibly-go-wrong">  Otimiza√ß√£o - O que poderia dar errado? </h1><br><p>  Fechaduras s√£o boas, mas podem ser caras.  At√¥micos s√£o baratos o suficiente para n√£o se preocupar com o desempenho. </p><br><p>  Assim, aprendemos que as primitivas de sincroniza√ß√£o introduzem sobrecarga e decidimos adicionar otimiza√ß√£o - verificaremos o sinalizador sem considerar o multithreading e depois verificaremos novamente usando as primitivas de sincroniza√ß√£o.  Tudo parece bem e deve funcionar. </p><br><p><img src="https://habrastorage.org/webt/jq/9u/cm/jq9ucmurmj-x9y4i9eu8ojzkfem.png"></p><br><p>  Est√° tudo bem, exceto que o compilador est√° tentando otimizar nosso c√≥digo.  O que ele esta fazendo?  Ele troca as instru√ß√µes de atribui√ß√£o e obtemos um comportamento inv√°lido, porque o nosso <code>done</code> se torna <code>true</code> antes que o valor da vari√°vel " <code></code> " seja atribu√≠do. </p><br><p>  N√£o tente fazer essas otimiza√ß√µes - por causa delas, voc√™ ter√° muitos problemas.  Aconselho que voc√™ leia a especifica√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Go Memory Model</a> e um artigo de Dmitry Vyukova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@dvyukov</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ra√ßas de dados benignas: o que poderia dar errado?</a>  para entender melhor os problemas. </p><br><p>  Se voc√™ realmente confia no desempenho dos bloqueios - escreva um c√≥digo sem bloqueios, mas n√£o precisar√° acessar n√£o sincronizado a mem√≥ria. </p><br><h1 id="deadlock">  Impasse </h1><br><p>  O pr√≥ximo problema que enfrentaremos √© o impasse.  Pode parecer que tudo √© bastante trivial aqui.  Existem dois recursos, por exemplo, dois <code>Mutex</code> .  No primeiro segmento, capturamos primeiro o primeiro <code>Mutex</code> e, no segundo, capturamos primeiro o segundo <code>Mutex</code> .  Al√©m disso, quereremos pegar o segundo <code>Mutex</code> no primeiro thread, mas n√£o conseguiremos fazer isso, porque ele j√° est√° bloqueado.  No segundo segmento, tentaremos pegar, respectivamente, o primeiro <code>Mutex</code> e tamb√©m o bloco.  L√° est√° ele, Deadlock. </p><br><p><img src="https://habrastorage.org/webt/pe/vk/y1/pevky1zcbkqtftopczdgbg2_xuu.png"></p><br><p>  Nenhum desses dois encadeamentos poder√° progredir mais, pois os dois aguardar√£o o recurso.  Como isso √© resolvido?  Trocamos bloqueios e, em seguida, n√£o surgem problemas.  Obviamente, √© f√°cil dizer, mas manter essa regra por toda a vida √∫til do produto n√£o √© f√°cil.  Se poss√≠vel, fa√ßa - <strong>pegue e solte os bloqueios na mesma ordem</strong> . </p><br><p>  Pode parecer que desenvolvedores experientes n√£o encontram esses erros, mas aqui est√° um exemplo de um impasse no c√≥digo do projeto etcd. </p><br><p><img src="https://habrastorage.org/webt/iq/8l/pe/iq8lpexqj2xc_ykt2qzzgbxxiwu.png"></p><br><p>  Aqui, o principal problema √© que a grava√ß√£o em um canal sem buffer est√° bloqueando; para escrever, voc√™ precisa de um leitor, por outro lado.  Tomando o mutex, o primeiro segmento aguarda o leitor aparecer.  O segundo segmento n√£o pode mais capturar o mutex.  Impasse </p><br><p>  Eu aconselho voc√™ a experimentar o emocionante jogo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Deadlock Empire</a> .  Neste jogo, voc√™ age como um agendador que deve alternar o contexto para impedir que o c√≥digo seja executado corretamente. </p><br><h1 id="sort-of-problems">  Tipo de problemas </h1><br><p>  Que problemas ainda existem?  Come√ßamos com as <strong>condi√ß√µes da corrida</strong> .  Em seguida, analisamos o <strong>Deadlock</strong> (ainda existe uma variante do <strong>Livelock</strong> , √© quando n√£o podemos capturar o recurso, mas n√£o h√° bloqueios expl√≠citos).  H√° <strong>fome</strong> , √© quando vamos √† impressora imprimir um peda√ßo de papel, e h√° uma fila e n√£o podemos acessar o recurso.  Analisamos o comportamento do programa com o <strong>compartilhamento falso</strong> .  Ainda existe um problema - <strong>Bloquear conten√ß√£o</strong> , quando o desempenho diminui devido a muita concorr√™ncia por um recurso (por exemplo, um mutex que um grande n√∫mero de encadeamentos precisa). </p><br><p><img src="https://habrastorage.org/webt/yo/5x/dz/yo5xdzb1iqwunpsqjitejygw_ji.png"></p><br><h1 id="race-detection">  Detec√ß√£o de corrida </h1><br><p>  O Go √© poderoso com a caixa de ferramentas fornecida imediatamente.  <strong>O Race Detector</strong> √© uma dessas ferramentas.  Us√°-lo √© simples: escrevemos testes ou executamos em uma carga de combate e detectamos erros. <br>  Voc√™ pode ler mais sobre o uso do Race Detector <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na documenta√ß√£o</a> , mas lembre-se de que ele tem limita√ß√µes.  Vamos nos debru√ßar sobre eles com mais detalhes. </p><br><p><img src="https://habrastorage.org/webt/sq/ft/kq/sqftkq68nj93cffxblalpvqss9s.png"></p><br><p>  Em primeiro lugar, o c√≥digo que n√£o foi executado n√£o √© verificado pelo Race Detector.  Portanto, a cobertura do teste deve ser alta.  Al√©m disso, o Race Detector lembra o hist√≥rico de chamadas para cada palavra na mem√≥ria, mas esse hist√≥rico de chamadas tem profundidade.  No Go, por exemplo, essa profundidade √© de quatro - quatro elementos, quatro acessos.  Se o Detector de Regatas n√£o conseguiu uma corrida nessa profundidade, ele acredita que n√£o h√° corrida.  Portanto, embora o Race Detector nunca esteja errado, ele n√£o detectar√° todos os erros.  Voc√™ pode esperar pelo Detector de Corrida, mas precisa se lembrar de suas limita√ß√µes.  Separadamente, voc√™ pode ler sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algoritmo do trabalho</a> . </p><br><h1 id="block-profile">  Bloquear perfil </h1><br><p>  <strong>O perfil de bloco</strong> √© outra ferramenta que nos permite encontrar e corrigir problemas de bloqueio. </p><br><p><img src="https://habrastorage.org/webt/hg/ex/ft/hgexftmdroak4fgg0udjq4s4vow.png"></p><br><p>  Ele pode ser usado no n√≠vel de teste de refer√™ncia e pode ser observado durante a carga de combate.  Portanto, se voc√™ estiver procurando por problemas associados √† sincroniza√ß√£o de acesso a dados, tente come√ßar com o Race Detector e continue usando o Block Profile. </p><br><h1 id="primer-programmy">  Exemplo de programa </h1><br><p>  Vejamos o c√≥digo real no qual podemos trope√ßar.  Escreveremos uma fun√ß√£o que simplesmente pega uma matriz de solicita√ß√µes e tenta execut√°-las: cada solicita√ß√£o em sequ√™ncia.  Se algum dos pedidos retornar um erro, a fun√ß√£o encerrar√° a execu√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/r_/kl/3w/r_kl3wjbfxfsfa5dvbs34afvtww.png"></p><br><p>  Se escrevermos em Go, devemos usar todo o poder da linguagem.  N√≥s tentamos.  Temos tr√™s vezes mais c√≥digo. </p><br><p><img src="https://habrastorage.org/webt/nc/qt/_q/ncqt_qwhoahbahx9tdmuspt1_1c.png"></p><br><p>  Pergunta: h√° algum erro no c√≥digo? </p><br><p>  Claro!  Vamos ver quais. </p><br><p>  No loop, executamos goroutines.  Para orquestra√ß√£o de goroutines, usamos <code>sync.WaitGroup</code> .  Mas o que estamos fazendo de errado?  J√° dentro da goroutine em execu√ß√£o, chamamos <code>wg.Add(1)</code> , ou seja, adicionamos mais uma goroutine para aguardar.  E usando <code>wg.Wait()</code> , estamos aguardando a conclus√£o de todas as goroutines.  Mas pode acontecer que, no momento em que <code>wg.Wait()</code> seja chamado, nenhuma goroutine seja iniciada.  Nesse caso, <code>wg.Wait()</code> considerar√° que tudo est√° feito, fecharemos o canal e sairemos da fun√ß√£o sem erros, acreditando que est√° tudo bem. </p><br><p><img src="https://habrastorage.org/webt/o1/wv/7m/o1wv7mielcch1r4k3zmdgfksbk4.png"></p><br><p>  O que acontecer√° depois?  Em seguida, as goroutines ser√£o iniciadas, o c√≥digo ser√° executado e talvez uma das solicita√ß√µes retorne um erro.  Um erro √© gravado em um canal fechado e a grava√ß√£o em um canal fechado √© um p√¢nico.  Nosso aplicativo falhar√°.  √â improv√°vel que isso fosse o que eu queria obter, ent√£o o corrigimos indicando antecipadamente quantas goroutines lan√ßaremos. </p><br><p><img src="https://habrastorage.org/webt/ly/re/v6/lyrev61roq8cswx4q0itv12reyy.png"></p><br><p>  Talvez ainda haja alguns problemas? </p><br><p>  H√° um erro relacionado a como o objeto <code>req</code> aparece dentro da fun√ß√£o.  A vari√°vel <code>req</code> atua como um iterador do ciclo e n√£o sabemos qual valor ter√° no momento do lan√ßamento da goroutine. </p><br><p><img src="https://habrastorage.org/webt/wi/xc/m2/wixcm2d3adxkmbqobaoapwm4ofq.png"></p><br><p>  Na pr√°tica, nesse c√≥digo, o valor <code>req</code> provavelmente ser√° igual ao √∫ltimo elemento da matriz.  Portanto, voc√™ acabou de enviar a mesma solicita√ß√£o N vezes.  Corre√ß√£o: passa explicitamente nossa solicita√ß√£o como argumento para a fun√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/3g/gq/ty/3ggqtyg5-pgxmfhfkwruozrajyg.png"></p><br><p>  Vamos dar uma olhada em como lidamos com erros.  Declaramos um canal em buffer em um slot.  Quando ocorre um erro, enviamos para este canal.  Tudo parece estar bem: ocorreu um erro - retornamos esse erro de uma fun√ß√£o. </p><br><p><img src="https://habrastorage.org/webt/3_/5-/ku/3_5-kufkknuxpfmc1tpsqn_aqr4.png"></p><br><p>  Mas e se todos os pedidos retornarem com um erro? </p><br><p>  Em seguida, escrever no canal receber√° apenas o primeiro erro, o restante bloquear√° a execu√ß√£o de goroutines.  Como n√£o haver√° mais leituras do canal na hora de sair da fun√ß√£o de leitura, temos um vazamento de goroutine.  Ou seja, todas aquelas gorutinas que n√£o conseguiram gravar o erro no canal simplesmente ficam na mem√≥ria. </p><br><p>  N√≥s corrigimos isso de maneira muito simples: selecionamos no canal do slot o n√∫mero de solicita√ß√µes.  Isso resolve nosso problema com pouca mem√≥ria, porque se tivermos um bilh√£o de solicita√ß√µes, precisamos alocar um bilh√£o de slots. </p><br><p><img src="https://habrastorage.org/webt/qe/nm/te/qenmteeutwuvzmmlu_lqjrnrhgy.png"></p><br><p>  N√≥s resolvemos os problemas.  O c√≥digo agora √© competitivo.  Mas o problema est√° na legibilidade - em compara√ß√£o com a vers√£o s√≠ncrona do c√≥digo, h√° muito.  E isso n√£o √© legal, porque o desenvolvimento de programas competitivos j√° √© dif√≠cil, por que o complicamos com muito c√≥digo? </p><br><p><img src="https://habrastorage.org/webt/ww/jx/v3/wwjxv3vhcewmqajtzlsrgqrsbli.png"></p><br><h1 id="errgroup">  Errgroup </h1><br><p>  Eu sugiro aumentar a legibilidade do c√≥digo. </p><br><p>  Eu gosto de usar o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">errgroup em</a> vez do <code>sync.WaitGroup</code> .  Este pacote n√£o requer a especifica√ß√£o de quantas goroutines esperar e permite que voc√™ ignore a cole√ß√£o de erros.  √â assim que nossa fun√ß√£o ser√° <code>errgroup</code> ao usar o <code>errgroup</code> : </p><br><p><img src="https://habrastorage.org/webt/p4/da/no/p4danooucpgyforvks7qd4eqmmi.png"></p><br><p>  Al√©m disso, o <code>errgroup</code> permite orquestrar convenientemente os componentes do nosso programa usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">context.Context</a> .  O que eu quero dizer? </p><br><p>  Suponha que tenhamos v√°rios componentes de nosso programa; se pelo menos um deles falhar, queremos concluir cuidadosamente todos os outros.  Portanto, o grupo de <code>errgroup</code> quando <code>errgroup</code> um erro, completa o <code>context</code> e, portanto, todos os componentes recebem uma notifica√ß√£o sobre a necessidade de concluir o trabalho. </p><br><p><img src="https://habrastorage.org/webt/5l/gb/95/5lgb95elqafmsoakuaktm1_nn2u.png"></p><br><p>  Isso pode ser usado para criar programas complexos de m√∫ltiplos componentes que se comportam de maneira previs√≠vel. </p><br><h1 id="vyvody">  Conclus√µes </h1><br><p>  Torne o mais simples poss√≠vel.  Melhor de forma s√≠ncrona.  O desenvolvimento de programas multithread √© geralmente um processo complexo, levando ao aparecimento de erros desagrad√°veis. </p><br><p><img src="https://habrastorage.org/webt/by/bl/nz/byblnzeor9pzwpraobylgc5yfme.png"></p><br><p>  N√£o use sincroniza√ß√£o impl√≠cita.  Se voc√™ realmente descansou, pense em como se livrar dos bloqueios, como criar um algoritmo sem bloqueios. </p><br><p>  Go √© uma boa linguagem para escrever programas que funcionam efetivamente com um grande n√∫mero de n√∫cleos, mas n√£o √© melhor que todos os outros idiomas, e os erros sempre aparecer√£o.  Portanto, mesmo armado com o Go, tente entender v√°rios n√≠veis de abstra√ß√µes abaixo do que voc√™ trabalha. </p><br><p><img src="https://habrastorage.org/webt/ze/i7/rd/zei7rd4-t5-oxw-imkx2is7qlrc.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466495/">https://habr.com/ru/post/pt466495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466479/index.html">Usando o PVS-Studio ao verificar projetos do Unreal Engine no sistema operacional Windows</a></li>
<li><a href="../pt466485/index.html">Carros el√©tricos dos anos 90. Parte 1. Irm√£os Citroen e Peugeot</a></li>
<li><a href="../pt466489/index.html">Os engenheiros coreanos sugerem o uso da Hololens como alternativa √†s divis√≥rias de escrit√≥rio</a></li>
<li><a href="../pt466491/index.html">Projeto de Treinamento em Godot - Pong (Parte 2) Criando e Configurando a Bola</a></li>
<li><a href="../pt466493/index.html">Docker: Para come√ßar. Aten√ß√£o Implantar</a></li>
<li><a href="../pt466497/index.html">Ambiente moderno para aplicativos React Native</a></li>
<li><a href="../pt466501/index.html">A√ß√µes do Github e constru√ß√£o de plataforma cruzada</a></li>
<li><a href="../pt466503/index.html">Slurm DevOps. Segundo dia. IaC, testes de infraestrutura e "Slurm inspira!"</a></li>
<li><a href="../pt466505/index.html">YIMP - Painel de Controle para o Yii 2 no Bootstrap 4</a></li>
<li><a href="../pt466509/index.html">Um olhar para dentro: o processo do dispositivo para trabalhar e adapta√ß√£o no Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>