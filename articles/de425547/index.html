<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 🔊 😖 Qt: Zeichnung basierend auf Vektorgrafiken 🕸️ 🤴🏻 👆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt bietet dem Programmierer sehr umfangreiche Funktionen, aber die Anzahl der Widgets ist begrenzt. Wenn keines der verfügbaren Elemente geeignet ist,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: Zeichnung basierend auf Vektorgrafiken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt bietet dem Programmierer sehr umfangreiche Funktionen, aber die Anzahl der Widgets ist begrenzt.  Wenn keines der verfügbaren Elemente geeignet ist, müssen Sie etwas Eigenes zeichnen.  Der einfachste Weg - vorgefertigte Bilder zu verwenden - weist schwerwiegende Nachteile auf: die Notwendigkeit, Bilder in einer Datei oder in Ressourcen zu speichern, Probleme mit der Skalierbarkeit und Portabilität von Bildformaten.  Im Folgenden wird die Verwendung der Prinzipien von Vektorgrafiken ohne Verwendung der tatsächlichen Vektorgrafiken beschrieben. </p><a name="habracut"></a><br><h2 id="preambula">  Präambel </h2><br><p>  Alles begann mit der Tatsache, dass einmal ein Hinweis auf Ein-Bit-Zeichen benötigt wurde.  Einige Anwendungen empfangen Daten an einem Port. Das Paket muss zerlegt und auf dem Bildschirm angezeigt werden.  Es wäre gleichzeitig schön, das vertraute Dashboard irgendwie nachzuahmen.  Um digitale Daten anzuzeigen, bietet Qt die QLCDNumber-Klasse "out of the box" an, ähnlich den bekannten Sieben-Segment-Anzeigen, aber bei einzelnen Lampen ist etwas nicht sichtbar. </p><br><p>  Die Verwendung von Flags (sie sind Kontrollkästchen) und Schaltern (sie sind Optionsfelder) für diese Zwecke ist schlecht, und hier ist eine Liste von Gründen: </p><br><ul><li>  Das ist semantisch falsch.  Schaltflächen - Sie sind Schaltflächen und dienen zur Benutzereingabe und nicht dazu, ihm etwas anzuzeigen. </li><li>  Dies impliziert das zweite: Der Benutzer bemüht sich, auf solche Tasten zu stoßen.  Wenn gleichzeitig die Informationsaktualisierung nicht besonders schnell ist, liegt die Anzeige und der Benutzer meldet ein fehlerhaftes Programm, das heftig kichert. </li><li>  Wenn Sie die Taste zum Drücken sperren (setEnabled (false)), wird sie hässlich grau.  Ich erinnere mich, dass es in Delphi in der Region von Version 6 eine solche Finte mit Ohren gab: Man konnte eine Flagge auf das Panel setzen und die Verfügbarkeit des Panels deaktivieren, nicht die Flagge, dann war die Flagge weder grau noch aktiv.  Dieser Trick funktioniert hier nicht. </li><li>  Die Tasten haben einen Eingabefokus.  Wenn sich also Eingabeelemente im Fenster befinden und der Benutzer mit der Tabulatortaste daran entlang geht, muss er entlang der Ausgabeelemente gehen, was unpraktisch und hässlich ist. </li><li>  Am Ende sehen diese Tasten nur unästhetisch aus, besonders neben dem Siebensegment. </li></ul><br><p>  Fazit: Sie müssen selbst eine Glühbirne zeichnen. </p><br><h2 id="muki-vybora">  Mehl der Wahl </h2><br><p>  Zuerst suchte ich nach vorgefertigten Lösungen.  In dieser Zeit, als ich Delphi verwendete, konnte man nur eine gigantische Menge fertiger Komponenten finden, sowohl von seriösen Unternehmen als auch von Amateurherstellern.  Qt hat große Probleme damit.  QWT hat einige Elemente, aber das nicht.  Amateurismus habe ich überhaupt nicht gesehen.  Wenn Sie auf Github richtig graben, können Sie wahrscheinlich etwas finden, aber ich werde es wahrscheinlich selbst schneller machen. </p><br><p>  Das erste, was sich aus dem hausgemachten herausstellte, war die Verwendung von zwei Bilddateien mit Bildern des Lichts ein und aus.  Schlecht: </p><br><ul><li>  Es ist notwendig, gute Bilder zu finden (oder zu zeichnen, aber ich bin kein Künstler). </li><li>  Die Frage des Prinzips lautet: Binden ist nicht gut, auch Bilder, sogar unter den Füßen liegen; </li><li>  Sie müssen irgendwo aufbewahrt werden.  Die Dateien sind sehr schlecht: versehentlich gelöscht - und es gibt keine Schaltflächen.  Die Ressourcen sind besser, aber ich habe auch keine Lust, durchzukommen. </li><li>  Keine Skalierbarkeit; </li><li>  Die Anpassbarkeit (z. B. Farben) wird nur durch Hinzufügen von Dateien erreicht.  Das heißt, ressourcenintensiv und unflexibel. </li></ul><br><p>  Das zweite, was sich aus dem ersten ergibt, ist die Verwendung von Vektorbildern anstelle von Bildern.  Darüber hinaus kann Qt SVG rendern.  Hier ist die Suche nach dem Bild selbst schon etwas einfacher: Es gibt viele Lektionen zu den Vektorgrafiken im Netzwerk, Sie können etwas mehr oder weniger geeignetes finden und es an Ihre Bedürfnisse anpassen.  Es bleibt jedoch die Frage nach Speicherung und Anpassung, und das Rendern ist nicht ressourcenfrei.  Pennies natürlich, aber immer noch ... </p><br><p>  Und der dritte folgt aus dem zweiten: Sie können die Prinzipien der Vektorgrafik zum Selbstzeichnen von Bildern verwenden!  Eine Vektorbilddatei in Textform gibt an, was und wie gezeichnet werden soll.  Ich kann den gleichen Code mithilfe von Vektor-Tutorials angeben.  Glücklicherweise verfügt das QPainter-Objekt über die erforderlichen Werkzeuge: einen Stift, einen Pinsel, einen Verlauf und Zeichenprimitive sowie eine Texturfüllung.  Ja, die Werkzeuge sind bei weitem nicht alles: Es gibt keine Masken, Mischmodi, aber es ist absolut kein Fotorealismus erforderlich. </p><br><p>  Ich habe im Internet nach einigen Beispielen gesucht.  Er nahm die erste Lektion, die auftauchte: "Wir zeichnen eine Schaltfläche im Inkscape-Grafikeditor" von der Website "Es ist einfach zu zeichnen."  Der Knopf aus dieser Lektion ähnelt viel eher einer Glühbirne als einem Knopf, was perfekt zu mir passt.  Ich mache einen Entwurf: Anstelle von Inkscape, einem Projekt in Qt. </p><br><h2 id="proba-pera">  Federtest </h2><br><p>  Ich erstelle ein neues Projekt.  Ich wähle den Namen des Projekts rgbled (weil ich so etwas wie eine RGB-LED machen möchte) und den Pfad dazu.  Ich wähle die Basisklasse QWidget und den Namen RgbLed und lehne es ab, eine Formulardatei zu erstellen.  Das Projekt macht nach dem Start standardmäßig ein leeres Fenster, es ist immer noch uninteressant. </p><br><h3 id="podgotovka-k-risovaniyu">  Vorbereitung zum Zeichnen </h3><br><p>  Es ist ein Leerzeichen.  Jetzt müssen Sie die privaten Mitglieder der Klasse abrufen, die die Geometrie des Bildes bestimmen.  Ein wesentlicher Vorteil von Vektorgrafiken ist ihre Skalierbarkeit, daher sollte es ein Minimum an konstanten Zahlen geben, und sie legen nur die Proportionen fest.  Die Dimensionen werden im resizeEvent () -Ereignis neu berechnet, das neu definiert werden muss. </p><br><p>  Im verwendeten Zeichentutorial werden die Abmessungen im Laufe der Zeit in Pixel angegeben.  Ich muss im Voraus bestimmen, was ich verwenden werde und wie ich nachzählen soll. </p><br><p>  Ein gezeichnetes Bild besteht aus folgenden Elementen: </p><br><ul><li>  Außenring (nach außen geneigt, Teil des konvexen Randes) </li><li>  Innenring (nach innen gekippt) </li><li>  LED-Lampengehäuse, „Glas“ </li><li>  Schatten am Rand des Glases </li><li>  Top-Highlight </li><li>  Bodenfackel </li></ul><br><p>  Konzentrische Kreise, dh alles außer der Blendung, werden durch die Position des Zentrums und den Radius bestimmt.  Die Blendung wird durch die Mitte, Breite und Höhe bestimmt, und die Position der X-Blendungszentren stimmt mit der Position der X-Mitte des gesamten Bildes überein. </p><br><p>  Um die Elemente der Geometrie zu berechnen, müssen Sie bestimmen, welche größer ist - die Breite oder Höhe, da die Glühbirne rund ist und in ein Quadrat mit einer Seite passen muss, die der kleineren der beiden Dimensionen entspricht.  Also füge ich die entsprechenden privaten Mitglieder zur Header-Datei hinzu. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Dann definiere ich die geschützte Funktion neu, die aufgerufen wird, wenn die Größe des Widgets geändert wird. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Hier wird die Seite des Quadrats berechnet, in die die Glühbirne eingeschrieben ist, die Mitte dieses Quadrats, der Radius der Felge, die die maximal mögliche Fläche einnimmt, die Breite der Felge, deren äußerer Teil 1/10 des Durchmessers betragen sollte, und der innere Teil 1/14.  Dann wird die Position der Blendung berechnet, die sich in der Mitte des oberen und unteren Radius befindet, die Breite und Höhe werden mit dem Auge ausgewählt. </p><br><p>  Außerdem werde ich in den geschützten Feldern sofort eine Reihe von Farben hinzufügen, die verwendet werden sollen. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  An den Namen ist ungefähr klar, dass dies die Farben der Glühbirne, der helle Teil des Schattens, der dunkle Teil des Schattens, die drei Farben des ringförmigen Schattens um die Glühbirne und die Farben der Blendungsverläufe sind. </p><br><p>  Die Farben sollten initialisiert werden, damit ich das Werkstück des Designers ergänzen kann. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  Vergessen Sie auch nicht, die Einschlüsse von Klassen, die beim Zeichnen benötigt werden, in die Header-Datei einzufügen. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Dieser Code wird erfolgreich kompiliert, aber im Widget-Fenster hat sich nichts geändert.  Es ist Zeit zu zeichnen. </p><br><h3 id="risovanie">  Zeichnen </h3><br><p>  Ich gebe eine geschlossene Funktion ein </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  und definieren Sie die geschützte Funktion neu </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  Das Neuzeichnungsereignis bewirkt die eigentliche Zeichnung, an die die Farbe des "Glases" als Parameter übergeben wird. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  So weit so.  Und wir beginnen allmählich, die Zeichenfunktion auszufüllen. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Zunächst wird ein Künstlerobjekt erstellt, das mit dem Zeichnen beschäftigt ist.  Dann wird ein Bleistift erstellt, der benötigt wird, damit kein Bleistift vorhanden ist: In diesem Bild wird der Konturstrich nicht nur nicht, sondern überhaupt nicht benötigt. </p><br><p>  Dann wird der erste Kreis ungefähr gemäß der Lektion über Vektorgrafiken gezeichnet: ein großer Kreis, gefüllt mit einem radialen Gradienten.  Der Farbverlauf hat oben einen hellen Ankerpunkt, aber nicht ganz am Rand, und unten einen dunklen, aber auch nicht ganz am Rand.  Basierend auf dem Farbverlauf wird ein Pinsel erstellt. Dieser Pinselmaler malt einen Kreis (dh eine Ellipse, die in ein Quadrat eingeschrieben ist).  Es stellt sich ein solcher Code heraus </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  Die Umgebung betont den Farbparameter der Funktion drawLed, da er nicht verwendet wird.  Lass ihn tolerieren, er wird noch nicht gebraucht, aber er wird es bald brauchen.  Das gestartete Projekt führt zu folgendem Ergebnis: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  Fügen Sie einen weiteren Code-Stapel hinzu. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Fast der gleiche Kreis, nur kleiner und verkehrt herum.  Wir bekommen folgendes Bild: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Dann brauchen Sie endlich die Farbe des Glases: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Hier wird unter Verwendung der dunkleren Funktion aus der übertragenen Farbe dieselbe Farbe erhalten, jedoch dunkler, um den Gradienten zu organisieren.  Koeffizient 120 mit dem Auge ausgewählt.  Hier ist das Ergebnis: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  Fügen Sie einen ringförmigen Schatten um das Glas hinzu.  Dies geschieht in der Lektion über Vektorgrafiken und sollte Volumen und Realismus hinzufügen: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Es gibt einen dreistufigen Farbverlauf, so dass der Schatten bis zum Rand dicker wird und zur Mitte hin blass wird.  Es stellt sich so heraus: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  Fügen Sie beide Highlights gleichzeitig hinzu.  Das obere Highlight wird im Gegensatz zum unteren (und allen anderen Elementen) linear dargestellt.  Der Künstler von mir ist so lala, ich nehme mein Wort für den Autor der Lektion.  Vielleicht stimmt das, ich werde nicht mit verschiedenen Arten von Verläufen experimentieren. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  Das ist in der Tat alles, eine fertige Glühbirne, wie bei KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  Die Sichtbarkeit von Blendung und Ausbuchtung des Glases wird durch die Farbe oder vielmehr durch die Dunkelheit beeinflusst.  Es mag sinnvoll sein, je nach Dunkelheit eine Anpassung für die Helligkeit der Blendung und den Dimmkoeffizienten in der dunkleren Funktion hinzuzufügen, aber das ist Perfektionismus, denke ich. </p><br><p>  Unten finden Sie ein Beispiel für die Verwendung in einem Programmfenster. </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Verwöhnen </h3><br><p>  Zum Spaß können Sie mit Blumen herumspielen.  Beispiel: Überschreiben eines geschützten Mausklickereignisses </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  auf diese Weise: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  Nicht zu vergessen, Mausereignisse zum Header hinzuzufügen: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Jetzt ändert ein Mausklick auf die Komponente die Farbe der Glühbirne: Rot, Grün, Blau, Grau und etwas zufälliges Licht von der Lampe. </p><br><h2 id="epilog">  Nachwort </h2><br><p>  Das Zeichnen ist alles.  Und das Widget sollte Funktionen hinzufügen.  In meinem Fall wurde ein boolesches Feld "use state" hinzugefügt, ein weiteres boolesches Feld, das den Status "On" oder "Off" und die Standardfarben für diese Zustände definiert, sowie offene Getter und Setter für all dies. Diese Felder werden in verwendet Mit der Funktion paintEvent () können Sie die Farbe auswählen, die als Parameter an drawLed () übergeben wird. Infolgedessen können Sie die Verwendung von Zuständen deaktivieren und die Glühbirne auf eine beliebige Farbe einstellen oder die Zustände aktivieren und die Glühbirne je nach Ereignis ein- oder ausschalten verbunden  sei es mit dem Signal, das überwacht werden muß. </p><br><p>  Die Verwendung von mousePressEvent zeigt, dass ein Widget nicht nur als Indikator, sondern auch als Schaltfläche erstellt werden kann. Dadurch wird es gedrückt, freigegeben, gebogen, gedreht, farbig und was auch immer Sie möchten, für die Ereignisse Zeigen, Klicken und Freigeben. </p><br><p>  Dies ist jedoch nicht mehr grundlegend.  Ziel war es zu zeigen, wo Sie beim Zeichnen Ihrer eigenen Widgets Vorbilder verwenden können und wie diese Zeichnung ohne Verwendung von Raster- oder Vektorbildern in Ressourcen oder Dateien einfach implementiert werden kann. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425547/">https://habr.com/ru/post/de425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425531/index.html">Kühlung der Flüssigkeitsbremse. Systementwicklungsoptionen</a></li>
<li><a href="../de425533/index.html">So arbeiten Sie in der Cloud: von der Überprüfung der Zuverlässigkeit eines Rechenzentrums bis zur Verwaltung einer virtuellen Infrastruktur</a></li>
<li><a href="../de425537/index.html">Wie man Java, Js und Grafiken mit Kunst kombiniert oder wie ein interaktives Theater geschaffen wurde</a></li>
<li><a href="../de425541/index.html">So umgehen Sie schnell und ohne unnötige Chips die Unveränderlichkeit der Adresse des HTU21-Sensors</a></li>
<li><a href="../de425545/index.html">Sie sollten über Stunden des Übens nachdenken.</a></li>
<li><a href="../de425549/index.html">Supermicro-Aktien stürzen bei der Untersuchung des Einsatzes chinesischer Spionagechips ab</a></li>
<li><a href="../de425551/index.html">Wer sollte Geld aus dem Verkauf eines von AI geschaffenen Kunstwerks erhalten?</a></li>
<li><a href="../de425553/index.html">Was der Graf von Monte Cristo über Cybersicherheit sagen kann</a></li>
<li><a href="../de425555/index.html">Charles Nutter über dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425557/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausführung, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>