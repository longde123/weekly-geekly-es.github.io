<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø üîä üòñ Qt: Zeichnung basierend auf Vektorgrafiken üï∏Ô∏è ü§¥üèª üëÜüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt bietet dem Programmierer sehr umfangreiche Funktionen, aber die Anzahl der Widgets ist begrenzt. Wenn keines der verf√ºgbaren Elemente geeignet ist,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: Zeichnung basierend auf Vektorgrafiken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt bietet dem Programmierer sehr umfangreiche Funktionen, aber die Anzahl der Widgets ist begrenzt.  Wenn keines der verf√ºgbaren Elemente geeignet ist, m√ºssen Sie etwas Eigenes zeichnen.  Der einfachste Weg - vorgefertigte Bilder zu verwenden - weist schwerwiegende Nachteile auf: die Notwendigkeit, Bilder in einer Datei oder in Ressourcen zu speichern, Probleme mit der Skalierbarkeit und Portabilit√§t von Bildformaten.  Im Folgenden wird die Verwendung der Prinzipien von Vektorgrafiken ohne Verwendung der tats√§chlichen Vektorgrafiken beschrieben. </p><a name="habracut"></a><br><h2 id="preambula">  Pr√§ambel </h2><br><p>  Alles begann mit der Tatsache, dass einmal ein Hinweis auf Ein-Bit-Zeichen ben√∂tigt wurde.  Einige Anwendungen empfangen Daten an einem Port. Das Paket muss zerlegt und auf dem Bildschirm angezeigt werden.  Es w√§re gleichzeitig sch√∂n, das vertraute Dashboard irgendwie nachzuahmen.  Um digitale Daten anzuzeigen, bietet Qt die QLCDNumber-Klasse "out of the box" an, √§hnlich den bekannten Sieben-Segment-Anzeigen, aber bei einzelnen Lampen ist etwas nicht sichtbar. </p><br><p>  Die Verwendung von Flags (sie sind Kontrollk√§stchen) und Schaltern (sie sind Optionsfelder) f√ºr diese Zwecke ist schlecht, und hier ist eine Liste von Gr√ºnden: </p><br><ul><li>  Das ist semantisch falsch.  Schaltfl√§chen - Sie sind Schaltfl√§chen und dienen zur Benutzereingabe und nicht dazu, ihm etwas anzuzeigen. </li><li>  Dies impliziert das zweite: Der Benutzer bem√ºht sich, auf solche Tasten zu sto√üen.  Wenn gleichzeitig die Informationsaktualisierung nicht besonders schnell ist, liegt die Anzeige und der Benutzer meldet ein fehlerhaftes Programm, das heftig kichert. </li><li>  Wenn Sie die Taste zum Dr√ºcken sperren (setEnabled (false)), wird sie h√§sslich grau.  Ich erinnere mich, dass es in Delphi in der Region von Version 6 eine solche Finte mit Ohren gab: Man konnte eine Flagge auf das Panel setzen und die Verf√ºgbarkeit des Panels deaktivieren, nicht die Flagge, dann war die Flagge weder grau noch aktiv.  Dieser Trick funktioniert hier nicht. </li><li>  Die Tasten haben einen Eingabefokus.  Wenn sich also Eingabeelemente im Fenster befinden und der Benutzer mit der Tabulatortaste daran entlang geht, muss er entlang der Ausgabeelemente gehen, was unpraktisch und h√§sslich ist. </li><li>  Am Ende sehen diese Tasten nur un√§sthetisch aus, besonders neben dem Siebensegment. </li></ul><br><p>  Fazit: Sie m√ºssen selbst eine Gl√ºhbirne zeichnen. </p><br><h2 id="muki-vybora">  Mehl der Wahl </h2><br><p>  Zuerst suchte ich nach vorgefertigten L√∂sungen.  In dieser Zeit, als ich Delphi verwendete, konnte man nur eine gigantische Menge fertiger Komponenten finden, sowohl von seri√∂sen Unternehmen als auch von Amateurherstellern.  Qt hat gro√üe Probleme damit.  QWT hat einige Elemente, aber das nicht.  Amateurismus habe ich √ºberhaupt nicht gesehen.  Wenn Sie auf Github richtig graben, k√∂nnen Sie wahrscheinlich etwas finden, aber ich werde es wahrscheinlich selbst schneller machen. </p><br><p>  Das erste, was sich aus dem hausgemachten herausstellte, war die Verwendung von zwei Bilddateien mit Bildern des Lichts ein und aus.  Schlecht: </p><br><ul><li>  Es ist notwendig, gute Bilder zu finden (oder zu zeichnen, aber ich bin kein K√ºnstler). </li><li>  Die Frage des Prinzips lautet: Binden ist nicht gut, auch Bilder, sogar unter den F√º√üen liegen; </li><li>  Sie m√ºssen irgendwo aufbewahrt werden.  Die Dateien sind sehr schlecht: versehentlich gel√∂scht - und es gibt keine Schaltfl√§chen.  Die Ressourcen sind besser, aber ich habe auch keine Lust, durchzukommen. </li><li>  Keine Skalierbarkeit; </li><li>  Die Anpassbarkeit (z. B. Farben) wird nur durch Hinzuf√ºgen von Dateien erreicht.  Das hei√üt, ressourcenintensiv und unflexibel. </li></ul><br><p>  Das zweite, was sich aus dem ersten ergibt, ist die Verwendung von Vektorbildern anstelle von Bildern.  Dar√ºber hinaus kann Qt SVG rendern.  Hier ist die Suche nach dem Bild selbst schon etwas einfacher: Es gibt viele Lektionen zu den Vektorgrafiken im Netzwerk, Sie k√∂nnen etwas mehr oder weniger geeignetes finden und es an Ihre Bed√ºrfnisse anpassen.  Es bleibt jedoch die Frage nach Speicherung und Anpassung, und das Rendern ist nicht ressourcenfrei.  Pennies nat√ºrlich, aber immer noch ... </p><br><p>  Und der dritte folgt aus dem zweiten: Sie k√∂nnen die Prinzipien der Vektorgrafik zum Selbstzeichnen von Bildern verwenden!  Eine Vektorbilddatei in Textform gibt an, was und wie gezeichnet werden soll.  Ich kann den gleichen Code mithilfe von Vektor-Tutorials angeben.  Gl√ºcklicherweise verf√ºgt das QPainter-Objekt √ºber die erforderlichen Werkzeuge: einen Stift, einen Pinsel, einen Verlauf und Zeichenprimitive sowie eine Texturf√ºllung.  Ja, die Werkzeuge sind bei weitem nicht alles: Es gibt keine Masken, Mischmodi, aber es ist absolut kein Fotorealismus erforderlich. </p><br><p>  Ich habe im Internet nach einigen Beispielen gesucht.  Er nahm die erste Lektion, die auftauchte: "Wir zeichnen eine Schaltfl√§che im Inkscape-Grafikeditor" von der Website "Es ist einfach zu zeichnen."  Der Knopf aus dieser Lektion √§hnelt viel eher einer Gl√ºhbirne als einem Knopf, was perfekt zu mir passt.  Ich mache einen Entwurf: Anstelle von Inkscape, einem Projekt in Qt. </p><br><h2 id="proba-pera">  Federtest </h2><br><p>  Ich erstelle ein neues Projekt.  Ich w√§hle den Namen des Projekts rgbled (weil ich so etwas wie eine RGB-LED machen m√∂chte) und den Pfad dazu.  Ich w√§hle die Basisklasse QWidget und den Namen RgbLed und lehne es ab, eine Formulardatei zu erstellen.  Das Projekt macht nach dem Start standardm√§√üig ein leeres Fenster, es ist immer noch uninteressant. </p><br><h3 id="podgotovka-k-risovaniyu">  Vorbereitung zum Zeichnen </h3><br><p>  Es ist ein Leerzeichen.  Jetzt m√ºssen Sie die privaten Mitglieder der Klasse abrufen, die die Geometrie des Bildes bestimmen.  Ein wesentlicher Vorteil von Vektorgrafiken ist ihre Skalierbarkeit, daher sollte es ein Minimum an konstanten Zahlen geben, und sie legen nur die Proportionen fest.  Die Dimensionen werden im resizeEvent () -Ereignis neu berechnet, das neu definiert werden muss. </p><br><p>  Im verwendeten Zeichentutorial werden die Abmessungen im Laufe der Zeit in Pixel angegeben.  Ich muss im Voraus bestimmen, was ich verwenden werde und wie ich nachz√§hlen soll. </p><br><p>  Ein gezeichnetes Bild besteht aus folgenden Elementen: </p><br><ul><li>  Au√üenring (nach au√üen geneigt, Teil des konvexen Randes) </li><li>  Innenring (nach innen gekippt) </li><li>  LED-Lampengeh√§use, ‚ÄûGlas‚Äú </li><li>  Schatten am Rand des Glases </li><li>  Top-Highlight </li><li>  Bodenfackel </li></ul><br><p>  Konzentrische Kreise, dh alles au√üer der Blendung, werden durch die Position des Zentrums und den Radius bestimmt.  Die Blendung wird durch die Mitte, Breite und H√∂he bestimmt, und die Position der X-Blendungszentren stimmt mit der Position der X-Mitte des gesamten Bildes √ºberein. </p><br><p>  Um die Elemente der Geometrie zu berechnen, m√ºssen Sie bestimmen, welche gr√∂√üer ist - die Breite oder H√∂he, da die Gl√ºhbirne rund ist und in ein Quadrat mit einer Seite passen muss, die der kleineren der beiden Dimensionen entspricht.  Also f√ºge ich die entsprechenden privaten Mitglieder zur Header-Datei hinzu. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Dann definiere ich die gesch√ºtzte Funktion neu, die aufgerufen wird, wenn die Gr√∂√üe des Widgets ge√§ndert wird. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Hier wird die Seite des Quadrats berechnet, in die die Gl√ºhbirne eingeschrieben ist, die Mitte dieses Quadrats, der Radius der Felge, die die maximal m√∂gliche Fl√§che einnimmt, die Breite der Felge, deren √§u√üerer Teil 1/10 des Durchmessers betragen sollte, und der innere Teil 1/14.  Dann wird die Position der Blendung berechnet, die sich in der Mitte des oberen und unteren Radius befindet, die Breite und H√∂he werden mit dem Auge ausgew√§hlt. </p><br><p>  Au√üerdem werde ich in den gesch√ºtzten Feldern sofort eine Reihe von Farben hinzuf√ºgen, die verwendet werden sollen. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  An den Namen ist ungef√§hr klar, dass dies die Farben der Gl√ºhbirne, der helle Teil des Schattens, der dunkle Teil des Schattens, die drei Farben des ringf√∂rmigen Schattens um die Gl√ºhbirne und die Farben der Blendungsverl√§ufe sind. </p><br><p>  Die Farben sollten initialisiert werden, damit ich das Werkst√ºck des Designers erg√§nzen kann. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  Vergessen Sie auch nicht, die Einschl√ºsse von Klassen, die beim Zeichnen ben√∂tigt werden, in die Header-Datei einzuf√ºgen. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Dieser Code wird erfolgreich kompiliert, aber im Widget-Fenster hat sich nichts ge√§ndert.  Es ist Zeit zu zeichnen. </p><br><h3 id="risovanie">  Zeichnen </h3><br><p>  Ich gebe eine geschlossene Funktion ein </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  und definieren Sie die gesch√ºtzte Funktion neu </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  Das Neuzeichnungsereignis bewirkt die eigentliche Zeichnung, an die die Farbe des "Glases" als Parameter √ºbergeben wird. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  So weit so.  Und wir beginnen allm√§hlich, die Zeichenfunktion auszuf√ºllen. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Zun√§chst wird ein K√ºnstlerobjekt erstellt, das mit dem Zeichnen besch√§ftigt ist.  Dann wird ein Bleistift erstellt, der ben√∂tigt wird, damit kein Bleistift vorhanden ist: In diesem Bild wird der Konturstrich nicht nur nicht, sondern √ºberhaupt nicht ben√∂tigt. </p><br><p>  Dann wird der erste Kreis ungef√§hr gem√§√ü der Lektion √ºber Vektorgrafiken gezeichnet: ein gro√üer Kreis, gef√ºllt mit einem radialen Gradienten.  Der Farbverlauf hat oben einen hellen Ankerpunkt, aber nicht ganz am Rand, und unten einen dunklen, aber auch nicht ganz am Rand.  Basierend auf dem Farbverlauf wird ein Pinsel erstellt. Dieser Pinselmaler malt einen Kreis (dh eine Ellipse, die in ein Quadrat eingeschrieben ist).  Es stellt sich ein solcher Code heraus </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  Die Umgebung betont den Farbparameter der Funktion drawLed, da er nicht verwendet wird.  Lass ihn tolerieren, er wird noch nicht gebraucht, aber er wird es bald brauchen.  Das gestartete Projekt f√ºhrt zu folgendem Ergebnis: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  F√ºgen Sie einen weiteren Code-Stapel hinzu. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Fast der gleiche Kreis, nur kleiner und verkehrt herum.  Wir bekommen folgendes Bild: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Dann brauchen Sie endlich die Farbe des Glases: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Hier wird unter Verwendung der dunkleren Funktion aus der √ºbertragenen Farbe dieselbe Farbe erhalten, jedoch dunkler, um den Gradienten zu organisieren.  Koeffizient 120 mit dem Auge ausgew√§hlt.  Hier ist das Ergebnis: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  F√ºgen Sie einen ringf√∂rmigen Schatten um das Glas hinzu.  Dies geschieht in der Lektion √ºber Vektorgrafiken und sollte Volumen und Realismus hinzuf√ºgen: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Es gibt einen dreistufigen Farbverlauf, so dass der Schatten bis zum Rand dicker wird und zur Mitte hin blass wird.  Es stellt sich so heraus: </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  F√ºgen Sie beide Highlights gleichzeitig hinzu.  Das obere Highlight wird im Gegensatz zum unteren (und allen anderen Elementen) linear dargestellt.  Der K√ºnstler von mir ist so lala, ich nehme mein Wort f√ºr den Autor der Lektion.  Vielleicht stimmt das, ich werde nicht mit verschiedenen Arten von Verl√§ufen experimentieren. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  Das ist in der Tat alles, eine fertige Gl√ºhbirne, wie bei KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  Die Sichtbarkeit von Blendung und Ausbuchtung des Glases wird durch die Farbe oder vielmehr durch die Dunkelheit beeinflusst.  Es mag sinnvoll sein, je nach Dunkelheit eine Anpassung f√ºr die Helligkeit der Blendung und den Dimmkoeffizienten in der dunkleren Funktion hinzuzuf√ºgen, aber das ist Perfektionismus, denke ich. </p><br><p>  Unten finden Sie ein Beispiel f√ºr die Verwendung in einem Programmfenster. </p><br><div class="spoiler">  <b class="spoiler_title">Zeichnen</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Verw√∂hnen </h3><br><p>  Zum Spa√ü k√∂nnen Sie mit Blumen herumspielen.  Beispiel: √úberschreiben eines gesch√ºtzten Mausklickereignisses </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  auf diese Weise: </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  Nicht zu vergessen, Mausereignisse zum Header hinzuzuf√ºgen: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Jetzt √§ndert ein Mausklick auf die Komponente die Farbe der Gl√ºhbirne: Rot, Gr√ºn, Blau, Grau und etwas zuf√§lliges Licht von der Lampe. </p><br><h2 id="epilog">  Nachwort </h2><br><p>  Das Zeichnen ist alles.  Und das Widget sollte Funktionen hinzuf√ºgen.  In meinem Fall wurde ein boolesches Feld "use state" hinzugef√ºgt, ein weiteres boolesches Feld, das den Status "On" oder "Off" und die Standardfarben f√ºr diese Zust√§nde definiert, sowie offene Getter und Setter f√ºr all dies. Diese Felder werden in verwendet Mit der Funktion paintEvent () k√∂nnen Sie die Farbe ausw√§hlen, die als Parameter an drawLed () √ºbergeben wird. Infolgedessen k√∂nnen Sie die Verwendung von Zust√§nden deaktivieren und die Gl√ºhbirne auf eine beliebige Farbe einstellen oder die Zust√§nde aktivieren und die Gl√ºhbirne je nach Ereignis ein- oder ausschalten verbunden  sei es mit dem Signal, das √ºberwacht werden mu√ü. </p><br><p>  Die Verwendung von mousePressEvent zeigt, dass ein Widget nicht nur als Indikator, sondern auch als Schaltfl√§che erstellt werden kann. Dadurch wird es gedr√ºckt, freigegeben, gebogen, gedreht, farbig und was auch immer Sie m√∂chten, f√ºr die Ereignisse Zeigen, Klicken und Freigeben. </p><br><p>  Dies ist jedoch nicht mehr grundlegend.  Ziel war es zu zeigen, wo Sie beim Zeichnen Ihrer eigenen Widgets Vorbilder verwenden k√∂nnen und wie diese Zeichnung ohne Verwendung von Raster- oder Vektorbildern in Ressourcen oder Dateien einfach implementiert werden kann. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425547/">https://habr.com/ru/post/de425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425531/index.html">K√ºhlung der Fl√ºssigkeitsbremse. Systementwicklungsoptionen</a></li>
<li><a href="../de425533/index.html">So arbeiten Sie in der Cloud: von der √úberpr√ºfung der Zuverl√§ssigkeit eines Rechenzentrums bis zur Verwaltung einer virtuellen Infrastruktur</a></li>
<li><a href="../de425537/index.html">Wie man Java, Js und Grafiken mit Kunst kombiniert oder wie ein interaktives Theater geschaffen wurde</a></li>
<li><a href="../de425541/index.html">So umgehen Sie schnell und ohne unn√∂tige Chips die Unver√§nderlichkeit der Adresse des HTU21-Sensors</a></li>
<li><a href="../de425545/index.html">Sie sollten √ºber Stunden des √úbens nachdenken.</a></li>
<li><a href="../de425549/index.html">Supermicro-Aktien st√ºrzen bei der Untersuchung des Einsatzes chinesischer Spionagechips ab</a></li>
<li><a href="../de425551/index.html">Wer sollte Geld aus dem Verkauf eines von AI geschaffenen Kunstwerks erhalten?</a></li>
<li><a href="../de425553/index.html">Was der Graf von Monte Cristo √ºber Cybersicherheit sagen kann</a></li>
<li><a href="../de425555/index.html">Charles Nutter √ºber dynamische Sprachen in der JVM unter jug.msk.ru</a></li>
<li><a href="../de425557/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 10: Symbolische Ausf√ºhrung, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>