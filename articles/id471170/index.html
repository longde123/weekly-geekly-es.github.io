<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ» ğŸ•— â™Ÿï¸ Praktik dan frontend fungsional: monad dan functors â˜„ï¸ ğŸ‡ ğŸ‘£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Dmitry Rudnev, saya adalah pengembang frontend di BCS. Saya memulai perjalanan saya dengan tata letak antarmuka dengan berbag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktik dan frontend fungsional: monad dan functors</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bcs_company/blog/471170/">  Halo semuanya!  Nama saya Dmitry Rudnev, saya adalah pengembang frontend di BCS.  Saya memulai perjalanan saya dengan tata letak antarmuka dengan berbagai kompleksitas dan selalu memberikan perhatian khusus pada antarmuka: betapa nyamannya bagi pengguna untuk berinteraksi dengannya, jika saya bisa menyampaikan kepada pengguna antarmuka yang tepat seperti yang diinginkan oleh perancang. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/yz/ab/5d/yzab5di3ggnaaph0i7zxs16sh5k.png"></a> <br><br>  Dalam seri artikel ini saya ingin berbagi pengalaman saya menerapkan praktik fungsional dalam pengembangan frontend, saya akan berbicara tentang pro dan kontra yang akan Anda terima sebagai pengembang menggunakan praktik ini.  Jika Anda suka temanya, maka kita akan terjun ke sudut yang â€œlebih keringâ€ dan lebih kompleks dari dunia fungsional.  Saya segera mencatat bahwa kita akan beralih dari yang lebih besar ke yang lebih kecil, yaitu, kita akan melihat aplikasi klasik dari pandangan mata burung, dan ketika kita membaca artikel-artikelnya, kita akan turun ke tempat praktik tertentu akan membawa kita manfaat yang nyata. <br><br>  Jadi, mari kita mulai dengan menangani status.  Pada saat yang sama saya akan memberi tahu Anda, apalagi, monad dan functors pada umumnya. <br><a name="habracut"></a><br><h2>  Intro </h2><br>  Ketika mengungkap antarmuka berikutnya dan menemukan titik temu antara UI dan analitik, saya mulai memperhatikan bahwa setiap kali seorang pengembang berurusan dengan jaringan, ia hanya perlu memproses semua keadaan UI dan menggambarkan reaksi terhadap keadaan tertentu.  Dan karena masing-masing dari kita berjuang untuk keunggulan, ada keinginan untuk cara pemrosesan ini untuk mengeluarkan pola yang menggambarkan setransparan mungkin apa yang terjadi dan apa yang merupakan pemrakarsa dari reaksi tertentu, dan sebagai hasilnya, hasil dari pekerjaan.  Untungnya, dalam dunia pemrograman, hampir semua yang Anda pikirkan diterapkan oleh seseorang sebelum Anda. <br><br>  Baik di dunia pengembangan dan di dunia desain, tidak hanya pola yang terbentuk yang memungkinkan Anda untuk memecahkan masalah Anda secara efektif, tetapi juga antipatters, yang harus dihindari dengan segala cara agar praktik buruk tidak berkembang, dan pengembang atau perancang selalu memiliki pijakan dalam situasi, ketika tidak ada solusi konkret. <br><br>  Dalam kasus kami, situasi yang dimiliki sebagian besar pengembang adalah pemrosesan semua keadaan elemen UI dan reaksi mereka.  Masalahnya di sini adalah bahwa elemen UI dapat berinteraksi dengan keadaan lokal (tanpa menjalankan permintaan asinkron) dan dengan sumber daya atau repositori jarak jauh.  Pengembang terkadang lupa untuk menangani semua kasus tepi, yang mengarah pada perilaku sistem yang tidak konsisten secara keseluruhan. <br><br><blockquote>  Semua contoh akan berisi contoh kode menggunakan perpustakaan Bereaksi dan superset JavaScript - TypeScript, serta perpustakaan untuk pemrograman fungsional fp-ts. </blockquote><br>  Pertimbangkan contoh paling sederhana, di mana kami memiliki daftar elemen yang kami minta dari server, dan kami harus menampilkan UI dengan benar sesuai dengan hasil permintaan.  Kami tertarik pada fungsi <code>render</code> , karena di dalamnya kita perlu menampilkan status yang benar selama eksekusi permintaan.  Kode contoh lengkap dapat dilihat di: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi sederhana</a> .  Di masa depan, akan tersedia proyek yang lengkap, berfokus pada serangkaian artikel, di mana dalam kursus kita akan membongkar bagian-bagiannya masing-masing. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderInitial = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> ...; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderPending = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> ...; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderError = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> ... ; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderSuccess = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> ... ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( {state.subcribers.foldL( renderInitial, renderPending, renderError, renderSuccess, )} );</code> </pre><br>  Contoh tersebut dengan jelas menunjukkan bahwa setiap keadaan model data memiliki fungsi sendiri, dan setiap fungsi mengembalikan sebagian UI yang ditentukan untuknya (pesan, tombol, dll.).  <code>RemoteData monad</code> depan, saya akan mengatakan bahwa contoh menggunakan <code>RemoteData monad</code> . <br><br>  Itu sangat elegan, dan yang paling penting aman, kita dapat bekerja dengan data dan meresponsnya.  Ini adalah pengantar, di mana saya mencoba menunjukkan manfaat dari pendekatan fungsional dalam contoh yang tampaknya sederhana. <br><br><h2>  Functor dan Monad </h2><br>  Sekarang, mari kita mulai secara bertahap menyelami teori kategori terapan dan menganalisis konsep-konsep seperti <code>Functor</code> dan <code>Monad</code> , dan juga mempertimbangkan praktik untuk bekerja dengan data secara aman menggunakan praktik fungsional. <br><br>  <i>â€œPada dasarnya, functor tidak lebih dari struktur data yang memungkinkan Anda untuk menerapkan fungsi transformasi untuk mengekstrak nilai dari shell, memodifikasinya, dan kemudian memasukkannya kembali ke shell.</i> <i><br><br></i>  <i>Menutup nilai dalam shell atau wadah adalah pola desain dasar dalam pemrograman fungsional, karena melindungi terhadap akses langsung ke nilai-nilai, yang memungkinkan mereka untuk dimanipulasi dengan aman dan tidak berubah dalam program aplikasi. "</i> <br><br>  Saya mengambil kutipan ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku yang</a> bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang ulasan teknik pemrograman fungsional dalam JavaScript</a> .  Mari kita mulai dengan komponen teoretis dan menganalisis apa sebenarnya functor itu.  Untuk mulai dengan, kita perlu berkenalan dengan bagian yang menarik dari matematika yang disebut teori kategori di tingkat paling dasar. <br><br>  <i><b>Teori kategori</b> adalah cabang matematika yang mempelajari sifat-sifat hubungan antara objek matematika, terlepas dari struktur internal objek.</i>  <i>Teori kategori menempati tempat sentral dalam matematika modern, tetapi juga menemukan aplikasi dalam ilmu komputer, logika, dan fisika teoretis.</i> <br><br>  Kategori terdiri dari objek dan panah yang diarahkan di antara mereka.  Cara termudah untuk memvisualisasikan kategori adalah: <br><img src="https://habrastorage.org/webt/qp/ll/bv/qpllbv3kqau5lt2jwpydi9mq07a.png"><br>  Panah diatur sehingga jika Anda memiliki panah dari objek <i>A</i> ke objek <i>B</i> dan panah dari objek <i>B</i> ke <i>C</i> , maka harus ada panah - komposisinya adalah dari <i>A</i> ke <i>C.</i>  Pikirkan panah sebagai fungsi;  mereka juga disebut morfisme.  Anda memiliki fungsi <code>f</code> yang mengambil A sebagai argumen dan mengembalikan B. Ada fungsi lain <code>g</code> yang mengambil B sebagai argumen dan mengembalikan C. Anda dapat menggabungkannya dengan meneruskan hasil dari <code>f</code> ke <code>g</code> .  Kami baru saja menggambarkan fungsi baru yang mengambil A dan mengembalikan C. Dalam matematika, komposisi seperti itu dilambangkan oleh lingkaran kecil antara notasi fungsi: g â—¦ f.  Perhatikan urutan komposisi - dari kanan ke kiri. <br><br>  Dalam matematika, komposisi diarahkan dari kanan ke kiri.  Dalam hal ini, akan membantu jika Anda membaca g â—¦ f sebagai â€œg setelah fâ€. <br><br><pre> <code class="haskell hljs">-â€”   <span class="hljs-type"><span class="hljs-type">A</span></span>  <span class="hljs-type"><span class="hljs-type">B</span></span> f :: <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span> -â€”   <span class="hljs-type"><span class="hljs-type">B</span></span>   g :: <span class="hljs-type"><span class="hljs-type">B</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span> -â€” <span class="hljs-type"><span class="hljs-type">A</span></span>  <span class="hljs-type"><span class="hljs-type">C</span></span> g . f</code> </pre><br>  Ada dua sifat yang sangat penting yang harus dipenuhi komposisi dalam kategori apa pun. <br><br><ol><li>  Komposisi bersifat asosiatif (asosiatif adalah properti operasi yang memungkinkan Anda untuk mengembalikan urutan eksekusi tanpa adanya indikasi eksplisit tentang suksesi dengan prioritas yang sama; ini membedakan antara asosiatif kiri, di mana ekspresi dievaluasi dari kiri ke kanan, dan asosiatifitas kanan dari kanan ke kiri. Operator yang sesuai disebut asosiatif kiri dan asosiatif kanan Jika Anda memiliki tiga morfisme (panah), f, g dan h, yang dapat diatur (yaitu, tipenya konsisten satu sama lain), Anda  perlu tanda kurung untuk kelompok mereka. Secara matematis, ini ditulis sebagai <code>h â—¦ (g â—¦ f) = (h â—¦ g) â—¦ f = h â—¦ g â—¦ f</code> (h â—¦ g) â—¦ f = h â—¦ g â—¦ f </li><li>  Untuk setiap objek A ada panah, yang akan menjadi unit komposisi.  Panah ini dari objek ke dirinya sendiri.  Menjadi unit komposisi berarti ketika menyusun unit dengan panah apa pun yang dimulai pada A atau berakhir pada A, masing-masing, komposisi mengembalikan panah yang sama.  Panah satuan dari objek A disebut IDa (unit pada A).  Dalam notasi matematika, jika f beralih dari A ke B, maka <code>f â—¦ idA = f</code> <br><br>  Untuk bekerja dengan fungsi, panah tunggal diimplementasikan sebagai fungsi yang identik, yang hanya mengembalikan argumennya. </li></ol><br>  Sekarang kita dapat mempertimbangkan apa fungsi dalam teori kategori. <br><br>  <i>Functor adalah jenis pemetaan khusus antar kategori.</i>  <i>Ini dapat dipahami sebagai tampilan yang mempertahankan struktur.</i>  <i>Fungsi antara kategori kecil adalah morfisme dalam kategori kategori kecil.</i>  <i>Totalitas semua kategori bukan kategori dalam arti biasa, karena totalitas objeknya bukan kelas.</i>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Wikipedia</i></a> . <br><br>  Pertimbangkan contoh penerapan functor untuk wadah Maybe, yang merupakan gagasan "nilai yang mungkin tidak ada". <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compose = &lt;A, B, C&gt;( f: (a: A) =&gt; B, g: (b: B) =&gt; C, ): (a: A) =&gt; C =&gt; (a: A) =&gt; g(f(a)); //  Maybe: type Nothing = Readonly&lt;{ tag: 'Nothing' }&gt;; type Just&lt;A&gt; = Readonly&lt;{ tag: 'Just'; value: A }&gt;; export type Maybe&lt;A&gt; = Nothing | Just&lt;A&gt;; const nothing: Nothing = { tag: 'Nothing' }; const just = &lt;A&gt;(value: A): Just&lt;A&gt; =&gt; ({ tag: 'Just', value }); //    Maybe: const fmap = &lt;A, B&gt;(f: (a: A) =&gt; B) =&gt; (fa: Maybe&lt;A&gt;): Maybe&lt;B&gt; =&gt; { switch (fa.tag) { case 'Nothing': return nothing; case 'Just': return just(f(fa.value)); } }; //  1: fmap id === id namespace Laws { console.log( fmap(id)(just(42)), id(just(42)), ); // =&gt; { tag: 'Just', value: 42 } //  2: fmap f â—¦ fmap g === fmap (f â—¦ g) const f = (a: number): string =&gt; `Got ${a}!`; const g = (s: string): number =&gt; s.length; console.log( compose(fmap(f), fmap(g))(just(42)), fmap(compose(f, g))(just(42)), ); // =&gt; { tag: 'Just', value: 7 } }</code> </pre><br>  Metode <code>fmap</code> dapat dilihat dari dua sisi: <br><br><ol><li>  Sebagai cara untuk menerapkan fungsi murni ke nilai "kemas"; </li><li>  Sebagai cara untuk "meningkatkan konteks wadah" fungsi murni. </li></ol><br>  Memang, jika tanda kurung di antarmuka sedikit berbeda, kita bisa mendapatkan tanda tangan dari fungsi <code>fmap</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fmap: &lt;A, B&gt;(f: (a: A) =&gt; B) =&gt; ((ma: Maybe&lt;A&gt;) =&gt; Maybe&lt;B&gt;);</code> </pre><br>  Setelah mendefinisikan antarmuka: <br><br><pre> <code class="javascript hljs">type Function1&lt;Domain, Codomain&gt; = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a: Domain</span></span></span><span class="hljs-function">) =&gt;</span></span> Codomain;</code> </pre><br>  kami mendapatkan definisi <code>fmap</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fmap: &lt;A, B&gt;(f: (a: A) =&gt; B) =&gt; Function1&lt;Maybe&lt;A&gt;, Maybe&lt;B&gt;&gt;;</code> </pre><br>  Trik sederhana ini memungkinkan kita untuk memikirkan functor sebagai cara untuk "meningkatkan fungsi murni ke dalam konteks wadah".  Berkat ini, dimungkinkan untuk bekerja dengan berbagai jenis data dengan cara yang aman: misalnya, berhasil memproses rantai nilai tersarang opsional;  Konversi daftar data  menangani pengecualian dan banyak lagi. <br><br>  Seperti dijelaskan sebelumnya, menggunakan functors, Anda dapat menerapkan fungsi ke nilai dengan aman dan tidak berubah.  Monads mirip dengan functors, kecuali bahwa mereka dapat mendelegasikan logika khusus dalam kasus khusus.  Functor sendiri hanya tahu cara menerapkan fungsi ini dan membungkus hasilnya kembali dalam sebuah shell, dan ia tidak memiliki logika tambahan. <br><br>  Monad muncul saat membuat seluruh tipe data dengan prinsip mengekstraksi data dengan prinsip mengekstraksi nilai dari shell dan menentukan aturan dari nesting.  Seperti halnya functors, monad adalah template desain yang digunakan untuk menggambarkan perhitungan dalam bentuk urutan tahapan di mana nilai yang diproses tidak diketahui sama sekali, tetapi monad yang memungkinkan untuk secara aman dan tanpa efek samping mengontrol aliran data saat digunakan dalam komposisi.  Monads dapat ditujukan untuk memecahkan berbagai masalah.  Secara teoritis, monad bergantung pada sistem tipe dalam bahasa tertentu.  Bahkan, banyak orang berpikir bahwa mereka hanya dapat dipahami jika ada tipe data eksplisit. <br><br>  Untuk lebih memahami monad, konsep penting berikut harus dipelajari. <br><blockquote>  Monad  Menyediakan antarmuka abstrak untuk operasi monadik <br>  Jenis monadik.  Implementasi spesifik dari antarmuka ini </blockquote><br>  Tetapi contoh-contoh praktis dari penerapan sifat-sifat ini dari functor dan konstruksi kategoris lainnya akan saya tunjukkan dalam artikel mendatang. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471170/">https://habr.com/ru/post/id471170/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471154/index.html">Kembali ke sekolah: cara melatih penguji genggam untuk menghadapi tes otomatis</a></li>
<li><a href="../id471158/index.html">ID @ Xbox di Rusia: memperluas cakrawala permainan</a></li>
<li><a href="../id471160/index.html">Masalah menginstal Ruby on Rails pada akhir 2019</a></li>
<li><a href="../id471162/index.html">Mengumumkan Dukungan untuk Pengeditan Asli Notebook Jupyter dalam Kode VS</a></li>
<li><a href="../id471166/index.html">Python dalam Visual Studio Code - Rilis Oktober 2019</a></li>
<li><a href="../id471174/index.html">Memulai dengan Git dan GitHub lebih mudah dari sebelumnya dengan GitHub Desktop 2.2</a></li>
<li><a href="../id471176/index.html">Pengeditan asli Notebook Jupyter dalam VS Code</a></li>
<li><a href="../id471178/index.html">Panduan Mulai Cepat DPI: Skenario Penggunaan</a></li>
<li><a href="../id471182/index.html">GitHub Desktop 2.2: Apa yang Baru</a></li>
<li><a href="../id471184/index.html">Campuran pada pemrograman dan tentang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>