<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòî üë®üèΩ‚Äçüåæ üë∂üèø Construire une architecture de microservices sur Golang et gRPC, partie 2 (docker) üê± üò• üèà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il est temps de s'attaquer aux conteneurs 
 Tout d'abord, nous utilisons la derni√®re image Linux Alpine. Linux Alpine est une distribution Linux l√©g√®r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construire une architecture de microservices sur Golang et gRPC, partie 2 (docker)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455812/"><h3>  Il est temps de s'attaquer aux conteneurs </h3><br>  Tout d'abord, nous utilisons la derni√®re image Linux Alpine.  Linux Alpine est une distribution Linux l√©g√®re con√ßue et optimis√©e pour ex√©cuter des applications Web dans Docker.  En d'autres termes, Linux Alpine poss√®de suffisamment de d√©pendances et de fonctionnalit√©s pour ex√©cuter la plupart des applications.  Cela signifie que la taille de l'image est d'environ 8 Mo! <br><br>  Par rapport √†, disons ... une machine virtuelle Ubuntu d'une capacit√© d'environ 1 Go, c'est pourquoi les images Docker sont devenues plus naturelles pour les microservices et le cloud computing. <br><br>  Donc, maintenant j'esp√®re que vous voyez de la valeur dans la conteneurisation, et nous pouvons commencer √† ¬´Dockeriser¬ª notre premier service.  Cr√©ons un Dockerfile <b>$ touch</b> consignment <b>-service / Dockerfile</b> . <br><br><img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Premi√®re partie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©p√¥t d'origine EwanValentine</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article original</a> <br><br>  Dans le Dockerfile, ajoutez les √©l√©ments suivants: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Ensuite, nous cr√©ons un nouveau r√©pertoire pour h√©berger notre application.  Ensuite, nous ajoutons notre binaire compil√© √† notre conteneur Docker et l'ex√©cutons. <br><br>  Maintenant, mettons √† jour l'enregistrement de construction de notre Makefile pour cr√©er une image Docker. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  Nous avons ajout√© deux autres √©tapes et je voudrais les expliquer plus en d√©tail.  Tout d'abord, nous cr√©ons notre binaire Go.  Cependant, vous remarquerez deux variables d'environnement avant d'ex√©cuter $ go build.  GOOS et GOARCH vous permettent de compiler de fa√ßon crois√©e votre binaire pour un autre syst√®me d'exploitation.  √âtant donn√© que je d√©veloppe pour un Macbook, je ne peux pas compiler l'ex√©cutable go, puis l'ex√©cuter dans un conteneur Docker qui utilise Linux.  Le binaire n'aura aucun sens dans votre conteneur Docker et g√©n√©rera une erreur. <br><br>  La deuxi√®me √©tape que j'ai ajout√©e est le processus de construction du docker.  Docker lira votre Dockerfile et cr√©era une image nomm√©e consignment-service, le point indique le chemin du r√©pertoire, donc ici, nous voulons juste que le processus de construction regarde le r√©pertoire actuel. <br><br>  Je vais ajouter une nouvelle entr√©e √† notre Makefile: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Ici, nous lan√ßons notre image Docker en ouvrant le port 50051. Puisque Docker fonctionne sur une couche r√©seau distincte, vous devez rediriger le port.  Par exemple, si vous souhaitez d√©marrer ce service sur le port 8080, vous devez remplacer l'argument -p par 8080: 50051.  Vous pouvez √©galement ex√©cuter le conteneur en arri√®re-plan en incluant l'indicateur -d.  Par exemple, <b>docker run -d -p 50051: 50051 consign-service</b> . <br><br>  Ex√©cutez <b>$ make run</b> , puis √† nouveau dans un panneau de terminal s√©par√© <b>$ go run main.go</b> et v√©rifiez qu'il fonctionne toujours. <br><br>  Lorsque vous ex√©cutez la g√©n√©ration $ docker, vous int√©grez votre code et votre runtime dans l'image.  Les images Docker sont des images portables de votre environnement et de ses d√©pendances.  Vous pouvez partager des images Docker en les publiant sur le Docker Hub.  Qui est similaire √† npm ou au r√©f√©rentiel yum pour les images docker.  Lorsque vous d√©finissez FROM dans votre Dockerfile, vous dites √† Docker de retirer cette image du r√©f√©rentiel Docker pour l'utiliser comme base.  Vous pouvez ensuite d√©velopper et red√©finir des parties de ce fichier de base, en les red√©finissant √† votre guise.  Nous ne publierons pas nos images de docker, mais n'h√©sitez pas √† parcourir le r√©f√©rentiel de docker et √† noter que presque tous les logiciels ont d√©j√† √©t√© emball√©s dans des conteneurs.  Certaines choses vraiment merveilleuses ont √©t√© dock√©es. <br><br>  Chaque annonce dans Dockerfile est mise en cache la premi√®re fois qu'elle est cr√©√©e.  Cela √©limine le besoin de reconstruire l'int√©gralit√© de l'ex√©cution √† chaque fois que vous apportez des modifications.  Le docker est suffisamment intelligent pour d√©terminer quels d√©tails ont chang√© et lesquels doivent √™tre reconstruits.  Cela rend le processus de construction incroyablement rapide. <br><br>  Assez parl√© des conteneurs!  Revenons √† notre code. <br><br>  Lors de la cr√©ation du service gRPC, il y a beaucoup de code standard pour cr√©er des connexions, et vous devez coder en dur l'emplacement de l'adresse de service dans le client ou un autre service afin qu'il puisse s'y connecter.  Cela est difficile car lorsque vous d√©marrez des services dans le cloud, ils peuvent ne pas utiliser le m√™me h√¥te, ou l'adresse ou l'adresse IP peuvent changer apr√®s le red√©ploiement du service. <br><br>  C'est l√† que le service de d√©couverte entre en jeu.  Le service de d√©couverte met √† jour l'annuaire de tous vos services et leurs emplacements.  Chaque service est enregistr√© √† l'ex√©cution et se d√©senregistre √† la fermeture.  Chaque service se voit alors attribuer un nom ou un identifiant.  Ainsi, m√™me s'il peut avoir une nouvelle adresse IP ou une adresse d'h√¥te, √† condition que le nom du service reste le m√™me, vous n'avez pas besoin de mettre √† jour les appels √† ce service √† partir d'autres services. <br><br>  En r√®gle g√©n√©rale, il existe de nombreuses approches √† ce probl√®me, mais, comme la plupart des choses en programmation, si quelqu'un a d√©j√† trait√© ce probl√®me, cela n'a aucun sens de r√©inventer la roue.  @Chuhnk (Asim Aslam), le cr√©ateur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Go-micro</a> , r√©sout ces probl√®mes avec une clart√© et une facilit√© d'utilisation fantastiques.  Il produit √† lui seul des logiciels fantastiques.  Pensez √† l'aider si vous aimez ce que vous voyez! <br><br><h3>  Allez micro </h3><br>  Go-micro est un puissant framework de microservices √©crit en Go, √† utiliser, pour la plupart, avec Go.  Cependant, vous pouvez utiliser Sidecar pour interagir avec d'autres langues. <br><br>  Go-micro poss√®de des fonctionnalit√©s utiles pour cr√©er des microservices dans Go.  Mais nous allons commencer par peut-√™tre le probl√®me le plus courant qu'il r√©sout, et c'est la d√©couverte d'un service. <br><br>  Nous devrons effectuer plusieurs mises √† jour de notre service afin de travailler avec go-micro.  Go-micro s'int√®gre en tant que plugin Protocoles, dans ce cas rempla√ßant le plugin gRPC standard que nous utilisons actuellement.  Commen√ßons donc par le remplacer dans notre Makefile. <br><br>  Assurez-vous d'installer les d√©pendances go-micro: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Mettez √† jour notre Makefile pour utiliser le plugin go-micro au lieu du plugin gRPC: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Maintenant, nous devons mettre √† jour notre shippy-service-consignment / main.go pour utiliser go-micro.  Ceci r√©sume la plupart de notre code gRPC pr√©c√©dent.  Il traite facilement l'enregistrement et acc√©l√®re la r√©daction d'un service. <br><br><div class="spoiler">  <b class="spoiler_title">shippy-service-consignment / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Le principal changement ici est la fa√ßon dont nous cr√©ons notre serveur gRPC, qui a √©t√© soigneusement abstrait de mico.NewService (), qui g√®re l'enregistrement de notre service.  Et enfin, la fonction service.Run (), qui traite la connexion elle-m√™me.  Comme pr√©c√©demment, nous enregistrons notre impl√©mentation, mais cette fois avec une m√©thode l√©g√®rement diff√©rente. <br><br>  Le deuxi√®me changement le plus important concerne les m√©thodes de service elles-m√™mes: les arguments et les types de r√©ponses sont l√©g√®rement modifi√©s pour accepter √† la fois la demande et les structures de r√©ponse comme arguments, et ne renvoient d√©sormais qu'une erreur.  Dans nos m√©thodes, nous d√©finissons la r√©ponse que les processus go-micro. <br><br>  Enfin, nous ne programmons plus le port.  Go-micro doit √™tre configur√© √† l'aide de variables d'environnement ou d'arguments de ligne de commande.  Pour d√©finir l'adresse, utilisez MICRO_SERVER_ADDRESS =: 50051.  Par d√©faut, Micro utilise mdns (multicast dns) comme courtier de d√©couverte de service pour une utilisation locale.  Habituellement, vous n'utilisez pas mdns pour d√©couvrir des services dans un environnement de production, mais nous voulons √©viter d'avoir √† ex√©cuter localement quelque chose comme Consul ou etcd pour les tests.  Plus d'informations √† ce sujet plus tard. <br><br>  Mettons √† jour notre Makefile pour refl√©ter cela. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e est le drapeau de la variable d'environnement, il vous permet de passer des variables d'environnement √† votre conteneur Docker.  Vous devez avoir un indicateur pour chaque variable, par exemple -e ENV = staging -e DB_HOST = localhost, etc. <br><br>  Maintenant, si vous ex√©cutez $ make run, vous aurez un service Dockerised avec d√©couverte de service.  Donc, mettons √† jour notre outil Cli pour l'utiliser. <br><br><div class="spoiler">  <b class="spoiler_title">consignation-cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Ici, nous avons import√© les biblioth√®ques go-micro pour cr√©er des clients et remplac√© le code de connexion existant par le code client go-micro, qui utilise l'autorisation du service au lieu de se connecter directement √† l'adresse. <br><br>  Cependant, si vous l'ex√©cutez, cela ne fonctionnera pas.  C'est parce que nous lan√ßons maintenant notre service dans le conteneur Docker, qui a ses propres mdns, distinct de l'h√¥te mdns que nous utilisons actuellement.  Le moyen le plus simple de r√©soudre ce probl√®me est de vous assurer que le service et le client s'ex√©cutent dans le Dockland, afin qu'ils fonctionnent tous les deux sur le m√™me h√¥te et utilisent la m√™me couche r√©seau.  Cr√©ons donc make consignment-cli / Makefile et cr√©ons des entr√©es. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  Comme pr√©c√©demment, nous voulons construire notre binaire pour Linux.  Lorsque nous lan√ßons notre image docker, nous voulons passer une variable d'environnement pour donner la commande go-micro pour utiliser mdns. <br><br>  Cr√©ons maintenant un Dockerfile pour notre outil CLI: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  Ceci est tr√®s similaire √† notre service Dockerfile, sauf qu'il extrait √©galement notre fichier de donn√©es json. <br><br>  Maintenant, lorsque vous ex√©cutez $ make run dans votre envoi shippy-cli, vous devriez voir Cr√©√©: vrai, comme auparavant. <br><br>  Maintenant, il semble temps de jeter un ≈ìil √† la nouvelle fonctionnalit√© Docker: les builds multi-√©tapes.  Cela nous permet d'utiliser plusieurs images Docker dans un seul Dockerfile. <br><br>  Ceci est particuli√®rement utile dans notre cas, car nous pouvons utiliser une image pour cr√©er notre fichier binaire avec toutes les d√©pendances correctes.  Et puis utilisez la deuxi√®me image pour la lancer.  Essayons cela, je vais laisser des commentaires d√©taill√©s avec le code: <br><div class="spoiler">  <b class="spoiler_title">consignation-service / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Je vais maintenant passer √† d'autres fichiers Docker et adopter cette nouvelle approche.  Oh, et n'oubliez pas de supprimer $ go build de vos Makefiles! <br><br><h3>  Service de bateau </h3><br>  Cr√©ons un deuxi√®me service.  Nous avons un service (shippy-service-consignment), qui s'occupe de la coordination du lot de conteneurs avec le navire, qui est le mieux adapt√© pour ce lot.  Pour correspondre √† notre lot, nous devons envoyer le poids et le nombre de conteneurs √† notre nouveau service d'exp√©dition, qui trouvera alors un navire capable de g√©rer ce lot. <br><br>  Cr√©ez un nouveau r√©pertoire dans votre r√©pertoire racine <b>$ mkdir navire-service</b> , cr√©ez maintenant un sous-r√©pertoire pour notre nouvelle d√©finition de services protobuf, <b>$ mkdir -p shippy-service-navire / proto / navire</b> .  Cr√©ons maintenant un nouveau fichier protobuf, <b>$ touch shippy-service-vessel / proto / vessel / vessel.proto</b> . <br><br>  √âtant donn√© que la d√©finition de protobuf est en effet au c≈ìur de notre conception logicielle, commen√ßons par elle. <br><br><div class="spoiler">  <b class="spoiler_title">navire / navire.proto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  Comme vous pouvez le voir, cela ressemble beaucoup √† notre premier service.  Nous cr√©ons un service avec une m√©thode rpc appel√©e FindAvailable.  Cela prend un type de sp√©cification et renvoie un type de r√©ponse.  Le type de r√©ponse renvoie le type de navire ou plusieurs navires √† l'aide d'un champ r√©p√©titif. <br><br>  Nous devons maintenant cr√©er un Makefile pour g√©rer notre logique de construction et notre script de d√©marrage.  <b>$ touch shippy-service-navire / Makefile</b> .  Ouvrez ce fichier et ajoutez ce qui suit: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  Ceci est presque identique au premier Makefile que nous avons cr√©√© pour notre service de consignation, mais notez que les noms des services et des ports ont un peu chang√©.  Nous ne pouvons pas lancer deux conteneurs Dock sur le m√™me port, nous utilisons donc la redirection de port Dockers pour que ce service redirige de 50051 vers 50052 sur le r√©seau h√¥te. <br><br>  Nous avons maintenant besoin d'un Dockerfile utilisant notre nouveau format multi-√©tapes: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Enfin, nous pouvons √©crire notre impl√©mentation: <br><br><div class="spoiler">  <b class="spoiler_title">navire-service / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Passons maintenant √† la partie int√©ressante.  Lorsque nous cr√©ons un envoi, nous devons changer notre service de manutention de fret pour contacter le service de recherche de navires, trouver le navire et mettre √† jour le param√®tre ship_id dans l'envoi cr√©√©: <br><br><div class="spoiler">  <b class="spoiler_title">shippy / consign-service / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Ici, nous avons cr√©√© une instance client pour notre service d'exp√©dition, qui nous permet d'utiliser le nom du service, c'est-√†-dire  shipy.service.vessel pour appeler le service du navire en tant que client et interagir avec ses m√©thodes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, une seule m√©thode (FindAvailable). Nous exp√©dions le poids du lot avec le nombre de conteneurs que nous voulons exp√©dier, comme sp√©cification pour le service du navire. Ce qui nous renvoie le navire correspondant √† cette sp√©cification. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettez √† jour le fichier consignment-cli / consignment.json, supprimez le ship_id cod√© en dur, car nous voulons confirmer que notre service de recherche de navires fonctionne. Ajoutons √©galement quelques conteneurs suppl√©mentaires et augmentons le poids.</font></font> Par exemple: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lancez </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ make build &amp;&amp; make run</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans consignment-cli. </font><font style="vertical-align: inherit;">Vous devriez voir une r√©ponse avec une liste des biens cr√©√©s. </font><font style="vertical-align: inherit;">Dans vos parties, vous devriez voir que le param√®tre navire_id est d√©fini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc deux microservices interconnect√©s et une interface de ligne de commande! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la prochaine partie de cette s√©rie, nous envisagerons d'enregistrer certaines de ces donn√©es √† l'aide de MongoDB. </font><font style="vertical-align: inherit;">Nous ajouterons √©galement un troisi√®me service et utiliserons docker-compose pour g√©rer localement notre √©cosyst√®me de conteneurs en pleine croissance. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie I </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rentiel d'origine EwanValentine</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455812/">https://habr.com/ru/post/fr455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455796/index.html">Programmation orient√©e objet en Java et Python: similitudes et diff√©rences</a></li>
<li><a href="../fr455800/index.html">Matrix 1.0 - Version du protocole de messagerie d√©centralis√©e</a></li>
<li><a href="../fr455802/index.html">Comment assembler l'Olympic par le biais de newsletters par e-mail. Case Black Star</a></li>
<li><a href="../fr455806/index.html">Naissance et mort d'un album: nous comprenons comment les formats musicaux ont chang√© au cours des 100 derni√®res ann√©es</a></li>
<li><a href="../fr455808/index.html">Obtenez des extraits du registre sur le site Web de FTS en utilisant python</a></li>
<li><a href="../fr455816/index.html">Comment cr√©er une action sympa pour Google Assistant. Lifehacks de Just AI</a></li>
<li><a href="../fr455820/index.html">Analyse des performances des machines virtuelles dans VMware vSphere. Partie 2: M√©moire</a></li>
<li><a href="../fr455826/index.html">Arrosage automatique t√©l√©command√©</a></li>
<li><a href="../fr455828/index.html">Les scientifiques ont d√©couvert de nouvelles formes de synchronisation exotiques</a></li>
<li><a href="../fr455830/index.html">Un regard sur Passer par les yeux d'un d√©veloppeur .NET. Semaine # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>