<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè≠ üëï üïó Die ganze Wahrheit √ºber RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE üßëüèª üíÜ ü§òüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bisher haben wir uns in dieser Artikelserie mit den Funktionen von Nucleus SE befasst. Jetzt ist es Zeit zu sehen, wie es in einer echten Firmware-Anw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467763/">  Bisher haben wir uns in dieser Artikelserie mit den Funktionen von Nucleus SE befasst.  Jetzt ist es Zeit zu sehen, wie es in einer echten Firmware-Anwendung verwendet werden kann. <br><br><img src="https://habrastorage.org/webt/8y/ch/3t/8ych3tyabi2vdvohugo65t3uekk.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Fr√ºhere Artikel in der Reihe:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 32.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE-Migration: Nicht realisierte Funktionen und Kompatibilit√§t</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 31.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagnose und Fehlerpr√ºfung RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 30.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungs- und Startverfahren f√ºr Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterbrechungen in Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Timer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kan√§le: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkan√§le: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postf√§cher: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <br></div></div><br><h2>  Was ist Nucleus SE? </h2><br>  Wir wissen, dass Nucleus SE der Kern eines Echtzeitbetriebssystems ist, aber Sie m√ºssen verstehen, wie es in den Rest der Anwendung passt.  Und es passt einfach, weil die Anwendung im Gegensatz zu einem Desktop-Betriebssystem (z. B. Windows) nicht auf Nucleus SE gestartet wird.  Der Kernel ist einfach Teil eines Programms, das auf einem eingebetteten Ger√§t ausgef√ºhrt wird.  Dies ist der h√§ufigste Anwendungsfall f√ºr RTOS. <br><br>  Aus einer √ºbergeordneten Sicht ist eine eingebettete Anwendung eine Art Code, der beim Starten der CPU gestartet wird.  In diesem Fall wird die Hardware- und Softwareumgebung initialisiert und anschlie√üend die Funktion <b>main ()</b> aufgerufen, mit der der Hauptanwendungscode gestartet wird. <br><br>  Bei Verwendung von Nucleus SE (und vielen anderen √§hnlichen Kerneln) besteht der Unterschied darin, dass die Funktion <b>main ()</b> Teil des Kernel-Codes ist.  Diese Funktion initialisiert einfach die Datenstrukturen des Kernels und ruft dann den Scheduler auf, was zum Start des Anwendungscodes (Tasks) f√ºhrt.  Der Benutzer kann der <b>main () -</b> Funktion einen beliebigen nativen Initialisierungscode hinzuf√ºgen. <br><br>  Nucleus SE enth√§lt auch eine Reihe von Funktionen - eine Anwendungsprogrammierschnittstelle (API), die eine Reihe von Funktionen wie Kommunikation und Task-Synchronisation, Arbeiten mit Timern, Speicherzuweisung usw. bereitstellt.  Alle API-Funktionen wurden bereits in den Artikeln dieser Reihe beschrieben. <br><br>  Die gesamte Nucleus SE-Software wird als Quellcode bereitgestellt (haupts√§chlich in C).  Um den Code gem√§√ü den Anforderungen einer bestimmten Anwendung zu konfigurieren, wird eine bedingte Kompilierung verwendet.  Dies wird in diesem Artikel im Abschnitt Konfiguration ausf√ºhrlich beschrieben. <br><br>  Nachdem der Code kompiliert wurde, werden die resultierenden Nucleus SE-Objektmodule den Anwendungscodemodulen zugeordnet, was zu einem einzelnen Bin√§rbild f√ºhrt, das normalerweise im Flash-Speicher des eingebetteten Ger√§ts abgelegt wird.  Das Ergebnis dieser statischen Bindung ist, dass alle symbolischen Informationen sowohl aus dem Anwendungscode als auch aus dem Kernelcode verf√ºgbar bleiben.  Dies ist n√ºtzlich f√ºr das Debuggen. Es ist jedoch Vorsicht geboten, um einen Missbrauch der Nucleus SE-Daten zu vermeiden. <br><br><h2>  CPU- und Tool-Unterst√ºtzung </h2><br>  Da Nucleus SE als Quellcode geliefert wird, muss es portabel sein.  Code, der auf einer so niedrigen Ebene ausgef√ºhrt wird (bei Verwendung von Schedulern, bei denen eine Kontextumschaltung erforderlich ist, dh alles andere als Run to Completion), kann jedoch nicht vollst√§ndig unabh√§ngig von der Assemblersprache sein.  Ich habe diese Abh√§ngigkeit minimiert und f√ºr die Portierung auf eine neue CPU ist eine Low-Level-Programmierung fast nicht erforderlich.  Die Verwendung neuer Entwicklungstools (Compiler, Assembler, Linker usw.) kann ebenfalls zu Portierungsproblemen f√ºhren. <br><br><h2>  Einrichten der Nucleus SE-App </h2><br>  Der Schl√ºssel zur effizienten Nutzung von Nucleus SE ist die richtige Einrichtung.  Es mag kompliziert aussehen, aber tats√§chlich ist alles ziemlich logisch und erfordert nur einen systematischen Ansatz.  Fast die gesamte Konfiguration erfolgt durch Bearbeiten von zwei Dateien: <b>nuse_config.h</b> und <b>nuse_config.c</b> . <br><br><h3>  Einstellung Nuse_config.h </h3><br>  Diese Datei ist nur ein Zeichensatz der Direktive <b>#define</b> , dem die entsprechenden Werte zugewiesen wurden, um die erforderliche Kernelkonfiguration zu erhalten.  In der Datei <b>nuse_config.h sind</b> standardm√§√üig alle Zeichen vorhanden, ihnen werden jedoch die Mindesteinstellungen zugewiesen. <br><br>  <b><i>Objektz√§hler</i></b> <br>  Die Anzahl der <b>Kernelobjekte</b> jedes Typs wird durch Symbolwerte der Form <b>NUSE_SEMAPHORE_NUMBER festgelegt</b> .  F√ºr die meisten Objekte kann dieser Wert zwischen 0 und 15 variieren. Aufgaben sind eine Ausnahme, es muss mindestens eine vorhanden sein.  Signale sind in der Tat keine unabh√§ngigen Objekte, da sie Aufgaben zugeordnet sind und durch <b>Setzen von NUSE_SIGNAL_SUPPOR</b> T auf <b>TRUE</b> <b>aktiviert werden</b> . <br><br>  <b><i>API-Funktionsaktivatoren</i></b> <br>  Jede Nucleus SE-API-Funktion kann separat aktiviert werden, indem <b>TRUE</b> ein Symbol <b>zugewiesen wird,</b> dessen Name mit dem Funktionsnamen (z. B. <b>NUSE_PIPE_JAM</b> ) <b>√ºbereinstimmt</b> .  Dies f√ºhrt zur Aufnahme des Funktionscodes in die Anwendung. <br><br>  <b><i>Scheduler Auswahl und Einstellungen</i></b> <br>  Nucleus SE unterst√ºtzt vier Arten von Schedulern, wie in einem vorherigen Artikel beschrieben.  Der verwendete Scheduler wird festgelegt, indem <b>NUSE_SCHEDULER_TYPE</b> einem der folgenden Werte <b>zugewiesen</b> wird: <b>NUSE_RUN_TO_COMPLETION_SCHEDULER</b> , <b>NUSE_TIME_SLICE_SCHEDULER</b> , <b>NUSE_ROUND_ROBIN_SCHEDULER</b> oder <b>NUSE_PRIORITY_SCHEDULER</b> . <br><br>  Sie k√∂nnen andere Scheduler-Parameter konfigurieren: <br>  <b>NUSE_TIME_SLICE_TICKS</b> gibt die Anzahl der Ticks pro Slot f√ºr den Time Slice Scheduler an.  Wenn ein anderer Scheduler verwendet wird, sollte dieser Parameter auf 0 gesetzt werden. <br>  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> kann auf <b>TRUE</b> oder <b>FALSE gesetzt werden</b> , um den Scheduler- <b>Z√§hlermechanismus</b> zu aktivieren / deaktivieren. <br>  <b>NUSE_SUSPEND_ENABLE aktiviert</b> das Sperren ( <b>Anhalten) von</b> Aufgaben f√ºr viele API-Funktionen.  Dies bedeutet, dass ein Aufruf einer solchen Funktion zu einer Unterbrechung der aufrufenden Aufgabe f√ºhren kann, bis die Ressource freigegeben wird.  Um diese Option auszuw√§hlen, <b>muss NUSE_SUSPEND_ENABLE</b> ebenfalls auf <b>TRUE gesetzt sein</b> . <br><br>  <b><i>Andere Optionen</i></b> <br>  Es k√∂nnen auch mehreren anderen Parametern <b>TRUE-</b> oder <b>FALSE-</b> Werte zugewiesen werden, um andere Kernelfunktionen zu aktivieren / deaktivieren: <br>  <b>NUSE_API_PARAMETER_CHECKING</b> f√ºgt einen √úberpr√ºfungscode f√ºr API-Funktionsaufrufparameter hinzu.  Wird h√§ufig zum Debuggen verwendet. <br>  <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> legt den Anfangszustand aller Aufgaben als <b>NUSE_READY</b> oder <b>NUSE_PURE_SUSPEND fest</b> .  Wenn dieser Parameter deaktiviert ist, haben alle Tasks den Ausgangszustand <b>NUSE_READY</b> . <br>  <b>NUSE_SYSTEM_TIME_SUPPORT</b> - Unterst√ºtzung f√ºr die Systemzeit. <br>  <b>NUSE_INCLUDE_EVERYTHING</b> - Ein Parameter, der der Konfiguration von Nucleus SE die maximale Anzahl von Funktionen hinzuf√ºgt.  Dies f√ºhrt zur Aktivierung aller optionalen Funktionen und jeder API-Funktion der konfigurierten Objekte.  Wird verwendet, um schnell eine Nucleus SE-Konfiguration zu erstellen und eine neue Portierung des Kernel-Codes zu √ºberpr√ºfen. <br><br><h3>  Festlegen von nuse_config.c </h3><br>  Nach Angabe der <b>Kernelkonfiguration</b> in <b>nuse_config.h m√ºssen</b> die verschiedenen im ROM gespeicherten Datenstrukturen initialisiert werden.  Dies erfolgt in der Datei <b>nuse_config.c</b> .  Die Definition von Datenstrukturen wird durch bedingte Kompilierung gesteuert, sodass alle Strukturen in einer Kopie der Standarddatei <b>nuse_config.c</b> enthalten sind. <br><br>  <b><i>Aufgabendaten</i></b> <br>  Das Array <b>NUSE_Task_Start_Address []</b> muss mit dem Wert der Startadressen jeder Aufgabe initialisiert werden.  Dies ist normalerweise nur eine Liste von Funktionsnamen ohne Klammern.  Prototypen von Aufgabeneingabefunktionen sollten ebenfalls sichtbar sein.  In der Standarddatei ist die Aufgabe mit dem Namen <b>NUSE_Idle_Task ()</b> konfiguriert. Dies kann in die Anwendungsaufgabe ge√§ndert werden. <br><br>  Wenn Sie einen Scheduler au√üer Run to Completion verwenden, ben√∂tigt jede Aufgabe einen eigenen Stapel.  F√ºr jeden Taskstack m√ºssen Sie ein Array im RAM erstellen.  Diese Arrays m√ºssen vom Typ <b>ADDR sein</b> und die Adresse jedes Arrays muss in <b>NUSE_Task_Stack_Base []</b> gespeichert sein.  Es ist schwierig, die Gr√∂√üe des Arrays vorherzusagen, daher ist es besser, Messungen zu verwenden (siehe Abschnitt "Debuggen" weiter unten in diesem Artikel).  Die Gr√∂√üe jedes Arrays ( <b>dh</b> die Anzahl der W√∂rter auf dem Stapel) sollte in <b>NUSE_Task_Stack_Size []</b> gespeichert werden. <br><br>  Wenn eine Funktion aktiviert wurde, um den Anfangsstatus der Aufgabe <b>anzuzeigen</b> (mithilfe des Parameters <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> ), muss das Array <b>NUSE_Task_Initial_State []</b> mit dem <b>Status NUSE_READY oder NUSE_PURE_SUSPEND</b> initialisiert werden. <br><br>  <b><i>Partitionspooldaten</i></b> <br>  Wenn mindestens ein Partitionspool konfiguriert ist, muss f√ºr jeden im ROM ein Array (vom Typ <b>U8</b> ) erstellt werden.  Die Gr√∂√üe dieser Arrays wird wie folgt berechnet: (Anzahl der Partitionen * (Partitionsgr√∂√üe + 1)).  Die Adressen dieser Abschnitte ( <b>dh</b> ihre Namen) m√ºssen den entsprechenden <b>NUSE_Partition_Pool_Data_Address []</b> -Elementen zugewiesen werden.  F√ºr jeden Pool sollten die Anzahl der Partitionen und ihre Gr√∂√üe in <b>NUSE_Partition_Pool_Partition_Number []</b> bzw. <b>NUSE_Partition_Message_Size []</b> platziert werden. <br><br>  <b><i>Warteschlangendaten</i></b> <br>  Wenn mindestens eine Warteschlange konfiguriert ist, muss f√ºr jedes Array im RAM ein Array (vom Typ <b>ADDR</b> ) erstellt werden.  Die Gr√∂√üe dieser Arrays entspricht der Anzahl der Elemente in jeder Warteschlange.  Die Adressen dieser Arrays ( <b>dh</b> ihre Namen) m√ºssen den entsprechenden <b>NUSE_Queue_Data []</b> -Elementen zugewiesen werden.  Die Gr√∂√üe jeder Warteschlange muss dem entsprechenden Element <b>NUSE_Queue_Size []</b> zugewiesen werden. <br><br>  <b><i>Datenverbindungsdaten</i></b> <br>  Wenn mindestens ein Datenkanal konfiguriert ist, muss daf√ºr (oder f√ºr jeden von ihnen) ein Array (vom Typ <b>U8</b> ) im RAM erstellt werden.  Die Gr√∂√üe dieser Arrays wird wie folgt berechnet: (Kanalgr√∂√üe * Nachrichtengr√∂√üe im Kanal).  Die Adressen dieser Arrays ( <b>dh</b> ihre Namen) m√ºssen den entsprechenden <b>NUSE_Pipe_Data []</b> -Elementen zugewiesen werden.  F√ºr jeden Kanal m√ºssen seine Nachrichtengr√∂√üe und -gr√∂√üe den entsprechenden Elementen <b>NUSE_Pipe_Size []</b> bzw. <b>NUSE_Pipe_Message_Size []</b> zugewiesen werden. <br><br>  <b><i>Semaphordaten</i></b> <br>  Wenn mindestens ein Semaphor konfiguriert ist, muss das Array <b>NUSE_Semaphore_Initial_Value []</b> mit den Anfangswerten des Countdowns initialisiert werden. <br><br>  <b><i>Anwendungs-Timer-Daten</i></b> <br>  Wenn mindestens ein Timer konfiguriert ist, muss das Array <b>NUSE_Timer_Initial_Time []</b> mit den Anfangswerten der Z√§hler initialisiert werden.  Au√üerdem m√ºssen <b>NUSE_Timer_Reschedule_Time []</b> Neustartwerte zugewiesen werden.  Diese Timerwerte werden nach dem Ende des ersten Timerzyklus verwendet.  Wenn die Neustartwerte auf 0 gesetzt sind, stoppt der Z√§hler nach einem Zyklus. <br><br>  Wenn die Unterst√ºtzung f√ºr Kontenabschlussmechanismen konfiguriert ist (indem der Parameter <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> auf <b>TRUE gesetzt wird</b> ), m√ºssen zwei weitere Arrays erstellt werden.  Adressen von Vervollst√§ndigungsmechanismen (nur eine Liste von Funktionsnamen ohne Klammern) m√ºssen in <b>NUSE_Timer_Expiration_Routine_Address [] platziert werden</b> .  Das Array <b>NUSE_Timer_Expiration_Routine_Parameter []</b> muss mit den Werten der Abschlussparameter initialisiert werden. <br><br><h2>  Welche API? </h2><br>  Alle Betriebssysteme in der einen oder anderen Form verf√ºgen √ºber eine API (Application Programming Interface).  Nucleus SE ist keine Ausnahme, und die Funktionen, aus denen sich die API zusammensetzt, wurden in dieser Artikelserie ausf√ºhrlich beschrieben. <br><br>  Es mag offensichtlich erscheinen, dass Sie beim Schreiben einer Anwendung mit Nucleus SE die API verwenden m√ºssen, wie in den vorherigen Artikeln beschrieben.  Dies ist jedoch nicht immer der Fall. <br><br>  F√ºr die meisten Benutzer ist die Nucleus SE-API etwas Neues, m√∂glicherweise sogar ihre erste Erfahrung mit der Betriebssystem-API.  Und da es ganz einfach ist, kann es als gute Einf√ºhrung in das Thema dienen.  In diesem Fall ist das Verfahren klar. <br><br>  F√ºr einige Benutzer kann eine alternative API eine attraktivere Option sein.  Es gibt drei offensichtliche Situationen, in denen dies m√∂glich ist. <br><ol><li>  Nucleus SE ist nur ein Teil eines Systems, das andere Betriebssysteme f√ºr andere Komponenten verwendet.  Daher sind die Portabilit√§t des Codes und vor allem die Erfahrung mit der Verwendung verschiedener Betriebssysteme sehr verlockend. </li><li>  Der Benutzer verf√ºgt √ºber umfangreiche Erfahrung mit der API eines anderen Betriebssystems.  Diese Erfahrung ist auch sehr ratsam. </li><li>  Der Benutzer m√∂chte Code, der f√ºr die API eines anderen Betriebssystems geschrieben wurde, wiederverwenden.  Das √Ñndern von API-Aufrufen ist m√∂glich, aber zeitaufw√§ndig. </li></ol><br><br>  Da der vollst√§ndige Quellcode von Nucleus SE f√ºr alle verf√ºgbar ist, hindert Sie nichts daran, jede API-Funktion so zu bearbeiten, dass sie wie die eines anderen Betriebssystems aussieht.  Es wird jedoch viel Zeit in Anspruch nehmen und sehr unproduktiv sein.  Ein korrekterer Ansatz w√§re, einen ‚ÄûWrapper‚Äú zu schreiben.  Es gibt verschiedene M√∂glichkeiten, dies zu tun. Am einfachsten ist es jedoch, eine Header-Datei ( <b>#include</b> ) zu erstellen, die eine Reihe von <b>#</b> <b>Define-</b> Makros enth√§lt, mit denen API-Funktionen von Drittanbietern Nucleus SE-API-Funktionen zugeordnet werden. <br><br>  Ein Wrapper, der die Funktionen der Nucleus RTOS-API (teilweise) auf Nucleus SE √ºbertr√§gt, wird mit Nucleus SE verteilt.  Dies kann f√ºr Entwickler n√ºtzlich sein, die Erfahrung mit Nucleus RTOS haben oder in Zukunft auf dieses RTOS umsteigen k√∂nnen.  Dieser Wrapper kann auch als Beispiel f√ºr die Entwicklung √§hnlicher Dinge dienen. <br><br><h2>  Debuggen von Nucleus SE-Anwendungen </h2><br>  Das Schreiben einer eingebetteten Anwendung mit einem Multitasking-Kernel ist eine komplexe Aufgabe.  Es kann eine entmutigende Aufgabe sein, sicherzustellen, dass der Code funktioniert und Fehler zu erkennen.  Trotz der Tatsache, dass dies nur Code ist, der auf einem Prozessor ausgef√ºhrt wird, macht es die gleichzeitige Ausf√ºhrung mehrerer Aufgaben ziemlich schwierig, sich auf einen bestimmten Ausf√ºhrungsthread zu konzentrieren.  Dies ist noch komplizierter, wenn mehrere Aufgaben einen gemeinsamen Code verwenden.  Am schlimmsten ist es, wenn zwei Aufgaben genau den gleichen Code haben (aber mit unterschiedlichen Daten arbeiten).  Erschwerend kommt auch das Aufl√∂sen von Datenstrukturen hinzu, mit denen Kernelobjekte implementiert werden, um aussagekr√§ftige Informationen zu erhalten. <br><br>  Zum Debuggen von Anwendungen, die mit Nucleus SE erstellt wurden, sind keine zus√§tzlichen Bibliotheken oder anderen Dienste erforderlich.  Der gesamte Kernel-Code kann vom Debugger gelesen werden.  Daher stehen alle symbolischen Informationen zum Studium zur Verf√ºgung.  Bei der Arbeit mit Nucleus SE-Anwendungen kann jedes moderne Debugging-Tool verwendet werden. <br><br><h3>  Verwenden eines Debuggers </h3><br>  Debugging-Tools, die speziell f√ºr eingebettete Systeme entwickelt wurden, sind in den 30 Jahren ihres Bestehens sehr leistungsf√§hig geworden.  Das Hauptmerkmal einer eingebetteten Anwendung im Vergleich zu einem Desktop-Programm ist, dass alle eingebetteten Systeme unterschiedlich sind (und alle PCs einander sehr √§hnlich sind).  Ein guter eingebetteter Debugger sollte flexibel sein und √ºber gen√ºgend Einstellungen verf√ºgen, um den verschiedenen eingebetteten Systemen und Benutzeranforderungen zu entsprechen.  Die Anpassbarkeit des Debuggers wird in verschiedenen Formen ausgedr√ºckt, normalerweise besteht jedoch die M√∂glichkeit, Skripte zu erstellen.  Mit dieser Funktion kann der Debugger gut mit einer Anwendung auf Kernelebene zusammenarbeiten.  Im Folgenden werde ich einige F√§lle der Verwendung des Debuggers erl√§utern. <br><br>  Es ist erw√§hnenswert, dass ein Debugger normalerweise eine Familie von Werkzeugen ist, nicht nur ein Programm.  Der Debugger kann √ºber verschiedene Betriebsmodi verf√ºgen, √ºber die er bei der Entwicklung von Code auf einem virtuellen System oder auf realer Hardware hilfreich ist. <br><br><h3>  Aufgabensensitive Haltepunkte </h3><br>  Wenn das Programm einen Code hat, der mehreren Aufgaben gemeinsam ist, ist die Verwendung herk√∂mmlicher Haltepunkte w√§hrend des Debuggens kompliziert.  H√∂chstwahrscheinlich muss der Code nur gestoppt werden, wenn ein Haltepunkt im Kontext einer bestimmten Aufgabe erreicht wird, die Sie gerade debuggen.  Dazu ben√∂tigen Sie einen Haltepunkt, der die Aufgabe ber√ºcksichtigt. <br><br>  Gl√ºcklicherweise machen die M√∂glichkeit, Skripte auf modernen Debuggern zu erstellen, und die Verf√ºgbarkeit von Nucleus SE-Zeichendaten die Implementierung aufgabenspezifischer Haltepunkte zu einer ziemlich einfachen Sache.  Sie m√ºssen lediglich ein einfaches Skript schreiben, das einem Haltepunkt zugeordnet wird, den Sie zur Unterscheidung zwischen Aufgaben einlernen m√∂chten.  Dieses Skript √ºbernimmt den Parameter: index (ID) der Aufgabe, an der Sie interessiert sind.  Das Skript vergleicht diesen Wert einfach mit dem Index der aktuellen Aufgabe ( <i>NUSE_Task_Active</i> ).  Wenn die Werte √ºbereinstimmen, wird das Programm angehalten.  Wenn sie unterschiedlich sind, wird die Ausf√ºhrung fortgesetzt.  Es ist anzumerken, dass die Ausf√ºhrung dieses Skripts die Ausf√ºhrung der Anwendung in Echtzeit beeinflusst ( <i>Anmerkung des √úbersetzers:</i> Dies <i>bedeutet, dass die Ausf√ºhrung des Programms im Vergleich zum normalen Betrieb langsamer wird</i> ).  Befindet sich das Skript jedoch nicht in einer Schleife, die sehr oft ausgef√ºhrt wird, ist dieser Effekt minimal. <br><br><h3>  Kernel-Objektinformationen </h3><br>  Die offensichtliche Notwendigkeit f√ºr das Debuggen der Nucleus SE-Anwendung besteht in der M√∂glichkeit, Informationen √ºber die Kernelobjekte abzurufen: Welche Eigenschaften haben sie und welchen aktuellen Status haben sie?  Auf diese Weise erhalten Sie Antworten auf Fragen wie: "Wie gro√ü ist diese Warteschlange und wie viele Nachrichten befinden sich jetzt darin?" <br><br>  Dies kann verwendet werden, indem Sie Ihrer Anwendung zus√§tzlichen Debugging-Code hinzuf√ºgen, der die "informativen" API-Aufrufe (z. B. <b>NUSE_Queue_Information</b> ) verwendet.  Dies bedeutet nat√ºrlich, dass Ihre Anwendung jetzt zus√§tzlichen Code enth√§lt, der nach der Implementierung der Anwendung nicht mehr erforderlich ist.  Die Verwendung von <b>#define</b> zum <b>Ein-</b> und Ausschalten dieses Codes mithilfe der bedingten Kompilierung w√§re eine logische Entscheidung. <br><br>  Einige Debugger k√∂nnen einen gezielten Funktionsaufruf ausf√ºhren, dh direkt eine API-Funktion aufrufen, um Informationen abzurufen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch ist kein zus√§tzlicher Code erforderlich, diese API-Funktion muss jedoch konfiguriert sein, damit der Debugger sie verwenden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein alternativer, flexiblerer, aber weniger alternder Ansatz ist der direkte Zugriff auf die Datenstrukturen von Kernelobjekten. </font><font style="vertical-align: inherit;">Am wahrscheinlichsten ist es, dies mit Debugger-Skripten zu tun. </font><font style="vertical-align: inherit;">In unserem Beispiel kann die Warteschlangengr√∂√üe von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Size []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die aktuelle Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data [] abgerufen werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Au√üerdem k√∂nnen Nachrichten in der Warteschlange unter Verwendung der Adresse des Warteschlangendatenbereichs (von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">angezeigt werden </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√ºckgabewerte f√ºr API-Aufrufe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele API-Funktionen geben einen Statuswert zur√ºck, der angibt, wie erfolgreich der Aufruf abgeschlossen wurde. Es w√§re n√ºtzlich, diese Werte zu verfolgen und F√§lle zu markieren, in denen sie nicht gleich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_SUCCESS sind</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">dh</font></b><font style="vertical-align: inherit;"> sie haben den Wert Null). Da dieses Tracking nur zum Debuggen dient, ist die bedingte Kompilierung durchaus angemessen. Die Definition einer globalen Variablen (z. B. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) kann bedingt kompiliert werden (unter der Kontrolle des Direktiven-Symbols #define). Dann kann ein Teil der Definition von API-Aufrufen, n√§mlich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auch bedingt kompiliert werden. Zum Debuggen beispielsweise ein Aufruf, der normalerweise folgenderma√üen aussieht: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPSEND);</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird die folgende Form annehmen:</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status = NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPEND); </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Task-Sperre aktiviert ist, k√∂nnen viele API-Funktionsaufrufe nur Informationen √ºber einen erfolgreichen Anrufabschluss oder das Zur√ºcksetzen des Objekts zur√ºckgeben. </font><font style="vertical-align: inherit;">Wenn jedoch die API-Parameterpr√ºfung aktiviert ist, k√∂nnen API-Aufrufe viele andere Werte zur√ºckgeben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Festlegen der Gr√∂√üe des Taskstapels und des Stapel√ºberlaufs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Thema Stapel√ºberlaufschutz wurde in einem fr√ºheren Artikel (Nr. 31) er√∂rtert. Beim Debuggen gibt es mehrere andere M√∂glichkeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Speicherbereich des Stapels kann mit einem charakteristischen Wert gef√ºllt werden: etwas anderes als alle Einsen oder alle Nullen. Danach kann der Debugger verwendet werden, um die Speicherbereiche zu √ºberwachen und wie stark die Werte ge√§ndert werden, wodurch wir den Grad der F√ºlle des Stapels verstehen k√∂nnen. Wenn alle Speicherbereiche ge√§ndert wurden, bedeutet dies nicht, dass der Stapel voll war, aber es kann bedeuten, dass seine Gr√∂√üe kaum ausreicht, was gef√§hrlich ist. Es sollte erh√∂ht und die Tests fortgesetzt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel 31 beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Implementierung der Diagnose k√∂nnen sich zus√§tzliche Bereiche, ‚ÄûSchutzw√∂rter‚Äú, an jeder Kante des Stapelspeicherbereichs befinden. </font><font style="vertical-align: inherit;">Der Debugger kann verwendet werden, um den Zugriff auf diese W√∂rter zu verfolgen, da jeder Versuch, in sie zu schreiben, einen √úberlauf oder eine Ersch√∂pfung des Stapels bedeutet.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Checkliste f√ºr die Nucleus SE-Konfiguration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Nucleus SE als hochflexibles und anpassbares System zur Erf√ºllung der Anwendungsanforderungen konzipiert wurde, sind zahlreiche anpassbare Parameter erforderlich. </font><font style="vertical-align: inherit;">Aus diesem Grund ist dieser gesamte Artikel der Konfiguration von Nucleus SE gewidmet. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass wir nichts verpassen, finden Sie im Folgenden eine Checkliste aller wichtigen Schritte, die Sie zum Erstellen der eingebetteten Nucleus SE-Anwendung ausf√ºhren m√ºssen.</font></font><br><ol><li> <b> Nucleus SE.</b>   ,     Nucleus SE       ,        Nucleus SE     . </li><li> <b>  CPU/.</b>             . </li><li> <b>  .</b>     ,       ,    . </li><li> <b>  .</b>        .       .  ,     .      16 . </li><li> <b> .</b>     -   <b>main()</b> ? </li><li> <b> .</b>     4 ,       . </li><li> <b>   </b> ,     . </li><li> <b>    .</b> </li><li> <b>.</b>   ,     . </li><li> <b> .</b>    ,    . </li><li> <b>  .</b> ,      .     .  ‚Äî  16   . </li><li> <b>  .</b>        ,   . </li><li> <b>  .</b>        ,    (,      ). </li><li> <b> API.</b>    API,   . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der n√§chste Artikel (der letzte in dieser Reihe) fasst die gesamte Geschichte mit Nucleus SE zusammen und enth√§lt Informationen, die Sie beim Erstellen und Verwenden von Nucleus SE-Implementierungen unterst√ºtzen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úber den Autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware. </font><font style="vertical-align: inherit;">Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware. </font><font style="vertical-align: inherit;">Lebt in Gro√übritannien. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colins</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professioneller </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Blog</font></a><font style="vertical-align: inherit;"> , E-Mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467763/">https://habr.com/ru/post/de467763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467751/index.html">Wie funktioniert ein dezentraler Messenger in der Blockchain?</a></li>
<li><a href="../de467753/index.html">Weltrekord f√ºr drahtlose Daten√ºbertragung: 40 Gbit / s pro 11 Kilometer</a></li>
<li><a href="../de467755/index.html">Prionen, Kalzium, Mikrobiota, Nahrungshormone und Alzheimer</a></li>
<li><a href="../de467759/index.html">Unix-√§hnliches Betriebssystemdesign - Virtueller Adressraum (6)</a></li>
<li><a href="../de467761/index.html">Energie, W√§rme und Wasser Teil drei: Gehen Sie zum Radio</a></li>
<li><a href="../de467765/index.html">Wi-Fi und viele andere Abk√ºrzungen. So erhalten Sie Daten auf Wi-Fi-Knoten in einer Android-Anwendung und schwellen nicht an</a></li>
<li><a href="../de467767/index.html">Weitere Annehmlichkeiten f√ºr JSON-RPC-Follower</a></li>
<li><a href="../de467769/index.html">Auf einer einzigen Bundesinformationsquelle, die Bev√∂lkerungsinformationen enth√§lt</a></li>
<li><a href="../de467773/index.html">Beschaffung ungew√∂hnlicher Ressourcen und Erstkontakt</a></li>
<li><a href="../de467775/index.html">5 Mythen √ºber das Gesch√§ft: Warum der Kunde falsch liegt und wie man Apple √ºbertrifft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>