<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏭 👕 🕗 Die ganze Wahrheit über RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE 🧑🏻 💆 🤘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bisher haben wir uns in dieser Artikelserie mit den Funktionen von Nucleus SE befasst. Jetzt ist es Zeit zu sehen, wie es in einer echten Firmware-Anw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel # 33. Verwenden des Echtzeit-Betriebssystems Nucleus SE</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467763/">  Bisher haben wir uns in dieser Artikelserie mit den Funktionen von Nucleus SE befasst.  Jetzt ist es Zeit zu sehen, wie es in einer echten Firmware-Anwendung verwendet werden kann. <br><br><img src="https://habrastorage.org/webt/8y/ch/3t/8ych3tyabi2vdvohugo65t3uekk.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Frühere Artikel in der Reihe:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 32.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE-Migration: Nicht realisierte Funktionen und Kompatibilität</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 31.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diagnose und Fehlerprüfung RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 30.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Initialisierungs- und Startverfahren für Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 29.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterbrechungen in Nucleus SE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 28.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Software-Timer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemzeit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kanäle: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenkanäle: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlangen: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postfächer: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Nebendienstleistungen und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Semaphoren: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Hilfsdienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ereignisflag-Gruppen: Einführung und Basisdienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <br></div></div><br><h2>  Was ist Nucleus SE? </h2><br>  Wir wissen, dass Nucleus SE der Kern eines Echtzeitbetriebssystems ist, aber Sie müssen verstehen, wie es in den Rest der Anwendung passt.  Und es passt einfach, weil die Anwendung im Gegensatz zu einem Desktop-Betriebssystem (z. B. Windows) nicht auf Nucleus SE gestartet wird.  Der Kernel ist einfach Teil eines Programms, das auf einem eingebetteten Gerät ausgeführt wird.  Dies ist der häufigste Anwendungsfall für RTOS. <br><br>  Aus einer übergeordneten Sicht ist eine eingebettete Anwendung eine Art Code, der beim Starten der CPU gestartet wird.  In diesem Fall wird die Hardware- und Softwareumgebung initialisiert und anschließend die Funktion <b>main ()</b> aufgerufen, mit der der Hauptanwendungscode gestartet wird. <br><br>  Bei Verwendung von Nucleus SE (und vielen anderen ähnlichen Kerneln) besteht der Unterschied darin, dass die Funktion <b>main ()</b> Teil des Kernel-Codes ist.  Diese Funktion initialisiert einfach die Datenstrukturen des Kernels und ruft dann den Scheduler auf, was zum Start des Anwendungscodes (Tasks) führt.  Der Benutzer kann der <b>main () -</b> Funktion einen beliebigen nativen Initialisierungscode hinzufügen. <br><br>  Nucleus SE enthält auch eine Reihe von Funktionen - eine Anwendungsprogrammierschnittstelle (API), die eine Reihe von Funktionen wie Kommunikation und Task-Synchronisation, Arbeiten mit Timern, Speicherzuweisung usw. bereitstellt.  Alle API-Funktionen wurden bereits in den Artikeln dieser Reihe beschrieben. <br><br>  Die gesamte Nucleus SE-Software wird als Quellcode bereitgestellt (hauptsächlich in C).  Um den Code gemäß den Anforderungen einer bestimmten Anwendung zu konfigurieren, wird eine bedingte Kompilierung verwendet.  Dies wird in diesem Artikel im Abschnitt Konfiguration ausführlich beschrieben. <br><br>  Nachdem der Code kompiliert wurde, werden die resultierenden Nucleus SE-Objektmodule den Anwendungscodemodulen zugeordnet, was zu einem einzelnen Binärbild führt, das normalerweise im Flash-Speicher des eingebetteten Geräts abgelegt wird.  Das Ergebnis dieser statischen Bindung ist, dass alle symbolischen Informationen sowohl aus dem Anwendungscode als auch aus dem Kernelcode verfügbar bleiben.  Dies ist nützlich für das Debuggen. Es ist jedoch Vorsicht geboten, um einen Missbrauch der Nucleus SE-Daten zu vermeiden. <br><br><h2>  CPU- und Tool-Unterstützung </h2><br>  Da Nucleus SE als Quellcode geliefert wird, muss es portabel sein.  Code, der auf einer so niedrigen Ebene ausgeführt wird (bei Verwendung von Schedulern, bei denen eine Kontextumschaltung erforderlich ist, dh alles andere als Run to Completion), kann jedoch nicht vollständig unabhängig von der Assemblersprache sein.  Ich habe diese Abhängigkeit minimiert und für die Portierung auf eine neue CPU ist eine Low-Level-Programmierung fast nicht erforderlich.  Die Verwendung neuer Entwicklungstools (Compiler, Assembler, Linker usw.) kann ebenfalls zu Portierungsproblemen führen. <br><br><h2>  Einrichten der Nucleus SE-App </h2><br>  Der Schlüssel zur effizienten Nutzung von Nucleus SE ist die richtige Einrichtung.  Es mag kompliziert aussehen, aber tatsächlich ist alles ziemlich logisch und erfordert nur einen systematischen Ansatz.  Fast die gesamte Konfiguration erfolgt durch Bearbeiten von zwei Dateien: <b>nuse_config.h</b> und <b>nuse_config.c</b> . <br><br><h3>  Einstellung Nuse_config.h </h3><br>  Diese Datei ist nur ein Zeichensatz der Direktive <b>#define</b> , dem die entsprechenden Werte zugewiesen wurden, um die erforderliche Kernelkonfiguration zu erhalten.  In der Datei <b>nuse_config.h sind</b> standardmäßig alle Zeichen vorhanden, ihnen werden jedoch die Mindesteinstellungen zugewiesen. <br><br>  <b><i>Objektzähler</i></b> <br>  Die Anzahl der <b>Kernelobjekte</b> jedes Typs wird durch Symbolwerte der Form <b>NUSE_SEMAPHORE_NUMBER festgelegt</b> .  Für die meisten Objekte kann dieser Wert zwischen 0 und 15 variieren. Aufgaben sind eine Ausnahme, es muss mindestens eine vorhanden sein.  Signale sind in der Tat keine unabhängigen Objekte, da sie Aufgaben zugeordnet sind und durch <b>Setzen von NUSE_SIGNAL_SUPPOR</b> T auf <b>TRUE</b> <b>aktiviert werden</b> . <br><br>  <b><i>API-Funktionsaktivatoren</i></b> <br>  Jede Nucleus SE-API-Funktion kann separat aktiviert werden, indem <b>TRUE</b> ein Symbol <b>zugewiesen wird,</b> dessen Name mit dem Funktionsnamen (z. B. <b>NUSE_PIPE_JAM</b> ) <b>übereinstimmt</b> .  Dies führt zur Aufnahme des Funktionscodes in die Anwendung. <br><br>  <b><i>Scheduler Auswahl und Einstellungen</i></b> <br>  Nucleus SE unterstützt vier Arten von Schedulern, wie in einem vorherigen Artikel beschrieben.  Der verwendete Scheduler wird festgelegt, indem <b>NUSE_SCHEDULER_TYPE</b> einem der folgenden Werte <b>zugewiesen</b> wird: <b>NUSE_RUN_TO_COMPLETION_SCHEDULER</b> , <b>NUSE_TIME_SLICE_SCHEDULER</b> , <b>NUSE_ROUND_ROBIN_SCHEDULER</b> oder <b>NUSE_PRIORITY_SCHEDULER</b> . <br><br>  Sie können andere Scheduler-Parameter konfigurieren: <br>  <b>NUSE_TIME_SLICE_TICKS</b> gibt die Anzahl der Ticks pro Slot für den Time Slice Scheduler an.  Wenn ein anderer Scheduler verwendet wird, sollte dieser Parameter auf 0 gesetzt werden. <br>  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> kann auf <b>TRUE</b> oder <b>FALSE gesetzt werden</b> , um den Scheduler- <b>Zählermechanismus</b> zu aktivieren / deaktivieren. <br>  <b>NUSE_SUSPEND_ENABLE aktiviert</b> das Sperren ( <b>Anhalten) von</b> Aufgaben für viele API-Funktionen.  Dies bedeutet, dass ein Aufruf einer solchen Funktion zu einer Unterbrechung der aufrufenden Aufgabe führen kann, bis die Ressource freigegeben wird.  Um diese Option auszuwählen, <b>muss NUSE_SUSPEND_ENABLE</b> ebenfalls auf <b>TRUE gesetzt sein</b> . <br><br>  <b><i>Andere Optionen</i></b> <br>  Es können auch mehreren anderen Parametern <b>TRUE-</b> oder <b>FALSE-</b> Werte zugewiesen werden, um andere Kernelfunktionen zu aktivieren / deaktivieren: <br>  <b>NUSE_API_PARAMETER_CHECKING</b> fügt einen Überprüfungscode für API-Funktionsaufrufparameter hinzu.  Wird häufig zum Debuggen verwendet. <br>  <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> legt den Anfangszustand aller Aufgaben als <b>NUSE_READY</b> oder <b>NUSE_PURE_SUSPEND fest</b> .  Wenn dieser Parameter deaktiviert ist, haben alle Tasks den Ausgangszustand <b>NUSE_READY</b> . <br>  <b>NUSE_SYSTEM_TIME_SUPPORT</b> - Unterstützung für die Systemzeit. <br>  <b>NUSE_INCLUDE_EVERYTHING</b> - Ein Parameter, der der Konfiguration von Nucleus SE die maximale Anzahl von Funktionen hinzufügt.  Dies führt zur Aktivierung aller optionalen Funktionen und jeder API-Funktion der konfigurierten Objekte.  Wird verwendet, um schnell eine Nucleus SE-Konfiguration zu erstellen und eine neue Portierung des Kernel-Codes zu überprüfen. <br><br><h3>  Festlegen von nuse_config.c </h3><br>  Nach Angabe der <b>Kernelkonfiguration</b> in <b>nuse_config.h müssen</b> die verschiedenen im ROM gespeicherten Datenstrukturen initialisiert werden.  Dies erfolgt in der Datei <b>nuse_config.c</b> .  Die Definition von Datenstrukturen wird durch bedingte Kompilierung gesteuert, sodass alle Strukturen in einer Kopie der Standarddatei <b>nuse_config.c</b> enthalten sind. <br><br>  <b><i>Aufgabendaten</i></b> <br>  Das Array <b>NUSE_Task_Start_Address []</b> muss mit dem Wert der Startadressen jeder Aufgabe initialisiert werden.  Dies ist normalerweise nur eine Liste von Funktionsnamen ohne Klammern.  Prototypen von Aufgabeneingabefunktionen sollten ebenfalls sichtbar sein.  In der Standarddatei ist die Aufgabe mit dem Namen <b>NUSE_Idle_Task ()</b> konfiguriert. Dies kann in die Anwendungsaufgabe geändert werden. <br><br>  Wenn Sie einen Scheduler außer Run to Completion verwenden, benötigt jede Aufgabe einen eigenen Stapel.  Für jeden Taskstack müssen Sie ein Array im RAM erstellen.  Diese Arrays müssen vom Typ <b>ADDR sein</b> und die Adresse jedes Arrays muss in <b>NUSE_Task_Stack_Base []</b> gespeichert sein.  Es ist schwierig, die Größe des Arrays vorherzusagen, daher ist es besser, Messungen zu verwenden (siehe Abschnitt "Debuggen" weiter unten in diesem Artikel).  Die Größe jedes Arrays ( <b>dh</b> die Anzahl der Wörter auf dem Stapel) sollte in <b>NUSE_Task_Stack_Size []</b> gespeichert werden. <br><br>  Wenn eine Funktion aktiviert wurde, um den Anfangsstatus der Aufgabe <b>anzuzeigen</b> (mithilfe des Parameters <b>NUSE_INITIAL_TASK_STATE_SUPPORT</b> ), muss das Array <b>NUSE_Task_Initial_State []</b> mit dem <b>Status NUSE_READY oder NUSE_PURE_SUSPEND</b> initialisiert werden. <br><br>  <b><i>Partitionspooldaten</i></b> <br>  Wenn mindestens ein Partitionspool konfiguriert ist, muss für jeden im ROM ein Array (vom Typ <b>U8</b> ) erstellt werden.  Die Größe dieser Arrays wird wie folgt berechnet: (Anzahl der Partitionen * (Partitionsgröße + 1)).  Die Adressen dieser Abschnitte ( <b>dh</b> ihre Namen) müssen den entsprechenden <b>NUSE_Partition_Pool_Data_Address []</b> -Elementen zugewiesen werden.  Für jeden Pool sollten die Anzahl der Partitionen und ihre Größe in <b>NUSE_Partition_Pool_Partition_Number []</b> bzw. <b>NUSE_Partition_Message_Size []</b> platziert werden. <br><br>  <b><i>Warteschlangendaten</i></b> <br>  Wenn mindestens eine Warteschlange konfiguriert ist, muss für jedes Array im RAM ein Array (vom Typ <b>ADDR</b> ) erstellt werden.  Die Größe dieser Arrays entspricht der Anzahl der Elemente in jeder Warteschlange.  Die Adressen dieser Arrays ( <b>dh</b> ihre Namen) müssen den entsprechenden <b>NUSE_Queue_Data []</b> -Elementen zugewiesen werden.  Die Größe jeder Warteschlange muss dem entsprechenden Element <b>NUSE_Queue_Size []</b> zugewiesen werden. <br><br>  <b><i>Datenverbindungsdaten</i></b> <br>  Wenn mindestens ein Datenkanal konfiguriert ist, muss dafür (oder für jeden von ihnen) ein Array (vom Typ <b>U8</b> ) im RAM erstellt werden.  Die Größe dieser Arrays wird wie folgt berechnet: (Kanalgröße * Nachrichtengröße im Kanal).  Die Adressen dieser Arrays ( <b>dh</b> ihre Namen) müssen den entsprechenden <b>NUSE_Pipe_Data []</b> -Elementen zugewiesen werden.  Für jeden Kanal müssen seine Nachrichtengröße und -größe den entsprechenden Elementen <b>NUSE_Pipe_Size []</b> bzw. <b>NUSE_Pipe_Message_Size []</b> zugewiesen werden. <br><br>  <b><i>Semaphordaten</i></b> <br>  Wenn mindestens ein Semaphor konfiguriert ist, muss das Array <b>NUSE_Semaphore_Initial_Value []</b> mit den Anfangswerten des Countdowns initialisiert werden. <br><br>  <b><i>Anwendungs-Timer-Daten</i></b> <br>  Wenn mindestens ein Timer konfiguriert ist, muss das Array <b>NUSE_Timer_Initial_Time []</b> mit den Anfangswerten der Zähler initialisiert werden.  Außerdem müssen <b>NUSE_Timer_Reschedule_Time []</b> Neustartwerte zugewiesen werden.  Diese Timerwerte werden nach dem Ende des ersten Timerzyklus verwendet.  Wenn die Neustartwerte auf 0 gesetzt sind, stoppt der Zähler nach einem Zyklus. <br><br>  Wenn die Unterstützung für Kontenabschlussmechanismen konfiguriert ist (indem der Parameter <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> auf <b>TRUE gesetzt wird</b> ), müssen zwei weitere Arrays erstellt werden.  Adressen von Vervollständigungsmechanismen (nur eine Liste von Funktionsnamen ohne Klammern) müssen in <b>NUSE_Timer_Expiration_Routine_Address [] platziert werden</b> .  Das Array <b>NUSE_Timer_Expiration_Routine_Parameter []</b> muss mit den Werten der Abschlussparameter initialisiert werden. <br><br><h2>  Welche API? </h2><br>  Alle Betriebssysteme in der einen oder anderen Form verfügen über eine API (Application Programming Interface).  Nucleus SE ist keine Ausnahme, und die Funktionen, aus denen sich die API zusammensetzt, wurden in dieser Artikelserie ausführlich beschrieben. <br><br>  Es mag offensichtlich erscheinen, dass Sie beim Schreiben einer Anwendung mit Nucleus SE die API verwenden müssen, wie in den vorherigen Artikeln beschrieben.  Dies ist jedoch nicht immer der Fall. <br><br>  Für die meisten Benutzer ist die Nucleus SE-API etwas Neues, möglicherweise sogar ihre erste Erfahrung mit der Betriebssystem-API.  Und da es ganz einfach ist, kann es als gute Einführung in das Thema dienen.  In diesem Fall ist das Verfahren klar. <br><br>  Für einige Benutzer kann eine alternative API eine attraktivere Option sein.  Es gibt drei offensichtliche Situationen, in denen dies möglich ist. <br><ol><li>  Nucleus SE ist nur ein Teil eines Systems, das andere Betriebssysteme für andere Komponenten verwendet.  Daher sind die Portabilität des Codes und vor allem die Erfahrung mit der Verwendung verschiedener Betriebssysteme sehr verlockend. </li><li>  Der Benutzer verfügt über umfangreiche Erfahrung mit der API eines anderen Betriebssystems.  Diese Erfahrung ist auch sehr ratsam. </li><li>  Der Benutzer möchte Code, der für die API eines anderen Betriebssystems geschrieben wurde, wiederverwenden.  Das Ändern von API-Aufrufen ist möglich, aber zeitaufwändig. </li></ol><br><br>  Da der vollständige Quellcode von Nucleus SE für alle verfügbar ist, hindert Sie nichts daran, jede API-Funktion so zu bearbeiten, dass sie wie die eines anderen Betriebssystems aussieht.  Es wird jedoch viel Zeit in Anspruch nehmen und sehr unproduktiv sein.  Ein korrekterer Ansatz wäre, einen „Wrapper“ zu schreiben.  Es gibt verschiedene Möglichkeiten, dies zu tun. Am einfachsten ist es jedoch, eine Header-Datei ( <b>#include</b> ) zu erstellen, die eine Reihe von <b>#</b> <b>Define-</b> Makros enthält, mit denen API-Funktionen von Drittanbietern Nucleus SE-API-Funktionen zugeordnet werden. <br><br>  Ein Wrapper, der die Funktionen der Nucleus RTOS-API (teilweise) auf Nucleus SE überträgt, wird mit Nucleus SE verteilt.  Dies kann für Entwickler nützlich sein, die Erfahrung mit Nucleus RTOS haben oder in Zukunft auf dieses RTOS umsteigen können.  Dieser Wrapper kann auch als Beispiel für die Entwicklung ähnlicher Dinge dienen. <br><br><h2>  Debuggen von Nucleus SE-Anwendungen </h2><br>  Das Schreiben einer eingebetteten Anwendung mit einem Multitasking-Kernel ist eine komplexe Aufgabe.  Es kann eine entmutigende Aufgabe sein, sicherzustellen, dass der Code funktioniert und Fehler zu erkennen.  Trotz der Tatsache, dass dies nur Code ist, der auf einem Prozessor ausgeführt wird, macht es die gleichzeitige Ausführung mehrerer Aufgaben ziemlich schwierig, sich auf einen bestimmten Ausführungsthread zu konzentrieren.  Dies ist noch komplizierter, wenn mehrere Aufgaben einen gemeinsamen Code verwenden.  Am schlimmsten ist es, wenn zwei Aufgaben genau den gleichen Code haben (aber mit unterschiedlichen Daten arbeiten).  Erschwerend kommt auch das Auflösen von Datenstrukturen hinzu, mit denen Kernelobjekte implementiert werden, um aussagekräftige Informationen zu erhalten. <br><br>  Zum Debuggen von Anwendungen, die mit Nucleus SE erstellt wurden, sind keine zusätzlichen Bibliotheken oder anderen Dienste erforderlich.  Der gesamte Kernel-Code kann vom Debugger gelesen werden.  Daher stehen alle symbolischen Informationen zum Studium zur Verfügung.  Bei der Arbeit mit Nucleus SE-Anwendungen kann jedes moderne Debugging-Tool verwendet werden. <br><br><h3>  Verwenden eines Debuggers </h3><br>  Debugging-Tools, die speziell für eingebettete Systeme entwickelt wurden, sind in den 30 Jahren ihres Bestehens sehr leistungsfähig geworden.  Das Hauptmerkmal einer eingebetteten Anwendung im Vergleich zu einem Desktop-Programm ist, dass alle eingebetteten Systeme unterschiedlich sind (und alle PCs einander sehr ähnlich sind).  Ein guter eingebetteter Debugger sollte flexibel sein und über genügend Einstellungen verfügen, um den verschiedenen eingebetteten Systemen und Benutzeranforderungen zu entsprechen.  Die Anpassbarkeit des Debuggers wird in verschiedenen Formen ausgedrückt, normalerweise besteht jedoch die Möglichkeit, Skripte zu erstellen.  Mit dieser Funktion kann der Debugger gut mit einer Anwendung auf Kernelebene zusammenarbeiten.  Im Folgenden werde ich einige Fälle der Verwendung des Debuggers erläutern. <br><br>  Es ist erwähnenswert, dass ein Debugger normalerweise eine Familie von Werkzeugen ist, nicht nur ein Programm.  Der Debugger kann über verschiedene Betriebsmodi verfügen, über die er bei der Entwicklung von Code auf einem virtuellen System oder auf realer Hardware hilfreich ist. <br><br><h3>  Aufgabensensitive Haltepunkte </h3><br>  Wenn das Programm einen Code hat, der mehreren Aufgaben gemeinsam ist, ist die Verwendung herkömmlicher Haltepunkte während des Debuggens kompliziert.  Höchstwahrscheinlich muss der Code nur gestoppt werden, wenn ein Haltepunkt im Kontext einer bestimmten Aufgabe erreicht wird, die Sie gerade debuggen.  Dazu benötigen Sie einen Haltepunkt, der die Aufgabe berücksichtigt. <br><br>  Glücklicherweise machen die Möglichkeit, Skripte auf modernen Debuggern zu erstellen, und die Verfügbarkeit von Nucleus SE-Zeichendaten die Implementierung aufgabenspezifischer Haltepunkte zu einer ziemlich einfachen Sache.  Sie müssen lediglich ein einfaches Skript schreiben, das einem Haltepunkt zugeordnet wird, den Sie zur Unterscheidung zwischen Aufgaben einlernen möchten.  Dieses Skript übernimmt den Parameter: index (ID) der Aufgabe, an der Sie interessiert sind.  Das Skript vergleicht diesen Wert einfach mit dem Index der aktuellen Aufgabe ( <i>NUSE_Task_Active</i> ).  Wenn die Werte übereinstimmen, wird das Programm angehalten.  Wenn sie unterschiedlich sind, wird die Ausführung fortgesetzt.  Es ist anzumerken, dass die Ausführung dieses Skripts die Ausführung der Anwendung in Echtzeit beeinflusst ( <i>Anmerkung des Übersetzers:</i> Dies <i>bedeutet, dass die Ausführung des Programms im Vergleich zum normalen Betrieb langsamer wird</i> ).  Befindet sich das Skript jedoch nicht in einer Schleife, die sehr oft ausgeführt wird, ist dieser Effekt minimal. <br><br><h3>  Kernel-Objektinformationen </h3><br>  Die offensichtliche Notwendigkeit für das Debuggen der Nucleus SE-Anwendung besteht in der Möglichkeit, Informationen über die Kernelobjekte abzurufen: Welche Eigenschaften haben sie und welchen aktuellen Status haben sie?  Auf diese Weise erhalten Sie Antworten auf Fragen wie: "Wie groß ist diese Warteschlange und wie viele Nachrichten befinden sich jetzt darin?" <br><br>  Dies kann verwendet werden, indem Sie Ihrer Anwendung zusätzlichen Debugging-Code hinzufügen, der die "informativen" API-Aufrufe (z. B. <b>NUSE_Queue_Information</b> ) verwendet.  Dies bedeutet natürlich, dass Ihre Anwendung jetzt zusätzlichen Code enthält, der nach der Implementierung der Anwendung nicht mehr erforderlich ist.  Die Verwendung von <b>#define</b> zum <b>Ein-</b> und Ausschalten dieses Codes mithilfe der bedingten Kompilierung wäre eine logische Entscheidung. <br><br>  Einige Debugger können einen gezielten Funktionsaufruf ausführen, dh direkt eine API-Funktion aufrufen, um Informationen abzurufen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch ist kein zusätzlicher Code erforderlich, diese API-Funktion muss jedoch konfiguriert sein, damit der Debugger sie verwenden kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein alternativer, flexiblerer, aber weniger alternder Ansatz ist der direkte Zugriff auf die Datenstrukturen von Kernelobjekten. </font><font style="vertical-align: inherit;">Am wahrscheinlichsten ist es, dies mit Debugger-Skripten zu tun. </font><font style="vertical-align: inherit;">In unserem Beispiel kann die Warteschlangengröße von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Size []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die aktuelle Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data [] abgerufen werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Außerdem können Nachrichten in der Warteschlange unter Verwendung der Adresse des Warteschlangendatenbereichs (von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Queue_Data []</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">angezeigt werden </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rückgabewerte für API-Aufrufe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele API-Funktionen geben einen Statuswert zurück, der angibt, wie erfolgreich der Aufruf abgeschlossen wurde. Es wäre nützlich, diese Werte zu verfolgen und Fälle zu markieren, in denen sie nicht gleich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_SUCCESS sind</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">dh</font></b><font style="vertical-align: inherit;"> sie haben den Wert Null). Da dieses Tracking nur zum Debuggen dient, ist die bedingte Kompilierung durchaus angemessen. Die Definition einer globalen Variablen (z. B. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) kann bedingt kompiliert werden (unter der Kontrolle des Direktiven-Symbols #define). Dann kann ein Teil der Definition von API-Aufrufen, nämlich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , auch bedingt kompiliert werden. Zum Debuggen beispielsweise ein Aufruf, der normalerweise folgendermaßen aussieht: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPSEND);</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird die folgende Form annehmen:</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_API_Call_Status = NUSE_Mailbox_Send (mbox, msg, NUSE_SUSPEND); </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Task-Sperre aktiviert ist, können viele API-Funktionsaufrufe nur Informationen über einen erfolgreichen Anrufabschluss oder das Zurücksetzen des Objekts zurückgeben. </font><font style="vertical-align: inherit;">Wenn jedoch die API-Parameterprüfung aktiviert ist, können API-Aufrufe viele andere Werte zurückgeben.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Festlegen der Größe des Taskstapels und des Stapelüberlaufs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Thema Stapelüberlaufschutz wurde in einem früheren Artikel (Nr. 31) erörtert. Beim Debuggen gibt es mehrere andere Möglichkeiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Speicherbereich des Stapels kann mit einem charakteristischen Wert gefüllt werden: etwas anderes als alle Einsen oder alle Nullen. Danach kann der Debugger verwendet werden, um die Speicherbereiche zu überwachen und wie stark die Werte geändert werden, wodurch wir den Grad der Fülle des Stapels verstehen können. Wenn alle Speicherbereiche geändert wurden, bedeutet dies nicht, dass der Stapel voll war, aber es kann bedeuten, dass seine Größe kaum ausreicht, was gefährlich ist. Es sollte erhöht und die Tests fortgesetzt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel 31 beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Implementierung der Diagnose können sich zusätzliche Bereiche, „Schutzwörter“, an jeder Kante des Stapelspeicherbereichs befinden. </font><font style="vertical-align: inherit;">Der Debugger kann verwendet werden, um den Zugriff auf diese Wörter zu verfolgen, da jeder Versuch, in sie zu schreiben, einen Überlauf oder eine Erschöpfung des Stapels bedeutet.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Checkliste für die Nucleus SE-Konfiguration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Nucleus SE als hochflexibles und anpassbares System zur Erfüllung der Anwendungsanforderungen konzipiert wurde, sind zahlreiche anpassbare Parameter erforderlich. </font><font style="vertical-align: inherit;">Aus diesem Grund ist dieser gesamte Artikel der Konfiguration von Nucleus SE gewidmet. </font><font style="vertical-align: inherit;">Um sicherzustellen, dass wir nichts verpassen, finden Sie im Folgenden eine Checkliste aller wichtigen Schritte, die Sie zum Erstellen der eingebetteten Nucleus SE-Anwendung ausführen müssen.</font></font><br><ol><li> <b> Nucleus SE.</b>   ,     Nucleus SE       ,        Nucleus SE     . </li><li> <b>  CPU/.</b>             . </li><li> <b>  .</b>     ,       ,    . </li><li> <b>  .</b>        .       .  ,     .      16 . </li><li> <b> .</b>     -   <b>main()</b> ? </li><li> <b> .</b>     4 ,       . </li><li> <b>   </b> ,     . </li><li> <b>    .</b> </li><li> <b>.</b>   ,     . </li><li> <b> .</b>    ,    . </li><li> <b>  .</b> ,      .     .  —  16   . </li><li> <b>  .</b>        ,   . </li><li> <b>  .</b>        ,    (,      ). </li><li> <b> API.</b>    API,   . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der nächste Artikel (der letzte in dieser Reihe) fasst die gesamte Geschichte mit Nucleus SE zusammen und enthält Informationen, die Sie beim Erstellen und Verwenden von Nucleus SE-Implementierungen unterstützen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über den Autor:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware. </font><font style="vertical-align: inherit;">Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics). </font><font style="vertical-align: inherit;">Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware. </font><font style="vertical-align: inherit;">Lebt in Großbritannien. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colins</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> professioneller </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Blog</font></a><font style="vertical-align: inherit;"> , E-Mail: colin_walls@mentor.com.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467763/">https://habr.com/ru/post/de467763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467751/index.html">Wie funktioniert ein dezentraler Messenger in der Blockchain?</a></li>
<li><a href="../de467753/index.html">Weltrekord für drahtlose Datenübertragung: 40 Gbit / s pro 11 Kilometer</a></li>
<li><a href="../de467755/index.html">Prionen, Kalzium, Mikrobiota, Nahrungshormone und Alzheimer</a></li>
<li><a href="../de467759/index.html">Unix-ähnliches Betriebssystemdesign - Virtueller Adressraum (6)</a></li>
<li><a href="../de467761/index.html">Energie, Wärme und Wasser Teil drei: Gehen Sie zum Radio</a></li>
<li><a href="../de467765/index.html">Wi-Fi und viele andere Abkürzungen. So erhalten Sie Daten auf Wi-Fi-Knoten in einer Android-Anwendung und schwellen nicht an</a></li>
<li><a href="../de467767/index.html">Weitere Annehmlichkeiten für JSON-RPC-Follower</a></li>
<li><a href="../de467769/index.html">Auf einer einzigen Bundesinformationsquelle, die Bevölkerungsinformationen enthält</a></li>
<li><a href="../de467773/index.html">Beschaffung ungewöhnlicher Ressourcen und Erstkontakt</a></li>
<li><a href="../de467775/index.html">5 Mythen über das Geschäft: Warum der Kunde falsch liegt und wie man Apple übertrifft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>