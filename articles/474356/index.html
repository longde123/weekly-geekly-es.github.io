<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛬 🛌🏻 🖌️ ThingJS v1.0-alpha 👾 👨🏼‍🌾 🙍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante los últimos dos años he estado desarrollando mi propia plataforma IoT y hoy estoy listo para mostrar su versión alfa. 


 Junto con un socio, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ThingJS v1.0-alpha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474356/"><p><img src="https://habrastorage.org/webt/hd/vu/kq/hdvukqu1cfju8ygby3otuzmptmu.png"></p><br><p> Durante los últimos dos años he estado desarrollando mi propia plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IoT</a> y hoy estoy listo para mostrar su versión alfa. </p><br><p>  Junto con un socio, creamos y admitimos dispositivos IoT.  Desmantelamos más <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de un cobertizo de rastrillo</a> en el proceso de esta actividad.  ThingJS nació no tanto por el deseo como por la necesidad de hacernos la vida más fácil, sino al mismo tiempo, espero, para ti. </p><br><p>  El artículo será interesante para las personas que están cerca del tema de IoT y que ya han hecho algo en esta área.  Un punto importante será que la plataforma debería interesar (de repente) a los desarrolladores de JavaScript, ya que  Este lenguaje se elige como la base de la plataforma.  Por supuesto, los desarrolladores de C / C ++ también tendrán algo para leer. </p><br><p>  Primero, hablaré sobre los problemas clave que encontramos al desarrollar dispositivos IoT, luego describiré cómo la plataforma los maneja y, al final, todo es aburrido: el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte técnica</a> y puedes tocar todo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vivo</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Tabla de contenidos</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problemas de IoT</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problema de mano corta</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El problema de la torre de Babel.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Problema del síndrome de Estocolmo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soluciones a problemas</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comunidad, Adicción, Moda, Juventud.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más promesas y abstracciones.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dispositivos virtuales de IoT</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informacion tecnica</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructura de aplicación de ThingJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pila de tecnología</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Características del entorno de desarrollo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dispositivos compatibles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comparación con la competencia.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inicio rápido</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solo tengo que mirar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quiero intentar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicación de parpadeo</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asamblea desde la fuente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Composición de la aplicación</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manifest.json</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloque de componentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloque de secuencias de comandos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El bloque "requiere"</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">blink.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blink.vue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">scripts / blink.js</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación de interfaz</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Entorno de desarrollo</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de aplicaciones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de firmware</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Que sigue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Referencias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FAQ</a> </li></ul></div></div><br><h1 id="problemy-iot--anchorproblemsanchor">  Problemas de IoT: <a name="problems"></a></h1><br><h2 id="--problema-korotkih-ruk-anchorshort-handsanchor">  - El problema de los brazos cortos. <a name="short-hands"></a></h2><br><p>  IoT se basa en un ecosistema.  El desarrollo de su concepto y arquitectura técnica es realmente mucho trabajo.  Además, aún necesita desarrollar un montón de firmware para dispositivos heterogéneos.  Para inventar e implementar el transporte para el intercambio de datos entre dispositivos en varios principios físicos y lógicos.  Expande los recursos en la nube.  Trabajar interfaces de usuario.  Etc.  etc. </p><br><p>  Incluso si un especialista individual tiene las habilidades necesarias para hacer esto, entonces simplemente no tiene suficiente tiempo (manos) para implementar tal idea.  Si bien él lo cortará, ella se volverá obsoleta. </p><br><h2 id="--problema-vavilonskoy-bashni-anchortoweranchor">  - El problema de la torre de Babel <a name="tower"></a></h2><br><p>  El desarrollo de un ecosistema de IoT completo requiere una pila tecnológica muy amplia.  Ser una pila completa en IoT es sencillo ... difícil.  Necesito experiencia en todas partes.  No todos pueden presumir de una gama tan amplia de conocimientos e incluso de experiencia.  Y aquí la pregunta no está en las habilidades mentales.  Esta es una conclusión obvia del problema de la mano corta. </p><br><p>  Crear un ecosistema verdaderamente rico requiere el trabajo de muchos especialistas bastante limitados, pero con un profundo conocimiento en su campo.  Estos especialistas hablan diferentes idiomas, usan diferentes patrones y, a menudo, entienden los términos elementales de diferentes maneras.  Y dado que IoT se basa en dispositivos con recursos limitados, las comunicaciones efectivas son críticas para la realización de lo que se pretende. </p><br><h2 id="--problema-stokgolmskogo-sindroma-anchorsindromanchor">  - El problema del síndrome de Estocolmo <a name="sindrom"></a></h2><br><p>  Hoy hay vendedores que desarrollan sus ecosistemas.  Estos son Google, Microsoft, Yandex, Megáfono, MTS, etc.  Algunos de ellos le permiten integrar sus propias cosas en sus ecosistemas en sus términos.  Esto cubre en gran medida los problemas descritos anteriormente.  Pero crea uno nuevo: la adicción.  Y a los vendedores les gusta cambiar las condiciones para la integración.  Y aún más, no hay cuestión de autorrealización en este paradigma. </p><br><h1 id="resheniya-problem-anchorsolutionsanchor">  Soluciones a problemas: <a name="solutions"></a></h1><br><h2 id="--soobschestvo-zavisimosti-modno-molodezhno-anchorcommunityanchor">  - Comunidad, adicción, moda, juventud. <a name="community"></a></h2><br><p>  Los problemas descritos anteriormente, de hecho, bloquean el acceso al desarrollo de IoT para individuos.  El desarrollo de la plataforma se lanzó con la conciencia de estos problemas.  Se sentaron las bases para el desarrollo de la plataforma a través de la comunidad. </p><br><p>  Para implementar esta idea, la plataforma, por supuesto, viene con una base de código abierto, y también tiene un paradigma de dependencia en todas las capas. </p><br><p>  Si no sabe qué son las adicciones, es hora de conocerlas.  Pero si intentas explicarlo de manera muy simple, entonces el módulo que estás desarrollando puede depender de otro que escriba tu amigo.  Y accederá a su módulo a través de una interfaz predefinida. </p><br><p>  Por lo tanto, al mismo tiempo, de manera independiente, muchas personas pueden desarrollar sus propios componentes de plataforma y reutilizar los existentes desarrollados por alguien.  Esto resuelve fundamentalmente el problema de las manos cortas. </p><br><p><img src="https://habrastorage.org/webt/zt/xk/ok/ztxkokx7yqcgzwymgrq3o-ueah4.png"></p><br><p>  Además, el problema de la "Torre de Babel" se está resolviendo.  Las dependencias se crean de modo que los distintos niveles de la plataforma, desarrollados en diferentes idiomas, tengan un mecanismo predeterminado para construir dependencias entre ellos. </p><br><p>  Por ejemplo, un desarrollador de C puede aprovechar un componente de front-end listo para usar al proporcionarle la interfaz requerida.  O, por el contrario, el desarrollador front-end puede usar un componente listo para usar escrito en C. Es decir  todos harán lo que mejor sabe. </p><br><h2 id="--bolshe-obeschaniy-i-abstrakciy-anchorpromisesanchor">  - Más promesas y abstracciones. <a name="promises"></a></h2><br><p>  El protocolo de comunicación entre dispositivos no está definido.  En cambio, hay una abstracción: un bus de datos.  El dispositivo puede enviar un evento al bus o escuchar el bus.  No está claro quién escribe en el autobús y quién recibe, por adelantado.  Y cuando también.  El intercambio de datos asíncrono y la entrega no están garantizados.  En general, el infierno.  Sin pánico  Así concebido. </p><br><p>  La cuestión es que el ecosistema es un grupo de dispositivos independientes y autosuficientes.  En cualquier momento, algunos dispositivos pueden no estar disponibles.  Por varias razones  Para detener la actividad de otros dispositivos si una parte no está disponible, no es el mejor escenario.  Es necesario legalizar lo que no se puede evitar. </p><br><p>  La plataforma implementa el paradigma de las promesas de proporcionar eventos.  El primer dispositivo se suscribe a la promesa del segundo de darle información.  Pero no hay garantías.  El suscriptor debe decidir qué hacer en caso de que le proporcione datos de manera prematura. </p><br><p>  El problema de la comunicación sincrónica se resuelve transmitiendo eventos a través del bus con enlaces a canales sincrónicos.  El protocolo de canal síncrono está determinado por el tipo de evento en sí.  Por ejemplo, puede enviar un evento con el tipo "do-render-video-stream" y cómo enviar cámaras IP WEB como carga útil.  Por lo tanto, el destinatario sabrá que necesita reproducir la transmisión de video desde la dirección especificada. </p><br><p><img src="https://habrastorage.org/webt/3s/th/vn/3sthvnlojthoq_gh9uqirnbqedg.png"></p><br><p>  Pero, ¿cómo funciona físicamente el autobús?  La implementación del autobús recae en la comunidad.  El neumático se expande con el transporte que requiere su proyecto.  Por ejemplo, se recibe un evento a través de http y se retransmite a través de UART.  Para todos los elementos del ecosistema, exteriormente nada cambiará. </p><br><h1 id="--virtualnye-iot-ustroystva-anchorvirtualanchor">  - Dispositivos virtuales de IoT <a name="virtual"></a></h1><br><p>  Para ThingJS, una cosa no es solo una cosa física, sino también una aplicación especial, una cosa virtual.  Además, una cosa física puede contener varias cosas virtuales (aplicaciones) que usan los recursos de una cosa física. </p><br><p>  Este enfoque le permite unificar la interacción entre el backend condicional (controlador / servidor / nube, etc.) y el frontend (navegador, aplicación, etc.), así como b2b e incluso f2f.  Construya una matriz, no una jerarquía de interacciones. </p><br><p><img src="https://habrastorage.org/webt/-l/vg/bd/-lvgbdkme-d81bzhaqpqjwhcnly.png"></p><br><p>  Un ejemplo simple sería una cámara WEB, que en sí misma tiene una cosa virtual: una interfaz de usuario.  Cuando el usuario va a la dirección <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://192.168.4.1</a> , se abre la página WEB, donde lo virtual comienza a "vivir".  La cámara (cosa física) y la página (cosa virtual) se convierten automáticamente en un ecosistema donde está disponible un bus de datos unificado.  A través de él, lo virtual se comunica con lo físico.  En este caso: lo físico le dice a lo virtual a través del bus la dirección del flujo de video, su estado, etc., y lo virtual le muestra al usuario el video y le da los comandos necesarios a lo físico. </p><br><p>  La continuación lógica es la capacidad de alojar cosas virtuales en las nubes e incluirlas en un ecosistema común.  Y esto, a su vez, le permite crear dispositivos virtuales con enormes recursos que resuelven problemas, por ejemplo, disponibles para IA. </p><br><p>  Puede crear dichos dispositivos usted mismo o usar los ya creados.  El síndrome de Estocolmo está derrotado.  Usted mismo determina de qué depende su proyecto y cómo lo desarrollará. </p><br><h1 id="tehnicheskaya-informaciya-anchortech-infoanchor">  Informacion tecnica <a name="tech-info"></a></h1><br><h2 id="struktura-prilozheniya-thingjs-anchorapp-structanchor">  Estructura de aplicación de ThingJS <a name="app-struct"></a></h2><br><p><img src="https://habrastorage.org/webt/sz/-w/ul/sz-wuldlbfp7z2kcc1vgrqov_ta.png"></p><br><h2 id="stek-tehnologiy-anchortech-stackanchor">  Pila de tecnología <a name="tech-stack"></a></h2><br><p>  La plataforma de hardware seleccionada es el controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ESP32</a> .  La plataforma fue diseñada como hardware independiente.  Pero, desafortunadamente, no hubo tiempo para particionar en otros dispositivos. </p><br><p>  Para el desarrollo del firmware, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se utilizan las herramientas</a> recomendadas de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Espressif</a> .  El firmware está desarrollado en C. El colector cmake.  El proyecto utiliza el concepto de componente, también promovido por Espressif. </p><br><p>  Además de esp-idf, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se utiliza Mongoose WEB Server</a> , así como un intérprete de JavaScript modificado Mongoose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mJS</a> . </p><br><p>  Para el desarrollo de aplicaciones, JavaScript se usa con el marco VUE 2. Cree aplicaciones usando webpack.  El administrador de paquetes es npm.  El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VUE CLI se</a> utilizó como base para el entorno de desarrollo. </p><br><p>  Para estandarizar la visualización de aplicaciones y aliviar los dolores de la creatividad de la interfaz de usuario, el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vuetifyjs</a> está incluido en la plataforma. </p><br><h2 id="vozmozhnosti-sredy-razrabotki-anchordev-skilsanchor">  Características del entorno de desarrollo <a name="dev-skils"></a></h2><br><p>  Para desarrolladores de JavaScript (cosas virtuales): </p><br><ul><li>  IDE recomendado - WEBStorm; </li><li>  Todos los beneficios que otorga VUE CLI e IDE; </li><li>  Depuración de aplicaciones dentro del sistema (depurador mJS en el controlador); </li><li>  MJS implementa el comando depurador, que le permite llamar al depurador en un lugar arbitrario; </li><li>  Carga en caliente de archivos actualizados al controlador durante el desarrollo (los desarrolladores de JavaScript ya no pueden vivir sin esta función); </li><li>  El desarrollo en tiempo de ejecución se combina con un controlador real.  Usted programa y, allí mismo, ve el resultado en el hardware; </li><li>  Configurado ESLint para comprender los objetos de la plataforma. </li></ul><br><p>  Para desarrolladores de C (cosas físicas): </p><br><ul><li>  IDE recomendado - CLion; </li><li>  Todas las ganancias esp-idf e IDE; </li><li>  La plataforma se divide en componentes como parte del concepto esp-idf; </li><li>  Fácil integración con la plataforma de componentes nativos. </li></ul><br><h2 id="podderzhivaemye-ustroystva-anchorhw-supportedanchor">  Dispositivos compatibles <a name="hw-supported"></a></h2><br><p>  Solo ESP32 es compatible actualmente.  El chip es popular debido a su disponibilidad con sorprendentes características técnicas.  En base a esto, se han creado muchos dispositivos IoT listos para usar que se pueden usar con ThingJS. </p><br><h2 id="sravnenie-s-konkurentami-anchorvs-otheranchor">  Comparación con la competencia. <a name="vs-other"></a></h2><br><p>  Sugiero no correr tan lejos.  No me atrevo a llamar competidores a las plataformas comerciales.  Y el código abierto aparece y desaparece sin dejar un rastro notable.  Por lo tanto, no hice una comparación.  Sin embargo, si alguien tiene un deseo, estoy listo para publicar el resultado de su trabajo aquí. </p><br><h1 id="bystryy-start-anchorget-startedanchor">  Inicio rápido <a name="get-started"></a></h1><br><h2 id="mne-tolko-posmotret-anchorvideoanchor">  Solo tengo que mirar <a name="video"></a></h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dhPIAL2N0MQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="hochu-poprobovat-anchortouch-itanchor">  Quiero intentar <a name="touch-it"></a></h2><br><p>  Para probar la plataforma en hardware real, necesitará cualquier dispositivo basado en ESP32 con flash 4mb y la capacidad de flashearlo a través de USB.  Pero la placa base ESP32 v2 es la más adecuada. </p><br><p><img src="https://habrastorage.org/webt/ik/qw/jy/ikqwjyhkejf5t5kwdmbn20lq1ko.png"></p><br><p>  Puede comprar tales cosas sin problemas en Aliexpress o Ebay.  Además, incluso hay oficinas de representación en Rusia.  Yo personalmente compro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">San Petersburgo</a> . </p><br><p>  Para probar el funcionamiento de la aplicación de prueba "Parpadeo", debe conectar un LED.  Algunas versiones de las placas tienen un LED preinstalado conectado a GPIO2.  Si tiene un tablero así, entonces no puede hacer nada.  El parpadeo debería funcionar sin movimientos innecesarios.  Si solo tiene un diodo (fuente de alimentación), deberá conectar el diodo indicador usted mismo.  Esto no es nada complicado. </p><br><p>  Necesitará cualquier indicador LED y resistencia de 1 a 5K. </p><br><p><img src="https://habrastorage.org/webt/ey/vg/e7/eyvge7dfugct2jtk2u2rq8wkpqs.png"></p><br><p>  Lo único que queda es implementar el paquete de usuario en el dispositivo.  Puedes llevarlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Las instrucciones de implementación se encuentran allí. </p><br><h2 id="blink-prilozhenie-anchorblinkanchor">  Aplicación de parpadeo <a name="blink"></a></h2><br><h3 id="sborka-iz-ishodnikov-anchorblink-bouldanchor">  Asamblea desde la fuente <a name="blink-bould"></a></h3><br><p>  Blink es un ecosistema simple que consta de un dispositivo virtual que implementa la interfaz de usuario y uno físico.  Un dispositivo virtual comienza desde un dispositivo físico cuando se accede a él a través de un navegador. </p><br><p>  El guión es simple.  Al instalar la aplicación en un dispositivo físico, el LED (previamente conectado a él) comienza a parpadear a una frecuencia de 1 Hz.  El usuario puede encender o apagar el parpadeo del diodo desde la interfaz.  Puedes ver el video en la sección "Solo puedo ver". </p><br><p>  Las fuentes están en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio</a> src / aplicaciones / blink.  Para recopilar blink y jugar con él, solo necesita este repositorio.  Asegúrese de que ya tiene instalados git, npm y nodejs. </p><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install npm run build</code> </pre> <br><p>  Si todo salió bien, terminarás con algo como lo siguiente: </p><br><p><img src="https://habrastorage.org/webt/7b/a-/n8/7ba-n8_6y8hng41irp6jttozxks.png"></p><br><p>  Felicidades  Has creado tu primera aplicación ThingJS.  Puede encontrarlo en la carpeta dist / apps / blink e inmediatamente intente instalarlo en el dispositivo, guiado por el video de la sección <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Solo puedo ver"</a> . </p><br><h3 id="sostav-prilozheniya-anchorblink-containsanchor">  Composición de la aplicación <a name="blink-contains"></a></h3><br><div class="scrollable-table"><table><tbody><tr><th>  Archivo </th><th>  Descripción </th></tr><tr><td>  scripts / blink.js </td><td>  El script que está instalado en el controlador. </td></tr><tr><td>  blink.js </td><td>  Punto de montaje del componente de aplicación </td></tr><tr><td>  Blink.vue </td><td>  Componente VUE que implementa la interfaz de usuario </td></tr><tr><td>  favicon.svg </td><td>  Icono de la aplicación </td></tr><tr><td>  langs.js </td><td>  Paquete de idioma de la aplicación </td></tr><tr><td>  manifest.json </td><td>  Manifiesto de solicitud </td></tr></tbody></table></div><br><p>  Puede familiarizarse con todos los detalles de la aplicación usted mismo.  Me enfocaré en varios archivos. </p><br><h3 id="manifestjson-anchorblink-manifestanchor">  manifest.json <a name="blink-manifest"></a></h3><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span> : <span class="hljs-string"><span class="hljs-string">"rpiontik"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subversion"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patch"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink Example"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"components"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"requires"</span></span> : {...} }</code> </pre> <br><p>  Como lo indica el nombre del archivo, este es el manifiesto de la aplicación.  Tiene metadatos generales sobre el propósito de los cuales es fácil de adivinar.  Además de ellos, hay tres bloques importantes.  Miremos de cerca: </p><br><h4 id="blok-components-anchorblink-manifest-componentsanchor">  Bloque de componentes <a name="blink-manifest-components"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink-app"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"intent_filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.action.MAIN"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"category"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.category.LAUNCH"</span></span> } ] } }</code> </pre> <br><p>  El bloque describe toda la base de componentes de la aplicación.  El campo "fuente" apunta al punto de montaje del componente (consulte blink.js) y es el punto de entrada del ensamblaje para webpack ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entrada</a> ).  Por lo tanto, cada componente se emitirá en un paquete separado.  Este paquete se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cargará</a> según sea necesario ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">carga diferida</a> ). </p><br><p>  Una estructura importante es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">intent_filter</a> .  Si programa para Android, encontrará algo familiar para usted.  Y no te equivoques.  El sistema genera eventos de interfaz y servicio a los que se suscribe el componente.  Si se produce un evento que satisfaga las condiciones de filtrado, el componente se cargará y el control se transferirá al punto de montaje. </p><br><p>  En este caso, el componente "aplicación de parpadeo" está suscrito al evento de inicio del componente de interfaz principal de la aplicación.  Cuando el iniciador inicie la aplicación, se introducirá este componente. </p><br><p>  Si modifica el manifiesto cambiando la línea </p><br><p> <code>thingjs.intent.category.LAUNCH &gt;&gt; thingjs.intent.category.PREFERENCE</code> </p> <br><p>  , luego de su ensamblaje e instalación resulta que la aplicación ha dejado de abrirse en el escritorio.  Pero apareció un nuevo "mosaico" en la sección "Configuración".  Al mismo tiempo, nada ha cambiado funcionalmente. </p><br><p>  Por lo tanto, le indicamos al lanzador que este componente es un elemento de interfaz para personalizar nuestra aplicación.  Y este componente comenzó a aparecer en la configuración. </p><br><h4 id="blok-scripts-anchorblink-manifest-scriptsanchor">  Bloque de secuencias de comandos <a name="blink-manifest-scripts"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"entry"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subscriptions"</span></span> : [<span class="hljs-string"><span class="hljs-string">"$-script-restart"</span></span>, <span class="hljs-string"><span class="hljs-string">"blink"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"hot_reload"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"scripts/blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"optimize"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } }</code> </pre> <br><p>  Este bloque es similar en función al bloque de "componentes", pero describe la base del componente de la aplicación en el lado del controlador. </p><br><p>  Indica claramente el punto de entrada.  En el campo "entrada".  Por separado, prestaré atención a que al instalar la aplicación, el script no se inicia inmediatamente.  Se inicia solo cuando ocurre uno de los eventos a los que está suscrito el script. </p><br><p>  El campo "suscripciones" es responsable de las suscripciones.  Ahora indica dos eventos: </p><br><ul><li>  <strong>$ -script-restart</strong> : ocurre cuando el sistema se inicia o reinicia; </li><li>  <strong>blink</strong> es un evento personalizado que es relevante para el ecosistema blink. </li></ul><br><p>  En el bloque "módulos", sigue la descripción de los scripts.  Notaré dos campos: </p><br><ul><li>  <strong>hot_reload</strong> : si este campo se establece en verdadero, cuando se cambia un archivo en modo de desarrollo, se descargará automáticamente al controlador (recarga en caliente); </li><li>  <strong>optimizar</strong> : si es verdadero, al compilar el proyecto, el script se optimizará y agregará. </li></ul><br><h4 id="blok-requires-anchorblink-manifest-requiresanchor">  El bloque "requiere" <a name="blink-manifest-requires"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"requires"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"interfaces"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED indicator"</span></span> } } } }</code> </pre> <br><p>  Probablemente ya haya notado que al instalar la aplicación, debe seleccionar el pin en el que parpadeará el LED.  Sin embargo, por defecto ya está seleccionado como GPIO2.  Este bloque es responsable de esta configuración. </p><br><p>  En este bloque se indican las dependencias.  En este caso, para que la aplicación funcione, debe proporcionar una interfaz con el tipo "bit_port".  Esta interfaz es un requisito obligatorio (obligatorio = verdadero) y, de forma predeterminada, se especifica GPIO2 (predeterminado = 2).  Se proyectará en el script con el nombre "parpadeo". </p><br><p>  Al instalar la aplicación, se tiene en cuenta el perfil del equipo en el que se implementarán los scripts.  Este perfil enumera las interfaces disponibles y los recursos de hardware disponibles para ellas (en particular, pines y sus combinaciones).  Comprueba la compatibilidad de requisitos y equipos.  Si el equipo puede satisfacer los requisitos de la aplicación, se muestra al usuario un esquema de asignación de recursos, donde los recursos primarios se asignan automáticamente, teniendo en cuenta las recomendaciones del manifiesto.  Es decir  desde ese mismo campo "predeterminado". </p><br><p>  Por lo tanto, se pueden instalar varias aplicaciones en un dispositivo, que pueden compartir recursos de hardware entre ellos. </p><br><h3 id="blinkjs-anchorblink-blink-jsanchor">  blink.js <a name="blink-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Blink.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Langs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./langs'</span></span>; $includeLang(Langs); $exportComponent(<span class="hljs-string"><span class="hljs-string">'blink-app'</span></span>, App);</code> </pre> <br><p>  El archivo es el punto de montaje del componente anunciado en el manifiesto (ver manifest.js / components). Registra el VUE del componente 'blink-app' a través del método de abstracción $ exportComponent, y también registra el paquete de idioma. </p><br><p>  Usted puede preguntar: ¿por qué tantas dificultades?  ¿Por qué no registrar inmediatamente el componente VUE que especifique en la fuente?  El hecho es que el manifiesto describe componentes públicos.  Estos componentes pueden ser solicitados por aplicaciones de terceros (dependencias de tiempo de ejecución).  El punto de montaje, a su vez, puede registrar componentes relacionados (para uso interno), así como servicios.  Es decir, preparar el entorno del componente. </p><br><h3 id="blinkvue-anchorblink-blink-vueanchor">  Blink.vue <a name="blink-blink-vue"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Blink'</span></span>, <span class="hljs-attr"><span class="hljs-attr">watch</span></span>: { blink_state (state) { <span class="hljs-comment"><span class="hljs-comment">// Send event to script this.$bus.$emit($consts.EVENTS.UBUS_MESSAGE, 'blink', state); } }, data () { return { blink_state: true }; } };</span></span></code> </pre> <br><p>  El código habla por sí mismo.  Cuando se cambia la propiedad "blink_state", se envía un mensaje al bus ($ bus) con el valor actual.  Esto es todo lo que necesita hacer para que el script en el lado del controlador reciba el comando deseado. </p><br><h3 id="scriptsblinkjs-anchorblink-script-blink-jsanchor">  scripts / blink.js <a name="blink-script-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Set port direction $res.blink.direction($res.blink.DIR_MODE_DEF_OUTPUT); // Run background process setInterval(function () { if (active) { // $res - is container with required resources $res.blink.set(state); // Do invert state = !state; } }, 1000); // Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  En general, el código es muy similar al uso clásico de un temporizador en JavaScript.  Excepto que no está en este dialecto de JavaScript.  Se implementa en la plataforma.  Conoce a este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mJS</a> .  Puede obtener más información al respecto en la página oficial del proyecto. </p><br><p>  Para las necesidades de la plataforma, se finaliza el dialecto.  Se han introducido temporizadores, así como un comando tan útil como "depurador".  Bueno, el depurador en sí.  Más información sobre esto por separado en la sección <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Entorno de desarrollo"</a> . </p><br><p>  Presta atención a los objetos globales de la plataforma.  Se nombran con el carácter "$". </p><br><ul><li>  <strong>$ res</strong> : contiene recursos que se asignan al script; </li><li>  <strong>$ bus</strong> - interfaz de <strong>bus</strong> . </li></ul><br><p>  Porque  la aplicación solicitó una interfaz con el tipo "bit_port" (ver profile.json / require) y el nombre "blink", se le asignó como $ res.blink.  La interfaz implementa solo tres funciones: </p><br><ul><li>  <strong>set (value)</strong> : establece el nivel GPIO </li><li>  <strong>get ()</strong> - obtiene el nivel GPIO actual </li><li>  <strong>direction (value)</strong> : establece el modo GPIO </li></ul><br><p>  Para la función de dirección, las constantes disponibles se describen a través de la misma interfaz $ res.blink.: DIR_MODE_DISABLE;  DIR_MODE_DEF_INPUT;  DIR_MODE_DEF_OUTPUT;  DIR_MODE_INPUT_OUTPUT_OD;  DIR_MODE_INPUT_OUTPUT. </p><br><p>  La suscripción a eventos de bus se realiza a través del método $ bus.on.  En este caso, todos los eventos a los que está suscrito el script pasarán al controlador.  El controlador acepta tres parámetros: </p><br><ul><li>  <strong>evento</strong> : identificador de <strong>evento</strong> .  En este caso, solo dos son posibles: "$ -script-restart" y "parpadear".  De los cuales solo se procesa uno: parpadeo.  La suscripción a la segunda es necesaria solo para que el script se inicie inmediatamente al iniciar el sistema. </li><li>  <strong>contenido</strong> : los datos pueden venir con el evento.  Su tamaño está limitado a 126 bytes, teniendo en cuenta la longitud del identificador de evento. </li><li>  <strong>datos</strong> : datos que se transmiten al suscribirse al evento como un segundo parámetro.  Y en este caso, son nulos. </li></ul><br><p>  Las interfaces son extensibles.  A continuación encontrará una descripción de cómo crear su propia interfaz. </p><br><h2 id="realizaciya-interfeysa-anchorintefacesanchor">  Implementación de interfaz <a name="intefaces"></a></h2><br><p>  ThingJS le permite expandir los recursos de hardware y servicio disponibles a través de interfaces especiales.  Puede crear de forma independiente una interfaz que implementará cualquier complejo, preciso, cargado, etc.  funcional </p><br><p>  Por ejemplo, puede implementar una interfaz de integración con su servicio en la nube.  O un proceso asíncrono en segundo plano con el que el script podrá intercambiar mensajes.  Bueno, o implementar soporte de pantalla.  Será igualmente fácil de hacer y usar.  Tanto tú como los demás.  Es cierto, para esto necesitas saber C. </p><br><p>  Considere la implementación de la interfaz bit_port, que se usa en el ejemplo de Blink.  Para comenzar, debe implementar el proyecto de lanzamiento alfa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ThingJS-template</a> .  La documentación de implementación está en el proyecto mismo. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-template</code> </pre> <br><p>  El proyecto incluye componentes: </p><br><ul><li>  <strong>ThingJS-boards</strong> - contiene configuraciones de dispositivos.  Hasta ahora, solo ESP32_CORE_BOARD V2 y compatible; </li><li>  <strong>ThingJS-extern</strong> : bibliotecas de proyectos de terceros que utiliza ThingJS; </li><li>  <strong>ThingJS-core</strong> - núcleo de la plataforma; </li><li>  <strong>ThingJS-front</strong> - entorno de desarrollo de aplicaciones; </li><li>  <strong>ThingJS-stdi</strong> - interfaces estándar. </li></ul><br><p>  Estamos interesados ​​en el proyecto ThingJS-stdi.  Su estructura es la siguiente: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Archivo </th><th>  Descripción </th></tr><tr><td>  implementación / tgsi_bit_port.c </td><td>  Implementación de la interfaz Bit_port </td></tr><tr><td>  implementación / tgsi_bit_port.h </td><td>  Archivo de encabezado de interfaz Bit_pro </td></tr><tr><td>  CMakeLists.txt </td><td>  cmake build script </td></tr><tr><td>  README.md </td><td></td></tr><tr><td>  sdti_utils.h </td><td>  Ayudantes </td></tr><tr><td>  thingjs_stdi.c </td><td>  Punto de montaje de interfaz </td></tr><tr><td>  thingjs_stdi.h </td><td>  Archivo de encabezado de punto de montaje </td></tr></tbody></table></div><br><p>  De hecho, solo estamos interesados ​​en un archivo: implementación / tgsi_bit_port.c.  Contiene todo lo que requiere una explicación por separado. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingjsBitPortRegister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thingjs_bit_port_cases[] = DEF_CASES( DEF_CASE(GPIO0), DEF_CASE(GPIO2), DEF_CASE(GPIO3), DEF_CASE(GPIO4), DEF_CASE(GPIO5), DEF_CASE(GPIO12), DEF_CASE(GPIO13), DEF_CASE(GPIO14), DEF_CASE(GPIO15), DEF_CASE(GPIO16), DEF_CASE(GPIO17), DEF_CASE(GPIO18), DEF_CASE(GPIO19), DEF_CASE(GPIO21), DEF_CASE(GPIO22), DEF_CASE(GPIO23), DEF_CASE(GPIO25), DEF_CASE(GPIO26), DEF_CASE(GPIO27), DEF_CASE(GPIO32), DEF_CASE(GPIO33) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st_thingjs_interface_manifest</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> = {</span></span> .type = <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, .constructor = thingjsBitPortConstructor, .cases = thingjs_bit_port_cases }; thingjsRegisterInterface(&amp;interface); }</code> </pre> <br><p>  La función thingjsBitPortRegister registra un componente en el núcleo ThingJS.  Para hacer esto, llama a la función thingjsRegisterInterface, a la que pasa una estructura con una descripción de interfaz. </p><br><ul><li>  <strong>tipo</strong> : identificador de interfaz.  Es él quien se especifica como el tipo en el archivo manifest.json de la aplicación; </li><li>  <strong>constructor</strong> : enlace al constructor de la interfaz.  Se llama a la función cada vez que necesita crear una nueva instancia de la interfaz; </li><li>  <strong>cases</strong> es una matriz que describe los posibles recursos de hardware que la interfaz puede usar para su trabajo.  En este caso, estos son GPIO individuales.  Pero sus combinaciones o dependencias pueden describirse por separado. </li></ul><br><p>  El constructor de la interfaz monta la interfaz en la máquina mJS. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mjs_val_t</span></span> thingjsBitPortConstructor(struct mjs *mjs, cJSON *params) { <span class="hljs-comment"><span class="hljs-comment">//Validate preset params //The params must have pin number if (!cJSON_IsNumber(params)) return MJS_UNDEFINED; //Get pin number gpio_num_t gpio = params-&gt;valueint; //Create mjs object mjs_val_t interface = mjs_mk_object(mjs); /* Configure the IOMUX register for pad BLINK_GPIO (some pads are muxed to GPIO on reset already, but some default to other functions and need to be switched to GPIO. Consult the Technical Reference for a list of pads and their default functions.) */ gpio_pad_select_gpio(gpio); //Add protected property to interface mjs_set(mjs, interface, "gpio", ~0, mjs_mk_number(mjs, gpio)); //Set protected flag mjs_set_protected(mjs, interface, "gpio", ~0, true); //Bind functions mjs_set(mjs, interface, "set", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortSet)); mjs_set(mjs, interface, "get", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortGet)); mjs_set(mjs, interface, "direction", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortDirection)); //Consts mjs_set(mjs, interface, "DIR_MODE_DISABLE", ~0, mjs_mk_number(mjs, GPIO_MODE_DISABLE)); mjs_set(mjs, interface, "DIR_MODE_DEF_INPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_INPUT)); mjs_set(mjs, interface, "DIR_MODE_DEF_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_OUTPUT)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT_OD", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT_OD)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT)); //Return mJS interface object return interface; }</span></span></code> </pre> <br><p>  Cómo se pasan los parámetros: </p><br><ul><li>  <strong>mjs</strong> : contexto de ejecución global; </li><li>  <strong>params</strong> : parámetros de inicialización de la interfaz.  En este caso, este es el número GPIO. </li></ul><br><p>  Se crea un objeto de "interfaz" mJS, donde se montan los métodos y propiedades de la interfaz: </p><br><ul><li>  <strong>gpio</strong> : propiedad de solo lectura en la que se almacena el número de GPIO utilizados; </li><li>  <strong>set</strong> - método para configurar el nivel de señal; </li><li>  <strong>get</strong> : un método para obtener el nivel de señal actual; </li><li>  <strong>dirección</strong> : configuración del modo GPIO; </li></ul><br><p>  Además, se montan constantes con las que pueden operar los scripts (DIR_MODE_DISABLE, DIR_MODE_DEF_INPUT, etc.). </p><br><p>  Después de crear la interfaz, se monta bajo un identificador específico (en el ejemplo de Blink es "blink") en el objeto global $ res.  Se puede encontrar un ejemplo de uso en la sección Blink ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">scripts / blink.js</a> ). </p><br><p>  Puede formatear interfaces en componentes o paquetes separados.  Esto te permitirá ensamblar el firmware como lego. </p><br><h1 id="sreda-razrabotki-anchordevanchor">  Entorno de desarrollo <a name="dev"></a></h1><br><h2 id="razrabotka-prilozheniy-anchordev-appanchor">  Desarrollo de aplicaciones <a name="dev-app"></a></h2><br><p>  El entorno de desarrollo de aplicaciones se basa en VUE CLI, que se ha perfeccionado para satisfacer las necesidades de la plataforma ThingJS.  Este es un tenedor duro, incl.  Vale la pena esperar las nuevas funciones de VUE CLI si facilitan directamente la vida. </p><br><p>  Para implementar el entorno, debe clonar el proyecto de lanzamiento alfa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ThingJS-front</a> .  Asegúrese de que ya tiene instalados git, npm y nodejs. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install</code> </pre> <br><p>  Al desarrollar, recomiendo usar la IDE WEBStorm. </p><br><p>  La composición y estructura del proyecto se hereda de VUE CLI.  Reflejaré diferencias significativas: </p><br><ol><li>  Se modificaron los scripts de compilación en la carpeta de compilación. </li><li>  Se ha agregado una variable de entorno "HW_DEVICE_URL" a la configuración del entorno de desarrollo (config / dev.env.js).  Es necesario especificar un enlace al dispositivo físico con el que trabajará. </li><li>  Ha aparecido la carpeta del sistema src / aplicaciones.  Contiene aplicaciones que se construirán automáticamente.  En particular, contiene dos aplicaciones: ante (lanzador) y blink (aplicación). </li><li>  Todo lo que está encima de la carpeta src / aplicaciones se considera módulos y recursos de la plataforma.  Por supuesto, puede hacer cambios en ellos, pero en este caso, aparecerán en el controlador solo después de flashearlo.  T.ch.  A menos que establezca objetivos específicamente para usted, es mejor no tocarlos. </li></ol><br><p>  Para las pruebas, puede iniciar inmediatamente el servidor de desarrollo.  Aunque no puede desarrollarse completamente sin el hardware físico, esto no interfiere con el desarrollo de la interfaz.  Y así, el servidor de desarrollo comienza: </p><br><pre> <code class="bash hljs">npm run dev</code> </pre> <br><p>  El resultado debería ser algo como esto: </p><br><p><img src="https://habrastorage.org/webt/c2/ku/if/c2kuifxxfz1ppogv-_50rp7wtuo.png"></p><br><p>  Al abrir el navegador e ingresar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://0.0.0.0:8080</a> en la barra de direcciones, verá la plataforma en modo de desarrollo: </p><br><p><img src="https://habrastorage.org/webt/no/cv/ax/nocvaxx5-kdjtvy0x7i5_jfvcbg.png"></p><br><p>  El proceso de desarrollo de la interfaz en sí no es muy diferente del clásico desarrollo front-end en VUE.  Excepto que hay objetos de plataforma global que debe tener en cuenta: </p><br><ul><li>  <strong>$ const</strong> - contiene constantes de plataforma, así como paquetes de idiomas; </li><li>  <strong>$ bus</strong> - bus de datos; </li><li>  <strong>$ store</strong> - almacenamiento global (VUEX). <br>  De los ejemplos puedes entender cómo usarlos. </li></ul><br><p>  El multilingüismo se implementa de la manera más simple: a través del filtro "lang".  Especifique un idioma constante, se interpreta en texto dependiendo del idioma de la interfaz. </p><br><pre> <code class="xml hljs">v-bind:label="'BLINK_SATE' | lang"</code> </pre> <br><p>  Para evaluar completamente las capacidades del entorno de desarrollo, necesitará un controlador preparado (cosido).  Puede ensamblar el firmware usted mismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde el proyecto</a> o usar el firmware y la utilidad listos para usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desde aquí</a> . </p><br><p>  Después de flashear el controlador y conectarse a la red, debe asegurarse de que el controlador sea accesible a través de IP desde su computadora.  Para hacer esto, escriba <a href="">http: // [IP del</a> controlador] en el navegador.  La interfaz WEB debería abrirse. </p><br><p>  Ahora debe especificar la dirección del controlador en el archivo config / dev.env.js </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> merge = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-merge'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prodEnv = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./prod.env'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = merge(prodEnv, { <span class="hljs-attr"><span class="hljs-attr">NODE_ENV</span></span>: <span class="hljs-string"><span class="hljs-string">'"development"'</span></span>, <span class="hljs-attr"><span class="hljs-attr">HW_DEVICE_URL</span></span>: <span class="hljs-string"><span class="hljs-string">'"http://[IP ]"'</span></span> <span class="hljs-comment"><span class="hljs-comment">//HW_DEVICE_URL: '"http://192.168.8.105"', //HW_DEVICE_URL: '"http://192.168.4.1"', })</span></span></code> </pre> <br><p>  Si se inició el servidor de desarrollo, deténgalo y reinícielo.  En el futuro, después de cambiar los archivos de compilación, la configuración y el manifiesto de la aplicación, siempre reinicie el servidor de desarrollo. </p><br><p>  Aunque cuando se trabaja en un entorno de desarrollo, se muestran todas las aplicaciones que están instaladas en la carpeta src / application, solo aquellas que realmente están instaladas en el controlador funcionarán completamente.  Esta no es una característica, sino un error alfa.  En el futuro, la sincronización del hardware y el entorno de desarrollo se realizará automáticamente.  Pero por ahora, necesita instalar manualmente la aplicación en el controlador para que el entorno la "enganche" y la sincronice con lo que está en desarrollo. </p><br><p>  Ensamblamos la aplicación en modo prod: </p><br><pre> <code class="bash hljs">npm run prod</code> </pre> <br><p>  Instale las aplicaciones recopiladas en el controlador directamente.  <u><strong>No a través del servidor de desarrollo</strong></u> . </p><br><p>  Ahora puedes comenzar el desarrollo.  Cualquier cambio que realice en sus archivos comenzará automáticamente a reconstruir las aplicaciones y la imagen en la pantalla cambiará (recarga en caliente).  La misma regla se aplica a los scripts del controlador.  Por ejemplo, puede agregar el comando depurador a la secuencia de comandos de la aplicación de parpadeo y ver el resultado. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { debugger; active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Ahora, cuando cambia el estado de la casilla de verificación de la aplicación Blink, el entorno de desarrollo arrojará el siguiente mensaje: </p><br><p><img src="https://habrastorage.org/webt/bj/lw/qg/bjlwqgwrzgutdhi0vr2oed_cuee.png"></p><br><p>  Al hacer clic en el enlace "Iniciar depurador", accederá al depurador.  Se muestra la línea en la que ocurrió la parada. </p><br><p><img src="https://habrastorage.org/webt/m7/8u/3e/m78u3etl9hleirs072xjgpye_rw.png"></p><br><p>  El proceso de depuración en sí no es muy diferente de otros depuradores. </p><br><p><img src="https://habrastorage.org/webt/0m/i_/nt/0mi_nt0gx_-e-7nnvrrtdhxb9kg.png"></p><br><p>  El depurador se divide en cuatro secciones.  En el código central en sí.  Dejó aplicaciones instaladas en el controlador.  Su estructura y composición.  Correcto, inspector.  El registro se muestra a continuación.  En la parte inferior izquierda se encuentra el estado actual de la comunicación con el controlador. </p><br><p>  El entorno de depuración está en proceso de desarrollo intensivo.  Hay muchas más herramientas de monitoreo y depuración para construir.  Pido disculpas de antemano por posibles errores. </p><br><h2 id="razrabotka-proshivki-anchordev-firmwareanchor">  Desarrollo de firmware <a name="dev-firmware"></a></h2><br><p>  El desarrollo del firmware se basa en el concepto propuesto por Espressif.  No puedo superar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación nativa</a> a este respecto. </p><br><p>  Se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha</a> preparado un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> para un inicio rápido.  Contiene información de implementación.  Para ver un ejemplo de uso, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Implementación de una interfaz"</a> . </p><br><p>  El ensamblaje es muy simple y, literalmente, en 1-2 horas ya estará ensamblando el firmware sin ningún problema. </p><br><h1 id="chto-dalshe-anchorwhat-afteranchor">  Que sigue <a name="what-after"></a></h1><br><p>  Además, si la plataforma es de interés para la comunidad, se planifica: </p><br><ul><li>  Desarrollo de un entorno de depuración; </li><li>  Estandarización de nombres de interfaces, eventos, componentes; </li><li>  Documentación detallada en la plataforma; </li><li>  Alojamiento en la nube para cosas virtuales; </li><li>  Repositorios de tiempo de ejecución </li><li>  Particionamiento a varios dispositivos terminados. </li></ul><br><p>  Además, estoy buscando personas que deseen desarrollar la plataforma conmigo.  Ya es muy grande en alcance y ambición.  Asumo la misma cooperación, cuyo propósito será desarrollar la plataforma para un principio OpenSource completo. </p><br><p>        pull-     . </p><br><h1 id="ssylki-anchorrefsanchor">  Referencias <a name="refs"></a></h1><br><p>   ThingJS: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sitio</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> </li></ul><br><p>   ThingJS: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">    </a> </li></ul><br><p>  : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ESP32</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esp-idf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mongoose WEB Server</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mJS</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vue 2</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vuetifyjs</a> </li></ul><br><h1 id="faq-anchorfaqanchor">  FAQ <a name="faq"></a></h1><br><p>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474356/">https://habr.com/ru/post/474356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474342/index.html">Acelerar escenas en un video usando una vista de tabla</a></li>
<li><a href="../474344/index.html">Internet de las cosas en la industria: ¿Cómo funcionan las plantas inteligentes?</a></li>
<li><a href="../474346/index.html">Desarrollo de Docker en el subsistema de Windows para Linux (WSL)</a></li>
<li><a href="../474352/index.html">Destrucción de enemigos por un salto, como en "Mario" Unity 2D</a></li>
<li><a href="../474354/index.html">Hogar inteligente en contenedores (ioBroker + Zigbee en Docker)</a></li>
<li><a href="../474358/index.html">Duerma lo suficiente el fin de semana: cómo el ruido blanco ayuda a los adultos a relajarse y controla la calidad del sueño de los niños</a></li>
<li><a href="../474360/index.html">Mejora tu CSS con estos 5 principios.</a></li>
<li><a href="../474364/index.html">Desarrollo de electrónica. Una revisión subjetiva de los sensores integrados más útiles.</a></li>
<li><a href="../474366/index.html">Eventos digitales en Moscú del 4 al 10 de noviembre.</a></li>
<li><a href="../474368/index.html">Sinopsis del aprendizaje automático. Teoría de la probabilidad. Fórmula de Bayes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>