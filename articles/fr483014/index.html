<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💢 🥟 🧘🏾 Files d'attente de messages PostgreSQL utilisant PgQ 📦 👨‍❤️‍👨 ⛹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les files d'attente de messages sont utilisées pour effectuer: opérations en attente, interaction entre services, «traitement par lots», etc. Il exist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Files d'attente de messages PostgreSQL utilisant PgQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483014/"><img src="https://habrastorage.org/webt/g4/5g/b1/g45gb1ef-etyywuggdsyiyr-lyk.jpeg"><br><br>  Les files d'attente de messages sont utilisées pour effectuer: opérations en attente, interaction entre services, «traitement par lots», etc.  Il existe des solutions spécialisées pour organiser de telles files d'attente, telles que: RabbitMQ, ActiveMQ, ZeroMQ, etc., mais il arrive souvent qu'elles ne soient pas d'un grand besoin, et leur installation et leur support causeront plus de douleur et de souffrance qu'elles n'en apporteront d'avantages.  Supposons que vous ayez un service lors de votre inscription dans lequel un e-mail est envoyé à l'utilisateur pour confirmation, et si vous utilisez Postgres, alors vous avez de la chance - dans Postgres, presque prêt à l'emploi, il existe une extension PgQ qui fera tout le sale boulot pour vous. <br><br>  Dans cet article, je parlerai de la mise en file d'attente des messages (tâches) dans PostgreSQL en utilisant l'extension PgQ.  Cet article sera utile si vous n'avez pas utilisé PgQ ou utilisez des files d'attente auto-écrites au-dessus de Postgres. <br><br>  Pourquoi avez-vous besoin de PgQ, si vous pouvez simplement créer une tablette et y écrire des tâches?  Cela semble possible, mais vous devrez prendre en compte l'accès parallèle aux tâches, les erreurs possibles (que se passera-t-il si le processus de traitement de la tâche tombe?), Ainsi que les performances (PgQ est très rapide, et les solutions auto-écrites ne le sont généralement pas, surtout si la transaction est en la base de données ne se ferme pas pendant toute l'exécution de la tâche), mais la raison la plus importante à mon avis pour laquelle il est nécessaire d'utiliser PgQ est que PgQ est déjà écrit et fonctionne, et la solution auto-écrite doit encore être écrite (UPD: pourquoi cela ne vaut pas la peine d'utiliser des files d'attente auto-écrites , vous pouvez lire, par exemple, <a href="https://habr.com/ru/company/oleg-bunin/blog/455248/">ici</a> ). <br>  (UPD: puisque PgQ s'exécute au-dessus de Postgres, tous les plaisirs des transactions peuvent également y être utilisés) <br><br>  Mais PgQ a un énorme inconvénient - le manque de documentation, j'essaie de compenser cette lacune avec cet article. <br><a name="habracut"></a><br><h4>  Périphérique </h4><br>  PgQ se compose de parties (au moins 2): 1 - extension pgq pour postgres, 2 - démon pgqd (pour les installer un peu plus tard). <br><br>  Toutes les interactions avec la file d'attente sont effectuées à l'aide de fonctions à l'intérieur de Postgres. <br><br>  Par exemple, pour créer une file d'attente, vous devez exécuter <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.create_queue({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>);</code> </pre> <br>  Une fois la file d'attente créée, vous pouvez y ajouter des messages. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.insert_event({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, {  } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>);</code> </pre> <br>  Maintenant, nous devons apprendre à recevoir des messages enregistrés.  Pour cela, il existe une entité telle que «consommateur» (j'écrirai un consommateur), qui reçoit non pas des messages (événements), mais «batch» (batch).  Un bach est un groupe de messages consécutifs, les baches sont créés à l'aide de pgqd.  Périodiquement (le paramètre «ticker_period» dans le fichier de configuration) pgqd prend tous les messages accumulés et écrit dans un nouveau bach.  <b>Il est important</b> que pgqd ne fonctionne pas, alors de nouveaux bachs ne sont pas créés, ce qui signifie que les consommateurs n'ont rien à lire, également si pgqd n'a pas fonctionné pendant une longue période puis allumé, il créera un gros bach à partir des messages accumulés pendant ce temps, donc pgqd ne devrait pas être il suffit de l'éteindre. <br><br>  Enregistrement d'un consommateur ( <b>Important! Un</b> consommateur ne recevra des événements enregistrés <b>qu'après</b> son enregistrement, vous devez donc d'abord créer un consommateur, puis écrire des événements uniquement): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.register_consumer({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>);</code> </pre> <br>  <i>(similaire à pgq.unregister_consumer)</i> <br>  Chaque consommateur recevra <b>absolument tous les événements</b> survenus après sa création (même traités par un autre consommateur), ce qui signifie que vous n'avez probablement besoin que d'un seul consommateur pour un tour.  Ensuite, je vais vous dire comment répartir la charge sur plusieurs serveurs. <br><br>  Pour obtenir un bach, vous devez d'abord trouver son ID: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.next_batch({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>);</code> </pre> <br>  La fonction peut retourner NULL si le consommateur a traité tous les bachs.  Dans ce cas, il vous suffit d'attendre que pgqd crée un nouveau bach. <br><br>  Dans ce cas, alors que le bach n'est pas traité, cette fonction retournera la même valeur. <br>  Vous pouvez obtenir tous les événements du lot en utilisant: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.get_batch_events({<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>);</code> </pre> <br>  (Le bach est peut-être vide.) <br><br>  Si une erreur s'est produite lors du traitement de l'un d'eux, vous pouvez essayer de traiter cet événement ultérieurement: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.event_retry({<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, {<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, {   } <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>);</code> </pre> <br>  Pour informer sur la fin du bach et avoir l'opportunité d'en démarrer un nouveau, il est utilisé <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq.finish_batch({<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>);</code> </pre> <br>  Bien sûr, ce ne sont pas toutes les fonctions de l'extension, je recommande de lire <a href="https://pgq.github.io/extension/pgq/files/external-sql.html" rel="nofollow">pgq.github.io/extension/pgq/files/external-sql.html</a> et <a href="https://github.com/pgq/pgq/tree/master/functions" rel="nofollow">github.com/pgq/pgq/tree/master/functions</a> (chaque fichier contient une définition et une description fonction correspondante). <br><br><h4>  Partage de charge </h4><br>  Afin de gérer les événements simultanément par plusieurs gestionnaires, il existe l'extension pgq_coop, qui fonctionne comme pgq et ajoute une nouvelle entité appelée «sous-consommateur», qui recevra tous les événements à partir du moment de l'enregistrement du consommateur parent, bien sûr, à l'exception de ceux déjà traités. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq_coop.register_subconsumer({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>);</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq_coop.next_batch({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>);</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq_coop.next_batch({ } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, { } <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, {        ,      } <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span>);</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgq_coop.finish_batch({<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>);</code> </pre> <br>  Découvrez toutes les fonctionnalités <a href="https://github.com/pgq/pgq-coop/tree/master/functions" rel="nofollow">ici</a> . <br><br><h4>  L'installation </h4><br>  L'extension pgq et le démon pgqd sont inclus dans les référentiels PGDG et sont installés très simplement dans la plupart des distributions, par exemple dans Debian: <br><br>  <code>sudo apt install postgresql-XX-pgq3 pgqd</code> (XX est le numéro de version). <br><br>  pgqd est un petit programme que vous pouvez découvrir sur l'utilisation de <code>pgqd --help</code> , n'oubliez pas de l'ajouter à l' <code>sudo systemctl enable pgqd.service</code> automatique ( <code>sudo systemctl enable pgqd.service</code> , et la configuration par défaut est <code>/etc/pgqd.ini</code> ). <br><br>  Pour commencer à utiliser PgQ, dans la base de données il vous suffit de connecter l'extension: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> extension <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> pgq;</code> </pre> <br><br>  Avec pgq_coop, tout est un peu plus compliqué, ce n'est pas dans le dépôt, mais ce n'est pas difficile de le compiler à partir des sources (exemple pour Debian): <br><br><pre> <code class="plaintext hljs">sudo apt install postgresql-server-dev-XX git clone https://github.com/pgq/pgq-coop.git cd pgq-coop sudo make install</code> </pre><br>  et connectez l'extension à l'aide <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> extension <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> pgq_coop;</code> </pre> <br><h4>  Liens utiles </h4><br>  <a href="https://pgq.github.io/extension/pgq/files/external-sql.html" rel="nofollow">Documentation PGQ</a> <br>  <a href="https://github.com/pgq/pgq/tree/master/functions" rel="nofollow">Fonctions Pgq</a> <br>  <a href="https://github.com/pgq/pgq-coop/tree/master/functions" rel="nofollow">Fonctions Pgq_coop</a> <br>  <a href="https://github.com/pgq/pgqd" rel="nofollow">Code source pgqd</a> <br>  <a href="https://github.com/pgq" rel="nofollow">compte github avec tous les projets associés</a> <br>  <a href="https://wiki.postgresql.org/wiki/PGQ_Tutorial" rel="nofollow">Postgres wiki</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483014/">https://habr.com/ru/post/fr483014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482998/index.html">Nouvelles du monde d'OpenStreetMap n ° 492 (17/12/2019 - 23/12/2019)</a></li>
<li><a href="../fr483000/index.html">La position officielle de Telegram concernant la blockchain TON</a></li>
<li><a href="../fr483004/index.html">Effet Kuleshov dans Disco Elysium: comment le contexte crée du sens</a></li>
<li><a href="../fr483008/index.html">Un autre avenir - une scission de l'humanité</a></li>
<li><a href="../fr483012/index.html">Antiquités: Roland MT-32, un son alternatif pour les jeux DOS</a></li>
<li><a href="../fr483016/index.html">Une brève histoire des microprocesseurs spatiaux, deuxième partie</a></li>
<li><a href="../fr483018/index.html">Mask-R CNN du débutant au professionnel</a></li>
<li><a href="../fr483024/index.html">«Qu'est-ce que les entreprises ont fait avec votre vie privée?», Arthur Khachuyan (Tazeros Global)</a></li>
<li><a href="../fr483026/index.html">Java / Spring: comment générer complètement une API CRUD REST à l'aide de Speedment</a></li>
<li><a href="../fr483030/index.html">API qui vous fait pleurer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>