<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏭 ⚕️ 👨🏽‍🚒 Entwicklung eines Debugboards für K1986BE1QI (Air) 📚 📝 ⛵️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Jahren habe ich mich mit den russischen Mikrocontrollern von Milander getroffen. Es war 2013, als die Ingenieure die ersten Ergebnisse des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines Debugboards für K1986BE1QI (Air)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482716/"><img src="https://habrastorage.org/webt/xa/8d/4m/xa8d4m3m5jgwavt_34l7oj8abfi.jpeg" alt="Debug Board MDB1986"><br><br>  Vor einigen Jahren habe ich mich mit den russischen Mikrocontrollern von Milander getroffen.  Es war 2013, als die Ingenieure die ersten Ergebnisse des Bundeszielprogramms "Entwicklung der Basis elektronischer Komponenten und der Funkelektronik" für 2008-2015 heftig diskutierten.  Zu diesem Zeitpunkt war der K1986BE9x-Controller (Cortex-M3-Core) bereits freigegeben, und der 1986BE1T-Controller (Cortex-M1-Core) ist gerade erschienen.  Er hatte im Kunststoffkoffer LQFP-144 die Bezeichnung K1986BE1QI (avia) und auf dem Chip selbst die Bezeichnung MDR32F1QI.  Auf der Website des Herstellers hat er das Suffix "avia", da es spezifische Schnittstellen für die Luftfahrtindustrie hat (ARINC 429, MIL_STD_1553). <a name="habracut"></a><br><br>  Überraschenderweise erstellte die Firma Milander zum Zeitpunkt der Verteilung dieser Steuerungen Debugging-Kits und eine Bibliothek mit Unterprogrammen für die Arbeit mit Peripheriegeräten, „jedoch ohne zusätzliche Garantien und Verpflichtungen hinsichtlich der Korrektheit der Bibliothek“.  Die Bibliothek ähnelt der STMicroelectronics Standard Peripheral Library.  Im Allgemeinen haben alle ARM-Controller, die auf dem Cortex-M-Kern basieren, viel gemeinsam.  Aus diesem Grund ging die Bekanntschaft mit den neuen russischen Controllern schnell.  Und für diejenigen, die gebrandete Debugging-Kits gekauft haben, wurde während des Gebrauchs technischer Support bereitgestellt. <br><br><img src="https://habrastorage.org/webt/36/-5/cu/36-5cuhduqbdylqea5diodzri2o.png"><br>  <i>Debug-Kit für den Mikrocontroller 1986BE1T, © Milander</i> <br><br>  Im Laufe der Zeit traten jedoch „Kinderkrankheiten“ neuer Mikroschaltungen und Bibliotheken auf.  Testbeispiele für Firmware funktionierten ohne sichtbare Probleme, aber mit einer signifikanten Modifikation regneten Abstürze und Fehler.  Das erste "Schlucken" in meiner Praxis waren ungeklärte Betriebsstörungen des CAN-Controllers.  Ein Jahr später, auf dem 1986BE1T (Air) Early Audit Controller, wurde ein Problem mit dem <a href="https://ru.wikipedia.org/wiki/MIL-STD-1553" rel="nofollow">MKIO-</a> Modul <a href="https://ru.wikipedia.org/wiki/MIL-STD-1553" rel="nofollow">(Multiplexed Information Exchange Channel)</a> festgestellt.  Im Allgemeinen waren alle Revisionen dieser Mikrocontroller bis 2016 von begrenztem Nutzen.  Es hat viel Zeit und Nerven gekostet, diese Probleme zu identifizieren, deren Bestätigung nun in den <a href="https://ic.milandr.ru/upload/iblock/352/352a1573c08c406a94b976ed95fe4506.pdf" rel="nofollow">Fehlerlisten (Errata) zu finden ist</a> . <br><br>  Unangenehm war, dass nicht auf den Debug-Boards, sondern auf den Prototyp-Boards der für die Serienproduktion geplanten Geräte gearbeitet und mit Fehlern umgegangen werden musste.  Außer dem JTAG-Anschluss war normalerweise nichts vorhanden.  Das Anschließen an einen Logikanalysator war schwierig und unbequem, und normalerweise gab es keine LEDs oder Bildschirme.  Aus diesem Grund habe ich darüber nachgedacht, ein eigenes Debug-Board zu erstellen. <br><br>  Einerseits gab es gebrandete Debugging-Kits auf dem Markt sowie wunderbare Boards von LDM-Systems aus Zelenograd.  Andererseits sind die Preise für diese Produkte ins Wanken geraten, und die Grundfunktionalität ohne Erweiterungskarten entspricht nicht den Erwartungen.  Eine Platine mit einem gelöteten Controller und einer Stiftleiste interessiert mich nicht.  Und interessantere Boards sind teuer. <br><br><img src="https://habrastorage.org/webt/6u/ob/ww/6uobww_tvc36dmyyhcmemgkedhg.jpeg"><br>  <i>Debug-Board MILANDR LDM-HELPER-K1986BE1QI-FULL, © LDM Systems</i> <br><br>  Das Unternehmen "Milander" Preisgestaltung und Marketing sind eigenartig.  So ist es möglich, kostenlose Muster einiger Mikroschaltungen zu erhalten, aber dies steht nur juristischen Personen zur Verfügung und ist mit einem bürokratischen Auftrag verbunden.  Im Allgemeinen sind Mikroschaltungen in einem Metall-Keramik-Gehäuse im direkten und im übertragenen Sinne Gold.  Zum Beispiel kostet der 1986BE1T-Controller in Moskau 14 bis 24 Tausend Rubel.  Der statische Speicherchip 1645RU6U kostet ab 15.000 Rubel.  Und eine solche Reihenfolge der Preise für alle Produkte.  Dadurch sparen und scheuen auch spezialisierte Forschungsinstitute mit staatlichen Aufträgen solche Preise.  Mikroschaltungen in einer Kunststoffhülle für den zivilen Einsatz sind deutlich günstiger, aber bei gängigen Anbietern nicht erhältlich.  Außerdem scheint mir die Qualität von Mikroschaltkreisen in einem Kunststoffgehäuse schlechter zu sein als die von „Gold“.  Zum Beispiel konnte ich den K1986BE1QI-Controller nicht mit einer Frequenz von 128 MHz starten, ohne den Parameter für die Flash-Latenz zu erhöhen.  Gleichzeitig stieg die Temperatur dieses Reglers auf 40-50 ° C.  Der Controller 1986BE1T ("gold") wurde jedoch ohne zusätzliche Einstellungen mit 128 MHz gestartet und blieb kalt.  Er ist wirklich gut <br><br><img src="https://habrastorage.org/webt/hm/hd/vm/hmhdvmzvhpvw7ujz09cw5ol49ou.png"><br>  <i>"Goldener" Mikrocontroller 1986BE1T, (c) Milander</i> <br><br>  Ich hatte das Glück, dass ein Mikrocontroller in einem Kunststoffgehäuse noch im Einzelhandel bei LDM Systems erhältlich ist und alle Leiterplatten frei verfügbar sind.  Das Schlimme ist, dass sich auf der Seite auf dem Foto des Controllers eine Markierung befindet, die besagt, dass dies die 4. Revision von 2014 ist, d. H.  mit Mängeln.  Ich habe lange überlegt - zu kaufen oder nicht zu kaufen.  So vergingen mehrere Jahre ... <hr><br><br>  Die Idee, ein Debug-Board zu erstellen, ist nicht verschwunden.  Allmählich formulierte ich alle Anforderungen und überlegte, wie ich das alles auf ein Board packen sollte, damit es kompakt und nicht teuer wäre.  Parallel dazu habe ich die fehlenden Teile bei den Chinesen bestellt.  Ich hatte es nicht eilig - ich habe alles für mich getan.  Chinesische Lieferanten sind berühmt für Schlamperei - ich musste dasselbe an verschiedenen Orten bestellen, um alles zu bekommen, was ich brauchte.  Darüber hinaus stellte sich heraus, dass einige der Speichermikroschaltungen in Gebrauch waren - offensichtlich verdampft von defekten Geräten.  Dies kam später zu mir zurück. <br><br>  Einen Mikrocontroller Milander K1986BE1QI (avia) zu kaufen, ist keine leichte Aufgabe.  Im selben Chip and Dip-Geschäft habe ich im Bereich "Bestellartikel" nur den K1986BE92QI für 740 Rubel gefunden, der mir jedoch nicht zusagte.  Die einzige Möglichkeit ist, bei LDM-Systems für 2.000 Rubel keine neue Revision zu kaufen.  Da ich nirgendwo anders Ersatz finden konnte, habe ich mich für den Kauf entschieden.  Zu meiner angenehmen Überraschung verkauften sie mir einen brandneuen Release-Controller für Dezember 2018, Revision 6+ (1820).  Und die Seite hat noch ein altes Foto und zum Zeitpunkt des Schreibens ist der Controller nicht verfügbar ... <br><br><img src="https://habrastorage.org/webt/cr/p3/eu/crp3euoxhtfbkqo_pzet4vjencs.jpeg"><br>  <i>Mikrocontroller K1986BE1QI (Avia) in technologischen Verpackungen (c) - Foto von</i> <br><br>  Die wichtigsten technischen Daten meiner <b>MDB1986-</b> Debug- <b>Karte lauten</b> wie folgt: <br><br><ul><li>  eingebauter Debugger-Programmierer, kompatibel mit J-Link und CMSIS-DAP; </li><li>  4 Mbit statischer Speicher (256 kx 16, 10 ns); </li><li>  64 MBit Flash-Speicherchip, Winbond 25Q64FVSIG; </li><li>  RS-232-Schnittstellentransceiver mit RTS- und CTS-Leitungen; </li><li>  Schnittstellen und Anschlüsse für Ethernet, USB, CAN; </li><li>  MAX7221 7-Segment-Display-Controller </li><li>  Pin-Anschluss für die Arbeit mit MKIO (MIL_STD_1553) und ARINC429; </li><li>  Everlight PT17-21C Fototransistor; </li><li>  fünf farbige LEDs, eine Rücksetztaste und zwei Benutzertasten; </li><li>  Stromversorgung über USB-Anschluss 5 Volt; </li><li>  Leiterplattenabmessungen 100 x 80 mm </li></ul><br>  Ich mochte die Boards der STM-Discovery-Serie, weil es einen integrierten Debugger-Programmierer gibt - ST-Link.  Die Marke ST-Link funktioniert nur mit Steuerungen von STMicroelectronics. Vor einigen Jahren war es jedoch möglich, die Firmware in ST-Link zu aktualisieren und einen SEGGER J-Link OB (On-Board) -Debugger zu erhalten.  Rechtlich ist die Verwendung eines solchen Debuggers nur für STMicroelectronics-Boards beschränkt, tatsächlich ist das Potenzial jedoch nicht begrenzt.  Mit einem J-Link-OB können Sie also einen integrierten Debugger auf der Debug-Karte haben.  Ich stelle fest, dass in den Produkten von "LDM-Systems" der Konverter CP2102 (Usb2Uart) verwendet wird, der nur flashen kann. <br><br><img src="https://habrastorage.org/webt/fq/yd/6z/fqyd6z1yxuwig0mw46du7l0pu8y.jpeg"><br>  <i>Mikrocontroller STM32F103C8T6, real und nicht real, (c) Foto von</i> <br><br>  Daher musste das Original STM32F103C8T6 gekauft werden, da die proprietäre Firmware mit dem Klon nicht ordnungsgemäß funktioniert.  Ich bezweifelte diese These und entschloss mich, den CS32F103C8T6-Controller der chinesischen Firma CKS in Betrieb zu nehmen.  Ich habe keine Beschwerden über den Controller selbst, aber die Firmware ST-Link hat nicht funktioniert.  J-Link funktionierte teilweise - das USB-Gerät wurde erkannt, aber der Programmierer führte seine Funktionen nicht aus und erinnerte ständig daran, dass es "defekt" war. <br><br><img src="https://habrastorage.org/webt/sh/dp/zs/shdpzs1rrvs4ndpodfxgykmxoqk.png"><br>  <i>Fehler beim Arbeiten mit dem Debugger auf einem nicht originalen Controller</i> <br><br>  Ich habe mich nicht beruhigt und habe zuerst die Firmware für das Blinken der LED geschrieben und dann die IDCODE-Anforderung mithilfe des JTAG-Protokolls realisiert.  Der ST-Link-Programmierer, den ich auf der Discovery-Karte hatte, und das ST-Link-Hilfsprogramm haben CS32F103C8T6 ohne Probleme geflasht. Als Ergebnis habe ich sichergestellt, dass meine Karte funktioniert.  Zu meiner Freude hat der Zielcontroller K1986BE1QI (avia) fröhlich seinen IDCODE über die TDO-Leitung ausgegeben. <br><br><img src="https://habrastorage.org/webt/mg/cd/6b/mgcd6bodfiolhoncf0dqpy_ztyi.png"><br>  <i>Oszillogramm der TDO-Signalleitung mit codierter IDCODE-Antwort, (c) - Foto von</i> <br><br><img src="https://habrastorage.org/webt/ls/9b/hk/ls9bhkuow-fz1gir-e48kwyld2i.png"><br>  <i>Der SWD-Port war also praktisch, um den Debugger selbst zu debuggen und IDCODE zu überprüfen</i> <br><br>  Es gab eine Variante mit dem <a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html" rel="nofollow">CMSIS-DAP-</a> Debugger <a href="https://arm-software.github.io/CMSIS_5/DAP/html/index.html" rel="nofollow">(Debug Access Port)</a> .  Es ist keine leichte Aufgabe, ein Projekt aus dem Quellcode von ARM zu erstellen. Ich habe das Projekt von <a href="https://habr.com/ru/users/x893/" class="user_link">X893 übernommen</a> und dann DAP42 ausprobiert.  Leider hat Keil uVision aufgelegt und wollte nicht mit ihnen arbeiten.  Infolgedessen habe ich den Debugger-Chip durch den proprietären STM32F103C8T6 ersetzt und bin nicht mehr auf dieses Problem zurückgekommen. <br><br><img src="https://habrastorage.org/webt/qd/ry/fs/qdryfsbagp3hggtvmrl0tiym-dg.png"><br>  <i>Erfolgreicher J-Link STLink V2 Debugger</i> <br><br>  Als alle wichtigen Komponenten des zukünftigen Debug-Boards vorrätig waren, stieg ich in Eagle CAD ein und stellte fest, dass sie nicht in der Elementbibliothek enthalten waren.  Nirgendwo hin - sie mussten sich selbst malen.  Gleichzeitig habe ich Speicherabdrücke und HanRun-Anschlüsse für Ethernet erstellt und Rahmen für Widerstände und Kondensatoren hinzugefügt.  Die Projektdatei und die Komponentenbibliothek befinden sich <a href="https://github.com/makbit/MDB1986" rel="nofollow">auf meinem GitHub</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Schematische Darstellung der Debug-Karte MDB1986</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hx/44/jy/hx44jyp0pkskpjgb1zh-1tf6hfu.png"></div></div><br><br>  Die Platine wird von einer 5-Volt-Gleichstromquelle gespeist, die über den USB-Anschluss bezogen wird.  Auf der Karte befinden sich zwei USB-Anschlüsse vom Typ B.  Eine ist für den Programmierer, die zweite für den K1986BE1QI-Controller.  Das Board kann aus jeder dieser Quellen oder mit beiden gleichzeitig arbeiten.  Die einfachste Laststeuerung und der einfachste Schutz von Stromleitungen sind bei Schottky-Dioden in den Schaltkreisen D2 und D3 (SS24) implementiert.  Auf dem Diagramm sind auch die selbstheilenden Sicherungen F1 und F2 bei 500 mA zu sehen.  Die Signalleitungen des USB-Anschlusses sind durch eine USBLC6-2SC6-Diodenbaugruppe geschützt. <br><br>  Die ST-Link Debugger-Programmer-Schaltung ist vielen bekannt. Sie finden sie in der Dokumentation zu STM32-Discovery-Karten und anderen Quellen.  Für die anfängliche Firmware des ST-Link / J-Link-OB / DAP-Klons (optional) habe ich die Leitungen SWDIO (PA13), SWCLK (PA14), GND herausgebracht.  Viele Leute verwenden UART für Firmware und sind gezwungen, BOOT-Jumper zu ziehen.  Aber SWD ist für mich praktischer, außerdem ermöglicht dieses Protokoll das Debuggen. <br><br>  Fast alle Komponenten der Karte werden mit 3,3 Volt versorgt, die vom Spannungsregler AMS1117-3.3 stammen.  Um elektromagnetische Störungen und Einschaltströme zu unterdrücken, werden LC-Filter von Kondensatoren und Drosseln der BLM31PG-Serie verwendet. <br><br>  Wir sollten auch den Treiber für die 7-Segment-Anzeige MAX7221 erwähnen.  Gemäß der Spezifikation beträgt die empfohlene Stromversorgung 4 bis 5,5 Volt, und der hohe Signalpegel (logische Einheit) beträgt mindestens 3,5 V (0,7 x VCC) bei 5 V Stromversorgung.  Für den Controller K1986BE1QI (avia) entspricht der Ausgang einer logischen Einheit einer Spannung von 2,8 bis 3,3 V.  Offensichtlich gibt es eine Fehlanpassung der Signalpegel, die den normalen Betrieb stören kann.  Ich beschloss, den MAX7221 mit 4 V zu versorgen und die Signalpegel auf 2,8 V (0,7 x 4 = 2,8) zu senken.  Zu diesem Zweck wird die D4-Diode (RS1A oder FR103) in Reihe mit dem Treiberstromversorgungskreis installiert.  Der gesamte Spannungsabfall beträgt 0,9 V (Schottky-Diode 0,3 V und Diode 0,6 V), und alles funktioniert. <br><br>  Die meisten Ports des Mikrocontrollers K1986BE1QI (avia) sind mit Signalen bis 5 V kompatibel.  Der Einsatz des CAN-Transceivers MCP2551, der auch mit 5V betrieben wird, ist daher unproblematisch.  Der MAX3232-Chip ist auf dem Diagramm als RS-232-Transceiver angegeben, aber tatsächlich habe ich SN65C3232D von Texas Instruments verwendet, weil  Es wird mit 3,3 V betrieben und bietet Geschwindigkeiten von bis zu 1 Mbit / s. <br><br>  Auf der Platine befinden sich 4 Quarzresonatoren - einer für den Debugger (8 MHz) und drei für den Ziel-Mikrocontroller K1986BE1QI (avia) mit Werten von 32,768 kHz, 16 MHz, 25 MHz.  Dies sind notwendige Komponenten, wie  Die Parameter des eingebauten RC-Generators liegen in einem weiten Bereich von 6 bis 10 MHz.  Für den Betrieb des integrierten Ethernet-Controllers ist eine Frequenz von 25 MHz erforderlich.  Auf der Seite von Milander (möglicherweise aus Versehen) wird aus irgendeinem Grund darauf hingewiesen, dass sich kein Ethernet im Kunststoffgehäuse befindet.  Aber wir werden uns auf die Spezifikation und die Fakten verlassen. <br><br>  Ein wichtiger Anreiz für die Erstellung einer eigenen Debug-Karte war die Möglichkeit, mit dem externen Systembus EBC (External Bus Controller) zu arbeiten, der im Wesentlichen eine parallele Schnittstelle ist.  Mit dem Mikrocontroller K1986BE1QI (avia) können Sie externe Speicherchips und Peripheriegeräte wie ADC, FPGA usw. anschließen und damit arbeiten.  Die Fähigkeiten des externen Systembusses sind recht groß - Sie können mit statischem 8-Bit-, 16-Bit- und 32-Bit-RAM, ROM und NAND-Flash arbeiten.  Zum Lesen / Schreiben von 32-Bit-Daten kann der Controller automatisch zwei entsprechende Operationen für 16-Bit-Schaltungen und für 8-Bit-4-Operationen ausführen.  Offensichtlich ist eine 32-Bit-E / A-Operation mit dem 32-Bit-Datenbus die schnellste.  Zu den Nachteilen gehört, dass das Programm mit 32-Bit-Daten arbeiten muss und 32 Spuren auf die Platine gelegt werden müssen. <br><br><img src="https://habrastorage.org/webt/oh/sf/n8/ohsfn8vpr98krnms8rohx6l-bjs.jpeg"><br>  <i>Benutzte statische RAM-Chips (rate, welcher defekt ist)</i> <br><br>  Eine ausgewogene Lösung ist die Verwendung von 16-Bit-Speicherchips.  Ich habe Silicon Solutions Inc. integriert.  (ISSI IS61LV25616AL, 16 × 256 k, 10 ns, 3,3 V).  Natürlich verfügt die Firma Milander über eine eigene <a href="https://ic.milandr.ru/products/mikroskhemy_pamyati/" rel="nofollow">Serie von</a> statischen <a href="https://ic.milandr.ru/products/mikroskhemy_pamyati/" rel="nofollow">1645RU-</a> Speicherchips, die jedoch zu teuer und unzugänglich sind.  Alternativ gibt es Samsung K6R4016V1D Pin-kompatibel.  Zuvor erwähnte ich, dass die Mikroschaltungen in Gebrauch waren und die Instanz, die ich ursprünglich installiert hatte, Fehler und chaotische Werte in der 15. Datenleitung aufwies.  Die Suche nach Hardwarefehlern dauerte mehrere Tage. Umso zufriedener war ich, als ich den beschädigten Chip durch einen funktionierenden ersetzte.  Wie dem auch sei, die Geschwindigkeit der Arbeit mit dem externen Speicher lässt zu wünschen übrig. <br><br><div class="spoiler">  <b class="spoiler_title">Externer Bus und StandAlone-Modus</b> <div class="spoiler_text">  Der K1986BE1QI-Mikrocontroller (avia) verfügt über einen einzigartigen StandAlone-Modus, der für den direkten externen Zugriff auf Ethernet- und MKIO-Controller (MIL_STD_1553) über einen externen Bus ausgelegt ist, und der Kern befindet sich in einem Rücksetzzustand, d. H.  Wird nicht benutzt.  Dieser Modus eignet sich für Prozessoren und FPGAs, bei denen kein Ethernet und / oder MKIO vorhanden ist. </div></div><br>  Das Anschlussschema sieht wie folgt aus: <br><br><ul><li>  MCU-Datenbus (D0-D15) =&gt; SRAM (I / O0-I / O15), </li><li>  Adressbus-MCU (A1-A18) =&gt; SRAM (A0-A17), </li><li>  MCU-Steuerung (nWR, nRD, PortC2) =&gt; SRAM (WE, OE, CE), </li><li>  SRAM (UB, LB) angeschlossen oder über einen Widerstand an Masse gezogen. </li></ul><br>  Die CE-Leitung wird über einen Widerstand hochgezogen, die Pins für die MCU-Byteauswahl (BE0-BE3) werden nicht verwendet.  Unter dem Spoiler zitiere ich den Portinitialisierungscode und den externen Buscontroller. <br><br><div class="spoiler">  <b class="spoiler_title">Initialisierung von Ports und EBC-Controller (externer Buscontroller)</b> <div class="spoiler_text"><pre><code class="plaintext hljs">void SRAM_Init (void) { EBC_InitTypeDef EBC_InitStruct = { 0 }; EBC_MemRegionInitTypeDef EBC_MemRegionInitStruct = { 0 }; PORT_InitTypeDef initStruct = { 0 }; RST_CLK_PCLKcmd (RST_CLK_PCLK_EBC, ENABLE); PORT_StructInit (&amp;initStruct); //--------------------------------------------// // DATA PA0..PA15 (D0..D15) // //--------------------------------------------// initStruct.PORT_MODE = PORT_MODE_DIGITAL; initStruct.PORT_PD_SHM = PORT_PD_SHM_ON; initStruct.PORT_SPEED = PORT_SPEED_FAST; initStruct.PORT_FUNC = PORT_FUNC_MAIN; initStruct.PORT_Pin = PORT_Pin_All; PORT_Init (MDR_PORTA, &amp;initStruct); //--------------------------------------------// // Address PF3-PF15 (A0..A12), A0 - not used. // //--------------------------------------------// initStruct.PORT_FUNC = PORT_FUNC_ALTER; initStruct.PORT_Pin = PORT_Pin_4 | PORT_Pin_5 | PORT_Pin_6 | PORT_Pin_7 | PORT_Pin_8 | PORT_Pin_9 | PORT_Pin_10 | PORT_Pin_11 | PORT_Pin_12 | PORT_Pin_13 | PORT_Pin_14 | PORT_Pin_15; PORT_Init (MDR_PORTF, &amp;initStruct); //--------------------------------------------// // Address PD3..PD0 (A13..A16) // //--------------------------------------------// initStruct.PORT_FUNC = PORT_FUNC_OVERRID; initStruct.PORT_Pin = PORT_Pin_0 | PORT_Pin_1 | PORT_Pin_2 | PORT_Pin_3; PORT_Init (MDR_PORTD, &amp;initStruct); //--------------------------------------------// // Address PE3, PE4 (A17, A18) // //--------------------------------------------// initStruct.PORT_FUNC = PORT_FUNC_ALTER; initStruct.PORT_Pin = PORT_Pin_3 | PORT_Pin_4; PORT_Init (MDR_PORTE, &amp;initStruct); //--------------------------------------------// // Control PC0,PC1 (nWE,nOE) // //--------------------------------------------// initStruct.PORT_FUNC = PORT_FUNC_MAIN; initStruct.PORT_Pin = PORT_Pin_0 | PORT_Pin_1; PORT_Init (MDR_PORTC, &amp;initStruct); //--------------------------------------------// // Control PC2 (nCE) // //--------------------------------------------// initStruct.PORT_PD = PORT_PD_DRIVER; initStruct.PORT_OE = PORT_OE_OUT; initStruct.PORT_FUNC = PORT_FUNC_PORT; initStruct.PORT_Pin = MDB_SRAM_CE; PORT_Init (MDR_PORTC, &amp;initStruct); //--------------------------------------------// // Initialize EBC controler // //--------------------------------------------// EBC_DeInit(); EBC_StructInit(&amp;EBC_InitStruct); EBC_InitStruct.EBC_Mode = EBC_MODE_RAM; EBC_InitStruct.EBC_WaitState = EBC_WAIT_STATE_3HCLK; EBC_InitStruct.EBC_DataAlignment = EBC_EBC_DATA_ALIGNMENT_16; EBC_Init(&amp;EBC_InitStruct); EBC_MemRegionStructInit(&amp;EBC_MemRegionInitStruct); EBC_MemRegionInitStruct.WS_Active = 2; EBC_MemRegionInitStruct.WS_Setup = EBC_WS_SETUP_CYCLE_1HCLK; EBC_MemRegionInitStruct.WS_Hold = EBC_WS_HOLD_CYCLE_1HCLK; EBC_MemRegionInitStruct.Enable_Tune = ENABLE; EBC_MemRegionInit (&amp;EBC_MemRegionInitStruct, EBC_MEM_REGION_60000000); EBC_MemRegionCMD(EBC_MEM_REGION_60000000, ENABLE); // Turn ON RAM (nCE) PORT_ResetBits (MDR_PORTC, MDB_SRAM_CE); }</code> </pre> </div></div><br>  Der Mikrocontroller im LQFP-144-Gehäuse und der Speicher im TSOP-44-Gehäuse haben viele verbundene Pins und beanspruchen viel Platz auf der Leiterplatte.  Da ich Erfahrung in der Lösung von Optimierungsproblemen auf wirtschaftlichem Gebiet habe, war es für mich offensichtlich, dass diese Mikroschaltungen an erster Stelle auf der Platine platziert werden mussten.  In verschiedenen Quellen habe ich Lob für <a href="https://www.eremex.ru/products/delta-design/topor/" rel="nofollow">TopoR CAD (Topological Router) gesehen</a> .  Ich habe die Testversion heruntergeladen und konnte mein Projekt dort erst aus Eagle CAD exportieren, als ich fast alle Komponenten gelöscht habe.  Leider haben mir auch 10 Elemente des TopoR-Programms nicht geholfen, mich auf dem Board zu platzieren.  Zuerst wurden alle Komponenten in einer Ecke platziert und dann entlang der Kante platziert.  Diese Option hat mich nicht zufrieden gestellt und ich habe das Board lange Zeit im manuellen Modus in der bekannten Eagle CAD-Umgebung nachverfolgt. <br><br>  Ein wichtiges Element der Leiterplatte ist der Siebdruck.  Die Debug-Karte sollte nicht nur Signaturen für elektronische Komponenten enthalten, sondern alle Anschlüsse sollten signiert sein.  Auf der Rückseite des Boards habe ich Memotabellen mit den Funktionen der Controller-Ports (primär, alternativ, überschrieben, aktuell) platziert.  Ich bestellte die Herstellung von Leiterplatten in China im bekannten Büro von PCBWay.  Ich werde nicht loben, denn die Qualität ist gut.  Sie können es besser machen, mit weniger Toleranzen, aber <a href="https://www.pcbway.com/HighQualityOrderOnline.aspx" rel="nofollow">gegen eine Gebühr</a> . <br><br><img src="https://habrastorage.org/webt/8q/gh/2w/8qgh2wsaofz5p2lat7gcoqc4km4.jpeg"><br>  <i>Hergestellt Leiterplatten MDB1986, (c) Foto vom Autor</i> <br><br>  Ich musste die Komponenten „auf meinem Knie“ mit einem 40-Watt-Lötkolben und POS-61-Lötzinn löten, weil ich es selten ein bis zwei Mal im Jahr löte und die Lötpaste ausgetrocknet war.  Ich musste den chinesischen CS32F103-Controller gegen den ursprünglichen STM32F103 austauschen und dann auch den Speicher austauschen.  Im Allgemeinen gefällt mir das Ergebnis jetzt voll und ganz, obwohl ich die Funktionsweise von RS-232 und CAN noch nicht überprüft habe. <br><br><img src="https://habrastorage.org/webt/-h/il/8v/-hil8vgd1228zqjk7ig090eurpq.jpeg"><br>  <i>Debug Board MDB1986 bei der Arbeit - glänzt und heizt, (c) Foto von</i> <br><br>  Auf der Milandra-Website finden Sie genügend <a href="https://edu.milandr.ru/library/" rel="nofollow">Schulungsmaterialien, um</a> die Controller der 1986BE9-Serie (Cortex-M3-Core) <a href="https://edu.milandr.ru/library/" rel="nofollow">zu studieren</a> , aber ich sehe nichts für den K1986BE1QI-Mikrocontroller (avia).  Nach Durchsicht der dort veröffentlichten Materialien, Handbücher und Laborarbeiten für Universitäten bin ich froh, dass das Personal im ganzen Land für die Arbeit mit russischen Controllern geschult wird.  Die meisten Schulungsunterlagen sind für die Arbeit mit E / A-Anschlüssen, Timern, ADCs, DACs, SPI und UART vorbereitet.  Es werden verschiedene IDE-Entwicklungsumgebungen verwendet (Keil, IAR, CodeMaster).  Irgendwo programmieren sie mit CMSIS-Registern, und irgendwo verwenden sie die MDR-Bibliothek.  Es ist notwendig, die <a href="https://startmilandr.ru/" rel="nofollow">Start Milandr-</a> Ressource zu erwähnen, die viele Artikel von praktischen Programmierern enthält.  Und natürlich sollte man <a href="https://forum.milandr.ru/" rel="nofollow">das Milander-Forum</a> nicht vergessen. <br><br><div class="spoiler">  <b class="spoiler_title">Der Gedanke an Milander</b> <div class="spoiler_text">  Die Mikroelektronik entwickelt sich in Russland und Milander spielt dabei eine herausragende Rolle.  Es gibt neue interessante Mikrocontroller, zum Beispiel 198681 und "Power" mit SpaceWire- und MKIO-Schnittstellen (die gleichen wie 1986BE1 und möglicherweise mit den gleichen Problemen) usw.  Aber gewöhnliche Studenten, Lehrer und Bauingenieure, um solche Chips zu kaufen, ist nicht realistisch.  Die Gemeinschaft der Ingenieure wird daher die Fehler und Probleme dieses Chips nicht schnell erkennen können.  Mir scheint, dass es zunächst notwendig ist, Mikroschaltungen in einem Kunststoffgehäuse herzustellen, an alle Interessenten zu verteilen und erst nach Prüfung (lateinische Approbation, Anerkennung) ein Audit in einem Metall-Keramik-Gehäuse mit Schutz gegen alle schrecklichen Faktoren vorzubereiten.  Ich hoffe, dass wir ALLE in naher Zukunft mit den auf den Messen angekündigten neuen Projekten zufrieden sein werden. </div></div><br>  Jeder, der von mir, dem Debug Board, entwickelt wurde, kann diese wiederholen, modifizieren und im Bildungsprozess verwenden.  Zuallererst habe ich mir ein Board gemacht, aber es ist so gut geworden, dass <a href="https://github.com/makbit/MDB1986" rel="nofollow">ich beschlossen habe, es mit allen zu teilen</a> . <br><br>  K1986BE1QI (avia) ist ein sehr interessanter Controller mit einzigartigen Schnittstellen, die an Universitäten zur Ausbildung von Studenten verwendet werden können.  Ich denke, dass nach der Korrektur der im Controller erkannten Fehler und dem Bestehen der Zertifizierungstests der Controller im wahrsten Sinne des Wortes fliegen wird! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482716/">https://habr.com/ru/post/de482716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482704/index.html">Redis Cache-Synchronisierung für Go-Dienst</a></li>
<li><a href="../de482706/index.html">Empfehlungen zur Implementierung der parallelen Rechnungslegung RAS + IFRS auf der 1C-Plattform</a></li>
<li><a href="../de482708/index.html">Ein Merkmal der Unternehmenskultur, das für das Wohl der Codebasis erforderlich ist</a></li>
<li><a href="../de482712/index.html">Antiquitäten: Sony MZ-1 oder die Geschichte eines Prototyps, der in Produktion ging</a></li>
<li><a href="../de482714/index.html">Die einfachste Internetradio-Kolumne "Kodi" oder die Rettung von "Raspberry" -Backstein</a></li>
<li><a href="../de482718/index.html">Umgekehrte Pyramide als Ende Ihres Projekts</a></li>
<li><a href="../de482722/index.html">Fantastische Geschichte „Projekt C. Eitelkeit der Eitelkeiten“ (10 Min.)</a></li>
<li><a href="../de482726/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 328 (23. - 29. Dezember)</a></li>
<li><a href="../de482728/index.html">JPEG. Kompressionsalgorithmus</a></li>
<li><a href="../de482730/index.html">Feiertagsumfrage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>