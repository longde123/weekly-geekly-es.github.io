<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèéÔ∏è üåå üö• Mapas hexagonales en Unity: guardar y cargar, texturas, distancias ü•õ üíáüèø ‚¨úÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malla, colores y alturas de celda 

 Partes 4-7: baches, r√≠os y caminos 

 Partes 8-11: agua, accidentes geogr√°ficos y murallas 

 Partes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas hexagonales en Unity: guardar y cargar, texturas, distancias</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, r√≠os y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geogr√°ficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigaci√≥n de mapas, generaci√≥n de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 12: guardar y cargar </h1><br><ul><li>  Rastrea el tipo de terreno en lugar del color. </li><li>  Crea un archivo. </li><li>  Escribimos los datos en un archivo y luego los leemos. </li><li>  Nosotros serializamos los datos de la celda. </li><li>  Reduce el tama√±o del archivo. </li></ul><br>  Ya sabemos c√≥mo crear mapas bastante interesantes.  Ahora necesita aprender c√≥mo guardarlos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>Cargado desde el archivo <a href="">test.map</a> .</i> <br><br><h2>  Tipo de terreno </h2><br>  Al guardar un mapa, no necesitamos almacenar todos los datos que rastreamos durante la ejecuci√≥n de la aplicaci√≥n.  Por ejemplo, solo necesitamos recordar el nivel de altura de la celda.  Su posici√≥n vertical en s√≠ se toma de estos datos, por lo que no es necesario almacenarlos.  En realidad, es mejor si no almacenamos estas m√©tricas calculadas.  Por lo tanto, los datos del mapa seguir√°n siendo correctos, incluso si m√°s tarde decidimos cambiar el desplazamiento de altura.  Los datos est√°n separados de su presentaci√≥n. <br><br>  Del mismo modo, no necesitamos almacenar el color exacto de la celda.  Puedes escribir que la celda es verde.  Pero el tono exacto del verde puede cambiar con un cambio en el estilo visual.  Para hacer esto, podemos guardar el √≠ndice de color, no los colores en s√≠.  De hecho, puede ser suficiente para nosotros almacenar este √≠ndice en lugar de colores reales en las celdas en tiempo de ejecuci√≥n.  Esto permitir√° m√°s adelante pasar a una visualizaci√≥n m√°s compleja del relieve. <br><br><h3>  Moviendo una variedad de colores </h3><br>  Si las celdas ya no tienen datos de color, entonces deber√≠an almacenarse en otro lugar.  Es m√°s conveniente almacenarlo en <code>HexMetrics</code> .  As√≠ que agreguemos una variedad de colores. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Al igual que todos los dem√°s datos globales, como el ruido, podemos inicializar estos colores con <code>HexGrid</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; ‚Ä¶ } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  Y como ahora no asignamos colores directamente a las celdas, eliminaremos el color predeterminado. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; ‚Ä¶ void CreateCell (int x, int z, int i) { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; ‚Ä¶ }</span></span></code> </pre> <br>  Establezca los nuevos colores para que coincidan con la matriz general del editor de mapas hexagonales. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Colores a√±adidos a la cuadr√≠cula.</i> <br><br><h3>  Refactorizaci√≥n Celular </h3><br>  Elimine el campo de color de <code>HexCell</code> .  En cambio, almacenaremos el √≠ndice.  En lugar de un √≠ndice de color, usamos un √≠ndice de tipo de relieve m√°s general. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  La propiedad de color puede usar este √≠ndice solo para obtener el color correspondiente.  Ahora no est√° configurado directamente, as√≠ que elimine esta parte.  En este caso, obtenemos un error de compilaci√≥n, que solucionaremos pronto. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // ‚Ä¶ // } }</span></span></code> </pre> <br>  Agregue una nueva propiedad para obtener y establecer un nuevo √≠ndice de tipo de elevaci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Refactorizaci√≥n del editor </h3><br>  Dentro de <code>HexMapEditor</code> todo el c√≥digo con respecto a los colores.  Esto solucionar√° el error de compilaci√≥n. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ // Color activeColor; ‚Ä¶ // bool applyColor; ‚Ä¶ // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } ‚Ä¶ // void Awake () { // SelectColor(0); // } ‚Ä¶ void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } ‚Ä¶ } }</span></span></code> </pre> <br>  Ahora agregue un campo y un m√©todo para controlar el √≠ndice de tipo de elevaci√≥n activo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  Utilizamos este m√©todo como reemplazo del m√©todo <code>SelectColor</code> ahora falta.  Conecte los widgets de color en la interfaz de usuario con <code>SetTerrainTypeIndex</code> , dejando todo lo dem√°s sin cambios.  Esto significa que un √≠ndice negativo todav√≠a est√° en uso y significa que el color no debe cambiar. <br><br>  Cambie <code>EditCell</code> para que el √≠ndice de tipo de elevaci√≥n se asigne a la celda que se est√° editando. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } ‚Ä¶ } }</code> </pre> <br>  Aunque eliminamos los datos de color de las celdas, el mapa deber√≠a funcionar igual que antes.  La √∫nica diferencia es que el color predeterminado ahora es el primero en la matriz.  En mi caso es amarillo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>El amarillo es el nuevo color predeterminado.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Guardar datos en un archivo </h2><br>  Para controlar el guardado y la carga del mapa, utilizamos <code>HexMapEditor</code> .  Crearemos dos m√©todos que har√°n esto, y por ahora los dejaremos vac√≠os. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Agregue dos botones a la IU ( <em>GameObject / UI / Button</em> ).  Con√©ctelos a los botones y asigne las etiquetas apropiadas.  Los puse en la parte inferior del panel derecho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Guardar y cargar botones.</i> <br><br><h3>  Ubicaci√≥n del archivo </h3><br>  Para almacenar una tarjeta, debe guardarla en alg√∫n lugar.  Como se hace en la mayor√≠a de los juegos, almacenaremos datos en un archivo.  Pero, ¬ød√≥nde poner este archivo en el sistema de archivos?  La respuesta depende de en qu√© sistema operativo se est√© ejecutando el juego.  Cada sistema operativo tiene sus propios est√°ndares para almacenar archivos relacionados con aplicaciones. <br><br>  No necesitamos conocer estos est√°ndares.  Unity conoce el camino correcto que podemos obtener con <code>Application.persistentDataPath</code> .  Puede verificar c√≥mo ser√° con usted, en el m√©todo <code>Save</code> , mostr√°ndolo en la consola y presionando el bot√≥n en el modo Reproducir. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  En los sistemas de escritorio, la ruta contendr√° el nombre de la empresa y el producto.  Esta ruta es utilizada tanto por el editor como por el ensamblado.  Los nombres se pueden configurar en <em>Edici√≥n / Configuraci√≥n del proyecto / Reproductor</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Nombre de la empresa y producto.</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© no puedo encontrar la carpeta Biblioteca en Mac?</b> <div class="spoiler_text">  La carpeta <em>Biblioteca a</em> menudo est√° oculta.  La forma en que se puede mostrar depende de la versi√≥n de OS X. Si no tiene una versi√≥n anterior, seleccione la carpeta de inicio en el Finder y vaya a <em>Mostrar opciones de vista</em> .  Hay una casilla de verificaci√≥n para la carpeta <em>Biblioteca</em> . </div></div><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© hay de WebGL?</b> <div class="spoiler_text">  Los juegos de WebGL no pueden acceder al sistema de archivos del usuario.  En cambio, todas las operaciones de archivos se redirigen a un sistema de archivos ubicado en la memoria.  Ella es transparente para nosotros.  Sin embargo, para guardar los datos, deber√° ordenar manualmente la p√°gina web para volcar los datos en el almacenamiento del navegador. </div></div><br><h3>  Creaci√≥n de archivos </h3><br>  Para crear un archivo, necesitamos usar clases del espacio de nombres <code>System.IO</code> .  Por lo tanto, agregamos una declaraci√≥n de <code>using</code> sobre la clase <code>HexMapEditor</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br>  Primero necesitamos crear la ruta completa al archivo.  Usamos <em>test.map</em> como el <em>nombre del</em> archivo.  Debe agregarse a la ruta de los datos almacenados.  Si necesita insertar una barra diagonal inversa o barra diagonal inversa (barra diagonal inversa o barra diagonal inversa) depende de la plataforma.  El m√©todo <code>Path.Combine</code> har√° <code>Path.Combine</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  A continuaci√≥n, necesitamos acceder al archivo en esta ubicaci√≥n.  Hacemos esto usando el m√©todo <code>File.Open</code> .  Dado que queremos escribir datos en este archivo, necesitamos usar su modo de creaci√≥n.  En este caso, se crear√° un nuevo archivo en la ruta especificada o se reemplazar√° un archivo existente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  El resultado de llamar a este m√©todo ser√° un flujo de datos abierto asociado con este archivo.  Podemos usarlo para escribir datos en un archivo.  Y no debemos olvidar cerrar la transmisi√≥n cuando ya no la necesitemos. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  En esta etapa, cuando hace clic en el bot√≥n <em>Guardar</em> , el archivo <em>test.map</em> se crear√° en la carpeta especificada como la ruta a los datos almacenados.  Si estudia este archivo, estar√° vac√≠o y tendr√° un tama√±o de 0 bytes, porque hasta ahora no hemos escrito nada en √©l. <br><br><h3>  Escribir en el archivo </h3><br>  Para escribir datos en un archivo, necesitamos una forma de transmitir datos a √©l.  La forma m√°s f√°cil de hacer esto es con <code>BinaryWriter</code> .  Estos objetos le permiten escribir datos primitivos en cualquier secuencia. <br><br>  Cree un nuevo objeto <code>BinaryWriter</code> , y nuestro flujo de archivos ser√° su argumento.  El escritor de cierre cierra la secuencia que utiliza.  Por lo tanto, ya no necesitamos almacenar un enlace directo a la transmisi√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  Para transferir datos a una secuencia, podemos usar el m√©todo <code>BinaryWriter.Write</code> .  Existe una variante del m√©todo <code>Write</code> para todos los tipos primitivos, como entero y flotante.  Tambi√©n puede grabar l√≠neas.  Tratemos de escribir el entero 123. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Haga clic en el bot√≥n <em>Guardar</em> y examine <em>test.map</em> nuevamente.  Ahora su tama√±o es de 4 bytes, porque el tama√±o entero es de 4 bytes. <br><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© mi administrador de archivos muestra que el archivo ocupa m√°s espacio?</b> <div class="spoiler_text">  Porque los sistemas de archivos dividen el espacio en bloques de bytes.  No rastrean bytes individuales.  Como <em>test.map</em> solo toma cuatro bytes hasta el momento, requiere un bloque de espacio de almacenamiento. </div></div><br>  Tenga en cuenta que almacenamos datos binarios, no textos legibles por humanos.  Por lo tanto, si abrimos el archivo en un editor de texto, veremos un conjunto de caracteres confusos.  Probablemente ver√° el s√≠mbolo <em>{</em> seguido de nada o algunos marcadores de posici√≥n. <br><br>  Puede abrir el archivo en un editor hexadecimal.  En este caso, veremos <em>7b 00 00 00</em> .  Estos son cuatro bytes de nuestro entero, mapeados en notaci√≥n hexadecimal.  En n√∫meros decimales ordinarios, esto es <em>123 0 0 0</em> .  En binario, el primer byte se parece a <em>01111011</em> . <br><br>  El c√≥digo ASCII para <em>{</em> es 123, por lo que este car√°cter se puede mostrar en un editor de texto.  ASCII 0 es un car√°cter nulo que no coincide con ning√∫n car√°cter visible. <br><br>  Los tres bytes restantes son iguales a cero, porque escribimos un n√∫mero menor que 256. Si escribi√©ramos 256, ver√≠amos <em>00 01 00 00</em> en el editor hexadecimal. <br><br><div class="spoiler">  <b class="spoiler_title">¬øNo deber√≠a almacenarse 123 como 00 00 00 7b?</b> <div class="spoiler_text">  <code>BinaryWriter</code> usa el formato little-endian para guardar n√∫meros.  Esto significa que los bytes menos significativos se escriben primero.  Este formato fue utilizado por Microsoft en el desarrollo del marco .Net.  Probablemente fue elegido porque la CPU Intel usa el formato little-endian. <br><br>  Una alternativa a esto es big-endian, en la que los bytes m√°s significativos se almacenan primero.  Esto corresponde al orden habitual de n√∫meros en n√∫meros.  123 es ciento veintitr√©s porque nos referimos al registro big-endian.  Si fuera un little endian, entonces 123 significar√≠a trescientos veintiuno. </div></div><br><h3>  Hacemos recursos gratis </h3><br>  Es importante que cerremos escritor.  Mientras est√° abierto, el sistema de archivos bloquea el archivo, evitando que otros procesos escriban en √©l.  Si olvidamos cerrarlo, tambi√©n nos bloquearemos.  Si presionamos el bot√≥n Guardar dos veces, la segunda vez no podremos abrir la transmisi√≥n. <br><br>  En lugar de cerrar el escritor manualmente, podemos crear un bloque de <code>using</code> para esto.  Define el alcance dentro del cual el escritor es v√°lido.  Cuando el c√≥digo ejecutable va m√°s all√° de este alcance, el escritor se elimina y el hilo se cierra. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  Esto funcionar√° porque las clases de escritor y secuencia de archivos implementan la interfaz <code>IDisposable</code> .  Estos objetos tienen un m√©todo <code>Dispose</code> , que se llama indirectamente cuando van m√°s all√° del alcance del <code>using</code> . <br><br>  La gran ventaja de <code>using</code> es que funciona sin importar c√≥mo se ejecute el programa fuera de alcance.  Las devoluciones anticipadas, las excepciones y los errores no le molestan.  Adem√°s, √©l es muy conciso. <br><br><h3>  Recuperaci√≥n de datos </h3><br>  Para leer datos escritos previamente, necesitamos insertar el c√≥digo en el m√©todo <code>Load</code> .  Como en el caso de guardar, necesitamos crear una ruta y abrir la secuencia del archivo.  La diferencia es que ahora abrimos el archivo para leer, no para escribir.  Y en lugar de escritor necesitamos <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  En este caso, podemos usar el m√©todo <code>File.OpenRead</code> para abrir el archivo para leerlo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© no podemos usar File.OpenWrite al escribir?</b> <div class="spoiler_text">  Este m√©todo crea una secuencia que agrega datos a los archivos existentes, en lugar de reemplazarlos. </div></div><br>  Al leer, debemos indicar expl√≠citamente el tipo de datos recibidos.  Para leer un entero de una secuencia, necesitamos usar <code>BinaryReader.ReadInt32</code> .  Este m√©todo lee un n√∫mero entero de 32 bits, es decir, cuatro bytes. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  Cabe se√±alar que al recibir <em>123,</em> ser√° suficiente para que podamos leer un byte.  Pero al mismo tiempo, tres bytes pertenecientes a este entero permanecer√°n en la secuencia.  Adem√°s, esto no funcionar√° para n√∫meros fuera del intervalo 0‚Äì255.  Por lo tanto, no lo hagas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Escribir y leer datos de mapas </h2><br>  Al guardar datos, una pregunta importante es si se debe usar un formato legible por humanos.  Por lo general, los formatos legibles por humanos son JSON, XML y ASCII simple con alg√∫n tipo de estructura.  Dichos archivos se pueden abrir, interpretar y editar en editores de texto.  Adem√°s, simplifican el intercambio de datos entre diferentes aplicaciones. <br><br>  Sin embargo, dichos formatos tienen sus propios requisitos.  Los archivos ocupar√°n m√°s espacio (a veces mucho m√°s) que el uso de datos binarios.  Tambi√©n pueden aumentar considerablemente el costo de codificar y decodificar datos, tanto en t√©rminos de tiempo de ejecuci√≥n como de huella de memoria. <br><br>  En contraste, los datos binarios son compactos y r√°pidos.  Esto es importante cuando se graban grandes cantidades de datos.  Por ejemplo, al guardar autom√°ticamente un mapa grande en cada turno del juego.  Por lo tanto <br>  Utilizaremos el formato binario.  Si puede manejar esto, puede trabajar con formatos m√°s detallados. <br><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© pasa con la serializaci√≥n autom√°tica?</b> <div class="spoiler_text">  Inmediatamente durante el proceso de serializaci√≥n de datos de Unity, podemos escribir directamente clases serializadas en la secuencia.  Los detalles de la grabaci√≥n de campos individuales ser√°n ocultos para nosotros.  Sin embargo, no podemos serializar directamente las c√©lulas.  Son clases de <code>MonoBehaviour</code> que contienen datos que no necesitamos guardar.  Por lo tanto, necesitamos usar una jerarqu√≠a separada de objetos, lo que destruye la simplicidad de la serializaci√≥n autom√°tica.  Adem√°s, ser√° m√°s dif√≠cil soportar futuros cambios de c√≥digo.  Por lo tanto, mantendremos el control total con la serializaci√≥n manual.  Adem√°s, nos har√° comprender realmente lo que est√° sucediendo. </div></div><br>  Para serializar el mapa, necesitamos almacenar los datos de cada celda.  Para guardar y cargar una sola celda, agregue los m√©todos <code>Save</code> y <code>Load</code> a <code>HexCell</code> .  Como necesitan un escritor o lector para trabajar, los agregaremos como par√°metros. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Agregue los m√©todos <code>Save</code> y <code>Load</code> a <code>HexGrid</code> .  Estos m√©todos simplemente omiten todas las celdas llamando a sus m√©todos <code>Load</code> y <code>Save</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  Si descargamos un mapa, debe actualizarse despu√©s de que se hayan cambiado los datos de la celda.  Para hacer esto, solo actualice todos los fragmentos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Finalmente, reemplazamos nuestro c√≥digo de prueba en <code>HexMapEditor</code> con llamadas a los m√©todos <code>Save</code> and <code>Load</code> de la cuadr√≠cula, pasando el escritor o lector con ellos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Guardar un tipo de relieve </h3><br>  En la etapa actual, volver a guardar crea un archivo vac√≠o, y la descarga no hace nada.  Comencemos gradualmente grabando y cargando solo el √≠ndice de tipo de elevaci√≥n <code>HexCell</code> . <br><br>  Asigne el valor directamente al campo terrenoTypeIndex.  No usaremos propiedades.  Dado que actualizamos expl√≠citamente todos los fragmentos, no se necesitan llamadas a las propiedades de <code>Refresh</code> .  Adem√°s, dado que guardamos solo los mapas correctos, asumiremos que todos los mapas descargados tambi√©n son correctos.  Por lo tanto, por ejemplo, no verificaremos si el r√≠o o la carretera est√°n permitidos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  Al guardar en este archivo, uno tras otro se escribir√° el √≠ndice del tipo de relieve de todas las celdas.  Como el √≠ndice es un entero, su tama√±o es de cuatro bytes.  Mi tarjeta contiene 300 celdas, es decir, el tama√±o del archivo ser√° de 1200 bytes. <br><br>  La carga lee los √≠ndices en el mismo orden en que se escriben.  Si cambi√≥ los colores de las celdas despu√©s de guardar, al cargar el mapa, los colores volver√°n al estado al guardar.  Como ya no guardamos nada, el resto de los datos de la celda permanecer√°n igual.  Es decir, la carga cambiar√° el tipo de terreno, pero no su altura, nivel de agua, caracter√≠sticas del terreno, etc. <br><br><h3>  Guardar todo entero </h3><br>  Guardar un √≠ndice de tipo de alivio no es suficiente para nosotros.  Necesita guardar todos los dem√°s datos.  Comencemos con todos los campos enteros.  Este es un √≠ndice del tipo de relieve, altura de celda, nivel de agua, nivel de ciudad, nivel de granja, nivel de vegetaci√≥n y el √≠ndice de objetos especiales.  Deber√°n leerse en el mismo orden en que se grabaron. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Intente ahora guardar y cargar el mapa, haciendo cambios entre estas operaciones.  Todo lo que incluimos en los datos almacenados se restaur√≥ lo mejor que pudimos, excepto la altura de la celda.  Esto sucedi√≥ porque cuando cambia el nivel de altura, necesita actualizar la posici√≥n vertical de la celda.  Esto se puede hacer asign√°ndole a la propiedad, y no al campo, el valor de la altura cargada.  Pero esta propiedad hace un trabajo adicional que no necesitamos.  Por lo tanto, extraigamos el c√≥digo actualizando la posici√≥n de la celda del <code>RefreshPosition</code> <code>Elevation</code> e insert√°ndolo en un m√©todo <code>RefreshPosition</code> separado.  El √∫nico cambio que necesita hacer aqu√≠ es reemplazar el <code>value</code> referencia al campo de <code>elevation</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Ahora podemos llamar al m√©todo al establecer la propiedad, as√≠ como despu√©s de cargar los datos de altura. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); ‚Ä¶ } } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); ‚Ä¶ }</code> </pre> <br>  Despu√©s de este cambio, las celdas cambiar√°n correctamente su altura aparente al cargar. <br><br><h3>  Guardar todos los datos </h3><br>  La presencia de paredes y r√≠os entrantes / salientes en la celda se almacena en campos booleanos.  Podemos escribirlos simplemente como un n√∫mero entero.  Adem√°s, los datos de carreteras son una matriz de seis valores booleanos que podemos escribir con un bucle. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  Las direcciones de los r√≠os entrantes y salientes se almacenan en los campos de <code>HexDirection</code> .  El tipo <code>HexDirection</code> es una enumeraci√≥n que se almacena internamente como m√∫ltiples valores enteros.  Por lo tanto, tambi√©n podemos serializarlos como un entero utilizando una conversi√≥n expl√≠cita. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Los valores booleanos se leen utilizando el m√©todo <code>BinaryReader.ReadBoolean</code> .  Las direcciones de los r√≠os son enteras, que debemos convertir de nuevo a <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Ahora guardamos todos los datos de celda que son necesarios para el guardado completo y la restauraci√≥n del mapa.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto requiere nueve enteros y nueve valores booleanos por celda. </font><font style="vertical-align: inherit;">Cada valor booleano toma un byte, por lo que utilizamos un total de 45 bytes por celda. </font><font style="vertical-align: inherit;">Es decir, una tarjeta con 300 celdas requiere un total de 13,500 bytes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce el tama√±o del archivo </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque parece que 13,500 bytes no es mucho para 300 celdas, quiz√°s podamos hacerlo con una cantidad menor. </font><font style="vertical-align: inherit;">Al final, tenemos control total sobre c√≥mo se serializan los datos. </font><font style="vertical-align: inherit;">Veamos si hay una forma m√°s compacta de almacenarlos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reducci√≥n de intervalo num√©rico </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los diferentes niveles e √≠ndices celulares se almacenan como un n√∫mero entero. </font><font style="vertical-align: inherit;">Sin embargo, usan solo un peque√±o rango de valores. </font><font style="vertical-align: inherit;">Cada uno de ellos definitivamente permanecer√° en el rango de 0-255. </font><font style="vertical-align: inherit;">Esto significa que solo se usar√° el primer byte de cada entero. </font><font style="vertical-align: inherit;">Los tres restantes siempre ser√°n cero. </font><font style="vertical-align: inherit;">No tiene sentido almacenar estos bytes vac√≠os. </font><font style="vertical-align: inherit;">Podemos descartarlos escribiendo entero a byte antes de escribir en la secuencia.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, para devolver estos n√∫meros, tenemos que usar </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La conversi√≥n de byte a entero se realiza impl√≠citamente, por lo que no necesitamos agregar conversiones expl√≠citas.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces nos deshacemos de tres bytes por entero, lo que ahorra 27 bytes por celda. Ahora gastamos 18 bytes por celda, y solo 5,400 bytes por 300 celdas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale la pena se√±alar que los datos de la tarjeta anterior dejan de tener sentido en esta etapa. Al cargar el antiguo guardado, los datos se mezclan y obtenemos celdas confusas. Esto se debe a que ahora estamos leyendo menos datos. Si leemos m√°s datos que antes, obtendr√≠amos un error al intentar leer m√°s all√° del final del archivo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La incapacidad para procesar datos antiguos nos conviene, porque estamos en el proceso de determinar el formato. </font><font style="vertical-align: inherit;">Pero cuando decidimos el formato de guardado, necesitaremos asegurarnos de que el c√≥digo futuro siempre pueda leerlo. </font><font style="vertical-align: inherit;">Incluso si cambiamos el formato, idealmente a√∫n deber√≠amos poder leer el formato anterior.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> River Byte Union </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, usamos cuatro bytes para almacenar datos del r√≠o, dos por direcci√≥n. </font><font style="vertical-align: inherit;">Para cada direcci√≥n, almacenamos la presencia del r√≠o y la direcci√≥n en la que fluye. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece obvio que no necesitamos almacenar la direcci√≥n del r√≠o si no es as√≠. </font><font style="vertical-align: inherit;">Esto significa que las celdas sin un r√≠o necesitan dos bytes menos. </font><font style="vertical-align: inherit;">De hecho, un byte en la direcci√≥n del r√≠o ser√° suficiente para nosotros, independientemente de su existencia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos seis direcciones posibles, que se almacenan como n√∫meros en el intervalo 0-5. </font><font style="vertical-align: inherit;">Tres bits son suficientes para esto, porque en forma binaria los n√∫meros del 0 al 5 se parecen a 000, 001, 010, 011, 100, 101 y 110. Es decir, un byte m√°s permanece sin usar cinco bits m√°s. </font><font style="vertical-align: inherit;">Podemos usar uno de ellos para indicar si existe un r√≠o. </font><font style="vertical-align: inherit;">Por ejemplo, puede usar el octavo bit, que corresponde al n√∫mero 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para hacer esto, le agregaremos 128 antes de convertir la direcci√≥n en bytes. Es decir, si tenemos un r√≠o que fluye hacia el noroeste, escribiremos 133, que en forma binaria es 10000101. Y si no hay r√≠o, simplemente escribimos un byte cero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al mismo tiempo, cuatro bits m√°s permanecen sin usar, pero esto es normal. </font><font style="vertical-align: inherit;">Podemos combinar ambas direcciones del r√≠o en un byte, pero esto ya ser√° demasiado confuso.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para decodificar los datos del r√≠o, primero tenemos que volver a leer el byte. </font><font style="vertical-align: inherit;">Si su valor no es inferior a 128, esto significa que hay un r√≠o. </font><font style="vertical-align: inherit;">Para obtener su direcci√≥n, resta 128 y luego convierte a </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtuvimos 16 bytes por celda. </font><font style="vertical-align: inherit;">La mejora parece no ser grande, pero este es uno de esos trucos que se utilizan para reducir el tama√±o de los datos binarios.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar carreteras en un byte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar un truco similar para comprimir los datos del camino. </font><font style="vertical-align: inherit;">Tenemos seis valores booleanos que se pueden almacenar en los primeros seis bits de un byte. </font><font style="vertical-align: inherit;">Es decir, cada direcci√≥n de la carretera est√° representada por un n√∫mero que es una potencia de dos. </font><font style="vertical-align: inherit;">Estos son 1, 2, 4, 8, 16 y 32, o en forma binaria 1, 10, 100, 1000, 10000 y 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear un byte terminado, necesitamos establecer los bits que corresponden a las direcciones utilizadas de las carreteras. </font><font style="vertical-align: inherit;">Para obtener la direcci√≥n correcta para la direcci√≥n, podemos usar el operador </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego comb√≠nelos usando el operador OR bit a bit. </font><font style="vertical-align: inherit;">Por ejemplo, si se utilizan las carreteras primera, segunda, tercera y sexta, el byte final ser√° 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funciona &lt;&lt; funciona?</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para recuperar el valor booleano de la carretera, debe verificar si el bit est√° configurado. </font><font style="vertical-align: inherit;">Si es as√≠, enmascare todos los dem√°s bits utilizando el operador AND bit a bit con el n√∫mero apropiado. </font><font style="vertical-align: inherit;">Si el resultado no es igual a cero, se establece el bit y existe el camino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo exprimido seis bytes en uno, recibimos 11 bytes por celda. </font><font style="vertical-align: inherit;">Con 300 celdas, esto es solo 3,300 bytes. </font><font style="vertical-align: inherit;">Es decir, despu√©s de trabajar un poco con bytes, redujimos el tama√±o del archivo en un 75%.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prepar√°ndose para el futuro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de declarar nuestro formato de guardado completo, agregamos un detalle m√°s. </font><font style="vertical-align: inherit;">Antes de guardar los datos del mapa, forzaremos a </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribir un entero cero.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto agregar√° cuatro bytes vac√≠os al comienzo de nuestros datos. </font><font style="vertical-align: inherit;">Es decir, antes de cargar la tarjeta, tenemos que leer estos cuatro bytes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque estos bytes son in√∫tiles hasta ahora, se usan como un encabezado que proporcionar√° compatibilidad con versiones anteriores en el futuro. </font><font style="vertical-align: inherit;">Si no hubi√©ramos agregado estos bytes nulos, entonces el contenido de los primeros bytes depend√≠a de la primera celda del mapa. </font><font style="vertical-align: inherit;">Por lo tanto, en el futuro ser√≠a m√°s dif√≠cil para nosotros averiguar qu√© versi√≥n del formato de guardado estamos tratando. </font><font style="vertical-align: inherit;">Ahora podemos verificar los primeros cuatro bytes. </font><font style="vertical-align: inherit;">Si est√°n vac√≠os, entonces estamos tratando con una versi√≥n de formato 0. En futuras versiones, ser√° posible agregar algo m√°s all√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, si el t√≠tulo no es cero, estamos tratando con alguna versi√≥n desconocida. </font><font style="vertical-align: inherit;">Como no podemos averiguar qu√© datos hay, debemos negarnos a descargar el mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 13: gesti√≥n de tarjetas </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creamos nuevas cartas en el modo Jugar. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue soporte para varios tama√±os de tarjeta. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregue el tama√±o del mapa a los datos guardados. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guarda y carga mapas arbitrarios. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar una lista de tarjetas. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta parte, agregaremos soporte para varios tama√±os de tarjetas, as√≠ como guardaremos diferentes archivos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de esta parte, se crear√°n tutoriales en Unity 5.5.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El comienzo de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> la biblioteca de mapas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear nuevos mapas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta este punto, creamos la cuadr√≠cula hexagonal solo una vez, al cargar la escena. </font><font style="vertical-align: inherit;">Ahora haremos posible comenzar un nuevo mapa en cualquier momento. </font><font style="vertical-align: inherit;">La nueva tarjeta simplemente reemplazar√° a la actual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En Awake </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se inicializan algunas m√©tricas y luego se determina el n√∫mero de celdas y se crean los fragmentos y celdas necesarios. </font><font style="vertical-align: inherit;">Al crear un nuevo conjunto de fragmentos y celdas, creamos un nuevo mapa. </font><font style="vertical-align: inherit;">Divid√°monos </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en dos partes: el c√≥digo fuente de inicializaci√≥n y el m√©todo general </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un bot√≥n en la interfaz de usuario para crear un nuevo mapa. </font><font style="vertical-align: inherit;">Lo hice grande y lo coloqu√© debajo de los botones guardar y cargar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo bot√≥n de mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conectemos el evento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">este bot√≥n con el m√©todo de </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuestro objeto </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es decir, no pasaremos por el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de mapas hexadecimales</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sino que llamaremos directamente al m√©todo de objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuadr√≠cula hexadecimal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un mapa haciendo clic.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Borrar datos antiguos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando hace clic en el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se crear√° un nuevo conjunto de fragmentos y celdas. </font><font style="vertical-align: inherit;">Sin embargo, los antiguos no se eliminan autom√°ticamente. </font><font style="vertical-align: inherit;">Por lo tanto, como resultado, obtenemos varias mallas de mapa superpuestas entre s√≠. </font><font style="vertical-align: inherit;">Para evitar esto, primero tenemos que deshacernos de los objetos viejos. </font><font style="vertical-align: inherit;">Esto se puede hacer destruyendo todos los fragmentos actuales al principio </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPodemos reutilizar objetos existentes?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    ‚Äî    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øEs posible destruir elementos secundarios como este en un bucle?</font></font></b> <div class="spoiler_text">  Por supuesto         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Especifique el tama√±o en celdas en lugar de fragmentos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras establecemos el tama√±o del mapa a trav√©s de los campos </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero ser√° mucho m√°s conveniente indicar el tama√±o del mapa en las celdas. </font><font style="vertical-align: inherit;">Al mismo tiempo, incluso podemos cambiar el tama√±o del fragmento en el futuro sin cambiar el tama√±o de las tarjetas. </font><font style="vertical-align: inherit;">Por lo tanto, cambiemos los roles de la cantidad de celdas y la cantidad de campos de fragmentos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; ‚Ä¶ // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; ‚Ä¶ public void CreateMap () { ‚Ä¶ // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto conducir√° a un error de compilaci√≥n, ya que </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza tama√±os de fragmento </font><font style="vertical-align: inherit;">para limitar su posici√≥n </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cambie </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que use directamente la cantidad de celdas que a√∫n necesita.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fragmento tiene un tama√±o de 5 por 5 celdas, y los mapas por defecto tienen un tama√±o de 4 por 3 fragmentos. </font><font style="vertical-align: inherit;">Por lo tanto, para mantener las tarjetas iguales, tendremos que usar un tama√±o de 20 por 15 celdas. </font><font style="vertical-align: inherit;">Y aunque hemos asignado valores predeterminados en el c√≥digo, el objeto de cuadr√≠cula todav√≠a no los usar√° autom√°ticamente, porque los campos ya exist√≠an y estaban predeterminados a 0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por defecto, la tarjeta tiene un tama√±o de 20 por 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tama√±os de tarjetas personalizados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente paso ser√° el soporte para crear tarjetas de cualquier tama√±o, no solo el tama√±o predeterminado. </font><font style="vertical-align: inherit;">Para hacer esto, agregue </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X y Z </font><font style="vertical-align: inherit;">a los </font><font style="vertical-align: inherit;">par√°metros, que reemplazar√°n el n√∫mero existente de celdas. </font><font style="vertical-align: inherit;">En el interior, los </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamaremos con el n√∫mero actual de celdas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, esto funcionar√° correctamente solo con el n√∫mero de celdas que es un m√∫ltiplo del tama√±o del fragmento. </font><font style="vertical-align: inherit;">De lo contrario, la divisi√≥n entera crear√° muy pocos fragmentos. </font><font style="vertical-align: inherit;">Aunque podemos agregar soporte para fragmentos parcialmente llenos de celdas, proh√≠bamos el uso de tama√±os que no correspondan a fragmentos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar el operador </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para calcular el resto de dividir el n√∫mero de celdas por el n√∫mero de fragmentos. </font><font style="vertical-align: inherit;">Si no es igual a cero, existe una discrepancia y no crearemos un nuevo mapa. </font><font style="vertical-align: inherit;">Y mientras hacemos esto, agreguemos protecci√≥n contra cero y tama√±os negativos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nuevo men√∫ de tarjeta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la etapa actual, el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ya no funciona, porque el m√©todo </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora tiene dos par√°metros. No podemos conectar directamente los eventos de Unity con tales m√©todos. Adem√°s, para admitir diferentes tama√±os de tarjetas, necesitamos algunos botones. En lugar de agregar todos estos botones a la interfaz de usuario principal, creemos un men√∫ emergente separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un nuevo lienzo a la escena ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Utilizaremos la misma configuraci√≥n que el lienzo existente, excepto que su </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orden de clasificaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deber√≠a ser igual a 1. Gracias a esto, estar√° en la parte superior de la interfaz de usuario del editor principal. Hice que tanto el lienzo como el sistema de eventos fueran hijos del nuevo objeto de interfaz de usuario para que la jerarqu√≠a de la escena permanezca limpia.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√∫ de lienzo Nuevo mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un </font><font style="vertical-align: inherit;">panel </font><font style="vertical-align: inherit;">al </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo men√∫ del mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que cierre toda la pantalla. </font><font style="vertical-align: inherit;">Es necesario para oscurecer el fondo y no permitir que el cursor interact√∫e con todo lo dem√°s cuando el men√∫ est√° abierto. </font><font style="vertical-align: inherit;">Le di un color uniforme, borrando su </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen de origen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font><font style="vertical-align: inherit;">configur√© (0, 0, 0, 200) </font><font style="vertical-align: inherit;">como el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuraci√≥n de imagen de fondo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una barra de men√∫ al centro del lienzo, similar a los paneles del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de mapas hexadecimales</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Creemos una etiqueta y botones claros para sus tarjetas peque√±as, medianas y grandes. </font><font style="vertical-align: inherit;">Tambi√©n le agregaremos un bot√≥n de cancelaci√≥n en caso de que el jugador cambie de opini√≥n. </font><font style="vertical-align: inherit;">Una vez que haya terminado de crear el dise√±o, desactive todo el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√∫ Nuevo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo men√∫ de mapa. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para administrar el men√∫, cree un componente </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agr√©guelo al objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo men√∫ del mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del lienzo </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para crear un nuevo mapa, necesitamos acceso al objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por lo tanto, le agregamos un campo com√∫n y lo conectamos.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente del nuevo men√∫ del mapa.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apertura y cierre </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos abrir y cerrar el men√∫ emergente simplemente activando y desactivando el objeto del lienzo. </font><font style="vertical-align: inherit;">Agreguemos </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos m√©todos comunes para hacer esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora conecte el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font><font style="vertical-align: inherit;">del </font><font style="vertical-align: inherit;">editor al m√©todo </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrir el men√∫ presionando. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n conecte el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al m√©todo </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto nos permitir√° abrir y cerrar el men√∫ emergente.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear nuevos mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear nuevos mapas, necesitamos llamar al </font><font style="vertical-align: inherit;">m√©todo </font><font style="vertical-align: inherit;">en el objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Adem√°s, despu√©s de eso, necesitamos cerrar el men√∫ emergente. </font><font style="vertical-align: inherit;">Agregue al </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo que se ocupar√° de esto, teniendo en cuenta un tama√±o arbitrario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo no debe ser general, porque todav√≠a no podemos conectarlo directamente a eventos de bot√≥n. </font><font style="vertical-align: inherit;">En su lugar, cree un m√©todo por bot√≥n que llame </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el tama√±o especificado. </font><font style="vertical-align: inherit;">Para un mapa peque√±o, utilic√© un tama√±o de 20 por 15, correspondiente al tama√±o predeterminado del mapa. </font><font style="vertical-align: inherit;">Para la tarjeta central, decid√≠ duplicar este tama√±o, obteniendo 40 por 30, y duplicarlo nuevamente para la tarjeta grande. </font><font style="vertical-align: inherit;">Conecte los botones con los m√©todos adecuados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloqueo de la c√°mara </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora podemos usar el men√∫ emergente para crear nuevos mapas con tres tama√±os diferentes! Todo funciona bien, pero debemos cuidar algunos detalles. Cuando el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">men√∫ Nuevo mapa est√°</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> activo, ya no podemos interactuar con la interfaz de usuario del editor y editar celdas. Sin embargo, a√∫n podemos controlar la c√°mara. Idealmente, con el men√∫ abierto, la c√°mara deber√≠a bloquearse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como solo tenemos una c√°mara, una soluci√≥n r√°pida y pragm√°tica es simplemente agregarle una propiedad est√°tica </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para un uso generalizado, esta soluci√≥n no es muy adecuada, pero para nuestra interfaz simple es suficiente. Esto requiere que rastreemos la instancia est√°tica en el interior </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se configura cuando la c√°mara Despierta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una propiedad </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede ser una propiedad booleana est√°tica simple solo con un setter. </font><font style="vertical-align: inherit;">Todo lo que hace es apagar la instancia </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando est√° bloqueada y encenderla cuando est√° desbloqueada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede bloquear la c√°mara y </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desbloquearla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mantener la posici√≥n correcta de la c√°mara. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay otro problema probable con la c√°mara. </font><font style="vertical-align: inherit;">Al crear un nuevo mapa que es m√°s peque√±o que el actual, la c√°mara puede aparecer fuera de los bordes del mapa. </font><font style="vertical-align: inherit;">Ella permanecer√° all√≠ hasta que el jugador intente mover la c√°mara. </font><font style="vertical-align: inherit;">Y solo entonces estar√° limitado por los l√≠mites del nuevo mapa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver este problema, podemos agregar al </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo est√°tico </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Llamar a un m√©todo de </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instancia con un desplazamiento cero obligar√° a la c√°mara a moverse a los bordes del mapa. </font><font style="vertical-align: inherit;">Si la c√°mara ya est√° dentro de los bordes del nuevo mapa, permanecer√° en su lugar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Llame al m√©todo dentro </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despu√©s de crear un nuevo mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar tama√±o de mapa </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque podemos crear tarjetas de diferentes tama√±os, no se tiene en cuenta al guardar y cargar. </font><font style="vertical-align: inherit;">Esto significa que cargar un mapa provocar√° un error o un mapa incorrecto si el tama√±o del mapa actual no coincide con el tama√±o del mapa cargado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para resolver este problema, antes de cargar los datos de la celda, necesitamos crear un nuevo mapa del tama√±o apropiado. </font><font style="vertical-align: inherit;">Digamos que tenemos un peque√±o mapa guardado. </font><font style="vertical-align: inherit;">En este caso, todo estar√° bien si creamos </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un mapa de 20 por 15 </font><font style="vertical-align: inherit;">al principio </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tama√±o de la tarjeta de almacenamiento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, podemos almacenar una tarjeta de cualquier tama√±o. </font><font style="vertical-align: inherit;">Por lo tanto, una soluci√≥n generalizada ser√° guardar el tama√±o del mapa frente a estas celdas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entonces podemos obtener el tama√±o verdadero y usarlo para crear un mapa con los tama√±os correctos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ahora podemos cargar mapas de diferentes tama√±os, nuevamente nos enfrentamos con el problema de la posici√≥n de la c√°mara. </font><font style="vertical-align: inherit;">Lo resolveremos verificando su posici√≥n </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">despu√©s de cargar el mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nuevo formato de archivo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque este enfoque funciona con tarjetas que conservaremos en el futuro, no funcionar√° con las antiguas. </font><font style="vertical-align: inherit;">Y viceversa: el c√≥digo de la parte anterior del tutorial no podr√° cargar correctamente nuevos archivos de mapa. </font><font style="vertical-align: inherit;">Para distinguir entre formatos antiguos y nuevos, aumentaremos el valor entero del encabezado. </font><font style="vertical-align: inherit;">El antiguo formato de guardar sin un tama√±o de mapa ten√≠a la versi√≥n 0. El nuevo formato con un tama√±o de mapa tendr√° la versi√≥n 1. Por lo tanto, al grabar, </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe escribir 1 en lugar de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de ahora, las tarjetas se guardar√°n como versi√≥n 1. Si intentamos abrirlas en el ensamblaje del tutorial anterior, se negar√°n a cargar e informar sobre un formato de tarjeta desconocido. </font><font style="vertical-align: inherit;">De hecho, esto suceder√° si ya intentamos cargar dicha tarjeta. </font><font style="vertical-align: inherit;">Debe cambiar el m√©todo </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que acepte la nueva versi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compatibilidad con versiones anteriores </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, si queremos, a√∫n podemos descargar mapas de la versi√≥n 0, suponiendo que todos tengan el mismo tama√±o 20 por 15. Es decir, el t√≠tulo no tiene que ser 1, tambi√©n puede ser cero. </font><font style="vertical-align: inherit;">Como cada versi√≥n requiere su propio enfoque, </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe pasar el encabezado al m√©todo </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√≠tulo </font><font style="vertical-align: inherit;">al </font><font style="vertical-align: inherit;">par√°metro y √∫selo para tomar decisiones sobre acciones adicionales. </font><font style="vertical-align: inherit;">Si el encabezado no es inferior a 1, debe leer los datos del tama√±o de la tarjeta. </font><font style="vertical-align: inherit;">De lo contrario, usamos el tama√±o de tarjeta fija anterior de 20 por 15 y omitimos la lectura de los datos de tama√±o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); ‚Ä¶ }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivo de mapa versi√≥n 0</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificaci√≥n del tama√±o de la tarjeta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con la creaci√≥n de un nuevo mapa, es te√≥ricamente posible que tengamos que cargar un mapa que sea incompatible con el tama√±o del fragmento. </font><font style="vertical-align: inherit;">Cuando esto sucede, debemos interrumpir la descarga de la tarjeta. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya se niega a crear un mapa y muestra un error en la consola. </font><font style="vertical-align: inherit;">Para decirle esto al llamador del m√©todo, regresemos un bool que indique si se cre√≥ el mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tambi√©n puede detener la ejecuci√≥n cuando falla la creaci√≥n del mapa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como la carga sobrescribe todos los datos en las celdas existentes, no necesitamos crear un nuevo mapa si se carga un mapa del mismo tama√±o. </font><font style="vertical-align: inherit;">Por lo tanto, este paso se puede omitir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesti√≥n de archivos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos guardar y cargar tarjetas de diferentes tama√±os, pero siempre escribimos y leemos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ahora agregaremos soporte para diferentes archivos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de guardar o cargar directamente el mapa, utilizamos otro men√∫ emergente que proporciona administraci√≥n avanzada de archivos. </font><font style="vertical-align: inherit;">Cree otro lienzo, como en el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√∫ Nuevo mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero esta vez lo llamaremos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Men√∫ Guardar carga</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este men√∫ guardar√° y cargar√° mapas, dependiendo del bot√≥n presionado para abrirlo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crearemos el dise√±o del </font><em><font style="vertical-align: inherit;">men√∫ Guardar carga</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como si fuera un men√∫ para guardar. M√°s tarde lo convertiremos din√°micamente en un men√∫ de arranque. Al igual que otro men√∫, debe tener un fondo y una barra de men√∫, una etiqueta de men√∫ y un bot√≥n de cancelar. Luego agregue una vista de desplazamiento ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) al men√∫ para mostrar una lista de archivos. A continuaci√≥n, insertamos el campo de entrada ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) para indicar los nombres de las nuevas tarjetas. Tambi√©n necesitamos un bot√≥n de acci√≥n para guardar el mapa. Y finalmente agregue un bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para eliminar tarjetas innecesarias.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dise√±o Guardar Cargar Men√∫.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por defecto, la vista de desplazamiento permite el desplazamiento horizontal y vertical, pero solo necesitamos una lista con desplazamiento vertical. Por lo tanto, desactivar el desplazamiento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y desenchufe la barra de desplazamiento horizontal. Tambi√©n configuramos el </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de movimiento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para bloquear y deshabilitar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inercia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que la lista parezca m√°s restrictiva.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opciones de la lista de archivos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminaremos el elemento secundario </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barra de desplazamiento horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de archivos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque no lo necesitamos. </font><font style="vertical-align: inherit;">Luego, cambie el tama√±o de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barra de desplazamiento vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que </font><em><font style="vertical-align: inherit;">llegue al</font></em><font style="vertical-align: inherit;"> final de la lista. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marcador de posici√≥n objeto de texto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nombre de la entrada</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se puede cambiar en sus hijos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">marcador de posici√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Us√© texto descriptivo, pero puedes dejarlo en blanco y deshacerte del marcador de posici√≥n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se modific√≥ el dise√±o del men√∫. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hemos terminado con el dise√±o y ahora desactivamos el men√∫ para que, por defecto, est√© oculto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gesti√≥n de men√∫ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que el men√∫ funcione, necesitamos otro script, en este caso - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al igual que </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, necesita un enlace a la cuadr√≠cula, as√≠ como m√©todos </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue este componente a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y dele un enlace al objeto de cuadr√≠cula.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se abrir√° un men√∫ para guardar o cargar. </font><font style="vertical-align: inherit;">Para simplificar el trabajo, agregue un </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro booleano </font><font style="vertical-align: inherit;">al m√©todo </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Determina si el men√∫ debe estar en modo guardar. </font><font style="vertical-align: inherit;">Realizaremos un seguimiento de este modo en el campo para saber qu√© acci√≥n realizar m√°s adelante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora combinar los botones </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cargar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objetos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Editor de mapas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con el m√©todo </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar Cargar el men√∫</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Verifique el par√°metro booleano solo para el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrir el men√∫ en modo guardar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si a√∫n no lo ha hecho, conecte el evento del bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al m√©todo </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ahora </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar Cargar men√∫</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede ser abierta y cerrada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambio en la apariencia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos el men√∫ como un men√∫ para guardar, pero su modo est√° determinado por el bot√≥n presionado para abrir. </font><font style="vertical-align: inherit;">Necesitamos cambiar la apariencia del men√∫ dependiendo del modo. </font><font style="vertical-align: inherit;">En particular, necesitamos cambiar la etiqueta del men√∫ y la etiqueta del bot√≥n de acci√≥n. </font><font style="vertical-align: inherit;">Esto significa que necesitaremos enlaces a estas etiquetas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexi√≥n con etiquetas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando el men√∫ se abre en modo guardar, usamos las etiquetas existentes, es decir, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para el men√∫ y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para el bot√≥n de acci√≥n. </font><font style="vertical-align: inherit;">De lo contrario, estamos en modo de carga, es decir, usamos </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ingrese el nombre de la tarjeta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dejemos la lista de archivos por ahora. </font><font style="vertical-align: inherit;">El usuario puede especificar el archivo guardado o descargado ingresando el nombre de la tarjeta en el campo de entrada. </font><font style="vertical-align: inherit;">Para obtener estos datos, necesitamos una referencia al componente </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del objeto de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada de nombre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conexi√≥n al campo de entrada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No es necesario obligar al usuario a ingresar la ruta completa al archivo de mapa. </font><font style="vertical-align: inherit;">Bastar√° solo el nombre de la tarjeta sin la extensi√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Agreguemos un m√©todo que toma la entrada del usuario y crea la ruta correcta para ello. </font><font style="vertical-align: inherit;">Esto no es posible cuando la entrada est√° vac√≠a, por lo que en este caso volveremos </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© sucede si el usuario ingresa caracteres no v√°lidos?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar y cargar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora se dedicar√° a guardar y cargar </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, nos movemos los m√©todos </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ya no tienen que compartirse y funcionar√°n con el par√°metro de ruta en lugar de la ruta fija.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ahora estamos cargando archivos arbitrarios, ser√≠a bueno verificar que el archivo realmente exista, y solo entonces intentar leerlo. </font><font style="vertical-align: inherit;">Si no es as√≠, arrojamos un error y terminamos la operaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora agregue el m√©todo general </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Comienza con la obtenci√≥n de la ruta seleccionada por el usuario. </font><font style="vertical-align: inherit;">Si hay una ruta, gu√°rdela o c√°rguela. </font><font style="vertical-align: inherit;">Luego cierra el men√∫.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al adjuntar un evento de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bot√≥n de acci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a este m√©todo </font><font style="vertical-align: inherit;">, podemos guardar y cargar usando nombres de mapas arbitrarios. </font><font style="vertical-align: inherit;">Como no restablecemos el campo de entrada, el nombre seleccionado permanecer√° hasta el pr√≥ximo guardado o carga. </font><font style="vertical-align: inherit;">Esto es conveniente para guardar o cargar desde un archivo varias veces seguidas, por lo que no cambiaremos nada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Elementos de la lista de mapas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, completaremos la lista de archivos con todas las tarjetas que se encuentran en la ruta de almacenamiento de datos. </font><font style="vertical-align: inherit;">Cuando hace clic en uno de los elementos de la lista, se utilizar√° como texto en la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada de nombre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Agregue un </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo general para esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos algo que sea un elemento de la lista. </font><font style="vertical-align: inherit;">El bot√≥n habitual servir√°. </font><font style="vertical-align: inherit;">Cr√©elo y reduzca la altura a 20 unidades para que no ocupe mucho espacio verticalmente. </font><font style="vertical-align: inherit;">No deber√≠a verse como un bot√≥n, por lo que borraremos el enlace de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen de origen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><font style="vertical-align: inherit;">su componente de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">imagen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En este caso, se volver√° completamente blanco. </font><font style="vertical-align: inherit;">Adem√°s, nos aseguraremos de que la etiqueta est√© alineada a la izquierda y de que haya espacio entre el texto y el lado izquierdo del bot√≥n. </font><font style="vertical-align: inherit;">Habiendo terminado con el dise√±o del bot√≥n, lo convertimos en un prefabricado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El bot√≥n es un elemento de la lista. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podemos conectar directamente el evento del bot√≥n al </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuevo men√∫ del mapa</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque es un prefabricado y a√∫n no existe en la escena. </font><font style="vertical-align: inherit;">Por lo tanto, un elemento de men√∫ necesita un enlace al men√∫ para poder invocar un m√©todo cuando se hace clic en √©l </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambi√©n necesita hacer un seguimiento del nombre de la tarjeta que representa y establecer su texto. </font><font style="vertical-align: inherit;">Vamos a crear un peque√±o componente para esto </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un componente al elemento del men√∫ y haga que el bot√≥n llame a su m√©todo </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Componente del art√≠culo.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relleno de lista </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para completar la lista, </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesita un enlace al </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenido</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dentro de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ventana gr√°fica</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista de archivos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tambi√©n necesita un enlace al elemento prefabricado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezcle el contenido de la lista y prefabricado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizamos un nuevo m√©todo para completar esta lista. </font><font style="vertical-align: inherit;">El primer paso es identificar los archivos de mapas existentes. </font><font style="vertical-align: inherit;">Para obtener una matriz de todas las rutas de archivos dentro del directorio, podemos usar el m√©todo </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo tiene un segundo par√°metro que le permite filtrar archivos. </font><font style="vertical-align: inherit;">En nuestro caso, solo se requieren archivos que coincidan con la m√°scara </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lamentablemente, el orden de los archivos no est√° garantizado. </font><font style="vertical-align: inherit;">Para mostrarlos en orden alfab√©tico, necesitamos ordenar la matriz con </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, crearemos instancias prefabricadas para cada elemento de la matriz. </font><font style="vertical-align: inherit;">Vincula el elemento al men√∫, establece su nombre de mapa y convi√©rtelo en un elemento secundario del contenido de la lista.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve las rutas completas a los archivos, necesitamos borrarlos. </font><font style="vertical-align: inherit;">Afortunadamente, esto es exactamente lo que hace que el m√©todo sea conveniente </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de mostrar el men√∫, necesitamos completar una lista. </font><font style="vertical-align: inherit;">Y dado que es probable que los archivos cambien, debemos hacer esto cada vez que abramos el men√∫.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Al volver a llenar la lista, debemos eliminar todos los anteriores antes de agregar nuevos elementos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art√≠culos sin arreglo.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arreglo de puntos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora la lista mostrar√° elementos, pero se superpondr√°n y estar√°n en una mala posici√≥n. Para convertirlos en una lista vertical, agregue el </font><font style="vertical-align: inherit;">componente </font><em><font style="vertical-align: inherit;">Grupo de dise√±o vertical</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">Componente / Dise√±o / Grupo de dise√±o vertical</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">al objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenido</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font><font style="vertical-align: inherit;">lista </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para que la disposici√≥n funcione correctamente, habilite </font><em><font style="vertical-align: inherit;">Ancho</font></em><font style="vertical-align: inherit;"> del </font><em><font style="vertical-align: inherit;">tama√±o de control secundario</font></em><font style="vertical-align: inherit;"> y </font><em><font style="vertical-align: inherit;">Expandir fuerza secundaria</font></em><font style="vertical-align: inherit;"> . Ambas opciones de </font><em><font style="vertical-align: inherit;">altura</font></em><font style="vertical-align: inherit;"> deben estar deshabilitadas.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de grupo de dise√±o vertical. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos una hermosa lista de art√≠culos. </font><font style="vertical-align: inherit;">Sin embargo, el tama√±o del contenido de la lista no se ajusta al n√∫mero real de elementos. </font><font style="vertical-align: inherit;">Por lo tanto, la barra de desplazamiento nunca cambia de tama√±o. </font><font style="vertical-align: inherit;">Podemos forzar que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cambie de tama√±o autom√°ticamente agregando un componente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component / Layout / Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Su modo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajuste vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> debe establecerse en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tama√±o preferido</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando ajustador de tama√±o de contenido. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora con un peque√±o n√∫mero de puntos, la barra de desplazamiento desaparecer√°. </font><font style="vertical-align: inherit;">Y cuando hay demasiados elementos en la lista que no caben en la ventana gr√°fica, aparece la barra de desplazamiento y tiene un tama√±o apropiado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aparece una barra de desplazamiento.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminaci√≥n de la tarjeta </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos trabajar convenientemente con muchos archivos de mapas. </font><font style="vertical-align: inherit;">Sin embargo, a veces es necesario deshacerse de algunas cartas. </font><font style="vertical-align: inherit;">Para hacer esto, puede usar el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Creemos un m√©todo para esto y hagamos que el bot√≥n lo llame. </font><font style="vertical-align: inherit;">Si hay una ruta seleccionada, simplemente elim√≠nela con </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ tambi√©n deber√≠amos comprobar que estamos trabajando con un archivo realmente existente. </font><font style="vertical-align: inherit;">Si este no es el caso, entonces no deber√≠amos intentar eliminarlo, pero esto no conduce a un error.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de retirar la tarjeta, no necesitamos cerrar el men√∫. </font><font style="vertical-align: inherit;">Esto facilita la eliminaci√≥n de varios archivos a la vez. </font><font style="vertical-align: inherit;">Sin embargo, despu√©s de la eliminaci√≥n, debemos borrar la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entrada de nombre</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as√≠ como actualizar la lista de archivos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 14: texturas en relieve </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Use colores de v√©rtice para crear un mapa splat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear un activo de textura de matriz. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar √≠ndices de elevaci√≥n a las mallas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transiciones entre texturas en relieve. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta este momento, utilizamos colores s√≥lidos para las tarjetas para colorear. </font><font style="vertical-align: inherit;">Ahora aplicaremos la textura.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dibujando texturas.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una mezcla de tres tipos. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si bien los colores uniformes se distinguen claramente y se adaptan bastante a la tarea, no parecen muy interesantes. </font><font style="vertical-align: inherit;">El uso de texturas aumentar√° significativamente el atractivo de los mapas. </font><font style="vertical-align: inherit;">Por supuesto, para esto tenemos que mezclar texturas, no solo colores. </font><font style="vertical-align: inherit;">En el tutorial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3, Combinaci√≥n de texturas,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> habl√© sobre c√≥mo mezclar m√∫ltiples texturas usando el mapa splat. </font><font style="vertical-align: inherit;">En nuestros mapas hexagonales, puede usar un enfoque similar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el tutorial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo se mezclan cuatro texturas, y con un mapa splat podemos admitir hasta cinco texturas. </font><font style="vertical-align: inherit;">Por el momento, utilizamos cinco colores diferentes, por lo que esto es muy adecuado para nosotros. </font><font style="vertical-align: inherit;">Sin embargo, m√°s adelante podemos agregar otros tipos. </font><font style="vertical-align: inherit;">Por lo tanto, se necesita soporte para un n√∫mero arbitrario de tipos de alivio. </font><font style="vertical-align: inherit;">Cuando se utilizan propiedades de textura establecidas expl√≠citamente, esto no es posible, por lo que debe usar una matriz de texturas. </font><font style="vertical-align: inherit;">M√°s tarde lo crearemos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se usan matrices de texturas, de alguna manera necesitamos decirle al sombreador qu√© texturas mezclar. </font><font style="vertical-align: inherit;">La mezcla m√°s dif√≠cil es necesaria para tri√°ngulos angulares, que pueden estar entre tres celdas con su propio tipo de terreno. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos un soporte de mezcla entre los tres tipos por tri√°ngulo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando colores de v√©rtice como mapas Splat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suponiendo que podamos decirte qu√© texturas mezclar, podemos usar los colores de v√©rtice para crear un mapa splat para cada tri√°ngulo. </font><font style="vertical-align: inherit;">Dado que en cada caso se utiliza un m√°ximo de tres texturas, solo necesitamos tres canales de color. </font><font style="vertical-align: inherit;">El rojo representar√° la primera textura, el verde, el segundo, y el azul, el tercero.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa de tri√°ngulo Splat.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øLa suma del mapa triangular splat siempre es igual a uno?</font></font></b> <div class="spoiler_text">  Si         .     . ,        (1, 0, 0)  ,  (¬Ω, ¬Ω, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si un tri√°ngulo necesita solo una textura, usamos solo el primer canal. </font><font style="vertical-align: inherit;">Es decir, su color ser√° completamente rojo. </font><font style="vertical-align: inherit;">En el caso de mezclar entre dos tipos diferentes, usamos el primer y el segundo canal. </font><font style="vertical-align: inherit;">Es decir, el color del tri√°ngulo ser√° una mezcla de rojo y verde. </font><font style="vertical-align: inherit;">Y cuando se encuentren los tres tipos, ser√° una mezcla de rojo, verde y azul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tres configuraciones de mapas splat. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilizaremos estas configuraciones de mapa splat independientemente de qu√© texturas se mezclen realmente. </font><font style="vertical-align: inherit;">Es decir, el mapa splat siempre ser√° el mismo. </font><font style="vertical-align: inherit;">Solo las texturas cambiar√°n. </font><font style="vertical-align: inherit;">C√≥mo hacer esto, lo descubriremos m√°s tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos cambiar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que cree estos mapas splat, en lugar de usar colores de celda. </font><font style="vertical-align: inherit;">Como a menudo usaremos tres colores, crearemos campos est√°ticos para ellos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Centros celulares </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos reemplazando el color del centro de las celdas por defecto. </font><font style="vertical-align: inherit;">Aqu√≠ no se realiza ninguna combinaci√≥n, por lo que solo usamos el primer color, es decir, rojo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Centros rojos de c√©lulas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los centros celulares ahora se vuelven rojos. </font><font style="vertical-align: inherit;">Todos usan la primera de las tres texturas, sin importar cu√°l sea la textura. </font><font style="vertical-align: inherit;">Sus mapas splat son los mismos, independientemente del color con el que coloreamos las celdas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrio del r√≠o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiamos segmentos solo dentro de las celdas sin r√≠os que fluyan a lo largo de ellas. </font><font style="vertical-align: inherit;">Necesitamos hacer lo mismo para los segmentos adyacentes a los r√≠os. </font><font style="vertical-align: inherit;">En nuestro caso, esto es tanto una tira de costilla como un abanico de tri√°ngulos de la costilla. </font><font style="vertical-align: inherit;">Aqu√≠ tambi√©n, solo el rojo es suficiente para nosotros.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmentos rojos adyacentes a los r√≠os.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, debemos cuidar la geometr√≠a de los r√≠os dentro de las celdas. </font><font style="vertical-align: inherit;">Todos ellos tambi√©n deber√≠an ponerse rojos. </font><font style="vertical-align: inherit;">Para empezar, echemos un vistazo al principio y al final de los r√≠os.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y luego la geometr√≠a que compone las orillas y el lecho del r√≠o. </font><font style="vertical-align: inherit;">He agrupado las llamadas al m√©todo de color para que el c√≥digo sea m√°s f√°cil de leer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); ‚Ä¶ }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠os rojos a lo largo de las celdas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costillas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos los bordes son diferentes porque est√°n entre celdas que pueden tener diferentes tipos de terreno. </font><font style="vertical-align: inherit;">Usamos el primer color para el tipo de celda actual y el segundo color para el tipo vecino. </font><font style="vertical-align: inherit;">Como resultado, el mapa splat se convertir√° en un degradado rojo-verde, incluso si ambas celdas son del mismo tipo. </font><font style="vertical-align: inherit;">Si ambas c√©lulas usan la misma textura, entonces se convierte en una mezcla de la misma textura en ambos lados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costillas rojo-verdes, excluidas las repisas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo causar√≠a problemas la transici√≥n brusca entre rojo y verde?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los bordes con las repisas son un poco m√°s complicados porque tienen v√©rtices adicionales. </font><font style="vertical-align: inherit;">Afortunadamente, el c√≥digo de interpolaci√≥n existente funciona muy bien con los colores del mapa splat. </font><font style="vertical-align: inherit;">Simplemente use el primer y segundo color, no los colores de las celdas del principio y el final.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repisas de costillas rojo-verde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ångulos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los √°ngulos celulares son los m√°s dif√≠ciles porque tienen que mezclar tres texturas diferentes. </font><font style="vertical-align: inherit;">Usamos rojo para el pico inferior, verde para la izquierda y azul para la derecha. </font><font style="vertical-align: inherit;">Comencemos con las esquinas de un tri√°ngulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esquinas rojo-verde-azul, excepto las repisas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ podemos usar nuevamente el c√≥digo de interpolaci√≥n de color existente para esquinas con salientes. </font><font style="vertical-align: inherit;">La interpolaci√≥n justa se realiza entre tres, no dos colores. </font><font style="vertical-align: inherit;">Primero, considere las repisas que no est√°n cerca de los acantilados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Columnas de esquina rojo-verde-azul, excepto las repisas a lo largo de los acantilados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se trata de acantilados, necesitamos usar un m√©todo </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo recibi√≥ las celdas de inicio y de izquierda como par√°metros. </font><font style="vertical-align: inherit;">Sin embargo, ahora necesitamos los colores de splat apropiados, que pueden variar seg√∫n la topolog√≠a. </font><font style="vertical-align: inherit;">Por lo tanto, reemplazamos estos par√°metros con colores.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°mbielo </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que use los colores correctos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y haz lo mismo para </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa completo de relieve splat. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Matrices de texturas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que nuestro terreno tiene un mapa splat, podemos pasar la colecci√≥n de texturas al sombreador. </font><font style="vertical-align: inherit;">No podemos simplemente asignar un sombreador a una matriz de texturas de C #, porque la matriz debe existir en la memoria de la GPU como una entidad √∫nica. </font><font style="vertical-align: inherit;">Tendremos que usar un objeto especial </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que haya sido compatible con Unity desde la versi√≥n 5.4.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øTodas las GPU admiten matrices de texturas?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li> PlayStation 4 </li></ul></div></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El maestro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, el soporte de Unity para matrices de texturas en la versi√≥n 5.5 es m√≠nimo. </font><font style="vertical-align: inherit;">No podemos simplemente crear un activo de matriz de textura y asignarle texturas. </font><font style="vertical-align: inherit;">Tenemos que hacerlo manualmente. </font><font style="vertical-align: inherit;">Podemos crear una variedad de texturas en el modo Reproducir o crear un activo en el editor. </font><font style="vertical-align: inherit;">Vamos a crear un activo.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© crear un activo?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear una variedad de texturas, armaremos nuestro propio maestro. </font><font style="vertical-align: inherit;">Cree un script </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y col√≥quelo dentro de la carpeta </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En cambio, </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deber√≠a extender el tipo </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde el espacio de nombres </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos abrir el asistente a trav√©s de un m√©todo est√°tico generalizado </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sus par√°metros son los nombres de la ventana del asistente y su bot√≥n de creaci√≥n. </font><font style="vertical-align: inherit;">Llamaremos a este m√©todo en un m√©todo est√°tico </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para acceder al asistente a trav√©s del editor, necesitamos agregar este m√©todo al men√∫ de Unity. </font><font style="vertical-align: inherit;">Esto se puede hacer agregando un atributo al m√©todo </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A√±√°dalo al men√∫ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y m√°s espec√≠ficamente a los </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activos / Crear / Matriz de texturas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro mago personalizado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el nuevo elemento del men√∫, puede abrir el men√∫ emergente de nuestro asistente personalizado. </font><font style="vertical-align: inherit;">No es muy bonito, pero es adecuado para resolver el problema. </font><font style="vertical-align: inherit;">Sin embargo, todav√≠a est√° vac√≠o. </font><font style="vertical-align: inherit;">Para crear una matriz de texturas, necesitamos una matriz de texturas. </font><font style="vertical-align: inherit;">Agregue un campo general para el maestro. </font><font style="vertical-align: inherit;">La GUI est√°ndar del asistente lo muestra como lo hace un inspector est√°ndar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maestro con texturas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos a crear algo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando hace clic en el bot√≥n </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crear</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del </font><font style="vertical-align: inherit;">asistente, desaparece. </font><font style="vertical-align: inherit;">Adem√°s, Unity se queja de que no hay ning√∫n m√©todo </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es el m√©todo que se llama cuando se hace clic en el bot√≥n Crear, por lo que debemos agregarlo al asistente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqu√≠ crearemos nuestra matriz de texturas. </font><font style="vertical-align: inherit;">Al menos si el usuario agrega texturas al maestro. </font><font style="vertical-align: inherit;">Si no, no hay nada que crear y el trabajo debe detenerse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente paso es solicitar la ubicaci√≥n para guardar el activo de matriz de textura. </font><font style="vertical-align: inherit;">Guarde el archivo del panel puede ser abierto por </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sus par√°metros definen el nombre del panel, el nombre de archivo predeterminado, la extensi√≥n y la descripci√≥n del archivo. </font><font style="vertical-align: inherit;">Las matrices de textura utilizan la extensi√≥n de archivo de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> general </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devuelve la ruta del archivo seleccionado por el usuario. </font><font style="vertical-align: inherit;">Si el usuario hizo clic en cancelar en este panel, la ruta ser√° una cadena vac√≠a. </font><font style="vertical-align: inherit;">Por lo tanto, en este caso, debemos interrumpir el trabajo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear una variedad de texturas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tenemos el camino correcto, podemos avanzar y crear un nuevo objeto </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Su m√©todo de construcci√≥n requiere especificar el ancho y la altura de la textura, la longitud de la matriz, el formato de las texturas y la necesidad de texturas mip. </font><font style="vertical-align: inherit;">Estos par√°metros deben ser los mismos para todas las texturas en la matriz. </font><font style="vertical-align: inherit;">Para configurar el objeto, usamos la primera textura. </font><font style="vertical-align: inherit;">El usuario debe verificar que todas las texturas tengan el mismo formato.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la matriz de textura es un recurso de GPU √∫nico, utiliza los mismos modos de filtrado y plegado para todas las texturas. </font><font style="vertical-align: inherit;">Aqu√≠ nuevamente usamos la primera textura para configurarlo todo.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos copiar la textura de una matriz mediante el m√©todo </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El m√©todo copia datos de textura sin procesar, un nivel de mip a la vez. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos recorrer todas las texturas y sus niveles de mip. </font><font style="vertical-align: inherit;">Los par√°metros del m√©todo son dos conjuntos que consisten en un recurso de textura, un √≠ndice y un nivel mip. </font><font style="vertical-align: inherit;">Como las texturas originales no son matrices, su √≠ndice siempre es cero.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, tenemos en memoria la matriz correcta de texturas, pero a√∫n no es un activo. </font><font style="vertical-align: inherit;">El √∫ltimo paso ser√° llamar </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con la matriz y su ruta. </font><font style="vertical-align: inherit;">En este caso, los datos se escribir√°n en un archivo en nuestro proyecto y aparecer√°n en la ventana del proyecto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { ‚Ä¶ } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Texturas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear una matriz real de texturas, necesitamos las texturas originales. Aqu√≠ hay cinco texturas que coinciden con los colores que usamos hasta ahora. El amarillo se convierte en arena, el verde en hierba, el azul en tierra, el naranja en piedra y el blanco en nieve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texturas de arena, hierba, tierra, piedra y nieve. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenga en cuenta que estas texturas no son fotograf√≠as de este relieve. </font><font style="vertical-align: inherit;">Estos son los patrones pseudoaleatorios f√°ciles que cre√© usando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Me esforc√© por crear tipos de relieve reconocibles y detalles que no entren en conflicto con el relieve poligonal abstracto. </font><font style="vertical-align: inherit;">El fotorrealismo result√≥ ser inadecuado para esto. </font><font style="vertical-align: inherit;">Adem√°s, aunque los patrones agregan variabilidad, hay algunas caracter√≠sticas distintas en ellos que har√≠an que las repeticiones se noten de inmediato. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue estas texturas a la matriz maestra, asegur√°ndose de que su orden coincida con los colores. </font><font style="vertical-align: inherit;">Es decir, primero arena, luego hierba, tierra, piedra y finalmente nieve.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creando una variedad de texturas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de crear el activo de matriz de textura, selecci√≥nelo y exam√≠nelo en el inspector.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspector de matriz de textura.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta es la visualizaci√≥n m√°s simple de una pieza de datos de matriz de textura. Tenga en cuenta que hay un interruptor </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que se enciende inicialmente. Como no necesitamos leer datos de p√≠xeles de la matriz, ap√°guelo. No podemos hacer esto en el asistente porque no </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay m√©todos o propiedades para acceder a este par√°metro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(En Unity 5.6, hay un error que estropea las matrices de texturas en ensamblajes en varias plataformas. Puede evitarlo sin deshabilitar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es legible</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n vale la pena se√±alar que hay un campo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espacio de color</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al cual se le asigna el valor 1. Esto significa que se supone que las texturas est√°n en el espacio gamma, lo cual es cierto. </font><font style="vertical-align: inherit;">Si se supon√≠a que estaban en un espacio lineal, entonces el campo ten√≠a que establecerse en 0. En realidad, el dise√±ador </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene un par√°metro adicional para especificar el espacio de color, pero </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no muestra si est√° en un espacio lineal o no, por lo tanto, en cualquier caso, debe establecer valor de forma manual.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos una variedad de texturas, debemos ense√±arle al sombreador c√≥mo trabajar con ella. </font><font style="vertical-align: inherit;">Por ahora, usamos el sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para representar el terreno </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como ahora usaremos texturas en lugar de colores, c√°mbiele el nombre a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Luego convertimos su par√°metro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en una matriz de texturas y le asignamos un activo.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material en relieve con una variedad de texturas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para habilitar las matrices de texturas en todas las plataformas que las admiten, debe aumentar el nivel de destino del sombreador de 3.0 a 3.5.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la variable </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora se refiere a una matriz de texturas, necesitamos cambiar su tipo. </font><font style="vertical-align: inherit;">El tipo depende de la plataforma de destino y la macro se encargar√° de esto </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en otros sombreadores, para muestrear la textura del relieve necesitamos las coordenadas del mundo XZ. </font><font style="vertical-align: inherit;">Por lo tanto, agregaremos una posici√≥n en el mundo a la estructura de entrada del sombreador de superficie. </font><font style="vertical-align: inherit;">Tambi√©n eliminamos las coordenadas UV predeterminadas, porque no las necesitamos.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para muestrear una variedad de texturas, necesitamos usar una macro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para muestrear una matriz, necesita tres coordenadas. </font><font style="vertical-align: inherit;">Los dos primeros son coordenadas UV normales. </font><font style="vertical-align: inherit;">Utilizaremos las coordenadas mundiales XZ escaladas a 0.02. </font><font style="vertical-align: inherit;">Entonces obtenemos una buena resoluci√≥n de textura con un aumento total. </font><font style="vertical-align: inherit;">Las texturas se repetir√°n aproximadamente cada cuatro celdas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tercera coordenada se usa como el √≠ndice de la matriz de textura, como en una matriz regular. </font><font style="vertical-align: inherit;">Como las coordenadas son flotantes, antes de indexar la matriz de GPU las redondea. </font><font style="vertical-align: inherit;">Como hasta que sepamos qu√© textura se necesita, usemos siempre la primera. </font><font style="vertical-align: inherit;">Adem√°s, el color del v√©rtice no afectar√° el resultado final, porque es un mapa splat.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo se ha convertido en arena. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selecci√≥n de textura </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos un mapa de relieve que combine los tres tipos en un tri√°ngulo. </font><font style="vertical-align: inherit;">Tenemos una variedad de texturas con una textura para cada tipo de terreno. </font><font style="vertical-align: inherit;">Tenemos un sombreador que muestrea una variedad de texturas. </font><font style="vertical-align: inherit;">Pero por ahora, no tenemos forma de decirle al sombreador qu√© texturas elegir para cada tri√°ngulo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como cada tri√°ngulo mezcla hasta tres tipos, necesitamos asociar tres √≠ndices con cada tri√°ngulo. </font><font style="vertical-align: inherit;">No podemos almacenar informaci√≥n para tri√°ngulos, por lo que tenemos que almacenar √≠ndices para v√©rtices. </font><font style="vertical-align: inherit;">Los tres v√©rtices del tri√°ngulo simplemente almacenar√°n los mismos √≠ndices que con el color s√≥lido.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datos de mallas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar uno de los conjuntos de la malla UV para almacenar √≠ndices. </font><font style="vertical-align: inherit;">Como se almacenan tres √≠ndices en cada v√©rtice, los conjuntos de UV 2D existentes no ser√°n suficientes. </font><font style="vertical-align: inherit;">Afortunadamente, los conjuntos UV pueden contener hasta cuatro coordenadas. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos a la </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segunda lista </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a la que nos referiremos como tipos de relieve.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habilite los tipos de terreno para el </font><font style="vertical-align: inherit;">hijo del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> del prefabricado </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos tipos de alivio. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si es necesario, tomaremos otra lista </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para los tipos de relieve durante la limpieza de la malla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el proceso de aplicar los datos de malla, guardamos los tipos de relieve en el tercer conjunto de UV. </font><font style="vertical-align: inherit;">Debido a esto, no entrar√°n en conflicto con otros dos conjuntos, si alguna vez decidimos usarlos juntos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para establecer los tipos de relieve del tri√°ngulo, usaremos </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como los que son iguales para todo el tri√°ngulo, solo agregamos los mismos datos tres veces.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mezclar en quad funciona igual. </font><font style="vertical-align: inherit;">Los cuatro v√©rtices son del mismo tipo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fans de tri√°ngulos de costillas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos agregar tipos a los datos de malla </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos a comenzar con </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, en aras de una mejor legibilidad, separaremos las llamadas a los m√©todos de v√©rtice y color. </font><font style="vertical-align: inherit;">Recuerde que con cada llamada a este m√©todo, se lo pasamos a √©l </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, para que podamos usar este color directamente y no aplicar el par√°metro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de los colores, agregamos tipos de relieve. </font><font style="vertical-align: inherit;">Dado que los tipos en el tri√°ngulo pueden ser diferentes, este deber√≠a ser un par√°metro que reemplace el color. </font><font style="vertical-align: inherit;">Use este tipo simple para crear </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Solo los primeros cuatro canales son importantes para nosotros, porque en este caso el mapa splat siempre es rojo. </font><font style="vertical-align: inherit;">Como los tres componentes del vector deben asignarse, les asignaremos un tipo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos cambiar todas las llamadas a este m√©todo, reemplazando el argumento de color con un √≠ndice del tipo de terreno de la celda. </font><font style="vertical-align: inherit;">Vnesom este cambio </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, cuando inicie el modo de reproducci√≥n, aparecer√°n errores que le informar√°n que los terceros conjuntos de mallas UV est√°n fuera de los l√≠mites. </font><font style="vertical-align: inherit;">Esto sucedi√≥ porque todav√≠a no agregamos tipos de relieve a cada tri√°ngulo y cuadrante. </font><font style="vertical-align: inherit;">Entonces sigamos cambiando </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rayas de la costilla </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, al crear una franja de borde, necesitamos saber qu√© tipos de terreno hay en ambos lados. </font><font style="vertical-align: inherit;">Por lo tanto, los agregamos como par√°metros y luego creamos un vector de tipos a cuyos dos canales se les asignan estos tipos. </font><font style="vertical-align: inherit;">El tercer canal no es importante, por lo que solo hay que compararlo con el primero. </font><font style="vertical-align: inherit;">Despu√©s de agregar los colores, agregue los tipos al quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos cambiar los desaf√≠os </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe usar el tipo de celda para ambos lados de la tira el√°stica.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, el caso m√°s simple de un borde </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe usar el tipo de celda para el borde m√°s cercano y el tipo vecino para el borde lejano. </font><font style="vertical-align: inherit;">Pueden ser iguales o diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo mismo se aplica a lo </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se dispara tres veces </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los tipos para las repisas son los mismos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ångulos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El caso m√°s simple de un √°ngulo es un tri√°ngulo simple. </font><font style="vertical-align: inherit;">La celda inferior transfiere el primer tipo, el izquierdo el segundo y el derecho el tercero. </font><font style="vertical-align: inherit;">Utiliz√°ndolos, cree un vector de tipos y agr√©guelo al tri√°ngulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos el mismo enfoque en </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, solo que aqu√≠ creamos un grupo de quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al mezclar repisas y acantilados, necesitamos usar </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Simplemente dele un par√°metro de tipo vector y agr√©guelo a todos sus tri√°ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crear un vector de tipos basado en las celdas transferidas. </font><font style="vertical-align: inherit;">Luego agr√©galo a un tri√°ngulo y pasa </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo mismo vale para </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √∫ltimo m√©todo para cambiar es este </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como aqu√≠ estamos en el centro de la celda, solo tratamos con el tipo de celda actual. </font><font style="vertical-align: inherit;">Por lo tanto, cree un vector para √©l y agr√©guelo a tri√°ngulos y quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo de mezcla </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta etapa, las mallas contienen los √≠ndices de elevaci√≥n necesarios. </font><font style="vertical-align: inherit;">Todo lo que nos queda es obligar al sombreador del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a </font><font style="vertical-align: inherit;">usarlos. </font><font style="vertical-align: inherit;">Para que los √≠ndices caigan en el sombreador de fragmentos, primero debemos pasarlos a trav√©s del sombreador de v√©rtices. </font><font style="vertical-align: inherit;">Podemos hacer esto en nuestra propia funci√≥n de v√©rtice, como lo hicimos en el sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuario</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">En este caso, agregamos un campo a la estructura de entrada </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y lo copiamos </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> ‚Ä¶ struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos muestrear la matriz de textura tres veces por fragmento. </font><font style="vertical-align: inherit;">Por lo tanto, creemos una funci√≥n conveniente para crear coordenadas de textura, muestrear una matriz y modular una muestra con un mapa splat para un √≠ndice.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPodemos trabajar con un vector como matriz?</font></font></b> <div class="spoiler_text">  Si   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Con esta funci√≥n, podemos simplemente muestrear la matriz de textura tres veces y combinar los resultados. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relieve texturizado. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos pintar el relieve con texturas. </font><font style="vertical-align: inherit;">Se mezclan como los colores s√≥lidos. </font><font style="vertical-align: inherit;">Como utilizamos las coordenadas mundiales como coordenadas UV, no cambian con la altura. </font><font style="vertical-align: inherit;">Como resultado, a lo largo de los acantilados, las texturas se estiran. </font><font style="vertical-align: inherit;">Si las texturas son bastante neutrales y muy variables, los resultados ser√°n aceptables. </font><font style="vertical-align: inherit;">De lo contrario, tenemos grandes estr√≠as feas. </font><font style="vertical-align: inherit;">Puede intentar ocultarlo con geometr√≠a adicional o textura de acantilados, pero en el tutorial no haremos esto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando usemos texturas en lugar de colores, ser√° l√≥gico cambiar el panel del editor. </font><font style="vertical-align: inherit;">Podemos crear una interfaz hermosa que incluso puede mostrar texturas en relieve, pero me centrar√© en las abreviaturas que corresponden al estilo del esquema existente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opciones de socorro. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad de color ya no es necesaria, as√≠ que elim√≠nela.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede eliminar una matriz de colores y c√≥digo asociado.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; ‚Ä¶ void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } ‚Ä¶ ‚Ä¶ void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, tampoco se necesita una variedad de colores </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 15: distancias </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mostrar las l√≠neas de la cuadr√≠cula. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar entre los modos de edici√≥n y navegaci√≥n. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calcule la distancia entre celdas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontramos formas de sortear obst√°culos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tomamos en cuenta los costos variables de la mudanza. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habiendo creado mapas de alta calidad, comenzaremos la navegaci√≥n. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El camino m√°s corto no siempre es recto.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizaci√≥n de cuadr√≠cula </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La navegaci√≥n en el mapa se realiza movi√©ndose de una celda a otra. </font><font style="vertical-align: inherit;">Para llegar a alg√∫n lugar, debe pasar por una serie de celdas. </font><font style="vertical-align: inherit;">Para facilitar la estimaci√≥n de distancias, agreguemos la opci√≥n de mostrar la cuadr√≠cula hexagonal en la que se basa nuestro mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Textura de malla </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de las irregularidades de la malla del mapa, la malla subyacente es perfectamente plana. </font><font style="vertical-align: inherit;">Podemos mostrar esto proyectando un patr√≥n de cuadr√≠cula en un mapa. </font><font style="vertical-align: inherit;">Esto se puede lograr utilizando una textura de malla repetitiva.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repetici√≥n de textura de malla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La textura que se muestra arriba contiene una peque√±a parte de la rejilla hexagonal que cubre 2 por 2 celdas. </font><font style="vertical-align: inherit;">Esta √°rea es rectangular, no cuadrada. </font><font style="vertical-align: inherit;">Dado que la textura en s√≠ es un cuadrado, el patr√≥n se ve estirado. </font><font style="vertical-align: inherit;">Al tomar muestras, debemos compensar esto.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyecci√≥n de cuadr√≠cula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para proyectar un patr√≥n de malla, necesitamos agregar </font><font style="vertical-align: inherit;">una propiedad de textura al </font><font style="vertical-align: inherit;">sombreador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material en relieve con textura de malla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muestra la textura usando las coordenadas XZ del mundo, y luego multipl√≠cala por albedo. </font><font style="vertical-align: inherit;">Dado que las l√≠neas de la cuadr√≠cula en la textura son grises, esto entrelazar√° el patr√≥n en el relieve.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albedo multiplicado por malla fina. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos escalar el patr√≥n para que coincida con las celdas en el mapa. </font><font style="vertical-align: inherit;">La distancia entre los centros de las celdas vecinas es de 15, debe duplicarse para subir dos celdas. </font><font style="vertical-align: inherit;">Es decir, necesitamos dividir las coordenadas de la cuadr√≠cula V entre 30. El radio interno de las celdas es 5‚àö3, y para mover dos celdas a la derecha, necesitamos cuatro veces m√°s. </font><font style="vertical-align: inherit;">Por lo tanto, es necesario dividir las coordenadas de la cuadr√≠cula U por 20‚àö3.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tama√±o de malla correcto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora las l√≠neas de la cuadr√≠cula corresponden a las celdas del mapa. </font><font style="vertical-align: inherit;">Al igual que las texturas en relieve, ignoran la altura, por lo que las l√≠neas se estirar√°n a lo largo de los acantilados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyecci√≥n sobre celdas con altura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deformaci√≥n de la malla generalmente no es tan mala, especialmente cuando se mira un mapa desde una gran distancia.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malla en la distancia.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inclusi√≥n de cuadr√≠cula </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque mostrar una cuadr√≠cula es conveniente, no siempre es obligatorio. </font><font style="vertical-align: inherit;">Por ejemplo, debe desactivarlo cuando tome una captura de pantalla. </font><font style="vertical-align: inherit;">Adem√°s, no todos prefieren ver la cuadr√≠cula constantemente. </font><font style="vertical-align: inherit;">As√≠ que hag√°moslo opcional. </font><font style="vertical-align: inherit;">Agregaremos la directiva multi_compile al sombreador para crear opciones con y sin grilla. </font><font style="vertical-align: inherit;">Para hacer esto, usaremos la palabra clave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La compilaci√≥n del sombreador condicional se describe en el tutorial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5, Luces m√∫ltiples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al declarar una variable, </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero le asignamos un valor de 1. Como resultado, la cuadr√≠cula se desactivar√°. </font><font style="vertical-align: inherit;">Luego, probaremos la textura de la cuadr√≠cula solo para la variante con una palabra clave espec√≠fica </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como la palabra clave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">est√° </font><font style="vertical-align: inherit;">incluida en el sombreador del terreno, la cuadr√≠cula desaparecer√°. </font><font style="vertical-align: inherit;">Para habilitarlo nuevamente, agregaremos un interruptor a la interfaz de usuario del editor de mapas. </font><font style="vertical-align: inherit;">Para que esto sea posible, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debo obtener un enlace al material del </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y un m√©todo para habilitar o deshabilitar la palabra clave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor de hex√°gonos de marzo con referencia al material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un interruptor de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuadr√≠cula</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la interfaz de usuario </font><font style="vertical-align: inherit;">y con√©ctelo al m√©todo </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor de rejilla.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Guardar estado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora en modo Play, podemos cambiar la visualizaci√≥n de la cuadr√≠cula. </font><font style="vertical-align: inherit;">En la primera prueba, la cuadr√≠cula se apaga inicialmente y se vuelve visible cuando activamos el interruptor. </font><font style="vertical-align: inherit;">Cuando lo apaga, la cuadr√≠cula desaparecer√° nuevamente. </font><font style="vertical-align: inherit;">Sin embargo, si salimos del modo Reproducir cuando la cuadr√≠cula est√© visible, la pr√≥xima vez que inicie el modo Reproducir, se volver√° a encender, aunque el interruptor est√© apagado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se debe a que estamos cambiando la palabra clave para el material de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> general </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Estamos editando el activo material, por lo que el cambio se guarda en el editor de Unity. </font><font style="vertical-align: inherit;">No se guardar√° en la asamblea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comenzar siempre el juego sin una grilla, desactivaremos la palabra clave </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Despertar </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modo de edici√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si queremos controlar el movimiento en el mapa, entonces necesitamos interactuar con √©l. </font><font style="vertical-align: inherit;">Como m√≠nimo, debemos seleccionar la celda como punto de partida de la ruta. </font><font style="vertical-align: inherit;">Pero cuando hace clic en una celda, se editar√°. </font><font style="vertical-align: inherit;">Podemos deshabilitar todas las opciones de edici√≥n manualmente, pero esto es inconveniente. </font><font style="vertical-align: inherit;">Adem√°s, no queremos que se realicen c√°lculos de desplazamiento durante la edici√≥n del mapa. </font><font style="vertical-align: inherit;">As√≠ que agreguemos un interruptor que determina si estamos en modo de edici√≥n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Editar interruptor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo booleano </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ como el m√©todo que lo define. </font><font style="vertical-align: inherit;">Luego agregue otro interruptor a la interfaz de usuario para controlarlo. </font><font style="vertical-align: inherit;">Comencemos con el modo de navegaci√≥n, es decir, el modo de edici√≥n estar√° deshabilitado por defecto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor de modo de edici√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para realmente deshabilitar la edici√≥n, haga que la llamada </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependa de </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etiquetas de depuraci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora no tenemos unidades para movernos por el mapa. </font><font style="vertical-align: inherit;">En cambio, visualizamos distancias de movimiento. </font><font style="vertical-align: inherit;">Para hacer esto, puede usar etiquetas de celda existentes. </font><font style="vertical-align: inherit;">Por lo tanto, los haremos visibles cuando el modo de edici√≥n est√© desactivado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como comenzamos con el modo de navegaci√≥n, las etiquetas predeterminadas deber√≠an estar habilitadas. </font><font style="vertical-align: inherit;">Actualmente los </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desactiva, pero ya no deber√≠a hacerlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordinar etiquetas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las coordenadas de celda ahora se hacen visibles inmediatamente despu√©s de iniciar el modo Play. </font><font style="vertical-align: inherit;">Pero no necesitamos coordenadas, usamos etiquetas para mostrar distancias. </font><font style="vertical-align: inherit;">Dado que esto requiere solo un n√∫mero por celda, puede aumentar el tama√±o de la fuente para que puedan leerse mejor. </font><font style="vertical-align: inherit;">Cambie la prefabricaci√≥n de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etiqueta de celda hexadecimal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que use una fuente en negrita con tama√±o 8.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etiquetas con tama√±o de fuente en negrita 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora, despu√©s de iniciar el modo Reproducir, veremos etiquetas grandes. </font><font style="vertical-align: inherit;">Solo las primeras coordenadas de la celda son visibles, el resto no se coloca en la etiqueta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etiquetas grandes </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya no necesitamos las coordenadas, eliminaremos el </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor </font><font style="vertical-align: inherit;">en la </font><font style="vertical-align: inherit;">asignaci√≥n </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n puede eliminar el interruptor de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etiquetas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y su m√©todo asociado </font><font style="vertical-align: inherit;">de la interfaz de usuario </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El cambio de m√©todo ya no existe. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encontrar distancias </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos el modo de navegaci√≥n etiquetado, podemos comenzar a mostrar distancias. </font><font style="vertical-align: inherit;">Seleccionaremos una celda y luego mostraremos la distancia desde esta celda a todas las celdas en el mapa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pantalla de distancia </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para rastrear la distancia a la celda, agregue al </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo entero </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Indicar√° la distancia entre esta celda y la seleccionada. </font><font style="vertical-align: inherit;">Por lo tanto, para la celda seleccionada en s√≠, ser√° cero, para el vecino inmediato es 1, y as√≠ sucesivamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando se establece la distancia, debemos actualizar la etiqueta de la celda para mostrar su valor. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene una referencia al </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto UI. </font><font style="vertical-align: inherit;">Tendremos que llamarlo </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para llegar a la celda. </font><font style="vertical-align: inherit;">Considere lo que </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay en el espacio de nombres </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as√≠ que √∫selo al comienzo del gui√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo deber√≠amos mantener un enlace directo al componente Texto?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Establezcamos la propiedad general para recibir y establezca la distancia a la celda, as√≠ como actualizar su etiqueta. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue al </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo general </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el par√°metro de celda. </font><font style="vertical-align: inherit;">Por ahora, simplemente estableceremos la distancia cero a cada celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el modo de edici√≥n no est√° habilitado, </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamamos a un nuevo m√©todo con la celda actual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Distancias entre coordenadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora en modo de navegaci√≥n, despu√©s de tocar una de ellas, todas las celdas muestran cero. </font><font style="vertical-align: inherit;">Pero, por supuesto, deber√≠an mostrar la verdadera distancia a la celda. </font><font style="vertical-align: inherit;">Para calcular la distancia a ellos, podemos usar las coordenadas de la celda. </font><font style="vertical-align: inherit;">Por lo tanto, suponga que </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene un m√©todo </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y √∫selo </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora agregue al </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Debe comparar sus propias coordenadas con las coordenadas de otro conjunto. </font><font style="vertical-align: inherit;">Comencemos solo midiendo X, y restaremos las coordenadas X entre s√≠.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtenemos un desplazamiento a lo largo de X en relaci√≥n con la celda seleccionada. </font><font style="vertical-align: inherit;">Pero las distancias no pueden ser negativas, por lo que debe devolver la diferencia de coordenadas X m√≥dulo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distancias a lo largo de X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por lo tanto, obtenemos las distancias correctas solo si tenemos en cuenta solo una dimensi√≥n. </font><font style="vertical-align: inherit;">Pero hay tres dimensiones en una cuadr√≠cula de hex√°gonos. </font><font style="vertical-align: inherit;">Entonces, sumemos las distancias para las tres dimensiones y veamos qu√© nos da.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suma de distancias XYZ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que tenemos el doble de distancia. </font><font style="vertical-align: inherit;">Es decir, para obtener la distancia correcta, esta cantidad debe dividirse a la mitad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distancias reales</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© la suma es igual al doble de la distancia?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, ‚àí3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trabajar con obst√°culos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las distancias calculadas por nosotros corresponden a las rutas m√°s cortas desde la celda seleccionada a la celda de cada una. </font><font style="vertical-align: inherit;">No podemos encontrar un camino m√°s corto. </font><font style="vertical-align: inherit;">Pero se garantiza que estos caminos ser√°n correctos si la ruta no bloquea nada. </font><font style="vertical-align: inherit;">Los acantilados, el agua y otros obst√°culos pueden hacernos andar. </font><font style="vertical-align: inherit;">Quiz√°s algunas c√©lulas no se puedan alcanzar en absoluto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para encontrar un camino alrededor de los obst√°culos, necesitamos usar un enfoque diferente en lugar de simplemente calcular la distancia entre las coordenadas. </font><font style="vertical-align: inherit;">Ya no podemos examinar cada celda individualmente. </font><font style="vertical-align: inherit;">Tendremos que buscar en el mapa hasta encontrar todas las celdas a las que se pueda llegar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualizaci√≥n de b√∫squeda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La b√∫squeda de mapas es un proceso iterativo. </font><font style="vertical-align: inherit;">Para entender lo que estamos haciendo, ser√≠a √∫til ver cada etapa de la b√∫squeda. </font><font style="vertical-align: inherit;">Podemos hacer esto convirtiendo el algoritmo de b√∫squeda en una rutina, para lo cual necesitamos un espacio de b√∫squeda </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La frecuencia de actualizaci√≥n de 60 iteraciones por segundo es lo suficientemente peque√±a como para que podamos ver lo que est√° sucediendo, y buscar en un mapa peque√±o no nos llev√≥ demasiado tiempo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debemos asegurarnos de que solo una b√∫squeda est√© activa en un momento dado. </font><font style="vertical-align: inherit;">Por lo tanto, antes de comenzar una nueva b√∫squeda, detenemos todas las corutinas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s, debemos completar la b√∫squeda al cargar un nuevo mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Breadth-First Search </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso antes de comenzar la b√∫squeda, sabemos que la distancia a la celda seleccionada es cero. Y, por supuesto, la distancia a todos sus vecinos es 1, si se puede llegar a ellos. Entonces podemos echar un vistazo a uno de estos vecinos. Es muy probable que esta celda tenga sus propios vecinos a los que se pueda llegar, y para los cuales a√∫n no se ha calculado la distancia. Si es as√≠, la distancia a estos vecinos deber√≠a ser 2. Podemos repetir este proceso para todos los vecinos a una distancia de 1. Despu√©s de eso, lo repetimos para todos los vecinos a una distancia de 2. Y as√≠ sucesivamente, hasta llegar a todas las celdas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es decir, primero encontramos todas las celdas a una distancia de 1, luego encontramos todo a una distancia de 2, luego a una distancia de 3, y as√≠ sucesivamente, hasta que terminemos. </font><font style="vertical-align: inherit;">Esto asegura que encontremos la distancia m√°s peque√±a a cada celda accesible. </font><font style="vertical-align: inherit;">Este algoritmo se llama b√∫squeda de amplitud. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que funcione, necesitamos saber si ya hemos determinado la distancia a la celda. </font><font style="vertical-align: inherit;">A menudo, para esto, las celdas se colocan en una colecci√≥n llamada conjunto listo o cerrado. </font><font style="vertical-align: inherit;">Pero podemos establecer la distancia a la celda </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar que a√∫n no la hemos visitado. </font><font style="vertical-align: inherit;">Necesitamos hacer esto para todas las celdas justo antes de realizar una b√∫squeda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n puede usar esto para ocultar todas las celdas no visitadas cambiando </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Despu√©s de eso, comenzaremos cada b√∫squeda en un mapa en blanco.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, debemos rastrear las celdas que se deben visitar y el orden en que se visitan. </font><font style="vertical-align: inherit;">Tal colecci√≥n a menudo se llama borde o conjunto abierto. </font><font style="vertical-align: inherit;">Solo necesitamos procesar las celdas en el mismo orden en que las conocimos. </font><font style="vertical-align: inherit;">Puede usar una cola para hacer esto </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que es parte del espacio de nombres </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La celda seleccionada ser√° la primera en colocarse en esta cola y tendr√° una distancia de 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A partir de este momento, el algoritmo ejecuta el ciclo mientras hay algo en la cola. </font><font style="vertical-align: inherit;">En cada iteraci√≥n, la celda frontal se recupera de la cola.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos la celda actual, que puede estar a cualquier distancia. </font><font style="vertical-align: inherit;">Luego, necesitamos agregar a todos sus vecinos a la cola un paso m√°s all√° de la celda seleccionada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pero deber√≠amos agregar solo aquellas celdas que a√∫n no han recibido una distancia. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amplia b√∫squeda.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar el agua </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de asegurarnos de que la b√∫squeda de amplitud encuentra las distancias correctas en el mapa mon√≥tono, podemos comenzar a agregar obst√°culos. </font><font style="vertical-align: inherit;">Esto se puede hacer al negarse a agregar celdas a la cola si se cumplen ciertas condiciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, ya omitimos algunas celdas: aquellas que no existen y aquellas a las que ya les hemos indicado la distancia. </font><font style="vertical-align: inherit;">Reescribamos el c√≥digo para que en este caso omitamos a los vecinos expl√≠citamente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omitamos tambi√©n todas las celdas que est√°n debajo del agua. </font><font style="vertical-align: inherit;">Esto significa que cuando buscamos las distancias m√°s cortas, consideramos solo el movimiento en el suelo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distancias sin moverse a trav√©s del agua. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo todav√≠a encuentra las distancias m√°s cortas, pero ahora evita toda el agua. </font><font style="vertical-align: inherit;">Por lo tanto, las c√©lulas submarinas nunca ganan distancia, como √°reas aisladas de tierra. </font><font style="vertical-align: inherit;">La celda submarina solo recibe distancia si est√° seleccionada.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evitar los acantilados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, para determinar la posibilidad de visitar a un vecino, podemos usar el tipo de costilla. </font><font style="vertical-align: inherit;">Por ejemplo, puede hacer que los acantilados bloqueen el camino. </font><font style="vertical-align: inherit;">Si permite el movimiento en pendientes, entonces las celdas en el otro lado del acantilado a√∫n se pueden alcanzar, solo en otros caminos. </font><font style="vertical-align: inherit;">Por lo tanto, pueden estar a distancias muy diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distancias sin cruzar acantilados. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gastos de viaje </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos evitar celdas y bordes, pero estas opciones son binarias. </font><font style="vertical-align: inherit;">Uno puede imaginar que es m√°s f√°cil navegar en algunas direcciones que en otras. </font><font style="vertical-align: inherit;">En este caso, la distancia se mide en trabajo o tiempo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Carreteras r√°pidas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° l√≥gico que sea m√°s f√°cil y r√°pido viajar en carreteras, as√≠ que hagamos que la intersecci√≥n de bordes con carreteras sea menos costosa. </font><font style="vertical-align: inherit;">Dado que usamos valores enteros para establecer la distancia, dejaremos el costo de movernos por las carreteras igual a 1, y el costo de cruzar otros bordes aumentaremos a 10. Esta es una gran diferencia que nos permite ver de inmediato si obtenemos los resultados correctos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos con distancias equivocadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordenaci√≥n de borde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, resulta que la b√∫squeda de amplitud no puede funcionar con costos de mudanza variables. </font><font style="vertical-align: inherit;">√âl supone que las celdas se agregan al borde en el orden de distancia creciente, y para nosotros esto ya no es relevante. </font><font style="vertical-align: inherit;">Necesitamos una cola prioritaria, es decir, una cola que se clasifique a s√≠ misma. </font><font style="vertical-align: inherit;">No hay colas de prioridad est√°ndar, porque no puede programarlas de tal manera que se adapten a todas las situaciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos crear nuestra propia cola prioritaria, pero perm√≠tanos optimizarla para el futuro tutorial. </font><font style="vertical-align: inherit;">Por ahora, simplemente reemplazamos la cola con una lista que tendr√° un m√©todo </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { ‚Ä¶ neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo puedo usar ListPool &lt;HexCell&gt;?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que el borde sea correcto, debemos ordenarlo despu√©s de agregarle una celda. </font><font style="vertical-align: inherit;">De hecho, podemos posponer la clasificaci√≥n hasta que se agreguen todos los vecinos de la celda, pero, repito, hasta que nos interesen las optimizaciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queremos ordenar las celdas por distancia. </font><font style="vertical-align: inherit;">Para hacer esto, debemos llamar al m√©todo de clasificaci√≥n de listas con un enlace al m√©todo que realiza esta comparaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funciona este m√©todo de clasificaci√≥n?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El borde ordenado sigue siendo incorrecto.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Actualizaci√≥n de la frontera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de comenzar a ordenar el borde, comenzamos a obtener mejores resultados, pero todav√≠a hay errores. Esto se debe a que cuando se agrega una celda al borde, no necesariamente encontramos la distancia m√°s corta a esta celda. Esto significa que ahora ya no podemos saltear a los vecinos a los que ya se les ha asignado una distancia. En cambio, debemos verificar si hemos encontrado un camino m√°s corto. Si es as√≠, entonces necesitamos cambiar la distancia al vecino, en lugar de agregarlo al borde.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las distancias correctas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos las distancias correctas, comenzaremos a considerar los costos de mudanza. </font><font style="vertical-align: inherit;">Puede notar que las distancias a algunas celdas son inicialmente demasiado grandes, pero se corrigen cuando se eliminan del borde. </font><font style="vertical-align: inherit;">Este enfoque se llama algoritmo de Dijkstra, lleva el nombre del primero inventado por Edsger Dijkstra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pendientes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No queremos limitarnos a costos diferentes solo para carreteras. </font><font style="vertical-align: inherit;">Por ejemplo, puede reducir el costo de cruzar bordes planos sin carreteras a 5, dejando las pendientes sin carreteras con un valor de 10.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para superar las pendientes necesitas hacer m√°s trabajo, y las carreteras siempre son r√°pidas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Objetos de socorro </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos agregar costos en presencia de objetos en relieve. </font><font style="vertical-align: inherit;">Por ejemplo, en muchos juegos es m√°s dif√≠cil navegar por los bosques. </font><font style="vertical-align: inherit;">En este caso, simplemente agregamos todos los niveles de objetos a la distancia. </font><font style="vertical-align: inherit;">Y aqu√≠ nuevamente el camino acelera todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los objetos se ralentizan si no hay camino.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Las paredes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, tomemos en cuenta las paredes. </font><font style="vertical-align: inherit;">Las paredes deben bloquear el movimiento si el camino no las atraviesa.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las paredes no nos dejan pasar, debes buscar la puerta. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es425919/">https://habr.com/ru/post/es425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es425905/index.html">C√≥mo escribir c√≥digo de ensamblador con instrucciones superpuestas (otra t√©cnica para ofuscar el c√≥digo de bytes)</a></li>
<li><a href="../es425907/index.html">Estamos haciendo un proyecto de aprendizaje autom√°tico en Python. Parte 2</a></li>
<li><a href="../es425911/index.html">Transferir CRM en la nube a la versi√≥n en caja</a></li>
<li><a href="../es425915/index.html">C√≥mo las comunicaciones transfronterizas pueden reemplazar los sem√°foros y acortar el camino al trabajo</a></li>
<li><a href="../es425917/index.html">Justice Fighter evita que Waymo patente la tecnolog√≠a LIDAR clave</a></li>
<li><a href="../es425921/index.html">Reuni√≥n de la comunidad .NET en CLRium # 4 + en l√≠nea</a></li>
<li><a href="../es425923/index.html">Fatalidad de 25 a√±os</a></li>
<li><a href="../es425925/index.html">Impresi√≥n 3D en la creaci√≥n de dise√±os en el ejemplo del STUDIO 911</a></li>
<li><a href="../es425927/index.html">Estaci√≥n meteorol√≥gica en Arduino de la A a la Z. Parte 2</a></li>
<li><a href="../es425929/index.html">Google ha abandonado la lucha por el contrato n√∫mero mil millones del Pent√°gono</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>